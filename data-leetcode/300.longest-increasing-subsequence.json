[
    {
        "title": "Same Tree",
        "question_content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n&nbsp;\nExample 1:\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in both trees is in the range [0, 100].\n\t-104 <= Node.val <= 104",
        "solutions": [
            {
                "id": 32729,
                "title": "shortest-simplest-python",
                "content": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "solutionTags": [
                    "Python"
                ],
                "code": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "codeTag": "Python3"
            },
            {
                "id": 32687,
                "title": "five-line-java-solution-with-recursion",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32685,
                "title": "here-s-a-c-recursion-solution-in-minimal-lines-of-code",
                "content": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "solutionTags": [],
                "code": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3746149,
                "title": "recursive-approach-with-easy-steps",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to recursively check if two binary trees are identical. If both trees are empty (null), they are considered identical. If only one tree is empty or the values of the current nodes are different, the trees are not identical. Otherwise, we recursively check if the left and right subtrees of both trees are identical.\\n\\n# Approach\\n1. Check the base case: if both trees are null, return true.\\n1. Check if only one tree is null or the values of the current nodes are different, return false.\\n1. Recursively check if the left subtrees of both trees are identical.\\n1. Recursively check if the right subtrees of both trees are identical.\\n1. Return the logical AND of the results from steps 3 and 4.\\n\\n Complexity\\n- Time complexity:\\nThe time complexity of the solution is $$O(min(N, M))$$, where N and M are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be O(N).\\n\\n- Space complexity:\\nThe space complexity of the solution is$$O(min(H1, H2))$$, where H1 and H2 are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to O(N) or O(M), depending on which tree is larger.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/779ca60d-af64-404b-8240-038c7cee76af_1689003011.760921.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32894,
                "title": "python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue",
                "content": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 32684,
                "title": "my-non-recursive-method",
                "content": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "solutionTags": [],
                "code": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 826280,
                "title": "recursive-and-iterative-easy-understanding",
                "content": "\\n\\t //iterative\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }\\n              return true;\\n          }\\n      };\\n\\t  \\n    //recursive\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              if(p==nullptr && q==nullptr) return true;\\n              if(p==nullptr || q==nullptr) return false;\\n              if(q->val!=p->val) return false;\\n              return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3027456,
                "title": "c-recursion-one-line-and-iterative-solution-with-explaination",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\nWe well use 2 method to solve this problem\\n1. Recursive method\\n2. Iterative method\\n\\n# Approach\\n# method 1. Recursion\\n1. If one of the node is NULL then return the equality result of p an q.\\n     a. This boils down to if both are NULL then return true, \\n     b. if one of them is NULL but not the other one then return false\\n  \\n2.  At this point both root nodes represent valid pointers(after checking the if condition).\\n    - Return true if the root nodes have same value  (p->val==q->val)\\n    - Recursively check right subtrees of both trees p and q\\n    - Recursively check left subtrees of both trees p and q\\n3. If the left or right subtrees are different, return false \\n\\nHere is image for more clearity\\n![leetcode.png](https://assets.leetcode.com/users/images/09b47818-50d3-40e3-8c4b-05ea129abf09_1673315076.6926653.png)\\n\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(H)H=height of binary tree\\n\\n# Method 2. Iterative solution\\n1. Create a stack and push the roots of both trees onto the stack as pairs.\\n2. While the stack is not empty\\n    - Pop a pair of nodes from the stack.\\n    -  If both nodes are null, continue.\\n    -  If one node is null or the values at the nodes are different, return false.\\n    -  Push the left and right children of both nodes onto the stack as pairs.\\n3. If the loop completes, return true.\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(N)\\n\\n\\n# Code(Recursion)\\n```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\\n# Code(Iterative)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n# [MY LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do better*.\\nLets connect on # [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32935,
                "title": "javascript-solution",
                "content": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607631,
                "title": "javascript-too-easy",
                "content": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027900,
                "title": "java-solution-with-explanation",
                "content": "\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code is checking if two trees are the same by comparing their structure and node values. The function takes in the root nodes of the two trees, p and q, as arguments.\\n\\n2. The function first checks if both trees are null - if they are, then the function returns true, because two null trees are considered to be the same. If only one of the trees is null (and the other isn\\'t), the function returns false, because a tree with nodes is not the same as a null tree.\\n\\n3. If both trees are non-null, the function compares the values of their root nodes. If the values are not the same, the function returns false, because the trees are not the same. If the values are the same, the function recursively calls itself on the left and right children of the two root nodes. The function returns true if the left and right subtrees of both trees are the same, and false otherwise.\\n\\n4. Overall, the function checks the structure and node values of the two trees in a recursive manner, starting from the root nodes and moving down to the leaf nodes. If the structure and values of both trees are the same at every level, the function returns true, indicating that the trees are the same. If any differences are found, the function returns false, indicating that the trees are not the same.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376495,
                "title": "c-solution-recursive-approach",
                "content": "Time complexity - O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```\\nPlease Upvote if you like the solution and comment if have doubts",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32733,
                "title": "simple-java-solution-both-recurison-and-iteration",
                "content": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3027608,
                "title": "python3-dfs-explained-chatgpt-solutions",
                "content": "\\n**Logic:**\\n(1) If both ```p``` and ```q``` are None, we have reched the end on the branches from both trees, so return True.\\n(2) If both nodes are not None, then their values has to be the same, and if so we keep check their left and right nodes.\\n(3) If both nodes are not None, but their values are different, retun False.\\n(4) If one of the node is None and the other one is not, we return False.\\n\\nAs you can see (3) and (4) are just in the else condition from (2). \\n\\n**DFS (Recursive)**\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\\n\\n**DFS (Iterative)** Applying the same logic but using stack.\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\\n\\n**Solution and explination from ChatGPT** (I\\'m sure ChatGPT has seen this question before, and the answer it gives is the same as the offical one)\\n\\nTo check if two binary trees are the same, we can do a pre-order traversal of both trees and compare the nodes at each level. If at any point the nodes are different or one of the trees has no more nodes, we can return false. Otherwise, we can return true.\\n\\nThis function will have a time complexity of O(n) where n is the number of nodes in the tree, since it needs to visit each node exactly once. The space complexity is also O(n) since at worst case the recursive call stack could contain all the nodes in one of the trees.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n**Me: can you do it without recursion?**\\n\\n**ChatGPT:** Yes, it is also possible to implement this function without recursion using an iterative approach. One way to do this is to use a breadth-first search (BFS) to traverse the trees level by level, and compare the nodes at each level.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```\\n\\nFrom what I tested, ChatGPT can only do easy problem if it has never seen it before, and will fail on the medium ones. Note that since the training data for ChatGPT is the data before 2021, so for these harder questions on LeetCode before 2021, ChatGPT can also do it.\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n",
                "solutionTags": [],
                "code": "```p```\n```q```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642761,
                "title": "easy-to-understand-faster-simple-recursive-iterative-dfs-python-solution",
                "content": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3028777,
                "title": "java-without-recursion-100-faster",
                "content": "Upvote if it helps \\u270C\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158580,
                "title": "python-dfs-stack-queue",
                "content": "### 100. Same Tree\\n```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\\n\\n\\u5728\\u6BCF\\u4E00\\u5C42\\u5148\\u68C0\\u67E5\\u518D\\u9012\\u5F52\\uFF0C\\u6240\\u4EE5\\u8FD9\\u662Fpre-order\\u7684\\u601D\\u8DEF\\u3002\\n\\u6BD4\\u5BF9\\u76F8\\u7B49\\u7684\\u6761\\u4EF6\\uFF1A\\n1. `p.val == q.val`\\n2. `if not p or not q: return p == q`\\n\\u5982\\u6709\\u4E0D\\u7B49\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DEFalse\\uFF0C\\u5C31\\u4E0D\\u7528\\u7EE7\\u7EED\\u9012\\u5F52\\u4E86\\u3002\\u6700\\u540E\\u5DE6\\u53F3\\u5B69\\u5B50\\u8FD4\\u56DE\\u7ED9Root\\uFF1A`return left and right`\\n\\n\\np.s. \\u4E0A\\u9762\\u7684\\u7B2C\\u4E8C\\u4E2A\\u76F8\\u7B49\\u6761\\u4EF6\\uFF0C\\u68C0\\u67E5\\u4E862\\u79CD\\u60C5\\u51B5\\uFF1A\\n1.`if not p and not q: return True`\\n2.`if not p or not q: return False`\\n\\n#### DFS\\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\\n\\n#### Stack\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n#### Queue\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32926,
                "title": "2-lines-c-simple-solution-easy-understanding",
                "content": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 733783,
                "title": "python-3-lines-recursion-explained",
                "content": "As it given in problem statement: two binary trees are considered the same if they are structurally identical and the nodes have the same value. So all we need to do is to check this condition recursively:\\n\\nIf we reached node `p` in one tree and `q` in another tree (we allow to reach `None` nodes), we need to consider 3 cases:\\n\\n1. If one of them do not exist and another exist, we return `False`.\\n2. If two of them are equal to `None`, we return `True`.\\n3. If none of two above condition holds, we look at children and return `True` only if values of nodes are equal and if `True` holds for left and right subtrees.\\n\\n**Complexity**: time complexity is `O(n)`, because we traverse all tree. Space complexity is `O(h)` to keep recursion stack. Time complexity can be imporved a bit, if we use helper function and directly return `False` if we found difference between trees. \\n\\n```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32910,
                "title": "python-recursive-solution-within-36ms",
                "content": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "codeTag": "Java"
            },
            {
                "id": 3029585,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\\n\\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32721,
                "title": "2-lines-java-code",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32703,
                "title": "javascript-solution",
                "content": "Nothing fancy, just perform a preorder traversal for both trees at the same pace, simply return `false` whenever we found a mismatch, otherwise continue the traversal on both left and right subtrees.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)` (ignore recursion stack, otherwise the height of the tree)\\n```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724190,
                "title": "python-3-30ms-recursive-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32936,
                "title": "c-solutions-recursively-bfs-queue-dfs-stack",
                "content": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32749,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32916,
                "title": "recursive-non-recursive-recommend-for-beginners-clean-c-implementation",
                "content": "> Non-recursive solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }\\n            return stack_p.size() == stack_q.size();\\n        }\\n    };\\n\\n\\n> Recursive Solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            if(!p && !q)    return true;\\n            if(!p || !q)    return false;\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 463101,
                "title": "c-short-and-easy-o-n-iterative-solution",
                "content": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361737,
                "title": "python3-recursively-and-bfs-and-dfs-iteratively",
                "content": "* recursively\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\\n* DFS iteratively\\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\\n\\n* BFS iteratively\\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028413,
                "title": "funny-one-liner-py",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301998,
                "title": "rust-one-line-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32969,
                "title": "three-lines-java-solution",
                "content": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "solutionTags": [],
                "code": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3028332,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3027467,
                "title": "c-java-c-python-explained-beats-100-0ms",
                "content": "\\n# Appraoch (Recursive)\\n1. If both trees reach their end, then every node in them was checked (return True)\\n1. If one tree ends before the other (return False)\\n2. If a node is different than another (return False)\\n3. Call the function to check the left & right subtrees\\n4. return their conjunction (AND)\\n\\n![image.png](https://assets.leetcode.com/users/images/0c52c091-11e8-46d5-9868-93da969328cf_1673313225.8125043.png)\\n\\n# Explained Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\n# Raw Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\nTime Complexity : $$O(n)$$\\nSpace Complexity : $$O(n)$$\\n![image.png](https://assets.leetcode.com/users/images/5e74b192-b0fc-4ce2-a284-6be226aec420_1673312476.8145483.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508218,
                "title": "c-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32856,
                "title": "3-lines-java-solution",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "codeTag": "Unknown"
            },
            {
                "id": 33026,
                "title": "java-one-liner-and-the-more-readable-solution-it-was-derived-from",
                "content": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "codeTag": "Unknown"
            },
            {
                "id": 2778173,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919297,
                "title": "c-100-faster-100-memory-efficient-easy-code",
                "content": "If one of the tree is NULL, then ans is \\'false\\'\\nIf both the trees are NULL, then ans is \\'true\\'\\n\\n**1. Recursive approach :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn l&r;        \\n\\t\\t}\\n\\t};\\n\\t\\n**2. Iterative approach:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\t//for iterative approach, we generally follow the 4 major steps:\\n\\t\\t\\t//1. Make a queue \\n\\t\\t\\t//2. Push the current Node in the queue (starting from the root node)\\n\\t\\t\\t//3. Process the queue, while its not empty (by adding its left & right child)\\n\\t\\t\\t//4. Once the queue is empty, then alorithm has finished\\n\\n\\t\\t\\t//Step 1\\n\\t\\t\\tqueue<TreeNode*> qu;  \\n\\n\\t\\t\\t//Step 2\\n\\t\\t\\tqu.push(p);\\n\\t\\t\\tqu.push(q);\\n\\n\\t\\t\\t//step 3\\n\\t\\t\\twhile(qu.size() != 0){\\n\\t\\t\\t\\tTreeNode* n1 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tTreeNode* n2 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\n\\t\\t\\t\\t//meet the question conditions\\n\\t\\t\\t\\tif(n1 == NULL && n2 == NULL) continue;\\n\\t\\t\\t\\tif(n1 == NULL || n2 == NULL) return false;\\n\\t\\t\\t\\tif(n1->val != n2->val) return false;\\n\\n\\t\\t\\t\\tqu.push(n1->left);\\n\\t\\t\\t\\tqu.push(n2->left);\\n\\t\\t\\t\\tqu.push(n1->right);\\n\\t\\t\\t\\tqu.push(n2->right);\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//Step 4\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3027471,
                "title": "javascript-simple-video-explanation-dfs",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/37Q-F5qqsXw\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926231,
                "title": "100-fastest-swift-solution-time-o-min-n-m-space-o-min-n-m",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028320,
                "title": "explanation-with-images-clean-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, think from the smallest part. The smallest part or the base case of a tree to consider is when it is null.\\n\\n- If both trees are null, they are the same. So, we will return true.\\n- If one of them is null, then they cannot be equal. So, we will return false.\\n\\n![image.png](https://assets.leetcode.com/users/images/a0233f35-a325-4a35-84d2-6ce2767a81dc_1673326587.6208208.png)\\n\\n- When both nodes are not null, we first need to check if the values are equal. Then we will traverse the left subtree and the right subtree of the both tree sequentially.\\n\\n- Check if `p.val == q.val`:\\n\\n![image.png](https://assets.leetcode.com/users/images/7c934401-4552-40ff-8b3c-d1ad64758202_1673326852.0365388.png)\\n\\n- Recursively call the left and right subtree:\\n\\n- Left Subtree `isSameTree(p.left, q.left)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/a359591a-bcf4-4b46-8e47-3ee1d7c598cc_1673326981.6579647.png)\\n\\n- Right Subtree `isSameTree(p.right, q.right)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/5e6e7bfb-a2e2-4114-8085-9175430c08de_1673327073.0911453.png)\\n\\n\\n- Now, all of these must return true. So, the recursive call should return:\\n\\n`p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)`\\n\\nIf one of them is not true, it will be false. That\\'s why we need the && operation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we visit every node of the tree.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe recursion stack is called n times in worst case. So, it will need $$O(n)$$ memory.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028316,
                "title": "rust-derive-eq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe defination of TreeNode derived the Eq trait so the answer is just use it.\\n\\n# Code\\n```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766257,
                "title": "rust-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Same Tree.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Same Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560321,
                "title": "python-js-go-c-o-n-sol-by-dfs-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/6506b5dbfd89780001901407)\\n\\nO(n) sol by DFS\\n\\n---\\n\\n**Diagram** and **Abstract Model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585824141.png)\\n\\n\\n---\\n\\n\\n**Implementation** by DFS:\\n\\nPython:\\n\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\\n\\n\\n---\\n\\nAnother **Implementation** by BFS :\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```\\n\\n---\\n\\n\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #101 Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)\\n\\n---\\n\\nReference:\\n\\n[Wiki: Pre-order traversal of binary tree](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543621,
                "title": "javascript-recursion-iterative",
                "content": "- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456229,
                "title": "python-recursion-iteration",
                "content": "# Recursion:\\n```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\nRuntime: 24 ms, faster than 95.22% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\n\\n# Iteration:\\none function\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\ntwo function , which is more easy to understand\\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\nRecursion is faster a little \\n\\n**If it helps you , \\nPlease give me a vote star\\nThanls**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432219,
                "title": "python-20ms-beats-99-64",
                "content": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```\\n   \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293440,
                "title": "just-3-lines-of-code-superb-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:----->90%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:---->99%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027571,
                "title": "c-easy-solution",
                "content": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733818,
                "title": "c-simple-one-line-performing-100-time-90-space-recursive-solution-explained",
                "content": "First of all I check if both nodes are `NULL`, in which case I return `true`; if it is `false`, then I move to the right term of my `||` statement as follows.\\n\\nIf at least one of them is not `NULL`, then I make sure that they both are valid (ie: non terminal, non `NULL`) nodes (`p && q`,  I can stop there if see that one is `NULL` and other is not). If that is `true` (both are valid nodes), then I can access their properties without fearing errors and first of all I compare their `val`s; if they match, I progress onwars, calling the function recursively on their `left` and then `right` branches.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nThe kind of sweet problem that you solve in one line, first attempt and that sets your mood for the day (and hopefully the week as well!) - thanks LC :)\\n\\nEdit: now that I posted, I see that actually this solution is giving me consistenly 100% time - title updated!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33022,
                "title": "simple-iterative-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\t//structure\\n    \\t\\tif(p == null || q == null){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t//val\\n    \\t\\tif(p.val != q.val){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tStack<TreeNode> stk1 = new Stack<TreeNode>();\\n    \\t\\tStack<TreeNode> stk2 = new Stack<TreeNode>();\\n    \\t\\tstk1.push(p);\\n    \\t\\tstk2.push(q);\\n    \\t\\t\\n    \\t\\twhile( !stk1.isEmpty() && !stk2.isEmpty() ){\\n    \\t\\t\\tTreeNode tn1 = stk1.pop();\\n    \\t\\t\\tTreeNode tn2 = stk2.pop();\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.val != tn2.val){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t//structure different\\n    \\t\\t\\tif(tn1.left == null && tn2.left != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.left != null && tn2.left == null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right == null && tn2.right != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right != null && tn2.right == null) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.left != null && tn2.left != null){\\n    \\t\\t\\t\\tstk1.push(tn1.left);\\n    \\t\\t\\t\\tstk2.push(tn2.left);\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.right != null && tn2.right != null){\\n    \\t\\t\\t\\tstk1.push(tn1.right);\\n    \\t\\t\\t\\tstk2.push(tn2.right);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1300535,
                "title": "c-3-statements-only-easily-understand-recursion",
                "content": "Here we simply trasverse each node of both the given trees and compare if each of their child is similar with current root. If all of them returns `true` then keep on checking and at any time if we get `false` we return the answer.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```\\n\\u2728 PS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments :slight_smile:. Thanks for reading.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083292,
                "title": "non-recursive-javscript",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557390,
                "title": "c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Same Tree.\\nMemory Usage: 5.3 MB, less than 100.00% of C online submissions for Same Tree.\\n\\n```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32884,
                "title": "oh-java-thou-beauty",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3187804,
                "title": "100-same-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved recursively. We first check if the roots of the two trees are equal. Then we check recursively if the left and right subtrees of the two trees are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the number of nodes in the larger tree.\\n\\n- Space complexity:\\nO(H) where H is the height of the larger tree. In the worst case, the space complexity can be O(N) when the tree is completely unbalanced.\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036465,
                "title": "c-solution-with-video",
                "content": "# Video\\nhttps://youtu.be/m_oZLz8tk8g\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028181,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419286,
                "title": "very-easy-0-ms-100-fully-explained-c-java-python-js-c-python3",
                "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Same Tree.\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 2 ms, faster than 89.56% of C++ online submissions for Same Tree.\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n        \\n# **JavaSript Solution:**\\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726340,
                "title": "100-faster-and-elegant-c-solution",
                "content": "Dear All,\\n\\nPlease find below 100% faster and elegant C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nHope you found this solution useful.\\n\\nThank you and have a good day.\\n\\nBest regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471532,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872029,
                "title": "python3-dfs-easy-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Java"
            },
            {
                "id": 428859,
                "title": "rust-0-ms-iterative-recursive-and-native-solutions",
                "content": "Nobody posted yet an iterative solution for Rust, so here\\'s mine.\\n\\n**Iteration**\\n\\nQuite complex but still 0 ms runtime.\\n\\nBecause of the borrow checker I couldn\\'t push to the queue references to the left and right nodes Options from inside the while loop, so I had to clone the Rcs and wrap them in new Options.\\n\\nDoes anyone have a better solution?\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\\n\\nAnd for reference, much simplifier solutions.\\n\\n**Recursion**\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\\n\\n**Native**\\n\\nRust can compare by itself the structs because of `derive(PartialEq)`. Not very interesting for learning purpose but quite handy in real life situations. :)\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32915,
                "title": "0ms-simple-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }\\n        \\n        if(p==null || q==null) {\\n            return false;\\n        }\\n        \\n        if(p.val == q.val) {\\n            boolean left = isSameTree(p.left, q.left);\\n            boolean right = isSameTree(p.right, q.right);\\n            return (left & right);\\n        }\\n\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33034,
                "title": "my-one-line-recursive-solutions-in-3-languages",
                "content": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Unknown"
            },
            {
                "id": 3483205,
                "title": "easy-bfs",
                "content": "1. The algorithm will look as follows:\\n\\n1. We create a queue, in which we add the root nodes of both trees.\\n\\n1. As long as the queue is not empty, retrieve an element from the beginning of the queue:\\n\\n1. If the elements are null, then move on to the next element in the queue.\\n\\n1. If the node values are not equal, the trees are not identical.\\n\\n1. If the node values are equal, then add the left and right children for both nodes to the queue.\\n\\n1. If all nodes pass the check, then the trees are identical.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030595,
                "title": "python-iterative-solution-visual-explanation",
                "content": "Here is the visual explanation for the iterative version.\\nI\\'m waiting for your comments\\uD83D\\uDCA1\\nThanks for your Upvote\\uD83D\\uDE4F\\n\\nSample 1:\\n![leet code (2).png](https://assets.leetcode.com/users/images/026ba740-aa53-469a-ae64-0b4afd374a30_1673365031.5457146.png)\\n\\n___\\nSample 2:\\n![leet code (1).png](https://assets.leetcode.com/users/images/604e96a3-5e42-455c-8793-dc5ee57da7fc_1673358122.7690244.png)\\n\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028026,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249745,
                "title": "python-dfs-recursion-time-o-n-space-o-n",
                "content": "# Explaination:\\nWe are given two trees and we need to find out if they are the same tree. Meaning they have the same height, same node values in the same places, and same structure.\\n\\nWe will be traversing through both trees at the same exact time and in the same way. Meaning we will check the left side of both trees first to see if they match and then the right side. As we go down the tree we will compare the current node we are at for both trees and see if they have matching values, if at any point they do not match, we return `False`. \\nIf everything matches and we reach `None` when checking the leaf nodes children, if both trees match and they both reach the leaf node and reach the `None` at the same time, we return `True`\\n\\n**Solution Breakdown:**\\n1. We check if either trees `p` or `q` are `None`, if either of them or both of them are, then we return `p == q` to check if they are both `None`, if they are it will return `True` meaning they match, if only one is `None`, we return `False` and say the trees don\\'t match.\\n2. Each time we visit a node we compare the node we are currently visiting on both trees and return `False` if they don\\'t match.\\n3. If they match we check the left and then the right of both trees.\\n4. Then we return `left == right` which means, if all the nodes on the left side for both trees match and all the nodes on the right side for both trees match, we return `True`, if we got `False` on either side of the traversals, we return `False`.\\n\\n**Time O(N) | Space O(N):**\\nTime is O(N) since we need to traverse through all the nodes of both trees, since we are doing it at the same time for both its O(N), since in the worst case both trees match and we visited all nodes to confirm they matched.\\nSpace is O(N) due to the recursive stack and in the worst case we can have an unbalanced tree which will look like a linked list.\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536269,
                "title": "c-0ms-faster-than-100-1-line-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733770,
                "title": "c-easy-to-understand-with-explanation",
                "content": "### Approach 1 - DFS\\nWe have to perform DFS on both the trees simultaneously and at any point if the value is not same we can return false\\n1. If p or q is null - IF both are null return true otherwise return false\\n2. Both are non-null so if p->val != q->val, return false\\n3. perform DFS on left and right children and return true only if both are true otherwise return false (left && right);\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n\\n### Approach 2 - BFS (level order traversal)\\nWe will use a queue for this purpose\\n1. Check if the initial p and q are valid. If not return false.\\n2. insert them in the queue - qu (pair - {p,q})\\n3. while qu is not empty (qu is empty - last level)\\n4. store the current size of q in sz - the elements we have to check in current level\\n5. Perform the checks if both are valid. If not return false.\\n6. If both are valid insert their left and right children as pair in the queue\\n7. Perform the same operation using loop for the level then we go to next level and so on\\n8. If the entire tree is valid the loop ends and return true;\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32784,
                "title": "c-non-recursive-o-1-space-based-on-morris-traversal",
                "content": "Not a fan of recursive. Stack space is also space, otherwise we wouldn't have the \"STACKOVERFLOW\".\\n```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32947,
                "title": "two-line-java-code",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3672457,
                "title": "easy-approach-2-lines-inorder-traversal-beats-100",
                "content": "# Intuition \\uD83D\\uDCA1\\nTo determine if two binary trees are the same, we can compare their nodes recursively. If the current nodes have the same value and the left and right subtrees are also the same, then the trees are considered the same.\\n\\n# Approach \\uD83D\\uDD0D\\nHere is the step-by-step approach to solve the problem:\\n\\n1. Write a recursive function `isSameTree` that takes two parameters, `p` and `q`, representing the root nodes of the two binary trees.\\n2. Check if either `p` or `q` is null. If one is null and the other is not, return false since they cannot be the same.\\n3. Check if the values of the current nodes, `p.val` and `q.val`, are equal.\\n4. Recursively call the `isSameTree` function on the left subtrees, `p.left` and `q.left`.\\n5. Recursively call the `isSameTree` function on the right subtrees, `p.right` and `q.right`.\\n6. Return the logical AND of all the conditions checked above.\\n\\n> Feel free to post your doubts in the commen section :) \\n# Code \\nThe Java code implementing the above approach is as follows:\\n\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3532284,
                "title": "c-dfs-beats-92-100",
                "content": "# Intuition\\nTraversing branches by recursion\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029302,
                "title": "clear-and-concise-recursive-solution",
                "content": "Sorry for the lambda syntax, but I could not resist using it:\\n```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028873,
                "title": "simple-recursive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto check if the two trees are same we need to make sure that value at each node is same.That is we can check each node at a time via recursion\\n\\n# Approach\\n   passing each node recursively and if their value are not same i return false, i fthey are same we pass one call to check the left subtree and then another call to check the same for right subtree and return true if both left and right are true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlet the height of the tree be h=log(n) (approximately)\\nso the time copmplexity of the above code is O(2^h) since at each level we have two options put h=log(n) we get the time complexity to be O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhere the space complexity is O(h) that is O(log(n)) and this space is due to the recursive stack space in the compiler if we do not consider the recurasive stack space then space complexity is O(1).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028868,
                "title": "c-solution-100-faster-simple-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n__The Idea is to match all the nodes of one tree with the other one, and whenever there is no match possible, return false__\\n\\n# Approach\\n__The idea her is to recursive map nodes of one tree with the nodes of the other tree__\\n\\n>__Check if the nodes reach null together (base case),__ \\n  If yes, return true\\n  Else, execute other statements \\n\\n>__Check if only either of the nodes reach an end point__\\n If yes, Return false\\n Else, execute other statements\\n\\n>__If the nodes are not the end points, check if the values they are storing are same or not?__\\nIf different, return false\\nElse, continue with the code\\n\\n>Recursive structure: \\n__[match the left subtree of the current node with the left subtree of the other current node]__\\n__&&  (logical operator)__\\n__[match the right subtree of the current node with the right subtree of the other current node]__\\n\\n# Complexity\\n- Time complexity:\\nO(N) :- N => Number of nodes in the tree\\n\\n- Space complexity:\\nO(1), ignoring the recursive stack, otherwise the space = O(N)\\n\\n# Code\\n```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027524,
                "title": "java-solution-with-explanation-beat-100",
                "content": "# Intuition\\nIf tree is same it must have nodes with same value at same place\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using recursion to solve this problem \\n1)if p is null and q is null then it\\'s same we will return true\\n2)if any of p or q is null then we will return false\\n3) if value of p and q is not same then it\\'s not same tree so we will return false\\nNow check for above cases for left subtree and right subtree and if we get false we will return false otherwise the trees are same\\n\\n# Complexity\\n- Time complexity:\\nO(min(N, M)), Where N and M are the sizes of the trees\\n\\n- Space complexity:\\n O(log min(N, M)), due to auxiliary stack space used by recursion calls\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```\\n\\nI hope you guys understand the solution,Keep coding.\\n\\nJai Shree Krishna\\u2764\\uFE0F\\uD83D\\uDE4F....",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027419,
                "title": "c-2-different-approaches-recursive-one-liner-iterative",
                "content": "# Approach 1: recursive\\n\\nIt\\'s a long one-liner though:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\\n\\nclang-formatted and with comments:\\n\\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\\n\\nSimilar idea, slightly different implementation:\\n\\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\\n\\nA slightly more readable version could look like this:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of nodes in the tree and $$h$$ the height, which can vary from $$\\\\log n$$ to $$n$$ then the\\n  * Time complexity is $$O(n)$$ we need to visit all the nodes and the\\n  * Space complexity is $$O(h)$$\\n\\n# Approach 2: iterative\\nThe benefit of the iterative approach could be that we have better control and catch situtations if the input isn\\'t a actually a tree and contains a loop.\\n\\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIs the same as for the recursive version.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027357,
                "title": "explained-recursive-solution-o-n",
                "content": "#### Approach\\n\\nThe simplest strategy here is to use recursion. Check if p and q nodes are not None, and their values are equal. If all checks are OK, do the same for the child nodes recursively.\\n\\n#### Complexity Analysis\\n\\n**Time complexity** : O(n), where n is a number of nodes in the tree, since one visits each node exactly once.\\n\\n**Space complexity** : O(n) in the worst case of completely unbalanced tree, to keep a recursion stack.\\n\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857536,
                "title": "0ms-solution-recursion-java",
                "content": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780859,
                "title": "c-0-ms-faster-than-100-recursive-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf root of p and q is same, then check again for the root of left subtree of p and q. Again repeat the same process until you reach NULL.\\nRepeat this process for the right subtrees also.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We are following a bottom to top approach where we go to the bottom of the tree and then come to top and keep checking whether p and q are same or not. If at any point, they are not same, return false, otherwise keep returning true.\\n- Also if p and q both are NULL at the same time, then it will return true because it implies that both are equal.\\nBut if either p is null or q is null (but not both at the same time), then it implies that they are not equal and we return false.\\n- Also note that at any point of time, if the actual value of p and q are not equal, then also we have to return false. Here, we cannot write `p!=q`. Instead, we have to write `p->val != q->val` because we have to compare the values of p and q, but `p!=q` will compare the pointers, which can obviously never be equal because both p and q are present at different memory locations, although the value present inside both of them maybe same.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we traverse each node only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Auxiliary $$O(n)$$\\nBecause in the worst case i.e. for a skew tree, the maximum stack space required will be equal to total number of nodes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365177,
                "title": "c-solution-using-recursion-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936835,
                "title": "js-simple-explained-recursive-pre-order",
                "content": "# 100. Same Tree \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nThe question explains itself pretty well here. All we need to do is to go to each node in both trees at the same time and ensure they\\'re the same exact node as each other. \\n\\n##  Recommended Knowledge\\n1. Binary Trees\\n2. Depth First Search (Recursive)\\n3. Javascript Stack (Bubbles up in DFS)\\n4. Recursion\\n\\n## What do we know?\\n1. That we have 2 trees and we need to check that they\\'re the same\\n2. The max number of nodes a tree can have is 100.\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to do this recursively. Meaning, that at each node in the both trees, we\\'re going to be visiting at one point. We do this by recalling the ***isSameTree*** function with the left or right pointers\\n2.  We\\'re going to go to each node in both trees at the same time. That is to say, in tree 1, when we go left, we also go left in tree 2. Until we reach the very end of that right tree. We will also do this with the right tree too.\\n3.  Each time we visit a new node, we will make a check, are both nodes empty? In this case, both trees are empty and are at the end and thus correct.\\n4. Are any of the pointers null that aren\\'t supposed to be? Meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n5. We then check the values. Are they not the same? Then it\\'s a invalid tree\\n6. Repeat this until all nodes are exhausted, comparing that both the left and right trees are valid.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is equal to the number of nodes in both trees. | We visit every node in worst case\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the tallest tree. This is within the Call Stack | In the worst case, a tree\\'s number of nodes is it\\'s height. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 64 ms, faster than ***84.15%*** of JavaScript online submissions for Same Tree.\\n* Memory Usage: 42.3 MB, less than ***58.35%*** of JavaScript online submissions for Same Tree.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/678388505/)\\n\\n\\n***\\n\\n# The Solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338775,
                "title": "faster-than-100-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734211,
                "title": "python-3-5-lines-recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\\n\\nUPD: In 4 lines\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327852,
                "title": "golang-recursive-and-bfs-solutions",
                "content": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\\n\\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32683,
                "title": "java-intuitive-and-easy-to-understand-non-recursive-solutions-both-bfs-and-dfs-no-size-checking",
                "content": "Hi here are my non-recursive solutions. I think it is more intuitive as I only deal with properties of nodes pushed/polled and don't check queue/stack's status in the while loop.\\n\\nIn this question the iterative DFS and  iterative BFS are exactly the same thing. I think it is because we're doing the graph search, so it doesn't matter which sequence we are following to check nodes, as long as the checking for two trees are synchronized. \\n\\nIterative DFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\n\\nIterative BFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\nThough I have to say that the time performance of these two iterative solutions are pretty bad... below 5%. \\n\\nidk if it is because how I wrote my for loop.. anyway this format seems to be more intuitive to me!\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32908,
                "title": "one-line-java-with-recursive",
                "content": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "codeTag": "Unknown"
            },
            {
                "id": 4047543,
                "title": "python-3line-code-simple-approach",
                "content": "**Plz Upvote ..if you got help from this.**\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513811,
                "title": "python-easy-3-line-code",
                "content": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484336,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430835,
                "title": "4-lines-of-code-100-faster-optimal",
                "content": "# Explantion\\n1. if both the nodes are null return *true*\\n2. one of the nodes are null return *false*\\n3. if values of both nodes are not same return *false*\\n4. call left and right child for both the nodes.\\n# Complexity\\n- Time complexity: O(n), where, n is the number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030035,
                "title": "beats-100-simple-c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check if current nodes data of both trees is same and check for left subtree and rightsubtree respectively by simply doing  recusrive calls for both\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029914,
                "title": "java-3-solutions-commented",
                "content": "# Please Upvote :D\\n---\\n##### 1. Preorder traversal + extra space:\\n\\n``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\\n##### 2. Recursive approach (No extra space):\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\\n---\\n##### 3. Iterative approach:\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029147,
                "title": "java-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/11922000-a384-41a2-85fb-a6bfedcea97f_1673336288.9135783.png)\\n\\n\\n# Intuition\\nThe problem is straightforward. First, compare both trees\\' root node values with each other, and continue this procedure going right and left.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027740,
                "title": "c-100-faster-1-liner-solution-must-watch",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027461,
                "title": "c-solution-in-recursive-and-iterative-approach",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive solution.***\\n- If both trees are null, return true\\n- If one tree is null and the other is not, return false\\n- If the values at the roots of the trees are different, return false\\n- Recursively check the left and right subtrees of both trees\\n    - If the left or right subtrees are different, return false\\n- If the function has not yet returned false, return true\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using ***Iterative solution.***\\n- Create a stack and push the roots of both trees onto the stack as pairs.\\n- While the stack is not empty:\\n    - Pop a pair of nodes from the stack.\\n    - If both nodes are null, continue.\\n    - If one node is null or the values at the nodes are different, return false.\\n    - Push the left and right children of both nodes onto the stack as pairs.\\n- If the loop completes, return true.\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027352,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830951,
                "title": "shortest-simplest-c-2-lines",
                "content": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2765177,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726706,
                "title": "python-bt-beginners-solution-easy",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714988,
                "title": "0ms-runtime-easy-3-lines-c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```\\n*If this code helps please upvote, it motivates to write more solutions to help the community*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690285,
                "title": "stack-queue-approach",
                "content": "**Stack**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n\\n**Queue**\\n\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656522,
                "title": "o-n-time-and-o-n-space-recursion",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640564,
                "title": "c-solution-same-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197519,
                "title": "elixir-a-solution-that-cannot-be-simpler",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```\\n\\nWe can do so because in Elixir, everything is immutable, so if two things initially look the same, they\\'ll never become different; if they are initially different, they\\'ll never become the same either. Thus, comparing references is meaningless. So, in Elixir, `==` compares whole data structures.",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769465,
                "title": "3-lines-clean-easy-c-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1393461,
                "title": "bfs-c",
                "content": "\\n**Implementation**\\n\\nTime Complexity = O(N), Space Complexity = O(W) where W is the width of the Binary Tree\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038971,
                "title": "95-faster-python-3-code-recursive",
                "content": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956314,
                "title": "java-0-ms-100-faster-queues-iterative-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796604,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794503,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765093,
                "title": "esay-understand-of-interative",
                "content": "It is dfs with stack,i think it is very easy to understand,use only one stack can success it ,better than the offical answer\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 735223,
                "title": "java-2-lines",
                "content": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345623,
                "title": "go-recursive-solution",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234255,
                "title": "go-100-0ms",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222099,
                "title": "python-fast-and-simple-solution-both-recursion-and-iterative",
                "content": "### Recursion\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n### Iterative\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189672,
                "title": "python-clean-iterative-solution",
                "content": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 181179,
                "title": "simple-python-solution-beats-99-95",
                "content": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161608,
                "title": "python-solution",
                "content": "Iterative:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\\nRecursive:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32862,
                "title": "java-0ms-3-line-recursive-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32940,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32867,
                "title": "0-ms-c-solution",
                "content": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "solutionTags": [],
                "code": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32972,
                "title": "my-44ms-python-solution",
                "content": "\\n    class Solution:\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {boolean}\\n        def isSameTree(self, p, q):\\n            if p==q==None:\\n                return True\\n            if None in [p,q]:\\n                return False\\n            if p.val!=q.val:\\n                return False\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 3885554,
                "title": "simple-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808320,
                "title": "simplest-python-recursive-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483195,
                "title": "java-solution",
                "content": "Follow the given steps to solve the problem:\\n\\n    - If both trees are empty then return 1(Base case)\\n    - Else If both trees are non-empty\\n    - Check data of the root nodes (tree1->data ==  tree2->data)\\n    - Check left subtrees recursively\\n    - Check right subtrees recursively\\n    - If the above three statements are true then return 1\\n    - Else return 0 (one is empty and the other is not)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391761,
                "title": "pyhton3-dfs-recursion",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363285,
                "title": "this-java-solution-beats-everyone",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) where h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1b42ccef-6f00-4aa8-9c48-986edd079a88_1680286752.4062045.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217719,
                "title": "best-o-n-solution",
                "content": "# Approach\\nWe can use any traversal.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030043,
                "title": "python-easy-to-unserstand-well-explained",
                "content": "# Intuition\\nTo recursively check for the structural and value similarity between each node of both trees\\n\\n# Approach\\nDepth-first search (DFS) traversal\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)        \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028642,
                "title": "c-easy-solution-with-two-easy-approch",
                "content": "# Intuition\\nSo Main Intution of this Question is just we have to check for each node in both the tree if node has same value then check for left subtree and right subtree and all nodes have same value with other tree so return 1 else return 0.\\n\\n# Approach\\nFor this Question we have a two approch.\\n1) First just check a node for both tree and compare its value if the value is same so go for left and right subtree for that purpose we can use any traversal method.\\n2) and in second approch just do any one traversal in both tree and store in a vector and at the end just compare two vector if that vector is same so bothe the tree is same otherwise not.\\n\\n# Complexity\\n- Time complexity:\\n\\n1) O(N) where N is number of node.\\n2) 2O(N) N is number of node.\\n\\n- Space complexity:\\n1) only auxilary stack space\\n2) O(N)+ auxilary stack space\\n\\n# Code\\n```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\\n\\n# code\\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028358,
                "title": "3-js-solutions",
                "content": "\\n# Code BFS\\n```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\\n\\n# Code DFS\\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\\n\\n# Code JSON\\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3028273,
                "title": "efficiently-comparing-structurally-identical-binary-trees-o-n-time",
                "content": "The function takes two TreeNode objects as input, p and q. It first checks if p and q are the same object (i.e., if they are both null or if they are the same instance). If they are, it returns true. If either p or q is null, it returns false. If the values of p and q are different, it also returns false. If none of these conditions are true, it recursively checks if the left and right subtrees of p and q are the same.\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028256,
                "title": "simple-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat should be true for them to be same???\\n(1) Value of root should be same \\n(2) Left subtree should also be same \\n(3) Same for the right subtree\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028165,
                "title": "solved-using-pre-order-traversal-python3-solutiont",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I Traverse through both trees and develop a list of their values, Then if the list of both the trees is same, then  those two trees will be Same\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe apply inorder Traversal through the tree, and store the values in the seperate lists for both the trees, Note, when an intermediate tree node has Null value we store `-` in the list to differentiate between the empty node. At the end we compare two list so obtained and return True if the lists are same or else False..\\nHope it helps!!\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028020,
                "title": "c-short-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027663,
                "title": "c-recursion-approach-with-explanation",
                "content": "# Intuition\\n- Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The idea is to traverse both trees and compare values at their root node. If the value matches, recursively check if the first tree\\u2019s left subtree is identical to the left subtree of the second tree and the right subtree of the first tree is identical to the right subtree of the second tree. If the value at their root node differs, the trees violate data property. If at any point in the recursion, the first tree is empty and the second tree is non-empty, or the second tree is empty and the first tree is non-empty, the trees violate structural property, and they cannot be identical.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(min(n,m))$$\\n   - Where n & m are the size of tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(log (min(n, m)))$$\\n   - Due to auxiliary stack space used by recursion calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027484,
                "title": "java-iterative-recursive-0-ms-beats-100-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We just have to traverse through the trees and just check whether at every instance \\n    1. If the current node of `p` is null then so must be the current node of `q`\\n    2. If any one of them is null and not both then we return false\\n    3. If the values of current nodes don\\'t match we return false\\n    4. If we successfully traversed both the tree without hitting any roadblocks mentioned above we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- One possible approach is recursion, by traversing through the depth of the tree. Use the points mentioned in the intuition section to build the base case.\\n- For Iterative appraoch, we can use Breadth-First-Search. Even for BFS we keep in mind the 4 steps mentioned above.\\n\\n\\n# Code\\n\\n### Recursive\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\\n\\n### Iterative\\n\\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027375,
                "title": "c-easy-to-understand-best-and-easiest-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027351,
                "title": "daily-leetcoding-challenge-january-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2812678,
                "title": "the-same-tree",
                "content": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754146,
                "title": "very-easy-java-solution-0ms-100-faster-5lines-of-code",
                "content": "**very simplified solution for same tree**\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(p==null||q==null || p.val!=q.val) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2747446,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\n\\n``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698286,
                "title": "java-single-line-code-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377267,
                "title": "c-bfs-esay-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }\\n            \\n            if(node1->val != node2->val) return false;\\n            \\n            q1.push(node1->left);\\n            q1.push(node1->right);\\n            \\n            q2.push(node2->left);\\n            q2.push(node2->right);\\n            \\n        }\\n        \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2250107,
                "title": "c-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you \\nHappy Coding :)**\\n```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751251,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1750475,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1574051,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1575533,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1571213,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2056465,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2035545,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2034620,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2032553,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2017649,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1950698,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1920118,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1914194,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1911901,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1888531,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1873892,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1833960,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1801300,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1793045,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1783411,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1778166,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1768687,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1753213,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752974,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752507,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752124,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751778,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751329,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751191,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751137,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751123,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751121,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751090,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751067,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751003,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750994,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750940,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750912,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750873,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750872,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750863,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750853,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750781,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750710,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750704,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750662,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750655,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750631,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750572,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750559,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750533,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750512,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750508,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750501,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750489,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750472,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750432,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750386,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750384,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750380,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1742029,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1734679,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1732046,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1728203,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1714471,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1713647,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1710568,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1697147,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1676250,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1675088,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Islands",
        "question_content": "<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 56340,
                "title": "python-simple-dfs-solution",
                "content": "Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.\\n\\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n            \\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n    \\n    def dfs(self, grid, i, j):\\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '#'\\n        self.dfs(grid, i+1, j)\\n        self.dfs(grid, i-1, j)\\n        self.dfs(grid, i, j+1)\\n        self.dfs(grid, i, j-1)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.\\n\\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n            \\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n    \\n    def dfs(self, grid, i, j):\\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '#'\\n        self.dfs(grid, i+1, j)\\n        self.dfs(grid, i-1, j)\\n        self.dfs(grid, i, j+1)\\n        self.dfs(grid, i, j-1)",
                "codeTag": "Python3"
            },
            {
                "id": 56359,
                "title": "very-concise-java-ac-solution",
                "content": "    public class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n    \\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != '1') return;\\n        grid[i][j] = '0';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56589,
                "title": "c-bfs-dfs",
                "content": "I saw many peope post DFS solutions but fewer BFS ones. So I wrote one below. Each time when I see a `\\'1\\'`, I increment the counter and then erase all connected `\\'1\\'`s using a `queue`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```\\n\\nOr I can erase all the connected `\\'1\\'`s using DFS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n        grid[i][j] = \\'0\\';\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n        grid[i][j] = \\'0\\';\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56349,
                "title": "7-lines-python-14-lines-java",
                "content": "Sink and count the islands.\\n\\n---\\n\\n**Python Solution**\\n\\n    def numIslands(self, grid):\\n        def sink(i, j):\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == '1':\\n                grid[i][j] = '0'\\n                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n                return 1\\n            return 0\\n        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n\\n---\\n\\n**Java Solution 1**\\n\\n    public class Solution {\\n        char[][] g;\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            g = grid;\\n            for (int i=0; i<g.length; i++)\\n                for (int j=0; j<g[i].length; j++)\\n                    islands += sink(i, j);\\n            return islands;\\n        }\\n        int sink(int i, int j) {\\n            if (i < 0 || i == g.length || j < 0 || j == g[i].length || g[i][j] == '0')\\n                return 0;\\n            g[i][j] = '0';\\n            sink(i+1, j); sink(i-1, j); sink(i, j+1); sink(i, j-1);\\n            return 1;\\n        }\\n    }\\n\\n---\\n\\n**Java Solution 2**\\n\\n    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            for (int i=0; i<grid.length; i++)\\n                for (int j=0; j<grid[i].length; j++)\\n                    islands += sink(grid, i, j);\\n            return islands;\\n        }\\n        int sink(char[][] grid, int i, int j) {\\n            if (i < 0 || i == grid.length || j < 0 || j == grid[i].length || grid[i][j] == '0')\\n                return 0;\\n            grid[i][j] = '0';\\n            for (int k=0; k<4; k++)\\n                sink(grid, i+d[k], j+d[k+1]);\\n            return 1;\\n        }\\n        int[] d = {0, 1, 0, -1, 0};\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution {\\n        char[][] g;\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            g = grid;\\n            for (int i=0; i<g.length; i++)\\n                for (int j=0; j<g[i].length; j++)\\n                    islands += sink(i, j);\\n            return islands;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56354,
                "title": "1d-union-find-java-solution-easily-generalized-to-other-problems",
                "content": "For any problem I work on, I will try to generalize some reusable template out for future use.  We have limited time during interview and too much to worry about, so having some code template to use is very handy.  For this problem, although it is easier  and probably suggested to use BFS, but Union find also comes handy and can be easily extended to solve Island 2 and Surrounded regions.  \\n\\nI separate all the union find logic in a separate class and use 1d version to make the code clear.  I also use a 2d array for the 4 direction visit.  `int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};`\\n\\n\\n        int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};\\n        public int numIslands(char[][] grid) {  \\n            if (grid == null || grid.length == 0 || grid[0].length == 0)  {\\n                return 0;  \\n            }\\n            UnionFind uf = new UnionFind(grid);  \\n            int rows = grid.length;  \\n            int cols = grid[0].length;  \\n            for (int i = 0; i < rows; i++) {  \\n                for (int j = 0; j < cols; j++) {  \\n                    if (grid[i][j] == '1') {  \\n                        for (int[] d : distance) {\\n                            int x = i + d[0];\\n                            int y = j + d[1];\\n                            if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {  \\n                                int id1 = i*cols+j;\\n                                int id2 = x*cols+y;\\n                                uf.union(id1, id2);  \\n                            }  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n            return uf.count;  \\n        }\\n        \\nUnion Find:\\n\\n        class UnionFind {\\n            int[] father;  \\n            int m, n;\\n            int count = 0;\\n            UnionFind(char[][] grid) {  \\n                m = grid.length;  \\n                n = grid[0].length;  \\n                father = new int[m*n];  \\n                for (int i = 0; i < m; i++) {  \\n                    for (int j = 0; j < n; j++) {  \\n                        if (grid[i][j] == '1') {\\n                            int id = i * n + j;\\n                            father[id] = id;\\n                            count++;\\n                        }\\n                    }  \\n                }  \\n            }\\n            public void union(int node1, int node2) {  \\n                int find1 = find(node1);\\n                int find2 = find(node2);\\n                if(find1 != find2) {\\n                    father[find1] = find2;\\n                    count--;\\n                }\\n            }\\n            public int find (int node) {  \\n                if (father[node] == node) {  \\n                    return node;\\n                }\\n                father[node] = find(father[node]);  \\n                return father[node];\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "For any problem I work on, I will try to generalize some reusable template out for future use.  We have limited time during interview and too much to worry about, so having some code template to use is very handy.  For this problem, although it is easier  and probably suggested to use BFS, but Union find also comes handy and can be easily extended to solve Island 2 and Surrounded regions.  \\n\\nI separate all the union find logic in a separate class and use 1d version to make the code clear.  I also use a 2d array for the 4 direction visit.  `int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};`\\n\\n\\n        int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};\\n        public int numIslands(char[][] grid) {  \\n            if (grid == null || grid.length == 0 || grid[0].length == 0)  {\\n                return 0;  \\n            }\\n            UnionFind uf = new UnionFind(grid);  \\n            int rows = grid.length;  \\n            int cols = grid[0].length;  \\n            for (int i = 0; i < rows; i++) {  \\n                for (int j = 0; j < cols; j++) {  \\n                    if (grid[i][j] == '1') {  \\n                        for (int[] d : distance) {\\n                            int x = i + d[0];\\n                            int y = j + d[1];\\n                            if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {  \\n                                int id1 = i*cols+j;\\n                                int id2 = x*cols+y;\\n                                uf.union(id1, id2);  \\n                            }  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n            return uf.count;  \\n        }\\n        \\nUnion Find:\\n\\n        class UnionFind {\\n            int[] father;  \\n            int m, n;\\n            int count = 0;\\n            UnionFind(char[][] grid) {  \\n                m = grid.length;  \\n                n = grid[0].length;  \\n                father = new int[m*n];  \\n                for (int i = 0; i < m; i++) {  \\n                    for (int j = 0; j < n; j++) {  \\n                        if (grid[i][j] == '1') {\\n                            int id = i * n + j;\\n                            father[id] = id;\\n                            count++;\\n                        }\\n                    }  \\n                }  \\n            }\\n            public void union(int node1, int node2) {  \\n                int find1 = find(node1);\\n                int find2 = find(node2);\\n                if(find1 != find2) {\\n                    father[find1] = find2;\\n                    count--;\\n                }\\n            }\\n            public int find (int node) {  \\n                if (father[node] == node) {  \\n                    return node;\\n                }\\n                father[node] = find(father[node]);  \\n                return father[node];\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 345981,
                "title": "python3-number-of-islands-bfs-dfs",
                "content": "Explanation:\\nIn the grid, we need to record 1 peice of information of one point, grid[i][j], i.e., if grid[i][j] has been visited or not.\\nWe initialize the check matrix with all False. It means none of the elements in the check matrix has been visited.\\nIf one point grid[i][j] has not been visited, check[i][j] == False, it means we haven\\'t count this point into one islands.\\nIf one point grid[i][j] has been visited, check[i][j] == True, it means we already count this point into one islands.\\nSearch function:\\n\\nSearch function:\\nEach time you call search function, the search function will end until all the neighbors of grid[i][j] have value \"1\" been visited, i.e., those points are labeled True in check matrix.\\n\\n```\\nExample:\\ngrid = [ 1 ,  1 ,  1,\\n\\t\\t 1,   1,   0,\\n\\t\\t 0,   0,   1]\\n\\t\\t \\nIntial check:\\ncheck = [ False, False, False,\\n\\t\\t  False, False, False,\\n\\t\\t  False, False, False]\\n\\t\\t  \\n# the first time call  search function:\\ngrid[0][0] == \\'1\\' and check[0][0] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, False ]\\ncount = 1\\n# the second time call check function:\\ngrid[2][2] = \\'1\\' and check[2][2] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, True]\\nCount = 2\\n```\\n   \\n   \\n\\n\\nsearch function takes one point as input.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\\n* Improve space complexity to O(1): we can improve the algorithm by replacing the check matrix by flip the visited \\'1\\' to \\'0\\'. We can flip the visited \\'1\\' to \\'0\\' since we are only adding the index of \\'1\\' into the queue. The connected \\'1\\' already flip into \\'0\\', so we don\\'t need to worry about duplicate calculation. \\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    #print(i,j,grid)\\n                    grid[i][j] = \\'0\\'\\n                    self.helper(grid,i,j)\\n                    count += 1\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def helper(self,grid,i,j):\\n        queue = deque([(i,j)])\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I+1,J],[I,J+1],[I-1,J],[I,J-1]:\\n                if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    #print(i,j, queue)\\n                    grid[i][j] = \\'0\\'\\n                    queue.append((i,j))\\n```\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid):\\n        count = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    grid[i][j] = 0\\n                    queue.append((i,j))\\n                    self.helper(grid,queue) # turn the adjancent \\'1\\' to \\'0\\'\\n                    count += 1\\n        print(grid)\\n        return count\\n    \\n    def helper(self,grid,queue):\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I-1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0<= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    queue.append((i,j))\\n                    grid[i][j] = 0 #0\\n```\\n* DFS\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    print(i,j)\\n                    self.dfs(grid,i,j)\\n                    count  += 1\\n        #print(grid)\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def dfs(self,grid,i,j):\\n        grid[i][j] = 0\\n        for dr,dc in (1,0), (-1,0), (0,-1), (0,1):\\n            r = i + dr\\n            c = j + dc\\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]==\\'1\\':\\n                self.dfs(grid,r,c)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nExample:\\ngrid = [ 1 ,  1 ,  1,\\n\\t\\t 1,   1,   0,\\n\\t\\t 0,   0,   1]\\n\\t\\t \\nIntial check:\\ncheck = [ False, False, False,\\n\\t\\t  False, False, False,\\n\\t\\t  False, False, False]\\n\\t\\t  \\n# the first time call  search function:\\ngrid[0][0] == \\'1\\' and check[0][0] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, False ]\\ncount = 1\\n# the second time call check function:\\ngrid[2][2] = \\'1\\' and check[2][2] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, True]\\nCount = 2\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    #print(i,j,grid)\\n                    grid[i][j] = \\'0\\'\\n                    self.helper(grid,i,j)\\n                    count += 1\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def helper(self,grid,i,j):\\n        queue = deque([(i,j)])\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I+1,J],[I,J+1],[I-1,J],[I,J-1]:\\n                if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    #print(i,j, queue)\\n                    grid[i][j] = \\'0\\'\\n                    queue.append((i,j))\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid):\\n        count = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    grid[i][j] = 0\\n                    queue.append((i,j))\\n                    self.helper(grid,queue) # turn the adjancent \\'1\\' to \\'0\\'\\n                    count += 1\\n        print(grid)\\n        return count\\n    \\n    def helper(self,grid,queue):\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I-1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0<= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    queue.append((i,j))\\n                    grid[i][j] = 0 #0\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    print(i,j)\\n                    self.dfs(grid,i,j)\\n                    count  += 1\\n        #print(grid)\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def dfs(self,grid,i,j):\\n        grid[i][j] = 0\\n        for dr,dc in (1,0), (-1,0), (0,-1), (0,1):\\n            r = i + dr\\n            c = j + dc\\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]==\\'1\\':\\n                self.dfs(grid,r,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501000,
                "title": "c-simple-dfs-beats-100-in-memory-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/number-of-islands/\\n    TC: O(V^2)\\n*/\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int i, int j) {\\n        // boundary checking\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n            return;\\n        // return if current position is of water or is already visited\\n        if(grid[i][j] == \\'2\\' || grid[i][j] == \\'0\\')\\n            return;\\n        \\n        // mark the current as visited\\n        grid[i][j] = \\'2\\';\\n        \\n        // do DFS in all 4 directions\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i-1, j);\\n        DFS(grid, i, j+1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        // We can treat the matrix grid as a grid. Each Island is a\\n        // connected component. The task is to find no. of disconnectedd components\\n        // in the graph.\\n        \\n        int islands = 0;\\n        // We make each 1 as 2 in when it is visited\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                // do DFS in case has not been visited and there is land\\n                if(grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j);\\n                    ++islands;\\n                } \\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/number-of-islands/\\n    TC: O(V^2)\\n*/\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int i, int j) {\\n        // boundary checking\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n            return;\\n        // return if current position is of water or is already visited\\n        if(grid[i][j] == \\'2\\' || grid[i][j] == \\'0\\')\\n            return;\\n        \\n        // mark the current as visited\\n        grid[i][j] = \\'2\\';\\n        \\n        // do DFS in all 4 directions\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i-1, j);\\n        DFS(grid, i, j+1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        // We can treat the matrix grid as a grid. Each Island is a\\n        // connected component. The task is to find no. of disconnectedd components\\n        // in the graph.\\n        \\n        int islands = 0;\\n        // We make each 1 as 2 in when it is visited\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                // do DFS in case has not been visited and there is land\\n                if(grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j);\\n                    ++islands;\\n                } \\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56338,
                "title": "java-dfs-and-bfs-solution",
                "content": "Using Flood Fill algorithm:\\n\\nDFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    dfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void dfsFill(char[][] grid,int i, int j){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\\n            grid[i][j]='0';\\n            dfsFill(grid, i + 1, j);\\n            dfsFill(grid, i - 1, j);\\n            dfsFill(grid, i, j + 1);\\n            dfsFill(grid, i, j - 1);\\n        }\\n    }\\n\\nBFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    bfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void bfsFill(char[][] grid,int x, int y){\\n        grid[x][y]='0';\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        LinkedList<Integer> queue = new LinkedList<Integer>();  \\n        int code = x*m+y;  \\n        queue.offer(code);  \\n        while(!queue.isEmpty())  \\n        {  \\n            code = queue.poll();  \\n            int i = code/m;  \\n            int j = code%m;  \\n            if(i>0 && grid[i-1][j]=='1')    //search upward and mark adjacent '1's as '0'.\\n            {  \\n                queue.offer((i-1)*m+j);  \\n                grid[i-1][j]='0';  \\n            }  \\n            if(i<n-1 && grid[i+1][j]=='1')  //down\\n            {  \\n                queue.offer((i+1)*m+j);  \\n                grid[i+1][j]='0';  \\n            }  \\n            if(j>0 && grid[i][j-1]=='1')  //left\\n            {  \\n                queue.offer(i*m+j-1);  \\n                grid[i][j-1]='0';  \\n            }  \\n            if(j<m-1 && grid[i][j+1]=='1')  //right\\n            {  \\n                queue.offer(i*m+j+1);  \\n                grid[i][j+1]='0';  \\n            }\\n        } \\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Using Flood Fill algorithm:\\n\\nDFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    dfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void dfsFill(char[][] grid,int i, int j){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\\n            grid[i][j]='0';\\n            dfsFill(grid, i + 1, j);\\n            dfsFill(grid, i - 1, j);\\n            dfsFill(grid, i, j + 1);\\n            dfsFill(grid, i, j - 1);\\n        }\\n    }\\n\\nBFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    bfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void bfsFill(char[][] grid,int x, int y){\\n        grid[x][y]='0';\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        LinkedList<Integer> queue = new LinkedList<Integer>();  \\n        int code = x*m+y;  \\n        queue.offer(code);  \\n        while(!queue.isEmpty())  \\n        {  \\n            code = queue.poll();  \\n            int i = code/m;  \\n            int j = code%m;  \\n            if(i>0 && grid[i-1][j]=='1')    //search upward and mark adjacent '1's as '0'.\\n            {  \\n                queue.offer((i-1)*m+j);  \\n                grid[i-1][j]='0';  \\n            }  \\n            if(i<n-1 && grid[i+1][j]=='1')  //down\\n            {  \\n                queue.offer((i+1)*m+j);  \\n                grid[i+1][j]='0';  \\n            }  \\n            if(j>0 && grid[i][j-1]=='1')  //left\\n            {  \\n                queue.offer(i*m+j-1);  \\n                grid[i][j-1]='0';  \\n            }  \\n            if(j<m-1 && grid[i][j+1]=='1')  //right\\n            {  \\n                queue.offer(i*m+j+1);  \\n                grid[i][j+1]='0';  \\n            }\\n        } \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2497954,
                "title": "java-easy-solution-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\npublic class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    count++;\\n                    clearRestOfLand(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void clearRestOfLand(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        clearRestOfLand(grid, i+1, j);\\n        clearRestOfLand(grid, i-1, j);\\n        clearRestOfLand(grid, i, j+1);\\n        clearRestOfLand(grid, i, j-1);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    count++;\\n                    clearRestOfLand(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void clearRestOfLand(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        clearRestOfLand(grid, i+1, j);\\n        clearRestOfLand(grid, i-1, j);\\n        clearRestOfLand(grid, i, j+1);\\n        clearRestOfLand(grid, i, j-1);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56519,
                "title": "union-find-in-python",
                "content": "    class Solution(object):\\n        def numIslands(self, grid):\\n            \"\"\"\\n            :type grid: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(grid) == 0: return 0\\n            row = len(grid); col = len(grid[0])\\n            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))\\n            parent = [i for i in range(row*col)]\\n            \\n            def find(x):\\n                if parent[x]!= x:\\n                    return find(parent[x])\\n                return parent[x]\\n            \\n            def union(x,y):\\n                xroot, yroot = find(x),find(y)\\n                if xroot == yroot: return \\n                parent[xroot] = yroot\\n                self.count -= 1\\n            \\n            \\n            \\n            for i in range(row):\\n                for j in range(col):\\n                    if grid[i][j] == '0':\\n                        continue\\n                    index = i*col + j\\n                    if j < col-1 and grid[i][j+1] == '1':\\n                        union(index, index+1)\\n                    if i < row-1 and grid[i+1][j] == '1':\\n                        union(index, index+col)\\n            return self.count",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "    class Solution(object):\\n        def numIslands(self, grid):\\n            \"\"\"\\n            :type grid: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(grid) == 0: return 0\\n            row = len(grid); col = len(grid[0])\\n            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))\\n            parent = [i for i in range(row*col)]\\n            \\n            def find(x):\\n                if parent[x]!= x:\\n                    return find(parent[x])\\n                return parent[x]\\n            \\n            def union(x,y):\\n                xroot, yroot = find(x),find(y)\\n                if xroot == yroot: return \\n                parent[xroot] = yroot\\n                self.count -= 1\\n            \\n            \\n            \\n            for i in range(row):\\n                for j in range(col):\\n                    if grid[i][j] == '0':\\n                        continue\\n                    index = i*col + j\\n                    if j < col-1 and grid[i][j+1] == '1':\\n                        union(index, index+1)\\n                    if i < row-1 and grid[i+1][j] == '1':\\n                        union(index, index+col)\\n            return self.count",
                "codeTag": "Java"
            },
            {
                "id": 583745,
                "title": "python-3-solutions-dfs-bfs-union-find-concise-clean",
                "content": "**\\u2714\\uFE0F Solution 1: DFS**\\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        \\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == \"0\": return 0\\n            grid[r][c] = \"0\"  # Mark as visited\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i+1])\\n            return 1\\n        \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: BFS**\\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n    \\n        def bfs(r, c):\\n            if grid[r][c] == \"0\": return 0\\n            q = deque([(r, c)])\\n            while q:\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    grid[nr][nc] = \"0\"  # Mark as visited\\n                    q.append([nr, nc])\\n            return 1\\n    \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += bfs(r, c)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3a: Union-Find (Naive)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        while u != self.parent[u]:\\n            u = self.parent[u]\\n        return u\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN^2)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3b: Union-Find (Path Compression)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN * logMN)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3c: Union-Find (Path Compression & Union by Size)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Merge pu to pv\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        else:\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN * \\u03B1(MN))`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n   Explanation: Using both **path compression** and **union by size** ensures that the **amortized time** per **UnionFind** operation is only `\\u03B1(n)`, which is optimal, where `\\u03B1(n)` is the inverse Ackermann function. This function has a value `\\u03B1(n) < 5` for any value of n that can be written in this physical universe, so the disjoint-set operations take place in essentially constant time.\\nReference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure or https://www.slideshare.net/WeiLi73/time-complexity-of-union-find-55858534 for more information.\\n- Space: `O(M*N)`",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        \\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == \"0\": return 0\\n            grid[r][c] = \"0\"  # Mark as visited\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i+1])\\n            return 1\\n        \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n    \\n        def bfs(r, c):\\n            if grid[r][c] == \"0\": return 0\\n            q = deque([(r, c)])\\n            while q:\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    grid[nr][nc] = \"0\"  # Mark as visited\\n                    q.append([nr, nc])\\n            return 1\\n    \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += bfs(r, c)\\n        return ans\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        while u != self.parent[u]:\\n            u = self.parent[u]\\n        return u\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Merge pu to pv\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        else:\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56364,
                "title": "java-union-find-solution",
                "content": "class UF {\\n\\n    public int count = 0;\\n    public int[] id = null;\\n    \\n    public UF(int m, int n, char[][] grid) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '1') count++;\\n            }\\n        }\\n        id = new int[m * n];\\n        for(int i = 0; i < m * n; i++) {\\n            id[i] = i;\\n        }\\n    }\\n    \\n    public int find(int p) {\\n        while(p != id[p]) {\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot != qRoot) return false;\\n        else return true;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot == qRoot) return;\\n        id[pRoot] = qRoot;\\n        count--;\\n    }\\n}\\n\\n    public int numIslands(char[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        UF uf = new UF(m , n, grid);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '0') continue;\\n                int p = i * n + j;\\n                int q;\\n                if(i > 0 && grid[i - 1][j] == '1') {\\n                    q = p - n;\\n                    uf.union(p, q);\\n                }\\n                if(i < m - 1 && grid[i + 1][j] == '1') {\\n                    q = p + n;\\n                    uf.union(p, q);\\n                }\\n                if(j > 0 && grid[i][j - 1] == '1') {\\n                    q = p - 1;\\n                    uf.union(p, q);\\n                }\\n                if(j < n - 1 && grid[i][j + 1] == '1') {\\n                    q = p + 1;\\n                    uf.union(p, q);\\n                }\\n            }\\n        }\\n        return uf.count;\\n    }",
                "solutionTags": [],
                "code": "class UF {\\n\\n    public int count = 0;\\n    public int[] id = null;\\n    \\n    public UF(int m, int n, char[][] grid) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '1') count++;\\n            }\\n        }\\n        id = new int[m * n];\\n        for(int i = 0; i < m * n; i++) {\\n            id[i] = i;\\n        }\\n    }\\n    \\n    public int find(int p) {\\n        while(p != id[p]) {\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot != qRoot) return false;\\n        else return true;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot == qRoot) return;\\n        id[pRoot] = qRoot;\\n        count--;\\n    }\\n}\\n\\n    public int numIslands(char[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        UF uf = new UF(m , n, grid);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '0') continue;\\n                int p = i * n + j;\\n                int q;\\n                if(i > 0 && grid[i - 1][j] == '1') {\\n                    q = p - n;\\n                    uf.union(p, q);\\n                }\\n                if(i < m - 1 && grid[i + 1][j] == '1') {\\n                    q = p + n;\\n                    uf.union(p, q);\\n                }\\n                if(j > 0 && grid[i][j - 1] == '1') {\\n                    q = p - 1;\\n                    uf.union(p, q);\\n                }\\n                if(j < n - 1 && grid[i][j + 1] == '1') {\\n                    q = p + 1;\\n                    uf.union(p, q);\\n                }\\n            }\\n        }\\n        return uf.count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 121164,
                "title": "python-bfs-and-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslandsDFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \\'0\\'\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]    \\n            if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                self.dfs(grid, nr, nc)\\n\\n    def numIslandsBFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.bfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def bfs(self, grid, r, c):\\n        queue = collections.deque()\\n        queue.append((r, c))\\n        grid[r][c] = \\'0\\'\\n        while queue:\\n            directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n            r, c = queue.popleft()\\n            for d in directions:\\n                nr, nc = r + d[0], c + d[1]    \\n                if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                    queue.append((nr, nc))\\n                    grid[nr][nc] = \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslandsDFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \\'0\\'\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]    \\n            if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                self.dfs(grid, nr, nc)\\n\\n    def numIslandsBFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.bfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def bfs(self, grid, r, c):\\n        queue = collections.deque()\\n        queue.append((r, c))\\n        grid[r][c] = \\'0\\'\\n        while queue:\\n            directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n            r, c = queue.popleft()\\n            for d in directions:\\n                nr, nc = r + d[0], c + d[1]    \\n                if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                    queue.append((nr, nc))\\n                    grid[nr][nc] = \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497909,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nWe need to count ```number of groups of \\'1\\'```.  But only single ```\"1\"``` is to be counted from one island.\\n\\n**APPROACH**\\nWe traverse the ```grid``` element by element.\\nWhen :\\n* ```grid[i][j] == \"0\"``` -> Do nothing\\n* ```grid[i][j] == \"1\"``` ->There is an island.\\n* * Increase the count of islands by one.\\n* * Now we need to remove the island from the grid. ```[ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]```\\n* * We can use **DFS** to traverse through the island, where :\\n* * * If ```\"1\"``` is there, make it ```\"0\"```.\\n* * * Break out if we reach out of boundaries or we encounter ```\"0\"``` -> water.\\n* * * And to the same for neighbouring cells. ```[ i + 1 , i - 1 , j + 1 , j - 1 ]```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    void turn_to_dust(vector<vector<char>>& grid, int i, int j, int m, int n){\\n        if (i<0 || j<0 || i==m || j==n || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        turn_to_dust(grid,i+1,j,m,n);\\n        turn_to_dust(grid,i,j+1,m,n);\\n        turn_to_dust(grid,i-1,j,m,n);\\n        turn_to_dust(grid,i,j-1,m,n);\\n        return;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res=0;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j]==\\'1\\'){\\n                    res++;\\n                    turn_to_dust(grid,i,j,m,n);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        def turn_to_dust(i,j):\\n            if (i<0 or j<0 or i==len(grid) or j==len(grid[0]) or grid[i][j]==\"0\"):\\n                return\\n            grid[i][j]=\"0\"\\n            turn_to_dust(i,j+1)\\n            turn_to_dust(i,j-1)\\n            turn_to_dust(i+1,j)\\n            turn_to_dust(i-1,j)\\n            return\\n        res=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    res+=1\\n                    turn_to_dust(i,j)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/482ee389-ecd1-44f0-a898-414316dc069d_1661737467.6832316.webp)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```number of groups of \\'1\\'```\n```\"1\"```\n```grid```\n```grid[i][j] == \"0\"```\n```grid[i][j] == \"1\"```\n```[ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]```\n```\"1\"```\n```\"0\"```\n```\"0\"```\n```[ i + 1 , i - 1 , j + 1 , j - 1 ]```\n```\\nclass Solution {\\npublic:\\n    \\n    void turn_to_dust(vector<vector<char>>& grid, int i, int j, int m, int n){\\n        if (i<0 || j<0 || i==m || j==n || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        turn_to_dust(grid,i+1,j,m,n);\\n        turn_to_dust(grid,i,j+1,m,n);\\n        turn_to_dust(grid,i-1,j,m,n);\\n        turn_to_dust(grid,i,j-1,m,n);\\n        return;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res=0;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j]==\\'1\\'){\\n                    res++;\\n                    turn_to_dust(grid,i,j,m,n);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        def turn_to_dust(i,j):\\n            if (i<0 or j<0 or i==len(grid) or j==len(grid[0]) or grid[i][j]==\"0\"):\\n                return\\n            grid[i][j]=\"0\"\\n            turn_to_dust(i,j+1)\\n            turn_to_dust(i,j-1)\\n            turn_to_dust(i+1,j)\\n            turn_to_dust(i-1,j)\\n            return\\n        res=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    res+=1\\n                    turn_to_dust(i,j)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56460,
                "title": "clear-easy-java-solution",
                "content": "    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            \\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[i].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        count++;\\n                        clearRestOfLand(grid, i, j);\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n        \\n        private void clearRestOfLand(char[][] grid, int i, int j) {\\n            if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == '0') return;\\n            \\n            grid[i][j] = '0';\\n            clearRestOfLand(grid, i+1, j);\\n            clearRestOfLand(grid, i-1, j);\\n            clearRestOfLand(grid, i, j+1);\\n            clearRestOfLand(grid, i, j-1);\\n            return;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            \\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[i].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        count++;\\n                        clearRestOfLand(grid, i, j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 429842,
                "title": "javascript-dfs-commented-thought-process-beats-100-time-and-space",
                "content": "Below is what I typed out on a google doc in preparation for a google phone interview.\\nI thought it may be helpful for others to see and  give feedback on my thought process, and if it makes sense/is followable. After all, that\\'s what I want my interviewer to do, understand me. \\nGoal: Count number of islands\\nRules: \\n1) An island is surrounded by water(0\\'s)\\n2) We count things apart of our island if it is horizontal or vertical connected\\nPlan: \\nStart at the top left of the 2d array, and visit the first row, and all its columns, trying to find the start of the first island\\nOnce we find a 1, we can increment the number of islands, but we want to know where the island ends. So let\\u2019s look and follow any of the horizontal or vertical spots near the current position we are on. \\nFirst, let\\u2019s mark the current start/visited parts of the islands as visited by turning them into a 0,\\nSecond, explore all the adjacent possibilities,\\nIf one of them is a 1, recursively turn it into a 0 and check its children\\nOnce we are done, we should have gotten rid of the island that we discovered and can move on to the next island, if it exists in the 2d array\\n```\\nconst numIslands =  (grid) => {\\n\\tlet count = 0 // the counted islands\\n\\t//Go though each cell of the 2d array/grid \\n\\tfor(let row = 0; row < grid.length; row++){\\n\\tfor(let col = 0; col < grid[row].length; col ++){\\n\\tif(grid[row][col] == \\'1\\'){\\n\\t\\tcount ++\\n\\t\\texplore(row,col, grid)\\n            }\\n        }\\n    }\\n    return count\\n}\\n\\n\\n\\n// Takes a cell in a grid with a \\u201C1\\u201D , turns it into a \\u201C0\\u201D and explores (DFS) any of the left, right, up, down 1\\u2019s\\nfunction explore(row, col, grid){\\n    //Let\\'s return IF\\n    // row < 0 OR col < 0 OR row is out of bounds(meaning the row is larger than the number of arrays in the 2d array) OR col is at/out of bounds (meaning the current col is at/over the number of elements a row has.)\\n     if (row < 0 || col < 0 || row >= grid.length  \\n         || col >= grid[row].length || grid[row][col] === \\'0\\')  {\\n        return\\n    }\\n    \\n    //Otherwise, we should explore it!\\n    //First let\\'s set the current spot to \"0\"\\n    grid[row][col]=\\'0\\'\\n    \\n\\t//Possibilites:\\n\\t// 1) 1 to the right, left, top, bottom\\n\\t//right\\n\\texplore(row, col+1, grid)   \\n    //Left\\n\\texplore(row, col-1, grid)  \\n    //Down\\n\\texplore(row+1, col, grid) \\n    //Up\\n\\texplore(row-1, col, grid)   \\n\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst numIslands =  (grid) => {\\n\\tlet count = 0 // the counted islands\\n\\t//Go though each cell of the 2d array/grid \\n\\tfor(let row = 0; row < grid.length; row++){\\n\\tfor(let col = 0; col < grid[row].length; col ++){\\n\\tif(grid[row][col] == \\'1\\'){\\n\\t\\tcount ++\\n\\t\\texplore(row,col, grid)\\n            }\\n        }\\n    }\\n    return count\\n}\\n\\n\\n\\n// Takes a cell in a grid with a \\u201C1\\u201D , turns it into a \\u201C0\\u201D and explores (DFS) any of the left, right, up, down 1\\u2019s\\nfunction explore(row, col, grid){\\n    //Let\\'s return IF\\n    // row < 0 OR col < 0 OR row is out of bounds(meaning the row is larger than the number of arrays in the 2d array) OR col is at/out of bounds (meaning the current col is at/over the number of elements a row has.)\\n     if (row < 0 || col < 0 || row >= grid.length  \\n         || col >= grid[row].length || grid[row][col] === \\'0\\')  {\\n        return\\n    }\\n    \\n    //Otherwise, we should explore it!\\n    //First let\\'s set the current spot to \"0\"\\n    grid[row][col]=\\'0\\'\\n    \\n\\t//Possibilites:\\n\\t// 1) 1 to the right, left, top, bottom\\n\\t//right\\n\\texplore(row, col+1, grid)   \\n    //Left\\n\\texplore(row, col-1, grid)  \\n    //Down\\n\\texplore(row+1, col, grid) \\n    //Up\\n\\texplore(row-1, col, grid)   \\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56347,
                "title": "simple-java-solution",
                "content": "    public class NumberofIslands {\\n    \\tstatic int[] dx = {-1,0,0,1};\\n    \\tstatic int[] dy = {0,1,-1,0};\\n    \\tpublic static int numIslands(char[][] grid) {\\n    \\t\\tif(grid==null || grid.length==0) return 0;\\n    \\t\\tint islands = 0;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tfor(int j=0;j<grid[i].length;j++) {\\n    \\t\\t\\t\\tif(grid[i][j]=='1') {\\n    \\t\\t\\t\\t\\texplore(grid,i,j);\\n    \\t\\t\\t\\t\\tislands++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn islands;\\n    \\t}\\n    \\tpublic static void explore(char[][] grid, int i, int j) {\\n    \\t\\tgrid[i][j]='x';\\n    \\t\\tfor(int d=0;d<dx.length;d++) {\\n    \\t\\t\\tif(i+dy[d]<grid.length && i+dy[d]>=0 && j+dx[d]<grid[0].length && j+dx[d]>=0 && grid[i+dy[d]][j+dx[d]]=='1') {\\n    \\t\\t\\t\\texplore(grid,i+dy[d],j+dx[d]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n\\nThe algorithm works as follow:\\n\\n 1. Scan each cell in the grid.\\n 2. If the cell value is '1' explore that island.\\n 3. Mark the explored island cells with 'x'.\\n 4. Once finished exploring that island, increment islands counter.\\n\\nThe arrays dx[], dy[] store the possible moves from the current cell. Two land cells ['1'] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two '1' diagonally adjacent are not considered from the same island.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class NumberofIslands {\\n    \\tstatic int[] dx = {-1,0,0,1};\\n    \\tstatic int[] dy = {0,1,-1,0};\\n    \\tpublic static int numIslands(char[][] grid) {\\n    \\t\\tif(grid==null || grid.length==0) return 0;\\n    \\t\\tint islands = 0;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tfor(int j=0;j<grid[i].length;j++) {\\n    \\t\\t\\t\\tif(grid[i][j]=='1') {\\n    \\t\\t\\t\\t\\texplore(grid,i,j);\\n    \\t\\t\\t\\t\\tislands++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn islands;\\n    \\t}\\n    \\tpublic static void explore(char[][] grid, int i, int j) {\\n    \\t\\tgrid[i][j]='x';\\n    \\t\\tfor(int d=0;d<dx.length;d++) {\\n    \\t\\t\\tif(i+dy[d]<grid.length && i+dy[d]>=0 && j+dx[d]<grid[0].length && j+dx[d]>=0 && grid[i+dy[d]][j+dx[d]]=='1') {\\n    \\t\\t\\t\\texplore(grid,i+dy[d],j+dx[d]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n\\nThe algorithm works as follow:\\n\\n 1. Scan each cell in the grid.\\n 2. If the cell value is '1' explore that island.\\n 3. Mark the explored island cells with 'x'.\\n 4. Once finished exploring that island, increment islands counter.\\n\\nThe arrays dx[], dy[] store the possible moves from the current cell. Two land cells ['1'] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two '1' diagonally adjacent are not considered from the same island.",
                "codeTag": "Java"
            },
            {
                "id": 863366,
                "title": "python-3-dfs-bfs-union-find-all-3-methods-explanation",
                "content": "### Approach \\\\#1. DFS\\n- Iterate over the matrix and DFS at each point whenever a point is land (`1`)\\n- Mark visited as `2` to avoid revisit\\n- Increment `ans` each time need to do a DFS (original, not recursive)\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        def dfs(i, j):\\n            grid[i][j] = \\'2\\'\\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                ii, jj = i+di, j+dj\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == \\'1\\':\\n                    dfs(ii, jj)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(i, j)\\n                    ans += 1\\n        return ans\\n```\\n\\n### Approach \\\\#2. BFS\\n- Iterate over the matrix and BFS at each point whenever a point is land (`1`)\\n- Mark visited as `2` to avoid revisit\\n- Increment `ans` each time need to do a BFS (original, not recursive)\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    q = collections.deque([(i, j)])\\n                    grid[i][j] = \\'2\\'\\n                    while q:\\n                        x, y = q.popleft()\\n                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                            xx, yy = x+dx, y+dy\\n                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == \\'1\\':\\n                                q.append((xx, yy))\\n                                grid[xx][yy] = \\'2\\'\\n                    ans += 1            \\n        return ans\\n```\\n\\n### Approach \\\\#3. Union Find\\n- Create dictionary `d[(i,j)] = idx`, give `(x,y)` an id number, for eaiser union find\\n- Create a Union Find object with length of number of `\"1\"` (say length is `n` or `size`)\\n- Iterate over matrix, from left to right, from top to bottom\\n\\t- Union current and left or right, if they are both `1`\\n\\t- For each union, decrement `size`\\n- Return `size`\\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n)]\\n        self.n = n\\n        self.size = n\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi != pj:\\n            self.size -= 1\\n            self.p[pj] = pi\\n\\n    def find(self, i):\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        d = dict()\\n        idx = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    d[i, j] = idx\\n                    idx += 1\\n        uf = UF(idx)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    if i > 0 and grid[i-1][j] == \\'1\\':\\n                        uf.union(d[i-1, j], d[i, j])\\n                    if j > 0 and grid[i][j-1] == \\'1\\':\\n                        uf.union(d[i, j-1], d[i, j])\\n        return uf.size\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        def dfs(i, j):\\n            grid[i][j] = \\'2\\'\\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                ii, jj = i+di, j+dj\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == \\'1\\':\\n                    dfs(ii, jj)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(i, j)\\n                    ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    q = collections.deque([(i, j)])\\n                    grid[i][j] = \\'2\\'\\n                    while q:\\n                        x, y = q.popleft()\\n                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                            xx, yy = x+dx, y+dy\\n                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == \\'1\\':\\n                                q.append((xx, yy))\\n                                grid[xx][yy] = \\'2\\'\\n                    ans += 1            \\n        return ans\\n```\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n)]\\n        self.n = n\\n        self.size = n\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi != pj:\\n            self.size -= 1\\n            self.p[pj] = pi\\n\\n    def find(self, i):\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        d = dict()\\n        idx = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    d[i, j] = idx\\n                    idx += 1\\n        uf = UF(idx)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    if i > 0 and grid[i-1][j] == \\'1\\':\\n                        uf.union(d[i-1, j], d[i, j])\\n                    if j > 0 and grid[i][j-1] == \\'1\\':\\n                        uf.union(d[i, j-1], d[i, j])\\n        return uf.size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497897,
                "title": "python-c-c-95-easy-dfs-explained-beginner-friendly",
                "content": "**Idea:**\\n1. loop through\\n2. do dfs for every island, mark down visited island\\n3. increase the counter by 1\\n\\n<iframe src=\"https://leetcode.com/playground/bMUsJpSD/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "**Idea:**\\n1. loop through\\n2. do dfs for every island, mark down visited island\\n3. increase the counter by 1\\n\\n<iframe src=\"https://leetcode.com/playground/bMUsJpSD/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1511737,
                "title": "c-all-3-methods-dfs-bfs-union-find",
                "content": "**Method 1: DFS**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        for(int k=0; k<4; k++) {\\n            int ci=DR[k]+i;\\n            int cj=DC[k]+j;\\n            if(!valid_index(ci, cj, grid))\\n                continue;\\n            if(grid[ci][cj]==\\'1\\')\\n                dfs(ci, cj, grid);\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    dfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n**Method 2: BFS**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void bfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int ci=DR[k]+i;\\n                int cj=DC[k]+j;\\n                if(!valid_index(ci, cj, grid))\\n                    continue;\\n                if(grid[ci][cj]==\\'1\\') {\\n                    q.push({ci, cj});\\n                    grid[ci][cj]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    bfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n**Method 3: Union Find**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int no_of_islands=0;\\n    int DC[4]={0, 1, 0, -1};\\n    int DR[4]={1, 0, -1, 0};\\n    \\n    int find_parent(int a, vector<int> &parent) {\\n        if(parent[a]==a) return a;\\n        return parent[a]=find_parent(parent[a], parent);\\n    }\\n    \\n    void union_(int a, int b, vector<int> &parent) {\\n        int pa=find_parent(a, parent);\\n        int pb=find_parent(b, parent);\\n        if(pa==pb) return;\\n        parent[pa]=pb;\\n        no_of_islands--;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> parent(n*m);        \\n        for(int i=0; i<n*m; i++)\\n            parent[i]=i;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    for(int k=0; k<4; k++) {\\n                        int ci=DR[k]+i;\\n                        int cj=DC[k]+j;\\n                        if(ci<0 || cj<0 || ci>=n || cj>=m)\\n                            continue;\\n                        if(grid[ci][cj]==\\'1\\') {\\n                            union_((i*m)+j, (ci*m)+cj, parent);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n*Please upvote if you find it helpful*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        for(int k=0; k<4; k++) {\\n            int ci=DR[k]+i;\\n            int cj=DC[k]+j;\\n            if(!valid_index(ci, cj, grid))\\n                continue;\\n            if(grid[ci][cj]==\\'1\\')\\n                dfs(ci, cj, grid);\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    dfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void bfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int ci=DR[k]+i;\\n                int cj=DC[k]+j;\\n                if(!valid_index(ci, cj, grid))\\n                    continue;\\n                if(grid[ci][cj]==\\'1\\') {\\n                    q.push({ci, cj});\\n                    grid[ci][cj]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    bfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int no_of_islands=0;\\n    int DC[4]={0, 1, 0, -1};\\n    int DR[4]={1, 0, -1, 0};\\n    \\n    int find_parent(int a, vector<int> &parent) {\\n        if(parent[a]==a) return a;\\n        return parent[a]=find_parent(parent[a], parent);\\n    }\\n    \\n    void union_(int a, int b, vector<int> &parent) {\\n        int pa=find_parent(a, parent);\\n        int pb=find_parent(b, parent);\\n        if(pa==pb) return;\\n        parent[pa]=pb;\\n        no_of_islands--;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> parent(n*m);        \\n        for(int i=0; i<n*m; i++)\\n            parent[i]=i;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    for(int k=0; k<4; k++) {\\n                        int ci=DR[k]+i;\\n                        int cj=DC[k]+j;\\n                        if(ci<0 || cj<0 || ci>=n || cj>=m)\\n                            continue;\\n                        if(grid[ci][cj]==\\'1\\') {\\n                            union_((i*m)+j, (ci*m)+cj, parent);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391717,
                "title": "javascript-dfs-56ms-very-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    \\n    function depthSearch(x, y) {\\n        if (grid[x][y] === \\'1\\') {\\n            grid[x][y] = \\'0\\';\\n        } else {\\n            return;\\n        }\\n\\n        if (x < grid.length - 1) {\\n            depthSearch(x+1, y);\\n        }\\n        \\n        if (y < grid[x].length - 1) {\\n            depthSearch(x, y+1);\\n        }\\n        \\n        if (x > 0 && x < grid.length) {\\n            depthSearch(x-1, y);\\n        }\\n        \\n        if (y > 0 && y < grid[x].length) {\\n            depthSearch(x, y-1);\\n        }\\n    }\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === \\'1\\') {\\n                count++;\\n                depthSearch(i, j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    \\n    function depthSearch(x, y) {\\n        if (grid[x][y] === \\'1\\') {\\n            grid[x][y] = \\'0\\';\\n        } else {\\n            return;\\n        }\\n\\n        if (x < grid.length - 1) {\\n            depthSearch(x+1, y);\\n        }\\n        \\n        if (y < grid[x].length - 1) {\\n            depthSearch(x, y+1);\\n        }\\n        \\n        if (x > 0 && x < grid.length) {\\n            depthSearch(x-1, y);\\n        }\\n        \\n        if (y > 0 && y < grid[x].length) {\\n            depthSearch(x, y-1);\\n        }\\n    }\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === \\'1\\') {\\n                count++;\\n                depthSearch(i, j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121174,
                "title": "python-union-find-solution-with-both-path-compression-and-union-by-rank",
                "content": "```\\nclass UnionFind(object):\\n    def __init__(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        self.count = 0\\n        self.parent = [-1] * (m*n)\\n        self.rank = [0] * (m*n)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.parent[i*n + j] = i*n + j\\n                    self.count += 1\\n\\n    def find(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.rank[rootx] > self.rank[rooty]:\\n                self.parent[rooty] = rootx\\n            elif self.rank[rootx] < self.rank[rooty]:\\n                self.parent[rootx] = rooty\\n            else:\\n                self.parent[rooty] = rootx\\n                self.rank[rootx] += 1\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        uf = UnionFind(grid)\\n\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        m, n = len(grid), len(grid[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    for d in directions:\\n                        nr, nc = i + d[0], j + d[1]\\n                        if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                            uf.union(i*n+j, nr*n+nc)\\n        return uf.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind(object):\\n    def __init__(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        self.count = 0\\n        self.parent = [-1] * (m*n)\\n        self.rank = [0] * (m*n)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.parent[i*n + j] = i*n + j\\n                    self.count += 1\\n\\n    def find(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.rank[rootx] > self.rank[rooty]:\\n                self.parent[rooty] = rootx\\n            elif self.rank[rootx] < self.rank[rooty]:\\n                self.parent[rootx] = rooty\\n            else:\\n                self.parent[rooty] = rootx\\n                self.rank[rootx] += 1\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        uf = UnionFind(grid)\\n\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        m, n = len(grid), len(grid[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    for d in directions:\\n                        nr, nc = i + d[0], j + d[1]\\n                        if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                            uf.union(i*n+j, nr*n+nc)\\n        return uf.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56356,
                "title": "dfs-and-bfs-in-c",
                "content": "When we met a '1', the answer add 1, we also need to search all '1' which connected to it directly or indirectly, and change it to '0'. And we can use DFS or BFS to search.\\n\\n1. DFS\\n======\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        DFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void DFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            grid[x][y] = '0';\\n            if(x > 0 && grid[x - 1][y] == '1')\\n                DFS(grid, x - 1, y);\\n            if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                DFS(grid, x + 1, y);\\n            if(y > 0 && grid[x][y - 1] == '1')\\n                DFS(grid, x, y - 1);\\n            if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                DFS(grid, x, y + 1);\\n        }\\n    };\\n\\n2. BFS\\n======\\n\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        BFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void BFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            queue<vector<int>> q;\\n            q.push({x, y});\\n            grid[x][y] = '0';\\n            \\n            while(!q.empty())\\n            {\\n                x = q.front()[0], y = q.front()[1];\\n                q.pop();\\n                \\n                if(x > 0 && grid[x - 1][y] == '1')\\n                {\\n                    q.push({x - 1, y});\\n                    grid[x - 1][y] = '0';\\n                }\\n                if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                {\\n                    q.push({x + 1, y});\\n                    grid[x + 1][y] = '0';\\n                }\\n                if(y > 0 && grid[x][y - 1] == '1')\\n                {\\n                    q.push({x, y - 1});\\n                    grid[x][y - 1] = '0';\\n                }\\n                if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                {\\n                    q.push({x, y + 1});\\n                    grid[x][y + 1] = '0';\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        DFS(grid, i, j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 151858,
                "title": "javascript-dfs",
                "content": "```js\\nfunction numIslands(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  let count = 0;\\n  \\n  for (let r = 0; r < H; r++) {\\n    for (let c = 0; c < W; c++) {\\n      if (grid[r][c] === \\'0\\') continue;\\n      \\n      count++;\\n      dfs(r, c);\\n    }\\n  }\\n  return count;\\n  \\n  function dfs(r, c) {\\n    if (r < 0 || c < 0 || r === H || c === W) return;\\n    if (grid[r][c] === \\'0\\') return;\\n    \\n    grid[r][c] = \\'0\\';\\n    dfs(r-1, c);\\n    dfs(r+1, c);\\n    dfs(r, c-1);\\n    dfs(r, c+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction numIslands(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  let count = 0;\\n  \\n  for (let r = 0; r < H; r++) {\\n    for (let c = 0; c < W; c++) {\\n      if (grid[r][c] === \\'0\\') continue;\\n      \\n      count++;\\n      dfs(r, c);\\n    }\\n  }\\n  return count;\\n  \\n  function dfs(r, c) {\\n    if (r < 0 || c < 0 || r === H || c === W) return;\\n    if (grid[r][c] === \\'0\\') return;\\n    \\n    grid[r][c] = \\'0\\';\\n    dfs(r-1, c);\\n    dfs(r+1, c);\\n    dfs(r, c-1);\\n    dfs(r, c+1);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640295,
                "title": "optimized-by-memory-follow-up-question-what-if-matrix-is-too-big",
                "content": "There is this follow-up for this task: \"what if the input data is too big (and sparse)\"\\n\\nLets say the input data is such big that we can not even load it in memory so instead we want to read it line-by-line (for example, from file). Lets say we have a method `readR(int r)` that returns *r* row of the matrix;\\nSay `currLine` is a row we are checking, `prevLine` - one before it;\\nNow we can read line-by-line and follow these rules:\\n - if `currLine[i-1] && prevLine[i]` are not set, we consider i as a start of the new island;\\n - if `currLine[i-1]` is set but `prevLine[i]` is not we consider i belongs to island `currLine[i-1]`\\n - if `prevLine[i]` is set but `currLine[i-1]` is not  we consider i belongs to island `prevLine[i]`\\n - if both `currLine[i-1] && prevLine[i]` are set, we conider i belongs to `currLine[i-1]` **AND** we update `prevLine[i]` island to be `currLine[i-1]`.\\n \\nFor keeping track / updating indices of islands we use Union-Find: keep a `map(k,v)` where island k is considered connected to island v.  When we create a new island, we create `k->k` record, when updating k, we recursively traverse through all connected islands and update their values to the new one;\\n\\ncode:\\n```\\n\\npublic int numIslands(char[][] grid) {\\n        if (grid.length < 1) return 0;\\n        int[] firstR = readFirtsR(grid);\\n        Map<Integer, Integer> sets = new HashMap<>();\\n        int count = 0;\\n        // read first row and create first islands:\\n\\t\\t// [0 1 0 0 1 0 1] => [0 1 0 0 2 0 3]\\n\\t\\tfor (int n: firstR) if (n != 0) {\\n            sets.put(n, n);\\n            count = n;\\n        }\\n        int r = 1;\\n        while (r < grid.length) {\\n            char[] line = readR(r, grid);\\n            int[] secondR = new int[line.length];\\n            for (int i = 0; i < line.length; i++) {\\n                if (line[i] == \\'1\\') {\\n                    if (i != 0 && secondR[i - 1] != 0) {\\n                        secondR[i] = getRoot(secondR[i - 1],sets);\\n                    }\\n                    else if (firstR[i] != 0) {\\n                        secondR[i] = getRoot(firstR[i], sets);\\n                    }\\n                    else {\\n                        count++;\\n                        secondR[i] = count;\\n                        sets.put(count, count);\\n                    }\\n                    if (firstR[i] != secondR[i] && firstR[i] != 0) {\\n                        updateRoots(sets.get(firstR[i]), secondR[i], sets);\\n                    }\\n                }\\n            }\\n            firstR = secondR;\\n            r++;\\n        }\\n        int res = 0;\\n        for (int k : sets.keySet()) if (sets.get(k) == k) res++;\\n        return res;\\n    }\\n\\t\\n    // union-find \"find\" part\\n    private int getRoot(int v, Map<Integer, Integer> sets) {\\n        int k = v;\\n        while (k != sets.get(k)) k = sets.get(k);\\n        return k;\\n    }\\n\\n    // connect island k to island newVal\\n    private void updateRoots(int k, int newVal, Map<Integer, Integer> sets) {\\n        while (k != newVal) {\\n            int v = sets.get(k);\\n            sets.put(k, newVal);\\n            k = v;\\n        }\\n    }\\n\\n    private char[] readR(int i, char[][] grid) {\\n        return grid[i];\\n    }\\n\\n    //  this is ugly and probably can be done better:\\n\\t// read first line and connect adjusted \\'1\\' \\n    private int[] readFirtsR(char[][] grid) {\\n        int[] first = new int[grid[0].length];\\n        char[] r = readR(0, grid);\\n        int count = 1;\\n        int start = 0;\\n\\n        while (start < first.length) {\\n            if (r[start] == \\'1\\' &&\\n                    (start == 0 || r[start - 1] != \\'1\\')) first[start] = count++;\\n            if (start != 0 && r[start] == \\'1\\' && r[start - 1] == \\'1\\') first[start] = first[start - 1];\\n            start++;\\n        }\\n        return first;\\n    }\\n```\\n\\nMemory should be `O(max(grig[0].length, res))` \\nwhere `res` is number of islands. Worst-case `res` will be `n/2` (if islands consist of one-element cells adjusted by diagonals only). Hovewer in case of sparse matrix we can probably assume `grig[0].length >> res`.\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic int numIslands(char[][] grid) {\\n        if (grid.length < 1) return 0;\\n        int[] firstR = readFirtsR(grid);\\n        Map<Integer, Integer> sets = new HashMap<>();\\n        int count = 0;\\n        // read first row and create first islands:\\n\\t\\t// [0 1 0 0 1 0 1] => [0 1 0 0 2 0 3]\\n\\t\\tfor (int n: firstR) if (n != 0) {\\n            sets.put(n, n);\\n            count = n;\\n        }\\n        int r = 1;\\n        while (r < grid.length) {\\n            char[] line = readR(r, grid);\\n            int[] secondR = new int[line.length];\\n            for (int i = 0; i < line.length; i++) {\\n                if (line[i] == \\'1\\') {\\n                    if (i != 0 && secondR[i - 1] != 0) {\\n                        secondR[i] = getRoot(secondR[i - 1],sets);\\n                    }\\n                    else if (firstR[i] != 0) {\\n                        secondR[i] = getRoot(firstR[i], sets);\\n                    }\\n                    else {\\n                        count++;\\n                        secondR[i] = count;\\n                        sets.put(count, count);\\n                    }\\n                    if (firstR[i] != secondR[i] && firstR[i] != 0) {\\n                        updateRoots(sets.get(firstR[i]), secondR[i], sets);\\n                    }\\n                }\\n            }\\n            firstR = secondR;\\n            r++;\\n        }\\n        int res = 0;\\n        for (int k : sets.keySet()) if (sets.get(k) == k) res++;\\n        return res;\\n    }\\n\\t\\n    // union-find \"find\" part\\n    private int getRoot(int v, Map<Integer, Integer> sets) {\\n        int k = v;\\n        while (k != sets.get(k)) k = sets.get(k);\\n        return k;\\n    }\\n\\n    // connect island k to island newVal\\n    private void updateRoots(int k, int newVal, Map<Integer, Integer> sets) {\\n        while (k != newVal) {\\n            int v = sets.get(k);\\n            sets.put(k, newVal);\\n            k = v;\\n        }\\n    }\\n\\n    private char[] readR(int i, char[][] grid) {\\n        return grid[i];\\n    }\\n\\n    //  this is ugly and probably can be done better:\\n\\t// read first line and connect adjusted \\'1\\' \\n    private int[] readFirtsR(char[][] grid) {\\n        int[] first = new int[grid[0].length];\\n        char[] r = readR(0, grid);\\n        int count = 1;\\n        int start = 0;\\n\\n        while (start < first.length) {\\n            if (r[start] == \\'1\\' &&\\n                    (start == 0 || r[start - 1] != \\'1\\')) first[start] = count++;\\n            if (start != 0 && r[start] == \\'1\\' && r[start - 1] == \\'1\\') first[start] = first[start - 1];\\n            start++;\\n        }\\n        return first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56585,
                "title": "simple-dfs-python-code-beat-90",
                "content": "    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        sum  = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if grid[i][j] == \"0\":\\n                    continue\\n                else:\\n                    \\n                    #sum up only once per chance of meeting \"1\"\\n                    sum += 1\\n                    stack = list()\\n                    stack.append([i,j])\\n                    \\n                    #visit each \"1\" in the adjacent area using a stack\\n                    while len(stack) != 0:\\n                        \\n                        [p,q] = stack.pop()\\n                        \\n                        if p >= 1 and grid[p-1][q] == \"1\":\\n                            stack.append([p-1,q])\\n                            \\n                        if p < m -1 and grid[p+1][q] == \"1\":\\n                            stack.append([p+1,q])\\n                        \\n                        if q >= 1 and grid[p][q-1] == \"1\":\\n                            stack.append([p,q-1])\\n                            \\n                        if q < n - 1 and grid[p][q + 1] == \"1\":\\n                            stack.append([p,q+1])\\n                        \\n                        #mark as visited\\n                        grid[p][q] = \"0\"\\n        \\n        \\n        \\n        return sum\\n        \\n\\nUse a stack to DFS the lands area every time we found a island.",
                "solutionTags": [],
                "code": "    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        sum  = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if grid[i][j] == \"0\":\\n                    continue\\n                else:\\n                    \\n                    #sum up only once per chance of meeting \"1\"\\n                    sum += 1\\n                    stack = list()\\n                    stack.append([i,j])\\n                    \\n                    #visit each \"1\" in the adjacent area using a stack\\n                    while len(stack) != 0:\\n                        \\n                        [p,q] = stack.pop()\\n                        \\n                        if p >= 1 and grid[p-1][q] == \"1\":\\n                            stack.append([p-1,q])\\n                            \\n                        if p < m -1 and grid[p+1][q] == \"1\":\\n                            stack.append([p+1,q])\\n                        \\n                        if q >= 1 and grid[p][q-1] == \"1\":\\n                            stack.append([p,q-1])\\n                            \\n                        if q < n - 1 and grid[p][q + 1] == \"1\":\\n                            stack.append([p,q+1])\\n                        \\n                        #mark as visited\\n                        grid[p][q] = \"0\"\\n        \\n        \\n        \\n        return sum\\n        \\n\\nUse a stack to DFS the lands area every time we found a island.",
                "codeTag": "Python3"
            },
            {
                "id": 3530724,
                "title": "java-solutions-using-bfs-and-dfs",
                "content": "# Intuition\\nIt is similar to the methodology of connected components .The question arises here \"how can this problem be solved using a graph?\" Try to think of all the elements as a node or a vertex, we can observe they are connected in some way as all 8 directions connectivity is allowed. If we start a traversal algorithm, from a particular 1 (land) it will make sure it traverses the nearest 1 (land). So, one traversal with a starting point will cover an island. If we do 3 traversals then we will have 3 starting nodes, anyone can be considered as a starting node in an island, and make sure it visits everyone. In the following example, if we take 3 starting nodes we will be able to touch all the pieces of land. Hence, one starting node makes sure it touches all the connected lands. The basic idea is that \\u201Cone starting node represents one island\\u201D.  So, we just need to figure out the number of starting points.\\n\\n# Approach\\nIn any traversal technique, we have one starting node and it traverses all the nodes in the graph. We know about both the traversals, Breadth First Search (BFS) and Depth First Search (DFS). \\n\\nThe algorithm steps for BFS are as follows:\\n\\n  1.  The pairs of row and column (<row, column>) will represent the node numbers.\\n   2. For BFS traversal, we need a queue data structure and a visited array. Create a replica of the given array, i.e., create another array of the same size and call it a visited array. We can use the same matrix, but we will avoid alteration of the original data. \\n   3. In the queue, insert a vertex (pair of <row, column>) and mark it as visited. \\n  4.  While BFS traversal, pop out an element from the queue and travel to all its neighbours. In a graph, we store the list of neighbours in an adjacency list but here we know the neighbours are in 8 directions. \\n    5.We go in all 8 directions and check for unvisited land neighbours. To travel in 8 directions we will use nested loops, you can find the implementation details in the code. \\n   6. BFS function call will make sure that it starts the BFS call from that unvisited land, and visits all the nodes that are on that island, and at the same time, it will also mark them as visited. \\n   7. Since the nodes travelled in a traversal will be marked as visited, they will no further be called for any further BFS traversal. \\n    Keep repeating these steps, for every land that you find unvisited, and visit the entire island. \\n   8. Add a counter variable to count the number of times the BFS function is called, as in this way we can count the total number of starting nodes, which will give us the number of islands.\\n\\n\\n**The algorithmic steps for DFS are as follows:**\\n                The basic idea is we iterate all the element on grid[ ][ ], and if the element is 1, then it triggers DFS and tracks the surrounding elements  and  change all the element around it to be 0 in order to ensure that all the connected nodes make a single node count.Please do check code below for proper understanding.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N\\xB2 + NxMx9), N\\xB2 for the nested loops, and NxMx9 for the overall DFS of the matrix, that will happen throughout if all the cells are filled with 1.\\n\\n- Space complexity:\\nO(N\\xB2) for visited array max queue space O(N\\xB2), If all are marked as 1 then the maximum queue space will be N\\xB2.\\n\\n# Code\\n# **BFS CODE**\\n\\n    private void bfs(int ro, int co, int[][] vis, char[][] grid) {\\n      vis[ro][co] = 1; \\n      Queue<Pair> q = new LinkedList<Pair>();\\n      q.add(new Pair(ro, co)); \\n      int n = grid.length; \\n      int m = grid[0].length; \\n      \\n      // until the queue becomes empty\\n      while(!q.isEmpty()) {\\n          int row = q.peek().first; \\n          int col = q.peek().second; \\n          q.remove(); \\n          \\n          // traverse in the neighbours and mark them if its a land \\n          for(int delrow = -1; delrow<=1;delrow++) {\\n              for(int delcol = -1; delcol <= 1; delcol++) {\\n                  int nrow = row + delrow; \\n                  int ncol = col + delcol; \\n          // check if neighbour row and column is valid, and is an unvisited land\\n                  if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                  && grid[nrow][ncol] == \\'1\\' && vis[nrow][ncol] == 0) {\\n                      vis[nrow][ncol] = 1; \\n                      q.add(new Pair(nrow, ncol)); \\n                  }\\n              }\\n          }\\n      }\\n  }\\n\\n    // Function to find the number of islands.\\n    public int numIslands(char[][] grid) {\\n        int n = grid.length; \\n        int m = grid[0].length; \\n        int[][] vis = new int[n][m];\\n        int cnt = 0; \\n        for(int row = 0; row < n ; row++) {\\n            for(int col = 0; col < m ;col++) {\\n                // if not visited and is a land\\n                if(vis[row][col] == 0 && grid[row][col] == \\'1\\') {\\n                    cnt++; \\n                    bfs(row, col, vis, grid); \\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n\\n```\\n```\\n# **DFS SOLUTION**\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count++;\\n                    dfs(i,j,grid);\\n                }\\n            }}\\n            return count;\\n        }\\n```\\n\\n   \\n            public void dfs(int row,int col,char[][]grid){\\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length && grid[row][col]==\\'1\\'){\\n                grid[row][col]=\\'0\\';\\n                dfs(row,col+1,grid);\\n                dfs(row,col-1,grid);\\n                dfs(row+1,col,grid);\\n                dfs(row-1,col,grid);\\n            }\\n            }\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/69d7a2d8-87f7-4e3c-b8ef-6ee98c7cf1d3_1684239408.367929.png)\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count++;\\n                    dfs(i,j,grid);\\n                }\\n            }}\\n            return count;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922610,
                "title": "easy-python-recursion-solution-120-ms-faster-than-99-99-of-python3",
                "content": "The idea is simple if we find a 1 we remove all it\\'s neibors recursively.\\n```\\n   def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for r,row in enumerate(grid):\\n            for c,col in enumerate(row):\\n                if grid[r][c] == \\'1\\':\\n                    self.removeNeighbors(r,c,grid)\\n                    count += 1\\n        return count            \\n    def removeNeighbors(self, r ,c, grid):\\n        grid[r][c] = 0\\n        if r+1 < len(grid) and grid[r+1][c] == \\'1\\':\\n            self.removeNeighbors(r+1,c,grid)\\n        if c+1 < len(grid[0]) and grid[r][c+1] == \\'1\\':\\n            self.removeNeighbors(r,c+1,grid)    \\n        if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n            self.removeNeighbors(r-1,c,grid)\\n        if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n            self.removeNeighbors(r,c-1,grid)   \\n```\\nIf you like my solution please hit the up vote button Thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n   def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for r,row in enumerate(grid):\\n            for c,col in enumerate(row):\\n                if grid[r][c] == \\'1\\':\\n                    self.removeNeighbors(r,c,grid)\\n                    count += 1\\n        return count            \\n    def removeNeighbors(self, r ,c, grid):\\n        grid[r][c] = 0\\n        if r+1 < len(grid) and grid[r+1][c] == \\'1\\':\\n            self.removeNeighbors(r+1,c,grid)\\n        if c+1 < len(grid[0]) and grid[r][c+1] == \\'1\\':\\n            self.removeNeighbors(r,c+1,grid)    \\n        if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n            self.removeNeighbors(r-1,c,grid)\\n        if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n            self.removeNeighbors(r,c-1,grid)   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334599,
                "title": "c-simple-and-short-easy-to-understand-clean-dfs-solution",
                "content": "We use DFS to turn each island to \\'0\\'s. If we found a \\'1\\', then we got to a new island and we can increase res.\\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int x, int y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == \\'0\\') return;\\n        \\n        grid[x][y] = \\'0\\';\\n        \\n        DFS(grid, x + 1, y);\\n        DFS(grid, x - 1, y);\\n        DFS(grid, x, y + 1);\\n        DFS(grid, x, y - 1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i <n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    res++;\\n                    DFS(grid, i, j);\\n                } \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int x, int y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == \\'0\\') return;\\n        \\n        grid[x][y] = \\'0\\';\\n        \\n        DFS(grid, x + 1, y);\\n        DFS(grid, x - 1, y);\\n        DFS(grid, x, y + 1);\\n        DFS(grid, x, y - 1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i <n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    res++;\\n                    DFS(grid, i, j);\\n                } \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499241,
                "title": "javascript-recursive-dfs-easy-to-understand",
                "content": "```\\n// Time complexity: O(mn)\\n// Space complexity: O(mn)\\n\\nvar numIslands = function(grid) {\\n\\tlet count = 0;\\n\\t\\n\\tfunction callDFS(grid, i, j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\n\\t\\tcallDFS(grid, i + 1, j); // down\\n\\t\\tcallDFS(grid, i - 1, j); // up\\n\\t\\tcallDFS(grid, i, j + 1); // right\\n\\t\\tcallDFS(grid, i, j - 1); // left\\n\\t}\\n\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[i].length; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\tcallDFS(grid, i, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n// Time complexity: O(mn)\\n// Space complexity: O(mn)\\n\\nvar numIslands = function(grid) {\\n\\tlet count = 0;\\n\\t\\n\\tfunction callDFS(grid, i, j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\n\\t\\tcallDFS(grid, i + 1, j); // down\\n\\t\\tcallDFS(grid, i - 1, j); // up\\n\\t\\tcallDFS(grid, i, j + 1); // right\\n\\t\\tcallDFS(grid, i, j - 1); // left\\n\\t}\\n\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[i].length; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\tcallDFS(grid, i, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167097,
                "title": "union-find",
                "content": ">If we define a 1 as a node, two nodes are connected if they are adjacent, `adjacent 1s surrounded by 0s` will be regarded as a connected component.\\n\\n> The problem becomes to find all connected components, which can we solved by Union Find.\\n\\n> The initial number of connected component should equal to the number of 1s. Then for each 1, we union it around. Each time we hit a union succesfully, the number of connected component will decrease by 1.\\n\\n```\\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private UF uf;\\n    private int rows, cols, countIslands;\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid.length == 0) return 0;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        uf = new UF(rows * cols);\\n        \\n        countIslands = 0;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                // If value 1, union with adjacent\\n                if (grid[x][y] == \\'1\\') {\\n                    countIslands++;\\n                    unionAround(x, y, grid);\\n                }\\n            }\\n        }\\n        \\n        return countIslands;\\n    }\\n    \\n    private void unionAround(int x, int y, char[][] grid) {\\n        int mark = x * cols + y;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == \\'1\\') {\\n                if (uf.union(nx * cols + ny, mark)) {\\n                    countIslands--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    class UF {\\n        int[] parent;\\n\\n        public UF(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]); // Path compression\\n        }\\n\\n        // Return false if x and y are in the same disjoint set already\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return false;\\n            }\\n            parent[rootX] = rootY;\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private UF uf;\\n    private int rows, cols, countIslands;\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid.length == 0) return 0;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        uf = new UF(rows * cols);\\n        \\n        countIslands = 0;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                // If value 1, union with adjacent\\n                if (grid[x][y] == \\'1\\') {\\n                    countIslands++;\\n                    unionAround(x, y, grid);\\n                }\\n            }\\n        }\\n        \\n        return countIslands;\\n    }\\n    \\n    private void unionAround(int x, int y, char[][] grid) {\\n        int mark = x * cols + y;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == \\'1\\') {\\n                if (uf.union(nx * cols + ny, mark)) {\\n                    countIslands--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    class UF {\\n        int[] parent;\\n\\n        public UF(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]); // Path compression\\n        }\\n\\n        // Return false if x and y are in the same disjoint set already\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return false;\\n            }\\n            parent[rootX] = rootY;\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499215,
                "title": "python-no-recursion-faster-than-82-less-than-98",
                "content": "**Appreciate if you could upvote this solution**\\n\\nmethod: `BFS`\\n```\\nScan the each element in the `grid`.\\n1)  element == \\'1\\'\\n\\t- assign \\'0\\' to element\\n\\t- island_count += 1\\n\\t- Scan the neigbhour lands and set to \\'0\\'\\n2)  value == \\'0\\':\\n    - continue\\n```\\t \\n\\nCode:\\n```\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        def is_valid(i, j):\\n            return True if 0 <= i < len_row and 0 <= j < len_col and grid[i][j] == \"1\" else False\\n                \\n        len_row, len_col = len(grid), len(grid[0])\\n        island_count = 0\\n        for row in range(len_row):\\n            for col in range(len_col):\\n                if is_valid(row, col):\\n                    island_count += 1\\n                    queue = deque([(row, col)])\\n                    while len(queue) != 0:\\n                        r, c = queue.popleft()\\n                        if grid[r][c] == \"1\":\\n                            grid[r][c] = \"0\"\\n                            for r_move, c_move in ((-1,0),(1,0),(0,1),(0,-1)):\\n                                if is_valid(r + r_move, c + c_move):\\n                                    queue.append((r + r_move, c + c_move))\\n\\n        return island_count\\n```\\n\\nFeel free to correct me if the complexity is wrong :)\\n**Time Complexity**: `O(n^2 * m^2)`\\n**Space Complexity**: `O(1)`\\n<br />",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nScan the each element in the `grid`.\\n1)  element == \\'1\\'\\n\\t- assign \\'0\\' to element\\n\\t- island_count += 1\\n\\t- Scan the neigbhour lands and set to \\'0\\'\\n2)  value == \\'0\\':\\n    - continue\\n```\n```\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        def is_valid(i, j):\\n            return True if 0 <= i < len_row and 0 <= j < len_col and grid[i][j] == \"1\" else False\\n                \\n        len_row, len_col = len(grid), len(grid[0])\\n        island_count = 0\\n        for row in range(len_row):\\n            for col in range(len_col):\\n                if is_valid(row, col):\\n                    island_count += 1\\n                    queue = deque([(row, col)])\\n                    while len(queue) != 0:\\n                        r, c = queue.popleft()\\n                        if grid[r][c] == \"1\":\\n                            grid[r][c] = \"0\"\\n                            for r_move, c_move in ((-1,0),(1,0),(0,1),(0,-1)):\\n                                if is_valid(r + r_move, c + c_move):\\n                                    queue.append((r + r_move, c + c_move))\\n\\n        return island_count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 426077,
                "title": "java-dfs-bfs-solutions-using-marked-array-queue",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/number-of-islands/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a 2d grid map of `\\'1\\'`s (land) and `\\'0\\'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands **horizontally** or **vertically**. You may assume all four edges of the grid are all surrounded by water.\\n\\n**Example:** \\n\\n```java\\nInput:\\n11110\\n11010\\n11000\\n00000\\nOutput: 1\\n\\nInput:\\n11000\\n11000\\n00100\\n00011\\nOutput: 3\\n```\\n\\n\\n## Analysis\\n\\n### DFS\\n\\nIt is very obvious that this problem can be solved by using an DFS approach.\\n\\n**Note:** Be careful of the conditions that we `dfs` a place, which include `boundary check` and `whether it is an island`.\\n\\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        dfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void dfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  marked[i][j] = true; // visit;\\n  for (int[] dir : direction) {\\n    int x = i + dir[0];\\n    int y = j + dir[1];\\n    if (x >= 0 && x < m && y >= 0 && y < n) {\\n      if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n        dfs(x, y, grid, marked, direction);\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(MN)`. If we modify the original `grid` array, can we reduce the complexity to `O(1)`? `No`. It is because `DFS` goes by a call stack.\\n\\n\\n\\n### BFS\\n\\nA similar idea based on `BFS` using a queue.\\n\\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        bfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void bfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  Queue<int[]> queue = new LinkedList<>();\\n  queue.offer(new int[] { i, j });\\n  marked[i][j] = true;\\n  // bfs\\n  while (queue.size() > 0) {\\n    int[] curr = queue.poll();\\n    for (int[] dir : direction) {\\n      int x = curr[0] + dir[0];\\n      int y = curr[1] + dir[1];\\n      if (x >= 0 && x < m && y >= 0 && y < n) {\\n        if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n          queue.offer(new int[] { x, y });\\n          marked[x][y] = true; // mark when enqueued\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(\\\\min{(M, N)})`. In the worst case where the grid is filled with lands, the size of queue can be `O(\\\\min{(M, N)})` as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/dmexf.jpg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\nInput:\\n11110\\n11010\\n11000\\n00000\\nOutput: 1\\n\\nInput:\\n11000\\n11000\\n00100\\n00011\\nOutput: 3\\n```\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        dfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void dfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  marked[i][j] = true; // visit;\\n  for (int[] dir : direction) {\\n    int x = i + dir[0];\\n    int y = j + dir[1];\\n    if (x >= 0 && x < m && y >= 0 && y < n) {\\n      if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n        dfs(x, y, grid, marked, direction);\\n      }\\n    }\\n  }\\n}\\n```\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        bfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void bfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  Queue<int[]> queue = new LinkedList<>();\\n  queue.offer(new int[] { i, j });\\n  marked[i][j] = true;\\n  // bfs\\n  while (queue.size() > 0) {\\n    int[] curr = queue.poll();\\n    for (int[] dir : direction) {\\n      int x = curr[0] + dir[0];\\n      int y = curr[1] + dir[1];\\n      if (x >= 0 && x < m && y >= 0 && y < n) {\\n        if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n          queue.offer(new int[] { x, y });\\n          marked[x][y] = true; // mark when enqueued\\n        }\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56622,
                "title": "python-dfs-solutions",
                "content": "        \\n    # overwrite original grid\\n    def numIslands1(self, grid):\\n        count = 0\\n        for r in xrange(len(grid)):\\n            for c in xrange(len(grid[0])):\\n                if grid[r][c] == \"1\":\\n                    count += 1\\n                    self.dfs(grid, r, c)\\n        return count\\n        \\n    def dfs1(self, grid, r, c):\\n        if not (0 <= r < len(grid)) or not (0 <= c < len(grid[0])) or grid[r][c] == \"0\":\\n            return \\n        grid[r][c] = \"0\"\\n        self.dfs(grid, r+1, c)\\n        self.dfs(grid, r-1, c)\\n        self.dfs(grid, r, c+1)\\n        self.dfs(grid, r, c-1)\\n    \\n    # add visited flags   \\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n        count = 0\\n        r, c = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(c)] for _ in xrange(r)]\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                if grid[i][j] == \"1\" and not visited[i][j]:\\n                    count += 1\\n                    self.dfs(grid, i, j, visited)\\n        return count\\n        \\n    def dfs(self, grid, i, j, visited):\\n        if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == \"0\" or visited[i][j]:\\n            return \\n        visited[i][j] = True\\n        self.dfs(grid, i+1, j, visited)\\n        self.dfs(grid, i-1, j, visited)\\n        self.dfs(grid, i, j+1, visited)\\n        self.dfs(grid, i, j-1, visited)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "        \\n    # overwrite original grid\\n    def numIslands1(self, grid):\\n        count = 0\\n        for r in xrange(len(grid)):\\n            for c in xrange(len(grid[0])):\\n                if grid[r][c] == \"1\":\\n                    count += 1\\n                    self.dfs(grid, r, c)\\n        return count\\n        \\n    def dfs1(self, grid, r, c):\\n        if not (0 <= r < len(grid)) or not (0 <= c < len(grid[0])) or grid[r][c] == \"0\":\\n            return \\n        grid[r][c] = \"0\"\\n        self.dfs(grid, r+1, c)\\n        self.dfs(grid, r-1, c)\\n        self.dfs(grid, r, c+1)\\n        self.dfs(grid, r, c-1)\\n    \\n    # add visited flags   \\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n        count = 0\\n        r, c = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(c)] for _ in xrange(r)]\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                if grid[i][j] == \"1\" and not visited[i][j]:\\n                    count += 1\\n                    self.dfs(grid, i, j, visited)\\n        return count\\n        \\n    def dfs(self, grid, i, j, visited):\\n        if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == \"0\" or visited[i][j]:\\n            return \\n        visited[i][j] = True\\n        self.dfs(grid, i+1, j, visited)\\n        self.dfs(grid, i-1, j, visited)\\n        self.dfs(grid, i, j+1, visited)\\n        self.dfs(grid, i, j-1, visited)",
                "codeTag": "Python3"
            },
            {
                "id": 583483,
                "title": "summarize-of-3-types-of-solution-methods",
                "content": "## solution 1\\uFF1ADFS/BFS\\n\\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: \\n            m,n = len(grid), len(grid[0])\\n        except: \\n            return 0\\n        cnt = 0\\n        ones = { (i,j) for i in range(m) for j in range(n) if grid[i][j]==\"1\" }\\n        while ones:\\n            queue = collections.deque([ ones.pop() ])\\n            while queue:\\n                i,j = queue.popleft()   # BFS\\n             # i,j = queue.pop()       # DFS\\n                for x,y in (i+1,j), (i-1,j), (i,j+1), (i,j-1):\\n                    if 0<=x<m and 0<=y<n and (x,y) in ones:\\n                        ones.discard( (x,y) )\\n                        queue.append( (x,y) )\\n            cnt += 1\\n        return cnt\\n```\\n\\nOR:\\n```python\\ncnt = 0\\nfor row in range(m):\\n    for col in range(n):\\n        if grid[row][col] == \"0\": continue  # notice it\\'s \"0\" not 0\\u2026\\u2026\\n        grid[row][col] = \"0\"\\n        queue = collections.deque([ (row,col) ])\\n        while queue:\\n            i,j = queue.popleft()  \\n            for x,y in (i-1,j), (i+1,j), (i,j-1), (i,j+1):\\n                if 0<=x<m and 0<=y<n and grid[x][y]==\"1\":\\n                    grid[x][y] = \"0\"\\n                    queue.append((x,y))\\n        cnt += 1\\n```\\n\\n### pretty pythonic code\\n```python\\ndef numIslands(self, grid):\\n    def sink(i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == \\'1\\':\\n            grid[i][j] = \\'0\\'\\n            map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n            return 1\\n        return 0\\n    return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n```\\n\\n## solution 2\\uFF1AUnion Find\\n\\n```python\\nclass Solution:\\n    def find_parent( self, ij ):\\n        if self.parent[ij] == ij: return ij\\n        self.parent[ij] = self.find_parent( self.parent[ij] )\\n        return self.parent[ij]\\n    \\n    def union( self, ij1, ij2):\\n        if not ij2 in self.parent: return   # border check & \"0\" both included\\n        p1, p2 = self.find_parent(ij1), self.find_parent(ij2)\\n        if p1 == p2: return\\n        if self.rank[p1] < self.rank[p2]: p1,p2 = p2,p1  # p1 <- p2\\n        self.parent[p2] = p1\\n        self.rank[p1] = max( self.rank[p1], self.rank[p2]+1 )\\n        \\n    \\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        try: m,n = len(grid), len(grid[0])\\n        except:  return 0\\n        \\n        self.parent, self.rank = {}, {}\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    self.parent[(i,j)] = (i,j)\\n                    self.rank[(i,j)] = 0\\n\\n        for i,j in self.parent.keys():\\n            for x,y in (i+1,j), (i,j+1):  self.union( (i,j), (x,y) )\\n                \\n        return len( set( self.find_parent(ij) for ij in self.parent.keys() ) )\\n```\\n\\n- use dictionary to implement `self.parent`\\uFF1A\\n    - can use `(i,j)` directly as key\\n    - no need for border check: border check & \"0\" both included in `i,j not in self.parent` \\n    - another method is to use `i*n+j` as index\\n\\n\\n\\n## solution 3\\n\\nEssentially still union find\\uFF0Cbut with additional tricks:\\n- `point_map` \\u2194 `parent`\\uFF0Cused to find parent\\n- `island_map` is the reverse of `point_map`\\uFF0Cused to find children\\uFF0Cwhich is not implemented is common Union Find.\\n\\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: m, n = len(grid), len(grid[0])\\n        except: return 0\\n        point_map, island_map = {}, {}\\n        num = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"0\": continue\\n                island1 = point_map.get( (i, j-1), None)\\n                island2 = point_map.get( (i-1, j), None)   \\n                if not island1 and not island2:\\n                    point_map[ (i, j) ] = num\\n                    island_map[num] = [ (i, j) ]\\n                    num += 1\\n                else:\\n                    if island1 and island2 and island1 != island2:\\n                        # island1 <- island2\\n                        if len(island_map[island1]) < len(island_map[island2]):  \\n                            island1,island2 = island2,island1   \\n                        for point in island_map[island2]:  point_map[point] = island1\\n                        island_map[island1] += island_map[island2]\\n                        island_map.pop(island2)\\n                        island2 = None\\n                    island = island1 or island2\\n                    point_map[(i, j)] = island\\n                    island_map[island].append((i, j))\\n                    \\n        return len(island_map)\\n```\\n\\n\\n\\n( Acknowledgement: Some pieces of code are learned from other\\'s post. I wrote this as a personal note a long time ago, so I didn\\'t record the source. Now I want to share it, but too lazy to find out the original posts. Contact me to add links to original posts if you wish. )\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: \\n            m,n = len(grid), len(grid[0])\\n        except: \\n            return 0\\n        cnt = 0\\n        ones = { (i,j) for i in range(m) for j in range(n) if grid[i][j]==\"1\" }\\n        while ones:\\n            queue = collections.deque([ ones.pop() ])\\n            while queue:\\n                i,j = queue.popleft()   # BFS\\n             # i,j = queue.pop()       # DFS\\n                for x,y in (i+1,j), (i-1,j), (i,j+1), (i,j-1):\\n                    if 0<=x<m and 0<=y<n and (x,y) in ones:\\n                        ones.discard( (x,y) )\\n                        queue.append( (x,y) )\\n            cnt += 1\\n        return cnt\\n```\n```python\\ncnt = 0\\nfor row in range(m):\\n    for col in range(n):\\n        if grid[row][col] == \"0\": continue  # notice it\\'s \"0\" not 0\\u2026\\u2026\\n        grid[row][col] = \"0\"\\n        queue = collections.deque([ (row,col) ])\\n        while queue:\\n            i,j = queue.popleft()  \\n            for x,y in (i-1,j), (i+1,j), (i,j-1), (i,j+1):\\n                if 0<=x<m and 0<=y<n and grid[x][y]==\"1\":\\n                    grid[x][y] = \"0\"\\n                    queue.append((x,y))\\n        cnt += 1\\n```\n```python\\ndef numIslands(self, grid):\\n    def sink(i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == \\'1\\':\\n            grid[i][j] = \\'0\\'\\n            map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n            return 1\\n        return 0\\n    return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n```\n```python\\nclass Solution:\\n    def find_parent( self, ij ):\\n        if self.parent[ij] == ij: return ij\\n        self.parent[ij] = self.find_parent( self.parent[ij] )\\n        return self.parent[ij]\\n    \\n    def union( self, ij1, ij2):\\n        if not ij2 in self.parent: return   # border check & \"0\" both included\\n        p1, p2 = self.find_parent(ij1), self.find_parent(ij2)\\n        if p1 == p2: return\\n        if self.rank[p1] < self.rank[p2]: p1,p2 = p2,p1  # p1 <- p2\\n        self.parent[p2] = p1\\n        self.rank[p1] = max( self.rank[p1], self.rank[p2]+1 )\\n        \\n    \\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        try: m,n = len(grid), len(grid[0])\\n        except:  return 0\\n        \\n        self.parent, self.rank = {}, {}\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    self.parent[(i,j)] = (i,j)\\n                    self.rank[(i,j)] = 0\\n\\n        for i,j in self.parent.keys():\\n            for x,y in (i+1,j), (i,j+1):  self.union( (i,j), (x,y) )\\n                \\n        return len( set( self.find_parent(ij) for ij in self.parent.keys() ) )\\n```\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: m, n = len(grid), len(grid[0])\\n        except: return 0\\n        point_map, island_map = {}, {}\\n        num = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"0\": continue\\n                island1 = point_map.get( (i, j-1), None)\\n                island2 = point_map.get( (i-1, j), None)   \\n                if not island1 and not island2:\\n                    point_map[ (i, j) ] = num\\n                    island_map[num] = [ (i, j) ]\\n                    num += 1\\n                else:\\n                    if island1 and island2 and island1 != island2:\\n                        # island1 <- island2\\n                        if len(island_map[island1]) < len(island_map[island2]):  \\n                            island1,island2 = island2,island1   \\n                        for point in island_map[island2]:  point_map[point] = island1\\n                        island_map[island1] += island_map[island2]\\n                        island_map.pop(island2)\\n                        island2 = None\\n                    island = island1 or island2\\n                    point_map[(i, j)] = island\\n                    island_map[island].append((i, j))\\n                    \\n        return len(island_map)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56588,
                "title": "standard-bfs-java-solution",
                "content": "DFS is faster I think, but this is my BFS solution:\\n\\n    public class Solution {\\n        int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        public int numIslands(char[][] grid) {\\n            if(grid==null || grid.length==0) return 0;\\n            int islands = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        islands++;\\n                        BFS(grid,i,j);\\n                    }\\n                }\\n            }\\n            return islands;\\n        }\\n        private void BFS(char[][] grid, int x, int y){\\n            grid[x][y] = '0';\\n            Queue<Point> q = new LinkedList<Point>();\\n            q.offer(new Point(x,y));\\n            while(q.size()>0){\\n                int size = q.size();\\n                Point p = q.poll();\\n                for(int i=0;i<size;i++){\\n                    for(int[] dir:dirs){\\n                        int x1 = p.x+dir[0];\\n                        int y1 = p.y+dir[1];\\n                        if(x1>=0 && y1>=0 && x1< grid.length && y1<grid[0].length && grid[x1][y1]=='1'){\\n                            grid[x1][y1] = '0';\\n                            q.offer(new Point(x1,y1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    class Point{\\n        int x;\\n        int y;\\n        Point(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int[][] dirs = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 1284203,
                "title": "java-c-python-dfs-solution",
                "content": "# **Explanation**\\nDFS to search an island\\nreturn 1 if and only if we find an island.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numIslands(char[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    private int dfs(char[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\\n**C++**\\n```cpp\\n    int numIslands(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<char>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def numIslands(self, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == \\'1\\'): return 0\\n            A[i][j] = \\'0\\'\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                dfs(i + di, j + dj)\\n            return 1\\n\\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j] == \"1\")\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numIslands(char[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    private int dfs(char[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\n```cpp\\n    int numIslands(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<char>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\n```py\\n    def numIslands(self, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == \\'1\\'): return 0\\n            A[i][j] = \\'0\\'\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                dfs(i + di, j + dj)\\n            return 1\\n\\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j] == \"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56407,
                "title": "what-if-we-can-only-read-line-by-line-real-interview-question-in-yahoo",
                "content": "This question itself is a very common DFS.\\nI give an answer when I was having interview in Yahoo, Flickr in seconds.\\n\\nThen the following up is, what if the matrix is very big?\\nThe interviewer might want an answer around like sparse matrix. But I come out a naive thinking of **read line by line.** I did not work it out in interview in 30 mins. But I did not give up after interview. Now I think I got a way. As following.\\n\\nI use a concept of \"color\", which is still a kind of dfs. But the connection is implemented by hashtable and the size of hashtable is limited to O(n). So, it's O(n) space complexity in all.(rather than O(n^2))\\n\\n\\nLet me explain it as following:\\n\"1111111\"\\n\"0000001\"\\n\"1111101\"\\n\"1000101\"\\n\"1010101\"\\n\"1011101\"\\n\"1111111\"\\nSuppose a matrix as above. We are gonna read them one line each time.\\n\\nline 0-1\\n\"1111111\"\\n\"0000001\"\\nland in Line 1 is colored by island in line 0 as island 1.\\n\\nline 1-2\\n\"0000001\"\\n\"2222201\"\\n***Line 2 is colored by island in line 1 and got another island. Will the another island be colored later? Let's see.***\\n\\nline 2-3\\n\"2222201\"\\n\"2000201\"\\n***Similar as above***\\n\\nline 3-4\\n\"2000201\"\\n\"2030201\"\\n***Similar as above. Now we got island 3.We count as we have 3 islands in total.***\\n\\nline 4-5\\n\"3(2)0303(2)01\"\\n\"3(2)033301\"\\n***Here, we found island 3 and island 2 are connected! So we color all island 2 to island 3(vice versa is also available) and minus 1 in our count of island***\\n\\nline 5-6\\n\"3033303(1)\"\\n\"3333333\"\\n***Then island 1 and island 3 are connected, we minus 1 on total again!***\\n\\nThen we got island total as 1!\\n\\n\\n```python\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #Increase itself\\n        c = 0\\n        \\n        def generateInterval(line):\\n            invArr = []\\n            i = 0\\n            while i<len(line):\\n                if line[i] == '1':\\n                    newInv = {'start':i}\\n                    while i<len(line) and line[i] == '1' :\\n                        i+=1\\n                    newInv['end'] = (i-1)\\n                    invArr.append(newInv)\\n                i += 1\\n            return invArr\\n            \\n        lastLineInvArr = []\\n         \\n        islandColorId = 1\\n        for line in grid:\\n            p = 0\\n            curInvArr = generateInterval(line)\\n            \\n            colorTransMap = {}\\n            j = 0\\n            for j in range(0, len(curInvArr)):\\n                curInv = curInvArr[j]\\n                while p<len(lastLineInvArr) and lastLineInvArr[p]['end']<curInv['start']:\\n                    p += 1\\n                \\n                if p>=len(lastLineInvArr):\\n                    break\\n                \\n                if curInv['end'] < lastLineInvArr[p]['start']:\\n                    c += 1\\n                    curInv['color'] = islandColorId\\n                    islandColorId+=1\\n                    continue\\n                \\n                while p<len(lastLineInvArr) and curInv['end']>=lastLineInvArr[p]['start']:\\n                    if not 'color' in curInv:\\n                        if lastLineInvArr[p]['color'] in colorTransMap:\\n                            lastLineInvArr[p]['color'] = colorTransMap[lastLineInvArr[p]['color']]\\n                        curInv['color'] = lastLineInvArr[p]['color']\\n                    else:\\n                        if not lastLineInvArr[p]['color']==curInv['color'] and lastLineInvArr[p]['color'] not in colorTransMap:\\n                            c -= 1\\n                            colorTransMap[lastLineInvArr[p]['color']] = curInv['color']\\n                            lastLineInvArr[p]['color'] = curInv['color']\\n                        \\n                    if curInv['end'] >= lastLineInvArr[p]['end']:\\n                        p+=1\\n                    else:\\n                        break\\n            \\n            while j<len(curInvArr):\\n                if 'color' not in curInvArr[j]:\\n                    c += 1\\n                    curInvArr[j]['color'] = islandColorId\\n                    islandColorId += 1\\n                j += 1\\n        \\n            for curInv in curInvArr:\\n                if curInv['color'] in colorTransMap:\\n                    curInv['color'] = colorTransMap[curInv['color']]    \\n            \\n            lastLineInvArr = curInvArr\\n                  \\n        return c\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #Increase itself\\n        c = 0\\n        \\n        def generateInterval(line):\\n            invArr = []\\n            i = 0\\n            while i<len(line):\\n                if line[i] == '1':\\n                    newInv = {'start':i}\\n                    while i<len(line) and line[i] == '1' :\\n                        i+=1\\n                    newInv['end'] = (i-1)\\n                    invArr.append(newInv)\\n                i += 1\\n            return invArr\\n            \\n        lastLineInvArr = []\\n         \\n        islandColorId = 1\\n        for line in grid:\\n            p = 0\\n            curInvArr = generateInterval(line)\\n            \\n            colorTransMap = {}\\n            j = 0\\n            for j in range(0, len(curInvArr)):\\n                curInv = curInvArr[j]\\n                while p<len(lastLineInvArr) and lastLineInvArr[p]['end']<curInv['start']:\\n                    p += 1\\n                \\n                if p>=len(lastLineInvArr):\\n                    break\\n                \\n                if curInv['end'] < lastLineInvArr[p]['start']:\\n                    c += 1\\n                    curInv['color'] = islandColorId\\n                    islandColorId+=1\\n                    continue\\n                \\n                while p<len(lastLineInvArr) and curInv['end']>=lastLineInvArr[p]['start']:\\n                    if not 'color' in curInv:\\n                        if lastLineInvArr[p]['color'] in colorTransMap:\\n                            lastLineInvArr[p]['color'] = colorTransMap[lastLineInvArr[p]['color']]\\n                        curInv['color'] = lastLineInvArr[p]['color']\\n                    else:\\n                        if not lastLineInvArr[p]['color']==curInv['color'] and lastLineInvArr[p]['color'] not in colorTransMap:\\n                            c -= 1\\n                            colorTransMap[lastLineInvArr[p]['color']] = curInv['color']\\n                            lastLineInvArr[p]['color'] = curInv['color']\\n                        \\n                    if curInv['end'] >= lastLineInvArr[p]['end']:\\n                        p+=1\\n                    else:\\n                        break\\n            \\n            while j<len(curInvArr):\\n                if 'color' not in curInvArr[j]:\\n                    c += 1\\n                    curInvArr[j]['color'] = islandColorId\\n                    islandColorId += 1\\n                j += 1\\n        \\n            for curInv in curInvArr:\\n                if curInv['color'] in colorTransMap:\\n                    curInv['color'] = colorTransMap[curInv['color']]    \\n            \\n            lastLineInvArr = curInvArr\\n                  \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56627,
                "title": "short-accepted-cpp-code",
                "content": "   \\n\\n     void DFS(vector<vector<char>>& grid, int i, int j){\\n    \\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\\n    \\t    if('0' == grid[i][j]) return;\\n    \\t    grid[i][j] = '0';\\n    \\t    DFS(grid, i-1, j);\\n    \\t    DFS(grid, i+1, j);\\n    \\t    DFS(grid, i, j - 1);\\n    \\t    DFS(grid, i, j + 1);\\n    \\t}\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tint counter = 0;\\n    \\t\\tfor (int i = 0; i < grid.size(); ++i)\\n    \\t\\t\\tfor (int j = 0; j < grid[i].size(); ++j)\\n    \\t\\t\\t\\tif ('1' == grid[i][j])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t++counter;\\n    \\t\\t\\t\\t\\tDFS(grid, i, j);\\n    \\t\\t\\t\\t}\\n    \\t\\treturn counter;\\n    \\t}",
                "solutionTags": [
                    "C++"
                ],
                "code": "   \\n\\n     void DFS(vector<vector<char>>& grid, int i, int j){\\n    \\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\\n    \\t    if('0' == grid[i][j]) return;\\n    \\t    grid[i][j] = '0';\\n    \\t    DFS(grid, i-1, j);\\n    \\t    DFS(grid, i+1, j);\\n    \\t    DFS(grid, i, j - 1);\\n    \\t    DFS(grid, i, j + 1);\\n    \\t}\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tint counter = 0;\\n    \\t\\tfor (int i = 0; i < grid.size(); ++i)\\n    \\t\\t\\tfor (int j = 0; j < grid[i].size(); ++j)\\n    \\t\\t\\t\\tif ('1' == grid[i][j])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t++counter;\\n    \\t\\t\\t\\t\\tDFS(grid, i, j);\\n    \\t\\t\\t\\t}\\n    \\t\\treturn counter;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 903663,
                "title": "two-js-solutions",
                "content": "```\\nvar numIslands = function(grid) {\\n    if (grid.length <= 0) return 0;\\n    let count = 0, DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \\'1\\') { // there is no chance \\'0\\' is part of an island\\n                traverse(row, col); // once this finishes, we\\'ve visited all lands of one island\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n    \\n    // DFS Traversal\\n    function traverse(row, col) {\\n        if (row < 0 || row >= height || col < 0 || \\n            col >= width || grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        grid[row][col] = \"0\"; // turn land to water since we already visited it\\n        for (let dir of DIRECTIONS) {\\n            traverse(row+dir[0],col+dir[1]);\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), if the entire grid is one island, it will take up m*n space in function call stack\\n};\\n```\\n\\n```\\nvar numIslands = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    const DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \"1\") {\\n                count++;\\n                traverse([[row,col]]);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n    // BFS Traversal\\n    function traverse(queue) {\\n        while (queue.length > 0) {\\n            let [row, col] = queue.shift();\\n            if (row < 0 || row >= height || col < 0 || col >= width \\n                || grid[row][col] == \\'0\\') continue;\\n            grid[row][col] = \"0\"; // mark so that we know we already visited it\\n            for (let dir of DIRECTIONS) {\\n                queue.push([row+dir[0], col+dir[1]]);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), queue might contain m*n elements if the entire grid is one island\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIslands = function(grid) {\\n    if (grid.length <= 0) return 0;\\n    let count = 0, DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \\'1\\') { // there is no chance \\'0\\' is part of an island\\n                traverse(row, col); // once this finishes, we\\'ve visited all lands of one island\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n    \\n    // DFS Traversal\\n    function traverse(row, col) {\\n        if (row < 0 || row >= height || col < 0 || \\n            col >= width || grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        grid[row][col] = \"0\"; // turn land to water since we already visited it\\n        for (let dir of DIRECTIONS) {\\n            traverse(row+dir[0],col+dir[1]);\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), if the entire grid is one island, it will take up m*n space in function call stack\\n};\\n```\n```\\nvar numIslands = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    const DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \"1\") {\\n                count++;\\n                traverse([[row,col]]);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n    // BFS Traversal\\n    function traverse(queue) {\\n        while (queue.length > 0) {\\n            let [row, col] = queue.shift();\\n            if (row < 0 || row >= height || col < 0 || col >= width \\n                || grid[row][col] == \\'0\\') continue;\\n            grid[row][col] = \"0\"; // mark so that we know we already visited it\\n            for (let dir of DIRECTIONS) {\\n                queue.push([row+dir[0], col+dir[1]]);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), queue might contain m*n elements if the entire grid is one island\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56523,
                "title": "java-concise-dfs-solution",
                "content": "        \\n    public int numIslands(char[][] grid) {\\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == '1') {\\n                    ret++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void dfs(char[][] grid, int m, int n) {\\n        if (m < 0 || m >= grid.length || n < 0 || n >= grid[0].length || grid[m][n] != '1') {\\n            return;\\n        }\\n        grid[m][n] = '#';\\n        dfs(grid, m+1, n);\\n        dfs(grid, m-1, n);\\n        dfs(grid, m, n+1);\\n        dfs(grid, m, n-1);\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "        \\n    public int numIslands(char[][] grid) {\\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == '1') {\\n                    ret++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void dfs(char[][] grid, int m, int n) {\\n        if (m < 0 || m >= grid.length || n < 0 || n >= grid[0].length || grid[m][n] != '1') {\\n            return;\\n        }\\n        grid[m][n] = '#';\\n        dfs(grid, m+1, n);\\n        dfs(grid, m-1, n);\\n        dfs(grid, m, n+1);\\n        dfs(grid, m, n-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295066,
                "title": "c-dfs-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //dfs + recursive\\n    //time: o(row * column)\\n    //space: o(row)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\\n                }   \\n            }  \\n        }\\n        return count_of_islands;\\n    }\\nprivate:\\n    //dfs to mark every grid in this island.\\n    int dfs(vector<vector<char>>& grid, int row, int col) {\\n        grid[row][col] = \\'2\\';\\n        for(auto d : dir) {\\n            int next_row = row + d.first;\\n            int next_col = col + d.second;\\n            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == \\'1\\') {\\n                dfs(grid, next_row, next_col);\\n            }   \\n        }\\n        return 0;\\n    }\\nprivate:\\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\\n};\\n\\n//2.bfs\\nclass Solution {\\npublic:\\n    //bfs + iterative\\n    //time: o(row * column)\\n    //space: o(column)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    std::queue<pair<int, int>> bfs_que;//<row, column>\\n                    grid[row][col] = \\'2\\';\\n                    bfs_que.push(make_pair(row, col));\\n                    while(!bfs_que.empty()) {\\n                        std::pair<int, int> visited_node = bfs_que.front();\\n                        bfs_que.pop();\\n                        for(auto d : dir) {\\n                            int next_row = visited_node.first + d.first;\\n                            int next_col = visited_node.second + d.second;\\n                            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == \\'1\\') {\\n                                grid[next_row][next_col] = \\'2\\';\\n                                bfs_que.push(make_pair(next_row, next_col));\\n                            }\\n                            \\n                        }\\n                    }\\n                }   \\n            }  \\n        }\\n        return count_of_islands;\\n    }\\n\\nprivate:\\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    //dfs + recursive\\n    //time: o(row * column)\\n    //space: o(row)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56575,
                "title": "python-iterative-recursive-bfs-dfs",
                "content": "I first used a \"visited\" set to store visited point, and then I found my old implementation set the visited point to \"2\", as posted. Then I was confused, isn't string immutable?\\n\\nProblem solved: input are not list of strings.\\n\\n    def numIslands(self, grid):\\n        # BFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    for ii,jj in stack:\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        # DFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        ii, jj = stack.pop()\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        ## recursive DFS\\n        def dfs(grid, i,j):\\n            if 0<=i<m and 0<=j<n and grid[i][j] == \"1\":\\n                grid[i][j] = \"2\"\\n                dfs(grid, i-1, j)\\n                dfs(grid, i+1, j)\\n                dfs(grid, i, j-1)\\n                dfs(grid, i, j+1)\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    dfs(grid, i, j)\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "I first used a \"visited\" set to store visited point, and then I found my old implementation set the visited point to \"2\", as posted. Then I was confused, isn't string immutable?\\n\\nProblem solved: input are not list of strings.\\n\\n    def numIslands(self, grid):\\n        # BFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    for ii,jj in stack:\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        # DFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        ii, jj = stack.pop()\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        ## recursive DFS\\n        def dfs(grid, i,j):\\n            if 0<=i<m and 0<=j<n and grid[i][j] == \"1\":\\n                grid[i][j] = \"2\"\\n                dfs(grid, i-1, j)\\n                dfs(grid, i+1, j)\\n                dfs(grid, i, j-1)\\n                dfs(grid, i, j+1)\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    dfs(grid, i, j)\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 56383,
                "title": "my-accepted-c-solution-may-be-trivial",
                "content": "    class Solution {\\n    public:\\n        void contaminate(vector<vector<char> > &grid, int i, int j){\\n            if(i>0&&grid[i-1][j]=='1'){\\n                grid[i-1][j]='0';\\n                contaminate(grid, i-1, j);\\n            }\\n            if(j>0&&grid[i][j-1]=='1'){\\n                grid[i][j-1]='0';\\n                contaminate(grid, i, j-1);\\n            }\\n            if(i<grid.size()-1&&grid[i+1][j]=='1'){\\n                grid[i+1][j]='0';\\n                contaminate(grid, i+1, j);\\n            }\\n            if(j<grid[0].size()-1&&grid[i][j+1]=='1'){\\n                grid[i][j+1]='0';\\n                contaminate(grid, i, j+1);\\n            }\\n        }\\n        int numIslands(vector<vector<char>> &grid) {\\n            int n=grid.size();\\n            if(n==0) return 0;\\n            int m=grid[0].size();\\n            \\n            int cnt=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(grid[i][j]=='1'){\\n                        cnt++;\\n                        contaminate(grid, i, j);\\n                    }\\n                }\\n            }\\n            return cnt;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void contaminate(vector<vector<char> > &grid, int i, int j){\\n            if(i>0&&grid[i-1][j]=='1'){\\n                grid[i-1][j]='0';\\n                contaminate(grid, i-1, j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874609,
                "title": "c-very-very-simple-code-easy-to-understand-tc-o-n-m-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n\\nFollow me on Github for Daily Leetcode Solution: [https://github.com/anant0059]()\\n\\n```\\nvoid Island(vector<vector<char>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        Island(grid, i+1, j);\\n        Island(grid, i-1, j);\\n        Island(grid, i, j+1);\\n        Island(grid,  i, j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==\\'1\\'){\\n                    ans++;\\n                    Island(grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nThe extension of this question is [Max Area of Island.](https://leetcode.com/problems/max-area-of-island/) After little changes in the above solution we can evaluate this question also.\\n```\\nint area(vector<vector<int>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1 || grid[i][j]==0 ) return 0;\\n        grid[i][j]=-1;\\n        return 1+area(grid, i+1, j)+area(grid, i-1, j)+area(grid, i, j+1)+area(grid,  i, j-1);\\n    }\\n    \\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,area(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid Island(vector<vector<char>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        Island(grid, i+1, j);\\n        Island(grid, i-1, j);\\n        Island(grid, i, j+1);\\n        Island(grid,  i, j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==\\'1\\'){\\n                    ans++;\\n                    Island(grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\nint area(vector<vector<int>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1 || grid[i][j]==0 ) return 0;\\n        grid[i][j]=-1;\\n        return 1+area(grid, i+1, j)+area(grid, i-1, j)+area(grid, i, j+1)+area(grid,  i, j-1);\\n    }\\n    \\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,area(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584060,
                "title": "javascript-using-simple-dfs-beats-99-speed-97-memory",
                "content": "```\\nvar numIslands = function(grid) {\\n    \\n    const callDFS = (i, j) => {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] === \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        callDFS(i-1, j); // up\\n        callDFS(i+1, j); // down\\n        callDFS(i, j-1); // left\\n        callDFS(i, j+1); // right\\n    }\\n    \\n    let count = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        \\n        for(let j = 0; j < grid[i].length; j++) {\\n            \\n            if(grid[i][j] === \\'1\\') {\\n                count++;\\n                callDFS(i, j)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar numIslands = function(grid) {\\n    \\n    const callDFS = (i, j) => {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] === \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        callDFS(i-1, j); // up\\n        callDFS(i+1, j); // down\\n        callDFS(i, j-1); // left\\n        callDFS(i, j+1); // right\\n    }\\n    \\n    let count = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        \\n        for(let j = 0; j < grid[i].length; j++) {\\n            \\n            if(grid[i][j] === \\'1\\') {\\n                count++;\\n                callDFS(i, j)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182838,
                "title": "readable-javascript-solution",
                "content": "60ms DFS solution\n\n```\nfunction numIslands(grid) {\n  let count = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(grid, i,j);\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction dfs(grid, row, col) {\n  // bound check\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n\n  const value = grid[row][col];\n  if (value === '1') {\n    grid[row][col] = '#';\n    dfs(grid, row + 1, col);\n    dfs(grid, row - 1, col);\n    dfs(grid, row, col + 1);\n    dfs(grid, row, col - 1);\n  }\n}\n```",
                "solutionTags": [],
                "code": "```\nfunction numIslands(grid) {\n  let count = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(grid, i,j);\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction dfs(grid, row, col) {\n  // bound check\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n\n  const value = grid[row][col];\n  if (value === '1') {\n    grid[row][col] = '#';\n    dfs(grid, row + 1, col);\n    dfs(grid, row - 1, col);\n    dfs(grid, row, col + 1);\n    dfs(grid, row, col - 1);\n  }\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56339,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static void DFS(char[][] grid, int i, int j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n\\t\\t\\treturn;\\n\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\tgrid[i][j] = '2';\\n\\t\\t\\tDFS(grid, i + 1, j);\\n\\t\\t\\tDFS(grid, i - 1, j);\\n\\t\\t\\tDFS(grid, i, j + 1);\\n\\t\\t\\tDFS(grid, i, j - 1);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint row = grid.length, column = grid[0].length, count = 0;\\n\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\tfor (int j = 0; j < column; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tDFS(grid, i, j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\tpublic static void DFS(char[][] grid, int i, int j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n\\t\\t\\treturn;\\n\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\tgrid[i][j] = '2';\\n\\t\\t\\tDFS(grid, i + 1, j);\\n\\t\\t\\tDFS(grid, i - 1, j);\\n\\t\\t\\tDFS(grid, i, j + 1);\\n\\t\\t\\tDFS(grid, i, j - 1);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint row = grid.length, column = grid[0].length, count = 0;\\n\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\tfor (int j = 0; j < column; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tDFS(grid, i, j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1386594,
                "title": "easy-to-understand-dfs-solution-in-python",
                "content": "In this problem we just have to count number of Island . the 1\\'s are island and 0\\'s are water(or simply not a island.)\\nIf we find a 1\\'s then we check for all 1\\'s connected to it and accordingly increment our ans.\\n**Note: single 1 is also a island in itself**\\n``` \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid: return 0\\n        \\n        def DO_DFS(grid, row, col):\\n\\t\\t\\t# base case of this problem . checking for boundary condition .\\n\\t\\t\\t# so that our DFS couldn\\'t cross the boundary of the grid\\n            if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == \\'1\\':\\n                grid[row][col] = \\'0\\'\\n                # performing DFS on all 4 direction \\n                DO_DFS(grid, row+1, col)\\n                DO_DFS(grid, row-1, col)\\n                DO_DFS(grid, row, col+1)\\n                DO_DFS(grid, row, col-1)\\n        \\n        isLand = 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == \\'1\\':\\n                    DO_DFS(grid, row, col)\\n                    isLand += 1\\n        return isLand\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "``` \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid: return 0\\n        \\n        def DO_DFS(grid, row, col):\\n\\t\\t\\t# base case of this problem . checking for boundary condition .\\n\\t\\t\\t# so that our DFS couldn\\'t cross the boundary of the grid\\n            if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == \\'1\\':\\n                grid[row][col] = \\'0\\'\\n                # performing DFS on all 4 direction \\n                DO_DFS(grid, row+1, col)\\n                DO_DFS(grid, row-1, col)\\n                DO_DFS(grid, row, col+1)\\n                DO_DFS(grid, row, col-1)\\n        \\n        isLand = 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == \\'1\\':\\n                    DO_DFS(grid, row, col)\\n                    isLand += 1\\n        return isLand\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264826,
                "title": "python-dfs-bfs",
                "content": "The problem asks the number of connected \\'1\\' in the grid. \\nSo once we find a \\'1\\', we can use dfs or bfs to flipped all connected \\'1\\' to \\'0\\'. The times of finding a new \\'1\\' would be the number of islands.\\n```\\ndef numIslands(grid):\\n\\tm, n = len(grid), len(grid) and len(grid[0])\\n\\tdef dfs(i,j):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] == \\'1\\':\\n\\t\\t\\tgrid[i][j] = \\'0\\'\\n\\t\\t\\tdfs(i-1, j), dfs(i+1, j), dfs(i, j-1), dfs(i, j+1)\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\t\\t\\n\\tdef bfs(i, j):\\n\\t\\tq, grid[i][j] = [(i, j)], \"0\"\\n\\t\\tfor i, j in q:\\n\\t\\t\\tfor x, y in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and grid[x][y] == \"1\":\\n\\t\\t\\t\\t\\tgrid[x][y] = \"0\"\\n\\t\\t\\t\\t\\tq.append((x, y))\\n\\t\\treturn 1\\n\\t\\t\\t\\n\\t# return sum(dfs(i,j) for i in range(m) for j in range(n))\\n\\treturn sum(bfs(i,j) for i in range(m) for j in range(n) if grid[i][j] == \"1\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numIslands(grid):\\n\\tm, n = len(grid), len(grid) and len(grid[0])\\n\\tdef dfs(i,j):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] == \\'1\\':\\n\\t\\t\\tgrid[i][j] = \\'0\\'\\n\\t\\t\\tdfs(i-1, j), dfs(i+1, j), dfs(i, j-1), dfs(i, j+1)\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\t\\t\\n\\tdef bfs(i, j):\\n\\t\\tq, grid[i][j] = [(i, j)], \"0\"\\n\\t\\tfor i, j in q:\\n\\t\\t\\tfor x, y in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and grid[x][y] == \"1\":\\n\\t\\t\\t\\t\\tgrid[x][y] = \"0\"\\n\\t\\t\\t\\t\\tq.append((x, y))\\n\\t\\treturn 1\\n\\t\\t\\t\\n\\t# return sum(dfs(i,j) for i in range(m) for j in range(n))\\n\\treturn sum(bfs(i,j) for i in range(m) for j in range(n) if grid[i][j] == \"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2615684,
                "title": "c-dfs-bfs-easy-to-understand",
                "content": "Number of Islands\\n \\n **1) DFS -**\\n \\n```\\n class Solution {\\npublic:   \\n    void dfs(int r, int c, vector<vector<char>>& grid)\\n    {\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==\\'0\\')\\n        {\\n            return ;\\n        }      \\n        grid[r][c]=\\'0\\';\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    ans++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2) BFS -**\\n\\n```\\nclass Solution {\\npublic:   \\n    void bfs(int r, int c, vector<vector<int>>& vis, vector<vector<char>> grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vis[r][c]=1;\\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        while(!q.empty())\\n        {\\n            r = q.front().first;\\n            c = q.front().second;\\n            q.pop();\\n            for(int i=-1;i<=1;i++)\\n            {\\n                for(int j=-1;j<=1;j++)\\n                {\\n                    if(abs(i)==abs(j)){continue;}\\n                    int newr = r + i;\\n                    int newc = c + j;\\n                    if(newr>=0 && newr<n && newc>=0 && newc<m && \\n                       grid[newr][newc]==\\'1\\' && vis[newr][newc]==0)\\n                    {\\n                        q.push({newr,newc});\\n                        vis[newr][newc]=1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\' && vis[i][j]==0)\\n                {\\n                    ans++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n      return ans;  \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:   \\n    void dfs(int r, int c, vector<vector<char>>& grid)\\n    {\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==\\'0\\')\\n        {\\n            return ;\\n        }      \\n        grid[r][c]=\\'0\\';\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    ans++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:   \\n    void bfs(int r, int c, vector<vector<int>>& vis, vector<vector<char>> grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vis[r][c]=1;\\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        while(!q.empty())\\n        {\\n            r = q.front().first;\\n            c = q.front().second;\\n            q.pop();\\n            for(int i=-1;i<=1;i++)\\n            {\\n                for(int j=-1;j<=1;j++)\\n                {\\n                    if(abs(i)==abs(j)){continue;}\\n                    int newr = r + i;\\n                    int newc = c + j;\\n                    if(newr>=0 && newr<n && newc>=0 && newc<m && \\n                       grid[newr][newc]==\\'1\\' && vis[newr][newc]==0)\\n                    {\\n                        q.push({newr,newc});\\n                        vis[newr][newc]=1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\' && vis[i][j]==0)\\n                {\\n                    ans++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499050,
                "title": "super-simple-wicked-fast-100",
                "content": "**Algorithm:**\\n\\n*Valid islands in this 2D binary grid:*\\n\\n![image](https://assets.leetcode.com/users/images/9075c92d-92a8-4163-bd86-4c60b04df081_1661761222.0268018.png)\\n\\n\\n*1.We will maintain an array called \\u201Cislands\\u201D which will record the no. of islands visited.\\n2. Traverse through each element of the grid.\\n3. Check, if it is a land and it has not been visited yet i.e. grid[i][j] == 1, increment islands and change the value of that element to water i.e. 0.\\n4. Change the adjacent elements to water i.e. \\'0\\'.*\\n\\n```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int islands = 0; // It will store the no. of islands in 2D grid\\n        \\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        for(int i=0; i<rows; i++){\\n            \\n            for(int j=0; j<cols; j++){\\n                \\n                if(grid[i][j] == \\'1\\'){\\n                    \\n                    islands++;\\n                    \\n                    globalWarming(grid, i, j, rows, cols);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n    \\n    // This function changes all the adjacent 1\\'s to 0 because they all are part of the \\n    // same island\\n    \\n    // I have named it globalWarming because it is used to sink the adjacent islands\\n    \\n     void globalWarming(vector<vector<char>>& grid, int i, int j, int rows, int cols){\\n        \\n        if(i<0 || i>=rows || j<0 || j>=cols || grid[i][j]==\\'0\\'){\\n            return;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        globalWarming(grid, i+1, j, rows, cols);\\n        globalWarming(grid, i-1, j, rows, cols);\\n        globalWarming(grid, i, j+1, rows, cols);\\n        globalWarming(grid, i, j-1, rows, cols);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e441de6f-62bf-4f43-9c24-949620a9fe78_1661763503.2784755.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int islands = 0; // It will store the no. of islands in 2D grid\\n        \\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        for(int i=0; i<rows; i++){\\n            \\n            for(int j=0; j<cols; j++){\\n                \\n                if(grid[i][j] == \\'1\\'){\\n                    \\n                    islands++;\\n                    \\n                    globalWarming(grid, i, j, rows, cols);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n    \\n    // This function changes all the adjacent 1\\'s to 0 because they all are part of the \\n    // same island\\n    \\n    // I have named it globalWarming because it is used to sink the adjacent islands\\n    \\n     void globalWarming(vector<vector<char>>& grid, int i, int j, int rows, int cols){\\n        \\n        if(i<0 || i>=rows || j<0 || j>=cols || grid[i][j]==\\'0\\'){\\n            return;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        globalWarming(grid, i+1, j, rows, cols);\\n        globalWarming(grid, i-1, j, rows, cols);\\n        globalWarming(grid, i, j+1, rows, cols);\\n        globalWarming(grid, i, j-1, rows, cols);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497913,
                "title": "striver-s-solution-ac-bfs-visited-matrix-4-directions",
                "content": "\\nDifferences in code present in video and this one:\\n- in the video he has taken all 8 neighours in consideration but here we only need 4 neighbours\\n\\nWorking code: \\n\\n```\\n\\nclass Solution\\n{\\nprivate:\\n    void bfs(int row, int col, vector<vector<int>> &visited, vector<vector<char>> &grid, int delta_row[], int delta_col[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        visited[row][col] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n\\n        while (!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int neighbour_row = r + delta_row[i];\\n                int neighbour_col = c + delta_col[i];\\n\\n                // for each neighbour check boundary\\n                if (neighbour_row >= 0 && neighbour_row < n && neighbour_col >= 0 && neighbour_col < m)\\n                {\\n                    // check for land and prev visited\\n                    if (grid[neighbour_row][neighbour_col] == \\'1\\' && !visited[neighbour_row][neighbour_col])\\n                    {\\n                        visited[neighbour_row][neighbour_col] = 1;\\n                        q.push({neighbour_row, neighbour_col});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        int ans = 0;\\n        int delta_row[] = {-1, 0, 1, 0};\\n        int delta_col[] = {0, 1, 0, -1};\\n\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < m; c++)\\n                if (!visited[r][c] && grid[r][c] == \\'1\\')\\n                {\\n                    ++ans;\\n                    bfs(r, c, visited, grid, delta_row, delta_col);\\n                }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nStriver\\'s video can be found [here](https://youtu.be/muncqlKJrH0)\\n\\nIf this post helped you, kindly upvote!\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution\\n{\\nprivate:\\n    void bfs(int row, int col, vector<vector<int>> &visited, vector<vector<char>> &grid, int delta_row[], int delta_col[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        visited[row][col] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n\\n        while (!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int neighbour_row = r + delta_row[i];\\n                int neighbour_col = c + delta_col[i];\\n\\n                // for each neighbour check boundary\\n                if (neighbour_row >= 0 && neighbour_row < n && neighbour_col >= 0 && neighbour_col < m)\\n                {\\n                    // check for land and prev visited\\n                    if (grid[neighbour_row][neighbour_col] == \\'1\\' && !visited[neighbour_row][neighbour_col])\\n                    {\\n                        visited[neighbour_row][neighbour_col] = 1;\\n                        q.push({neighbour_row, neighbour_col});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        int ans = 0;\\n        int delta_row[] = {-1, 0, 1, 0};\\n        int delta_col[] = {0, 1, 0, -1};\\n\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < m; c++)\\n                if (!visited[r][c] && grid[r][c] == \\'1\\')\\n                {\\n                    ++ans;\\n                    bfs(r, c, visited, grid, delta_row, delta_col);\\n                }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585867,
                "title": "intuitive-reason-for-time-complexity-analysis-of-bfs-and-dfs-appraoch",
                "content": "Hello all\\n\\nAfter wasting 2 days on this question - time complexity, i came up with following intution that helped me understanding this.\\n\\n**Approach DFS or BFS**\\nT(N) = O(rows x cols)\\n\\n**Time complexity seems 4 ^ O(rows x cols) if we think this as for each node, we have 4 ways to expand, but it is not !!!**\\n**Reason**- Lets say, we are at one cell (r,c), from this we have 4 ways and at this point, we mark the cell (r,c) as visited.\\n```\\n           (r-1,c)\\n                |\\n(r,c-1) -    (r,c)   - (r,c+1)\\n            visited\\n               |\\n           (r+1,c) \\n```\\nNow, from each neighbour cell, we will have again 4 ways to expand (technically 3 because we came from (r,c) which has been visited so no need to go further - But you can say 4 comparisons will happen in each neighbouring cell again )\\nIt means, if we see each cell, there will be at-most 4 comparisons on that due to its 4 neighbours.\\n```\\n                (r-1,c)\\n                    |\\n(r,c-1)      -    (r,c)   -      (r,c+1)\\n              4 comparisions\\n                    |\\n                 (r+1,c) \\n```\\nTime complexity = 4 + 4 + 4 + ... + 4 (rows x cols times)\\n= 4 x O(row x col) = O(row x col)\\n\\n**Space Complexity Analysis for DFS-**\\nHere, we are using Recursion stack and Recursion stack can grow to the total cells available (assume all 1\\'s)\\n**S(N) = O(rows x cols) +  O(rows x cols) [visited hashmap]**\\n\\n**Space Complexity Analysis for BFS-**\\nHere, we are using Queue. Now the question is **what can be the max size of the Queue here?**\\nLets say we have 3 x 100 grid and we start from middle node.\\n```\\n(Q means the cell is in the Queue, X means the cell has been processed and outside of the Queue)\\n_    _    _    _    _.   _.   _\\n_    _    _    Q   _.   _.   _     Total cells in Queue = 1\\n_    _    _    _    _.   _.   _\\nExpand ...\\n_    _    _    Q    _.   _.   _\\n_    _    Q    x    Q.   _.   _.   Total cells in Queue = 4\\n_    _    _    Q    _.   _.   _\\nExpand ...\\n_    _    Q   x    Q.   _.   _\\n_    Q    x    x    x.   Q.   _.    Total cells in Queue = 6 (becomes Limited)\\n_    _    Q    x    Q.   _.   _\\nExpand ...\\n_    Q    x   x    x.   Q.   _\\nQ    x    x    x    x.   x.   Q.    Total cells in Queue = 6 (becomes Limited)\\n_    Q    x    x    x   Q.   _\\n\\n```\\nSo, total cells in queue becomes limited due to the 3 rows as compare to the 100 cols.\\nSo, **S(N) = Min(row,col) # queue**",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n           (r-1,c)\\n                |\\n(r,c-1) -    (r,c)   - (r,c+1)\\n            visited\\n               |\\n           (r+1,c) \\n```\n```\\n                (r-1,c)\\n                    |\\n(r,c-1)      -    (r,c)   -      (r,c+1)\\n              4 comparisions\\n                    |\\n                 (r+1,c) \\n```\n```\\n(Q means the cell is in the Queue, X means the cell has been processed and outside of the Queue)\\n_    _    _    _    _.   _.   _\\n_    _    _    Q   _.   _.   _     Total cells in Queue = 1\\n_    _    _    _    _.   _.   _\\nExpand ...\\n_    _    _    Q    _.   _.   _\\n_    _    Q    x    Q.   _.   _.   Total cells in Queue = 4\\n_    _    _    Q    _.   _.   _\\nExpand ...\\n_    _    Q   x    Q.   _.   _\\n_    Q    x    x    x.   Q.   _.    Total cells in Queue = 6 (becomes Limited)\\n_    _    Q    x    Q.   _.   _\\nExpand ...\\n_    Q    x   x    x.   Q.   _\\nQ    x    x    x    x.   x.   Q.    Total cells in Queue = 6 (becomes Limited)\\n_    Q    x    x    x   Q.   _\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678547,
                "title": "c-both-dfs-and-bfs-approaches-with-comments-runtime-comparison",
                "content": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n/*\\nDFS\\nRuntime - 20 ms, Memory - 10.1 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    dfs(grid, i, j, visited);\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || visited[i][j] || grid[i][j] == \\'0\\')     return;\\n        \\n        visited[i][j] = 1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i, j+1, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n    }\\n};\\n\\n/*\\nBFS\\nRuntime - 28 ms, Memory - 10.7 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void bfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        // lambda to check whether current cell is inside grid\\n        auto inside = [&](const pair<int, int> &p) -> bool {\\n            return p.first >= 0 && p.first < grid.size() && p.second >= 0 && p.second < grid[0].size();\\n        };\\n        \\n        // adding any pair to a coordinate gives a neighboring cell (up, right, down, left)\\n        vector<pair<int, int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            auto curr_cell = q.front();\\n            q.pop();\\n            visited[curr_cell.first][curr_cell.second] = 1;\\n            \\n            // for all neighboring cells of current cell\\n            for(auto dir: direction) {\\n                int new_i = (curr_cell.first + dir.first), new_j = (curr_cell.second + dir.second);\\n                auto new_cell = make_pair(new_i, new_j);\\n                // if neighboring cell lies inside grid and not visited already and has island part (i.e \\'1\\') then add it to queue\\n                if(inside(new_cell) && !visited[new_i][new_j] && grid[new_i][new_j] == \\'1\\') {\\n                    visited[new_i][new_j] = 1;\\n                    q.push(new_cell);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n/*\\nDFS\\nRuntime - 20 ms, Memory - 10.1 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    dfs(grid, i, j, visited);\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || visited[i][j] || grid[i][j] == \\'0\\')     return;\\n        \\n        visited[i][j] = 1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i, j+1, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n    }\\n};\\n\\n/*\\nBFS\\nRuntime - 28 ms, Memory - 10.7 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void bfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        // lambda to check whether current cell is inside grid\\n        auto inside = [&](const pair<int, int> &p) -> bool {\\n            return p.first >= 0 && p.first < grid.size() && p.second >= 0 && p.second < grid[0].size();\\n        };\\n        \\n        // adding any pair to a coordinate gives a neighboring cell (up, right, down, left)\\n        vector<pair<int, int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            auto curr_cell = q.front();\\n            q.pop();\\n            visited[curr_cell.first][curr_cell.second] = 1;\\n            \\n            // for all neighboring cells of current cell\\n            for(auto dir: direction) {\\n                int new_i = (curr_cell.first + dir.first), new_j = (curr_cell.second + dir.second);\\n                auto new_cell = make_pair(new_i, new_j);\\n                // if neighboring cell lies inside grid and not visited already and has island part (i.e \\'1\\') then add it to queue\\n                if(inside(new_cell) && !visited[new_i][new_j] && grid[new_i][new_j] == \\'1\\') {\\n                    visited[new_i][new_j] = 1;\\n                    q.push(new_cell);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 522736,
                "title": "in-c",
                "content": "```\\n\\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\\n{\\n    if (i < 0 || j < 0 || i >= gridSize)\\n        return;\\n    if (j >= gridColSize[i])\\n        return;\\n    if (grid[i][j] == \\'0\\')\\n        return;\\n    grid[i][j] = \\'0\\';\\n    visit(grid, i-1, j, gridSize, gridColSize);\\n    visit(grid, i+1, j, gridSize, gridColSize);\\n    visit(grid, i, j-1, gridSize, gridColSize);\\n    visit(grid, i, j+1, gridSize, gridColSize);\\n}\\n\\nint numIslands(char** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int res = 0;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == \\'1\\') {\\n                visit(grid, i, j, gridSize, gridColSize);\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\\n{\\n    if (i < 0 || j < 0 || i >= gridSize)\\n        return;\\n    if (j >= gridColSize[i])\\n        return;\\n    if (grid[i][j] == \\'0\\')\\n        return;\\n    grid[i][j] = \\'0\\';\\n    visit(grid, i-1, j, gridSize, gridColSize);\\n    visit(grid, i+1, j, gridSize, gridColSize);\\n    visit(grid, i, j-1, gridSize, gridColSize);\\n    visit(grid, i, j+1, gridSize, gridColSize);\\n}\\n\\nint numIslands(char** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int res = 0;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == \\'1\\') {\\n                visit(grid, i, j, gridSize, gridColSize);\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56336,
                "title": "python-dfs-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # idea is to make connected components count 1 only by making them 0 once visited\\n        self.sum = 0\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                self.sum += self.find_islands(grid, row, col)\\n        return self.sum\\n        \\n    def find_islands(self, grid,i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \"1\":\\n            grid[i][j] = \"0\"\\n            # go top left right bottom \\n            # make all 1's 0 till all connected becomes zero\\n            # then return 1 as all connected componets forms one island\\n            # done\\n            self.find_islands(grid, i + 1, j)\\n            self.find_islands(grid, i, j-1)\\n            self.find_islands(grid, i-1, j)\\n            self.find_islands(grid, i, j + 1)\\n            return 1\\n        return 0\\n            \\n        \\n\\n        \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # idea is to make connected components count 1 only by making them 0 once visited\\n        self.sum = 0\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                self.sum += self.find_islands(grid, row, col)\\n        return self.sum\\n        \\n    def find_islands(self, grid,i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \"1\":\\n            grid[i][j] = \"0\"\\n            # go top left right bottom \\n            # make all 1's 0 till all connected becomes zero\\n            # then return 1 as all connected componets forms one island\\n            # done\\n            self.find_islands(grid, i + 1, j)\\n            self.find_islands(grid, i, j-1)\\n            self.find_islands(grid, i-1, j)\\n            self.find_islands(grid, i, j + 1)\\n            return 1\\n        return 0\\n            \\n        \\n\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 56549,
                "title": "ac-java-solution-using-union-find-with-explanations",
                "content": "It is a classical DFS problem, and my solution applied union-find algorithm that passed all the test cases.\\nBasic idea is to iterate through every node's neighbours and marked them if they aren't connected.\\nFinally, if it was the root node then increase the total number of islands.\\n\\n\\npublic class Solution {\\n\\t\\n\\tprivate int[] sz;\\n\\tprivate int[] id;\\n\\tprivate int N, M;\\n\\t\\n\\tpublic int find(int p) {\\n\\t\\twhile (id[p] != p) \\n\\t\\t\\tp = id[p];\\n\\t\\treturn p;\\n\\t}\\n\\t\\n\\tpublic void union(int p, int q) {\\n\\t\\tint rootP = find(p);\\n\\t\\tint rootQ = find(q);\\n\\t\\tif (rootP == rootQ) return;\\n\\t\\t\\n\\t\\tif (sz[rootP] < sz[rootQ])\\t{sz[rootQ] += sz[rootP]; id[rootP] = id[rootQ];}\\n\\t\\telse \\t\\t\\t\\t\\t\\t{sz[rootP] += sz[rootQ]; id[rootQ] = id[rootP];}\\n\\t}\\n\\t\\n\\tprivate boolean inside(int x, int y) {\\n\\t\\treturn (x >= 0 && y >= 0 && x < N && y < M);\\n\\t}\\n\\t\\n\\tpublic int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length ==0) return 0;\\n\\t\\tN = grid.length;\\n\\t\\tM = grid[0].length;\\n\\t\\tsz = new int[N*M];\\n\\t\\tid = new int[N*M];\\n\\t\\tfor (int i = 0; i < N*M; i++) {\\n\\t\\t\\tid[i] = i;\\n\\t\\t\\tsz[i] = 1;\\n\\t\\t}\\n        for (int i = 0; i < N; i++) {\\n        \\tfor (int j = 0; j < M; j++) \\n        \\t\\tif (grid[i][j] != '0') {\\n\\t        \\t\\tint tmp = i*M + j;\\n\\t        \\t\\tif (inside(i-1, j) && grid[i-1][j] != '0') union(tmp, tmp - M);\\n\\t        \\t\\tif (inside(i, j-1) && grid[i][j-1] != '0') union(tmp, tmp - 1);\\n\\t        \\t\\tif (inside(i+1, j) && grid[i+1][j] != '0') union(tmp, tmp + M);\\n\\t        \\t\\tif (inside(i, j+1) && grid[i][j+1] != '0') union(tmp, tmp + 1);\\n\\t        \\t}\\n        }\\n        int islands = 0, i = 0;\\n        while (i < N*M) {\\n        \\tif (i == id[i] && grid[i/M][i%M] != '0') islands++;\\n        \\ti++;\\n        }\\n        return islands;\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\n\\tprivate int[] sz;\\n\\tprivate int[] id;\\n\\tprivate int N, M;\\n\\t\\n\\tpublic int find(int p) {\\n\\t\\twhile (id[p] != p) \\n\\t\\t\\tp = id[p];\\n\\t\\treturn p;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 56673,
                "title": "simple-dfs-sulotion",
                "content": "Dont need the extra space, and O(mn)\\n\\n    public int numIslands(char[][] grid) {\\n        int islands = 0;\\n        if (grid != null && grid.length != 0 && grid[0].length != 0) {\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        dfs(grid, i, j);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    \\n    private void dfs(char[][] grid, int x, int y) {\\n        if (x < 0 || grid.length <= x || y < 0 || grid[0].length <= y || grid[x][y] != '1') {\\n            return;\\n        }\\n        grid[x][y] = 'x';\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "Dont need the extra space, and O(mn)\\n\\n    public int numIslands(char[][] grid) {\\n        int islands = 0;\\n        if (grid != null && grid.length != 0 && grid[0].length != 0) {\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        dfs(grid, i, j);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    \\n    private void dfs(char[][] grid, int x, int y) {\\n        if (x < 0 || grid.length <= x || y < 0 || grid[0].length <= y || grid[x][y] != '1') {\\n            return;\\n        }\\n        grid[x][y] = 'x';\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 679357,
                "title": "iterative-dfs-and-bfs-explained",
                "content": "aim is to explain iterative BFS/DFS.\\n\\n**BFS - Breadth First Search**\\nWe use Queue in BFS , again WHY ? , because of its FIFO nature , (First in First OUT nature ).\\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        queue<pair<int,int>> que;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     \\n                {\\n                    no_of_island++;\\n                    que.push({i,j});\\n                    // BFS                                        \\n                    while(que.size())\\n                    {\\n                        auto [ startI , startJ ] = que.front();    que.pop();    \\n                        grid[startI][startJ] = \\'0\\';\\n                        for(int dir = 0 ; dir<4 ; dir++)    \\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                que.push({newi,newj}) , grid[newi][newj] = \\'0\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\\n**DFS : Iterative**\\nwhen it comes to Depth first search then we use Stack , why ? beacause of its LIFO (last in First Out nature ).\\nNotice changes : we replaced all ques with stack and we are good to go, **Yep its that simple !**\\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        stack<pair<int,int>> sk;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     // this place may be the begining of new island\\n                {\\n                    no_of_island++;\\n                    sk.push({i,j});\\n                    grid[i][j] = \\'0\\';\\n                    // DFS                                       \\n                    while(sk.size())\\n                    {\\n                        auto [ startI , startJ ] = sk.top();    sk.pop();\\n                        grid[startI][startJ] = \\'0\\';   // marking as visited to avoid looping, eliminating need of visited array\\n                                                      \\n                        for(int dir = 0 ; dir<4 ; dir++)\\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n\\t\\t\\t\\t\\t\\t\\t// if VALID and CONNECTED\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                sk.push({newi,newj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\\ndoubts ? **comments are welcomed.**",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        queue<pair<int,int>> que;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     \\n                {\\n                    no_of_island++;\\n                    que.push({i,j});\\n                    // BFS                                        \\n                    while(que.size())\\n                    {\\n                        auto [ startI , startJ ] = que.front();    que.pop();    \\n                        grid[startI][startJ] = \\'0\\';\\n                        for(int dir = 0 ; dir<4 ; dir++)    \\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                que.push({newi,newj}) , grid[newi][newj] = \\'0\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        stack<pair<int,int>> sk;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     // this place may be the begining of new island\\n                {\\n                    no_of_island++;\\n                    sk.push({i,j});\\n                    grid[i][j] = \\'0\\';\\n                    // DFS                                       \\n                    while(sk.size())\\n                    {\\n                        auto [ startI , startJ ] = sk.top();    sk.pop();\\n                        grid[startI][startJ] = \\'0\\';   // marking as visited to avoid looping, eliminating need of visited array\\n                                                      \\n                        for(int dir = 0 ; dir<4 ; dir++)\\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n\\t\\t\\t\\t\\t\\t\\t// if VALID and CONNECTED\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                sk.push({newi,newj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220533,
                "title": "200-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using a variation of Depth First Search (DFS) algorithm. We will traverse through the given matrix and visit all the connected 1\\'s, marking them as visited. We will keep a count of the number of times we visit the 1\\'s. Whenever we encounter an unvisited 1, we will increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited. Finally, we will return the count of the number of islands.\\n\\nAlgorithm:\\n\\n1. Initialize a count variable to 0.\\n2. Traverse through the given matrix.\\n3. Whenever we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n4. Return the count of the number of islands.\\n\\n# Complexity\\n- Time complexity:\\nO(mn), where m is the number of rows and n is the number of columns in the given matrix.\\n\\n- Space complexity:\\nO(mn), where m is the number of rows and n is the number of columns in the given matrix. The space is used by the visited matrix.\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def dfs(i: int, j: int) -> None:\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == \"0\" or visited[i][j]:\\n                # If the current cell is out of bounds or is water (0) or has already been visited, return.\\n                return\\n            visited[i][j] = True # Mark the current cell as visited.\\n            dfs(i+1, j) # Visit the neighbor to the right.\\n            dfs(i-1, j) # Visit the neighbor to the left.\\n            dfs(i, j+1) # Visit the neighbor below.\\n            dfs(i, j-1) # Visit the neighbor above.\\n        \\n        m, n = len(grid), len(grid[0]) # Get the dimensions of the given matrix.\\n        visited = [[False for _ in range(n)] for _ in range(m)] # Initialize a visited matrix with False for all cells.\\n        count = 0 # Initialize a count variable to 0.\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\" and not visited[i][j]: # If we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n                    count += 1\\n                    dfs(i, j)\\n        return count # Return the count of the number of islands.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def dfs(i: int, j: int) -> None:\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == \"0\" or visited[i][j]:\\n                # If the current cell is out of bounds or is water (0) or has already been visited, return.\\n                return\\n            visited[i][j] = True # Mark the current cell as visited.\\n            dfs(i+1, j) # Visit the neighbor to the right.\\n            dfs(i-1, j) # Visit the neighbor to the left.\\n            dfs(i, j+1) # Visit the neighbor below.\\n            dfs(i, j-1) # Visit the neighbor above.\\n        \\n        m, n = len(grid), len(grid[0]) # Get the dimensions of the given matrix.\\n        visited = [[False for _ in range(n)] for _ in range(m)] # Initialize a visited matrix with False for all cells.\\n        count = 0 # Initialize a count variable to 0.\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\" and not visited[i][j]: # If we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n                    count += 1\\n                    dfs(i, j)\\n        return count # Return the count of the number of islands.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366890,
                "title": "easy-c-solution-using-dfs-95-faster",
                "content": "#### C++\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfsislands(vector<vector<char>>& grid, int i, int j)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!=\\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[i][j]=\\'2\\';\\n        dfsislands(grid,i+1,j);\\n        dfsislands(grid,i,j+1);\\n        dfsislands(grid,i-1,j);\\n        dfsislands(grid,i,j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                    dfsislands(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfsislands(vector<vector<char>>& grid, int i, int j)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!=\\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[i][j]=\\'2\\';\\n        dfsislands(grid,i+1,j);\\n        dfsislands(grid,i,j+1);\\n        dfsislands(grid,i-1,j);\\n        dfsislands(grid,i,j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                    dfsislands(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347290,
                "title": "swift-solution-clean-code-dfs-bfs",
                "content": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        guard grid.count != 0, grid[0].count != 0 else { return 0 }\\n        var count = 0\\n        var grid = grid\\n        \\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if grid[row][col] == \"1\" {\\n                    DFS(row, col, &grid)\\n                    //BFS(row, col, &grid)\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n\\t\\n    // DFS\\n    func DFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        guard row >= 0, row < grid.count, col >= 0, col < grid[0].count, grid[row][col] == \"1\" else { return }\\n        grid[row][col] = \"0\" // set visited\\n        \\n        DFS(row-1, col, &grid)\\n        DFS(row+1, col, &grid)\\n        DFS(row, col-1, &grid)\\n        DFS(row, col+1, &grid)\\n    }\\n\\t\\n    // BFS\\n    func BFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        var queue = [(Int,Int)]()\\n        queue.append((row, col))\\n        grid[row][col] = \"0\" // set visited\\n        \\n        while queue.count != 0 {\\n            let current = queue.removeFirst()\\n            let (curRow, curCol) = current\\n            \\n            if curRow-1 >= 0, grid[curRow-1][curCol] == \"1\" { \\n                queue.append((curRow-1, curCol))\\n                grid[curRow-1][curCol] = \"0\"\\n            }\\n            if curRow+1 < grid.count, grid[curRow+1][curCol] == \"1\" { \\n                queue.append((curRow+1, curCol)) \\n                grid[curRow+1][curCol] = \"0\"\\n            }\\n            if curCol-1 >= 0, grid[curRow][curCol-1] == \"1\" { \\n                queue.append((curRow, curCol-1)) \\n                grid[curRow][curCol-1] = \"0\"\\n            }\\n            if curCol+1 < grid[0].count, grid[curRow][curCol+1] == \"1\" { \\n                queue.append((curRow, curCol+1)) \\n                grid[curRow][curCol+1] = \"0\"\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        guard grid.count != 0, grid[0].count != 0 else { return 0 }\\n        var count = 0\\n        var grid = grid\\n        \\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if grid[row][col] == \"1\" {\\n                    DFS(row, col, &grid)\\n                    //BFS(row, col, &grid)\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n\\t\\n    // DFS\\n    func DFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        guard row >= 0, row < grid.count, col >= 0, col < grid[0].count, grid[row][col] == \"1\" else { return }\\n        grid[row][col] = \"0\" // set visited\\n        \\n        DFS(row-1, col, &grid)\\n        DFS(row+1, col, &grid)\\n        DFS(row, col-1, &grid)\\n        DFS(row, col+1, &grid)\\n    }\\n\\t\\n    // BFS\\n    func BFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        var queue = [(Int,Int)]()\\n        queue.append((row, col))\\n        grid[row][col] = \"0\" // set visited\\n        \\n        while queue.count != 0 {\\n            let current = queue.removeFirst()\\n            let (curRow, curCol) = current\\n            \\n            if curRow-1 >= 0, grid[curRow-1][curCol] == \"1\" { \\n                queue.append((curRow-1, curCol))\\n                grid[curRow-1][curCol] = \"0\"\\n            }\\n            if curRow+1 < grid.count, grid[curRow+1][curCol] == \"1\" { \\n                queue.append((curRow+1, curCol)) \\n                grid[curRow+1][curCol] = \"0\"\\n            }\\n            if curCol-1 >= 0, grid[curRow][curCol-1] == \"1\" { \\n                queue.append((curRow, curCol-1)) \\n                grid[curRow][curCol-1] = \"0\"\\n            }\\n            if curCol+1 < grid[0].count, grid[curRow][curCol+1] == \"1\" { \\n                queue.append((curRow, curCol+1)) \\n                grid[curRow][curCol+1] = \"0\"\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272999,
                "title": "c-efficient-solution-beat-100",
                "content": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n      var count = 0;\\n      for (int i = 0; i < grid.Length; i++)\\n      {\\n        for (int j = 0; j < grid[i].Length; j++)\\n        {\\n          if (grid[i][j] == \\'1\\')\\n          {\\n            count++;\\n            UpdateGrid(i, j, grid);\\n          }\\n        }\\n      }\\n\\n      return count;\\n    }\\n    \\n    public void UpdateGrid(int i, int j, char[][] grid)\\n    {\\n      if (i < 0 || j < 0 || i == grid.Length || j == grid[0].Length || grid[i][j] == \\'0\\') return;\\n      grid[i][j] = \\'0\\';\\n\\n      UpdateGrid(i - 1, j, grid); //top\\n      UpdateGrid(i + 1, j, grid); //bottom\\n      UpdateGrid(i, j - 1, grid); //left\\n      UpdateGrid(i, j + 1, grid); //right\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n      var count = 0;\\n      for (int i = 0; i < grid.Length; i++)\\n      {\\n        for (int j = 0; j < grid[i].Length; j++)\\n        {\\n          if (grid[i][j] == \\'1\\')\\n          {\\n            count++;\\n            UpdateGrid(i, j, grid);\\n          }\\n        }\\n      }\\n\\n      return count;\\n    }\\n    \\n    public void UpdateGrid(int i, int j, char[][] grid)\\n    {\\n      if (i < 0 || j < 0 || i == grid.Length || j == grid[0].Length || grid[i][j] == \\'0\\') return;\\n      grid[i][j] = \\'0\\';\\n\\n      UpdateGrid(i - 1, j, grid); //top\\n      UpdateGrid(i + 1, j, grid); //bottom\\n      UpdateGrid(i, j - 1, grid); //left\\n      UpdateGrid(i, j + 1, grid); //right\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791201,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546582,
                "title": "go-dfs-bfs",
                "content": "Time complexity: O(mn + 4mn) -> O(mn)\\nspace complexity: O(mn)\\n\\n```\\nfunc numIslands(grid [][]byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'1\\' {\\n                count++\\n                \\n                dfs(grid, i, j)\\n\\t\\t\\t\\t// bfs(grid, i, j)\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc dfs(grid [][]byte, r, c int) {\\n    if r < 0 || r >= len(grid) || c < 0 || c >= len(grid[r]) || grid[r][c] != \\'1\\' {\\n        return\\n    }\\n    \\n    grid[r][c] = \\'2\\'\\n    dfs(grid, r+1, c)\\n    dfs(grid, r-1, c)\\n    dfs(grid, r, c+1)\\n    dfs(grid, r, c-1)\\n}\\n\\nfunc bfs(grid [][]byte, r, c int) {\\n    q := [][2]int{}\\n    \\n    q = append(q, [2]int{r,c})\\n    grid[r][c] = \\'2\\'\\n    \\n    offsets := [4][2]int{{-1,0}, {1,0}, {0,1}, {0,-1}}\\n    for len(q) > 0 {\\n        curr := q[0]\\n        q = q[1:]\\n        \\n        for _, offset := range offsets {\\n            x := curr[0] + offset[0]\\n            y := curr[1] + offset[1]\\n            \\n            if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] == \\'1\\' {\\n                q = append(q, [2]int{x,y})\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'1\\' {\\n                count++\\n                \\n                dfs(grid, i, j)\\n\\t\\t\\t\\t// bfs(grid, i, j)\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc dfs(grid [][]byte, r, c int) {\\n    if r < 0 || r >= len(grid) || c < 0 || c >= len(grid[r]) || grid[r][c] != \\'1\\' {\\n        return\\n    }\\n    \\n    grid[r][c] = \\'2\\'\\n    dfs(grid, r+1, c)\\n    dfs(grid, r-1, c)\\n    dfs(grid, r, c+1)\\n    dfs(grid, r, c-1)\\n}\\n\\nfunc bfs(grid [][]byte, r, c int) {\\n    q := [][2]int{}\\n    \\n    q = append(q, [2]int{r,c})\\n    grid[r][c] = \\'2\\'\\n    \\n    offsets := [4][2]int{{-1,0}, {1,0}, {0,1}, {0,-1}}\\n    for len(q) > 0 {\\n        curr := q[0]\\n        q = q[1:]\\n        \\n        for _, offset := range offsets {\\n            x := curr[0] + offset[0]\\n            y := curr[1] + offset[1]\\n            \\n            if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] == \\'1\\' {\\n                q = append(q, [2]int{x,y})\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497974,
                "title": "c-dfs-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\n**We need to count number of groups of \\'1\\'. But only single \"1\" is to be counted from one island.**\\n\\n**APPROACH\\nWe traverse the grid element by element.**\\n**When :**\\n\\n* **grid[i][j] == \"0\" -> Do nothing**\\n* **grid[i][j] == \"1\" ->There is an island.**\\n* **Increase the count of islands by one.**\\n* **Now we need to remove the island from the grid. [ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]**\\n* **We can use DFS to traverse through the island, where :**\\n* **If \"1\" is there, make it \"0\".**\\n* **Break out if we reach out of boundaries or we encounter \"0\" -> water.**\\n* **And to the same for neighbouring cells.**\\n\\n-----------------------------------------------------------------------------\\n# C# Code\\n\\n\\tusing System.Threading.Tasks;\\n\\tpublic class Solution {\\n\\t\\tprivate static int[][] directions => new int[][]{new int[]{0,-1}, new int[]{-1,0}, new int[]{0,1}, new int[]{1,0}};\\n\\n\\t\\tpublic int NumIslands(char[][] grid) {\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(int i=0; i<grid.Length; ++i){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].Length; ++j){\\n\\t\\t\\t\\t\\tif(grid[i][j]==\\'1\\'){  // if current grid is 1 there is part of island\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tDFS(i, j, grid);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\t// concurrent DFS\\n\\t\\tpublic void DFS(int i, int j, char[][] grid){\\n\\t\\t\\tif(i<0 || j<0 || i==grid.Length || j==grid[0].Length)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(grid[i][j]==\\'0\\') //if current is visited return \\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[i][j] = \\'0\\'; // making visited current \\n\\n\\t\\t\\tParallel.ForEach(directions, d=>DFS(i+d[0], j+d[1], grid)) ;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate static int[][] directions => new int[][]{new int[]{0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1353449,
                "title": "go-simple-dfs",
                "content": "Straightforward DFS solution in Go\\n\\n```go\\nfunc numIslands(grid [][]byte) int {\\n    result := 0\\n    for i, row := range grid {\\n        for j, value := range row {\\n            if value == \\'1\\' {\\n                visit(&grid, i, j)\\n                result += 1\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\nfunc visit(grid *[][]byte, i int, j int) {\\n    m, n := len(*grid), len((*grid)[0])\\n    if (i < 0) || (i >= m) || (j < 0) || (j >= n) || ((*grid)[i][j] == \\'0\\') {\\n        return\\n    }\\n\\n    (*grid)[i][j] = \\'0\\'\\n    \\n    visit(grid, i-1, j)\\n    visit(grid, i+1, j)\\n    visit(grid, i, j-1)\\n    visit(grid, i, j+1)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc numIslands(grid [][]byte) int {\\n    result := 0\\n    for i, row := range grid {\\n        for j, value := range row {\\n            if value == \\'1\\' {\\n                visit(&grid, i, j)\\n                result += 1\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\nfunc visit(grid *[][]byte, i int, j int) {\\n    m, n := len(*grid), len((*grid)[0])\\n    if (i < 0) || (i >= m) || (j < 0) || (j >= n) || ((*grid)[i][j] == \\'0\\') {\\n        return\\n    }\\n\\n    (*grid)[i][j] = \\'0\\'\\n    \\n    visit(grid, i-1, j)\\n    visit(grid, i+1, j)\\n    visit(grid, i, j-1)\\n    visit(grid, i, j+1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772514,
                "title": "c-bfs-dfs-solution",
                "content": "Traverse the whole grid and whenever you encounter a \\'1\\' increase the answer counter and convert all its neighbouring \\'1\\' to \\'0\\'s using BFS or DFS approach as required.\\n\\n**DFS approach :** \\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n) {\\n        if(i>=0 && i<m && j>=0 && j<n && grid[i][j] == \\'1\\') {\\n            grid[i][j] = 0;\\n            dfs(grid, i-1, j, m, n);\\n            dfs(grid, i+1, j, m, n);\\n            dfs(grid, i, j-1, m, n);\\n            dfs(grid, i, j+1, m, n);\\n        }\\n        else\\n            return;\\n            \\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**BFS approach:** using queue data structure \\n```\\nclass Solution {\\npublic:  \\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    q.emplace(make_pair(i,j));\\n                    \\n                    while(!q.empty()) {\\n                        auto pos = q.front();\\n                        q.pop();\\n                        int u = pos.first;\\n                        int v = pos.second;\\n                        \\n                        if(grid[u][v] == \\'1\\') {\\n                            grid[u][v] = \\'0\\';\\n                            for(auto dir : dirs) { \\n                                int a = u + dir[0];\\n                                int b = v + dir[1];\\n                                if(a>=0 && a<m && b>=0 && b<n)\\n                                    q.emplace(make_pair(a, b));\\n                            }\\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n) {\\n        if(i>=0 && i<m && j>=0 && j<n && grid[i][j] == \\'1\\') {\\n            grid[i][j] = 0;\\n            dfs(grid, i-1, j, m, n);\\n            dfs(grid, i+1, j, m, n);\\n            dfs(grid, i, j-1, m, n);\\n            dfs(grid, i, j+1, m, n);\\n        }\\n        else\\n            return;\\n            \\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:  \\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    q.emplace(make_pair(i,j));\\n                    \\n                    while(!q.empty()) {\\n                        auto pos = q.front();\\n                        q.pop();\\n                        int u = pos.first;\\n                        int v = pos.second;\\n                        \\n                        if(grid[u][v] == \\'1\\') {\\n                            grid[u][v] = \\'0\\';\\n                            for(auto dir : dirs) { \\n                                int a = u + dir[0];\\n                                int b = v + dir[1];\\n                                if(a>=0 && a<m && b>=0 && b<n)\\n                                    q.emplace(make_pair(a, b));\\n                            }\\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424555,
                "title": "java-o-mn-solution-bfs-and-dfs-with-easy-explanation",
                "content": "Three line explanation for interviews\\n\\n1) Intitate a count variable and Iterate over the matrix \\n\\t* \\tCount the island whenever we are encouterning \\'1\\' at any index.\\n\\t* \\tPerform BFS and DFS at the index to make all the neighboring elements from \\'1\\' --> \\'0\\' as they are part of same island. If the interviewer says we can not mutate the array then maintain a separate mX n visited array and mark all the BFS and DFS elements as visited.\\n2) For BFS maintain a queue and push index of encountered \\'1\\' in queue and subsequently keep adding all the neighbors with value \\'1\\' till queue becomes empty.\\n3) Return the count.\\n\\nTime Complexity: O(mn) in both BFS and DFS\\nSpace Complexity: O(mn) in BFS as we are maintianing a queue which in worst cases can have all the elements of matrix\\n\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n**BFS**\\n\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int count =0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dirs = new int [][] {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n        for(int i = 0; i <  m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    Queue <int []> q = new LinkedList<>();\\n                    q.add(new int[] {i,j});\\n                    grid[i][j] = \\'0\\';\\n                    while(!q.isEmpty()){\\n                        int [] curr = q.poll();\\n                        for(int [] dir : dirs){\\n                            int r = curr[0] + dir[0];\\n                            int c = curr[1] + dir[1];\\n                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\'){\\n                                 q.add(new int[] {r,c});\\n                                 grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n**DFS**\\n\\n```\\nclass Solution {\\n    private int m;\\n    private int n;\\n    public int numIslands(char[][] grid) {\\n        //edge case\\n        m = grid.length;\\n        if(grid == null || m == 0) return 0;\\n        n = grid[0].length;\\n        int count = 0;\\n \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;    \\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private void dfs (char[][] grid, int i, int j){\\n        // base case\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'0\\') return;\\n        int[][] dirs = new int [][] {{0,1},{1,0}, {-1,0},{0,-1}};\\n        grid[i][j] = \\'0\\';\\n        for(int[] dir: dirs){\\n            int r = i+dir[0];\\n            int c = j+dir[1];\\n             dfs(grid,r,c);\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int count =0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dirs = new int [][] {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n        for(int i = 0; i <  m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    Queue <int []> q = new LinkedList<>();\\n                    q.add(new int[] {i,j});\\n                    grid[i][j] = \\'0\\';\\n                    while(!q.isEmpty()){\\n                        int [] curr = q.poll();\\n                        for(int [] dir : dirs){\\n                            int r = curr[0] + dir[0];\\n                            int c = curr[1] + dir[1];\\n                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\'){\\n                                 q.add(new int[] {r,c});\\n                                 grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int m;\\n    private int n;\\n    public int numIslands(char[][] grid) {\\n        //edge case\\n        m = grid.length;\\n        if(grid == null || m == 0) return 0;\\n        n = grid[0].length;\\n        int count = 0;\\n \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;    \\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private void dfs (char[][] grid, int i, int j){\\n        // base case\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'0\\') return;\\n        int[][] dirs = new int [][] {{0,1},{1,0}, {-1,0},{0,-1}};\\n        grid[i][j] = \\'0\\';\\n        for(int[] dir: dirs){\\n            int r = i+dir[0];\\n            int c = j+dir[1];\\n             dfs(grid,r,c);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159799,
                "title": "python-solution",
                "content": "The problem can be solved with DFS. Time complexity: O(height * width), space complexity: O(height * width).\\n\\nDFS iterative:\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # DFS\\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        u = stack.pop()\\n                        visit.add(u)\\n                        h, w = u[0], u[1]\\n                        if h > 0 and grid[h-1][w] == \\'1\\' and (h-1,w) not in visit:\\n                            stack.append((h-1,w))\\n                        if h < height - 1 and grid[h+1][w] == \\'1\\' and (h+1,w) not in visit:\\n                            stack.append((h+1,w))\\n                        if w > 0 and grid[h][w-1] == \\'1\\' and (h,w-1) not in visit:\\n                            stack.append((h,w-1))\\n                        if w < width - 1 and grid[h][w+1] == \\'1\\' and (h,w+1) not in visit:\\n                            stack.append((h,w+1))\\n        return count\\n```\\nDFS recursive:\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs_visit(grid, u):\\n            i, j = u[0], u[1]\\n            visit.add((i,j))\\n            if i > 0 and grid[i-1][j] == \\'1\\' and (i-1,j) not in visit:\\n                dfs_visit(grid, (i-1,j))\\n            if i < height - 1 and grid[i+1][j] == \\'1\\' and (i+1,j) not in visit:\\n                dfs_visit(grid, (i+1,j))\\n            if j > 0 and grid[i][j-1] == \\'1\\' and (i,j-1) not in visit:\\n                dfs_visit(grid, (i,j-1))\\n            if j < width - 1 and grid[i][j+1] == \\'1\\' and (i,j+1) not in visit:\\n                dfs_visit(grid, (i,j+1))\\n        \\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    dfs_visit(grid,(i,j))\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # DFS\\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        u = stack.pop()\\n                        visit.add(u)\\n                        h, w = u[0], u[1]\\n                        if h > 0 and grid[h-1][w] == \\'1\\' and (h-1,w) not in visit:\\n                            stack.append((h-1,w))\\n                        if h < height - 1 and grid[h+1][w] == \\'1\\' and (h+1,w) not in visit:\\n                            stack.append((h+1,w))\\n                        if w > 0 and grid[h][w-1] == \\'1\\' and (h,w-1) not in visit:\\n                            stack.append((h,w-1))\\n                        if w < width - 1 and grid[h][w+1] == \\'1\\' and (h,w+1) not in visit:\\n                            stack.append((h,w+1))\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs_visit(grid, u):\\n            i, j = u[0], u[1]\\n            visit.add((i,j))\\n            if i > 0 and grid[i-1][j] == \\'1\\' and (i-1,j) not in visit:\\n                dfs_visit(grid, (i-1,j))\\n            if i < height - 1 and grid[i+1][j] == \\'1\\' and (i+1,j) not in visit:\\n                dfs_visit(grid, (i+1,j))\\n            if j > 0 and grid[i][j-1] == \\'1\\' and (i,j-1) not in visit:\\n                dfs_visit(grid, (i,j-1))\\n            if j < width - 1 and grid[i][j+1] == \\'1\\' and (i,j+1) not in visit:\\n                dfs_visit(grid, (i,j+1))\\n        \\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    dfs_visit(grid,(i,j))\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388095,
                "title": "python-solution-beating-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImagine grid as graph with edges from \"1\" cells to all adjaent (max 4) cells and DFS to find number of connected components = Ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Iterate through the grid \\n* DFS for each cell with \"1\" and increament answer counter\\n* Mark cell \"0\" in dfs calls to mark them visited\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) where m, n is size of grid\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) not using any space using same input grid to capture visited cells.\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n          \\n        if grid is None:\\n            return 0\\n\\n        m = len(grid)\\n\\n        if m == 0:\\n            return 0\\n        \\n        n = len(grid[0])\\n        if(n==0):\\n            return 0\\n        \\n        ans = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                if(grid[i][j]==\"1\"):\\n                    ans +=1\\n                    self.dfs(grid, i,j,m,n)\\n        \\n        return ans\\n    \\n    def dfs(self, g, i, j, m, n):\\n        if i<0 or j<0 or i>=m or j>=n or g[i][j] == \"0\":\\n            return\\n        \\n        g[i][j] = \"0\"\\n\\n        self.dfs(g,i-1,j,m,n)\\n        self.dfs(g,i+1,j,m,n)\\n        self.dfs(g,i,j-1,m,n)\\n        self.dfs(g,i,j+1,m,n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n          \\n        if grid is None:\\n            return 0\\n\\n        m = len(grid)\\n\\n        if m == 0:\\n            return 0\\n        \\n        n = len(grid[0])\\n        if(n==0):\\n            return 0\\n        \\n        ans = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                if(grid[i][j]==\"1\"):\\n                    ans +=1\\n                    self.dfs(grid, i,j,m,n)\\n        \\n        return ans\\n    \\n    def dfs(self, g, i, j, m, n):\\n        if i<0 or j<0 or i>=m or j>=n or g[i][j] == \"0\":\\n            return\\n        \\n        g[i][j] = \"0\"\\n\\n        self.dfs(g,i-1,j,m,n)\\n        self.dfs(g,i+1,j,m,n)\\n        self.dfs(g,i,j-1,m,n)\\n        self.dfs(g,i,j+1,m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976172,
                "title": "dfs-bfs-and-easy-implementation-of-union-find-dsu-c",
                "content": "```\\nExplanations:\\nMethod 1: Our own and powerful DFS, we just go to every one, from there travel\\nto its every adjacent 1, and mark it as zero.\\nNow for one island one dfs will mark all of its adjacent 1s to zero. \\nAnother 1 comes, that means one more island or component to work with and we travel from that 1, \\nto all of its adjacent and mark it as zero.\\n\\nMethod 2: Basic BFS, We encounter a 1, we do bfs from that one to all its adjacent 1\\'s \\njust like we did in our DFS, the method is different, here we use a que, insert adjacent 1, and keep doing it.\\n\\nMethod 3: Union Find, Here we are only doing Path Compression and not Union, \\nwhich only hampers our time complexity by a constant but we do save space\\nbecause we didn\\'t take a size array nor did we make an extra class. \\nAnd more over this method is simpler to code in actual interview sense.\\nSo, what we did was first declare every element to be its own parent.\\nNow, we encounter our (name: hero)first one, its parent is him only,\\nthen we go to its adjacent elements and mark its parent as the \\nindex of our first one(remember, hero) only. \\nAfter we our done with this process, we just go and traverse all the elements which\\nare its own parent and in grid its value is \\'1\\'.\\nSimple, and codeable in an interview. \\nDo upvote. Thankyou.\\n```\\n```\\n//dfs\\nint n,m;\\n    void dfsNumIsland(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& dir){\\n        grid[i][j] = \\'0\\';\\n        for(vector<int>& d: dir){\\n            int r = i + d[0], c = j + d[1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\')\\n                dfsNumIsland(grid, r,c,dir);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        int component = 0;\\n        n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j< m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                  component++;\\n                  dfsNumIsland(grid,i,j, dir);\\n                }\\n            }\\n        }\\n        return component;\\n    }\\n```\\n```\\n//bfs\\nint numIslands(vector<vector<char>>& grid) {\\nint n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        queue<int> kyu;\\n        vector<vector<int>> dir = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    kyu.push(i*m + j);\\n                    while(kyu.size() != 0){\\n                        int idx = kyu.front();\\n                        kyu.pop();\\n                        int a = idx/m, b = idx % m;\\n                        for(vector<int>& d: dir){\\n                            int r = a + d[0];\\n                            int c = b + d[1];\\n                            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                                kyu.push(r*m + c);\\n                                grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```\\n//union find\\nint findPar(int u, vector<int>& par){\\n        return par[u] == u ? u : (par[u] = findPar(par[u], par));\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int m = grid[0].size(), n = grid.size();\\n        vector<int> par(n*m);\\n        for(int i = 0; i < n*m; i++) par[i] = i;\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    int p1 = findPar(i *m + j, par);\\n                    for(vector<int>& d : dir){\\n                        int r = i + d[0], c = j + d[1];\\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                            int p2 = findPar(r*m + c, par);\\n                            if(p1 != p2) {\\n                                par[p2] = p1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int idx = 0; idx < n*m; idx++){\\n            int i = idx/ m, j = idx%m;\\n            if(par[idx] == idx && grid[i][j] == \\'1\\') ans++; \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nExplanations:\\nMethod 1: Our own and powerful DFS, we just go to every one, from there travel\\nto its every adjacent 1, and mark it as zero.\\nNow for one island one dfs will mark all of its adjacent 1s to zero. \\nAnother 1 comes, that means one more island or component to work with and we travel from that 1, \\nto all of its adjacent and mark it as zero.\\n\\nMethod 2: Basic BFS, We encounter a 1, we do bfs from that one to all its adjacent 1\\'s \\njust like we did in our DFS, the method is different, here we use a que, insert adjacent 1, and keep doing it.\\n\\nMethod 3: Union Find, Here we are only doing Path Compression and not Union, \\nwhich only hampers our time complexity by a constant but we do save space\\nbecause we didn\\'t take a size array nor did we make an extra class. \\nAnd more over this method is simpler to code in actual interview sense.\\nSo, what we did was first declare every element to be its own parent.\\nNow, we encounter our (name: hero)first one, its parent is him only,\\nthen we go to its adjacent elements and mark its parent as the \\nindex of our first one(remember, hero) only. \\nAfter we our done with this process, we just go and traverse all the elements which\\nare its own parent and in grid its value is \\'1\\'.\\nSimple, and codeable in an interview. \\nDo upvote. Thankyou.\\n```\n```\\n//dfs\\nint n,m;\\n    void dfsNumIsland(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& dir){\\n        grid[i][j] = \\'0\\';\\n        for(vector<int>& d: dir){\\n            int r = i + d[0], c = j + d[1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\')\\n                dfsNumIsland(grid, r,c,dir);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        int component = 0;\\n        n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j< m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                  component++;\\n                  dfsNumIsland(grid,i,j, dir);\\n                }\\n            }\\n        }\\n        return component;\\n    }\\n```\n```\\n//bfs\\nint numIslands(vector<vector<char>>& grid) {\\nint n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        queue<int> kyu;\\n        vector<vector<int>> dir = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    kyu.push(i*m + j);\\n                    while(kyu.size() != 0){\\n                        int idx = kyu.front();\\n                        kyu.pop();\\n                        int a = idx/m, b = idx % m;\\n                        for(vector<int>& d: dir){\\n                            int r = a + d[0];\\n                            int c = b + d[1];\\n                            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                                kyu.push(r*m + c);\\n                                grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n//union find\\nint findPar(int u, vector<int>& par){\\n        return par[u] == u ? u : (par[u] = findPar(par[u], par));\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int m = grid[0].size(), n = grid.size();\\n        vector<int> par(n*m);\\n        for(int i = 0; i < n*m; i++) par[i] = i;\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    int p1 = findPar(i *m + j, par);\\n                    for(vector<int>& d : dir){\\n                        int r = i + d[0], c = j + d[1];\\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                            int p2 = findPar(r*m + c, par);\\n                            if(p1 != p2) {\\n                                par[p2] = p1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int idx = 0; idx < n*m; idx++){\\n            int i = idx/ m, j = idx%m;\\n            if(par[idx] == idx && grid[i][j] == \\'1\\') ans++; \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245637,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int islands(int i, int j, vector<vector<char>> &grid)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size())\\n            return 0;\\n        if(grid[i][j] == \\'1\\')\\n        {\\n            grid[i][j] = 0;    // markinng the current cell as visited by sinking the land\\n            int x = islands(i+1, j, grid);\\n            int y = islands(i-1, j, grid);\\n            int w = islands(i, j+1, grid);\\n            int z = islands(i, j-1, grid);\\n            if(1+x+y+z+w >= 1)              // if area of island is atleast connected by 1 cell then island exists\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == \\'1\\')\\n                    count += islands(i, j, grid);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islands(int i, int j, vector<vector<char>> &grid)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size())\\n            return 0;\\n        if(grid[i][j] == \\'1\\')\\n        {\\n            grid[i][j] = 0;    // markinng the current cell as visited by sinking the land\\n            int x = islands(i+1, j, grid);\\n            int y = islands(i-1, j, grid);\\n            int w = islands(i, j+1, grid);\\n            int z = islands(i, j-1, grid);\\n            if(1+x+y+z+w >= 1)              // if area of island is atleast connected by 1 cell then island exists\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == \\'1\\')\\n                    count += islands(i, j, grid);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746230,
                "title": "python-dfs-solution-without-modifying-input-data",
                "content": "```\\ndef numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        islands = 0\\n        visited = set()\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == \\'1\\' and (row, col) not in visited:\\n                    islands += 1\\n                    self.dfs(grid, row, col, visited)\\n        return islands\\n    \\n    def dfs(self, grid, row, col, visited):\\n        if (row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0])\\n            and (row, col) not in visited and grid[row][col] == \\'1\\'):\\n            visited.add((row, col))\\n            self.dfs(grid, row + 1, col, visited)\\n            self.dfs(grid, row - 1, col, visited)\\n            self.dfs(grid, row, col + 1, visited)\\n            self.dfs(grid, row, col - 1, visited)\\n```\\nMany of the solutions from other users (and the official solution) involve updating elements in the grid to \\'0\\' to mark them as \"visited\".\\n\\nIn practice, this is a poor choice, as it  modifies the input data as a side-effect of the solution.\\n\\nUnless you have been explicitly told to modify some input \"in-place\", you should avoid this.\\n\\nIn my solution I chose to use a Set of tuples of (row, col) to keep track of each element I\\'ve already visited.\\n\\nYou might be asking: \"Doesn\\'t this add to the overall memory usage of the solution?\"\\n\\nAnd the answer would be \"yes\", however it does not increase the space *complexity* of the solution.\\n\\nSince we\\'re doing a DFS to mark each \"island\", we already have a space complexity of O(M x N); in the *worst-case* our DFS will visit every element in the grid and thus make M x N recursive calls.\\n\\nAdding on an additional M x N space by tracking the \"visited\" elements in a Set (you could also use an additional 2D list/array), does not increase the space *complexity*. This is because when we assess the \"Big O\" space of a solution, we drop constant terms. \\n\\nA solution that is O(2 x M x N) is still considered O(M x N).",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        islands = 0\\n        visited = set()\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == \\'1\\' and (row, col) not in visited:\\n                    islands += 1\\n                    self.dfs(grid, row, col, visited)\\n        return islands\\n    \\n    def dfs(self, grid, row, col, visited):\\n        if (row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0])\\n            and (row, col) not in visited and grid[row][col] == \\'1\\'):\\n            visited.add((row, col))\\n            self.dfs(grid, row + 1, col, visited)\\n            self.dfs(grid, row - 1, col, visited)\\n            self.dfs(grid, row, col + 1, visited)\\n            self.dfs(grid, row, col - 1, visited)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706851,
                "title": "c-beats-94",
                "content": "C# solution beating 94% of csharp submissions, please let me know if you have any questions of can suggest code improvements for this solution to optimize! Thanks!\\n\\n```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n        \\n        if (grid == null || grid.Length == 0) \\n        {\\n            return 0;\\n        }\\n        \\n        int numberOfIslands = 0;\\n        \\n        for (int i = 0; i < grid.GetLength(0); i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                char v = grid[i][j];\\n                if (v == \\'1\\')\\n                {\\n                    numberOfIslands += sink(grid, i, j);\\n                }\\n            } \\n        }\\n        \\n        return numberOfIslands;\\n    }\\n    \\n    public int sink(char[][] grid, int i, int j)\\n    {\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\')\\n        {\\n            return 0;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        sink(grid, i, j + 1);\\n        sink(grid, i, j - 1);\\n        sink(grid, i + 1, j);\\n        sink(grid, i - 1, j);\\n        return 1;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7bedd007-f1a3-4819-8836-1e30d32660cf_1593202040.5866594.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n        \\n        if (grid == null || grid.Length == 0) \\n        {\\n            return 0;\\n        }\\n        \\n        int numberOfIslands = 0;\\n        \\n        for (int i = 0; i < grid.GetLength(0); i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                char v = grid[i][j];\\n                if (v == \\'1\\')\\n                {\\n                    numberOfIslands += sink(grid, i, j);\\n                }\\n            } \\n        }\\n        \\n        return numberOfIslands;\\n    }\\n    \\n    public int sink(char[][] grid, int i, int j)\\n    {\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\')\\n        {\\n            return 0;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        sink(grid, i, j + 1);\\n        sink(grid, i, j - 1);\\n        sink(grid, i + 1, j);\\n        sink(grid, i - 1, j);\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583546,
                "title": "python-counting-islands-with-dfs",
                "content": "The idea is to go through every cell of the grid and whenever you step on the cell with \\'1\\', you increment your island count and you do depth first search in four directions (r-1, c) (r+1, c) (r, c-1) (r, c+1) where r and c are current row and column indices.\\n\\nWhen you are doing depth first search, you flip every \\'1\\' to \\'0\\'.\\n\\nThe depth first search essentially finds all the connected islands (the ones which are connected to the original cell which starts the whole DFS chain), and flips them to zero. By doing so, you will just skip these cells with \\'0\\' when you are back to normally going through every cell.\\n\\nThis DFS will make sure every connected islands to the original cell is all flipped to zero while leaving non-connected cells as they were.\\n\\nNow, when you are normally going through every cell and if you step on \\'0\\', you just ignore it and go to the next cell.\\n\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) < 1:\\n            return 0\\n        \\n        def dfs(r, c):            \\n            if r<0 or c<0 or r>rows-1 or c>cols-1 or grid[r][c]==\\'0\\': # Check whether we have reached beyond the edge of the grid or the current cell is \\'0\\'. If so, terminate the recursion stack.\\n                return       \\n            grid[r][c] = \\'0\\'     # Flips all the connected islands to \\'0\\'s\\n            \\n\\t\\t\\t# DFS in all four directions\\n            dfs(r-1, c)\\n            dfs(r+1, c)\\n            dfs(r, c-1)\\n            dfs(r, c+1)\\n                    \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        num_islands = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                cell = grid[r][c]\\n                \\n                if cell == \\'0\\':\\n                    continue\\n                \\n                if cell == \\'1\\':\\n                    num_islands += 1\\n                    dfs(r, c)\\n                                  \\n        return num_islands\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) < 1:\\n            return 0\\n        \\n        def dfs(r, c):            \\n            if r<0 or c<0 or r>rows-1 or c>cols-1 or grid[r][c]==\\'0\\': # Check whether we have reached beyond the edge of the grid or the current cell is \\'0\\'. If so, terminate the recursion stack.\\n                return       \\n            grid[r][c] = \\'0\\'     # Flips all the connected islands to \\'0\\'s\\n            \\n\\t\\t\\t# DFS in all four directions\\n            dfs(r-1, c)\\n            dfs(r+1, c)\\n            dfs(r, c-1)\\n            dfs(r, c+1)\\n                    \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        num_islands = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                cell = grid[r][c]\\n                \\n                if cell == \\'0\\':\\n                    continue\\n                \\n                if cell == \\'1\\':\\n                    num_islands += 1\\n                    dfs(r, c)\\n                                  \\n        return num_islands\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 423731,
                "title": "javascript-recursive-and-iterative-solutions",
                "content": "```\\nconst removeIslandIterative = (grid, x, y) => {\\n    let stack = []\\n    stack.push({x,y})\\n    while (stack.length > 0) {\\n        const {x, y} = stack.pop()\\n        grid[x][y] = \"0\"\\n        addIfValidCoordinate(stack,grid,x+1,y)\\n        addIfValidCoordinate(stack,grid,x-1,y)\\n        addIfValidCoordinate(stack,grid,x,y+1)\\n        addIfValidCoordinate(stack,grid,x,y-1)\\n    }\\n}\\n\\nconst addIfValidCoordinate = (stack, grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] === \"0\") return\\n    stack.push({x,y})\\n}\\n\\nconst removeIslandRecursive = (grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length  || y >= grid[x].length || grid[x][y] === \"0\") {\\n        return\\n    }\\n    grid[x][y] = \"0\"\\n    removeIslandRecursive(grid,x+1,y)\\n    removeIslandRecursive(grid,x-1,y)\\n    removeIslandRecursive(grid,x,y+1)\\n    removeIslandRecursive(grid,x,y-1)\\n}\\n\\nconst numIslands = (grid) => {\\n    let numOfIslands = 0\\n    grid.map((r,x) => {\\n        r.map((c,y) => {\\n            if (grid[x][y] === \"1\") {\\n                numOfIslands++   \\n                removeIslandRecursive(grid, x, y)\\n\\t\\t\\t\\t// removeIslandIterative(grid, x, y)\\n            }\\n        })\\n    })\\n    return numOfIslands\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeIslandIterative = (grid, x, y) => {\\n    let stack = []\\n    stack.push({x,y})\\n    while (stack.length > 0) {\\n        const {x, y} = stack.pop()\\n        grid[x][y] = \"0\"\\n        addIfValidCoordinate(stack,grid,x+1,y)\\n        addIfValidCoordinate(stack,grid,x-1,y)\\n        addIfValidCoordinate(stack,grid,x,y+1)\\n        addIfValidCoordinate(stack,grid,x,y-1)\\n    }\\n}\\n\\nconst addIfValidCoordinate = (stack, grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] === \"0\") return\\n    stack.push({x,y})\\n}\\n\\nconst removeIslandRecursive = (grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length  || y >= grid[x].length || grid[x][y] === \"0\") {\\n        return\\n    }\\n    grid[x][y] = \"0\"\\n    removeIslandRecursive(grid,x+1,y)\\n    removeIslandRecursive(grid,x-1,y)\\n    removeIslandRecursive(grid,x,y+1)\\n    removeIslandRecursive(grid,x,y-1)\\n}\\n\\nconst numIslands = (grid) => {\\n    let numOfIslands = 0\\n    grid.map((r,x) => {\\n        r.map((c,y) => {\\n            if (grid[x][y] === \"1\") {\\n                numOfIslands++   \\n                removeIslandRecursive(grid, x, y)\\n\\t\\t\\t\\t// removeIslandIterative(grid, x, y)\\n            }\\n        })\\n    })\\n    return numOfIslands\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56606,
                "title": "my-c-solution-using-union-find-set",
                "content": "    class Solution {\\n    public:\\n        int total;\\n        int getparent(vector<int>& parent,int a){\\n            if(parent[a] != a)\\n                parent[a] = getparent(parent,parent[a]);\\n            return parent[a];\\n        }\\n        void merge(vector<int>& parent,int a,int b){\\n            int p1 = getparent(parent,a);\\n            int p2 = getparent(parent,b);\\n            if(p1 == p2)  return;\\n            parent[p2] = p1;\\n            --total; \\n        }\\n        int numIslands(vector<vector<char>>& grid) {\\n            if(grid.size() == 0 || grid[0].size() == 0) return 0;\\n            int M = grid.size();\\n            int N = grid[0].size();\\n            vector<int> parent(M*N);\\n            total = M*N;\\n            for(int i=0;i<M;++i)\\n                for(int j=0;j<N;++j){\\n                    int index = i*N+j;\\n                    parent[index] = index;\\n                    if(grid[i][j] == '0') --total;\\n                    else{\\n                        if(i>0 && grid[i-1][j] == '1')\\n                            merge(parent,index,(i-1)*N + j);\\n                        if(j>0 && grid[i][j-1] == '1')\\n                            merge(parent,index,index-1);\\n                    }\\n                }\\n            return total;\\n        }\\n    };",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n    public:\\n        int total;\\n        int getparent(vector<int>& parent,int a){\\n            if(parent[a] != a)\\n                parent[a] = getparent(parent,parent[a]);\\n            return parent[a];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3811433,
                "title": "java-super-simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI went with brut force approach. See question asks about number of island where an island is number of adjacent one\\'s surrounded by zero\\'s.\\nMeans if you start from a source vertex and traverse all the one\\'s which are adjacent to it from source one\\'s are considered to be an island and we need to find such island.\\nHere i have used dfs you can either use bfs\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1: create a visited matrix equal to size of the grid given and plaxe 0 in all the places of visited matrix\\n2: take a count variable to take a count of number of island\\n3: Start a for loop from 1st element in grid and check if that element is 0 in visited and 1 in grid means we have a land which is unvisted till now\\n4: increase the count by 1 as you found 1st island\\n5: run a dfs (the code of dfs is as usual) on that node and find all the node\\'s which you can visit from the current node and mark them 1\\n6: as soon as dfs will over you will get the region of 1st island\\n7: you will move forward to the next element in your for loop untill you check all the elements and repeat the above 6 steps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N*M)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/8013a055-21ad-4622-b01c-3646e4f937cf_1690227303.9957466.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int visited[][] = new int[n][m]; // Create a 2D array to keep track of visited cells\\n\\n        // Initialize all cells of the \\'visited\\' array to 0 (not visited)\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        int count = 0; // Variable to keep track of the number of islands\\n\\n        // Traverse the grid and perform DFS to find the islands\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n\\n                if(visited[i][j] == 0 && grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid,i, j, visited);\\n                }\\n            }\\n        }\\n        return count; // Return the total count of islands\\n    }\\n\\n    // Depth First Search (DFS) function to explore the island starting from a given cell\\n    private void dfs(char grid[][], int row, int col, int visited[][]){\\n\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int delrow[] = {-1, 0, 1, 0}; // Array to represent possible row moves (up, right, down, left)\\n        int delcol[] = {0, 1, 0, -1}; // Array to represent possible column moves (up, right, down, left)\\n\\n        // Explore the adjacent cells (up, right, down, left) in a depth-first manner\\n        for(int i = 0; i < 4; i++){\\n\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            // Check if the adjacent cell is within the grid boundaries, not visited, and contains \\'1\\' (part of the island)\\n            if(nrow >= 0  && nrow < n && ncol >= 0 && ncol < m\\n                && visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\')\\n                {\\n                    // Recursively call DFS on the adjacent cell\\n                    dfs(grid, nrow, ncol, visited);\\n                } \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int visited[][] = new int[n][m]; // Create a 2D array to keep track of visited cells\\n\\n        // Initialize all cells of the \\'visited\\' array to 0 (not visited)\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        int count = 0; // Variable to keep track of the number of islands\\n\\n        // Traverse the grid and perform DFS to find the islands\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n\\n                if(visited[i][j] == 0 && grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid,i, j, visited);\\n                }\\n            }\\n        }\\n        return count; // Return the total count of islands\\n    }\\n\\n    // Depth First Search (DFS) function to explore the island starting from a given cell\\n    private void dfs(char grid[][], int row, int col, int visited[][]){\\n\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int delrow[] = {-1, 0, 1, 0}; // Array to represent possible row moves (up, right, down, left)\\n        int delcol[] = {0, 1, 0, -1}; // Array to represent possible column moves (up, right, down, left)\\n\\n        // Explore the adjacent cells (up, right, down, left) in a depth-first manner\\n        for(int i = 0; i < 4; i++){\\n\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            // Check if the adjacent cell is within the grid boundaries, not visited, and contains \\'1\\' (part of the island)\\n            if(nrow >= 0  && nrow < n && ncol >= 0 && ncol < m\\n                && visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\')\\n                {\\n                    // Recursively call DFS on the adjacent cell\\n                    dfs(grid, nrow, ncol, visited);\\n                } \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498081,
                "title": "c-dfs-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[i].size();j++)\\n                if(grid[i][j]==\\'1\\')// if 1, call the dfs and make res++ to add this island \\n                {\\n                    dfs(grid,i,j);\\n                    res++;\\n                }\\n        return res;\\n    }\\n    void dfs(vector<vector<char>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() || v[i][j]==\\'0\\')\\n            return;\\n        \\n        v[i][j]=\\'0\\';// reset to 0 as this is already included\\n        dfs(v,i-1,j);\\n        dfs(v,i+1,j);\\n        dfs(v,i,j-1);\\n        dfs(v,i,j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[i].size();j++)\\n                if(grid[i][j]==\\'1\\')// if 1, call the dfs and make res++ to add this island \\n                {\\n                    dfs(grid,i,j);\\n                    res++;\\n                }\\n        return res;\\n    }\\n    void dfs(vector<vector<char>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() || v[i][j]==\\'0\\')\\n            return;\\n        \\n        v[i][j]=\\'0\\';// reset to 0 as this is already included\\n        dfs(v,i-1,j);\\n        dfs(v,i+1,j);\\n        dfs(v,i,j-1);\\n        dfs(v,i,j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268293,
                "title": "number-of-islands-detailed-explanation",
                "content": "**PROBLEM STATEMENT**\\n//this problem is similar to that of number of components in an undirected graph.\\n//our task is to return number of connected components (which are islands indirectly in this problem)\\n//The islands are denoted with \\'1\\' and water with \\'0\\'.\\n**APPROACH**\\n-> we will use a seperate function which will perform DFS traversal \\n->  we will mark the visited vertex as \\'0\\' (can mark it as any other number also)\\n-> In our main function , we will traverse every row and every column and check if it is not visited \\n->if it is not visited then we will perform the traversal and increment the count \\'n\\' which will store no of times the DFS traversal is performed \\n-> no of times DFS performed = no of islands (connected components)\\n\\n**CODE**\\n```\\nint numIslands(vector<vector<char>>& grid) {\\n        //to check \\n        int n = 0;//islands count\\n        for(int i=0;i< grid.size();i++){\\n            for(int j=0;j< grid[0].size();j++){\\n                //performing DFS if its not visited\\n                if(grid[i][j]==\\'1\\'){\\n                    n++;\\n                    DFS(i,j,grid);\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n    void DFS(int r,int c,vector<vector<char>>& grid){\\n        //preventing crossing boundaries by checking\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size()){\\n            return;\\n        }\\n        //returning if the cuRrent position is already visited\\n        if(grid[r][c]==\\'0\\'){\\n            return;\\n        }\\n        //marking the unvisited vertex as visited by marking it as 0\\n        grid[r][c] = \\'0\\';\\n        //moving in all 4 directions and visiting them recursively\\n        DFS(r+1,c,grid);\\n        DFS(r,c-1,grid);\\n        DFS(r-1,c,grid);\\n        DFS(r,c+1,grid);\\n    }\\n    \\n```\\n*Hope it is clear. Thanks for reading it. Do upvote if it is useful :-)*\\n-----------------------------------HAPPY LEARNING--------------------------------------------",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nint numIslands(vector<vector<char>>& grid) {\\n        //to check \\n        int n = 0;//islands count\\n        for(int i=0;i< grid.size();i++){\\n            for(int j=0;j< grid[0].size();j++){\\n                //performing DFS if its not visited\\n                if(grid[i][j]==\\'1\\'){\\n                    n++;\\n                    DFS(i,j,grid);\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n    void DFS(int r,int c,vector<vector<char>>& grid){\\n        //preventing crossing boundaries by checking\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size()){\\n            return;\\n        }\\n        //returning if the cuRrent position is already visited\\n        if(grid[r][c]==\\'0\\'){\\n            return;\\n        }\\n        //marking the unvisited vertex as visited by marking it as 0\\n        grid[r][c] = \\'0\\';\\n        //moving in all 4 directions and visiting them recursively\\n        DFS(r+1,c,grid);\\n        DFS(r,c-1,grid);\\n        DFS(r-1,c,grid);\\n        DFS(r,c+1,grid);\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583531,
                "title": "easy-python3-dfs-solution-using-set-with-comments-o-n-runtime-o-n-space",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        land = set()\\n        \\n        #Put all pieces of land in a set\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                if grid[row][column] == \"1\":\\n                    land.add((row, column))\\n        islands = 0\\n        \\n        #If the piece of land is still in the\\n        #set we have not explored it yet. If\\n        #a piece of land we try to explore is\\n        #not in the set, we have already explored\\n        #it so we do nothing or it is water.\\n        def explore(r, c):\\n            if (r,c) in land:\\n                land.remove((r,c))\\n                explore(r, c+1)\\n                explore(r, c-1)\\n                explore(r+1, c)\\n                explore(r-1, c)            \\n            \\n        while land:\\n            #We want to get any piece of land\\n            #still in the set, but we don\\'t want\\n            #to remove it yet. We do that in the\\n            #explore function.\\n            piece = land.pop()\\n            land.add(piece)\\n            \\n            #Explore adjacent pieces of land:\\n            explore(piece[0], piece[1])\\n            islands += 1\\n        \\n        return islands\\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        land = set()\\n        \\n        #Put all pieces of land in a set\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                if grid[row][column] == \"1\":\\n                    land.add((row, column))\\n        islands = 0\\n        \\n        #If the piece of land is still in the\\n        #set we have not explored it yet. If\\n        #a piece of land we try to explore is\\n        #not in the set, we have already explored\\n        #it so we do nothing or it is water.\\n        def explore(r, c):\\n            if (r,c) in land:\\n                land.remove((r,c))\\n                explore(r, c+1)\\n                explore(r, c-1)\\n                explore(r+1, c)\\n                explore(r-1, c)            \\n            \\n        while land:\\n            #We want to get any piece of land\\n            #still in the set, but we don\\'t want\\n            #to remove it yet. We do that in the\\n            #explore function.\\n            piece = land.pop()\\n            land.add(piece)\\n            \\n            #Explore adjacent pieces of land:\\n            explore(piece[0], piece[1])\\n            islands += 1\\n        \\n        return islands\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 56569,
                "title": "8ms-c-solution-using-union-find-with-a-dummy-point",
                "content": "My idea comes from the solution of [Surrounded Regions](https://leetcode.com/discuss/6285/solve-it-using-union-find).\\n\\nIt's obvious to connect adjacent 1s. Then how to handle 0s?\\n\\nAn interesting finding is that if we connect all 0s, then the count of UF is equal to the number of islands plus 1.\\n\\n\\n    class UF {\\n    public:\\n    \\tUF(int N) {\\n    \\t\\tcount = N;\\n    \\t\\tid = new int[N];\\n    \\t\\tweight = new int[N];\\n    \\t\\tfor (int i = 0; i < N; i++) {\\n    \\t\\t\\tid[i] = i;\\n    \\t\\t\\tweight[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    \\t~UF() {\\n    \\t\\tdelete[]id;\\n    \\t\\tdelete[]weight;\\n    \\t}\\n    \\tvoid unionP(int p, int q) {\\n    \\t\\tint i = root(p);\\n    \\t\\tint j = root(q);\\n    \\t\\tif (i == j) {\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (weight[i] < weight[j]) {\\n    \\t\\t\\tid[i] = j;\\n    \\t\\t}\\n    \\t\\telse if (weight[i] > weight[j]) {\\n    \\t\\t\\tid[j] = i;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tid[i] = j;\\n    \\t\\t\\tweight[j]++;\\n    \\t\\t}\\n    \\t\\tcount--;\\n    \\t}\\n    \\tbool connected(int p, int q) {\\n    \\t\\treturn root(p) == root(q);\\n    \\t}\\n    \\tint getCount() {\\n    \\t\\treturn count;\\n    \\t}\\n    private:\\n    \\tint *id;\\n    \\tint *weight;\\n    \\tint count;\\n    \\tint root(int i) {\\n    \\t\\twhile (i != id[i]) {\\n    \\t\\t\\tid[i] = id[id[i]];\\n    \\t\\t\\ti = id[i];\\n    \\t\\t}\\n    \\t\\treturn i;\\n    \\t}\\n    };\\n    \\n    class Solution {\\n    public:\\n    \\t// Runtime: 8 ms\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tif (grid.empty() || grid[0].empty()) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\t\\tint ROW = grid.size(), COL = grid[0].size();\\n    \\t\\tUF uf(ROW * COL + 1);\\n    \\t\\tint dummyPoint = ROW * COL; // We assume it as 0 and it connects all 0s.\\n    \\t\\tfor (int i = 0; i < ROW; i++) {\\n    \\t\\t\\tfor (int j = 0; j < COL; j++) {\\n    \\t\\t\\t\\tif (grid[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (j != COL - 1 && grid[i][j + 1] == '1') {\\n    \\t\\t\\t\\t\\t\\tuf.unionP(i * COL + j, i * COL + j + 1);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (i != ROW - 1 && grid[i + 1][j] == '1') {\\n    \\t\\t\\t\\t\\t\\tuf.unionP(i * COL + j, (i + 1) * COL + j);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse {\\n    \\t\\t\\t\\t\\tuf.unionP(i * COL + j, dummyPoint);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn uf.getCount() - 1;\\n    \\t}\\n    };",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n    public:\\n    \\t// Runtime: 8 ms\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tif (grid.empty() || grid[0].empty()) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 56639,
                "title": "4ms-c-dfs-solution-reusing-grid-to-memoize-visited-squares",
                "content": "    bool visit(char **grid, int numRows, int numColumns, int x, int y) \\n    {\\n        if ( x <0 || y < 0 || x >= numColumns || y >= numRows || grid[y][x] != '1')\\n            return false;\\n        \\n        grid[y][x] = 'v'; //visited\\n        \\n        visit(grid, numRows, numColumns, x + 1, y);\\n        visit(grid, numRows, numColumns, x - 1, y);\\n        visit(grid, numRows, numColumns, x, y + 1);\\n        visit(grid, numRows, numColumns, x, y -1);\\n        \\n        return true;\\n    }\\n    \\n    int numIslands(char **grid, int numRows, int numColumns) \\n    {\\n        int total = 0;\\n        for (int y=0; y < numRows; y++)\\n            for (int x=0; x < numColumns; x++)\\n                total += visit(grid, numRows, numColumns, x, y) ? 1 : 0;\\n            \\n        return total;\\n    }",
                "solutionTags": [],
                "code": "    bool visit(char **grid, int numRows, int numColumns, int x, int y) \\n    {\\n        if ( x <0 || y < 0 || x >= numColumns || y >= numRows || grid[y][x] != '1')\\n            return false;\\n        \\n        grid[y][x] = 'v'; //visited\\n        \\n        visit(grid, numRows, numColumns, x + 1, y);\\n        visit(grid, numRows, numColumns, x - 1, y);\\n        visit(grid, numRows, numColumns, x, y + 1);\\n        visit(grid, numRows, numColumns, x, y -1);\\n        \\n        return true;\\n    }\\n    \\n    int numIslands(char **grid, int numRows, int numColumns) \\n    {\\n        int total = 0;\\n        for (int y=0; y < numRows; y++)\\n            for (int x=0; x < numColumns; x++)\\n                total += visit(grid, numRows, numColumns, x, y) ? 1 : 0;\\n            \\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3081804,
                "title": "one-of-the-best-explanation-animated",
                "content": "https://youtu.be/VvLlyZi-T6g",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3012829,
                "title": "js-very-easy-and-very-fast-solution-with-dfs",
                "content": "# Code\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst CONFIG = [[0, -1], [1, 0], [0, 1], [-1, 0]];\\nvar numIslands = function(grid) {\\n    let output = 0;\\n\\n    const checkIsInValid = (row, col) => row < 0 || row >= grid.length || col < 0 || col >= grid[0].length;\\n\\n    const dfs = (row, col, grid,) => {\\n        if (checkIsInValid(row, col) || grid[row][col] === \\'0\\') return;\\n\\n        grid[row][col] = \"0\";\\n\\n        for (const item of CONFIG) {\\n            dfs(row + item[0], col + item[1], grid);\\n        }\\n    }\\n\\n    for (let i = 0 ; i < grid.length; i++) {\\n        for (let j = 0 ; j < grid[0].length; j++) {\\n            if (grid[i][j] === \"1\") {\\n                output++;\\n                dfs(i, j, grid);\\n            }\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst CONFIG = [[0, -1], [1, 0], [0, 1], [-1, 0]];\\nvar numIslands = function(grid) {\\n    let output = 0;\\n\\n    const checkIsInValid = (row, col) => row < 0 || row >= grid.length || col < 0 || col >= grid[0].length;\\n\\n    const dfs = (row, col, grid,) => {\\n        if (checkIsInValid(row, col) || grid[row][col] === \\'0\\') return;\\n\\n        grid[row][col] = \"0\";\\n\\n        for (const item of CONFIG) {\\n            dfs(row + item[0], col + item[1], grid);\\n        }\\n    }\\n\\n    for (let i = 0 ; i < grid.length; i++) {\\n        for (let j = 0 ; j < grid[0].length; j++) {\\n            if (grid[i][j] === \"1\") {\\n                output++;\\n                dfs(i, j, grid);\\n            }\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711272,
                "title": "c-detailed-approach-using-graph-dfs-and-bfs-approach-and-code",
                "content": "# Approach to the problem\\nIn a very naive mentality, all you have to do is to find one piece of land and thereafter see all the lands which are present in any of the 4 directions (North, South, East, West) corresponding to the land you are at. Once you are at a piece of land, you mark it as _Discovered_ and thereafter look in the directions, ultimately marking them as _Discovered_ too.\\n\\nOn further exploration, you don\\'t explore any further when a particular piece of land is marked as _Discovered_. Rather, you look for lands which are still _Undiscovered_ and start your exploration from that point, performing the same set of operations as mentioned above. \\n\\nSince you are not exploring lands repeatedly (By marking lands as _Discovered_), the total number of islands in the area is equal to the number of times you find a land which is _Undiscovered_. \\n\\nSeems tough? Naah it ain\\'t.\\nGo through the steps below and you would find this as a piece of cake.\\n\\n# Procedure.\\n* First, we create an array called `visited` which marks whether a land is either _Discovered_ or _Undiscovered_.\\n\\t* Elements which are discovered are marked as `1` and the non-discovered are by default marked as `0`\\n`vector<vector<int>> visited (rows , vector<int> (cols , 0));`\\n\\n*  We iterate throughout the 2D Array and find the first piece of land which is _Undiscovered_ \\n\\t* Note that an undiscovered land is a land which is not visited before\\n`!visited[row][col] && grid[row][col] == \\'1\\'`\\n\\n* Once we find a piece of land which is _Undiscovered_, we start looking for surrounding lands and keep marking them as discovered as well. \\n\\t* By doing so, we would _Discover_ the whole island.\\n\\t* Since we start our exploration when the land is marked as _Undiscovered_, our next search will start when we discover the next island. Hence we can say once we reach at a piece of land, we have discovered an island.\\n\\t* Hence, we create a variable which stores the number of islands and increment it once we find a piece of _Undiscovered_ land. \\n\\t* In Graph Theory, we can use either **DFS (Depth first search) or BFS (Breadth First Search)** to _Discover_ the whole island. The explanations for both are given below:\\n\\n## Breadth First Search\\n* The breadth first approach is an approach which traverses the graph breadth wise. In other words, the lands are _Discovered_ layer by layer.\\n* For this, we use a **Queue** Data Structure to store the next cordinates of land which are surrounded by the piecec of land we currently _Discovererd_. These cordinateds in the queue would be _Discovered_ in the order they are added to the data structure.\\n* We push the first set of cordinates we _Discovered_ in the queue\\n\\n```\\nqueue<pair<int , int>> q;\\nq.push({row , col});\\nvisited[row][col] = 1;\\n```\\n\\n* For further explorations, we look at all the 4 directions at which any _Undiscovered_ piece of land maybe available. For doing so, we perform the following: \\n\\t* Here, we increase the row from -1 to +1 (West to East) \\n\\t* Similarly, we increase the column from -1 to +1 (South to North)\\n\\t* We just want the NSEW directions, for which the rows and columns should be like following:\\n\\t\\t* `(row + 1 , col)`\\n\\t\\t* `(row , col + 1)`\\n\\t\\t* `(row - 1 , col)`\\n\\t\\t* `(row , col - 1`\\n\\t* To maintain this order, we have added the `abs(deltaRow) != abs(deltaCol)` condition.\\n\\n```\\nfor(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n\\t for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n\\t\\t if(abs(deltaRow) != abs(deltaCol)){\\n\\t\\t\\t // Code Further Here\\n\\t\\t }\\n\\t}\\n```\\n\\n* Further to this, we check whether the cordinates of this _Undiscovered_ land is within the bounds of the 2D Array. Hence, we check the following conditions after getting the above mentioned coordinates:\\n```\\n// Row Conditions\\n\\tnewRow >= 0 && newRow < grid.size() &&\\n// Col Conditions\\n\\tnewCol >= 0 && newCol < grid[0].size() &&\\n```\\n\\n* Finally, we check whether this piece of land, whose coordinates we have just deducted, is actually discovered or not. For doing this, we perform the following checks\\n\\t* Whether there is land at the coordinates we have landed (`grid[newRow][newCol] == \\'1\\'`)\\n\\t* Whether we have visitted the land earlier or not (`!visited[newRow][newCol]`)\\n\\n* If the above conditions hold true, we mark this _Unvisited_ land as _Visited_ by marking it as visited in the array.\\n* We perform these operations until all the places in the area is explored. In simple terms, we perform the operation until the Queue is not empty.\\n\\n## Depth First Search\\n* Comparing it to BFS, DFS is comparatively simple, since we don\\'t have to create a Data Structure to add the coordinates that we have to _Discover_.\\n* Herein, we use recursion to reach the coordinates of _Undiscovered_ land. \\n* Once we get the cordinates of the _Undiscovered_ land, we mark that as _Discovered_ by making changes in the `visited` array.\\n* Similar to what we did above, we perform the loops to get the cordinates of the nearby areas and thereafter finding whether these cordinates represent _Undirected_ land. \\n* After deducing the coordinates of the land and checking whether that\\'s actually a land moreover an _Undiscovered_ land, we mark it as _Discovered_ in the `visited` array and start our exploration once again from this point which we were able to come to.\\n* We discover until we have explored the whole island, i.e., all the _Undiscovered_ land on the island is _Discovered_.\\n(If you understood the BFS Code, this is a cakewalk for you)\\n\\n# Code\\n**Note:** The codes for both DFS and BFS are mentioned in the private access modifier of the Solution class.\\nFeel free to use either of them for the solution. However, the DFS function returns a better outcome in terms of runtime and memory usage.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        visited[row][col] = 1;\\n        \\n        for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            dfs(newRow , newCol , visited , grid);\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n    \\n    void bfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        queue<pair<int , int>> q;\\n        q.push({row , col});\\n        visited[row][col] = 1;\\n        \\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            \\n            for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            visited[newRow][newCol] = 1;\\n                            q.push({newRow , newCol});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<vector<int>> visited (rows , vector<int> (cols , 0));\\n        int islands = 0;\\n        \\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                if(!visited[row][col] && grid[row][col] == \\'1\\'){\\n                    islands++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// You can use either BFS or DFS, the functions of both are mentioned \\n\\t\\t\\t\\t\\t// in the private segment of the class\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// bfs(row , col , visited , grid);\\n                    dfs(row , col , visited , grid);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n};\\n```\\n\\n# Add On-s \\nThere maybe a problem wherein an island is defined in a differnt fashion.\\nYou can have an island where you can have lands in 8 directions (North, South, East, West, North-East, North-West, South-East, South-West). In such a case, you can have these combinations:\\n* `(row + 1, col)`\\n* `(row + 1 , col + 1)`\\n* `(row + 1, col - 1)`\\n* `(row - 1, col)`\\n* `(row - 1, col + 1)`\\n* `(row - 1, col - 1)`\\n* `(row , col + 1)`\\n* `(row , col - 1)`\\nTo handle such a scenario, remove the `if(abs(deltaRow) != abs(deltaCol))` condition in the loops inside the DFS and BFS functions\\n\\n# Note\\nI am still learning and I maybe wrong in my approach. In a case like such, please feel free to use the comment section. I\\'ll be obliged to start a discussion \\nFinally, take care of you and your loved once. Call them if it had been a long time that you haven\\'t and just tell them what you feel like. Sometimes it\\'s better to say out than just keep thinking and not speaking.\\nI wish that we all land at the place we\\'re hustling for and we do good in our lives.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nqueue<pair<int , int>> q;\\nq.push({row , col});\\nvisited[row][col] = 1;\\n```\n```\\nfor(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n\\t for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n\\t\\t if(abs(deltaRow) != abs(deltaCol)){\\n\\t\\t\\t // Code Further Here\\n\\t\\t }\\n\\t}\\n```\n```\\n// Row Conditions\\n\\tnewRow >= 0 && newRow < grid.size() &&\\n// Col Conditions\\n\\tnewCol >= 0 && newCol < grid[0].size() &&\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        visited[row][col] = 1;\\n        \\n        for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            dfs(newRow , newCol , visited , grid);\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n    \\n    void bfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        queue<pair<int , int>> q;\\n        q.push({row , col});\\n        visited[row][col] = 1;\\n        \\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            \\n            for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            visited[newRow][newCol] = 1;\\n                            q.push({newRow , newCol});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<vector<int>> visited (rows , vector<int> (cols , 0));\\n        int islands = 0;\\n        \\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                if(!visited[row][col] && grid[row][col] == \\'1\\'){\\n                    islands++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// You can use either BFS or DFS, the functions of both are mentioned \\n\\t\\t\\t\\t\\t// in the private segment of the class\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// bfs(row , col , visited , grid);\\n                    dfs(row , col , visited , grid);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498577,
                "title": "bfs-clean-code-c-easy-to-understand",
                "content": "```\\n   vector<vector<bool>> visit(grid.size(),vector<bool>(grid[0].size(),false));\\n        int count = 0;\\n        queue<pair<int,int>> q;\\n \\n        for(int  i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n             if(visit[i][j] || grid[i][j]==\\'0\\')continue;\\n                q.push({i,j});\\n                count++;\\n                while(q.size()){\\n                    int u = q.front().first;\\n                    int v = q.front().second;\\n                    q.pop();\\n                    if(u>=grid.size() || u<0 || v>=grid[0].size() || v<0 || visit[u][v] || grid[u][v]==\\'0\\')continue;\\n                    visit[u][v] = true; \\n                   q.push({u+1,v});\\n                   q.push({u-1,v});\\n                   q.push({u,v+1});\\n                   q.push({u,v-1}); \\n                }  \\n            }   \\n        }\\n        \\n\\n        return count;\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n   vector<vector<bool>> visit(grid.size(),vector<bool>(grid[0].size(),false));\\n        int count = 0;\\n        queue<pair<int,int>> q;\\n \\n        for(int  i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n             if(visit[i][j] || grid[i][j]==\\'0\\')continue;\\n                q.push({i,j});\\n                count++;\\n                while(q.size()){\\n                    int u = q.front().first;\\n                    int v = q.front().second;\\n                    q.pop();\\n                    if(u>=grid.size() || u<0 || v>=grid[0].size() || v<0 || visit[u][v] || grid[u][v]==\\'0\\')continue;\\n                    visit[u][v] = true; \\n                   q.push({u+1,v});\\n                   q.push({u-1,v});\\n                   q.push({u,v+1});\\n                   q.push({u,v-1}); \\n                }  \\n            }   \\n        }\\n        \\n\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2498196,
                "title": "java-dfs-solution-100-faster",
                "content": "```\\n// Time Complexity :O(m*n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length, count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(char[][] grid, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length \\n           || col >= grid[0].length || grid[row][col] == \\'0\\') return;\\n\\t\\t   \\n        grid[row][col] = \\'0\\'; // mark visited \\n        \\n        dfs(grid, row-1, col);\\n        dfs(grid, row, col-1);\\n        dfs(grid, row+1, col);\\n        dfs(grid, row, col+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n// Time Complexity :O(m*n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length, count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(char[][] grid, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length \\n           || col >= grid[0].length || grid[row][col] == \\'0\\') return;\\n\\t\\t   \\n        grid[row][col] = \\'0\\'; // mark visited \\n        \\n        dfs(grid, row-1, col);\\n        dfs(grid, row, col-1);\\n        dfs(grid, row+1, col);\\n        dfs(grid, row, col+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798494,
                "title": "python3-bfs-clean-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nLAND = \"1\"\\nWATER = \"0\"\\n\\nLEFT = (0, -1)\\nRIGHT = (0, 1)\\nUP = (-1, 0)\\nDOWN = (1, 0)\\n\\nDIRECTIONS = (LEFT, RIGHT, UP, DOWN)\\n\\nclass Solution:\\n    def within_bounds(self, x, y):\\n        return 0 <= x < self.rows and 0 <= y < self.cols\\n    \\n    def is_land(self, x, y):\\n        return self.grid[x][y] == LAND\\n    \\n    def not_visited(self, x, y):\\n        return self.visited[(x, y)] == False\\n        \\n    def bfs(self, row, col):\\n        queue = [(row, col)]\\n        while queue:\\n            x, y = queue.pop(0)\\n            for dx, dy in DIRECTIONS:\\n                new_x = x + dx\\n                new_y = y + dy\\n                \\n                if not self.within_bounds(new_x, new_y):\\n                    continue\\n\\n                if self.is_land(new_x, new_y) and self.not_visited(new_x, new_y):\\n                    queue.append((new_x, new_y))\\n                    self.visited[(new_x, new_y)] = True\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        self.grid = grid\\n        self.visited = defaultdict(lambda: False)\\n        count = 0\\n\\n        for row in range(self.rows):\\n            for col in range(self.cols):\\n                if not self.is_land(row, col):\\n                    continue\\n                \\n                elif (row, col) in self.visited:\\n                    continue\\n                \\n                self.bfs(row, col)\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nLAND = \"1\"\\nWATER = \"0\"\\n\\nLEFT = (0, -1)\\nRIGHT = (0, 1)\\nUP = (-1, 0)\\nDOWN = (1, 0)\\n\\nDIRECTIONS = (LEFT, RIGHT, UP, DOWN)\\n\\nclass Solution:\\n    def within_bounds(self, x, y):\\n        return 0 <= x < self.rows and 0 <= y < self.cols\\n    \\n    def is_land(self, x, y):\\n        return self.grid[x][y] == LAND\\n    \\n    def not_visited(self, x, y):\\n        return self.visited[(x, y)] == False\\n        \\n    def bfs(self, row, col):\\n        queue = [(row, col)]\\n        while queue:\\n            x, y = queue.pop(0)\\n            for dx, dy in DIRECTIONS:\\n                new_x = x + dx\\n                new_y = y + dy\\n                \\n                if not self.within_bounds(new_x, new_y):\\n                    continue\\n\\n                if self.is_land(new_x, new_y) and self.not_visited(new_x, new_y):\\n                    queue.append((new_x, new_y))\\n                    self.visited[(new_x, new_y)] = True\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        self.grid = grid\\n        self.visited = defaultdict(lambda: False)\\n        count = 0\\n\\n        for row in range(self.rows):\\n            for col in range(self.cols):\\n                if not self.is_land(row, col):\\n                    continue\\n                \\n                elif (row, col) in self.visited:\\n                    continue\\n                \\n                self.bfs(row, col)\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209732,
                "title": "standard-1d-union-find-easy-to-understand-full-explanation-1ms",
                "content": "Idea :\\n1. To start with count as `m*n`  ( considering each as separate islands ).\\n2. Create a 1D union find implemented as array(of `m*n` disjoint elements)\\n3. While traversing unify the new island with connected island \\n4. Reduce the count if unified. (since this not a new seperate island but just a connected part of existing island)\\n3. Reduce the count if `grid[0][0] = \\'0\\'` (not an island)\\n\\n\\nWhile checking for an element we only try to unify with `grid[i-1][j]` or `grid[i][j-1]` , since only these may contain existing islands. \\nSo **no** need to check or unify with `grid[i+1][j]` or `grid[i][j+1]`. ( We are not traversing guys, we are just unifying islands we came across previously)\\n\\nThe 2D array of elements are mapped to the 1D union find array. (using `index  = i*n + j`)\\nFor a 2D array `(3x4)`,  the items in the matrix maps to nums array\\'s index in follow fashion\\n0 1 2 3\\n4 5 6 7\\n8 9 10 11\\n\\n\\n\\nHow I got this idea :\\nThis problem is similar to 323 \"The number of connected components in an undirected graph\" \\nhttps://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/\\n(Here connection exist in 4 directions.)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int count = 0;\\n\\t// optional : int m, n can be moved here to avoid passing \\'n\\' in find(int[] nums, int i, int j, int n)\\n    public int numIslands(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] nums = new int[m * n];\\n        for (int k = 0; k < m * n; k++)\\n            nums[k] = k; //(Initializing union find with its own index)  Each element is its own disjoint set\\n\\n        count = m * n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\') \\n                        unify(nums, i, j, i - 1, j, n);\\n\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\') \\n                        unify(nums, i, j, i, j - 1, n);\\n\\n                } else {\\n                    count--; //not an island\\n                }\\n            }\\n\\n        return count;\\n    }\\n\\n    public void unify(int[] nums, int i1, int j1, int i2, int j2, int n) {\\n        int x = find(nums, i1, j1, n);\\n        int y = find(nums, i2, j2, n);\\n        if (x != y) {\\n            nums[x] = y;\\n            count--; //Reducing count since grid[i][j] is not a new separate island but just a connected part of existing island (grid[i-1][j] or grid[i][j-1])\\n        }\\n    }\\n\\n    public int find(int[] nums, int i, int j, int n) {\\n        return find(nums, i * n + j);  //index = i*n + j\\n    }\\n\\n    public int find(int[] nums, int k) {\\n        int root = k;\\n        while (nums[root] != root) {\\n            root = nums[root];\\n        }\\n\\t\\t// path compression \\n        while (nums[k] != k) {\\n            int temp = nums[k];\\n            nums[k] = root;\\n            k = temp;\\n        }\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n\\t// optional : int m, n can be moved here to avoid passing \\'n\\' in find(int[] nums, int i, int j, int n)\\n    public int numIslands(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] nums = new int[m * n];\\n        for (int k = 0; k < m * n; k++)\\n            nums[k] = k; //(Initializing union find with its own index)  Each element is its own disjoint set\\n\\n        count = m * n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\') \\n                        unify(nums, i, j, i - 1, j, n);\\n\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\') \\n                        unify(nums, i, j, i, j - 1, n);\\n\\n                } else {\\n                    count--; //not an island\\n                }\\n            }\\n\\n        return count;\\n    }\\n\\n    public void unify(int[] nums, int i1, int j1, int i2, int j2, int n) {\\n        int x = find(nums, i1, j1, n);\\n        int y = find(nums, i2, j2, n);\\n        if (x != y) {\\n            nums[x] = y;\\n            count--; //Reducing count since grid[i][j] is not a new separate island but just a connected part of existing island (grid[i-1][j] or grid[i][j-1])\\n        }\\n    }\\n\\n    public int find(int[] nums, int i, int j, int n) {\\n        return find(nums, i * n + j);  //index = i*n + j\\n    }\\n\\n    public int find(int[] nums, int k) {\\n        int root = k;\\n        while (nums[root] != root) {\\n            root = nums[root];\\n        }\\n\\t\\t// path compression \\n        while (nums[k] != k) {\\n            int temp = nums[k];\\n            nums[k] = root;\\n            k = temp;\\n        }\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716626,
                "title": "javascript-clean-dfs",
                "content": "```javascript\\nvar numIslands = function(grid) {\\n    let islands = 0;\\n  \\n    for(let r = 0; r < grid.length; r++) {\\n        for(let c = 0; c < grid[0].length; c++) {\\n            if(grid[r][c] === \\'1\\') {\\n                islands++;\\n                callDFS(r, c);\\n            }\\n        }\\n    }\\n    \\n    function callDFS(r, c) {\\n        if(r < 0 || r >= grid.length || grid[r][c] !== \\'1\\') return;\\n        grid[r][c] = \\'0\\';\\n        \\n        callDFS(r+1, c); // down\\n        callDFS(r-1, c); // up\\n        callDFS(r, c+1); // right\\n        callDFS(r, c-1); // left\\n    }\\n    return islands;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar numIslands = function(grid) {\\n    let islands = 0;\\n  \\n    for(let r = 0; r < grid.length; r++) {\\n        for(let c = 0; c < grid[0].length; c++) {\\n            if(grid[r][c] === \\'1\\') {\\n                islands++;\\n                callDFS(r, c);\\n            }\\n        }\\n    }\\n    \\n    function callDFS(r, c) {\\n        if(r < 0 || r >= grid.length || grid[r][c] !== \\'1\\') return;\\n        grid[r][c] = \\'0\\';\\n        \\n        callDFS(r+1, c); // down\\n        callDFS(r-1, c); // up\\n        callDFS(r, c+1); // right\\n        callDFS(r, c-1); // left\\n    }\\n    return islands;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571524,
                "title": "java-dfs",
                "content": "Easy problem once you understand it. \\n```    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        \\n        int numIslands = 0;\\n        /* Do a linear traversal of the grid. The first place we find Land, We purge the island.\\n            The purge can only take place to adjacent land. So we can only purge one island at a time.\\n        */ \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    numIslands++;\\n                    purgeIsland(grid, i, j);\\n                } \\n            }\\n        }\\n        return numIslands;\\n    }\\n    \\n    //DFS. \\n    private void purgeIsland(char[][] grid, int i , int j) {    \\n        boolean isOutOfBounds =  i < 0 || j < 0 || i >= grid.length || j >= grid[i].length;\\n    \\n        if (isOutOfBounds || grid[i][j] == \\'0\\') { return; }\\n        \\n        grid[i][j] = \\'0\\';\\n        purgeIsland(grid, i+1, j);\\n        purgeIsland(grid, i-1, j);\\n        purgeIsland(grid, i, j+1);\\n        purgeIsland(grid, i, j-1);\\n    }",
                "solutionTags": [],
                "code": "Easy problem once you understand it. \\n```    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        \\n        int numIslands = 0;\\n        /* Do a linear traversal of the grid. The first place we find Land, We purge the island.\\n            The purge can only take place to adjacent land. So we can only purge one island at a time.\\n        */ \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    numIslands++;\\n                    purgeIsland(grid, i, j);\\n                } \\n            }\\n        }\\n        return numIslands;\\n    }\\n    \\n    //DFS. \\n    private void purgeIsland(char[][] grid, int i , int j) {    \\n        boolean isOutOfBounds =  i < 0 || j < 0 || i >= grid.length || j >= grid[i].length;\\n    \\n        if (isOutOfBounds || grid[i][j] == \\'0\\') { return; }\\n        \\n        grid[i][j] = \\'0\\';\\n        purgeIsland(grid, i+1, j);\\n        purgeIsland(grid, i-1, j);\\n        purgeIsland(grid, i, j+1);\\n        purgeIsland(grid, i, j-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480869,
                "title": "javascript-bfs",
                "content": "```\\nfunction numIslands(grid) {\\n  let count = 0;\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i][j] === \\'1\\') {\\n        count++;\\n        color(grid, i, j); \\n      }   \\n    }   \\n  }\\n  return count;\\n}\\n\\nfunction color(grid, i, j) {\\n  let q = [[i, j]];\\n  while (q.length) {\\n    let [x, y] = q.pop();\\n    grid[x][y] = 0;\\n    for (let [newX, newY] of [[x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1]]) {\\n      if (\\n        newX >= 0 &&\\n        newX < grid.length &&\\n        newY >= 0 &&\\n        newY < grid[0].length &&\\n        grid[newX][newY] === \\'1\\' \\n      ) { \\n        q.push([newX, newY]);\\n      }   \\n    }   \\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction numIslands(grid) {\\n  let count = 0;\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i][j] === \\'1\\') {\\n        count++;\\n        color(grid, i, j); \\n      }   \\n    }   \\n  }\\n  return count;\\n}\\n\\nfunction color(grid, i, j) {\\n  let q = [[i, j]];\\n  while (q.length) {\\n    let [x, y] = q.pop();\\n    grid[x][y] = 0;\\n    for (let [newX, newY] of [[x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1]]) {\\n      if (\\n        newX >= 0 &&\\n        newX < grid.length &&\\n        newY >= 0 &&\\n        newY < grid[0].length &&\\n        grid[newX][newY] === \\'1\\' \\n      ) { \\n        q.push([newX, newY]);\\n      }   \\n    }   \\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479692,
                "title": "intuitive-disjoint-set-union-find-in-java-python3",
                "content": "### Java\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0 || \\n\\t\\t\\tgrid[0] == null || grid[0].length == 0) return 0;\\n        \\n        int r = grid.length, c = grid[0].length;\\n        DSU dsu = new DSU(r * c);\\n        \\n        // union an island with its adjacent islands\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (grid[i][j] == \\'1\\') {\\n                    \\n                    // add this island first\\n                    dsu.incNumIsl();\\n                    \\n                    // union 4 adjacent islands if exist\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\')\\n                        dsu.union((i - 1) * c + j, i * c + j);\\n                    if (i + 1 < r && grid[i + 1][j] == \\'1\\')\\n                        dsu.union(i * c + j, (i + 1) * c + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\')\\n                        dsu.union(i * c + (j - 1), i * c + (j - 1));\\n                    if (j + 1 < c && grid[i][j + 1] == \\'1\\')\\n                        dsu.union(i * c + j, i * c + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        return dsu.getNumIsl();\\n    }\\n}\\n\\nclass DSU {\\n    private int[] par = null, rnk = null;\\n    private int numIsl;\\n\\t\\n    public DSU(int num) {\\n        this.par = new int[num];\\n        this.rnk = new int[num];\\n        this.numIsl = 0;\\n        for (int i = 0; i < num; ++i)\\n\\t\\t\\tthis.par[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if (this.par[x] != x)\\n            this.par[x] = this.find(this.par[x]);\\n        return this.par[x];\\n    }\\n    \\n    public void union(int x, int y) {\\n        int xr = this.find(x), yr = this.find(y);\\n        if (xr == yr)\\n\\t\\t\\treturn;\\n        else if (this.rnk[xr] < this.rnk[yr])\\n            this.par[xr] = yr;\\n        else if (this.rnk[xr] > this.rnk[yr])\\n            this.par[yr] = xr;\\n        else {\\n            this.par[yr] = xr;\\n            this.rnk[xr]++;\\n        }\\n        this.numIsl--;\\n    }\\n    \\n    public void incNumIsl() {\\n        this.numIsl++;\\n    }\\n    \\n    public int getNumIsl() {\\n        return this.numIsl;\\n    }\\n}\\n```\\n---\\n### Python3\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if grid == None or len(grid) == 0: return 0\\n        \\n        r, c = len(grid), len(grid[0])\\n        dsu = DSU(r * c)\\n        \\n        # union an island with its adjacent islands\\n        for i in range(r):\\n            for j in range(c):\\n                if int(grid[i][j]) == 1:\\n                    \\n                    # add this island first\\n                    dsu.numIsl += 1\\n                    \\n                    # union 4 adjacent islands if exist\\n                    if i - 1 >= 0 and int(grid[i - 1][j]) == 1:\\n                        dsu.union((i - 1) * c + j, i * c + j)\\n                    if i + 1 < r and int(grid[i + 1][j]) == 1:\\n                        dsu.union(i * c + j, (i + 1) * c + j)\\n                    if j - 1 >= 0 and int(grid[i][j - 1]) == 1:\\n                        dsu.union(i * c + (j - 1), i * c + j)\\n                    if j + 1 < c and int(grid[i][j + 1]) == 1:\\n                        dsu.union(i * c + j, i * c + (j + 1))\\n                            \\n        return dsu.numIsl\\n    \\nclass DSU:\\n    def __init__(self, num):\\n        self.numIsl = 0\\n        self.par = list(range(num))\\n        self.rnk = [0] * num\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n\\t\\t\\treturn\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        self.numIsl -= 1\\n```\\n---\\n### Analysis\\nTime Complexity: O(N\\u03B1(N))\\u2248O(N), where N is the number of vertices (and also the number of edges) in the graph, and \\u03B1 is the Inverse-Ackermann function.\\nSpace Complexity: O(N). The current construction of the graph (embedded in our dsu structure) has at most N nodes.\\n\\n---\\n\\n### References\\n\\nIntuitive Explanation Video\\nhttps://youtu.be/0jNmHPfA_yE\\n\\nhttps://leetcode.com/problems/redundant-connection/solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0 || \\n\\t\\t\\tgrid[0] == null || grid[0].length == 0) return 0;\\n        \\n        int r = grid.length, c = grid[0].length;\\n        DSU dsu = new DSU(r * c);\\n        \\n        // union an island with its adjacent islands\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (grid[i][j] == \\'1\\') {\\n                    \\n                    // add this island first\\n                    dsu.incNumIsl();\\n                    \\n                    // union 4 adjacent islands if exist\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\')\\n                        dsu.union((i - 1) * c + j, i * c + j);\\n                    if (i + 1 < r && grid[i + 1][j] == \\'1\\')\\n                        dsu.union(i * c + j, (i + 1) * c + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\')\\n                        dsu.union(i * c + (j - 1), i * c + (j - 1));\\n                    if (j + 1 < c && grid[i][j + 1] == \\'1\\')\\n                        dsu.union(i * c + j, i * c + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        return dsu.getNumIsl();\\n    }\\n}\\n\\nclass DSU {\\n    private int[] par = null, rnk = null;\\n    private int numIsl;\\n\\t\\n    public DSU(int num) {\\n        this.par = new int[num];\\n        this.rnk = new int[num];\\n        this.numIsl = 0;\\n        for (int i = 0; i < num; ++i)\\n\\t\\t\\tthis.par[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if (this.par[x] != x)\\n            this.par[x] = this.find(this.par[x]);\\n        return this.par[x];\\n    }\\n    \\n    public void union(int x, int y) {\\n        int xr = this.find(x), yr = this.find(y);\\n        if (xr == yr)\\n\\t\\t\\treturn;\\n        else if (this.rnk[xr] < this.rnk[yr])\\n            this.par[xr] = yr;\\n        else if (this.rnk[xr] > this.rnk[yr])\\n            this.par[yr] = xr;\\n        else {\\n            this.par[yr] = xr;\\n            this.rnk[xr]++;\\n        }\\n        this.numIsl--;\\n    }\\n    \\n    public void incNumIsl() {\\n        this.numIsl++;\\n    }\\n    \\n    public int getNumIsl() {\\n        return this.numIsl;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if grid == None or len(grid) == 0: return 0\\n        \\n        r, c = len(grid), len(grid[0])\\n        dsu = DSU(r * c)\\n        \\n        # union an island with its adjacent islands\\n        for i in range(r):\\n            for j in range(c):\\n                if int(grid[i][j]) == 1:\\n                    \\n                    # add this island first\\n                    dsu.numIsl += 1\\n                    \\n                    # union 4 adjacent islands if exist\\n                    if i - 1 >= 0 and int(grid[i - 1][j]) == 1:\\n                        dsu.union((i - 1) * c + j, i * c + j)\\n                    if i + 1 < r and int(grid[i + 1][j]) == 1:\\n                        dsu.union(i * c + j, (i + 1) * c + j)\\n                    if j - 1 >= 0 and int(grid[i][j - 1]) == 1:\\n                        dsu.union(i * c + (j - 1), i * c + j)\\n                    if j + 1 < c and int(grid[i][j + 1]) == 1:\\n                        dsu.union(i * c + j, i * c + (j + 1))\\n                            \\n        return dsu.numIsl\\n    \\nclass DSU:\\n    def __init__(self, num):\\n        self.numIsl = 0\\n        self.par = list(range(num))\\n        self.rnk = [0] * num\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n\\t\\t\\treturn\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        self.numIsl -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425331,
                "title": "python3-simple-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        if r == 0: return 0\\n        c=len(grid[0])\\n         \\n        def DFS(i, j):\\n            if grid[i][j] == \\'1\\':\\n                grid[i][j] = \\'0\\'\\n                if i > 0:   DFS(i-1, j)\\n                if i < r-1: DFS(i+1, j)\\n                if j > 0:   DFS(i, j-1)\\n                if j < c-1: DFS(i, j+1)\\n                    \\n        count = 0 \\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j] == \\'1\\':\\n                    count += 1\\n                    DFS(i, j)\\n        return count \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        if r == 0: return 0\\n        c=len(grid[0])\\n         \\n        def DFS(i, j):\\n            if grid[i][j] == \\'1\\':\\n                grid[i][j] = \\'0\\'\\n                if i > 0:   DFS(i-1, j)\\n                if i < r-1: DFS(i+1, j)\\n                if j > 0:   DFS(i, j-1)\\n                if j < c-1: DFS(i, j+1)\\n                    \\n        count = 0 \\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j] == \\'1\\':\\n                    count += 1\\n                    DFS(i, j)\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 325116,
                "title": "javascript-union-find-solution",
                "content": "Union Find Intuition: https://www.quora.com/What-is-an-intuitive-explanation-of-union-find\\n\\n\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    if (grid.length === 0) return 0;\\n    \\n    let parent = {};\\n\\n    const DIRS = [[0,-1], [0,1], [-1, 0], [1,0]];\\n    \\n    const UnionFind = function(grid){\\n        let size = {};\\n\\n        for (let i=0; i<grid.length; i++){\\n            for (let j=0; j<grid[i].length; j++){\\n                if (grid[i][j] === \\'1\\'){\\n                    let id = `${i}_${j}`;\\n                    parent[id] = id;\\n                    size[id] = 1;\\n                }\\n            }\\n        }\\n\\n        this.find = (id) => {\\n            if (parent[id] === id) return id;\\n            parent[id] = this.find(parent[id]);\\n            return parent[id];\\n        }\\n\\n        this.union = (x,y) => {\\n            let rootX = this.find(x);\\n            let rootY = this.find(y);\\n\\n            if (rootX === rootY) return;\\n            if (size[rootX] > size[rootY]){\\n                size[rootX] += size[rootY];\\n                parent[rootY] = rootX;\\n            }else{\\n                size[rootY] += size[rootX];\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n\\n    const UF = new UnionFind(grid);\\n\\n    for (let i=0; i<grid.length; i++){\\n        for (let j=0; j<grid[i].length; j++){\\n            if (grid[i][j] === \\'1\\'){\\n                let id = `${i}_${j}`;\\n                for (let dir of DIRS) {\\n                    let ni = i+dir[0];\\n                    let nj = j+dir[1];\\n                    if (ni>=0 && ni<grid.length && nj>=0 && nj<grid[i].length){\\n                        let nId = `${ni}_${nj}`\\n                        if (grid[ni][nj] === \\'1\\') UF.union(id, nId);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let rootSet = new Set();\\n    for (let child in parent){\\n        let root = UF.find(child);\\n        if (!rootSet.has(root)) rootSet.add(root);\\n    }\\n    return rootSet.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    if (grid.length === 0) return 0;\\n    \\n    let parent = {};\\n\\n    const DIRS = [[0,-1], [0,1], [-1, 0], [1,0]];\\n    \\n    const UnionFind = function(grid){\\n        let size = {};\\n\\n        for (let i=0; i<grid.length; i++){\\n            for (let j=0; j<grid[i].length; j++){\\n                if (grid[i][j] === \\'1\\'){\\n                    let id = `${i}_${j}`;\\n                    parent[id] = id;\\n                    size[id] = 1;\\n                }\\n            }\\n        }\\n\\n        this.find = (id) => {\\n            if (parent[id] === id) return id;\\n            parent[id] = this.find(parent[id]);\\n            return parent[id];\\n        }\\n\\n        this.union = (x,y) => {\\n            let rootX = this.find(x);\\n            let rootY = this.find(y);\\n\\n            if (rootX === rootY) return;\\n            if (size[rootX] > size[rootY]){\\n                size[rootX] += size[rootY];\\n                parent[rootY] = rootX;\\n            }else{\\n                size[rootY] += size[rootX];\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n\\n    const UF = new UnionFind(grid);\\n\\n    for (let i=0; i<grid.length; i++){\\n        for (let j=0; j<grid[i].length; j++){\\n            if (grid[i][j] === \\'1\\'){\\n                let id = `${i}_${j}`;\\n                for (let dir of DIRS) {\\n                    let ni = i+dir[0];\\n                    let nj = j+dir[1];\\n                    if (ni>=0 && ni<grid.length && nj>=0 && nj<grid[i].length){\\n                        let nId = `${ni}_${nj}`\\n                        if (grid[ni][nj] === \\'1\\') UF.union(id, nId);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let rootSet = new Set();\\n    for (let child in parent){\\n        let root = UF.find(child);\\n        if (!rootSet.has(root)) rootSet.add(root);\\n    }\\n    return rootSet.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238370,
                "title": "simple-python-dfs-with-explanation",
                "content": "Top level overview (func numIslands):\\n1. Iterate through each element in the grid.\\n2. At each element, if grid[i][j] == \"1\":\\n\\t* Increase our count of the number of islands (num_islands)\\n\\t* perform DFS starting at grid[i][j] to mark all the entire connected component as one island.\\n\\nDFS overview (func dfs):\\nGiven a grid and the starting row and column indices,\\n1. Change the value at grid[r][c] to \"0\" to mark this element as visited.\\n2. For each of its neighbor indices, if the neighbor is both within bounds of the grid and has a value of \"1\" (i.e. is part of the same island), peform dfs on that neighbor.\\n\\nTime complexity: O(M * N), M=number of rows and N=number of columns\\n* In numIslands we look at every element in grid once, so M * N\\n* In the worst case, a call of dfs from numIslands can look at every element if the whole grid is an island, so also M * N\\n* O(2M * N) = O(M * N)\\n\\nSpace complexity: O(1)\\n* No additional space needed to store visited nodes since we update in-place\\n\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        num_islands = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"1\":\\n                    num_islands += 1\\n                    self.dfs(grid, i, j)\\n                    \\n        return num_islands\\n    \\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \"0\"\\n        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\\n            nr = r + dr\\n            nc = c + dc\\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == \"1\":\\n                self.dfs(grid, nr, nc)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        num_islands = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"1\":\\n                    num_islands += 1\\n                    self.dfs(grid, i, j)\\n                    \\n        return num_islands\\n    \\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \"0\"\\n        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\\n            nr = r + dr\\n            nc = c + dc\\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == \"1\":\\n                self.dfs(grid, nr, nc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227328,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        \\n        guard grid.count > 0 else { return 0 }\\n        guard grid[0].count > 0 else { return 0 }\\n\\n        var matrix = grid\\n        var numberOfIslands = 0\\n        \\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                if matrix[i][j] == \"1\" {\\n                    numberOfIslands += 1\\n                    changeElement(&matrix, i, j)\\n                } \\n            }\\n        }\\n        return numberOfIslands\\n    }\\n    \\n    private func changeElement(_ matrix: inout [[Character]], _ i: Int, _ j: Int) {\\n        guard i >= 0, i < matrix.count, j >= 0, j < matrix[0].count, matrix[i][j] == \"1\" else { return }\\n        matrix[i][j] = \"0\"\\n        changeElement(&matrix, i + 1, j)\\n        changeElement(&matrix, i - 1, j)\\n        changeElement(&matrix, i, j + 1)\\n        changeElement(&matrix, i, j - 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        \\n        guard grid.count > 0 else { return 0 }\\n        guard grid[0].count > 0 else { return 0 }\\n\\n        var matrix = grid\\n        var numberOfIslands = 0\\n        \\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                if matrix[i][j] == \"1\" {\\n                    numberOfIslands += 1\\n                    changeElement(&matrix, i, j)\\n                } \\n            }\\n        }\\n        return numberOfIslands\\n    }\\n    \\n    private func changeElement(_ matrix: inout [[Character]], _ i: Int, _ j: Int) {\\n        guard i >= 0, i < matrix.count, j >= 0, j < matrix[0].count, matrix[i][j] == \"1\" else { return }\\n        matrix[i][j] = \"0\"\\n        changeElement(&matrix, i + 1, j)\\n        changeElement(&matrix, i - 1, j)\\n        changeElement(&matrix, i, j + 1)\\n        changeElement(&matrix, i, j - 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56638,
                "title": "sink-the-island-java-solution",
                "content": "Since it does not like other DFS or BFS question, after we sink the '1' to '0', it would not do same recursion because 1 already turn into 0. Only thing repeatedly being done is check this position whether it's 1, which takes O1.\\n\\n    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0; j<grid[i].length;j++){\\n                    if(grid[i][j] == '1'){\\n                        count++;\\n                        sink(grid,i,j);\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n        \\n        private void sink(char[][] grid, int a, int b){\\n            grid[a][b] = 0;\\n            if(a!= grid.length-1 && grid[a+1][b] == '1')\\n                sink(grid,a+1,b);\\n            if(b!= grid[a].length-1 && grid[a][b+1] == '1')\\n                sink(grid,a,b+1);\\n            if(a!= 0 && grid[a-1][b] == '1')\\n                sink(grid,a-1,b);\\n            if(b!= 0 && grid[a][b-1] == '1')\\n                sink(grid,a,b-1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0; j<grid[i].length;j++){\\n                    if(grid[i][j] == '1'){\\n                        count++;\\n                        sink(grid,i,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 56385,
                "title": "python-bfs-solution",
                "content": "    from collections import deque\\n    class Solution:\\n        # @param grid, a list of list of characters\\n        # @return an integer\\n        def numIslands(self, grid):\\n            if not grid:\\n                return 0\\n            lands=set([(i,j) for j in xrange(len(grid[0])) for i in xrange(len(grid)) if grid[i][j]=='1'])\\n            count=0\\n            while lands:\\n                count+=1\\n                i,j=lands.pop()\\n                connected=deque()\\n                connected.append((i,j))\\n                while connected:\\n                    i,j=connected.popleft()\\n                    if (i+1,j) in lands:\\n                        connected.append((i+1,j))\\n                        lands.remove((i+1,j))\\n                    if (i-1,j) in lands:\\n                        connected.append((i-1,j))\\n                        lands.remove((i-1,j))\\n                    if (i,j+1) in lands:\\n                        connected.append((i,j+1))\\n                        lands.remove((i,j+1))\\n                    if (i,j-1) in lands:\\n                        connected.append((i,j-1))\\n                        lands.remove((i,j-1))\\n            return count",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "    from collections import deque\\n    class Solution:\\n        # @param grid, a list of list of characters\\n        # @return an integer\\n        def numIslands(self, grid):\\n            if not grid:\\n                return 0\\n            lands=set([(i,j) for j in xrange(len(grid[0])) for i in xrange(len(grid)) if grid[i][j]=='1'])\\n            count=0\\n            while lands:\\n                count+=1\\n                i,j=lands.pop()\\n                connected=deque()\\n                connected.append((i,j))\\n                while connected:\\n                    i,j=connected.popleft()\\n                    if (i+1,j) in lands:\\n                        connected.append((i+1,j))\\n                        lands.remove((i+1,j))\\n                    if (i-1,j) in lands:\\n                        connected.append((i-1,j))\\n                        lands.remove((i-1,j))\\n                    if (i,j+1) in lands:\\n                        connected.append((i,j+1))\\n                        lands.remove((i,j+1))\\n                    if (i,j-1) in lands:\\n                        connected.append((i,j-1))\\n                        lands.remove((i,j-1))\\n            return count",
                "codeTag": "Java"
            },
            {
                "id": 56430,
                "title": "java-undirected-graph-connected-components",
                "content": "My solution is based on the concept of the connected components in graph, but basically it is a DFS variant.\\n\\nIt uses O(M N) extra space and has O(M N) time complexity.\\n\\n     public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = grid.length;\\n        final int M = grid[0].length;\\n        final boolean visited[][] = new boolean[N][M];\\n        int count = 0;\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n\\n                if(grid[i][j] == '1' && !visited[i][j]) {\\n                    dfs(grid, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n    private void dfs(char[][] grid, int i, int j, boolean[][] visited) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return;\\n        } else if(visited[i][j] || grid[i][j] != '1') {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n        dfs(grid, i - 1, j, visited);\\n        dfs(grid, i + 1, j, visited);\\n        dfs(grid, i, j - 1, visited);\\n        dfs(grid, i, j + 1, visited);\\n    }",
                "solutionTags": [],
                "code": "My solution is based on the concept of the connected components in graph, but basically it is a DFS variant.\\n\\nIt uses O(M N) extra space and has O(M N) time complexity.\\n\\n     public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = grid.length;\\n        final int M = grid[0].length;\\n        final boolean visited[][] = new boolean[N][M];\\n        int count = 0;\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n\\n                if(grid[i][j] == '1' && !visited[i][j]) {\\n                    dfs(grid, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n    private void dfs(char[][] grid, int i, int j, boolean[][] visited) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return;\\n        } else if(visited[i][j] || grid[i][j] != '1') {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n        dfs(grid, i - 1, j, visited);\\n        dfs(grid, i + 1, j, visited);\\n        dfs(grid, i, j - 1, visited);\\n        dfs(grid, i, j + 1, visited);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3724365,
                "title": "python3-dfs-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        visited = set()\\n        col, row = len(grid), len(grid[0])\\n        ans = 0\\n        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n\\n        def helper(c: int, r: int):\\n            visited.add((c, r))\\n            for i, j in dir:\\n                nc, nr = c+i, r+j\\n                if 0 <= nc < col and 0 <= nr < row and grid[nc][nr] == \"1\" and (nc, nr) not in visited:\\n                    helper(nc, nr)\\n        \\n        for c in range(col):\\n            for r in range(row):\\n                if (c, r) not in visited and grid[c][r] == \"1\":\\n                    helper(c, r)\\n                    ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        visited = set()\\n        col, row = len(grid), len(grid[0])\\n        ans = 0\\n        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n\\n        def helper(c: int, r: int):\\n            visited.add((c, r))\\n            for i, j in dir:\\n                nc, nr = c+i, r+j\\n                if 0 <= nc < col and 0 <= nr < row and grid[nc][nr] == \"1\" and (nc, nr) not in visited:\\n                    helper(nc, nr)\\n        \\n        for c in range(col):\\n            for r in range(row):\\n                if (c, r) not in visited and grid[c][r] == \"1\":\\n                    helper(c, r)\\n                    ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465780,
                "title": "dfs-and-bfs-solution",
                "content": "# BFS Approach\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def bfs(r,c):\\n            q=deque()\\n            q.append((r,c))\\n            visit.add((r,c))\\n            while q:\\n                row,col=q.popleft()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         q.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    bfs(r,c)\\n                    count+=1\\n        return count\\n        \\n```\\n# DFS Approach\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def dfs(r,c):\\n            stack=[]\\n            stack.append((r,c))\\n            visit.add((r,c))\\n            while stack:\\n                row,col=stack.pop()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         stack.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    dfs(r,c)\\n                    count+=1\\n        return count\\n  ````\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def bfs(r,c):\\n            q=deque()\\n            q.append((r,c))\\n            visit.add((r,c))\\n            while q:\\n                row,col=q.popleft()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         q.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    bfs(r,c)\\n                    count+=1\\n        return count\\n        \\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def dfs(r,c):\\n            stack=[]\\n            stack.append((r,c))\\n            visit.add((r,c))\\n            while stack:\\n                row,col=stack.pop()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         stack.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    dfs(r,c)\\n                    count+=1\\n        return count\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3205744,
                "title": "1-ms-simple-java-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n           int cnt =0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n               {\\n                cnt++;\\n                cleargrid(grid,i,j);\\n               }\\n            }   \\n        }\\n        return cnt;\\n    }\\n    public void cleargrid(char [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\\'0\\')\\n        return ;\\n        grid[i][j]=\\'0\\';\\n        cleargrid(grid,i+1,j);\\n        cleargrid(grid,i,j+1);\\n        cleargrid(grid,i-1,j);\\n        cleargrid(grid,i,j-1);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n           int cnt =0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n               {\\n                cnt++;\\n                cleargrid(grid,i,j);\\n               }\\n            }   \\n        }\\n        return cnt;\\n    }\\n    public void cleargrid(char [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\\'0\\')\\n        return ;\\n        grid[i][j]=\\'0\\';\\n        cleargrid(grid,i+1,j);\\n        cleargrid(grid,i,j+1);\\n        cleargrid(grid,i-1,j);\\n        cleargrid(grid,i,j-1);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947375,
                "title": "bfs-using-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) \\n    {\\n        Queue<(int, int)> queue = new();\\n        (int, int)[] directions = new[] {(-1, 0), (1, 0), (0, -1), (0, 1)};\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < grid.Length ; i++)\\n            for (int j = 0; j < grid[i].Length ; j++)\\n            {\\n                if (grid[i][j] == \\'1\\')\\n                {                \\n                    result++;\\n                    queue.Enqueue((i, j));\\n                    while (queue.Count > 0)\\n                    {\\n                        var p = queue.Dequeue();\\n                        foreach (var dir in directions)\\n                        {\\n                            int r = p.Item1 + dir.Item1;\\n                            int c = p.Item2 + dir.Item2;\\n                            \\n                            if(r >=0 && r < grid.Length &&\\n                               c >= 0 && c < grid[r].Length &&\\n                               grid[r][c] == \\'1\\')\\n                            {\\n                                grid[r][c] = \\'2\\';\\n                                queue.Enqueue((r, c));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) \\n    {\\n        Queue<(int, int)> queue = new();\\n        (int, int)[] directions = new[] {(-1, 0), (1, 0), (0, -1), (0, 1)};\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < grid.Length ; i++)\\n            for (int j = 0; j < grid[i].Length ; j++)\\n            {\\n                if (grid[i][j] == \\'1\\')\\n                {                \\n                    result++;\\n                    queue.Enqueue((i, j));\\n                    while (queue.Count > 0)\\n                    {\\n                        var p = queue.Dequeue();\\n                        foreach (var dir in directions)\\n                        {\\n                            int r = p.Item1 + dir.Item1;\\n                            int c = p.Item2 + dir.Item2;\\n                            \\n                            if(r >=0 && r < grid.Length &&\\n                               c >= 0 && c < grid[r].Length &&\\n                               grid[r][c] == \\'1\\')\\n                            {\\n                                grid[r][c] = \\'2\\';\\n                                queue.Enqueue((r, c));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497800,
                "title": "javascript-short-in-place-dfs",
                "content": "```\\nlet sinkIsland = function(grid, r, c) {\\n    if( r < 0 || c < 0 || r >= grid.length || c >= grid[0].length ) return;\\n    \\n    if( grid[r][c] != 1 ) return;\\n    grid[r][c] = 0;\\n    \\n    sinkIsland(grid, r+1, c);\\n    sinkIsland(grid, r-1, c);\\n    sinkIsland(grid, r, c+1);\\n    sinkIsland(grid, r, c-1);    \\n}\\nvar numIslands = function(grid) {\\n    var i,j;\\n    let n = grid.length, m = grid[0].length;\\n    let ans = 0;\\n    \\n    for( i=0; i<n; i++ ) {\\n        for( j=0; j<m; j++ ) {\\n            if( grid[i][j] == 1 ) {\\n                ans ++;\\n                sinkIsland(grid,i,j);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet sinkIsland = function(grid, r, c) {\\n    if( r < 0 || c < 0 || r >= grid.length || c >= grid[0].length ) return;\\n    \\n    if( grid[r][c] != 1 ) return;\\n    grid[r][c] = 0;\\n    \\n    sinkIsland(grid, r+1, c);\\n    sinkIsland(grid, r-1, c);\\n    sinkIsland(grid, r, c+1);\\n    sinkIsland(grid, r, c-1);    \\n}\\nvar numIslands = function(grid) {\\n    var i,j;\\n    let n = grid.length, m = grid[0].length;\\n    let ans = 0;\\n    \\n    for( i=0; i<n; i++ ) {\\n        for( j=0; j<m; j++ ) {\\n            if( grid[i][j] == 1 ) {\\n                ans ++;\\n                sinkIsland(grid,i,j);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248769,
                "title": "python-classic-dfs-solution-with-explanation",
                "content": "# Depth-First Search\\n**[DFS](https://en.wikipedia.org/wiki/Depth-first_search)** is an algorithm that traverses through a tree/graph-like structure where it extends as far as possible before backtracking. \\nIn other words: it goes to the deepest end, then goes back and tries other forks. \\n\\nWe iterate through the graph, and if we reach a cell with `1`, then we know it\\'s part of an island. Therefore, we dfs the 4 adjacent directions, and then add 1 to the count of islands. \\n\\nInside dfs function, we check first if the `i` and `j` indexes are within bounds, and then check if the cell is land or not (is `1` or not). \\n\\nWe mark visited cells with `#` to prevent us revisiting it (and adding more to the count). Then we recurse through right, left, up, and down (respectively). \\n\\n```py\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(grid, i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != \\'1\\':\\n                return\\n            \\n            grid[i][j] = \\'#\\'\\n            dfs(grid, i+1, j)\\n            dfs(grid, i-1, j)\\n            dfs(grid, i, j+1)\\n            dfs(grid, i, j-1)\\n          \\n        m = len(grid)\\n        n = len(grid[0])\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(grid, i, j)\\n                    count += 1\\n        return count\\n```\\n**If you liked this, please upvote to support me!**\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(grid, i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != \\'1\\':\\n                return\\n            \\n            grid[i][j] = \\'#\\'\\n            dfs(grid, i+1, j)\\n            dfs(grid, i-1, j)\\n            dfs(grid, i, j+1)\\n            dfs(grid, i, j-1)\\n          \\n        m = len(grid)\\n        n = len(grid[0])\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(grid, i, j)\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214490,
                "title": "go-simple-easy-to-understand",
                "content": "```\\nfunc numIslands(grid [][]byte) int {\\n    var res int\\n\\n    for row := 0; row < len(grid); row++ {\\n        for column := 0; column < len(grid[0]); column++ {\\n            if grid[row][column] == 49 {\\n                res++\\n                dfs(grid, row, column)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc dfs(grid [][]byte, row int, column int) {\\n    if row < 0 || row > len(grid) - 1 || column < 0 || column > len(grid[0]) - 1 || grid[row][column] == 48 {\\n        return\\n    }\\n    \\n    grid[row][column] = 48\\n    dfs(grid, row - 1, column)\\n    dfs(grid, row + 1, column)\\n    dfs(grid, row, column - 1)\\n    dfs(grid, row, column + 1)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n    var res int\\n\\n    for row := 0; row < len(grid); row++ {\\n        for column := 0; column < len(grid[0]); column++ {\\n            if grid[row][column] == 49 {\\n                res++\\n                dfs(grid, row, column)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc dfs(grid [][]byte, row int, column int) {\\n    if row < 0 || row > len(grid) - 1 || column < 0 || column > len(grid[0]) - 1 || grid[row][column] == 48 {\\n        return\\n    }\\n    \\n    grid[row][column] = 48\\n    dfs(grid, row - 1, column)\\n    dfs(grid, row + 1, column)\\n    dfs(grid, row, column - 1)\\n    dfs(grid, row, column + 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094043,
                "title": "typescript-javascript-bfs-and-dfs",
                "content": "```\\n//  Both BFS and DFS\\nfunction numIslands(grid: string[][]): number {\\n    let result = 0;\\n    for (let i = 0; i < grid.length; i ++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] == \"1\") {\\n                bfs(grid, i, j); // dfs(grid, i, j);\\n                result += 1;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n// DFS\\nfunction dfs(grid: string[][], r: number, c: number) {\\n    if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] == \"0\") {\\n        return;\\n    }\\n    grid[r][c] = \"0\";\\n    bfs(grid, r+1, c);\\n    bfs(grid, r-1, c);\\n    bfs(grid, r, c+1);\\n    bfs(grid, r, c-1);\\n}\\n\\n// BFS \\nfunction bfs(grid, x, y) {\\n    let queue = new Array();\\n    const matrix = [[1,0], [-1,0], [0,1],[0,-1]];\\n    queue.push([x,y]);\\n    while (queue.length > 0) {\\n        let len = queue.length;\\n        for (let i = 0; i < len; i++) {\\n            let curr = queue.shift();\\n            for (const dir of matrix) {\\n                let r = curr[0] + dir[0];\\n                let c = curr[1] + dir[1];\\n                if (r < 0 ||  r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == \"0\") {\\n                    continue;\\n                }\\n                grid[r][c] = \"0\";\\n                queue.push([r,c]);\\n            }\\n        }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//  Both BFS and DFS\\nfunction numIslands(grid: string[][]): number {\\n    let result = 0;\\n    for (let i = 0; i < grid.length; i ++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] == \"1\") {\\n                bfs(grid, i, j); // dfs(grid, i, j);\\n                result += 1;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n// DFS\\nfunction dfs(grid: string[][], r: number, c: number) {\\n    if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] == \"0\") {\\n        return;\\n    }\\n    grid[r][c] = \"0\";\\n    bfs(grid, r+1, c);\\n    bfs(grid, r-1, c);\\n    bfs(grid, r, c+1);\\n    bfs(grid, r, c-1);\\n}\\n\\n// BFS \\nfunction bfs(grid, x, y) {\\n    let queue = new Array();\\n    const matrix = [[1,0], [-1,0], [0,1],[0,-1]];\\n    queue.push([x,y]);\\n    while (queue.length > 0) {\\n        let len = queue.length;\\n        for (let i = 0; i < len; i++) {\\n            let curr = queue.shift();\\n            for (const dir of matrix) {\\n                let r = curr[0] + dir[0];\\n                let c = curr[1] + dir[1];\\n                if (r < 0 ||  r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == \"0\") {\\n                    continue;\\n                }\\n                grid[r][c] = \"0\";\\n                queue.push([r,c]);\\n            }\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969647,
                "title": "easy-c-dfs-solution-with-no-extra-space",
                "content": "**Without using visited array *(bool vis[300][300])***\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\tgrid[i][j] = \\'2\\';\\n\\t\\tdfs(grid, i - 1, j, n, m);\\n\\t\\tdfs(grid, i, j - 1, n, m);\\n\\t\\tdfs(grid, i + 1, j, n, m);\\n\\t\\tdfs(grid, i, j + 1, n, m);\\n\\t}\\npublic:\\n\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdfs(grid, i, j, n, m);\\n\\t\\t\\t\\t\\tct++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\tgrid[i][j] = \\'2\\';\\n\\t\\tdfs(grid, i - 1, j, n, m);\\n\\t\\tdfs(grid, i, j - 1, n, m);\\n\\t\\tdfs(grid, i + 1, j, n, m);\\n\\t\\tdfs(grid, i, j + 1, n, m);\\n\\t}\\npublic:\\n\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdfs(grid, i, j, n, m);\\n\\t\\t\\t\\t\\tct++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446732,
                "title": "flood-fill-approach-733",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        R, C = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(r, c):\\n            grid[r][c] = \\'0\\'\\n            if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n                dfs(r-1, c)\\n            if r+1 < R and grid[r+1][c] == \\'1\\':\\n                dfs(r+1, c)\\n            if c+1 < C and grid[r][c+1] == \\'1\\':\\n                dfs(r, c+1)\\n            if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n                dfs(r, c-1)\\n                \\n                \\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n                if grid[row][col] == \\'1\\':\\n                    count += 1\\n                    dfs(row, col)\\n                    \\n        return count\\n        \\n# first we find the 1 valued element using two for loops and then we update their values to 0 so \\n# that when we backtrack (like r-1) then it will not keep on running and when values of all of it\\'s connected\\n# elements become 0, we come out of the dfs(). This keeps on happening as the 2 for loops continue finding the \\'1\\' valued element.\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        R, C = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(r, c):\\n            grid[r][c] = \\'0\\'\\n            if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n                dfs(r-1, c)\\n            if r+1 < R and grid[r+1][c] == \\'1\\':\\n                dfs(r+1, c)\\n            if c+1 < C and grid[r][c+1] == \\'1\\':\\n                dfs(r, c+1)\\n            if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n                dfs(r, c-1)\\n                \\n                \\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n                if grid[row][col] == \\'1\\':\\n                    count += 1\\n                    dfs(row, col)\\n                    \\n        return count\\n        \\n# first we find the 1 valued element using two for loops and then we update their values to 0 so \\n# that when we backtrack (like r-1) then it will not keep on running and when values of all of it\\'s connected\\n# elements become 0, we come out of the dfs(). This keeps on happening as the 2 for loops continue finding the \\'1\\' valued element.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050390,
                "title": "python-simple-union-find-solution",
                "content": "```\\n# Classic Union Find DS\\nclass UnionFind:\\n    \\n    def __init__(self,m,n):\\n        self.parent = [0]*(m*n)\\n        self.size = [1]*(m*n)\\n        \\n        # initally root is itself\\n        for i in range(m*n):\\n            self.parent[i] = i\\n            \\n    # classic Find\\n    def find(self,x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n        \\n    \\n    def union(self, x, y):\\n        px,py = map(self.find, [x,y])\\n        \\n        # if same root no need to join\\n        if px == py:\\n            return\\n        \\n        # if px greater than insert to py\\n        if self.size[px] < self.size[py]:\\n            self.parent[px] = self.parent[py]\\n        \\n        # if py greater than insert to px\\n        elif self.size[px] > self.size[py]:\\n            self.parent[py] = self.parent[px]\\n            \\n        # if same then get to one of the roots\\n        # and then increment that root that got bigger\\n        else:\\n            self.parent[px] = self.parent[py]\\n            self.size[py]+=1\\n        \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        # number cell calculator\\n        def numcell(i,j):\\n            return len(grid[0])*i+j\\n            \\n        \\n        m,n = len(grid),len(grid[0])        \\n        dus = UnionFind(m,n)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # For each 1 check all 4-dir and if its 1 then unite\\n                # normally a DFS, but this is easier for UF method.\\n                if grid[i][j] == \\'1\\':\\n                    if i + 1 < m and grid[i + 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i+1,j))\\n                    if i - 1 >= 0 and grid[i - 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i-1,j))\\n                    if j + 1 < n and grid[i][j + 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j+1))\\n                    if j - 1 >= 0 and grid[i][j - 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j - 1))\\n        \\n        # Go through each element with a \\'1\\' and find its\\n        # root. in order not to repeat islands make sure to have\\n        # a freq. If it was never visited then visit that root and \\n        # increment root.\\n        res = 0\\n        freq = [0]*(m*n)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    px = dus.find(numcell(i,j))\\n                    \\n                    if freq[px] == 0:\\n                        res += 1\\n                    freq[px]+=1\\n                                     \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n# Classic Union Find DS\\nclass UnionFind:\\n    \\n    def __init__(self,m,n):\\n        self.parent = [0]*(m*n)\\n        self.size = [1]*(m*n)\\n        \\n        # initally root is itself\\n        for i in range(m*n):\\n            self.parent[i] = i\\n            \\n    # classic Find\\n    def find(self,x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n        \\n    \\n    def union(self, x, y):\\n        px,py = map(self.find, [x,y])\\n        \\n        # if same root no need to join\\n        if px == py:\\n            return\\n        \\n        # if px greater than insert to py\\n        if self.size[px] < self.size[py]:\\n            self.parent[px] = self.parent[py]\\n        \\n        # if py greater than insert to px\\n        elif self.size[px] > self.size[py]:\\n            self.parent[py] = self.parent[px]\\n            \\n        # if same then get to one of the roots\\n        # and then increment that root that got bigger\\n        else:\\n            self.parent[px] = self.parent[py]\\n            self.size[py]+=1\\n        \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        # number cell calculator\\n        def numcell(i,j):\\n            return len(grid[0])*i+j\\n            \\n        \\n        m,n = len(grid),len(grid[0])        \\n        dus = UnionFind(m,n)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # For each 1 check all 4-dir and if its 1 then unite\\n                # normally a DFS, but this is easier for UF method.\\n                if grid[i][j] == \\'1\\':\\n                    if i + 1 < m and grid[i + 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i+1,j))\\n                    if i - 1 >= 0 and grid[i - 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i-1,j))\\n                    if j + 1 < n and grid[i][j + 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j+1))\\n                    if j - 1 >= 0 and grid[i][j - 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j - 1))\\n        \\n        # Go through each element with a \\'1\\' and find its\\n        # root. in order not to repeat islands make sure to have\\n        # a freq. If it was never visited then visit that root and \\n        # increment root.\\n        res = 0\\n        freq = [0]*(m*n)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    px = dus.find(numcell(i,j))\\n                    \\n                    if freq[px] == 0:\\n                        res += 1\\n                    freq[px]+=1\\n                                     \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036341,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic int numIslands(char[][] grid) {\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        int countIslands = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                    countIslands(grid,i,j,visited);\\n                    countIslands++;\\n                }\\n            }\\n        }\\n        return countIslands;\\n    }\\n    \\n    public void countIslands(char[][] grid, int i, int j, boolean [][] visited){\\n         if(i<0 || i>= grid.length || j<0 || j>=grid[0].length || grid[i][j]==\\'0\\' || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        // Travel in all direction: north, east, south and west.\\n        countIslands(grid, i-1, j, visited);// North\\n        countIslands(grid, i, j+1, visited);// East\\n        countIslands(grid, i+1, j, visited);// South\\n        countIslands(grid, i, j-1, visited);// West\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIslands(char[][] grid) {\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        int countIslands = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                    countIslands(grid,i,j,visited);\\n                    countIslands++;\\n                }\\n            }\\n        }\\n        return countIslands;\\n    }\\n    \\n    public void countIslands(char[][] grid, int i, int j, boolean [][] visited){\\n         if(i<0 || i>= grid.length || j<0 || j>=grid[0].length || grid[i][j]==\\'0\\' || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        // Travel in all direction: north, east, south and west.\\n        countIslands(grid, i-1, j, visited);// North\\n        countIslands(grid, i, j+1, visited);// East\\n        countIslands(grid, i+1, j, visited);// South\\n        countIslands(grid, i, j-1, visited);// West\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583519,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public void dfs(char[][] grid, int row, int col) {\\n        if (grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'0\\';\\n        \\n        if (row+1 < grid.length) {\\n            dfs(grid, row+1, col);\\n        }\\n        \\n        if (row-1 >= 0) {\\n            dfs(grid, row-1, col);\\n        }\\n        \\n        if (col+1 < grid[0].length) {\\n            dfs(grid, row, col+1);\\n        }\\n        \\n        if (col-1 >= 0) {\\n            dfs(grid, row, col-1);\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    dfs(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void dfs(char[][] grid, int row, int col) {\\n        if (grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'0\\';\\n        \\n        if (row+1 < grid.length) {\\n            dfs(grid, row+1, col);\\n        }\\n        \\n        if (row-1 >= 0) {\\n            dfs(grid, row-1, col);\\n        }\\n        \\n        if (col+1 < grid[0].length) {\\n            dfs(grid, row, col+1);\\n        }\\n        \\n        if (col-1 >= 0) {\\n            dfs(grid, row, col-1);\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    dfs(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542339,
                "title": "py3-very-easy-sol-faster-than-96-16",
                "content": "```\\ndef doDfs(grid,i,j):\\n    deq = []\\n    deq.append([i,j])\\n    while deq:\\n        x,y=deq.pop()\\n        grid[x][y]=\"v\" #visited\\n        if x+1<len(grid) and grid[x+1][y]==\"1\":\\n            deq.append([x+1,y])\\n        if y+1<len(grid[0]) and grid[x][y+1]==\"1\":\\n            deq.append([x,y+1])\\n        if y-1>=0 and grid[x][y-1]==\"1\":\\n            deq.append([x,y-1])\\n        if x-1>=0 and grid[x-1][y]==\"1\":\\n            deq.append([x-1,y])\\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count= 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    doDfs(grid,i,j)\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef doDfs(grid,i,j):\\n    deq = []\\n    deq.append([i,j])\\n    while deq:\\n        x,y=deq.pop()\\n        grid[x][y]=\"v\" #visited\\n        if x+1<len(grid) and grid[x+1][y]==\"1\":\\n            deq.append([x+1,y])\\n        if y+1<len(grid[0]) and grid[x][y+1]==\"1\":\\n            deq.append([x,y+1])\\n        if y-1>=0 and grid[x][y-1]==\"1\":\\n            deq.append([x,y-1])\\n        if x-1>=0 and grid[x-1][y]==\"1\":\\n            deq.append([x-1,y])\\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count= 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    doDfs(grid,i,j)\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484397,
                "title": "python3-bfs-iterative-well-commented",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        ctr = 0\\n\\t\\t# This module will initiate the\\n\\t\\t# BFS traversal.\\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n\\t\\t\\t\\t# Initiate BFS if the value\\n\\t\\t\\t\\t# is 1.\\n                if grid[row][col] == \\'1\\':\\n\\t\\t\\t\\t\\t# Update the value in matrix\\n                    grid[row][col] = \\'0\\'\\n                    self.traverse_bfs(grid, row, col)\\n\\t\\t\\t\\t\\t# Increment counter\\n                    ctr += 1\\n        return ctr\\n\\t# This module will traverse\\n\\t# the grapf using BFS.\\n    def traverse_bfs(self, grid, r, c):\\n        que = deque()\\n\\t\\t# From each coordinate the trversal can\\n\\t\\t# be performed in 4 possible directions.\\n        possible_positions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t# Append the coordinate in the BFS queue.\\n        que.append((r, c))\\n\\t\\t# Iterate for all the values in Queue.\\n        while que:\\n\\t\\t\\t# Get the traversed coordinate.\\n            (a, b) = que.popleft()\\n\\t\\t\\t# Iterate through all the possible\\n\\t\\t\\t# positions for traversed coordinate.\\n            for position in possible_positions:\\n\\t\\t\\t\\t# Check if the position is valid\\n\\t\\t\\t\\t# and if the value at position is\\n\\t\\t\\t\\t# \\'1\\'.\\n                if (self.validity_check(grid, a + position[0], b + position[1])\\n\\t\\t\\t\\t\\tand grid[a + position[0]][b + position[1]] == \\'1\\'):\\n                    grid[a + position[0]][b + position[1]] = \\'0\\'\\n\\t\\t\\t\\t\\t# Append the coordinate in BFS queue.\\n                    que.append((a + position[0], b + position[1]))\\n\\t# This module checks the validity of\\n\\t# the position to be traversed.\\n    def validity_check(self, grid, c_row, c_col):\\n\\t\\t# The valid position muct have a row and\\n\\t\\t# column value greater or equal to 0 and\\n\\t\\t# must be less the the length.\\n        if (c_row >= 0 and c_row < len(grid)\\n            and c_col >= 0 and c_col < len(grid[0])):\\n            return True\\n\\t\\t# Else\\n        return False",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        ctr = 0\\n\\t\\t# This module will initiate the\\n\\t\\t# BFS traversal.\\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n\\t\\t\\t\\t# Initiate BFS if the value\\n\\t\\t\\t\\t# is 1.\\n                if grid[row][col] == \\'1\\':\\n\\t\\t\\t\\t\\t# Update the value in matrix\\n                    grid[row][col] = \\'0\\'\\n                    self.traverse_bfs(grid, row, col)\\n\\t\\t\\t\\t\\t# Increment counter\\n                    ctr += 1\\n        return ctr\\n\\t# This module will traverse\\n\\t# the grapf using BFS.\\n    def traverse_bfs(self, grid, r, c):\\n        que = deque()\\n\\t\\t# From each coordinate the trversal can\\n\\t\\t# be performed in 4 possible directions.\\n        possible_positions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t# Append the coordinate in the BFS queue.\\n        que.append((r, c))\\n\\t\\t# Iterate for all the values in Queue.\\n        while que:\\n\\t\\t\\t# Get the traversed coordinate.\\n            (a, b) = que.popleft()\\n\\t\\t\\t# Iterate through all the possible\\n\\t\\t\\t# positions for traversed coordinate.\\n            for position in possible_positions:\\n\\t\\t\\t\\t# Check if the position is valid\\n\\t\\t\\t\\t# and if the value at position is\\n\\t\\t\\t\\t# \\'1\\'.\\n                if (self.validity_check(grid, a + position[0], b + position[1])\\n\\t\\t\\t\\t\\tand grid[a + position[0]][b + position[1]] == \\'1\\'):\\n                    grid[a + position[0]][b + position[1]] = \\'0\\'\\n\\t\\t\\t\\t\\t# Append the coordinate in BFS queue.\\n                    que.append((a + position[0], b + position[1]))\\n\\t# This module checks the validity of\\n\\t# the position to be traversed.\\n    def validity_check(self, grid, c_row, c_col):\\n\\t\\t# The valid position muct have a row and\\n\\t\\t# column value greater or equal to 0 and\\n\\t\\t# must be less the the length.\\n        if (c_row >= 0 and c_row < len(grid)\\n            and c_col >= 0 and c_col < len(grid[0])):\\n            return True\\n\\t\\t# Else\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 464655,
                "title": "python-union-find-commented-clean-and-easy",
                "content": "```\\n# Approach : Using Union Find.  \\nclass Solution(object):\\n\\n    # the number of islands using\\n    # Disjoint Set data structure.\\n\\n    # Class to represent\\n    # Disjoint Set Data structure\\n    class DisjointUnionSets(object):\\n        def __init__(self, n):\\n            self.rank = [0] * n\\n            self.parent = [0] * n\\n            self.n = n\\n            self.makeSet()\\n\\n        def makeSet(self):\\n\\n            # Initially, all elements are in their\\n            # own set.\\n            for i in range(self.n):\\n                self.parent[i] = i\\n\\n                # Finds the representative of the set that x\\n\\n        # is an element of\\n        def find(self, x):\\n            if (self.parent[x] != x):\\n                # if x is not the parent of itself,\\n                # then x is not the representative of\\n                # its set.\\n                # so we recursively call Find on its parent\\n                # and move i\\'s node directly under the\\n                # representative of this set\\n                return self.find(self.parent[x])\\n            return x\\n\\n            # Unites the set that includes x and\\n\\n        # the set that includes y\\n        def Union(self, x, y):\\n\\n            # Find the representatives(or the root nodes)\\n            # for x an y\\n            xRoot = self.find(x)\\n            yRoot = self.find(y)\\n\\n            # Elements are in the same set,\\n            # no need to unite anything.\\n            if xRoot == yRoot:\\n                return\\n\\n            # If x\\'s rank is less than y\\'s rank\\n            # Then move x under y so that depth of tree\\n            # remains less\\n            if self.rank[xRoot] < self.rank[yRoot]:\\n                self.parent[xRoot] = yRoot\\n\\n                # Else if y\\'s rank is less than x\\'s rank\\n            # Then move y under x so that depth of tree\\n            # remains less\\n            elif self.rank[yRoot] < self.rank[xRoot]:\\n                self.parent[yRoot] = xRoot\\n\\n            else:\\n\\n                # Else if their ranks are the same\\n                # Then move y under x (doesn\\'t matter\\n                # which one goes where)\\n                self.parent[yRoot] = xRoot\\n\\n                # And increment the result tree\\'s\\n                # rank by 1\\n                self.rank[xRoot] = self.rank[xRoot] + 1\\n\\n    # Returns number of islands in a[][]\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        rowCount = len(grid)\\n        colCount = len(grid[0])\\n\\n        dus = self.DisjointUnionSets(rowCount * colCount)\\n\\n        # The following loop checks for its neighbours\\n        # and unites the indexes if both are 1.\\n        for rowIdx in range(0, rowCount):\\n            for colIdx in range(0, colCount):\\n\\n                # If cell is 0, nothing to do\\n                if grid[rowIdx][colIdx] == \"0\":\\n                    continue\\n\\n                # Check all 4 neighbours and do a Union\\n                # with neighbour\\'s set if neighbour is\\n                # also 1\\n                if rowIdx + 1 < rowCount and grid[rowIdx + 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx + 1) * (colCount) + colIdx)\\n\\n                if rowIdx - 1 >= 0 and grid[rowIdx - 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx - 1) * (colCount) + colIdx)\\n\\n                if colIdx + 1 < colCount and grid[rowIdx][colIdx + 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx + 1)\\n\\n                if colIdx - 1 >= 0 and grid[rowIdx][colIdx - 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx - 1)\\n\\n        # Array to note down frequency of each set\\n        frequencyArray = [0] * (rowCount * colCount)\\n        numberOfIslands = 0\\n        for rowIdx in range(rowCount):\\n            for colIdx in range(colCount):\\n                gridVal = grid[rowIdx][colIdx]\\n                if gridVal == \"1\":\\n                    x = dus.find(rowIdx * colCount + colIdx)\\n\\n                    # If frequency of set is 0,\\n                    # increment numberOfIslands\\n                    if frequencyArray[x] == 0:\\n                        numberOfIslands += 1\\n                        frequencyArray[x] += 1\\n                    else:\\n                        frequencyArray[x] += 1\\n        return numberOfIslands\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n# Approach : Using Union Find.  \\nclass Solution(object):\\n\\n    # the number of islands using\\n    # Disjoint Set data structure.\\n\\n    # Class to represent\\n    # Disjoint Set Data structure\\n    class DisjointUnionSets(object):\\n        def __init__(self, n):\\n            self.rank = [0] * n\\n            self.parent = [0] * n\\n            self.n = n\\n            self.makeSet()\\n\\n        def makeSet(self):\\n\\n            # Initially, all elements are in their\\n            # own set.\\n            for i in range(self.n):\\n                self.parent[i] = i\\n\\n                # Finds the representative of the set that x\\n\\n        # is an element of\\n        def find(self, x):\\n            if (self.parent[x] != x):\\n                # if x is not the parent of itself,\\n                # then x is not the representative of\\n                # its set.\\n                # so we recursively call Find on its parent\\n                # and move i\\'s node directly under the\\n                # representative of this set\\n                return self.find(self.parent[x])\\n            return x\\n\\n            # Unites the set that includes x and\\n\\n        # the set that includes y\\n        def Union(self, x, y):\\n\\n            # Find the representatives(or the root nodes)\\n            # for x an y\\n            xRoot = self.find(x)\\n            yRoot = self.find(y)\\n\\n            # Elements are in the same set,\\n            # no need to unite anything.\\n            if xRoot == yRoot:\\n                return\\n\\n            # If x\\'s rank is less than y\\'s rank\\n            # Then move x under y so that depth of tree\\n            # remains less\\n            if self.rank[xRoot] < self.rank[yRoot]:\\n                self.parent[xRoot] = yRoot\\n\\n                # Else if y\\'s rank is less than x\\'s rank\\n            # Then move y under x so that depth of tree\\n            # remains less\\n            elif self.rank[yRoot] < self.rank[xRoot]:\\n                self.parent[yRoot] = xRoot\\n\\n            else:\\n\\n                # Else if their ranks are the same\\n                # Then move y under x (doesn\\'t matter\\n                # which one goes where)\\n                self.parent[yRoot] = xRoot\\n\\n                # And increment the result tree\\'s\\n                # rank by 1\\n                self.rank[xRoot] = self.rank[xRoot] + 1\\n\\n    # Returns number of islands in a[][]\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        rowCount = len(grid)\\n        colCount = len(grid[0])\\n\\n        dus = self.DisjointUnionSets(rowCount * colCount)\\n\\n        # The following loop checks for its neighbours\\n        # and unites the indexes if both are 1.\\n        for rowIdx in range(0, rowCount):\\n            for colIdx in range(0, colCount):\\n\\n                # If cell is 0, nothing to do\\n                if grid[rowIdx][colIdx] == \"0\":\\n                    continue\\n\\n                # Check all 4 neighbours and do a Union\\n                # with neighbour\\'s set if neighbour is\\n                # also 1\\n                if rowIdx + 1 < rowCount and grid[rowIdx + 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx + 1) * (colCount) + colIdx)\\n\\n                if rowIdx - 1 >= 0 and grid[rowIdx - 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx - 1) * (colCount) + colIdx)\\n\\n                if colIdx + 1 < colCount and grid[rowIdx][colIdx + 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx + 1)\\n\\n                if colIdx - 1 >= 0 and grid[rowIdx][colIdx - 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx - 1)\\n\\n        # Array to note down frequency of each set\\n        frequencyArray = [0] * (rowCount * colCount)\\n        numberOfIslands = 0\\n        for rowIdx in range(rowCount):\\n            for colIdx in range(colCount):\\n                gridVal = grid[rowIdx][colIdx]\\n                if gridVal == \"1\":\\n                    x = dus.find(rowIdx * colCount + colIdx)\\n\\n                    # If frequency of set is 0,\\n                    # increment numberOfIslands\\n                    if frequencyArray[x] == 0:\\n                        numberOfIslands += 1\\n                        frequencyArray[x] += 1\\n                    else:\\n                        frequencyArray[x] += 1\\n        return numberOfIslands\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342666,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private int n;\\n    private int m;\\n\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == \\'1\\') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n\\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n        grid[i][j] = \\'0\\';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Number of Islands.\\nMemory Usage: 40.8 MB, less than 93.78% of Java online submissions for Number of Islands.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int n;\\n    private int m;\\n\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == \\'1\\') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n\\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n        grid[i][j] = \\'0\\';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294326,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    int n = 0;\\n    int m = 0;\\n    public int NumIslands(char[][] grid) {\\n        n = grid.Length;\\n        if (n == 0) return 0;\\n        m = grid[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!isVisited[i, j] && grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j, isVisited);\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void DFS(char[][] grid, int x, int y, bool[,] isVisited) {\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (isVisited[x, y]) return;\\n        if (grid[x][y] == \\'0\\') return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(grid, nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int n = 0;\\n    int m = 0;\\n    public int NumIslands(char[][] grid) {\\n        n = grid.Length;\\n        if (n == 0) return 0;\\n        m = grid[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!isVisited[i, j] && grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j, isVisited);\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void DFS(char[][] grid, int x, int y, bool[,] isVisited) {\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (isVisited[x, y]) return;\\n        if (grid[x][y] == \\'0\\') return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(grid, nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197026,
                "title": "3-solutions-in-go-golang",
                "content": "I dont like to mutate the grid, so i create a hashtable/dummyarray for visited territories. It seems like the dfs approach(with a dummy array) is the easiest to understand and it is the fastest\\n\\n**Approach 1:** \\n- dfs, hashtable for visited island territories\\n- runtime: 32ms, beats 9.4%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make(map[string]bool)\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\t\\t_, existed := visited[key]\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited map[string]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t_, existed := visited[key]\\n\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\tvisited[key] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\\n**Approach 2**\\n- dfs, dummy array for visited island territories\\n- runtime: 0ms, beats 100%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\tvisited[i][j] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\\n**Approach 3**\\n- bfs, queue for coordinates\\n- runtime: 4ms, beats 50.43%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t\\tbfs(grid, i, j, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc bfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tvar queue []Queue\\n\\tqueue = append(queue, Queue{i, j})\\n\\tfor len(queue) > 0 {\\n\\t\\thead := queue[0]\\n\\t\\trow := head.Row\\n\\t\\tcol := head.Col\\n\\t\\tqueue = queue[1:]\\n\\t\\tif grid[row][col] == \\'1\\' && !visited[row][col] {\\n\\t\\t\\tvisited[row][col] = true\\n\\t\\t\\tif row-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row - 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif row+1 < len(grid) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row + 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif col-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col - 1})\\n\\t\\t\\t}\\n\\t\\t\\tif col+1 < len(grid[0]) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col + 1})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Queue struct {\\n\\tRow int\\n\\tCol int\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make(map[string]bool)\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\t\\t_, existed := visited[key]\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited map[string]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t_, existed := visited[key]\\n\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\tvisited[key] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\tvisited[i][j] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t\\tbfs(grid, i, j, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc bfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tvar queue []Queue\\n\\tqueue = append(queue, Queue{i, j})\\n\\tfor len(queue) > 0 {\\n\\t\\thead := queue[0]\\n\\t\\trow := head.Row\\n\\t\\tcol := head.Col\\n\\t\\tqueue = queue[1:]\\n\\t\\tif grid[row][col] == \\'1\\' && !visited[row][col] {\\n\\t\\t\\tvisited[row][col] = true\\n\\t\\t\\tif row-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row - 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif row+1 < len(grid) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row + 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif col-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col - 1})\\n\\t\\t\\t}\\n\\t\\t\\tif col+1 < len(grid[0]) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col + 1})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Queue struct {\\n\\tRow int\\n\\tCol int\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56647,
                "title": "my-java-solution-iterative-dfs-stack",
                "content": "Hello! I think that the code is fairly straightforward and as many have said on here, it is a pretty cool DFS problem. The general idea of my solution is to switch the '1's to '0's if an island is found. Since an island can have more than one '1's interconnected, I used a stack to keep track of the surrounding '1's and switch them to '0's accordingly. This way, the loop can continue effortlessly without having to come across an island that has already been found. \\n\\nFeel free to let me know if this solution can be improved upon OR if you have any queries for me. :]\\n\\n    public int numIslands(char[][] grid) {\\n            int numOfRow = grid.length;\\n            if(numOfRow == 0)\\n                return 0;\\n            int numOfCol = grid[0].length;\\n            int numOfIslands = 0;\\n            Stack<Integer> gridTrackerOfRow = new Stack<Integer>();\\n            Stack<Integer> gridTrackerOfCol = new Stack<Integer>();\\n            for(int i = 0; i < numOfRow; i++){\\n                for(int j = 0; j < numOfCol; j++){\\n                    if(grid[i][j] == '1'){\\n                        gridTrackerOfRow.push(i);\\n                        gridTrackerOfCol.push(j);\\n                        while(!gridTrackerOfRow.isEmpty() && !gridTrackerOfCol.isEmpty()){\\n                            int x = gridTrackerOfRow.pop();\\n                            int y = gridTrackerOfCol.pop();\\n                            grid[x][y] = '0';\\n                            \\n                            if(y+1 < numOfCol && grid[x][y+1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y+1);\\n                            }\\n                            if(y-1 >= 0 && grid[x][y-1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y-1);\\n                            }\\n                            if(x+1 < numOfRow && grid[x+1][y] == '1'){\\n                                gridTrackerOfRow.push(x+1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                            if(x-1 >= 0 && grid[x-1][y] == '1'){\\n                                gridTrackerOfRow.push(x-1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                        }\\n                        numOfIslands++;\\n                    }\\n                }\\n            }\\n            \\n            return numOfIslands;\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "Hello! I think that the code is fairly straightforward and as many have said on here, it is a pretty cool DFS problem. The general idea of my solution is to switch the '1's to '0's if an island is found. Since an island can have more than one '1's interconnected, I used a stack to keep track of the surrounding '1's and switch them to '0's accordingly. This way, the loop can continue effortlessly without having to come across an island that has already been found. \\n\\nFeel free to let me know if this solution can be improved upon OR if you have any queries for me. :]\\n\\n    public int numIslands(char[][] grid) {\\n            int numOfRow = grid.length;\\n            if(numOfRow == 0)\\n                return 0;\\n            int numOfCol = grid[0].length;\\n            int numOfIslands = 0;\\n            Stack<Integer> gridTrackerOfRow = new Stack<Integer>();\\n            Stack<Integer> gridTrackerOfCol = new Stack<Integer>();\\n            for(int i = 0; i < numOfRow; i++){\\n                for(int j = 0; j < numOfCol; j++){\\n                    if(grid[i][j] == '1'){\\n                        gridTrackerOfRow.push(i);\\n                        gridTrackerOfCol.push(j);\\n                        while(!gridTrackerOfRow.isEmpty() && !gridTrackerOfCol.isEmpty()){\\n                            int x = gridTrackerOfRow.pop();\\n                            int y = gridTrackerOfCol.pop();\\n                            grid[x][y] = '0';\\n                            \\n                            if(y+1 < numOfCol && grid[x][y+1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y+1);\\n                            }\\n                            if(y-1 >= 0 && grid[x][y-1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y-1);\\n                            }\\n                            if(x+1 < numOfRow && grid[x+1][y] == '1'){\\n                                gridTrackerOfRow.push(x+1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                            if(x-1 >= 0 && grid[x-1][y] == '1'){\\n                                gridTrackerOfRow.push(x-1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                        }\\n                        numOfIslands++;\\n                    }\\n                }\\n            }\\n            \\n            return numOfIslands;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56671,
                "title": "short-dfs-java-solution",
                "content": "Hi guys!\\n\\nThe approach is same as in other posts, I just tried to make the code compact and clean.\\n\\nHave a nice coding!\\n\\n----------\\n\\n    public class Solution {\\n        private static final int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        private static final char L = '1', W = '0';\\n        \\n        public void dfsFill(char[][] g, int x, int y) {\\n            if (x >= 0 && x < g.length && y >= 0 && y < g[0].length && g[x][y] == L) {\\n                g[x][y] = W;\\n                for (int[] d : DIRS) dfsFill(g, x + d[0], y + d[1]);\\n            }\\n        }\\n        \\n        public int numIslands(char[][] grid) {\\n            int num = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == L) {\\n                        num++;\\n                        dfsFill(grid, i, j);\\n                    }\\n                }\\n            }\\n            return num;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        private static final int[][] DIRS = new int[][]{{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3926296,
                "title": "easy-dfs-solution-in-java",
                "content": "# Approach\\nWe are searching all grid cells until we encounter a \\'1\\' value. After that we increment the island counter by one and start to explore the rest of the island recursively using DFS (Depth First Search). While doing this, we toggle ones to zeros to prevent infinite recursion and at the end of the day we have the number of islands!\\n\\nThere is also a BFS (Breadth-First Search) solution here:\\n[Easy BFS Solution in JAVA \\u2615\\u2668\\uFE0F](https://leetcode.com/problems/number-of-islands/solutions/3960358/easy-bfs-solution-in-java/)\\n\\nPlease upvote \\uD83D\\uDC7D\\n\\n# Complexity\\n- **Time Complexity:**\\nThe overall time complexity of the solution is $$O(m * n)$$\\n\\n- **Space Complexity:**\\nIf we say $$k$$ represents the size of the largest possible island in the 2D grid, the space complexity would be $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int islandCount = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islandCount++;\\n                    searchIslandDFS(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public void searchIslandDFS(char[][] grid, int i, int j) {\\n        // Check the boundaries and the current cell\\'s value.\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n\\n        // Set the value of the grid cell to \\'0\\'.\\n        grid[i][j] = \\'0\\';\\n\\n        // Explore all four directions.\\n        searchIslandDFS(grid, i + 1, j);\\n        searchIslandDFS(grid, i - 1, j);\\n        searchIslandDFS(grid, i, j + 1);\\n        searchIslandDFS(grid, i, j - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int islandCount = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islandCount++;\\n                    searchIslandDFS(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public void searchIslandDFS(char[][] grid, int i, int j) {\\n        // Check the boundaries and the current cell\\'s value.\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n\\n        // Set the value of the grid cell to \\'0\\'.\\n        grid[i][j] = \\'0\\';\\n\\n        // Explore all four directions.\\n        searchIslandDFS(grid, i + 1, j);\\n        searchIslandDFS(grid, i - 1, j);\\n        searchIslandDFS(grid, i, j + 1);\\n        searchIslandDFS(grid, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852079,
                "title": "easy-dfs-solution",
                "content": "\\n# Approach\\nCreate a recursive function solve that performs Depth-First Search (DFS) to mark connected lands as \\'0\\'. This function will start from a given position (i, j) and recursively visit all the adjacent cells that contain \\'1\\' (i.e., land). During the visit, it will mark the cells as \\'0\\' to indicate that they have been visited. This function will take the grid, current row index i, current column index j, number of rows n, and number of columns m as parameters.\\n\\nFunction solve(grid, i, j, n, m):\\n\\nBase case: If the current position (i, j) is out of the grid boundaries (i.e., i < 0 || j < 0 || i >= n || j >= m), or if the cell contains \\'0\\', then return and exit the function.\\nMark the current cell as \\'0\\' to indicate that it has been visited.\\nRecursively call solve for the adjacent cells (up, down, left, right) to continue the DFS.\\nInitialize a variable count to 0 to keep track of the number of islands. This variable will be incremented each time we find a new island.\\n\\nIterate through the entire grid. For each cell (i, j):\\n\\nIf the cell contains \\'1\\', this means it is part of a new island. Call the solve function to mark all connected lands as \\'0\\'. Additionally, increment the count variable to count the number of islands.\\nFinally, return the count, which will represent the total number of islands in the grid.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<char>>& grid , int i ,int j,int n ,int m )\\n{\\n    if( i < 0 || j < 0 || i >= n || j >= m )\\n    {\\n        return ;\\n    }\\n    if(grid[i][j]==\\'0\\')\\n    {\\n        return ;\\n    }\\n    grid[i][j]=\\'0\\';\\n\\n    solve(grid,i+1,j, n,m );\\n    solve(grid,i-1,j, n,m );\\n    solve(grid,i,j+1, n,m );\\n    solve(grid,i,j-1, n,m );\\n}\\n\\n    int numIslands(vector<vector<char>>& grid)\\n    {\\n        int count=0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ;i<n;i++)\\n        {\\n            for(int j = 0 ;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    // recursive call\\n                    solve(grid,i,j,n,m); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<char>>& grid , int i ,int j,int n ,int m )\\n{\\n    if( i < 0 || j < 0 || i >= n || j >= m )\\n    {\\n        return ;\\n    }\\n    if(grid[i][j]==\\'0\\')\\n    {\\n        return ;\\n    }\\n    grid[i][j]=\\'0\\';\\n\\n    solve(grid,i+1,j, n,m );\\n    solve(grid,i-1,j, n,m );\\n    solve(grid,i,j+1, n,m );\\n    solve(grid,i,j-1, n,m );\\n}\\n\\n    int numIslands(vector<vector<char>>& grid)\\n    {\\n        int count=0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ;i<n;i++)\\n        {\\n            for(int j = 0 ;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    // recursive call\\n                    solve(grid,i,j,n,m); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756862,
                "title": "c-concise-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int row, int col) {\\n        // Base cases for recursion\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != \\'1\\') {\\n            return;\\n        }\\n        \\n        // Mark the current cell as visited\\n        grid[row][col] = \\'2\\';\\n        \\n        // Recursive calls in 4 directions\\n        dfs(grid, row - 1, col); // Up\\n        dfs(grid, row + 1, col); // Down\\n        dfs(grid, row, col - 1); // Left\\n        dfs(grid, row, col + 1); // Right\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int islandCount = 0;\\n        \\n        // Traverse each cell in the grid\\n        for (int row = 0; row < grid.size(); row++) {\\n            for (int col = 0; col < grid[0].size(); col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    islandCount++;\\n                    dfs(grid, row, col);\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Find a \\'1\\' in the grid.**\\n- **Mark it and all other \\'1\\'s adjacent** to it and each other using **dfs as \\'2\\'**. This ensures **an island is calculated only once.** **Increase** the **islandCount.**\\n- **Traverse** all over **grid** and **find all the islands.**\\n\\n---\\n\\n\\n# Approach\\n- **Initialize islandCount** to **0**;\\n- **Iterate over grid** and call the **dfs function if \\'1\\'**(island) is found. Also **increment islandCount**.\\n- The **dfs** function takes **3 parameters**:-\\n**row** and **column** of the \\'1\\',the **grid**.\\n- The **task of the dfs** function is to **mark all the adjacent \\'1\\'s to \\'2\\'** so that the are counted only once. The **working of dfs** is expalined:-\\n    1) **(base case)** - If the **row or column** of the dfs function are **out of range** or if **grid[row][col] is not** equal to **\\'1\\', return**.\\n    2) **(update step)** - **update** the value of **grid[row][col] to \\'2\\'**.\\n    3) **(recursive step)** - **Call the dfs function recursively** for adjacent rows and columns.\\n- **Return** the **islandCount**. \\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity: O(m*n)** where **m** and **n** are **dimensions** of the **grid.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(m*n)** where **m** and **n** are **dimensions** of the **grid.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n**Please upvote if it helped. Happy Coding!**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int row, int col) {\\n        // Base cases for recursion\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != \\'1\\') {\\n            return;\\n        }\\n        \\n        // Mark the current cell as visited\\n        grid[row][col] = \\'2\\';\\n        \\n        // Recursive calls in 4 directions\\n        dfs(grid, row - 1, col); // Up\\n        dfs(grid, row + 1, col); // Down\\n        dfs(grid, row, col - 1); // Left\\n        dfs(grid, row, col + 1); // Right\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int islandCount = 0;\\n        \\n        // Traverse each cell in the grid\\n        for (int row = 0; row < grid.size(); row++) {\\n            for (int col = 0; col < grid[0].size(); col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    islandCount++;\\n                    dfs(grid, row, col);\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296102,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                        visited[nrow][ncol] = 1;\\n                        q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(i, j, grid, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing DFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited, int drow[], int dcol[]) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                    dfs(nrow, ncol, grid, visited, drow, dcol);\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    dfs(i, j, grid, visited, drow, dcol);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                        visited[nrow][ncol] = 1;\\n                        q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(i, j, grid, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited, int drow[], int dcol[]) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                    dfs(nrow, ncol, grid, visited, drow, dcol);\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    dfs(i, j, grid, visited, drow, dcol);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248719,
                "title": "python-both-bfs-and-dfs-made-easy-90-fastest-solution-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAssume the grid as a graph and traverse through the graph using either BFS or DFS  and count the no of connected graph components are found.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can either use BFS approach or DFS approach to solve this problem\\n\\n- Some other similar problems are :\\n    - LC - 733\\n    - LC - 200\\n    - LC - 695\\n    - LC - 1254\\n    - LC - 1020\\n    - LC - 1905\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        ans=0\\n        visited=set()\\n        def bfs(i,j):\\n            q=deque()\\n            visited.add((i,j))\\n            q.append((i,j))\\n            while q:\\n                r,c=q.popleft()\\n                adj=[[1,0],[0,1],[-1,0],[0,-1]]\\n                for x,y in adj:\\n                    if (r+x) in range(m) and (c+y) in range(n) and grid[r+x][c+y]==\\'1\\' and (r+x,c+y) not in visited:\\n                        visited.add((r+x,c+y))\\n                        q.append((r+x,c+y))\\n        \\n        def dfs(i,j):\\n            visited.add((i,j))\\n            for x,y in [[i+1,j],[i,j+1],[i-1,j],[i,j-1]]:\\n                if x in range(m) and y in range(n) and (x,y) not in visited and grid[x][y]==\\'1\\':\\n                    dfs(x,y)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'1\\' and (i,j) not in visited:\\n                    ans+=1\\n                    dfs(i,j)\\n                    #bfs(i,j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        ans=0\\n        visited=set()\\n        def bfs(i,j):\\n            q=deque()\\n            visited.add((i,j))\\n            q.append((i,j))\\n            while q:\\n                r,c=q.popleft()\\n                adj=[[1,0],[0,1],[-1,0],[0,-1]]\\n                for x,y in adj:\\n                    if (r+x) in range(m) and (c+y) in range(n) and grid[r+x][c+y]==\\'1\\' and (r+x,c+y) not in visited:\\n                        visited.add((r+x,c+y))\\n                        q.append((r+x,c+y))\\n        \\n        def dfs(i,j):\\n            visited.add((i,j))\\n            for x,y in [[i+1,j],[i,j+1],[i-1,j],[i,j-1]]:\\n                if x in range(m) and y in range(n) and (x,y) not in visited and grid[x][y]==\\'1\\':\\n                    dfs(x,y)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'1\\' and (i,j) not in visited:\\n                    ans+=1\\n                    dfs(i,j)\\n                    #bfs(i,j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180904,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j) {\\n        grid[i][j] = \\'0\\';\\n        int m = grid.size(), n = grid[0].size();\\n\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\') dfs(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] == \\'1\\') dfs(grid, i+1, j);\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\') dfs(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] == \\'1\\') dfs(grid, i, j+1);\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\n        int ans = 0;\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        componentCounter = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j): \\n            grid[i][j] = -1\\n            if (i < m - 1 and grid[i + 1][j] == \"1\"): \\n                dfs(i + 1, j)\\n            if (i > 0 and grid[i - 1][j] == \"1\"): \\n                dfs(i - 1, j)\\n            if (j < n - 1 and grid[i][j + 1] == \"1\"): \\n                dfs(i, j + 1)\\n            if (j > 0 and grid[i][j - 1] == \"1\"): \\n                dfs(i, j - 1)\\n        \\n        for k in range(m): \\n            for l in range(n): \\n                if grid[k][l] == \"1\": \\n                    componentCounter += 1\\n                    dfs(k, l)\\n        return componentCounter\\n```\\n\\n```Java []\\nclass Solution {\\n    int r;\\n    int c;\\n    char[][] arr;\\n    int count;\\n    public int numIslands(char[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        arr = grid;\\n\\n        count =0;\\n        for(int i=0;i<r;i++){\\n            check(grid[i],i);\\n        }\\n        return count;\\n    }\\n    void check(char[] row,int i)\\n    {\\n        for(int j=0;j<c;j++)\\n        {\\n            if(row[j]==\\'1\\')\\n            {\\n                visitIsland(i,j);\\n                count++;\\n            }\\n        }\\n    }\\n    public void visitIsland(int i, int j){\\n        arr[i][j] = 2;\\n        if(i-1>=0 && arr[i-1][j]==\\'1\\')visitIsland(i-1,j);\\n         if(i+1<r && arr[i+1][j]==\\'1\\')visitIsland(i+1,j);\\n         if(j-1>=0 && arr[i][j-1]==\\'1\\')visitIsland(i,j-1);\\n         if(j+1<c && arr[i][j+1]==\\'1\\')visitIsland(i,j+1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j) {\\n        grid[i][j] = \\'0\\';\\n        int m = grid.size(), n = grid[0].size();\\n\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\') dfs(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] == \\'1\\') dfs(grid, i+1, j);\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\') dfs(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] == \\'1\\') dfs(grid, i, j+1);\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\n        int ans = 0;\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        componentCounter = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j): \\n            grid[i][j] = -1\\n            if (i < m - 1 and grid[i + 1][j] == \"1\"): \\n                dfs(i + 1, j)\\n            if (i > 0 and grid[i - 1][j] == \"1\"): \\n                dfs(i - 1, j)\\n            if (j < n - 1 and grid[i][j + 1] == \"1\"): \\n                dfs(i, j + 1)\\n            if (j > 0 and grid[i][j - 1] == \"1\"): \\n                dfs(i, j - 1)\\n        \\n        for k in range(m): \\n            for l in range(n): \\n                if grid[k][l] == \"1\": \\n                    componentCounter += 1\\n                    dfs(k, l)\\n        return componentCounter\\n```\n```Java []\\nclass Solution {\\n    int r;\\n    int c;\\n    char[][] arr;\\n    int count;\\n    public int numIslands(char[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        arr = grid;\\n\\n        count =0;\\n        for(int i=0;i<r;i++){\\n            check(grid[i],i);\\n        }\\n        return count;\\n    }\\n    void check(char[] row,int i)\\n    {\\n        for(int j=0;j<c;j++)\\n        {\\n            if(row[j]==\\'1\\')\\n            {\\n                visitIsland(i,j);\\n                count++;\\n            }\\n        }\\n    }\\n    public void visitIsland(int i, int j){\\n        arr[i][j] = 2;\\n        if(i-1>=0 && arr[i-1][j]==\\'1\\')visitIsland(i-1,j);\\n         if(i+1<r && arr[i+1][j]==\\'1\\')visitIsland(i+1,j);\\n         if(j-1>=0 && arr[i][j-1]==\\'1\\')visitIsland(i,j-1);\\n         if(j+1<c && arr[i][j+1]==\\'1\\')visitIsland(i,j+1);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2945310,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse and mark islands \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep A visited matrix and mark all islands through DFS and count them \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        visited[i][j]=true;\\n        if(j-1>=0 && grid[i][j-1]==\\'1\\' && visited[i][j-1]==false){\\n            dfs(grid,i,j-1,m,n,visited);\\n        }\\n        if(i-1>=0 && grid[i-1][j]==\\'1\\' && visited[i-1][j]==false){\\n            dfs(grid,i-1,j,m,n,visited);\\n        }\\n        if(j+1<n && grid[i][j+1]==\\'1\\' && visited[i][j+1]==false){\\n            dfs(grid,i,j+1,m,n,visited);\\n        }\\n        if(i+1<m && grid[i+1][j]==\\'1\\' && visited[i+1][j]==false){\\n            dfs(grid,i+1,j,m,n,visited);\\n        }\\n        return;\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m=grid.size ();\\n        int n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        int ans=0;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                dfs(grid,i,j,m,n,visited);\\n                ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        visited[i][j]=true;\\n        if(j-1>=0 && grid[i][j-1]==\\'1\\' && visited[i][j-1]==false){\\n            dfs(grid,i,j-1,m,n,visited);\\n        }\\n        if(i-1>=0 && grid[i-1][j]==\\'1\\' && visited[i-1][j]==false){\\n            dfs(grid,i-1,j,m,n,visited);\\n        }\\n        if(j+1<n && grid[i][j+1]==\\'1\\' && visited[i][j+1]==false){\\n            dfs(grid,i,j+1,m,n,visited);\\n        }\\n        if(i+1<m && grid[i+1][j]==\\'1\\' && visited[i+1][j]==false){\\n            dfs(grid,i+1,j,m,n,visited);\\n        }\\n        return;\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m=grid.size ();\\n        int n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        int ans=0;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                dfs(grid,i,j,m,n,visited);\\n                ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708844,
                "title": "very-easy-concise-java-solution",
                "content": "\\tpublic class Solution {\\n\\n\\t\\t\\tprivate int n;\\n\\t\\t\\tprivate int m;\\n\\n\\t\\tpublic int numIslands(char[][] grid) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tn = grid.length;\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tm = grid[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\t\\tDFSMarking(grid, i, j);\\n\\t\\t\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\n\\t\\tprivate void DFSMarking(char[][] grid, int i, int j) {\\n\\t\\t\\t\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tDFSMarking(grid, i + 1, j);\\n\\t\\t\\t\\tDFSMarking(grid, i - 1, j);\\n\\t\\t\\t\\tDFSMarking(grid, i, j + 1);\\n\\t\\t\\t\\tDFSMarking(grid, i, j - 1);\\n\\t\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\t\\t\\tprivate int n;\\n\\t\\t\\tprivate int m;\\n\\n\\t\\tpublic int numIslands(char[][] grid) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tn = grid.length;\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tm = grid[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\t\\tDFSMarking(grid, i, j);\\n\\t\\t\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2215358,
                "title": "python-optimal-solution",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        row, col, res = len(grid), len(grid[0]), 0\\n\\n        def mark_island(x, y):\\n            \"\"\"\\n            check whether current (x, y) is land or not. If it\\'s land, mark everything on the island to 2\\n            \"\"\"\\n            if 0 <= x < row and 0 <= y < col and grid[x][y] == \\'1\\':\\n                grid[x][y] = \\'2\\'\\n                for nxt_x, nxt_y in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\\n                    mark_island(nxt_x, nxt_y)\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \\'1\\':\\n                    mark_island(i, j)\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        row, col, res = len(grid), len(grid[0]), 0\\n\\n        def mark_island(x, y):\\n            \"\"\"\\n            check whether current (x, y) is land or not. If it\\'s land, mark everything on the island to 2\\n            \"\"\"\\n            if 0 <= x < row and 0 <= y < col and grid[x][y] == \\'1\\':\\n                grid[x][y] = \\'2\\'\\n                for nxt_x, nxt_y in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\\n                    mark_island(nxt_x, nxt_y)\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \\'1\\':\\n                    mark_island(i, j)\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063385,
                "title": "java-dfs-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3ce1222f-5dff-461f-b779-3c0a0804c669_1653215072.8381944.jpeg)\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n\\t\\tint count = 0; //count the total no of island\\n        \\n        for(int i = 0; i < grid.length; i++){ // Traverse Row\\n            for(int j = 0; j < grid[0].length; j++){ //Traverse Column\\n                if(grid[i][j] == \\'1\\'){ // if we find \\'1\\' in matrix\\n                    count++; \\n                    BFS(grid, i, j);  //call BFS method to find the island\\n                }\\n            }\\n        }\\n        return count; //return the number of island\\n    }\\n        // Helper Method to find island\\n    public void BFS(char[][] grid, int i, int j){\\n        //Base Condition\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == \\'0\\'){\\n            return;\\n        }\\n\\t\\t//when we find \\'1\\' then convert it into \\'0\\'\\n        grid[i][j] = \\'0\\'; \\n        BFS(grid, i+1, j); // up\\n        BFS(grid, i-1, j); // down\\n        BFS(grid, i, j-1); // left\\n        BFS(grid, i, j+1); // right\\n\\t\\t}\\n\\t}\\n\\n// If you like this solution please vote \\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n\\t\\tint count = 0; //count the total no of island\\n        \\n        for(int i = 0; i < grid.length; i++){ // Traverse Row\\n            for(int j = 0; j < grid[0].length; j++){ //Traverse Column\\n                if(grid[i][j] == \\'1\\'){ // if we find \\'1\\' in matrix\\n                    count++; \\n                    BFS(grid, i, j);  //call BFS method to find the island\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1527460,
                "title": "c-simple-and-cleanest-bfs-and-dfs-without-visited-array",
                "content": "```\\npublic int NumIslands(char[][] grid) \\n    {\\n        if(grid == null)\\n            return 0;\\n        \\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        var islands = 0;\\n        \\n        for(int row=0; row<rows; row++)\\n        {\\n            for(int col=0; col<cols; col++)\\n            {\\n                if(grid[row][col] == \\'1\\')\\n                {\\n\\t\\t\\t\\t\\t//want to apply DFS, replace following call with CheckLandBelongsToIsland**DFS**\\n                    CheckLandBelongsToIslandBFS(grid, row, col); \\n                    islands +=1;   \\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n\\n\\t//BFS\\n    public void CheckLandBelongsToIslandBFS(char[][] grid, int row, int col)\\n    {\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { row, col});\\n        \\n        \\n        while(queue.Count != 0)\\n        {\\n            var item = queue.Dequeue();\\n            row = item[0];\\n            col = item[1];\\n            \\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n            {\\n                continue;\\n            }\\n            \\n            grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n            queue.Enqueue(new int[] { row - 1, col}); //UP\\n            queue.Enqueue(new int[] { row + 1, col}); //Down\\n            queue.Enqueue(new int[] { row, col + 1}); //Right\\n            queue.Enqueue(new int[] { row, col - 1}); //Left\\n        }\\n    }\\n\\n\\t//DFS\\n    public void CheckLandBelongsToIslandDFS(char[][] grid, int row, int col)\\n    {\\n        if(row<0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n        CheckLandBelongsToIsland(grid, row - 1, col); //Up\\n        CheckLandBelongsToIsland(grid, row + 1, col); //Down\\n        CheckLandBelongsToIsland(grid, row, col + 1); //Right\\n        CheckLandBelongsToIsland(grid, row, col - 1); //Left\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int NumIslands(char[][] grid) \\n    {\\n        if(grid == null)\\n            return 0;\\n        \\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        var islands = 0;\\n        \\n        for(int row=0; row<rows; row++)\\n        {\\n            for(int col=0; col<cols; col++)\\n            {\\n                if(grid[row][col] == \\'1\\')\\n                {\\n\\t\\t\\t\\t\\t//want to apply DFS, replace following call with CheckLandBelongsToIsland**DFS**\\n                    CheckLandBelongsToIslandBFS(grid, row, col); \\n                    islands +=1;   \\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n\\n\\t//BFS\\n    public void CheckLandBelongsToIslandBFS(char[][] grid, int row, int col)\\n    {\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { row, col});\\n        \\n        \\n        while(queue.Count != 0)\\n        {\\n            var item = queue.Dequeue();\\n            row = item[0];\\n            col = item[1];\\n            \\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n            {\\n                continue;\\n            }\\n            \\n            grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n            queue.Enqueue(new int[] { row - 1, col}); //UP\\n            queue.Enqueue(new int[] { row + 1, col}); //Down\\n            queue.Enqueue(new int[] { row, col + 1}); //Right\\n            queue.Enqueue(new int[] { row, col - 1}); //Left\\n        }\\n    }\\n\\n\\t//DFS\\n    public void CheckLandBelongsToIslandDFS(char[][] grid, int row, int col)\\n    {\\n        if(row<0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n        CheckLandBelongsToIsland(grid, row - 1, col); //Up\\n        CheckLandBelongsToIsland(grid, row + 1, col); //Down\\n        CheckLandBelongsToIsland(grid, row, col + 1); //Right\\n        CheckLandBelongsToIsland(grid, row, col - 1); //Left\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395142,
                "title": "c-dfs-logic-explained-number-of-connected-components",
                "content": "* Overall the idea is to find **number of connected components**\\n* If adjacent cell is having 1, consider it as a **connected node** \\n* Being at any (i,j) point , apply DFS recursively to all its connected nodes\\n* You can either take a visited matrix or modify the same matrix making 1 as 0 ( I have modified the same matrix)\\n* DFS is like, if u burn a points, it will burn all the points connected, u need to count how much time u need to burn such that all points are burnt \\n* **TC: (N*M)**  ( Explained more in comment section )\\n* **SC: (N*M)**\\n\\nGive a like if it helped you. \\nHaving doubt ? Post it in comment section \\n```\\nclass Solution {\\npublic:\\n    void DFS( vector<vector<char>> &grid, int r, int c, int n, int m ){\\n        if( r<0 || r>=n || c<0 || c>=m || grid[r][c] == \\'0\\' ) return;\\n        grid[r][c] = \\'0\\';\\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        for( int i=0; i<4; i++ )\\n            DFS( grid, r+x[i], c+y[i], n, m );\\n    }\\n    int numIslands(vector<vector<char>> &grid) {\\n        int count =0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==\\'1\\' ){\\n                    count++;\\n                    DFS( grid, i, j, n, m );\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS( vector<vector<char>> &grid, int r, int c, int n, int m ){\\n        if( r<0 || r>=n || c<0 || c>=m || grid[r][c] == \\'0\\' ) return;\\n        grid[r][c] = \\'0\\';\\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        for( int i=0; i<4; i++ )\\n            DFS( grid, r+x[i], c+y[i], n, m );\\n    }\\n    int numIslands(vector<vector<char>> &grid) {\\n        int count =0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==\\'1\\' ){\\n                    count++;\\n                    DFS( grid, i, j, n, m );\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369131,
                "title": "js-dfs",
                "content": "```\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    for(let i=0;i<grid.length;i++) {\\n        for(let j=0;j<grid[0].length;j++) {\\n            if(grid[i][j] == \\'1\\') {\\n                count++;\\n                dfsSink(grid, i,j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n//if there are connected island sink them as connected island only count as one \\nconst dfsSink = (grid, i,j) => {\\n   //if out of bound or encounter sea\\n    if (i==grid.length ||i<0 ||j==grid[0].length||j<0||grid[i][j] ==\\'0\\') {\\n        return;\\n    }\\n    if (grid[i][j] ==\\'1\\') {\\n        grid[i][j] = \\'0\\';\\n        dfsSink(grid, i-1,j);\\n        dfsSink(grid, i,j-1);\\n        dfsSink(grid, i+1,j);\\n        dfsSink(grid, i,j+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    for(let i=0;i<grid.length;i++) {\\n        for(let j=0;j<grid[0].length;j++) {\\n            if(grid[i][j] == \\'1\\') {\\n                count++;\\n                dfsSink(grid, i,j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n//if there are connected island sink them as connected island only count as one \\nconst dfsSink = (grid, i,j) => {\\n   //if out of bound or encounter sea\\n    if (i==grid.length ||i<0 ||j==grid[0].length||j<0||grid[i][j] ==\\'0\\') {\\n        return;\\n    }\\n    if (grid[i][j] ==\\'1\\') {\\n        grid[i][j] = \\'0\\';\\n        dfsSink(grid, i-1,j);\\n        dfsSink(grid, i,j-1);\\n        dfsSink(grid, i+1,j);\\n        dfsSink(grid, i,j+1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358520,
                "title": "number-of-islands-bfs-python-iterative-faster-than-99-50",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        l, b = len(grid), len(grid[0])\\n        c = 0\\n\\n        def makeZero(grid, i, j, n, m):\\n            q = [[i, j]]\\n            while q != []:\\n                ci, cj = q.pop(0)\\n                grid[ci][cj] = \"0\"\\n                if (ci - 1) >= 0 and grid[ci - 1][cj] == \"1\":\\n                        q.append([ci - 1, cj])\\n                        grid[ci-1][cj]=\"0\"\\n                if (ci + 1) < n and grid[ci + 1][cj] == \"1\":\\n                        q.append([ci + 1, cj])\\n                        grid[ci + 1][cj] = \"0\"\\n                if (cj - 1) >= 0 and grid[ci][cj - 1] == \"1\":\\n                        q.append([ci, cj - 1])\\n                        grid[ci][cj-1] = \"0\"\\n                if (cj + 1) < m and grid[ci][cj + 1] == \"1\":\\n                        q.append([ci, cj + 1])\\n                        grid[ci][cj+1] = \"0\"\\n\\n\\n        for i in range(l):\\n            for j in range(b):\\n                if grid[i][j] == \"1\":\\n                    c += 1\\n                    makeZero(grid, i, j, l, b)\\n\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        l, b = len(grid), len(grid[0])\\n        c = 0\\n\\n        def makeZero(grid, i, j, n, m):\\n            q = [[i, j]]\\n            while q != []:\\n                ci, cj = q.pop(0)\\n                grid[ci][cj] = \"0\"\\n                if (ci - 1) >= 0 and grid[ci - 1][cj] == \"1\":\\n                        q.append([ci - 1, cj])\\n                        grid[ci-1][cj]=\"0\"\\n                if (ci + 1) < n and grid[ci + 1][cj] == \"1\":\\n                        q.append([ci + 1, cj])\\n                        grid[ci + 1][cj] = \"0\"\\n                if (cj - 1) >= 0 and grid[ci][cj - 1] == \"1\":\\n                        q.append([ci, cj - 1])\\n                        grid[ci][cj-1] = \"0\"\\n                if (cj + 1) < m and grid[ci][cj + 1] == \"1\":\\n                        q.append([ci, cj + 1])\\n                        grid[ci][cj+1] = \"0\"\\n\\n\\n        for i in range(l):\\n            for j in range(b):\\n                if grid[i][j] == \"1\":\\n                    c += 1\\n                    makeZero(grid, i, j, l, b)\\n\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265216,
                "title": "python-union-find",
                "content": "```\\nclass DSU:\\n    def __init__(self, size):\\n        self.array = [i for i in range(size)]\\n        self.size = size \\n        \\n    def find(self, num):\\n        if self.array[num] != num:\\n            self.array[num] = self.find(self.array[num])\\n        \\n        return self.array[num]\\n\\n    def union(self, num1, num2) -> bool:\\n        parent1 = self.find(num1)\\n        parent2 = self.find(num2)\\n        \\n        if parent1 == parent2: \\n            # there is no union to be done \\n            return False\\n         \\n        self.array[parent1] = parent2\\n        return True \\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dsu = DSU(m*n)\\n        \\n        res = 0 \\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    res += 1 \\n                    \\n                    for pair in dirs: \\n                        r = i + pair[0]\\n                        c = j + pair[1]\\n                        \\n                        if 0 <= r < m and 0 <= c < n and grid[r][c] == \"1\":\\n                            cell_1 = (i * n) + j \\n                            cell_2 = (r * n) + c \\n                            \\n                            if dsu.union(cell_1, cell_2): \\n                                # they both are a part of one island. So reduce result count \\n                                res -= 1 \\n        \\n        return res\\n    \\n# Time = O(M x N)\\n# Space = O(M x N)\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, size):\\n        self.array = [i for i in range(size)]\\n        self.size = size \\n        \\n    def find(self, num):\\n        if self.array[num] != num:\\n            self.array[num] = self.find(self.array[num])\\n        \\n        return self.array[num]\\n\\n    def union(self, num1, num2) -> bool:\\n        parent1 = self.find(num1)\\n        parent2 = self.find(num2)\\n        \\n        if parent1 == parent2: \\n            # there is no union to be done \\n            return False\\n         \\n        self.array[parent1] = parent2\\n        return True \\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dsu = DSU(m*n)\\n        \\n        res = 0 \\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    res += 1 \\n                    \\n                    for pair in dirs: \\n                        r = i + pair[0]\\n                        c = j + pair[1]\\n                        \\n                        if 0 <= r < m and 0 <= c < n and grid[r][c] == \"1\":\\n                            cell_1 = (i * n) + j \\n                            cell_2 = (r * n) + c \\n                            \\n                            if dsu.union(cell_1, cell_2): \\n                                # they both are a part of one island. So reduce result count \\n                                res -= 1 \\n        \\n        return res\\n    \\n# Time = O(M x N)\\n# Space = O(M x N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911853,
                "title": "code-with-image-and-debug-explanation",
                "content": "Here is the basic idea. When a cell is a land then convert all cells around  to water\\n![image](https://assets.leetcode.com/users/images/a3c6a127-0722-4131-9efc-8726e0e87324_1603768744.9087245.png)\\n\\nThen the rest is easy. \\n\\n```\\nvar numIslands = function(grid) {\\n    if(!grid || !grid[0]){\\n        return 0;\\n    }\\n    const convertLandToWater = (i,j) => {\\n        if(grid[i] == undefined || grid[i][j] == undefined || grid[i][j] == \"0\"){\\n            return;\\n        }\\n        grid[i][j]=\"0\";\\n        convertLandToWater(i+1,j);\\n        convertLandToWater(i,j +1);\\n        convertLandToWater(i-1,j);\\n        convertLandToWater(i,j -1);\\n    }\\n\\n    let counter = 0;\\n    for (let i = 0; i < grid.length ; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if(grid[i][j] == \"1\"){\\n                counter++;\\n                convertLandToWater(i,j);\\n       \\n            }\\n\\n        }\\n    }\\n    return counter;\\n};\\n```\\n\\nSample input : \\n\\n![image](https://assets.leetcode.com/users/images/4a023f5b-971e-4a2e-a358-6b04537145b3_1603768937.4152658.png)\\n\\nFind more inresting things here : https://canthodeveloper.wordpress.com/\\n",
                "solutionTags": [],
                "code": "```\\nvar numIslands = function(grid) {\\n    if(!grid || !grid[0]){\\n        return 0;\\n    }\\n    const convertLandToWater = (i,j) => {\\n        if(grid[i] == undefined || grid[i][j] == undefined || grid[i][j] == \"0\"){\\n            return;\\n        }\\n        grid[i][j]=\"0\";\\n        convertLandToWater(i+1,j);\\n        convertLandToWater(i,j +1);\\n        convertLandToWater(i-1,j);\\n        convertLandToWater(i,j -1);\\n    }\\n\\n    let counter = 0;\\n    for (let i = 0; i < grid.length ; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if(grid[i][j] == \"1\"){\\n                counter++;\\n                convertLandToWater(i,j);\\n       \\n            }\\n\\n        }\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809165,
                "title": "javascript-bfs",
                "content": "\\n```\\nconst WATER = \\'0\\';\\nconst LAND = \\'1\\';\\nconst DIRECTIONS = [\\n    [0, 1],\\n    [1, 0],\\n    [0, -1],\\n    [-1, 0],\\n];\\n\\nfunction bfs(grid, r, c ) {\\n    let queue = [[r, c]];\\n    grid[r][c] = WATER;\\n    \\n    while (queue.length) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let [row, col] = queue.pop();\\n            \\n            for (let [x, y] of DIRECTIONS) {\\n                let iRow = row + x;\\n                let iCol = col + y;\\n                \\n                if (iRow < 0 || iRow >= grid.length || iCol < 0 || iCol >= grid[0].length || grid[iRow][iCol] !== LAND) {\\n                    continue;\\n                }\\n                \\n                grid[iRow][iCol] = WATER;\\n                queue.unshift([iRow, iCol]);\\n            }\\n        }\\n    }\\n}\\n\\nfunction numIslands(grid) {\\n    if (!grid.length) {\\n        return 0;\\n    }\\n    \\n    let numberOfIslands = 0;\\n    for (let r = 0; r < grid.length; r++) {\\n        for (let c = 0; c < grid[0].length; c++) {\\n            if (grid[r][c] === LAND) {\\n                numberOfIslands++;\\n                bfs(grid, r, c);\\n            }\\n        }\\n    }\\n    return numberOfIslands;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst WATER = \\'0\\';\\nconst LAND = \\'1\\';\\nconst DIRECTIONS = [\\n    [0, 1],\\n    [1, 0],\\n    [0, -1],\\n    [-1, 0],\\n];\\n\\nfunction bfs(grid, r, c ) {\\n    let queue = [[r, c]];\\n    grid[r][c] = WATER;\\n    \\n    while (queue.length) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let [row, col] = queue.pop();\\n            \\n            for (let [x, y] of DIRECTIONS) {\\n                let iRow = row + x;\\n                let iCol = col + y;\\n                \\n                if (iRow < 0 || iRow >= grid.length || iCol < 0 || iCol >= grid[0].length || grid[iRow][iCol] !== LAND) {\\n                    continue;\\n                }\\n                \\n                grid[iRow][iCol] = WATER;\\n                queue.unshift([iRow, iCol]);\\n            }\\n        }\\n    }\\n}\\n\\nfunction numIslands(grid) {\\n    if (!grid.length) {\\n        return 0;\\n    }\\n    \\n    let numberOfIslands = 0;\\n    for (let r = 0; r < grid.length; r++) {\\n        for (let c = 0; c < grid[0].length; c++) {\\n            if (grid[r][c] === LAND) {\\n                numberOfIslands++;\\n                bfs(grid, r, c);\\n            }\\n        }\\n    }\\n    return numberOfIslands;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673201,
                "title": "python3-union-find-better-than-83",
                "content": "I haven\\'t seen any solutions using union find, so I think posting it might be useful since it also has decent performance.\\n\\nThe idea here is to go through all of the cells and for each cell, if it\\'s a 1:\\n- add it to the UF structure (done in a separate step)\\n- check the right neighbor and if it\\'s also a 1, union the two cells\\n- same for down neighbor\\n\\nAt the end, the answer is the number of cells that are roots\\n\\nNote: Also tried optimizing unions using size, but that actually made the solution slower somehow\\n\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) == 0:\\n            return 0\\n        \\n        uf = {}\\n        N = len(grid)\\n        M = len(grid[0])\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'1\\':\\n                    uf[(i,j)] = (i,j)\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'0\\':\\n                    continue\\n                \\n                if i+1<N and grid[i+1][j] == \\'1\\':\\n                    union(uf, (i,j), (i+1,j))\\n                if j+1<M and grid[i][j+1] == \\'1\\':\\n                    union(uf, (i,j), (i,j+1))\\n        \\n        count = 0\\n        for k, v in uf.items():\\n            if v == k:\\n                count += 1\\n        return count\\n    \\ndef union(uf, a, b) -> None:\\n    uf[root(uf, b)] = root(uf, a)\\n    \\ndef root(uf, x) -> str:\\n    r = x\\n    while r != uf[r]:\\n        r = uf[r]\\n    return r\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) == 0:\\n            return 0\\n        \\n        uf = {}\\n        N = len(grid)\\n        M = len(grid[0])\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'1\\':\\n                    uf[(i,j)] = (i,j)\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'0\\':\\n                    continue\\n                \\n                if i+1<N and grid[i+1][j] == \\'1\\':\\n                    union(uf, (i,j), (i+1,j))\\n                if j+1<M and grid[i][j+1] == \\'1\\':\\n                    union(uf, (i,j), (i,j+1))\\n        \\n        count = 0\\n        for k, v in uf.items():\\n            if v == k:\\n                count += 1\\n        return count\\n    \\ndef union(uf, a, b) -> None:\\n    uf[root(uf, b)] = root(uf, a)\\n    \\ndef root(uf, x) -> str:\\n    r = x\\n    while r != uf[r]:\\n        r = uf[r]\\n    return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597046,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int x[4] = {-1, 0, 1, 0};\\n    int y[4] = {0, 1, 0, -1};\\n\\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == \\'0\\') return;\\n        visited[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(i+x[k], j+y[k], grid, visited);\\n        }\\n    }\\n\\n    int ff(vector<vector<char>>& grid) {\\n        if (!grid.size()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int count = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j] == \\'1\\' and !visited[i][j]) {\\n                    dfs(i, j, grid, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        return ff(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4] = {-1, 0, 1, 0};\\n    int y[4] = {0, 1, 0, -1};\\n\\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == \\'0\\') return;\\n        visited[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(i+x[k], j+y[k], grid, visited);\\n        }\\n    }\\n\\n    int ff(vector<vector<char>>& grid) {\\n        if (!grid.size()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int count = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j] == \\'1\\' and !visited[i][j]) {\\n                    dfs(i, j, grid, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        return ff(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594296,
                "title": "c-elegant-code-with-comments",
                "content": "```\\npublic int NumIslands(char[][] grid) {\\n        if(grid == null || grid.Length == 0)\\n            return 0;\\n        int numIslands = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                // we have found an island\\n                if(grid[i][j] == \\'1\\')\\n                {\\n                    // check neighbours to find # of 1s that are part of this island\\n                    numIslands += DepthFirstSearch(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return numIslands;\\n    }\\n    \\n    private int DepthFirstSearch(char[][] grid, int i, int j)\\n    {\\n        // if i and j are out of bound or grid i,j represent water or grid i,j  is already visited\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\' || grid[i][j] == \\'v\\')\\n        {\\n            return 0;\\n        }\\n        \\n        // mark this point visited. Using \\'v \\'to mark visited\\n        grid[i][j] = \\'v\\';\\n        \\n        // check neighbours up,down,left and right in matrix. Method will mark neighbours visited if grid[i][j] are one i.e. they are also part of this island.\\n        DepthFirstSearch(grid, i-1, j);\\n        DepthFirstSearch(grid, i+1, j);\\n        DepthFirstSearch(grid, i, j-1);\\n        DepthFirstSearch(grid, i, j+1);\\n        \\n        return 1;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumIslands(char[][] grid) {\\n        if(grid == null || grid.Length == 0)\\n            return 0;\\n        int numIslands = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                // we have found an island\\n                if(grid[i][j] == \\'1\\')\\n                {\\n                    // check neighbours to find # of 1s that are part of this island\\n                    numIslands += DepthFirstSearch(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return numIslands;\\n    }\\n    \\n    private int DepthFirstSearch(char[][] grid, int i, int j)\\n    {\\n        // if i and j are out of bound or grid i,j represent water or grid i,j  is already visited\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\' || grid[i][j] == \\'v\\')\\n        {\\n            return 0;\\n        }\\n        \\n        // mark this point visited. Using \\'v \\'to mark visited\\n        grid[i][j] = \\'v\\';\\n        \\n        // check neighbours up,down,left and right in matrix. Method will mark neighbours visited if grid[i][j] are one i.e. they are also part of this island.\\n        DepthFirstSearch(grid, i-1, j);\\n        DepthFirstSearch(grid, i+1, j);\\n        DepthFirstSearch(grid, i, j-1);\\n        DepthFirstSearch(grid, i, j+1);\\n        \\n        return 1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501371,
                "title": "simple-java-bfs-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    static class Node {\\n        int row; \\n        int col;\\n        \\n        Node(int row, int col) {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) return 0;\\n        \\n        int numOfIslands = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    numOfIslands++;\\n             \\n                    Queue<Node> q = new LinkedList<Node>();\\n                    q.offer(new Node(row, col));\\n\\n                    while(!q.isEmpty()) {\\n                        Node n = q.poll();\\n\\n                        if (n.row - 1 >= 0 && grid[n.row - 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row - 1, n.col));\\n                            grid[n.row - 1][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.row + 1 < grid.length && grid[n.row + 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row + 1, n.col));\\n                            grid[n.row + 1 ][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.col - 1 >= 0 && grid[n.row][n.col - 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col - 1));\\n                            grid[n.row][n.col - 1] = \\'0\\';\\n                        }\\n\\n                        if (n.col + 1 < grid[n.row].length && grid[n.row][n.col + 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col + 1));\\n                            grid[n.row][n.col + 1] = \\'0\\';\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numOfIslands;\\n    }\\n}\\n```\\nTime complexity: O(n x m)\\nSpace complexity: O(min(n, m))",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Node {\\n        int row; \\n        int col;\\n        \\n        Node(int row, int col) {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) return 0;\\n        \\n        int numOfIslands = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    numOfIslands++;\\n             \\n                    Queue<Node> q = new LinkedList<Node>();\\n                    q.offer(new Node(row, col));\\n\\n                    while(!q.isEmpty()) {\\n                        Node n = q.poll();\\n\\n                        if (n.row - 1 >= 0 && grid[n.row - 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row - 1, n.col));\\n                            grid[n.row - 1][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.row + 1 < grid.length && grid[n.row + 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row + 1, n.col));\\n                            grid[n.row + 1 ][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.col - 1 >= 0 && grid[n.row][n.col - 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col - 1));\\n                            grid[n.row][n.col - 1] = \\'0\\';\\n                        }\\n\\n                        if (n.col + 1 < grid[n.row].length && grid[n.row][n.col + 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col + 1));\\n                            grid[n.row][n.col + 1] = \\'0\\';\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numOfIslands;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431553,
                "title": "c-dfs-easy-to-understand-solution-beats-92",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint m;\\n\\t\\tint n;\\n\\t\\tvoid fill(vector<vector<char>>& grid,int x,int y){\\n\\t\\t\\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]==\\'0\\'){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tgrid[x][y]=\\'0\\';\\n\\t\\t\\tfill(grid,x+1,y);\\n\\t\\t\\tfill(grid,x-1,y);\\n\\t\\t\\tfill(grid,x,y+1);\\n\\t\\t\\tfill(grid,x,y-1);\\n\\t\\t}\\n\\t\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\t\\tif(grid.empty()) return 0;\\n\\t\\t\\tm=grid.size();\\n\\t\\t\\tn=grid[0].size();\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif(grid[i][j]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\t\\tfill(grid,i,j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint m;\\n\\t\\tint n;\\n\\t\\tvoid fill(vector<vector<char>>& grid,int x,int y){\\n\\t\\t\\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]==\\'0\\'){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 117393,
                "title": "c-very-easy-and-ituitive-solution-with-expanation-accepted",
                "content": "```\npublic class Solution \n{\n    private char[,] grid;\n    private int totalRows;\n    private int totalCols;\n\n    public int NumIslands(char[,] grid)\n    {\n        int islandCount = 0;\n        this.grid = grid;\n        this.totalRows = this.grid.GetLength(0);\n        this.totalCols = this.grid.GetLength(1);\n        for (int r = 0; r < this.totalRows; r++)\n            for (int c = 0; c < this.totalCols; c++)\n            {\n                if (this.grid[r, c] == '1')     //Found land on an island.\n                {\n                    islandCount++;              //Increment island count.\n                    TravelFullIsland(r, c);     //Travel the island.\n                }\n            }\n\n        return islandCount;\n    }\n\n    private void TravelFullIsland(int r, int c)\n    {\n        if (r < 0 || c < 0 || r == this.totalRows || c == this.totalCols || this.grid[r, c] == '0' || this.grid[r, c] == 'T') return;\n        else\n        {\n            this.grid[r, c] = 'T';        //Marking travelled.\n            TravelFullIsland(r + 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c + 1);   //Travelling neighboring land on the island.\n            TravelFullIsland(r - 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c - 1);   //Travelling neighboring land on the island.\n        }\n    }\n}\n```\n![image](https://s3-lc-upload.s3.amazonaws.com/users/amandeep18feb/image_1520037191.png)\n",
                "solutionTags": [],
                "code": "```\npublic class Solution \n{\n    private char[,] grid;\n    private int totalRows;\n    private int totalCols;\n\n    public int NumIslands(char[,] grid)\n    {\n        int islandCount = 0;\n        this.grid = grid;\n        this.totalRows = this.grid.GetLength(0);\n        this.totalCols = this.grid.GetLength(1);\n        for (int r = 0; r < this.totalRows; r++)\n            for (int c = 0; c < this.totalCols; c++)\n            {\n                if (this.grid[r, c] == '1')     //Found land on an island.\n                {\n                    islandCount++;              //Increment island count.\n                    TravelFullIsland(r, c);     //Travel the island.\n                }\n            }\n\n        return islandCount;\n    }\n\n    private void TravelFullIsland(int r, int c)\n    {\n        if (r < 0 || c < 0 || r == this.totalRows || c == this.totalCols || this.grid[r, c] == '0' || this.grid[r, c] == 'T') return;\n        else\n        {\n            this.grid[r, c] = 'T';        //Marking travelled.\n            TravelFullIsland(r + 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c + 1);   //Travelling neighboring land on the island.\n            TravelFullIsland(r - 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c - 1);   //Travelling neighboring land on the island.\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 56578,
                "title": "dfs-java-solution",
                "content": "    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int total = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        total++;\\n                        dfs(grid,i,j);\\n                    }\\n                }\\n            }   \\n            return total;\\n        }\\n        \\n        public void dfs(char[][] grid, int row, int col){\\n            if(row<0||row==grid.length||col<0||col==grid[0].length||grid[row][col]!='1')\\n                return;\\n            \\n            grid[row][col]='2';\\n            dfs(grid,row-1,col);\\n            dfs(grid,row+1,col);\\n            dfs(grid,row,col-1);\\n            dfs(grid,row,col+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int total = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        total++;\\n                        dfs(grid,i,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3621229,
                "title": "simple-c-dfs-solution",
                "content": "\\n\\n# Approach\\n1. Iterate over each row and column which is not visited, and run a dfs function to traverse through each connected land. Also increase the value of cnt which represents the number of islands.\\n2. In dfs function: if row or col crosses boundary then we need to return function.\\n3. Also when the grid corresponding to particular row and col is water ie \\'0\\' then also we need to return.\\n4. Also when we are on already visited grid we need to return\\n5. Otherwise, mark the grid as visited and traverse in all possible directions and run the dfs function.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<char>>&grid,vector<vector<int>>&vis){\\n        int n=grid.size(),m=grid[0].size();\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==\\'0\\'||vis[row][col]){\\n            return;\\n        }\\n        vis[row][col]=1;\\n        vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto ele:dir){\\n            int nr=row+ele.first,nc=col+ele.second;\\n            dfs(nr,nc,grid,vis);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int cnt=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid[i][j]==\\'1\\'){\\n                    cnt++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n       // <!-- Please upvote if you liked !!!-->\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<char>>&grid,vector<vector<int>>&vis){\\n        int n=grid.size(),m=grid[0].size();\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==\\'0\\'||vis[row][col]){\\n            return;\\n        }\\n        vis[row][col]=1;\\n        vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto ele:dir){\\n            int nr=row+ele.first,nc=col+ele.second;\\n            dfs(nr,nc,grid,vis);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int cnt=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid[i][j]==\\'1\\'){\\n                    cnt++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n       // <!-- Please upvote if you liked !!!-->\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551263,
                "title": "simple-intuitive-solution-using-a-recursive-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive marking using ```bomb()``` funtion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMark the already found island to ```\"2\"```\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\times m )$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\times m )$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def bomb(grid, m, n, i, j):\\n            if i < n and j < m and i >= 0 and j >= 0:\\n                if grid[j][i] == \"1\":\\n                    grid[j][i] = \"2\"\\n                    bomb(grid, m, n, i + 1, j)\\n                    bomb(grid, m, n, i - 1, j)\\n                    bomb(grid, m, n, i , j + 1)\\n                    bomb(grid, m, n, i , j - 1)\\n            return\\n        r = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if grid[y][x] == \"1\":\\n                    r = r + 1\\n                    bomb(grid, m, n, x, y)\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```bomb()```\n```\"2\"```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def bomb(grid, m, n, i, j):\\n            if i < n and j < m and i >= 0 and j >= 0:\\n                if grid[j][i] == \"1\":\\n                    grid[j][i] = \"2\"\\n                    bomb(grid, m, n, i + 1, j)\\n                    bomb(grid, m, n, i - 1, j)\\n                    bomb(grid, m, n, i , j + 1)\\n                    bomb(grid, m, n, i , j - 1)\\n            return\\n        r = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if grid[y][x] == \"1\":\\n                    r = r + 1\\n                    bomb(grid, m, n, x, y)\\n        return r\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567749,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1572439,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1564854,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1565770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566246,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1570785,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568315,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566766,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566334,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1567749,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1572439,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1564854,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1565770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566246,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1570785,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568315,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566766,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566334,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1575348,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1568098,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1567359,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1569327,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1569018,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1799950,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1576473,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1576179,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1570037,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1914241,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1882431,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1847221,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1570824,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1882443,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1575989,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1575509,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573341,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573169,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573133,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573071,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1572881,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 1571420,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 1569019,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2071159,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2063470,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2041552,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2037953,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2014535,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2014533,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2005279,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2001154,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1996059,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1990756,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1982435,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1973057,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1941733,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1929666,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1919838,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1910266,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1891092,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1873142,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1867991,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1857610,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1852628,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1842805,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1840981,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1808723,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1808562,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1799886,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1798174,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1785136,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1778158,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1772259,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1769878,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1769432,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1763022,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1757511,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1755691,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1750138,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1743345,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1741500,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1728948,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1716990,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1713624,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1711134,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1711100,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1707804,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1706245,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1706183,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1705732,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1702946,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1693391,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1693288,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1692768,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1689650,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1687173,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1685491,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1673937,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1673936,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1671400,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Increasing Subsequence",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=\"subsequence-array\"><em><strong>subsequence</strong></em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,3,2,3]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7,7,7,7]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>\n",
        "solutions": [
            {
                "id": 1326308,
                "title": "c-python-dp-binary-search-bit-segment-tree-solutions-picture-explain-o-nlogn",
                "content": "**\\u2714\\uFE0F  Solution 1: Dynamic Programming**\\n- This is a classic Dynamic Programming problem.\\n- Let `dp[i]` is the longest increase subsequence of `nums[0..i]` which has `nums[i]` as the end element of the subsequence.\\n\\n<iframe src=\"https://leetcode.com/playground/48f56qCr/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Greedy with Binary Search**\\n- Let\\'s construct the idea from following example.\\n- Consider the example `nums = [2, 6, 8, 3, 4, 5, 1]`,  let\\'s try to build the increasing subsequences starting with an empty one: `sub1 = []`.\\n\\t1. Let pick the first element, `sub1 = [2]`.\\n\\t2. `6` is greater than previous number, `sub1 = [2, 6]`\\n\\t3. `8` is greater than previous number, `sub1 = [2, 6, 8]`\\n\\t4. `3` is less than previous number, we can\\'t extend the subsequence `sub1`, but we must keep `3` because in the future there may have the longest subsequence start with `[2, 3]`, `sub1 = [2, 6, 8], sub2 = [2, 3]`.\\n\\t5. With `4`,  we can\\'t extend `sub1`, but we can extend `sub2`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4]`.\\n\\t6. With `5`, we can\\'t extend `sub1`, but we can extend `sub2`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5]`.\\n\\t7. With `1`, we can\\'t extend neighter `sub1` nor `sub2`, but we need to keep `1`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1]`.\\n\\t8. Finally, length of longest increase subsequence = `len(sub2)` = 4.\\n- In the above steps, we need to keep different `sub` arrays (`sub1`, `sub2`..., `subk`) which causes poor performance. But we notice that we can just keep one `sub` array, when new number `x` is not greater than the last element of the subsequence `sub`, we do binary search to find the smallest element >= `x` in `sub`, and replace with number `x`.\\n- Let\\'s run that example `nums = [2, 6, 8, 3, 4, 5, 1]` again:\\n\\t1. Let pick the first element, `sub = [2]`.\\n\\t2. `6` is greater than previous number, `sub = [2, 6]`\\n\\t3. `8` is greater than previous number, `sub = [2, 6, 8]`\\n\\t4. `3` is less than previous number, so we can\\'t extend the subsequence `sub`. We need to find the smallest number >= `3` in `sub`, it\\'s `6`. Then we overwrite it, now `sub = [2, 3, 8]`.\\n\\t5. `4` is less than previous number, so we can\\'t extend the subsequence `sub`. We overwrite `8` by `4`, so `sub = [2, 3, 4]`.\\n\\t6. `5` is greater than previous number, `sub = [2, 3, 4, 5]`.\\n\\t7. `1` is less than previous number, so we can\\'t extend the subsequence `sub`. We overwrite `2` by `1`, so `sub = [1, 3, 4, 5]`.\\n\\t8. Finally, length of longest increase subsequence = `len(sub)` = 4.\\n\\n![image](https://assets.leetcode.com/users/images/737a284c-b0f7-4dea-aa0f-068e768e65f5_1625856915.051443.jpeg)\\n\\n<iframe src=\"https://leetcode.com/playground/F9But5fH/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * logN)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`, we can achieve `O(1)` in space by overwriting values of `sub` into original `nums` array.\\n\\n**[BONUS CODE] Get Longest Increasing Subsequence Path**\\n<iframe src=\"https://leetcode.com/playground/enQK8mKD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * logN)`\\n- Space: `O(N)`\\n\\n**REFERENCE**\\n- [Princeton lecture](https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf)\\n\\n---\\n**\\u2714\\uFE0F  Solution 3: Binary Indexed Tree (Increase BASE of `nums` into one-base indexing)**\\n- Let `f[x]` is the length of longest increase subsequence , where all number in the subsequence <= `x`. This is the max element in indices `[1..x]` if we build the **Binary Indexed Tree (BIT)**\\n- Since `-10^4 <= nums[i] <= 10^4`, we can convert nums into `1 <= nums[i] <= 2*10^4+1` by plus `BASE=10001` to store into the BIT.\\n- We build **Max BIT**, which has 2 operators:\\n\\t- `get(idx)`: Return the maximum value of indices in range `[1..idx]`.\\n\\t- `update(idx, val)`: Update a value `val` into BIT at index `idx`.\\n- Iterate numbers `i` in range `[0..n-1]`:\\n\\t- subLongest = bit.get(nums[i] - 1) // Get longest increasing subsequence so far, which `idx < nums[i]`, or `idx <= nums[i] - 1`.\\n\\t- bit.update(nums[i], subLongest + 1) // Update latest longest to the BIT.\\n- The answer is `bit.get(20001)` // Maximum of all elements in the BIT\\n\\n<iframe src=\"https://leetcode.com/playground/KjZLdp97/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * logMAX)`, where `MAX = 20000` is the difference between minimum and maximum elements in `nums`, `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(MAX)`\\n---\\n**\\u2714\\uFE0F  Solution 4: Binary Indexed Tree (Compress `nums` into values in `[1...N]`)**\\n- In solution 3, `-10^4 <= nums[i] <= 10^4` is small enough, so we can store in our **Binary Indexed Tree (BIT)**.\\n- Can we store when `-10^9 <= nums[i] <= 10^9` is very big? In that case, we can **compress** our `nums` array while **keeping the relative comparation order** between numbers.\\n- **How to compress?**\\n\\t- In the `nums` array length `N`, where `N <= 2500`, there are maximum `N` different numbers.\\n\\t- We can get the **unique values** of numbers in `nums`, and sort those values in increasing order, let name it `uniqueSorted`.\\n\\t- Then we traverse `i` in range `[0..n-1]`, we get the compressed value of `nums[i]` by looking the index in `uniqueSorted`.\\n\\t- As the result, elemenents in `nums` is compressed into values in range `[1...N]`.\\n\\n<iframe src=\"https://leetcode.com/playground/XUXi6u3E/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\nComplexity:\\n- Time: `O(N*logN)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F  Solution 5: Segment Tree**\\n- Same solution 4, but instead of using BIT, we can use Segment Tree to retrieve maximum of elements in range [left...right]\\n\\n<iframe src=\"https://leetcode.com/playground/VHCAkEfj/shared\" frameBorder=\"0\" width=\"100%\" height=\"920\"></iframe>\\n\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "**\\u2714\\uFE0F  Solution 1: Dynamic Programming**\\n- This is a classic Dynamic Programming problem.\\n- Let `dp[i]` is the longest increase subsequence of `nums[0..i]` which has `nums[i]` as the end element of the subsequence.\\n\\n<iframe src=\"https://leetcode.com/playground/48f56qCr/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Greedy with Binary Search**\\n- Let\\'s construct the idea from following example.\\n- Consider the example `nums = [2, 6, 8, 3, 4, 5, 1]`,  let\\'s try to build the increasing subsequences starting with an empty one: `sub1 = []`.\\n\\t1. Let pick the first element, `sub1 = [2]`.\\n\\t2. `6` is greater than previous number, `sub1 = [2, 6]`\\n\\t3. `8` is greater than previous number, `sub1 = [2, 6, 8]`\\n\\t4. `3` is less than previous number, we can\\'t extend the subsequence `sub1`, but we must keep `3` because in the future there may have the longest subsequence start with `[2, 3]`, `sub1 = [2, 6, 8], sub2 = [2, 3]`.\\n\\t5. With `4`,  we can\\'t extend `sub1`, but we can extend `sub2`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4]`.\\n\\t6. With `5`, we can\\'t extend `sub1`, but we can extend `sub2`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5]`.\\n\\t7. With `1`, we can\\'t extend neighter `sub1` nor `sub2`, but we need to keep `1`, so `sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1]`.\\n\\t8. Finally, length of longest increase subsequence = `len(sub2)` = 4.\\n- In the above steps, we need to keep different `sub` arrays (`sub1`, `sub2`..., `subk`) which causes poor performance. But we notice that we can just keep one `sub` array, when new number `x` is not greater than the last element of the subsequence `sub`, we do binary search to find the smallest element >= `x` in `sub`, and replace with number `x`.\\n- Let\\'s run that example `nums = [2, 6, 8, 3, 4, 5, 1]` again:\\n\\t1. Let pick the first element, `sub = [2]`.\\n\\t2. `6` is greater than previous number, `sub = [2, 6]`\\n\\t3. `8` is greater than previous number, `sub = [2, 6, 8]`\\n\\t4. `3` is less than previous number, so we can\\'t extend the subsequence `sub`. We need to find the smallest number >= `3` in `sub`, it\\'s `6`. Then we overwrite it, now `sub = [2, 3, 8]`.\\n\\t5. `4` is less than previous number, so we can\\'t extend the subsequence `sub`. We overwrite `8` by `4`, so `sub = [2, 3, 4]`.\\n\\t6. `5` is greater than previous number, `sub = [2, 3, 4, 5]`.\\n\\t7. `1` is less than previous number, so we can\\'t extend the subsequence `sub`. We overwrite `2` by `1`, so `sub = [1, 3, 4, 5]`.\\n\\t8. Finally, length of longest increase subsequence = `len(sub)` = 4.\\n\\n![image](https://assets.leetcode.com/users/images/737a284c-b0f7-4dea-aa0f-068e768e65f5_1625856915.051443.jpeg)\\n\\n<iframe src=\"https://leetcode.com/playground/F9But5fH/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * logN)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`, we can achieve `O(1)` in space by overwriting values of `sub` into original `nums` array.\\n\\n**[BONUS CODE] Get Longest Increasing Subsequence Path**\\n<iframe src=\"https://leetcode.com/playground/enQK8mKD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * logN)`\\n- Space: `O(N)`\\n\\n**REFERENCE**\\n- [Princeton lecture](https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf)\\n\\n---\\n**\\u2714\\uFE0F  Solution 3: Binary Indexed Tree (Increase BASE of `nums` into one-base indexing)**\\n- Let `f[x]` is the length of longest increase subsequence , where all number in the subsequence <= `x`. This is the max element in indices `[1..x]` if we build the **Binary Indexed Tree (BIT)**\\n- Since `-10^4 <= nums[i] <= 10^4`, we can convert nums into `1 <= nums[i] <= 2*10^4+1` by plus `BASE=10001` to store into the BIT.\\n- We build **Max BIT**, which has 2 operators:\\n\\t- `get(idx)`: Return the maximum value of indices in range `[1..idx]`.\\n\\t- `update(idx, val)`: Update a value `val` into BIT at index `idx`.\\n- Iterate numbers `i` in range `[0..n-1]`:\\n\\t- subLongest = bit.get(nums[i] - 1) // Get longest increasing subsequence so far, which `idx < nums[i]`, or `idx <= nums[i] - 1`.\\n\\t- bit.update(nums[i], subLongest + 1) // Update latest longest to the BIT.\\n- The answer is `bit.get(20001)` // Maximum of all elements in the BIT\\n\\n<iframe src=\"https://leetcode.com/playground/KjZLdp97/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * logMAX)`, where `MAX = 20000` is the difference between minimum and maximum elements in `nums`, `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(MAX)`\\n---\\n**\\u2714\\uFE0F  Solution 4: Binary Indexed Tree (Compress `nums` into values in `[1...N]`)**\\n- In solution 3, `-10^4 <= nums[i] <= 10^4` is small enough, so we can store in our **Binary Indexed Tree (BIT)**.\\n- Can we store when `-10^9 <= nums[i] <= 10^9` is very big? In that case, we can **compress** our `nums` array while **keeping the relative comparation order** between numbers.\\n- **How to compress?**\\n\\t- In the `nums` array length `N`, where `N <= 2500`, there are maximum `N` different numbers.\\n\\t- We can get the **unique values** of numbers in `nums`, and sort those values in increasing order, let name it `uniqueSorted`.\\n\\t- Then we traverse `i` in range `[0..n-1]`, we get the compressed value of `nums[i]` by looking the index in `uniqueSorted`.\\n\\t- As the result, elemenents in `nums` is compressed into values in range `[1...N]`.\\n\\n<iframe src=\"https://leetcode.com/playground/XUXi6u3E/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\nComplexity:\\n- Time: `O(N*logN)`, where `N <= 2500` is the number of elements in array `nums`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F  Solution 5: Segment Tree**\\n- Same solution 4, but instead of using BIT, we can use Segment Tree to retrieve maximum of elements in range [left...right]\\n\\n<iframe src=\"https://leetcode.com/playground/VHCAkEfj/shared\" frameBorder=\"0\" width=\"100%\" height=\"920\"></iframe>\\n\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "codeTag": "Java"
            },
            {
                "id": 74824,
                "title": "java-python-binary-search-o-nlogn-time-with-explanation",
                "content": "`tails` is an array storing the smallest tail of all increasing subsequences with length `i+1` in `tails[i]`.\\nFor example, say we have `nums = [4,5,6,3]`, then all the available increasing subsequences are:\\n    \\n    len = 1   :      [4], [5], [6], [3]   => tails[0] = 3\\n    len = 2   :      [4, 5], [5, 6]       => tails[1] = 5\\n    len = 3   :      [4, 5, 6]            => tails[2] = 6\\n\\nWe can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update.\\n\\nEach time we only do one of the two:\\n\\n    (1) if x is larger than all tails, append it, increase the size by 1\\n    (2) if tails[i-1] < x <= tails[i], update tails[i]\\n\\nDoing so will maintain the tails invariant. The the final answer is just the size.\\n\\n**Java**\\n\\n    public int lengthOfLIS(int[] nums) {\\n        int[] tails = new int[nums.length];\\n        int size = 0;\\n        for (int x : nums) {\\n            int i = 0, j = size;\\n            while (i != j) {\\n                int m = (i + j) / 2;\\n                if (tails[m] < x)\\n                    i = m + 1;\\n                else\\n                    j = m;\\n            }\\n            tails[i] = x;\\n            if (i == size) ++size;\\n        }\\n        return size;\\n    }\\n    // Runtime: 2 ms\\n\\n**Python**\\n\\n    def lengthOfLIS(self, nums):\\n        tails = [0] * len(nums)\\n        size = 0\\n        for x in nums:\\n            i, j = 0, size\\n            while i != j:\\n                m = (i + j) / 2\\n                if tails[m] < x:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            tails[i] = x\\n            size = max(i + 1, size)\\n        return size\\n\\n    # Runtime: 48 ms",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "`tails` is an array storing the smallest tail of all increasing subsequences with length `i+1` in `tails[i]`.\\nFor example, say we have `nums = [4,5,6,3]`, then all the available increasing subsequences are:\\n    \\n    len = 1   :      [4], [5], [6], [3]   => tails[0] = 3\\n    len = 2   :      [4, 5], [5, 6]       => tails[1] = 5\\n    len = 3   :      [4, 5, 6]            => tails[2] = 6\\n\\nWe can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update.\\n\\nEach time we only do one of the two:\\n\\n    (1) if x is larger than all tails, append it, increase the size by 1\\n    (2) if tails[i-1] < x <= tails[i], update tails[i]\\n\\nDoing so will maintain the tails invariant. The the final answer is just the size.\\n\\n**Java**\\n\\n    public int lengthOfLIS(int[] nums) {\\n        int[] tails = new int[nums.length];\\n        int size = 0;\\n        for (int x : nums) {\\n            int i = 0, j = size;\\n            while (i != j) {\\n                int m = (i + j) / 2;\\n                if (tails[m] < x)\\n                    i = m + 1;\\n                else\\n                    j = m;\\n            }\\n            tails[i] = x;\\n            if (i == size) ++size;\\n        }\\n        return size;\\n    }\\n    // Runtime: 2 ms\\n\\n**Python**\\n\\n    def lengthOfLIS(self, nums):\\n        tails = [0] * len(nums)\\n        size = 0\\n        for x in nums:\\n            i, j = 0, size\\n            while i != j:\\n                m = (i + j) / 2\\n                if tails[m] < x:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            tails[i] = x\\n            size = max(i + 1, size)\\n        return size\\n\\n    # Runtime: 48 ms",
                "codeTag": "Python3"
            },
            {
                "id": 1326552,
                "title": "optimization-from-brute-force-to-dynamic-programming-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to find maximum increasing subsequence length. In the brute-force approach, we can model this problem as - \\n1. If the current element is greater than the previous element, then we can either pick it or dont pick it because we may get a smaller element somewhere ahead which is greater than previous and picking that would be optimal. So we try both options.\\n2. If the current element is smaller or equal to previous element, it can\\'t be picked.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int i = 0, int prev = INT_MIN) {\\n        if(i == size(nums)) return 0;\\n        return max(lengthOfLIS(nums, i + 1, prev), (nums[i] > prev) + lengthOfLIS(nums, i + 1, max(nums[i], prev)));\\n    }\\n};\\n```\\n\\nA better and more understandable way of writing the same code as above -\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;                                // cant pick any more elements\\n        int take = 0, dontTake = solve(nums, i + 1, prev);           // try skipping the current element\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);   // or pick it if it is greater than previous picked element\\n        return max(take, dontTake);                                  // return whichever choice gives max LIS\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(2<sup>N</sup>)</code>**, where `N` is the size of *`nums`*. At each index, we have choice to either take or not take the element and we explore both ways. So, we `2 * 2 * 2...N times = O(2^N)`\\n***Space Complexity :*** **`O(N)`**, max recursive stack depth.\\n\\n--- \\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nThere are many unnecessary repeated calculations in the brute-force approach. We can observe that the length of increasing subsequence starting at `i`th element with previously picked element `prev` will always be the same. So we can use **dynamic programming** to store the results for this state and reuse again in the future.\\n\\nBut it wouldn\\'t be scalable to store the state as `(i, prev)` because `prev` element can be any number in <code>[-10<sup>4</sup>, 10<sup>4</sup>]</code> meaning we would need to declare a matrix `dp[n][1e8]` which won\\'t be possible <details>\\n\\n<summary>DP with <code>(i, prev)</code> as state</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int, int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums));\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i].count(prev)) return dp[i][prev];\\n        int take = 0, dontTake = solve(nums, i + 1, prev);\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);\\n        return dp[i][prev] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n</details>\\n\\nInstead, we could store the state of `(i, prev_i)`, where `prev_i` denotes the index of previous chosen element. Thus we would use a `dp` matrix where `dp[i][j]` will denote the longest increasing subsequence from index `i` when previous chosen element\\'s index is `j`.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums), vector<int>(1+size(nums), -1));   // dp[i][j] denotes max LIS starting from i when nums[j] is previous picked element\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i][prev_i+1] != -1) return dp[i][prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i]) take = 1 + solve(nums, i + 1, i); // try picking current element if no previous element is chosen or current > nums[prev_i]\\n        return dp[i][prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n\\nDepending on the mood of OJ, it may decide to accept your solution or give TLE for the above solution.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - III (DP - Memoization - Space Optimized)***\\n\\nWe can do better and further reduce the state stored using DP. It\\'s redundant to store states for all `i` having `prev` as its previous element index. The length will always be greatest for the state `(prev, prev)` since no more elements before `prev` can be taken. So we can just use a linear DP where `dp[i]` denotes the LIS starting at index `i`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums)+1, -1);\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[prev_i+1] != -1) return dp[prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i])\\n            take = 1 + solve(nums, i + 1, i);\\n        return dp[prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can solve it iteratively as well. Here, we use `dp` array where `dp[i]` denotes the LIS ending at index `i`. We can always pick a single element and hence all `dp[i]` will be initialized to 1. \\n\\nFor each element `nums[i]`, if there\\'s an smaller element `nums[j]` before it, the result will be maximum of current LIS length ending at `i`: `dp[i]`, and LIS ending at that `j` + 1: `dp[j]` + 1. `+1 ` because we are including the current element and extending the LIS ending at `j`.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 1, n = size(nums);\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) \\n            for(int j = 0; j < i; j++) \\n                if(nums[i] > nums[j]) \\n\\t\\t\\t\\t    dp[i] = max(dp[i], dp[j] + 1), ans = max(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Binary Search)***\\n\\nIn the brute-force approach, we were not sure if an element should be included or not to form the longest increasing subsequence and thus we explored both options. The problem lies in knowing if an element must be included in the sequence formed till now. Let\\'s instead try an approach where we include element whenever possible to maximize the length and if it\\'s not possible, then create a new subsequence and include it.\\n\\nConsider an example - `[1,7,8,4,5,6,-1,9]`:\\n\\n1. Let\\'s pick first element - `1` and form the subseqeunce **`sub1=[1]`**.\\n2. `7` is greater than previous element so extend the sequence by picking it. &nbsp; **`sub1=[1,7]`**. \\n3. Similarly, we pick `8` as well since it\\'s greater than `7`. &nbsp; **`sub1=[1,7,8]`**\\n4. Now we cant extend it further. We can\\'t simply discard previous sequence and start with `4` nor can we discard `7,8` and place `4` instead of them because we don\\'t know if future increasing subsequence will be of more length or not. So we keep both previous subsequence as well as try picking `4` by forming a new subsequence. It\\'s better to form new subsequence and place `4` after `1` to maximize new sequence length. So we have **`sub1=[1,7,8]`** and **`sub2=[1,4]`**\\n5. Can we add `5` in any of the sequence? Yes we can add it to `sub2`. If it wasn\\'t possible we would have tried the same approach as in 4th step and created another subsequence list.  &nbsp; **`sub1=[1,7,8], sub2=[1,4,5]`**\\n6. Similarly, add `6` to only possible list - `cur2`. &nbsp; **`sub1=[1,7,8], sub2=[1,4,5,6]`**\\n7. Now, `-1` cant extend any of the existing subsequence. So we need to form another sequence. Notice we cant copy and use any elements from existing subsequences before `-1` either, since `-1` is lowest. **`sub1=[1,7,8], sub2=[1,4,5,6], sub3=[-1]`**\\n7. Now, `9` can be used to extend all of the list. At last, we get &nbsp; **`sub1=[1,7,8,9], sub2=[1,4,5,6,9], sub3=[-1,9]`**\\n\\nWe finally pick the maximum length of all lists formed till now. This approach works and gets us the correct LIS but it seems like just another **inefficient approach because it\\'s costly to maintain multiple lists and search through all of them when including a new element or making a new list**. Is there a way to speed up this process? Yes. We can just maintain a single list and mark multiple lists inside it. Again, an example will better explain this.\\n\\nConsider the same example as above - `[1,7,8,4,5,6,-1,9]`:\\n\\n1. Pick first element - `1` and form the subseqeunce **`sub=[1]`**.\\n2. `7` is greater than `1` so extend the existing subsequence by picking it. &nbsp; **`sub=[1,7]`**. \\n3. Similarly, we pick `8` as well since it\\'s greater than `7`. &nbsp; **`sub=[1,7,8]`**\\n4. **Now comes the main part**. We can\\'t extend any existing sequence with `4`. So we need to create a new subsequence following 4th step previous approach but this time we will create it inside `sub` itself by replacing smallest element larger than `4` (Similar to 4th step above where we formed a new sequence after picking smaller elements than `4` from existing sequence).\\n\\t```\\n\\t    [1,    4,      8]\\n\\t           ^sub2   ^sub1\\n\\t\\n\\tThis replacement technique works because replaced elements dont matter to us\\n\\tWe only used end elements of existing lists to check if they can be extended otherwise form newer lists\\n\\tAnd since we have replaced a bigger element with smaller one it wont affect the \\n\\tstep of creating new list after taking some part of existing list (see step 4 in above approach)\\n\\t```\\n5. Now, we can\\'t extend with `5` either. We follow the same approach as step 4.\\n\\t```\\n\\t    [1,    4,    5]\\n\\t\\t\\t\\t\\t ^sub2\\n\\t\\t\\n\\tThink of it as extending sub2 in 5th step of above appraoch\\n\\tAlso, we can see sub2 replaced sub1 meaning any subsequence formed with sub2 always\\n\\thas better chance of being LIS than sub1.\\n\\t```\\n6. We get `6` now and we can extend the `sub` list by picking it.\\n\\t```\\n\\t    [1,    4,    5,    6]\\n\\t\\t\\t\\t\\t       ^sub2\\t\\n\\t```\\n\\n7. Cant extend with `-1`. So, Replace -\\n\\t```\\n\\t    [-1,    4,    5,   6]\\n\\t\\t  ^sub3\\t\\t       ^sub2\\t\\n\\t\\n\\tWe have again formed a new list internally by replacing smallest element larger than -1 from exisiting list\\n\\t```\\n8. We get `9`  which is greater than the end of our list and thus can be used to extend the list\\n\\t```\\n\\t    [-1,    4,    5,    6,    9]\\n\\t\\t  ^sub3\\t\\t              ^sub2\\t\\n\\t```\\n\\t<br/>\\n\\tFinally the length of our maintained list will denote the LIS length = `5`. Do note that it wont give the LIS itself but just correct length of it. \\n\\nThe optimization which improves this approach over DP is applying **Binary search** when we can\\'t extend the sequence and need to replace some element from maintained list - `sub`. The list always remains sorted and thus binary search gives us the correct index of element in list which will be replaced by current element under iteration.\\n\\nBasically, we will compare end element of `sub` with element under iteration `cur`. If `cur` is bigger than it, we just extend our list. Otherwise, we will simply apply binary search to find the smallest element >= cur and replace it. Understanding the explanation till now was the hard part...the approach is very easy to code\\uD83D\\uDE42 .\\n\\nI have used the input array itself as my maintained list. Use an auxillary array if you\\'re restricted from modifying the input.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& A) {\\n        int len = 0;\\n        for(auto cur : A) \\n            if(len == 0 || A[len-1] < cur) A[len++] = cur;             // extend\\n            else *lower_bound(begin(A), begin(A) + len, cur) = cur;    // replace\\n        return len;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int i = 0, int prev = INT_MIN) {\\n        if(i == size(nums)) return 0;\\n        return max(lengthOfLIS(nums, i + 1, prev), (nums[i] > prev) + lengthOfLIS(nums, i + 1, max(nums[i], prev)));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;                                // cant pick any more elements\\n        int take = 0, dontTake = solve(nums, i + 1, prev);           // try skipping the current element\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);   // or pick it if it is greater than previous picked element\\n        return max(take, dontTake);                                  // return whichever choice gives max LIS\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int, int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums));\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i].count(prev)) return dp[i][prev];\\n        int take = 0, dontTake = solve(nums, i + 1, prev);\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);\\n        return dp[i][prev] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums), vector<int>(1+size(nums), -1));   // dp[i][j] denotes max LIS starting from i when nums[j] is previous picked element\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i][prev_i+1] != -1) return dp[i][prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i]) take = 1 + solve(nums, i + 1, i); // try picking current element if no previous element is chosen or current > nums[prev_i]\\n        return dp[i][prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums)+1, -1);\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[prev_i+1] != -1) return dp[prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i])\\n            take = 1 + solve(nums, i + 1, i);\\n        return dp[prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 1, n = size(nums);\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) \\n            for(int j = 0; j < i; j++) \\n                if(nums[i] > nums[j]) \\n\\t\\t\\t\\t    dp[i] = max(dp[i], dp[j] + 1), ans = max(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```\n```\\n\\t    [1,    4,      8]\\n\\t           ^sub2   ^sub1\\n\\t\\n\\tThis replacement technique works because replaced elements dont matter to us\\n\\tWe only used end elements of existing lists to check if they can be extended otherwise form newer lists\\n\\tAnd since we have replaced a bigger element with smaller one it wont affect the \\n\\tstep of creating new list after taking some part of existing list (see step 4 in above approach)\\n\\t```\n```\\n\\t    [1,    4,    5]\\n\\t\\t\\t\\t\\t ^sub2\\n\\t\\t\\n\\tThink of it as extending sub2 in 5th step of above appraoch\\n\\tAlso, we can see sub2 replaced sub1 meaning any subsequence formed with sub2 always\\n\\thas better chance of being LIS than sub1.\\n\\t```\n```\\n\\t    [1,    4,    5,    6]\\n\\t\\t\\t\\t\\t       ^sub2\\t\\n\\t```\n```\\n\\t    [-1,    4,    5,   6]\\n\\t\\t  ^sub3\\t\\t       ^sub2\\t\\n\\t\\n\\tWe have again formed a new list internally by replacing smallest element larger than -1 from exisiting list\\n\\t```\n```\\n\\t    [-1,    4,    5,    6,    9]\\n\\t\\t  ^sub3\\t\\t              ^sub2\\t\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& A) {\\n        int len = 0;\\n        for(auto cur : A) \\n            if(len == 0 || A[len-1] < cur) A[len++] = cur;             // extend\\n            else *lower_bound(begin(A), begin(A) + len, cur) = cur;    // replace\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74848,
                "title": "9-lines-c-code-with-o-nlogn-complexity",
                "content": "Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> res;\\n        for(int i=0; i<nums.size(); i++) {\\n            auto it = std::lower_bound(res.begin(), res.end(), nums[i]);\\n            if(it==res.end()) res.push_back(nums[i]);\\n            else *it = nums[i];\\n        }\\n        return res.size();\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> res;\\n        for(int i=0; i<nums.size(); i++) {\\n            auto it = std::lower_bound(res.begin(), res.end(), nums[i]);\\n            if(it==res.end()) res.push_back(nums[i]);\\n            else *it = nums[i];\\n        }\\n        return res.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74825,
                "title": "short-java-solution-using-dp-o-n-log-n",
                "content": "    public class Solution {\\n        public int lengthOfLIS(int[] nums) {            \\n            int[] dp = new int[nums.length];\\n            int len = 0;\\n    \\n            for(int x : nums) {\\n                int i = Arrays.binarySearch(dp, 0, len, x);\\n                if(i < 0) i = -(i + 1);\\n                dp[i] = x;\\n                if(i == len) len++;\\n            }\\n    \\n            return len;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int lengthOfLIS(int[] nums) {            \\n            int[] dp = new int[nums.length];\\n            int len = 0;\\n    \\n            for(int x : nums) {\\n                int i = Arrays.binarySearch(dp, 0, len, x);\\n                if(i < 0) i = -(i + 1);\\n                dp[i] = x;\\n                if(i == len) len++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 152065,
                "title": "python-explain-the-o-nlogn-solution-step-by-step",
                "content": "My base idea  comes from:https://leetcode.com/problems/increasing-triplet-subsequence/description/\\nin that problem, the idea is:\\n1) initial sub = [max, max], we use a list of length 2 to store the subsequence, or smaller value which may form the new subsequence.\\n2) traversing the nums\\uFF1A\\n\\ta) if val <= sub[0], then we update sub[0] = val.\\n\\tb) else if sub[0] < val <= sub[1], the we update sub[1] = val.\\n\\tc) else: sub[1] < val, we find a 3 length subsequence. done!\\n\\t\\nThe key to understanding this solution is if we have found a subsequence of length 2. If the next element is larger than sub[1], then a subsequence of length 3 is found. If the next element is smaller than sub[0] or sub[1], then we find a part of a new subsequence and save it. At the same time, the known subsequence length is 2.\\n\\nHere is the solution\\'s track, say we have nums = [9, 7, 10, 1, 8, 9].\\n```\\ni = 0:    sub = [9, max];\\ni = 1:    sub = [7, max];\\ni = 2:    sub = [7, 10];\\ni = 3:    sub = [1, 10];\\ni = 4:    sub = [1, 8];\\ni = 5:    sub[1] < 9, done.\\n```\\n```\\ndef increasingTriplet(self, nums):\\n        sub = [float(\\'inf\\'), float(\\'inf\\')]\\n        for n in nums:\\n            if n <= sub[0]:\\n                sub[0] = n\\n            elif n <= sub[1]:\\n                sub[1] = n\\n            else:\\n                return True\\n        return False\\n```\\nSo back to this question, the idea extends to:\\n1) initial sub = [ ].\\n2) traversing the nums:\\n    a) if val > sub\\'s all elements, then subsequence length increased by 1, sub.append(val);\\n\\t\\tb) if sub[i-1] < val < sub[i], then we find a smaller value, update sub[i] = val. Some of the elements stored in the sub[ ] are known subsequences, and the other part is elements of other possible new subsequences. However, the length of the known subsequences is unchanged.\\n3) return the sub[ ]\\'s length.\\n\\nHere is the solution\\'s track, as we have nums = [8, 2, 5, 1, 6, 7, 9, 3],when we traversing the nums:\\n```\\ni = 0,    sub = [8]\\ni = 1,    sub = [2]\\ni = 2,    sub = [2, 5]\\ni = 3,    sub = [1, 5],    # element has been changed, but the sub\\'s length has not changed.\\ni = 4,    sub = [1, 5, 6]\\ni = 5,    sub = [1, 5, 6, 7]\\ni = 6,    sub = [1, 5, 6, 7, 9]\\ni = 7,    sub = [1, 3, 6, 7, 9]    #done! Although the elements are not correct, but the length is correct.\\n```\\n```\\n# O(n*m) solution. m is the sub[]\\'s length\\ndef lengthOfLIS(self, nums):\\n        sub = []\\n        for val in nums:\\n            pos , sub_len = 0, len(sub)\\n            while(pos <= sub_len):    # update the element to the correct position of the sub.\\n                if pos == sub_len:\\n                    sub.append(val)\\n                    break\\n                elif val <= sub[pos]:\\n                    sub[pos] = val\\n                    break\\n                else:\\n                    pos += 1\\n        \\n        return len(sub)\\n```\\n\\nBecause of sub[ ] is incremental, we can use a binary search to find the correct insertion position.\\n```\\n# O(nlogn) solution with binary search\\ndef lengthOfLIS(self, nums):\\n\\n        def binarySearch(sub, val):\\n            lo, hi = 0, len(sub)-1\\n            while(lo <= hi):\\n                mid = lo + (hi - lo)//2\\n                if sub[mid] < val:\\n                    lo = mid + 1\\n                elif val < sub[mid]:\\n                    hi = mid - 1\\n                else:\\n                    return mid\\n            return lo\\n        \\n        sub = []\\n        for val in nums:\\n            pos = binarySearch(sub, val)\\n            if pos == len(sub):\\n                sub.append(val)\\n            else:\\n                sub[pos] = val\\n        return len(sub)\\n```",
                "solutionTags": [],
                "code": "```\\ni = 0:    sub = [9, max];\\ni = 1:    sub = [7, max];\\ni = 2:    sub = [7, 10];\\ni = 3:    sub = [1, 10];\\ni = 4:    sub = [1, 8];\\ni = 5:    sub[1] < 9, done.\\n```\n```\\ndef increasingTriplet(self, nums):\\n        sub = [float(\\'inf\\'), float(\\'inf\\')]\\n        for n in nums:\\n            if n <= sub[0]:\\n                sub[0] = n\\n            elif n <= sub[1]:\\n                sub[1] = n\\n            else:\\n                return True\\n        return False\\n```\n```\\ni = 0,    sub = [8]\\ni = 1,    sub = [2]\\ni = 2,    sub = [2, 5]\\ni = 3,    sub = [1, 5],    # element has been changed, but the sub\\'s length has not changed.\\ni = 4,    sub = [1, 5, 6]\\ni = 5,    sub = [1, 5, 6, 7]\\ni = 6,    sub = [1, 5, 6, 7, 9]\\ni = 7,    sub = [1, 3, 6, 7, 9]    #done! Although the elements are not correct, but the length is correct.\\n```\n```\\n# O(n*m) solution. m is the sub[]\\'s length\\ndef lengthOfLIS(self, nums):\\n        sub = []\\n        for val in nums:\\n            pos , sub_len = 0, len(sub)\\n            while(pos <= sub_len):    # update the element to the correct position of the sub.\\n                if pos == sub_len:\\n                    sub.append(val)\\n                    break\\n                elif val <= sub[pos]:\\n                    sub[pos] = val\\n                    break\\n                else:\\n                    pos += 1\\n        \\n        return len(sub)\\n```\n```\\n# O(nlogn) solution with binary search\\ndef lengthOfLIS(self, nums):\\n\\n        def binarySearch(sub, val):\\n            lo, hi = 0, len(sub)-1\\n            while(lo <= hi):\\n                mid = lo + (hi - lo)//2\\n                if sub[mid] < val:\\n                    lo = mid + 1\\n                elif val < sub[mid]:\\n                    hi = mid - 1\\n                else:\\n                    return mid\\n            return lo\\n        \\n        sub = []\\n        for val in nums:\\n            pos = binarySearch(sub, val)\\n            if pos == len(sub):\\n                sub.append(val)\\n            else:\\n                sub[pos] = val\\n        return len(sub)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 74836,
                "title": "my-easy-to-understand-o-n-2-solution-using-dp-with-video-explanation",
                "content": "This solution is taken from this great guy - \\nhttps://www.youtube.com/watch?v=CE2b_-XfVDk   \\n\\n        public int lengthOfLIS(int[] nums) \\n    \\t{\\n    \\t\\t// Base case\\n    \\t\\tif(nums.length <= 1) \\n    \\t\\t\\treturn nums.length;\\n    \\n    \\t\\t// This will be our array to track longest sequence length\\n    \\t\\tint T[] = new int[nums.length];\\n    \\n    \\t\\t// Fill each position with value 1 in the array\\n    \\t\\tfor(int i=0; i < nums.length; i++)\\n    \\t\\t\\tT[i] = 1;\\n    \\n    \\n    \\t\\t// Mark one pointer at i. For each i, start from j=0.\\n    \\t\\tfor(int i=1; i < nums.length; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor(int j=0; j < i; j++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// It means next number contributes to increasing sequence.\\n    \\t\\t\\t\\tif(nums[j] < nums[i])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t// But increase the value only if it results in a larger value of the sequence than T[i]\\n    \\t\\t\\t\\t\\t// It is possible that T[i] already has larger value from some previous j'th iteration\\n    \\t\\t\\t\\t\\tif(T[j] + 1 > T[i])\\n    \\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\tT[i] = T[j] + 1;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t// Find the maximum length from the array that we just generated \\n    \\t\\tint longest = 0;\\n    \\t\\tfor(int i=0; i < T.length; i++)\\n    \\t\\t\\tlongest = Math.max(longest, T[i]);\\n    \\n    \\t\\treturn longest;\\n    \\t}",
                "solutionTags": [],
                "code": "This solution is taken from this great guy - \\nhttps://www.youtube.com/watch?v=CE2b_-XfVDk   \\n\\n        public int lengthOfLIS(int[] nums) \\n    \\t{\\n    \\t\\t// Base case\\n    \\t\\tif(nums.length <= 1) \\n    \\t\\t\\treturn nums.length;\\n    \\n    \\t\\t// This will be our array to track longest sequence length\\n    \\t\\tint T[] = new int[nums.length];\\n    \\n    \\t\\t// Fill each position with value 1 in the array\\n    \\t\\tfor(int i=0; i < nums.length; i++)\\n    \\t\\t\\tT[i] = 1;\\n    \\n    \\n    \\t\\t// Mark one pointer at i. For each i, start from j=0.\\n    \\t\\tfor(int i=1; i < nums.length; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor(int j=0; j < i; j++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// It means next number contributes to increasing sequence.\\n    \\t\\t\\t\\tif(nums[j] < nums[i])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t// But increase the value only if it results in a larger value of the sequence than T[i]\\n    \\t\\t\\t\\t\\t// It is possible that T[i] already has larger value from some previous j'th iteration\\n    \\t\\t\\t\\t\\tif(T[j] + 1 > T[i])\\n    \\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\tT[i] = T[j] + 1;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t// Find the maximum length from the array that we just generated \\n    \\t\\tint longest = 0;\\n    \\t\\tfor(int i=0; i < T.length; i++)\\n    \\t\\t\\tlongest = Math.max(longest, T[i]);\\n    \\n    \\t\\treturn longest;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 74880,
                "title": "java-easy-version-to-understand",
                "content": "    public static int findPositionToReplace(int[] a, int low, int high, int x) {\\n\\t\\tint mid;\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (a[mid] == x)\\n\\t\\t\\t\\treturn mid;\\n\\t\\t\\telse if (a[mid] > x)\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}\\n\\n\\tpublic static int lengthOfLIS(int[] nums) {\\n\\t\\tif (nums == null | nums.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint n = nums.length, len = 0;\\n\\t\\tint[] increasingSequence = new int[n];\\n\\t\\tincreasingSequence[len++] = nums[0];\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (nums[i] > increasingSequence[len - 1])\\n\\t\\t\\t\\tincreasingSequence[len++] = nums[i];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint position = findPositionToReplace(increasingSequence, 0, len - 1, nums[i]);\\n\\t\\t\\t\\tincreasingSequence[position] = nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len;\\n\\t}",
                "solutionTags": [],
                "code": "    public static int findPositionToReplace(int[] a, int low, int high, int x) {\\n\\t\\tint mid;\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (a[mid] == x)\\n\\t\\t\\t\\treturn mid;\\n\\t\\t\\telse if (a[mid] > x)\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}\\n\\n\\tpublic static int lengthOfLIS(int[] nums) {\\n\\t\\tif (nums == null | nums.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint n = nums.length, len = 0;\\n\\t\\tint[] increasingSequence = new int[n];\\n\\t\\tincreasingSequence[len++] = nums[0];\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (nums[i] > increasingSequence[len - 1])\\n\\t\\t\\t\\tincreasingSequence[len++] = nums[i];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint position = findPositionToReplace(increasingSequence, 0, len - 1, nums[i]);\\n\\t\\t\\t\\tincreasingSequence[position] = nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 300914,
                "title": "python-dp-easy",
                "content": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        n = len(nums)\\n        dp = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n                    \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        n = len(nums)\\n        dp = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n                    \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667975,
                "title": "python-3-lines-dp-with-binary-search-explained",
                "content": "Let us keep in table `dp[i]` the minumum value so far, which is the end of increasing sequence of length `i + 1`. It can be not easy to digest, so let us go through example `nums = [100, 9, 2, 9, 3, 7, 101, 6]`.\\n1. `dp = [100]`, because `dp` was empty, and there is nothig we can compare with.\\n2. `dp = [9]` now, why? Because so far we found ony increasing subsequences with length 1 and we update `dp[0]`.\\n3. `dp = [2]` for the same reason.\\n4. `dp = [2, 9]`, because new element is **greater** than the last element in our table, it means we can create increasing sequence of length 2.\\n5. `dp = [2, 3]`, because new element is 3, and we are looking for the smallest index in our table, such that value is more than `3`, so we update `9` to `3`: we found increasing subsequence of size 2, which ends with 3 < 9.\\n6. `dp = [2, 3, 7]`, because new element is more than the last element.\\n7. `dp = [2, 3, 7, 101]`, the same reason.\\n8. `dp = [2, 3, 6, 101]`, because for new element 6 we looking for the smallest index in our table, such that value is more than `6`, so we change element with value 7 to value 6.\\n\\nFinally, answer is equal to 4, the length of `dp`. (note, that `2, 3, 6, 101` **is not** increasing subsequence, this values mean, that `2` is the minimum value for increasing subsequence of lentgh 1, `3` is the minumum value for increasing subsequence of length 2 and so on)\\n\\n**Complexity** is `O(n log n)`, because for each new element we need to do binary search in `O(log n)`, and we do `n` steps.\\n\\n\\n**Code.** Here is staightforward code, which does exactly what I explained before.\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        dp = []\\n        for elem in nums:\\n            ind = bisect_left(dp, elem)\\n            if ind == len(dp):\\n                dp.append(elem)\\n            else:\\n                dp[ind] = elem\\n        return len(dp)\\n```\\n\\n**3 lines code**: we can prefill our `dp` table with big numbers, in this way, we can directly update index and not being afraid to out-of-bounds indexes\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect_left(dp, elem)] = elem  \\n        return dp.index(10**10)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        dp = []\\n        for elem in nums:\\n            ind = bisect_left(dp, elem)\\n            if ind == len(dp):\\n                dp.append(elem)\\n            else:\\n                dp[ind] = elem\\n        return len(dp)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect_left(dp, elem)] = elem  \\n        return dp.index(10**10)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74855,
                "title": "short-c-stl-based-solution-o-n-log-n-time-o-1-space-with-explanation",
                "content": "This solution can be viewed as d.p., but I find it easier not to think of it that way.\\n\\n**Runtime**: To get an O(n log n ) runtime, I'm going to create a second list S.  (Stick with me for now -- I'll get rid of it in a minute to get O(1) space.)  I'll do a single pass through **nums**, and as I look at each element:\\n\\n* The length of S will be equal to the length of the longest subsequence I've found to that point.\\n* The last element of S will be the last element of that subsequence.  (However, the earlier elements may no longer be part of that sequence -- S is not actually the subsequence itself.)\\n\\nAt the end, the *length* of S will be our solution.\\n\\nS will be sorted at all times.  Each new element is inserted into S, replacing the smallest element in S that is not smaller than it (which we can find with a binary search). If that element is larger than the last element of S, then we extend S by one -- maintaining both properties.\\n\\nFor example, if \\n\\n    nums = [5,6,7,1,2,8,3,4,0,5,9]\\n\\nthen after we prcoess the 7:\\n \\n    S = [5,6,7]\\n\\nafter w process the 2:\\n \\n    S = [1,2,7]\\n\\nafter we process the 8:\\n\\n    S = [1,2,7,8]\\n\\nThen we process the 3:\\n\\n    S = [1,2,3,8]\\n\\nWe process the 4:\\n\\n    S = [1,2,3,4]\\n\\nand now the next three elements:\\n\\n    S = [0,2,3,4,5,9]\\n\\nS is not the actual subsequence, but it is the right length (end ends in the right number).\\n\\nWe are making 1 pass on **n** elements, and doing a binary search each time.  So **O(n log n)** time.\\n\\n**Space**: Assuming we are allowed to destroy the list, we don't need S.  Since S will never be larger then the number of elements we have looked at, and we only need to look at each element once, we can just use the beginning of **nums** for S (keeping track of the size of \"S\" in a separate variable).\\n\\nMaking using of the STL lower_bound function (find the smallest element in a sorted list that is not smaller than the target):\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return nums.size();\\n\\n        vector<int>::iterator m = nums.begin();  // m will mark the virtual \"S.end()\".\\n        for (int& val : nums) {\\n            auto it = lower_bound(nums.begin(), m, val);\\n            *it = val;\\n            if (it == m)\\n                m++;\\n        }\\n        \\n        return m - nums.begin();\\n    }",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "This solution can be viewed as d.p., but I find it easier not to think of it that way.\\n\\n**Runtime**: To get an O(n log n ) runtime, I'm going to create a second list S.  (Stick with me for now -- I'll get rid of it in a minute to get O(1) space.)  I'll do a single pass through **nums**, and as I look at each element:\\n\\n* The length of S will be equal to the length of the longest subsequence I've found to that point.\\n* The last element of S will be the last element of that subsequence.  (However, the earlier elements may no longer be part of that sequence -- S is not actually the subsequence itself.)\\n\\nAt the end, the *length* of S will be our solution.\\n\\nS will be sorted at all times.  Each new element is inserted into S, replacing the smallest element in S that is not smaller than it (which we can find with a binary search). If that element is larger than the last element of S, then we extend S by one -- maintaining both properties.\\n\\nFor example, if \\n\\n    nums = [5,6,7,1,2,8,3,4,0,5,9]\\n\\nthen after we prcoess the 7:\\n \\n    S = [5,6,7]\\n\\nafter w process the 2:\\n \\n    S = [1,2,7]\\n\\nafter we process the 8:\\n\\n    S = [1,2,7,8]\\n\\nThen we process the 3:\\n\\n    S = [1,2,3,8]\\n\\nWe process the 4:\\n\\n    S = [1,2,3,4]\\n\\nand now the next three elements:\\n\\n    S = [0,2,3,4,5,9]\\n\\nS is not the actual subsequence, but it is the right length (end ends in the right number).\\n\\nWe are making 1 pass on **n** elements, and doing a binary search each time.  So **O(n log n)** time.\\n\\n**Space**: Assuming we are allowed to destroy the list, we don't need S.  Since S will never be larger then the number of elements we have looked at, and we only need to look at each element once, we can just use the beginning of **nums** for S (keeping track of the size of \"S\" in a separate variable).\\n\\nMaking using of the STL lower_bound function (find the smallest element in a sorted list that is not smaller than the target):\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return nums.size();\\n\\n        vector<int>::iterator m = nums.begin();  // m will mark the virtual \"S.end()\".\\n        for (int& val : nums) {\\n            auto it = lower_bound(nums.begin(), m, val);\\n            *it = val;\\n            if (it == m)\\n                m++;\\n        }\\n        \\n        return m - nums.begin();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74897,
                "title": "fast-java-binary-search-solution-with-detailed-explanation",
                "content": "This solution uses Binary Search + DP\\n\\n    1, traverse from 0 to len-1, the DP array keep the longest sequence.\\n    2, if the val is bigger than largest in the dp array, add it to the end;\\n    3, if it is among the sequence, return the pos that bigger than pres, update the array with this position if val is smaller than dp[pos];\\n    This is to keep the sequence element with the smallest number.\\n\\nFor example:\\n\\n    10, 9, 2, 5, 3, 7, 101, 18\\n    \\n    10 \\n    9\\n    2\\n    2,5\\n    2,3\\n    2,3,7\\n    2,3,7,101\\n    2,3,7,18\\nThe follow is the solution:\\n\\n    public class Solution {\\n        public int lengthOfLIS(int[] nums) {\\n            if (nums == null || nums.length == 0) {\\n                return 0;\\n            }\\n            int[] dp = new int[nums.length];\\n            dp[0] = nums[0];\\n            int len = 0;\\n            for (int i = 1; i < nums.length; i++) {\\n                int pos = binarySearch(dp,len,nums[i]);\\n                if (nums[i] < dp[pos]) dp[pos] = nums[i];\\n                if (pos > len) {\\n                    len = pos;\\n                    dp[len] = nums[i];\\n                }\\n            }\\n            return len+1;\\n        }\\n        private int binarySearch(int[] dp, int len, int val) {\\n            int left = 0;\\n            int right = len;\\n            while(left+1 < right) {\\n                int mid = left + (right-left)/2;\\n                if (dp[mid] == val) {\\n                    return mid;\\n                } else {\\n                    if (dp[mid] < val) {\\n                        left = mid;\\n                    } else {\\n                        right = mid;\\n                    }\\n                }\\n            }\\n            if (dp[right] < val) return len+1;\\n            else if (dp[left] >= val) return left;\\n            else return right;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int lengthOfLIS(int[] nums) {\\n            if (nums == null || nums.length == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 429079,
                "title": "python-5-approaches-recursion-recur-memo-dp-dp-binary-search-print-all-lis",
                "content": "**1. Recursion (TLE)**\\n\\nWe found this relationship:  `the longest LIS in [i - 1, N]` = `the longest LIS in[i, N]` + `1`\\n```\\n// We start out with i == 0,\\nthe longest LIS in [0, N] = 1 + the longest LIS in [1, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [2, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [3, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [i, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [N, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 0\\n```\\n\\n**2. Algo:**\\n*  If `nums[i]` is greater than the last value of the LIS in `[0, i - 1]` \\n\\t*  add `nums[i]` to the previous LIS in `[0, i - 1]` and calculate the maximum length of LIS in `[i, N]` \\n\\t*  do not add `nums[i]` to the previous LIS  in `[0, i - 1]` and calculate the maximum length of LIS in `[i, N]`  \\n\\t* Compare the maximum length in both cases. The larger one is the length of the longest LIS in `[i, N]` . \\n*   Otherwise:\\n\\t*  do not add`nums[i]` to the previous LIS  in `[0, i - 1]` and calculate the length of the longest LIS up in `[i, N]`  \\n\\t\\n**3. Why we need to compare \\'add\\' and \\'notAdd\\'?**\\nWhy we still need to consider not adding the current value even if it is greater than the last value in the longest LIS from[0, i - 1]? \\n\\nFor example, \\n\\n* If all the following numbers of nums[i] are larger than it, such as `\\'1, 2, 3 \\', \\'4\\', \\'5, 6, 7\\'.` Say if nums[I] is 4, the longest LIS we can obtain in the end in is 7 --> we should add `4` to obtain the longest LIS\\n* but if all of its subsequent Numbers are smaller than it and larger than the last number in his previous LIS in `[0, i - 1]`, such as`\\' 1, 2, 3 \\' \\'7\\' 4, 5, 6 \\'. ` Say nums[i] is 7, if we add it, then the maximum LIS that we can have in the end in is only 4 --> we shouldn\\'t add `7` even if it is greater than `3`\\n\\nTherefore, whether num[I] should be added depends not only on the last val of the longest LIS in front of it, but also on the relative value of all numbers after it.  So we need to taking the second factor into account by finding the final result (recursing to the end).\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\tN = len(nums)\\n        def helper(last, i):\\n            if i == N: return 0\\n            add, notAdd = 0, 0\\n            if nums[i] > last:\\n                add = 1 + helper(nums[i], i + 1)\\n            notAdd = helper(last, i + 1)\\n            return max(add, notAdd)\\n        \\n        return helper(float(\\'-inf\\'), 0)\\n```\\n\\n* Time: O(2^N)\\n*  Space: O(N)        \\n            \\n-------------\\n**2. Recursion with Memoization (TLE)**\\n\\n**2.1 Use a 2D memo**\\n* Due to recursion we start to fill 2D array memo[j][i] from the end (i = N, j = N - 1) to the beginning (i = 0, j = -1). (From lower right to upper left)\\n* Finished Status: we reached the memo[0][0] (previndex + 1 is 0 and curpos is 0 --- values the both variables had at the begining, when you enter the method \"lengthofLIS\" ).\\n\\n\\t* The N-th row of the data array represents the longest sequences starting with the last element of the input array (Length of LIS == 1). \\n\\t* N-1 th row represents LIS starting with the one element before last of the original array\\n\\t* ....\\n\\t* The first row represents the LIS of the original array starting from the first element (our final answer)\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def helper(prev_i, i):\\n            if i == len(nums): return 0\\n            if memo[prev_i + 1][i] >= 0:\\n                return memo[prev_i + 1][i]\\n            add, notAdd = 0, 0\\n            if prev_i < 0 or nums[i] > nums[prev_i]:\\n                add = 1 + helper(i, i + 1)\\n            notAdd = helper(prev_i, i + 1)\\n            memo[prev_i + 1][i] = max(add, notAdd)\\n            return memo[prev_i + 1][i]\\n\\t\\t\\t\\n        N = len(nums)\\n        memo = [[-1 for _ in range(N)] for _ in range(N)]        \\n        return helper(-1, 0)\\n```\\n\\n**2.2 Use 1D memo** \\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def helper(prev_i, i):\\n            if i == len(nums): return 0\\n            if memo[prev_i + 1] >= 0:\\n                return memo[prev_i + 1]\\n            add, notAdd = 0, 0\\n            if prev_i < 0 or nums[i] > nums[prev_i]:\\n                add = 1 + helper(i, i + 1)\\n            notAdd = helper(prev_i, i + 1)\\n            memo[prev_i + 1] = max(add, notAdd)\\n            return memo[prev_i + 1]\\n\\t\\t\\t\\n        N = len(nums)\\n        memo = [-1 for _ in range(N)]       \\n        return helper(-1, 0)\\n```\\n\\n--------\\n**3. Naive DP**\\n* * Time: O(N^2), Space: O(N)\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n\\t\\tN = len(nums)\\n        dp = [1] * N\\n        \\n        for i in range(N):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n      \\n        return max(dp)\\n```\\n\\n------------------\\n**4. DP + Binary Search**\\n\\n* Time: O(NlogN), Space: O(N)\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        tails = [0] * len(nums)\\n        size = 0\\n        for num in nums:\\n            l, r = 0, size\\n            while l != r:\\n                m = l + (r - l) // 2\\n                if tails[m] < num:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            tails[l] = num\\n            size = max(size, l + 1)\\n        return size\\n        \\n```\\n\\n**5. Print the longest LIS (instead of just returning its length)**\\n\\nThe following function returns all longest LIS up untill index i, where i is in [0, len(nums) - 1].\\n\\n```\\ninput: [10,9,2,5,3,7,101,18]\\noutput: {\\n\\t0: [[10]], \\n\\t1: [[9]], \\n\\t2: [[2]], \\n\\t3: [[2, 5]], \\n\\t4: [[2, 3]], \\n\\t5: [[2, 5, 7], [2, 3, 7]], \\n\\t6: [[2, 5, 7, 101], [2, 3, 7, 101]], \\n\\t7: [[2, 5, 7, 18], [2, 3, 7, 18]]\\n}\\n\\nlength of the longest LIS: 4\\n```\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = [1] * len(nums)\\n        # L[i]: all LIS (not necessarily the longest) up untill index i (included)\\n        L = collections.defaultdict(list)\\n        L[0].append([nums[0]])\\n        \\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if num > nums[j]:\\n                    for lst in L[j]:\\n                        L[i].append(lst + [nums[i]])\\n                elif num <= nums[j] and [nums[i]] not in L[i]:\\n                    L[i].append([nums[i]])\\n        \\n        # res[i]: all longest LIS up untill index i (included)\\n        res = collections.defaultdict(list)\\n        for i, lists in L.items():\\n            maxLen = 0\\n            for lst in lists:\\n                maxLen = max(maxLen, len(lst))\\n            for lst in lists:\\n                if len(lst) == maxLen:\\n                    res[i].append(lst)\\n                \\n        print(res)\\n```",
                "solutionTags": [],
                "code": "```\\n// We start out with i == 0,\\nthe longest LIS in [0, N] = 1 + the longest LIS in [1, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [2, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [3, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [i, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 1 + the longest LIS in [N, N]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 0\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\tN = len(nums)\\n        def helper(last, i):\\n            if i == N: return 0\\n            add, notAdd = 0, 0\\n            if nums[i] > last:\\n                add = 1 + helper(nums[i], i + 1)\\n            notAdd = helper(last, i + 1)\\n            return max(add, notAdd)\\n        \\n        return helper(float(\\'-inf\\'), 0)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def helper(prev_i, i):\\n            if i == len(nums): return 0\\n            if memo[prev_i + 1][i] >= 0:\\n                return memo[prev_i + 1][i]\\n            add, notAdd = 0, 0\\n            if prev_i < 0 or nums[i] > nums[prev_i]:\\n                add = 1 + helper(i, i + 1)\\n            notAdd = helper(prev_i, i + 1)\\n            memo[prev_i + 1][i] = max(add, notAdd)\\n            return memo[prev_i + 1][i]\\n\\t\\t\\t\\n        N = len(nums)\\n        memo = [[-1 for _ in range(N)] for _ in range(N)]        \\n        return helper(-1, 0)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def helper(prev_i, i):\\n            if i == len(nums): return 0\\n            if memo[prev_i + 1] >= 0:\\n                return memo[prev_i + 1]\\n            add, notAdd = 0, 0\\n            if prev_i < 0 or nums[i] > nums[prev_i]:\\n                add = 1 + helper(i, i + 1)\\n            notAdd = helper(prev_i, i + 1)\\n            memo[prev_i + 1] = max(add, notAdd)\\n            return memo[prev_i + 1]\\n\\t\\t\\t\\n        N = len(nums)\\n        memo = [-1 for _ in range(N)]       \\n        return helper(-1, 0)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n\\t\\tN = len(nums)\\n        dp = [1] * N\\n        \\n        for i in range(N):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n      \\n        return max(dp)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        tails = [0] * len(nums)\\n        size = 0\\n        for num in nums:\\n            l, r = 0, size\\n            while l != r:\\n                m = l + (r - l) // 2\\n                if tails[m] < num:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            tails[l] = num\\n            size = max(size, l + 1)\\n        return size\\n        \\n```\n```\\ninput: [10,9,2,5,3,7,101,18]\\noutput: {\\n\\t0: [[10]], \\n\\t1: [[9]], \\n\\t2: [[2]], \\n\\t3: [[2, 5]], \\n\\t4: [[2, 3]], \\n\\t5: [[2, 5, 7], [2, 3, 7]], \\n\\t6: [[2, 5, 7, 101], [2, 3, 7, 101]], \\n\\t7: [[2, 5, 7, 18], [2, 3, 7, 18]]\\n}\\n\\nlength of the longest LIS: 4\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = [1] * len(nums)\\n        # L[i]: all LIS (not necessarily the longest) up untill index i (included)\\n        L = collections.defaultdict(list)\\n        L[0].append([nums[0]])\\n        \\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if num > nums[j]:\\n                    for lst in L[j]:\\n                        L[i].append(lst + [nums[i]])\\n                elif num <= nums[j] and [nums[i]] not in L[i]:\\n                    L[i].append([nums[i]])\\n        \\n        # res[i]: all longest LIS up untill index i (included)\\n        res = collections.defaultdict(list)\\n        for i, lists in L.items():\\n            maxLen = 0\\n            for lst in lists:\\n                maxLen = max(maxLen, len(lst))\\n            for lst in lists:\\n                if len(lst) == maxLen:\\n                    res[i].append(lst)\\n                \\n        print(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326554,
                "title": "longest-increasing-subsequence-optimization-from-brute-force-to-dp-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to find maximum increasing subsequence length. In the brute-force approach, we can model this problem as - \\n1. If the current element is greater than the previous element, then we can either pick it or dont pick it because we may get a smaller element somewhere ahead which is greater than previous and picking that would be optimal. So we try both options.\\n2. If the current element is smaller or equal to previous element, it can\\'t be picked.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int i = 0, int prev = INT_MIN) {\\n        if(i == size(nums)) return 0;\\n        return max(lengthOfLIS(nums, i + 1, prev), (nums[i] > prev) + lengthOfLIS(nums, i + 1, max(nums[i], prev)));\\n    }\\n};\\n```\\n\\nA better and more understandable way of writing the same code as above -\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;                                // cant pick any more elements\\n        int take = 0, dontTake = solve(nums, i + 1, prev);           // try skipping the current element\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);   // or pick it if it is greater than previous picked element\\n        return max(take, dontTake);                                  // return whichever choice gives max LIS\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(2<sup>N</sup>)</code>**, where `N` is the size of *`nums`*. At each index, we have choice to either take or not take the element and we explore both ways. So, we `2 * 2 * 2...N times = O(2^N)`\\n***Space Complexity :*** **`O(N)`**, max recursive stack depth.\\n\\n--- \\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nThere are many unnecessary repeated calculations in the brute-force approach. We can observe that the length of increasing subsequence starting at `i`th element with previously picked element `prev` will always be the same. So we can use **dynamic programming** to store the results for this state and reuse again in the future.\\n\\nBut it wouldn\\'t be scalable to store the state as `(i, prev)` because `prev` element can be any number in <code>[-10<sup>4</sup>, 10<sup>4</sup>]</code> meaning we would need to declare a matrix `dp[n][1e8]` which won\\'t be possible <details>\\n\\n<summary>DP with <code>(i, prev)</code> as state</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int, int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums));\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i].count(prev)) return dp[i][prev];\\n        int take = 0, dontTake = solve(nums, i + 1, prev);\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);\\n        return dp[i][prev] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n</details>\\n\\nInstead, we could store the state of `(i, prev_i)`, where `prev_i` denotes the index of previous chosen element. Thus we would use a `dp` matrix where `dp[i][j]` will denote the longest increasing subsequence from index `i` when previous chosen element\\'s index is `j`.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums), vector<int>(1+size(nums), -1));   // dp[i][j] denotes max LIS starting from i when nums[j] is previous picked element\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i][prev_i+1] != -1) return dp[i][prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i]) take = 1 + solve(nums, i + 1, i); // try picking current element if no previous element is chosen or current > nums[prev_i]\\n        return dp[i][prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n\\nDepending on the mood of OJ, it may decide to accept your solution or give TLE for the above solution.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - III (DP - Memoization - Space Optimized)***\\n\\nWe can do better and further reduce the state stored using DP. It\\'s redundant to store states for all `i` having `prev` as its previous element index. The length will always be greatest for the state `(prev, prev)` since no more elements before `prev` can be taken. So we can just use a linear DP where `dp[i]` denotes the LIS starting at index `i`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums)+1, -1);\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[prev_i+1] != -1) return dp[prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i])\\n            take = 1 + solve(nums, i + 1, i);\\n        return dp[prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can solve it iteratively as well. Here, we use `dp` array where `dp[i]` denotes the LIS ending at index `i`. We can always pick a single element and hence all `dp[i]` will be initialized to 1. \\n\\nFor each element `nums[i]`, if there\\'s an smaller element `nums[j]` before it, the result will be maximum of current LIS length ending at `i`: `dp[i]`, and LIS ending at that `j` + 1: `dp[j]` + 1. `+1 ` because we are including the current element and extending the LIS ending at `j`.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 1, n = size(nums);\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) \\n            for(int j = 0; j < i; j++) \\n                if(nums[i] > nums[j]) \\n\\t\\t\\t\\t    dp[i] = max(dp[i], dp[j] + 1), ans = max(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**\\n***Space Complexity :*** **<code>O(N)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Binary Search)***\\n\\nIn the brute-force approach, we were not sure if an element should be included or not to form the longest increasing subsequence and thus we explored both options. The problem lies in knowing if an element must be included in the sequence formed till now. Let\\'s instead try an approach where we include element whenever possible to maximize the length and if it\\'s not possible, then create a new subsequence and include it.\\n\\nConsider an example - `[1,7,8,4,5,6,-1,9]`:\\n\\n1. Let\\'s pick first element - `1` and form the subseqeunce **`sub1=[1]`**.\\n2. `7` is greater than previous element so extend the sequence by picking it. &nbsp; **`sub1=[1,7]`**. \\n3. Similarly, we pick `8` as well since it\\'s greater than `7`. &nbsp; **`sub1=[1,7,8]`**\\n4. Now we cant extend it further. We can\\'t simply discard previous sequence and start with `4` nor can we discard `7,8` and place `4` instead of them because we don\\'t know if future increasing subsequence will be of more length or not. So we keep both previous subsequence as well as try picking `4` by forming a new subsequence. It\\'s better to form new subsequence and place `4` after `1` to maximize new sequence length. So we have **`sub1=[1,7,8]`** and **`sub2=[1,4]`**\\n5. Can we add `5` in any of the sequence? Yes we can add it to `sub2`. If it wasn\\'t possible we would have tried the same approach as in 4th step and created another subsequence list.  &nbsp; **`sub1=[1,7,8], sub2=[1,4,5]`**\\n6. Similarly, add `6` to only possible list - `cur2`. &nbsp; **`sub1=[1,7,8], sub2=[1,4,5,6]`**\\n7. Now, `-1` cant extend any of the existing subsequence. So we need to form another sequence. Notice we cant copy and use any elements from existing subsequences before `-1` either, since `-1` is lowest. **`sub1=[1,7,8], sub2=[1,4,5,6], sub3=[-1]`**\\n7. Now, `9` can be used to extend all of the list. At last, we get &nbsp; **`sub1=[1,7,8,9], sub2=[1,4,5,6,9], sub3=[-1,9]`**\\n\\nWe finally pick the maximum length of all lists formed till now. This approach works and gets us the correct LIS but it seems like just another **inefficient approach because it\\'s costly to maintain multiple lists and search through all of them when including a new element or making a new list**. Is there a way to speed up this process? Yes. We can just maintain a single list and mark multiple lists inside it. Again, an example will better explain this.\\n\\nConsider the same example as above - `[1,7,8,4,5,6,-1,9]`:\\n\\n1. Pick first element - `1` and form the subseqeunce **`sub=[1]`**.\\n2. `7` is greater than `1` so extend the existing subsequence by picking it. &nbsp; **`sub=[1,7]`**. \\n3. Similarly, we pick `8` as well since it\\'s greater than `7`. &nbsp; **`sub=[1,7,8]`**\\n4. **Now comes the main part**. We can\\'t extend any existing sequence with `4`. So we need to create a new subsequence following 4th step previous approach but this time we will create it inside `sub` itself by replacing smallest element larger than `4` (Similar to 4th step above where we formed a new sequence after picking smaller elements than `4` from existing sequence).\\n\\t```\\n\\t    [1,    4,      8]\\n\\t           ^sub2   ^sub1\\n\\t\\n\\tThis replacement technique works because replaced elements dont matter to us\\n\\tWe only used end elements of existing lists to check if they can be extended otherwise form newer lists\\n\\tAnd since we have replaced a bigger element with smaller one it wont affect the \\n\\tstep of creating new list after taking some part of existing list (see step 4 in above approach)\\n\\t```\\n5. Now, we can\\'t extend with `5` either. We follow the same approach as step 4.\\n\\t```\\n\\t    [1,    4,    5]\\n\\t\\t\\t\\t\\t ^sub2\\n\\t\\t\\n\\tThink of it as extending sub2 in 5th step of above appraoch\\n\\tAlso, we can see sub2 replaced sub1 meaning any subsequence formed with sub2 always\\n\\thas better chance of being LIS than sub1.\\n\\t```\\n6. We get `6` now and we can extend the `sub` list by picking it.\\n\\t```\\n\\t    [1,    4,    5,    6]\\n\\t\\t\\t\\t\\t       ^sub2\\t\\n\\t```\\n\\n7. Cant extend with `-1`. So, Replace -\\n\\t```\\n\\t    [-1,    4,    5,   6]\\n\\t\\t  ^sub3\\t\\t       ^sub2\\t\\n\\t\\n\\tWe have again formed a new list internally by replacing smallest element larger than -1 from exisiting list\\n\\t```\\n8. We get `9`  which is greater than the end of our list and thus can be used to extend the list\\n\\t```\\n\\t    [-1,    4,    5,    6,    9]\\n\\t\\t  ^sub3\\t\\t              ^sub2\\t\\n\\t```\\n\\t<br/>\\n\\tFinally the length of our maintained list will denote the LIS length = `5`. Do note that it wont give the LIS itself but just correct length of it. \\n\\nThe optimization which improves this approach over DP is applying **Binary search** when we can\\'t extend the sequence and need to replace some element from maintained list - `sub`. The list always remains sorted and thus binary search gives us the correct index of element in list which will be replaced by current element under iteration.\\n\\nBasically, we will compare end element of `sub` with element under iteration `cur`. If `cur` is bigger than it, we just extend our list. Otherwise, we will simply apply binary search to find the smallest element >= cur and replace it. Understanding the explanation till now was the hard part...the approach is very easy to code\\uD83D\\uDE42 .\\n\\nI have used the input array itself as my maintained list. Use an auxillary array if you\\'re restricted from modifying the input.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& A) {\\n        int len = 0;\\n        for(auto cur : A) \\n            if(len == 0 || A[len-1] < cur) A[len++] = cur;             // extend\\n            else *lower_bound(begin(A), begin(A) + len, cur) = cur;    // replace\\n        return len;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int i = 0, int prev = INT_MIN) {\\n        if(i == size(nums)) return 0;\\n        return max(lengthOfLIS(nums, i + 1, prev), (nums[i] > prev) + lengthOfLIS(nums, i + 1, max(nums[i], prev)));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;                                // cant pick any more elements\\n        int take = 0, dontTake = solve(nums, i + 1, prev);           // try skipping the current element\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);   // or pick it if it is greater than previous picked element\\n        return max(take, dontTake);                                  // return whichever choice gives max LIS\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int, int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums));\\n        return solve(nums, 0, INT_MIN);\\n    }\\n    int solve(vector<int>& nums, int i, int prev) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i].count(prev)) return dp[i][prev];\\n        int take = 0, dontTake = solve(nums, i + 1, prev);\\n        if(nums[i] > prev) take = 1 + solve(nums, i + 1, nums[i]);\\n        return dp[i][prev] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums), vector<int>(1+size(nums), -1));   // dp[i][j] denotes max LIS starting from i when nums[j] is previous picked element\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[i][prev_i+1] != -1) return dp[i][prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i]) take = 1 + solve(nums, i + 1, i); // try picking current element if no previous element is chosen or current > nums[prev_i]\\n        return dp[i][prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int lengthOfLIS(vector<int>& nums) {\\n        dp.resize(size(nums)+1, -1);\\n        return solve(nums, 0, -1);\\n    }\\n    int solve(vector<int>& nums, int i, int prev_i) {\\n        if(i >= size(nums)) return 0;\\n        if(dp[prev_i+1] != -1) return dp[prev_i+1];\\n        int take = 0, dontTake = solve(nums, i + 1, prev_i);\\n        if(prev_i == -1 || nums[i] > nums[prev_i])\\n            take = 1 + solve(nums, i + 1, i);\\n        return dp[prev_i+1] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 1, n = size(nums);\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) \\n            for(int j = 0; j < i; j++) \\n                if(nums[i] > nums[j]) \\n\\t\\t\\t\\t    dp[i] = max(dp[i], dp[j] + 1), ans = max(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```\n```\\n\\t    [1,    4,      8]\\n\\t           ^sub2   ^sub1\\n\\t\\n\\tThis replacement technique works because replaced elements dont matter to us\\n\\tWe only used end elements of existing lists to check if they can be extended otherwise form newer lists\\n\\tAnd since we have replaced a bigger element with smaller one it wont affect the \\n\\tstep of creating new list after taking some part of existing list (see step 4 in above approach)\\n\\t```\n```\\n\\t    [1,    4,    5]\\n\\t\\t\\t\\t\\t ^sub2\\n\\t\\t\\n\\tThink of it as extending sub2 in 5th step of above appraoch\\n\\tAlso, we can see sub2 replaced sub1 meaning any subsequence formed with sub2 always\\n\\thas better chance of being LIS than sub1.\\n\\t```\n```\\n\\t    [1,    4,    5,    6]\\n\\t\\t\\t\\t\\t       ^sub2\\t\\n\\t```\n```\\n\\t    [-1,    4,    5,   6]\\n\\t\\t  ^sub3\\t\\t       ^sub2\\t\\n\\t\\n\\tWe have again formed a new list internally by replacing smallest element larger than -1 from exisiting list\\n\\t```\n```\\n\\t    [-1,    4,    5,    6,    9]\\n\\t\\t  ^sub3\\t\\t              ^sub2\\t\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& A) {\\n        int len = 0;\\n        for(auto cur : A) \\n            if(len == 0 || A[len-1] < cur) A[len++] = cur;             // extend\\n            else *lower_bound(begin(A), begin(A) + len, cur) = cur;    // replace\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74989,
                "title": "c-typical-dp-n-2-solution-and-nlogn-solution-from-geekforgeek",
                "content": "This is a classic problem and here is a DP solution for reference \\nPlease note a NLogN solution can be found in the following link\\n[Geek for Geek ][1]\\n\\n    class Solution {\\n    public:\\n        // There's a typical DP solution with O(N^2) Time and O(N) space \\n        // DP[i] means the result ends at i\\n        // So for dp[i], dp[i] is max(dp[j]+1), for all j < i and nums[j] < nums[i]\\n        int lengthOfLIS(vector<int>& nums) {\\n            const int size = nums.size();\\n            if (size == 0) { return 0; } \\n            vector<int> dp(size, 1);\\n            int res = 1;\\n            for (int i = 1; i < size; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (nums[j] < nums[i]) {\\n                        dp[i] = max(dp[i], dp[j]+1);\\n                    }\\n                }\\n                res = max (res, dp[i]);\\n            }\\n            return res;\\n        }\\n    };\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        // There's a typical DP solution with O(N^2) Time and O(N) space \\n        // DP[i] means the result ends at i\\n        // So for dp[i], dp[i] is max(dp[j]+1), for all j < i and nums[j] < nums[i]\\n        int lengthOfLIS(vector<int>& nums) {\\n            const int size = nums.size();\\n            if (size == 0) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 988578,
                "title": "c-recursion-memoization-dynamic-programming",
                "content": "```\\n//recursion [22 / 54 test cases passed]\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return lis(-1,0,nums);\\n    }\\n    int lis(int prev,int curr,vector<int>& arr){\\n        if(curr==arr.size()){\\n            return 0;\\n        }\\n        int first=0;\\n        if(prev==-1 || arr[prev]<arr[curr]){\\n            first=1+lis(curr,curr+1,arr);\\n        }\\n        int sec=lis(prev,curr+1,arr);\\n        return max(first,sec);\\n    }\\n};\\n```\\n```\\n//MEMOIZATION \\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int k=nums.size();\\n        int **ans = new int*[k+1];\\n\\t    for(int i = 0; i <= k; i++) {\\n\\t\\t    ans[i] = new int[k+1];\\n\\t\\t    for(int j = 0; j <= k; j++) {\\n\\t\\t    \\tans[i][j] = -1;\\n\\t\\t    }\\n\\t    }\\n        return lis(-1,0,nums,ans);\\n    }\\n    int lis(int prev,int curr,vector<int>& arr,int **dp){\\n        if(curr==arr.size()){\\n            return 0;\\n        } \\n        if(prev!=-1 && dp[prev][curr]!=-1){\\n            return dp[prev][curr];\\n        }\\n        int first=0;\\n        if(prev==-1 || arr[prev]<arr[curr]){\\n            first=1+lis(curr,curr+1,arr,dp);\\n        }\\n        int sec=lis(prev,curr+1,arr,dp);\\n        if(prev!=-1){\\n            return dp[prev][curr]=max(first,sec);\\n        }else\\n            return max(first,sec);\\n    }\\n};\\n```\\n```\\n//dynamic programming\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=1;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]){\\n                    dp[i]=dp[j];\\n                }\\n            }\\n           dp[i]++;\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//recursion [22 / 54 test cases passed]\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        return lis(-1,0,nums);\\n    }\\n    int lis(int prev,int curr,vector<int>& arr){\\n        if(curr==arr.size()){\\n            return 0;\\n        }\\n        int first=0;\\n        if(prev==-1 || arr[prev]<arr[curr]){\\n            first=1+lis(curr,curr+1,arr);\\n        }\\n        int sec=lis(prev,curr+1,arr);\\n        return max(first,sec);\\n    }\\n};\\n```\n```\\n//MEMOIZATION \\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int k=nums.size();\\n        int **ans = new int*[k+1];\\n\\t    for(int i = 0; i <= k; i++) {\\n\\t\\t    ans[i] = new int[k+1];\\n\\t\\t    for(int j = 0; j <= k; j++) {\\n\\t\\t    \\tans[i][j] = -1;\\n\\t\\t    }\\n\\t    }\\n        return lis(-1,0,nums,ans);\\n    }\\n    int lis(int prev,int curr,vector<int>& arr,int **dp){\\n        if(curr==arr.size()){\\n            return 0;\\n        } \\n        if(prev!=-1 && dp[prev][curr]!=-1){\\n            return dp[prev][curr];\\n        }\\n        int first=0;\\n        if(prev==-1 || arr[prev]<arr[curr]){\\n            first=1+lis(curr,curr+1,arr,dp);\\n        }\\n        int sec=lis(prev,curr+1,arr,dp);\\n        if(prev!=-1){\\n            return dp[prev][curr]=max(first,sec);\\n        }else\\n            return max(first,sec);\\n    }\\n};\\n```\n```\\n//dynamic programming\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=1;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]){\\n                    dp[i]=dp[j];\\n                }\\n            }\\n           dp[i]++;\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395570,
                "title": "python3-7-lines-binsearch-cheating-w-explanation-t-m-94-82",
                "content": "```\\nclass Solution:     # Suppose, for example:\\n                    #           nums = [1,8,4,5,3,7],\\n                    # for which the longest strictly increasing subsequence is arr = [1,4,5,7],\\n                    # giving len(arr) = 4 as the answer\\n                    #\\n                    # Here\\'s the plan:\\n                    #   1) Initiate arr = [num[0]], which in this example means arr = [1]\\n                    #     \\n                    #   2) Iterate through nums. 2a) If n in nums is greater than arr[-1], append n to arr. 2b) If \\n                    #      not, determine the furthest position in arr at which n could be placed so that arr\\n                    #      remains strictly increasing, and overwrite the element at that position in arr with n.\\n\\n                    #   3) Once completed, return the length of arr.\\n\\n                    # Here\\'s the iteration for the example:\\n\\n                    #       nums = [ _1_, 8,4,5,3,7]     arr = [1]              (initial step)\\n                    #       nums = [1, _8_, 4,5,3,7]     arr = [1, 8]           (8 > 1, so    append 8)\\n                    #       nums = [1,8, _4_, 5,3,7]     arr = [1, 4]           (4 < 8, so overwrite 8)\\n                    #       nums = [1_8,4, _5_, 3,7]     arr = [1, 4, 5]        (5 > 4, so    append 5)\\n                    #       nums = [1_8,4,5, _3_, 7]     arr = [1, 3, 5]        (3 < 5, so overwrite 4)\\n                    #       nums = [1_8,4,5,3, _7_ ]     arr = [1, 3, 5, 7]     (7 > 5, so    append 7)    \\n\\n                    # Notice that arr is not the sequence given above as the correct seq. The ordering for [1,3,5,7]\\n                    # breaks the \"no changing the order\" rule. Cheating? Maybe... However len(arr) = 4 is the \\n                    # correct answer. Overwriting 4 with 3 did not alter the sequence\\'s length.\\n                                \\n    def lengthOfLIS(self, nums: list[int]) -> int:\\n\\n        arr = [nums.pop(0)]                  # <-- 1) initial step\\n \\n        for n in nums:                       # <-- 2) iterate through nums\\n            \\n            if n > arr[-1]:                  # <--    2a)\\n                arr.append(n)\\n\\n            else:                            # <--    2b)\\n                arr[bisect_left(arr, n)] = n \\n\\n        return len(arr)                      # <-- 3) return the length of arr",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:     # Suppose, for example:\\n                    #           nums = [1,8,4,5,3,7],\\n                    # for which the longest strictly increasing subsequence is arr = [1,4,5,7],\\n                    # giving len(arr) = 4 as the answer\\n                    #\\n                    # Here\\'s the plan:\\n                    #   1) Initiate arr = [num[0]], which in this example means arr = [1]\\n                    #     \\n                    #   2) Iterate through nums. 2a) If n in nums is greater than arr[-1], append n to arr. 2b) If \\n                    #      not, determine the furthest position in arr at which n could be placed so that arr\\n                    #      remains strictly increasing, and overwrite the element at that position in arr with n.\\n\\n                    #   3) Once completed, return the length of arr.\\n\\n                    # Here\\'s the iteration for the example:\\n\\n                    #       nums = [ _1_, 8,4,5,3,7]     arr = [1]              (initial step)\\n                    #       nums = [1, _8_, 4,5,3,7]     arr = [1, 8]           (8 > 1, so    append 8)\\n                    #       nums = [1,8, _4_, 5,3,7]     arr = [1, 4]           (4 < 8, so overwrite 8)\\n                    #       nums = [1_8,4, _5_, 3,7]     arr = [1, 4, 5]        (5 > 4, so    append 5)\\n                    #       nums = [1_8,4,5, _3_, 7]     arr = [1, 3, 5]        (3 < 5, so overwrite 4)\\n                    #       nums = [1_8,4,5,3, _7_ ]     arr = [1, 3, 5, 7]     (7 > 5, so    append 7)    \\n\\n                    # Notice that arr is not the sequence given above as the correct seq. The ordering for [1,3,5,7]\\n                    # breaks the \"no changing the order\" rule. Cheating? Maybe... However len(arr) = 4 is the \\n                    # correct answer. Overwriting 4 with 3 did not alter the sequence\\'s length.\\n                                \\n    def lengthOfLIS(self, nums: list[int]) -> int:\\n\\n        arr = [nums.pop(0)]                  # <-- 1) initial step\\n \\n        for n in nums:                       # <-- 2) iterate through nums\\n            \\n            if n > arr[-1]:                  # <--    2a)\\n                arr.append(n)\\n\\n            else:                            # <--    2b)\\n                arr[bisect_left(arr, n)] = n \\n\\n        return len(arr)                      # <-- 3) return the length of arr",
                "codeTag": "Java"
            },
            {
                "id": 74953,
                "title": "java-solution-dp-simple",
                "content": "    public int lengthOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0){\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length];\\n        int max = 1;\\n        for(int index=0; index<nums.length;index++){\\n            dp[index]=1;\\n            for(int dpIndex=0; dpIndex<index; dpIndex++){\\n                if(nums[dpIndex]<nums[index]){\\n                    dp[index]=Math.max(dp[index],dp[dpIndex]+1);\\n                    max=Math.max(dp[index],max);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int lengthOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0){\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length];\\n        int max = 1;\\n        for(int index=0; index<nums.length;index++){\\n            dp[index]=1;\\n            for(int dpIndex=0; dpIndex<index; dpIndex++){\\n                if(nums[dpIndex]<nums[index]){\\n                    dp[index]=Math.max(dp[index],dp[dpIndex]+1);\\n                    max=Math.max(dp[index],max);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 75002,
                "title": "python-dp-with-o-n-2-binary-search-with-o-nlogn",
                "content": "    class Solution(object):\\n    #using dP\\n    def lengthOfLIS1(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp = [1]*len(nums)\\n        for i in range (1, len(nums)):\\n            for j in range(i):\\n                if nums[i] >nums[j]:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n        return max(dp)\\n    #using binary search\\n    def lengthOfLIS(self, nums):\\n        def search(temp, left, right, target):\\n            if left == right:\\n                return left\\n            mid = left+(right-left)/2\\n            return search(temp, mid+1, right, target) if temp[mid]<target else search(temp, left, mid, target)\\n        temp = []\\n        for num in nums:\\n            pos = search(temp, 0, len(temp), num)\\n            if pos >=len(temp):\\n                temp.append(num)\\n            else:\\n                temp[pos]=num\\n        return len(temp)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    #using dP\\n    def lengthOfLIS1(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp = [1]*len(nums)\\n        for i in range (1, len(nums)):\\n            for j in range(i):\\n                if nums[i] >nums[j]:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n        return max(dp)\\n    #using binary search\\n    def lengthOfLIS(self, nums):\\n        def search(temp, left, right, target):\\n            if left == right:\\n                return left\\n            mid = left+(right-left)/2\\n            return search(temp, mid+1, right, target) if temp[mid]<target else search(temp, left, mid, target)\\n        temp = []\\n        for num in nums:\\n            pos = search(temp, 0, len(temp), num)\\n            if pos >=len(temp):\\n                temp.append(num)\\n            else:\\n                temp[pos]=num\\n        return len(temp)",
                "codeTag": "Java"
            },
            {
                "id": 74916,
                "title": "o-nlogn-clean-and-easy-java-dp-binary-search-solution-with-detailed-explanation",
                "content": "I use an array dp[] to store the largest elements in the increasing subsequences and the array's index is the length of the subsequence (since this, we can make sure that the array dp[] is in-order). The idea is keep checking if nums[i] is bigger than dp[len] or not: nums[i] > dp[len] means we can retrieve a longer subsequence by adding the current element nums[i] into the result, so we just increase the pointer 'len' by one and put the current element into the new index; otherwise we need to do a binary search to find out the index of the largest element st. dp[index] < nums[i] && dp[index + 1] > nums[i] and update the dp[index] with value nums[i]. \\n\\nLet's see an example:\\nintput: 2 4 9 3 7 8\\n\\nThe array 'dp' looks like these in first two iterations:\\n\\n2 4 0 0 0 (len = 1)\\n\\n2 4 9 0 0 (len = 2)\\n\\nIn the third iteration, we notice that dp[len] ('9' here) > nums[i] ('3' here), so we update the dp[index] with value '3', then we got:\\n\\n2 3 9 0 0 (len = 2) <---- **Attention here**, this array doesn't mean we can retrieve subsequence [2,3,9], it only means the largest element in a length 1 subsequence is '2' ([2]), the largest element in a length 2 subsequence is '3' ([2,3]) and the largest element in a length 3 subsequence is '9' ([2,4,9]) by far.\\n\\nIn next iteration, we update the dp[index] with value '7' again and we got:\\n2 3 7 0 0 (len = 2)\\n\\nIn the final round, obviously dp[len] (7) < nums[i] (8) so we increase the 'len' by one and put '8' into dp[3] then we got:\\n2 3 7 8 0 (len = 3)\\n\\nClearly len + 1 = 4 is our result : )\\n\\nPS: Keep in mind that 'len' always indicate the length of the longest increasing subsequence in each iteration.\\n\\n    public int lengthOfLIS(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int len = 0;\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > dp[len]) {\\n                dp[++len] = nums[i];\\n            }\\n            else {\\n                int index = search(dp, len, nums[i]);\\n                dp[index] = nums[i];\\n            }\\n        }\\n        return len + 1;\\n    }\\n\\n    private int search(int[] dp, int len, int val) {\\n        int start = 0;\\n        while(start <= len) {\\n            int mid = start + (len - start) / 2;\\n            if(dp[mid] == val) {\\n                return mid;\\n            }\\n            else if(dp[mid] < val) {\\n                start = mid + 1;\\n            }\\n            else {\\n                len = mid - 1;\\n            }\\n        }\\n        return start;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "I use an array dp[] to store the largest elements in the increasing subsequences and the array's index is the length of the subsequence (since this, we can make sure that the array dp[] is in-order). The idea is keep checking if nums[i] is bigger than dp[len] or not: nums[i] > dp[len] means we can retrieve a longer subsequence by adding the current element nums[i] into the result, so we just increase the pointer 'len' by one and put the current element into the new index; otherwise we need to do a binary search to find out the index of the largest element st. dp[index] < nums[i] && dp[index + 1] > nums[i] and update the dp[index] with value nums[i]. \\n\\nLet's see an example:\\nintput: 2 4 9 3 7 8\\n\\nThe array 'dp' looks like these in first two iterations:\\n\\n2 4 0 0 0 (len = 1)\\n\\n2 4 9 0 0 (len = 2)\\n\\nIn the third iteration, we notice that dp[len] ('9' here) > nums[i] ('3' here), so we update the dp[index] with value '3', then we got:\\n\\n2 3 9 0 0 (len = 2) <---- **Attention here**, this array doesn't mean we can retrieve subsequence [2,3,9], it only means the largest element in a length 1 subsequence is '2' ([2]), the largest element in a length 2 subsequence is '3' ([2,3]) and the largest element in a length 3 subsequence is '9' ([2,4,9]) by far.\\n\\nIn next iteration, we update the dp[index] with value '7' again and we got:\\n2 3 7 0 0 (len = 2)\\n\\nIn the final round, obviously dp[len] (7) < nums[i] (8) so we increase the 'len' by one and put '8' into dp[3] then we got:\\n2 3 7 8 0 (len = 3)\\n\\nClearly len + 1 = 4 is our result : )\\n\\nPS: Keep in mind that 'len' always indicate the length of the longest increasing subsequence in each iteration.\\n\\n    public int lengthOfLIS(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int len = 0;\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > dp[len]) {\\n                dp[++len] = nums[i];\\n            }\\n            else {\\n                int index = search(dp, len, nums[i]);\\n                dp[index] = nums[i];\\n            }\\n        }\\n        return len + 1;\\n    }\\n\\n    private int search(int[] dp, int len, int val) {\\n        int start = 0;\\n        while(start <= len) {\\n            int mid = start + (len - start) / 2;\\n            if(dp[mid] == val) {\\n                return mid;\\n            }\\n            else if(dp[mid] < val) {\\n                start = mid + 1;\\n            }\\n            else {\\n                len = mid - 1;\\n            }\\n        }\\n        return start;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74869,
                "title": "simple-java-o-nlogn-solution",
                "content": "    public int lengthOfLIS(int[] nums) \\n    {\\n        List<Integer> sequence = new ArrayList();\\n        for(int n : nums) update(sequence, n);\\n        \\n        return sequence.size();\\n    }\\n    \\n    private void update(List<Integer> seq, int n)\\n    {\\n        if(seq.isEmpty() || seq.get(seq.size() - 1) < n) seq.add(n);\\n        else\\n        {\\n            seq.set(findFirstLargeEqual(seq, n), n);\\n        }\\n    }\\n\\n    private int findFirstLargeEqual(List<Integer> seq, int target)\\n    {\\n        int lo = 0;\\n        int hi = seq.size() - 1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            if(seq.get(mid) < target) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }",
                "solutionTags": [],
                "code": "    public int lengthOfLIS(int[] nums) \\n    {\\n        List<Integer> sequence = new ArrayList();\\n        for(int n : nums) update(sequence, n);\\n        \\n        return sequence.size();\\n    }\\n    \\n    private void update(List<Integer> seq, int n)\\n    {\\n        if(seq.isEmpty() || seq.get(seq.size() - 1) < n) seq.add(n);\\n        else\\n        {\\n            seq.set(findFirstLargeEqual(seq, n), n);\\n        }\\n    }\\n\\n    private int findFirstLargeEqual(List<Integer> seq, int target)\\n    {\\n        int lo = 0;\\n        int hi = seq.size() - 1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            if(seq.get(mid) < target) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2395980,
                "title": "c-solution-both-ways",
                "content": "Language Used: C++\\n\\n*If you have any questions, feel free to ask. If you like the solution and explanation, please **upvote!***\\n\\n##### Method-1:\\n##### Dynamic Programming\\n\\nTime Complexity = O(n*n)\\nSpace Complexity = O(n)\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n, 1);\\n        \\n        for(int i{1}; i<n; i++){\\n            for(int j{0}; j<i; j++){\\n                if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\\n##### Method-2:\\n##### Tail Method\\n\\nTime Complexity = O(nlogn)\\nSpace Complexity = O(n)\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> tail;\\n        \\n        for(int num : nums){\\n            if(tail.empty() || num > tail.back()){\\n                tail.push_back(num);\\n            }\\n            else{\\n                tail[firstGreatEqual(tail, num)] = num;\\n            }\\n        }\\n        \\n        return tail.size();\\n    }\\nprivate:\\n    int firstGreatEqual(vector<int>& t, int tr){\\n\\t\\t// For finding the index of target element.\\n\\t\\t// Lower_Bound solves via Binary Search.\\n        return lower_bound(t.begin(), t.end(), tr) - t.begin();\\n    }\\n};\\n```\\n##### Method-3:\\n##### Special {edited}\\n*  In close observation, We have already solved Standard DP Problem [Longest Common Subsequence.](http://https://leetcode.com/problems/longest-common-subsequence/) This problem is also the derevative of it.\\n*  Steps:\\n\\t*  Find unique elements in the nums, and store it in a new vector<int> nums2.\\n\\t*  Sort(nums2).\\n\\t*  Find LCS of nums1 and nums2, to get the result.\\n*  The idea is to store unique elements is to get in the strictly increasing format.\\n\\n\\nKeep Coding\\n**`while(!success){ tryAgain(); } :)`**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n, 1);\\n        \\n        for(int i{1}; i<n; i++){\\n            for(int j{0}; j<i; j++){\\n                if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> tail;\\n        \\n        for(int num : nums){\\n            if(tail.empty() || num > tail.back()){\\n                tail.push_back(num);\\n            }\\n            else{\\n                tail[firstGreatEqual(tail, num)] = num;\\n            }\\n        }\\n        \\n        return tail.size();\\n    }\\nprivate:\\n    int firstGreatEqual(vector<int>& t, int tr){\\n\\t\\t// For finding the index of target element.\\n\\t\\t// Lower_Bound solves via Binary Search.\\n        return lower_bound(t.begin(), t.end(), tr) - t.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395913,
                "title": "python-fast-than-95-less-than-83-o-nlogn",
                "content": "**Appreciate if you could upvote this solution**\\n\\n**Method**: `DP`\\n\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\ttotal_number = len(nums)\\n\\tdp = [0 for _ in range(total_number)]\\n\\tfor i in range(1, total_number):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1)\\n\\treturn max(dp) + 1\\n```\\nTime Complexity: `O(n^2)`\\nTime Complexity: `O(n)`\\n<br/>\\n\\n**Method**: `Binary Search`\\nDetailed explanation: https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\ttails = [0] * len(nums)\\n\\tresult = 0\\n\\tfor num in nums:\\n\\t\\tleft_index, right_index = 0, result\\n\\t\\twhile left_index != right_index:\\n\\t\\t\\tmiddle_index = left_index + (right_index - left_index) // 2\\n\\t\\t\\tif tails[middle_index] < num:\\n\\t\\t\\t\\tleft_index = middle_index + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tright_index = middle_index\\n\\t\\tresult = max(result, left_index + 1)\\n\\t\\ttails[left_index] = num\\n\\treturn result\\n```\\nTime Complexity: `O(nlogn)`\\nTime Complexity: `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\ttotal_number = len(nums)\\n\\tdp = [0 for _ in range(total_number)]\\n\\tfor i in range(1, total_number):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1)\\n\\treturn max(dp) + 1\\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\ttails = [0] * len(nums)\\n\\tresult = 0\\n\\tfor num in nums:\\n\\t\\tleft_index, right_index = 0, result\\n\\t\\twhile left_index != right_index:\\n\\t\\t\\tmiddle_index = left_index + (right_index - left_index) // 2\\n\\t\\t\\tif tails[middle_index] < num:\\n\\t\\t\\t\\tleft_index = middle_index + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tright_index = middle_index\\n\\t\\tresult = max(result, left_index + 1)\\n\\t\\ttails[left_index] = num\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 659899,
                "title": "four-python-solutions-from-o-2-n-to-o-nlogn",
                "content": "- Brute-force recursion (TLE): time O(2^n) space O(n)\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tdef max_lis(idx, cur_max):\\n\\t\\tif idx == len(nums):\\n\\t\\t\\treturn 0\\n\\t\\tif nums[idx] > cur_max:\\n\\t\\t\\treturn max(1 + max_lis(idx + 1, nums[idx]), max_lis(idx + 1, cur_max))\\n\\t\\treturn max_lis(idx + 1, cur_max)\\n\\treturn max_lis(0, float(\\'-inf\\'))\\n```\\n- Recursion with memoization (DP): time O(n^2) space O(n^2)\\n```\\nfrom collections import defaultdict\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tcache = defaultdict(dict) # 2D cache of prev_max_idx & cur_idx\\n\\tnums.append(float(\\'-inf\\'))\\n\\tdef max_lis(idx, prev_max_idx):\\n\\t\\tif idx == len(nums) - 1:\\n\\t\\t\\treturn 0\\n\\t\\tif prev_max_idx not in cache or idx not in cache[prev_max_idx]:\\n\\t\\t\\tif nums[idx] > nums[prev_max_idx]:\\n\\t\\t\\t\\tcache[prev_max_idx][idx] = max(1 + max_lis(idx + 1, idx), max_lis(idx + 1, prev_max_idx))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcache[prev_max_idx][idx] = max_lis(idx + 1, prev_max_idx)\\n\\t\\treturn cache[prev_max_idx][idx]\\n\\treturn max_lis(0, -1)\\n```\\n- Bottom-up DP: time O(n^2) space O(n)\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tdp = [1] * len(nums)\\n\\tmax_len = 1\\n\\tfor i in range(1, len(nums)):\\n\\t\\tfor j in range(0, i):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1)\\n\\t\\tmax_len = max(max_len, dp[i])\\n\\treturn max_len\\n```\\nBottom-up DP + binary-search: time O(nlogn) space O(n)\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tdp = [nums[0]]\\n\\tlen_dp = 1\\n\\tfor i in range(1, len(nums)):\\n\\t\\tleft, right = 0, len(dp) - 1\\n\\t\\twhile left < right:\\n\\t\\t\\tmid = (left + right) // 2\\n\\t\\t\\tif dp[mid] < nums[i]:\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tright = mid\\n\\t\\tif dp[left] < nums[i]:\\n\\t\\t\\tdp.append(nums[i])\\n\\t\\t\\tlen_dp += 1\\n\\t\\telse:\\n\\t\\t\\tdp[left] = nums[i]\\n\\treturn len_dp\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tdef max_lis(idx, cur_max):\\n\\t\\tif idx == len(nums):\\n\\t\\t\\treturn 0\\n\\t\\tif nums[idx] > cur_max:\\n\\t\\t\\treturn max(1 + max_lis(idx + 1, nums[idx]), max_lis(idx + 1, cur_max))\\n\\t\\treturn max_lis(idx + 1, cur_max)\\n\\treturn max_lis(0, float(\\'-inf\\'))\\n```\n```\\nfrom collections import defaultdict\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tcache = defaultdict(dict) # 2D cache of prev_max_idx & cur_idx\\n\\tnums.append(float(\\'-inf\\'))\\n\\tdef max_lis(idx, prev_max_idx):\\n\\t\\tif idx == len(nums) - 1:\\n\\t\\t\\treturn 0\\n\\t\\tif prev_max_idx not in cache or idx not in cache[prev_max_idx]:\\n\\t\\t\\tif nums[idx] > nums[prev_max_idx]:\\n\\t\\t\\t\\tcache[prev_max_idx][idx] = max(1 + max_lis(idx + 1, idx), max_lis(idx + 1, prev_max_idx))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcache[prev_max_idx][idx] = max_lis(idx + 1, prev_max_idx)\\n\\t\\treturn cache[prev_max_idx][idx]\\n\\treturn max_lis(0, -1)\\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tdp = [1] * len(nums)\\n\\tmax_len = 1\\n\\tfor i in range(1, len(nums)):\\n\\t\\tfor j in range(0, i):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1)\\n\\t\\tmax_len = max(max_len, dp[i])\\n\\treturn max_len\\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tdp = [nums[0]]\\n\\tlen_dp = 1\\n\\tfor i in range(1, len(nums)):\\n\\t\\tleft, right = 0, len(dp) - 1\\n\\t\\twhile left < right:\\n\\t\\t\\tmid = (left + right) // 2\\n\\t\\t\\tif dp[mid] < nums[i]:\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tright = mid\\n\\t\\tif dp[left] < nums[i]:\\n\\t\\t\\tdp.append(nums[i])\\n\\t\\t\\tlen_dp += 1\\n\\t\\telse:\\n\\t\\t\\tdp[left] = nums[i]\\n\\treturn len_dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 75023,
                "title": "share-java-dp-solution",
                "content": "`dp[i]` represents the the length of the LIS till `nums[i]`.\\n\\nFor each `nums[i]`, we need to compare all the `nums[j]` where `0` <= `j` < `i`, if `nums[i]` > `nums[j]`, then `dp[i]` = `dp[j]` + `1`, that means we have found a potential LIS. \\n\\nLet `i` go through the `nums[]` array, eventually we will get the longest length of LIS. \\n\\nTime complexity is `O(n^2)`.\\n\\n    public int lengthOfLIS(int[] nums) {\\n      if (nums.length == 0) return 0;\\n      \\n      int n = nums.length, max = 0;\\n      int[] dp = new int[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        dp[i] = 1;\\n        \\n        for (int j = 0; j < i; j++) {\\n          if (nums[i] > nums[j] && dp[j] + 1 > dp[i]) {\\n            dp[i] = dp[j] + 1;\\n          }\\n        }\\n        \\n        max = Math.max(max, dp[i]);\\n      }\\n      \\n      return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "`dp[i]` represents the the length of the LIS till `nums[i]`.\\n\\nFor each `nums[i]`, we need to compare all the `nums[j]` where `0` <= `j` < `i`, if `nums[i]` > `nums[j]`, then `dp[i]` = `dp[j]` + `1`, that means we have found a potential LIS. \\n\\nLet `i` go through the `nums[]` array, eventually we will get the longest length of LIS. \\n\\nTime complexity is `O(n^2)`.\\n\\n    public int lengthOfLIS(int[] nums) {\\n      if (nums.length == 0) return 0;\\n      \\n      int n = nums.length, max = 0;\\n      int[] dp = new int[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        dp[i] = 1;\\n        \\n        for (int j = 0; j < i; j++) {\\n          if (nums[i] > nums[j] && dp[j] + 1 > dp[i]) {\\n            dp[i] = dp[j] + 1;\\n          }\\n        }\\n        \\n        max = Math.max(max, dp[i]);\\n      }\\n      \\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 896279,
                "title": "5-approaches-beat-99-9-time",
                "content": "\\t#     Attepmt 1 - NOT WORKING: loop through list for starting point, then find its increasing subsequence\\n\\t# it won\\'t work because eg [1,100,2,3,4]\\n\\t#     Time: O(n^2) space: O(1)\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n, res = len(nums), 1\\n        for i in range(n - 1):\\n            cur, LIS = nums[i], 1\\n            for j in range(i + 1, n):\\n                if nums[j] > cur:\\n                    LIS += 1\\n                    cur = nums[j]\\n            res = max(res, LIS)\\n        return res\\n    \\n\\t#     Attempt 2 - NOT WORKING: increasing monotonic stack\\n\\t# it won\\'t work because eg [1,100,2,3,4]\\n\\t#     Time: O(n) space: O(n)\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        stack, res = [], 0\\n        for num in nums:\\n            while stack and num <= stack[-1]:\\n                stack.pop()\\n            stack.append(num)\\n            res = max(res, len(stack))\\n        return res\\n    \\n    # APP1: brute force dfs with global variable. for each pos, we can pick or not pick. only pick larger one\\n    # Time: O(2^n) space: O(n) stack Runtime: TLE\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        self.res = 0\\n        self.dfs(nums, 0, -sys.maxsize, 0)\\n        return self.res \\n    \\n    def dfs(self, nums, i, pre, cur_len):\\n        if i == len(nums):\\n            self.res = max(self.res, cur_len)\\n            return\\n        self.dfs(nums, i + 1, pre, cur_len)\\n        if nums[i] > pre:\\n            self.dfs(nums, i + 1, nums[i], cur_len + 1)\\n    \\n    # APP2: brute force dfs without global variable. cleaner way for opimization later. \\n    # Time: O(2^n) space: O(n) stack Runtime: TLE\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        return self.dfs(nums, 0, -sys.maxsize)\\n        \\n    def dfs(self, nums, i, pre):\\n        if i == len(nums):\\n            return 0\\n        res = self.dfs(nums, i + 1, pre)\\n        if nums[i] > pre:\\n            res = max(res, 1 + self.dfs(nums, i + 1, nums[i]))\\n        return res\\n        \\n    # APP3: dfs + memoization. \\n    # Time: O(n^2) space: O(n^2) runtime: 5%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        memo = {}\\n        return self.dfs(nums, memo, 0, -sys.maxsize)\\n    \\n    def dfs(self, nums, memo, i, pre):\\n        if i == len(nums):\\n            return 0\\n        if (i, pre) in memo:\\n            return memo[(i, pre)]\\n        res = self.dfs(nums, memo, i + 1, pre)\\n        if nums[i] > pre:\\n            res = max(res, 1 + self.dfs(nums, memo, i + 1, nums[i]))\\n        memo[(i, pre)] = res\\n        return res\\n            \\n    # APP4: DP. f[i]: LIS upto index i, including nums[i], ans = max(f)\\n    # f[i] = 1 + max(f[j]) where 0 <= j < i, find max f[j] when nums[j] < nums[i] \\n    # Time: O(n^2) space: O(N^2) Runtime: 66%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        f = [0] * n\\n        for i in range(n):\\n            length, max_lis = 1, 0\\n            for j in range(i - 1, -1, -1):\\n                if nums[j] < nums[i]:\\n                    max_lis = max(max_lis, f[j])\\n            f[i] = max_lis + 1\\n        return max(f)\\n        \\n    # APP5: DP + binary search. f[i]: last min num for LIS at length i. \\n    # artical: https://bit.ly/33Z7Y4C\\n    # Time: O(nlgn) space: O(n) Runtime: 99.8%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        f = []\\n        for i in range(len(nums)):\\n            if not f or nums[i] > f[-1]:\\n                f.append(nums[i])\\n            else:\\n                pos = bisect.bisect_left(f, nums[i])\\n                f[pos] = nums[i]\\n        return len(f)\\n    \\n    \\n    \\n    \\n    \\n    \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "\\t#     Attepmt 1 - NOT WORKING: loop through list for starting point, then find its increasing subsequence\\n\\t# it won\\'t work because eg [1,100,2,3,4]\\n\\t#     Time: O(n^2) space: O(1)\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n, res = len(nums), 1\\n        for i in range(n - 1):\\n            cur, LIS = nums[i], 1\\n            for j in range(i + 1, n):\\n                if nums[j] > cur:\\n                    LIS += 1\\n                    cur = nums[j]\\n            res = max(res, LIS)\\n        return res\\n    \\n\\t#     Attempt 2 - NOT WORKING: increasing monotonic stack\\n\\t# it won\\'t work because eg [1,100,2,3,4]\\n\\t#     Time: O(n) space: O(n)\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        stack, res = [], 0\\n        for num in nums:\\n            while stack and num <= stack[-1]:\\n                stack.pop()\\n            stack.append(num)\\n            res = max(res, len(stack))\\n        return res\\n    \\n    # APP1: brute force dfs with global variable. for each pos, we can pick or not pick. only pick larger one\\n    # Time: O(2^n) space: O(n) stack Runtime: TLE\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        self.res = 0\\n        self.dfs(nums, 0, -sys.maxsize, 0)\\n        return self.res \\n    \\n    def dfs(self, nums, i, pre, cur_len):\\n        if i == len(nums):\\n            self.res = max(self.res, cur_len)\\n            return\\n        self.dfs(nums, i + 1, pre, cur_len)\\n        if nums[i] > pre:\\n            self.dfs(nums, i + 1, nums[i], cur_len + 1)\\n    \\n    # APP2: brute force dfs without global variable. cleaner way for opimization later. \\n    # Time: O(2^n) space: O(n) stack Runtime: TLE\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        return self.dfs(nums, 0, -sys.maxsize)\\n        \\n    def dfs(self, nums, i, pre):\\n        if i == len(nums):\\n            return 0\\n        res = self.dfs(nums, i + 1, pre)\\n        if nums[i] > pre:\\n            res = max(res, 1 + self.dfs(nums, i + 1, nums[i]))\\n        return res\\n        \\n    # APP3: dfs + memoization. \\n    # Time: O(n^2) space: O(n^2) runtime: 5%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        memo = {}\\n        return self.dfs(nums, memo, 0, -sys.maxsize)\\n    \\n    def dfs(self, nums, memo, i, pre):\\n        if i == len(nums):\\n            return 0\\n        if (i, pre) in memo:\\n            return memo[(i, pre)]\\n        res = self.dfs(nums, memo, i + 1, pre)\\n        if nums[i] > pre:\\n            res = max(res, 1 + self.dfs(nums, memo, i + 1, nums[i]))\\n        memo[(i, pre)] = res\\n        return res\\n            \\n    # APP4: DP. f[i]: LIS upto index i, including nums[i], ans = max(f)\\n    # f[i] = 1 + max(f[j]) where 0 <= j < i, find max f[j] when nums[j] < nums[i] \\n    # Time: O(n^2) space: O(N^2) Runtime: 66%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        f = [0] * n\\n        for i in range(n):\\n            length, max_lis = 1, 0\\n            for j in range(i - 1, -1, -1):\\n                if nums[j] < nums[i]:\\n                    max_lis = max(max_lis, f[j])\\n            f[i] = max_lis + 1\\n        return max(f)\\n        \\n    # APP5: DP + binary search. f[i]: last min num for LIS at length i. \\n    # artical: https://bit.ly/33Z7Y4C\\n    # Time: O(nlgn) space: O(n) Runtime: 99.8%\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        f = []\\n        for i in range(len(nums)):\\n            if not f or nums[i] > f[-1]:\\n                f.append(nums[i])\\n            else:\\n                pos = bisect.bisect_left(f, nums[i])\\n                f[pos] = nums[i]\\n        return len(f)\\n    \\n    \\n    \\n    \\n    \\n    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1595288,
                "title": "java-dynamic-programming-o-n-2-and-o-nlogn-with-explanation",
                "content": "### Approach 1: Time Complexity - O(n^2)\\n\\n#### Explanation:\\n![image](https://assets.leetcode.com/users/images/1e01dfc1-2886-4122-9dcf-c5332fe7f830_1637819260.734811.jpeg)\\n\\n\\n#### Code:\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        for(int i=1; i < n; i++){\\n            for(int j=0; j <= i-1; j++){\\n                if(nums[i] > nums[j])\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n<br/>\\n\\n### Approach 2: Time Complexity - O(nlogn)\\n\\n#### Explanation:\\n![image](https://assets.leetcode.com/users/images/2207b83a-a5dd-4cdd-bf0a-cb4f599190f4_1637819289.5847554.jpeg)\\n\\n\\n#### Code:\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        List<Integer> incrSubseq = new ArrayList<>();\\n        incrSubseq.add(nums[0]);\\n        \\n        for(int i=1; i < nums.length; i++){\\n            if(nums[i] > incrSubseq.get(incrSubseq.size() - 1))\\n                incrSubseq.add(nums[i]);\\n            else{\\n                int idx = getNextGreaterElement(incrSubseq, nums[i]);\\n                incrSubseq.set(idx, nums[i]);\\n            }\\n        }        \\n        return incrSubseq.size();        \\n    }\\n\\n    // Return the index of the smallest element that is greater than or equal to the given number\\n    int getNextGreaterElement(List<Integer> list, int num){        \\n        int left = 0, right = list.size() - 1;\\n        \\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(num == list.get(mid))\\n                return mid; // When same number already present we return the index of that element\\n            if(num > list.get(mid))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        for(int i=1; i < n; i++){\\n            for(int j=0; j <= i-1; j++){\\n                if(nums[i] > nums[j])\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        List<Integer> incrSubseq = new ArrayList<>();\\n        incrSubseq.add(nums[0]);\\n        \\n        for(int i=1; i < nums.length; i++){\\n            if(nums[i] > incrSubseq.get(incrSubseq.size() - 1))\\n                incrSubseq.add(nums[i]);\\n            else{\\n                int idx = getNextGreaterElement(incrSubseq, nums[i]);\\n                incrSubseq.set(idx, nums[i]);\\n            }\\n        }        \\n        return incrSubseq.size();        \\n    }\\n\\n    // Return the index of the smallest element that is greater than or equal to the given number\\n    int getNextGreaterElement(List<Integer> list, int num){        \\n        int left = 0, right = list.size() - 1;\\n        \\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(num == list.get(mid))\\n                return mid; // When same number already present we return the index of that element\\n            if(num > list.get(mid))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164830,
                "title": "java-7-approaches-brute-to-binary-search-2-approaches-to-print-lis-intiuition-explained",
                "content": "# Measuring LIS Length\\n\\n***1. Brute Force***\\nThe simplest way is to compute all subsequences and check if they are increasing or not and then store the length of the longest increasing subsequences as our answer.\\n// TC = O(2^n)\\n// SC = O(n) recurrence stack space\\nGenerate all subsequences and check for longest increasing subsequence at each instance.\\n**Observation:** Time Complexity is too high. We will surely get a TLE pursuing this approach.\\n\\n***2. Recursion***\\n// TC = O(2^n)\\n// SC = O(n) recurrence stack space\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return getLIS(nums, -1, 0);\\n    }\\n    public int getLIS(int[]arr, int prev, int i){\\n        if(i == arr.length) return 0;\\n        \\n        int max = Integer.MIN_VALUE, inc = Integer.MIN_VALUE;\\n        \\n        if(prev == -1 || arr[i] > arr[prev]) inc = 1 + getLIS(arr, i, i+1);\\n        int ign = getLIS(arr, prev, i+1);\\n        \\n        return Math.max(inc, ign);\\n    }\\n}\\n```\\n**Observation:** Time Complexity is too high even with recursion. We get a TLE with this approach in the given testcases. Also, we see there are repeating subproblems in the recursion (Dry run a testcase to see repetition). Hence, we must memoize the solution. This increases the space complexity but reduces the time complexity considerably [ O(2^n) to O(n^2)].\\n\\n***3. Memoization***\\n// TC = O(n^2)\\n// SC = O(n^2) + O(n)\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[][]dp = new int[nums.length][nums.length];\\n        for(int[]arr:dp) Arrays.fill(arr, -1);\\n        return getLIS(nums, -1, dp, 0);\\n    }\\n    public int getLIS(int[]arr, int prev, int[][]dp, int i){\\n        if(i == arr.length) return 0;\\n        if(prev != -1 && dp[prev][i] != -1) return dp[prev][i];\\n        \\n        int max = Integer.MIN_VALUE, inc = Integer.MIN_VALUE;\\n        \\n        if(prev == -1 || arr[i] > arr[prev]) inc = 1 + getLIS(arr, i, dp, i+1);\\n        int ign = getLIS(arr, prev, dp, i+1);\\n        \\n        if(prev != -1) return dp[prev][i] = Math.max(inc, ign);\\n        return Math.max(inc, ign);\\n    }\\n}\\n```\\n**Observation:** Time Complexity boils down to O(n^2) which passes all testcases but takes 1688 ms time. May be reduceable further if we observe the problem carefully. Also, we can remove the recursion stack space by tabulation (though the time complexity would remain the space).\\n\\n***4. Tabulation***\\n// TC = O(n^2)\\n// SC = O(n^2)\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[][]dp = new int[arr.length + 1][arr.length + 1];\\n        \\n        for(int i = arr.length-1; i >= 0; i--){\\n            for(int prev = i-1; prev >= -1; prev--){    // as prev can start from i-1 as it is previous of current element\\n                int inc = Integer.MIN_VALUE;\\n        \\n                if(prev == -1 || arr[i] > arr[prev]) inc = 1 + dp[i+1][i+1];\\n                int ign = dp[i+1][prev+1];\\n\\n                dp[i][prev+1] = Math.max(inc, ign);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n**Observation:** Time Complexity remains O(n^2) and all testcases pass. The time taken is 626 ms. Space complexity is reduced as we no longer require the recurrence stack space. Also, we can  reduce the 2D dp to two 1D dp arrays as we only require the previously filled row for calculating the current row.\\n\\n***5. Spatial optimization***\\n// TC = O(n^2)\\n// SC = O(n)\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[]pre = new int[arr.length + 1];\\n        \\n        for(int i = arr.length-1; i >= 0; i--){     // as prev can start from i-1 as it is previous of current element\\n            int[]curr = new int[arr.length + 1];\\n            for(int prev = i-1; prev >= -1; prev--){\\n                int inc = Integer.MIN_VALUE;\\n        \\n                if(prev == -1 || arr[i] > arr[prev]) inc = 1 + pre[i+1];\\n                int ign = pre[prev+1];\\n\\n                curr[prev+1] = Math.max(inc, ign);\\n            }\\n            pre = curr;\\n        }\\n        return pre[0];\\n    }\\n}\\n```\\n**Observation:** Time Complexity remains O(n^2) and all testcases pass. The time taken is 245 ms. The space consumed is further reduced as we only carry two 1D dp array rows instead of the entire 2D array.\\n\\n***6. Another Approach***\\n// TC = O(n^2)\\n// SC = O(n)\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int amax = 1;\\n        int[]dp = new int[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            int max = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[j] < arr[i]) max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = max+1;\\n            amax = Math.max(amax, dp[i]);\\n        }    \\n        return amax;\\n    }\\n}\\n```\\n**Observation:** After watching some solution videos and reading the discuss forums, I realized that we can begin from the zeroth index and at every index, traerse the array till current index and get the previous index with the longest subsequence till now having value smaller than the current index value. Time Complexity remains O(n^2) and all testcases pass. The time taken is 63 ms.\\nAfter observing approach 6 carefully, we can see that we do not actually need to traverse the entire previous array in order to check wether the current element can be paired with any previous elements. But, we can instead use a single traversal, allocating values to the binary searched locations (if location == al.size(), we simply insert the element into the al). Lastly, we can return the size of the arraylist.\\n\\n***7. Optimal Approach (Using Binary Search)***\\n// TC = O(n logn)\\n// SC = O(n)\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        List<Integer>al = new ArrayList<>();\\n        al.add(arr[0]);\\n        for(int i=1; i<arr.length; i++){\\n            if(arr[i] > al.get(al.size()-1)) al.add(arr[i]);\\n            else{\\n                int j = binSearch(al, arr[i]);\\n                al.set(j, arr[i]);\\n            }\\n        }\\n        return al.size();\\n    }\\n    public int binSearch(List<Integer>al, int val){\\n        int lo = 0;\\n        int hi = al.size()-1;\\n        while(hi > lo){\\n            int mid = lo + (hi-lo)/2;\\n            if(al.get(mid) < val) lo = mid+1;\\n            else hi = mid;\\n        }\\n        return hi;\\n    }\\n}\\n```\\n**Observation:** The time complexity boils down to O(nlogn) as we perform binary search for n nodes. This reduces the time taken drastically and leads to a net time consumption of 2-4ms. This, according to my understanding, is the optimal approach to the question.\\n# Printing LIS\\nA way to print the LIS is to maintain the LIS while looping for the LIS as shown under.\\n***1. Way 1:***\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        String amax = Integer.toString(arr[0]);\\n        String[]dp = new String[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            String val = Integer.toString(arr[i]);\\n            String max = val;\\n            for(int j=0; j<i; j++) if(arr[j] < arr[i] && dp[j].length() + 1 > max.length()) max = dp[j] +\", \"+ val;\\n            dp[i] = max;\\n            if(dp[i].length() > amax.length()) amax = dp[i];\\n        }    \\n        System.out.println(amax);\\n        return amax.split(\" \").length;\\n    }\\n}\\n```\\n\\nThe second way uses the tabulation table (dp) to generate the resultant LIS string. Make sure you have understood the tabulation code before pursuing the undermentioned algorithm for string generation.\\n***2. Another Way to print LIS (preferred as we can store ans as array / list directly)***\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int max = 1, lastidx = 0;\\n        \\n        int[]dp = new int[arr.length];\\n        Arrays.fill(dp,1);\\n        \\n        int[]hash = new int[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            hash[i] = i;\\n            for(int j=0; j<i; j++){\\n                if(arr[j] < arr[i] && dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    hash[i] = j;\\n                }\\n            }\\n            \\n            if(dp[i] > max){\\n                lastidx = i;\\n                max = dp[i];\\n            }\\n        }\\n        \\n        int[]ans = new int[max];\\n        int i = max-1;\\n        \\n        while(hash[lastidx] != lastidx){\\n            ans[i--] = arr[lastidx];\\n            lastidx = hash[lastidx];\\n        }\\n        ans[0] = arr[lastidx];\\n        \\n        for(int val:ans) System.out.print(val + \" \");\\n        System.out.println();\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return getLIS(nums, -1, 0);\\n    }\\n    public int getLIS(int[]arr, int prev, int i){\\n        if(i == arr.length) return 0;\\n        \\n        int max = Integer.MIN_VALUE, inc = Integer.MIN_VALUE;\\n        \\n        if(prev == -1 || arr[i] > arr[prev]) inc = 1 + getLIS(arr, i, i+1);\\n        int ign = getLIS(arr, prev, i+1);\\n        \\n        return Math.max(inc, ign);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[][]dp = new int[nums.length][nums.length];\\n        for(int[]arr:dp) Arrays.fill(arr, -1);\\n        return getLIS(nums, -1, dp, 0);\\n    }\\n    public int getLIS(int[]arr, int prev, int[][]dp, int i){\\n        if(i == arr.length) return 0;\\n        if(prev != -1 && dp[prev][i] != -1) return dp[prev][i];\\n        \\n        int max = Integer.MIN_VALUE, inc = Integer.MIN_VALUE;\\n        \\n        if(prev == -1 || arr[i] > arr[prev]) inc = 1 + getLIS(arr, i, dp, i+1);\\n        int ign = getLIS(arr, prev, dp, i+1);\\n        \\n        if(prev != -1) return dp[prev][i] = Math.max(inc, ign);\\n        return Math.max(inc, ign);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[][]dp = new int[arr.length + 1][arr.length + 1];\\n        \\n        for(int i = arr.length-1; i >= 0; i--){\\n            for(int prev = i-1; prev >= -1; prev--){    // as prev can start from i-1 as it is previous of current element\\n                int inc = Integer.MIN_VALUE;\\n        \\n                if(prev == -1 || arr[i] > arr[prev]) inc = 1 + dp[i+1][i+1];\\n                int ign = dp[i+1][prev+1];\\n\\n                dp[i][prev+1] = Math.max(inc, ign);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[]pre = new int[arr.length + 1];\\n        \\n        for(int i = arr.length-1; i >= 0; i--){     // as prev can start from i-1 as it is previous of current element\\n            int[]curr = new int[arr.length + 1];\\n            for(int prev = i-1; prev >= -1; prev--){\\n                int inc = Integer.MIN_VALUE;\\n        \\n                if(prev == -1 || arr[i] > arr[prev]) inc = 1 + pre[i+1];\\n                int ign = pre[prev+1];\\n\\n                curr[prev+1] = Math.max(inc, ign);\\n            }\\n            pre = curr;\\n        }\\n        return pre[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int amax = 1;\\n        int[]dp = new int[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            int max = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[j] < arr[i]) max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = max+1;\\n            amax = Math.max(amax, dp[i]);\\n        }    \\n        return amax;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        List<Integer>al = new ArrayList<>();\\n        al.add(arr[0]);\\n        for(int i=1; i<arr.length; i++){\\n            if(arr[i] > al.get(al.size()-1)) al.add(arr[i]);\\n            else{\\n                int j = binSearch(al, arr[i]);\\n                al.set(j, arr[i]);\\n            }\\n        }\\n        return al.size();\\n    }\\n    public int binSearch(List<Integer>al, int val){\\n        int lo = 0;\\n        int hi = al.size()-1;\\n        while(hi > lo){\\n            int mid = lo + (hi-lo)/2;\\n            if(al.get(mid) < val) lo = mid+1;\\n            else hi = mid;\\n        }\\n        return hi;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        String amax = Integer.toString(arr[0]);\\n        String[]dp = new String[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            String val = Integer.toString(arr[i]);\\n            String max = val;\\n            for(int j=0; j<i; j++) if(arr[j] < arr[i] && dp[j].length() + 1 > max.length()) max = dp[j] +\", \"+ val;\\n            dp[i] = max;\\n            if(dp[i].length() > amax.length()) amax = dp[i];\\n        }    \\n        System.out.println(amax);\\n        return amax.split(\" \").length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int max = 1, lastidx = 0;\\n        \\n        int[]dp = new int[arr.length];\\n        Arrays.fill(dp,1);\\n        \\n        int[]hash = new int[arr.length];\\n        for(int i=0; i<arr.length; i++){\\n            hash[i] = i;\\n            for(int j=0; j<i; j++){\\n                if(arr[j] < arr[i] && dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    hash[i] = j;\\n                }\\n            }\\n            \\n            if(dp[i] > max){\\n                lastidx = i;\\n                max = dp[i];\\n            }\\n        }\\n        \\n        int[]ans = new int[max];\\n        int i = max-1;\\n        \\n        while(hash[lastidx] != lastidx){\\n            ans[i--] = arr[lastidx];\\n            lastidx = hash[lastidx];\\n        }\\n        ans[0] = arr[lastidx];\\n        \\n        for(int val:ans) System.out.print(val + \" \");\\n        System.out.println();\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395728,
                "title": "java-easy-solution-using-arraylist",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n       \\n        ArrayList<Integer> lis = new ArrayList<>();\\n        \\n        for(int num:nums){\\n            \\n            int size = lis.size();\\n            \\n            if(size==0 ||size>0 && num>lis.get(size-1)){\\n                lis.add(num);\\n            }else{\\n                int insertIndex = bs(lis,num);\\n                lis.set(insertIndex,num);\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int bs(List<Integer> list, int target){\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        \\n        while(lo<hi){\\n            int mid = (lo+hi)/2;\\n            if(list.get(mid)<target){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n       \\n        ArrayList<Integer> lis = new ArrayList<>();\\n        \\n        for(int num:nums){\\n            \\n            int size = lis.size();\\n            \\n            if(size==0 ||size>0 && num>lis.get(size-1)){\\n                lis.add(num);\\n            }else{\\n                int insertIndex = bs(lis,num);\\n                lis.set(insertIndex,num);\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int bs(List<Integer> list, int target){\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        \\n        while(lo<hi){\\n            int mid = (lo+hi)/2;\\n            if(list.get(mid)<target){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164156,
                "title": "python-dp",
                "content": "\\n### 300 Longest Increacing Sequence\\n```\\n> \\u7C7B\\u578B\\uFF1A\\u4E00\\u7EF4DP\\n> Time Complexity O(N^2)\\n> Space Complexity O(N)\\n```\\n\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/300.jpeg)\\n\\n```python\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        dp = [1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        \\n        return max(dp)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1A\\u4E00\\u7EF4DP\\n> Time Complexity O(N^2)\\n> Space Complexity O(N)\\n```\n```python\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        dp = [1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        \\n        return max(dp)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 74991,
                "title": "c-o-nlogn-with-explanation-and-references",
                "content": "**Explanation**\\n\\n`tails[i]` stores the Longest Increasing Subsequence of length `i+1`, of which the last element is `tails[i]`. If `tails[i]` can be of multiple values, the minimum will be taken.\\n\\nSo that we have `tails[0] <= tails[1] <= tails[2] <= ... <= tails[N - 1]`.\\n\\nScan the array from beginning to the end. When an new element is met, either of following cases will happen: (And this is how we construct the `tails` array)\\n\\n1. The new element is larger than the tail of the longest LIS, i.e., `n > tails.back()`, then we have found a longer LIS which tail is `n`;\\n\\n2. The new element is no larger than the tail of the longest LIS, but it's smaller than the tail of a \"not-so-long\" subsequence, then we update the tail of the \"not-so-long\" subsequence to the smaller one. Because the tail has become smaller, this will allow us to extend the subsequence longer later if we find a value `n <= current_tail && n > new_tail`.\\n\\nSo the entire problem becomes searching for a value in a sorted array. The best way? Binary search.\\n\\n**Code**\\n\\n    #include <vector>\\n    #include <algorithm>\\n    \\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n      int lengthOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n          return 0;\\n        vector<int> tails;\\n        tails.reserve(nums.size());\\n        tails.push_back(nums.front());\\n    \\n        for (size_t i = 1; i < nums.size(); ++i) {\\n          const int& n = nums[i];\\n          auto iter = lower_bound(tails.begin(), tails.end(), n);\\n          if (iter == tails.end())\\n            tails.push_back(n);\\n          else if (n < *iter)\\n            *iter = n;\\n        }\\n        return tails.size();\\n      }\\n    };\\n\\n\\n**Reference**\\n\\nYou can find many external links on [Longest increasing subsequence from Wikipedia](https://en.wikipedia.org/wiki/Longest_increasing_subsequence), but the explanation is not easy to understand.\\n\\n[Longest Increasing Subsequence on Algorithmist](http://www.algorithmist.com/index.php/Longest_Increasing_Subsequence) gives better explanation. Take a look if you need help.",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n      int lengthOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n          return 0;\\n        vector<int> tails;\\n        tails.reserve(nums.size());\\n        tails.push_back(nums.front());\\n    \\n        for (size_t i = 1; i < nums.size(); ++i) {\\n          const int& n = nums[i];\\n          auto iter = lower_bound(tails.begin(), tails.end(), n);\\n          if (iter == tails.end())\\n            tails.push_back(n);\\n          else if (n < *iter)\\n            *iter = n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1306565,
                "title": "longest-increasing-subsequence-to-longest-common-subsequence",
                "content": "If we closely observe the problem then we can convert this problem to longest Common Subsequence Problem. Firstly we will create another array of unique elements of original array and sort it. Now the longest increasing subsequence of our array must be present as a subsequence in our sorted array. That\\u2019s why our problem is now reduced to finding the common subsequence between the two arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    int lcs(int x, int y, vector<int>& s1, vector<int>& s2)\\n    {\\n        int dp[x+1][y+1];\\n        \\n        for(int i = 0; i <= x; i++)\\n        {\\n            dp[i][0] = 0;\\n        }\\n        \\n        for(int j = 0; j <= y; j++)\\n        {\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1; i <= x; i++)\\n        {\\n            for(int j = 1; j <= y; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[x][y];\\n    }\\n\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> revNums = nums;\\n        \\n        // sort the array\\n        sort(revNums.begin(),revNums.end());\\n        \\n        // remove duplicates\\n        vector<int>::iterator ip = unique(revNums.begin(),revNums.end());\\n        revNums.erase(ip,revNums.end());\\n        int m = revNums.size();\\n        \\n        return lcs(n,m,nums,revNums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(int x, int y, vector<int>& s1, vector<int>& s2)\\n    {\\n        int dp[x+1][y+1];\\n        \\n        for(int i = 0; i <= x; i++)\\n        {\\n            dp[i][0] = 0;\\n        }\\n        \\n        for(int j = 0; j <= y; j++)\\n        {\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1; i <= x; i++)\\n        {\\n            for(int j = 1; j <= y; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[x][y];\\n    }\\n\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> revNums = nums;\\n        \\n        // sort the array\\n        sort(revNums.begin(),revNums.end());\\n        \\n        // remove duplicates\\n        vector<int>::iterator ip = unique(revNums.begin(),revNums.end());\\n        revNums.erase(ip,revNums.end());\\n        int m = revNums.size();\\n        \\n        return lcs(n,m,nums,revNums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738719,
                "title": "python-o-n-2-dp-with-a-detailed-explanation-for-first-timers",
                "content": "Before I explain, please know that dynamic programming is hard. It took multiple tries for me to arrive at my solution.\\n\\nFirst, we need to know what the definition of an increasing subsequence is. Given a list like [a, b, c] where a < b, but c < b and a < c, there exist two valid increasing subsequences: [a, b] and [a, c]. This means that a subsequence need not be contiguous.\\n\\nLet\\'s look at a small example, say [3, 5, 4, 101, 9, 18]. Here, the longest increasing subsequence is 3, 4, 9, 18] and the length is 4. If we just try to solve our problem from front to back, starting at 3 and going forward, we have a problem where we don\\'t know whether or not to include the 5 as opposed to the 4. This becomes complicated.\\n\\nSo, let\\'s think of how to break this problem down into smaller ones we know. We know for a fact that given an increasing subsequence [b, c, d, e], if an element a where a < b comes before the subsequence [b, c, d, e], [a, b, c, d, e] must also be an increasing subsequence. So, given smaller increasing subsequences that start from the right of the list instead of the left, we can build upon smaller subsequences which we know are in fact increasing.\\n\\nGoing back to our [3, 5, 4, 101, 9, 18] example: let\\'s start from the right. [18] is it\\'s own longest increasing subsequence. The length is 1. This applies to any singular increasing subsequence. [3], [5], [4], [101], [9], [18] are all valid. So, the base case here is of length 1. We initialize an array called res of [1, 1, 1, 1, 1, 1]. Shifting one over to the left, we see [9, 18]. Since 9 < 18, the longest increasing subsequence starting at 9 must be max(res[4], res[5]+1). We either keep the current recorded one if it\\'s greater, or replace the current longest subsequence for that index with the one we discussed [9, 18]. Next is 101. 101 is not less than any of the elements that come after it, so the longest subsequence starting at this index is just 1. Next is 4. Since 4 < 9, we can just add 1 to what is in res[4], which results in 3. Next is 5. 5 < 9, so we add 1 to what is in res[4], which is also 3. Next is 3. Since 3 < 5, we add whatever is in res[1] to 1, and we get 4.\\n\\nHopefully, the logic above makes sense. Please go through it on paper to get the recurrence relation. Note that we don\\'t stop when we replace the element in the array. You have to go through the entire array to make sure that what you have recorded is indeed the largest length. At the end, we return the largest of the ones we recorded.\\n\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        res = [1]*len(nums)\\n        res[-1] = 1\\n        for i in reversed(range(len(nums))):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] < nums[j]:\\n                    res[i] = max(res[i], res[j] + 1)\\n        return max(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        res = [1]*len(nums)\\n        res[-1] = 1\\n        for i in reversed(range(len(nums))):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] < nums[j]:\\n                    res[i] = max(res[i], res[j] + 1)\\n        return max(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1636162,
                "title": "java-binary-search-stepwise-explanation",
                "content": "**Intuition**\\nIf we iterate through the entire array left to right and make the most compact increasing array, then we can get the longest increasing subsequence. Compactness can be described by the following example:\\n\\n[1,2,3,4,5] is more compact than [1,10,15,20,30]\\n\\nThe idea is that we want to fill our subsequence with smallest numbers possible so that when comes the next number, we can simply append it to the end of the subsequence.\\n\\n**Implementation**\\n1. Initially we make a new array, let the name be I[], initially all the values of the array are\\ninfinite, only the 0th element contains negative infinite. The size of I[] will be total\\nelements in the sequence + 1.\\n\\n2. We iterate from left and we pick the numbers from Sequence one by one and insert them\\ninto I[]. When inserting a number, we find the position where all the numbers in left are\\nstrictly smaller than the number.\\n3. If we insert the numbers in this fashion, if you think a while, you will find that the\\nnumbers in I[] will always be in ascending order.\\n4. And another important thing is that, if a number is inserted into the ith place, and all the\\nnumbers from 1st place to (i-1)th place are smaller than that, so, the L[] value of that\\nnumber should be i. It can be proved inductively. \\n\\n**Time Complexity**\\n**O(nlogn)** We use binary search for n numbers.\\n\\n**Space Complexity**\\n**O(n)** We use an array to store the LIS\\n\\n```\\nclass Solution {\\n    public int findInsertionIndex(int[] nums, int val) {\\n        // find the greatest index < nums.\\n        int l = 0;\\n        int r = nums.length - 1;\\n        int res = nums.length;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < val) {\\n                res = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return res + 1;\\n    }\\n    public int lengthOfLIS(int[] nums) {\\n        int res = 0;\\n        int n = nums.length;\\n        int[] seq = new int[n + 1];\\n        Arrays.fill(seq, Integer.MAX_VALUE);\\n        seq[0] = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            int cur = nums[i];\\n\\n            int insertIndex = findInsertionIndex(seq, cur);\\n            res = Math.max(res, insertIndex);\\n\\n            if (seq[insertIndex] >= cur) {\\n                seq[insertIndex] = cur;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findInsertionIndex(int[] nums, int val) {\\n        // find the greatest index < nums.\\n        int l = 0;\\n        int r = nums.length - 1;\\n        int res = nums.length;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < val) {\\n                res = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return res + 1;\\n    }\\n    public int lengthOfLIS(int[] nums) {\\n        int res = 0;\\n        int n = nums.length;\\n        int[] seq = new int[n + 1];\\n        Arrays.fill(seq, Integer.MAX_VALUE);\\n        seq[0] = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            int cur = nums[i];\\n\\n            int insertIndex = findInsertionIndex(seq, cur);\\n            res = Math.max(res, insertIndex);\\n\\n            if (seq[insertIndex] >= cur) {\\n                seq[insertIndex] = cur;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74993,
                "title": "c-clean-o-nlogn-code-using-binary-search",
                "content": "    class Solution {\\n    public:\\n        int lengthOfLIS(vector<int>& nums) {\\n            vector<int> LIS;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (LIS.size() == 0 || LIS[LIS.size() - 1] < nums[i]) {\\n                    LIS.push_back(nums[i]);\\n                }\\n                else {\\n                    int l = 0, r = LIS.size() - 1;\\n                    while (l < r) {\\n                        int m = (l + r) / 2;\\n                        if (LIS[m] >= nums[i]) {\\n                            r = m;\\n                        }\\n                        else {\\n                            l = m + 1;\\n                        }\\n                    }\\n                    LIS[l] = nums[i];\\n                }\\n            }\\n            return LIS.size();\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int lengthOfLIS(vector<int>& nums) {\\n            vector<int> LIS;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (LIS.size() == 0 || LIS[LIS.size() - 1] < nums[i]) {\\n                    LIS.push_back(nums[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1680012,
                "title": "javascript-dp-solution-with-written-intuition",
                "content": "Time: `O(n^2)` - nested loops of length `n`\\nSpace: `O(n)` - single array of length `n`\\n\\nStrategy and Intuition:\\n\\n1) The longest increasing subsequence (LIS) at any point is at least 1.\\n\\t* Take the example `[10, 9, 2]`.  At every index, we can\\'t do any worse than 1.\\n\\n2) To figure out if we can do better than 1, we\\'ll need to compare two numbers.  This sets the grounds for using two loops to compare `nums[i]` against `nums[j]`.\\n\\n3) If we find that `nums[j] < nums[i]`, we may have found a *longer* increasing subsequence at index `i`.\\n\\t* In plain English, the current num at `i` is greater than the prev num at `j`.  Update the LIS at `i` if the LIS at `j` plus 1 is greater than it.\\n\\t* In Javascript, `Math.max(dp[i], dp[j]+1);`\\n\\n4) To be able to refer back to previously calculated LIS answers, we\\'ll need to save them somewhere.  This is the basis of our `dp` array.\\n\\nI hope this helps!\\n```\\nconst lengthOfLIS = (nums) => {\\n\\tlet dp = new Array(nums.length).fill(1);\\n\\tlet longest = 1;\\n\\tfor (let i = 1; i < nums.length; i++) {\\n\\t\\tfor (let j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[j] < nums[i]) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j]+1);\\n\\t\\t\\t\\tlongest = Math.max(longest, dp[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn longest;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst lengthOfLIS = (nums) => {\\n\\tlet dp = new Array(nums.length).fill(1);\\n\\tlet longest = 1;\\n\\tfor (let i = 1; i < nums.length; i++) {\\n\\t\\tfor (let j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[j] < nums[i]) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j]+1);\\n\\t\\t\\t\\tlongest = Math.max(longest, dp[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173042,
                "title": "python-solution",
                "content": "O(n**2) time, O(n) space:\\n```\\n        if not nums:\\n            return 0\\n        rec = [1] * len(nums) # rec[i] records the length of the longest increasing subsequence ending with nums[i]\\n        maxlen = 1\\n        for i in range(1, len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[j] < nums[i]:\\n                    rec[i] = max(rec[i], rec[j] + 1)\\n            maxlen = max(maxlen, rec[i])\\n        return maxlen\\n```\\nO(n log n) time, O(n) space:\\n\\nIdea: As we traverse `nums`, maintain a sequence `rec` that has the same length as the longest increasing subsequence so far. To do this, every time we reach some `nums[i]`, we do a binary search on `rec`, if the returned `index = len(rec)`, we append `nums[i]` to rec; Otherwise we replace `rec[index]` by `nums[index]`. After we finish traversing `nums`, `rec` will have the same length as the longest increasing subsequence of `nums`. \\n\\nE.g., `nums = [10, 9, 2, 5, 3, 7, 4, 18]`. Initialize `rec = []`. Now as `i` goes from `0` to `7`, `rec` changes as follows: \\n`i = 0: rec = [10]; `\\n`i = 1: rec = [9]; `\\n`i = 2: rec = [2]; `\\n`i = 3: rec = [2, 5]; `\\n`i = 4: rec = [2, 3]; `\\n`i = 5: rec = [2, 3, 7];` \\n`i = 6: rec = [2, 3, 4];` \\n`i = 7: rec = [2, 3, 4, 18].` \\nThe length of the longest increasing subsequence is therefore `4`.\\n\\nCaveat: this algorithm is only useful for getting the length of the longest increasing subsequence, but cannot be used to retrieve the actual subsequence that achieves this length. In order to get the solution of the problem that achieves the maximal value, one needs to resort to the O(n**2) algorithm.\\n```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def bSearch(arr, target):\\n            i = 0\\n            j = len(arr)\\n            while i < j:\\n                mid = (i+j) / 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] < target:\\n                    i = mid+1\\n                else:\\n                    j = mid\\n            return i\\n                \\n        if not nums:\\n            return 0\\n        rec = [nums[0]]\\n        for i in range(1, len(nums)):\\n            index = bSearch(rec, nums[i])\\n            if index == len(rec):\\n                rec.append(nums[i])\\n            else:\\n                rec[index] = nums[i]\\n        return len(rec)\\n```",
                "solutionTags": [],
                "code": "```\\n        if not nums:\\n            return 0\\n        rec = [1] * len(nums) # rec[i] records the length of the longest increasing subsequence ending with nums[i]\\n        maxlen = 1\\n        for i in range(1, len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[j] < nums[i]:\\n                    rec[i] = max(rec[i], rec[j] + 1)\\n            maxlen = max(maxlen, rec[i])\\n        return maxlen\\n```\n```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def bSearch(arr, target):\\n            i = 0\\n            j = len(arr)\\n            while i < j:\\n                mid = (i+j) / 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] < target:\\n                    i = mid+1\\n                else:\\n                    j = mid\\n            return i\\n                \\n        if not nums:\\n            return 0\\n        rec = [nums[0]]\\n        for i in range(1, len(nums)):\\n            index = bSearch(rec, nums[i])\\n            if index == len(rec):\\n                rec.append(nums[i])\\n            else:\\n                rec[index] = nums[i]\\n        return len(rec)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328480,
                "title": "java-solution-2-approach-dp-o-n-2-binary-search-o-nlogn",
                "content": "**Approach 1, using DP**\\n```\\n// O(N^2) Time | O(N) Space\\npublic static int lengthOfLIS1(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tArrays.fill(dp, 1);\\n\\tint ans = 1;\\n\\n\\tfor (int i = 1; i < dp.length; i++) {\\n\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j] + 1);\\n\\t\\t\\t}\\n\\t\\t\\tans = Math.max(ans, dp[i]);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n**Approach 2, using Binary search**\\n \\n```\\t\\n// O(NlogN) Time | O(N) Space\\npublic int lengthOfLIS(int[] nums) {\\n\\n\\tArrayList<Integer> sublist = new ArrayList<>();\\n\\tsublist.add(nums[0]);\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tint curr = nums[i];\\n\\n\\t\\t// if current element is greater than max value in sublist, add it in sublist\\n\\t\\tif (curr > sublist.get(sublist.size() - 1)) {\\n\\t\\t\\tsublist.add(curr);\\n\\t\\t} else {\\n\\t\\t\\t// replace with smallest element that is greater than or equal to curr\\n\\t\\t\\tint positionToInsert = binarySearch(sublist, curr);\\n\\t\\t\\tsublist.set(positionToInsert, curr);\\n\\t\\t}\\n\\t}\\n\\n\\treturn sublist.size();\\n}\\n\\nprivate int binarySearch(ArrayList<Integer> sublist, int curr) {\\n\\tint left = 0, right = sublist.size() - 1;\\n\\n\\twhile (left < right) {\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tif (sublist.get(mid) == curr) {\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\tif (sublist.get(mid) > curr) {\\n\\t\\t\\tright = mid;\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn left;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n// O(N^2) Time | O(N) Space\\npublic static int lengthOfLIS1(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tArrays.fill(dp, 1);\\n\\tint ans = 1;\\n\\n\\tfor (int i = 1; i < dp.length; i++) {\\n\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j] + 1);\\n\\t\\t\\t}\\n\\t\\t\\tans = Math.max(ans, dp[i]);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\t\\n// O(NlogN) Time | O(N) Space\\npublic int lengthOfLIS(int[] nums) {\\n\\n\\tArrayList<Integer> sublist = new ArrayList<>();\\n\\tsublist.add(nums[0]);\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tint curr = nums[i];\\n\\n\\t\\t// if current element is greater than max value in sublist, add it in sublist\\n\\t\\tif (curr > sublist.get(sublist.size() - 1)) {\\n\\t\\t\\tsublist.add(curr);\\n\\t\\t} else {\\n\\t\\t\\t// replace with smallest element that is greater than or equal to curr\\n\\t\\t\\tint positionToInsert = binarySearch(sublist, curr);\\n\\t\\t\\tsublist.set(positionToInsert, curr);\\n\\t\\t}\\n\\t}\\n\\n\\treturn sublist.size();\\n}\\n\\nprivate int binarySearch(ArrayList<Integer> sublist, int curr) {\\n\\tint left = 0, right = sublist.size() - 1;\\n\\n\\twhile (left < right) {\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tif (sublist.get(mid) == curr) {\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\tif (sublist.get(mid) > curr) {\\n\\t\\t\\tright = mid;\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326780,
                "title": "c-clean-easy-o-n-2-and-o-n-log-n-solutions",
                "content": "**Solution I:**\\n\\n**Approach:**\\nCreate a `1D` array `lis[]` of size `n` with all values initialised with `0`. Iterate for each element from index `0 to N-1`.\\n\\nFor each element, iterate elements with indices lesser than current element in a nested loop. In the nested loop, if the element\\u2019s value is less than the current element, assign `lis[i]` with `lis[j] + 1` if and only if `lis[j] + 1` is greater than `lis[i]` otherwise assign it with `1` since `minimum size of any subsequence` has to be `1`.\\n\\nNow, find the maximum element in the `1D array lis`.\\n\\n**Time Complexity**: `O(n^2)`\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Approach 1: Time Complexity = O(n^2)\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int lis[n];\\n        memset(lis, 0, sizeof(lis));\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                lis[i] = 1;\\n            else{\\n                for(int j = 0; j < i; j++){\\n                    if(nums[j] < nums[i])\\n                        lis[i] = max(lis[i], lis[j] + 1);\\n                    else\\n                        lis[i] = max(lis[i], 1);    \\n                }\\n            }\\n            max_1 = max(max_1, lis[i]);\\n        }\\n        return max_1;\\n    }\\n};\\n```\\n\\n**Solution II:**\\n\\n**Approach:**\\nWe know that if ```i == 0```, we can directly push this number into the vector as minimum size of increasing subsequence has to be ```1```. For further iterations, try to find a number which is just greater than or equal to ```nums[i]``` present in the vector ```v``` which can be done directly using ```lower_bound``` function. If we cannot find any such number, push it into the vector (shows increase). Otherwise, just overwrite it with the ```lower number i.e., nums[i]```. Why are we overwriting the existing index? Because it increases our chances of getting a larger increasing subsequence.  We can observe this using various examples.\\n\\n**Example:**\\n```10, 9, 2, 4, 5```\\nHere, if we push ```10```, we cannot include any numbers further.\\nIf we push ```9```, same as above.\\nBut, if we push ```2```, now we can also add ```4``` and ```5``` to it.\\nThus, creating a larger increasing sequence ```2, 4, 5```.\\n\\n**Example:**\\n```[2,5,3,7,10,8,11]```\\n\\n**Some Iterations:**\\n```\\n2 \\n2 5 \\n2 3 \\n2 3 7 \\n2 3 7 10 \\n2 3 7 8 \\n2 3 7 8 11  \\n```\\n\\n\\nAfter this, just return the ```size of vector```.\\nTime Complexity of ```lower_bound``` function is ```O(log(n))```\\nThus, Final **Time Complexity**: ```O(n*log(n))```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Approach 2: Time Complexity = O(n * log(n))\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                v.push_back(nums[i]);\\n            else{\\n                auto x = lower_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n                if(x >= v.size())\\n                    v.push_back(nums[i]);\\n                else\\n                v[x] = nums[i];\\n            }    \\n        }\\n        return v.size();\\n    }\\n};\\n```\\n\\n**Please feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Approach 1: Time Complexity = O(n^2)\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int lis[n];\\n        memset(lis, 0, sizeof(lis));\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                lis[i] = 1;\\n            else{\\n                for(int j = 0; j < i; j++){\\n                    if(nums[j] < nums[i])\\n                        lis[i] = max(lis[i], lis[j] + 1);\\n                    else\\n                        lis[i] = max(lis[i], 1);    \\n                }\\n            }\\n            max_1 = max(max_1, lis[i]);\\n        }\\n        return max_1;\\n    }\\n};\\n```\n```i == 0```\n```1```\n```nums[i]```\n```v```\n```lower_bound```\n```lower number i.e., nums[i]```\n```10, 9, 2, 4, 5```\n```10```\n```9```\n```2```\n```4```\n```5```\n```2, 4, 5```\n```[2,5,3,7,10,8,11]```\n```\\n2 \\n2 5 \\n2 3 \\n2 3 7 \\n2 3 7 10 \\n2 3 7 8 \\n2 3 7 8 11  \\n```\n```size of vector```\n```lower_bound```\n```O(log(n))```\n```O(n*log(n))```\n```\\nclass Solution {\\npublic:\\n    \\n    //Approach 2: Time Complexity = O(n * log(n))\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                v.push_back(nums[i]);\\n            else{\\n                auto x = lower_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n                if(x >= v.size())\\n                    v.push_back(nums[i]);\\n                else\\n                v[x] = nums[i];\\n            }    \\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74939,
                "title": "java-short-nlogn-treeset-solution",
                "content": "  Based on [http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/][1]\\n\\n    public int lengthOfLIS (int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i : nums) {\\n            Integer ceil = set.ceiling(i);\\n            if(null != ceil) {\\n                set.remove(ceil);\\n            }\\n            set.add(i);\\n        }\\n        return set.size();\\n    }\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "solutionTags": [
                    "Java"
                ],
                "code": "  Based on [http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/][1]\\n\\n    public int lengthOfLIS (int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i : nums) {\\n            Integer ceil = set.ceiling(i);\\n            if(null != ceil) {\\n                set.remove(ceil);\\n            }\\n            set.add(i);\\n        }\\n        return set.size();\\n    }\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "codeTag": "Unknown"
            },
            {
                "id": 2396663,
                "title": "c-all-approaches-print-lis-100",
                "content": "\\uD83D\\uDC48 Please Upvote if you find helpful \\u2764\\n\\n Approach **1**)  **Recursive + Memoization**  \\n \\n**Time Complexity** :  `O(n^2)`\\n**Space Complexity** : `O(n^2)` + Recursion Stack Space `O(n)`\\n```\\nclass Solution {                     \\npublic:\\n\\n\\t// Recursive Approach + Memoization\\n\\t\\n    vector<vector<int>> dp;\\n  \\n    int solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i == nums.size()) return 0;\\n            \\n        if(dp[i][prev+1] != -1) return dp[i][prev+1];\\n        \\n        int not_take = solve(nums, i+1, prev);\\n        \\n        int take = 0;\\n        if(prev == -1 || nums[i]>nums[prev])\\n            take = 1 + solve(nums, i+1, i);\\n               \\n        return dp[i][prev+1] = max(take, not_take);\\n    }\\n    \\n\\tint lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\tdp = vector<vector<int>> (n, vector<int> (n+1, -1));\\n        return solve(nums, 0, -1);\\n\\t\\t}\\n\\t};\\n```\\n\\n\\nApproach **2**) **Tabulation Method** (more space optimized than recursive approach)\\n\\n**Time Complexity** :  `O(n^2)`\\n**Space Complexity** : `O(n^2)` \\n```\\nclass Solution {                    \\npublic:\\n\\t \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// Tabulation\\n        dp = vector<vector<int>> (n+1, vector<int> (n+1, 0));\\n\\t\\t\\n        for(int i=n-1; i>=0; i--)\\n            for(int prev = i-1; prev>=-1; prev--)\\n            {\\n                int not_take = dp[i+1][prev+1];\\n                \\n                int take = 0;\\n                if(prev == -1 || nums[i]>nums[prev])\\n                take = 1 + dp[i+1][i+1];\\n                \\n                dp[i][prev+1] = max(take,not_take);\\n            }\\n        \\n          return dp[0][0];\\n\\t\\t}\\n\\t};\\n```\\n\\n\\nApproach **3**)  **More Space optimized than Tabulation Method**\\n\\n**Time Complexity** :  `O(n^2)`\\n**Space Complexity** : `O(n)` \\n```\\nclass Solution {                    \\npublic:\\n\\t \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// Space Optimized\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]>nums[j]) dp[i] = max(dp[i], 1 + dp[j]);\\n                maxi = max(maxi, dp[i]);\\n            }\\n        \\n        return maxi;\\n\\t\\t}\\n\\t};\\n```\\n\\nApproach **4**) **Binary Search Method** (most optimized method among all)\\n\\n**Time Complexity** :  `O(nlog(n))`\\n**Space Complexity** : `O(n)` \\n```\\nclass Solution {          \\npublic:\\n\\n\\t int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t //Binary Search\\n        vector<int> v; //it doesn\\'t store LIS but it\\'s length equal to LIS\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n; i++)\\n        {\\n            int j = v.size();\\n            \\n            if(nums[i] > v[j-1]) v.push_back(nums[i]);\\n            else\\n            {\\n                int idx = lower_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n                if(idx<j) v[idx] = nums[i];\\n            }\\n        }\\n        \\n        return v.size();\\n    }\\n};\\n```\\n\\n**Print LIS by using Back Tracking**\\n```\\nclass Solution {\\npublic:\\n\\n\\t    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t     // Print LIS\\n\\t\\t \\n        vector<int> dp(n,1);\\n        vector<int> hash(n,0);\\n        for(int i=0; i<n; i++) hash[i] = i;\\n        int maxi = 1;\\n        int max_idx = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]>nums[j] &&  dp[i] < 1 + dp[j])\\n                {\\n                   dp[i] = 1 + dp[j];\\n                   hash[i] = j;\\n                }\\n            }   \\n            \\n            if(maxi < dp[i])\\n            {\\n                maxi = dp[i];\\n                max_idx = i;\\n            }\\n        }\\n        \\n        stack<int> ans;\\n        ans.push(nums[max_idx]);\\n        \\n        while(max_idx != hash[max_idx])\\n        {\\n            max_idx = hash[max_idx];\\n            ans.push(nums[max_idx]);\\n        }\\n        \\n        while(!ans.empty())\\n        {\\n            cout<<ans.top()<<\" \";\\n            ans.pop();\\n        }\\n        cout<<endl;\\n        \\n        return maxi;\\n\\t\\t}\\n};\\n        \\n```\\nPlease Upvote if you find helpful \\u2764",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {                     \\npublic:\\n\\n\\t// Recursive Approach + Memoization\\n\\t\\n    vector<vector<int>> dp;\\n  \\n    int solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i == nums.size()) return 0;\\n            \\n        if(dp[i][prev+1] != -1) return dp[i][prev+1];\\n        \\n        int not_take = solve(nums, i+1, prev);\\n        \\n        int take = 0;\\n        if(prev == -1 || nums[i]>nums[prev])\\n            take = 1 + solve(nums, i+1, i);\\n               \\n        return dp[i][prev+1] = max(take, not_take);\\n    }\\n    \\n\\tint lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\tdp = vector<vector<int>> (n, vector<int> (n+1, -1));\\n        return solve(nums, 0, -1);\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {                    \\npublic:\\n\\t \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// Tabulation\\n        dp = vector<vector<int>> (n+1, vector<int> (n+1, 0));\\n\\t\\t\\n        for(int i=n-1; i>=0; i--)\\n            for(int prev = i-1; prev>=-1; prev--)\\n            {\\n                int not_take = dp[i+1][prev+1];\\n                \\n                int take = 0;\\n                if(prev == -1 || nums[i]>nums[prev])\\n                take = 1 + dp[i+1][i+1];\\n                \\n                dp[i][prev+1] = max(take,not_take);\\n            }\\n        \\n          return dp[0][0];\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {                    \\npublic:\\n\\t \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// Space Optimized\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]>nums[j]) dp[i] = max(dp[i], 1 + dp[j]);\\n                maxi = max(maxi, dp[i]);\\n            }\\n        \\n        return maxi;\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {          \\npublic:\\n\\n\\t int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t\\t //Binary Search\\n        vector<int> v; //it doesn\\'t store LIS but it\\'s length equal to LIS\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n; i++)\\n        {\\n            int j = v.size();\\n            \\n            if(nums[i] > v[j-1]) v.push_back(nums[i]);\\n            else\\n            {\\n                int idx = lower_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n                if(idx<j) v[idx] = nums[i];\\n            }\\n        }\\n        \\n        return v.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\t    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\t\\t\\n\\t     // Print LIS\\n\\t\\t \\n        vector<int> dp(n,1);\\n        vector<int> hash(n,0);\\n        for(int i=0; i<n; i++) hash[i] = i;\\n        int maxi = 1;\\n        int max_idx = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]>nums[j] &&  dp[i] < 1 + dp[j])\\n                {\\n                   dp[i] = 1 + dp[j];\\n                   hash[i] = j;\\n                }\\n            }   \\n            \\n            if(maxi < dp[i])\\n            {\\n                maxi = dp[i];\\n                max_idx = i;\\n            }\\n        }\\n        \\n        stack<int> ans;\\n        ans.push(nums[max_idx]);\\n        \\n        while(max_idx != hash[max_idx])\\n        {\\n            max_idx = hash[max_idx];\\n            ans.push(nums[max_idx]);\\n        }\\n        \\n        while(!ans.empty())\\n        {\\n            cout<<ans.top()<<\" \";\\n            ans.pop();\\n        }\\n        cout<<endl;\\n        \\n        return maxi;\\n\\t\\t}\\n};\\n        \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2341224,
                "title": "4-approaches-recursion-memoization-tabulation-binary-search",
                "content": "Approaches used :-\\n1) Recursion + Memoization \\n2) Tabulation\\n3) Tabulation (Better Space Complexity)\\n4) Binary Search\\n\\n```\\nclass Solution {\\npublic:\\n    //RECURSION + MEMOIZATION\\n    int help(int ind , int prev ,vector<int>& arr,vector<vector<int>> &dp){\\n        if(ind == arr.size())return 0;\\n            \\n        if(dp[ind][prev+1] != -1){\\n            return dp[ind][prev+1];\\n        }\\n        \\n        int nottake = help(ind+1,prev,arr,dp);\\n        int take =0;\\n        if(prev==-1 || arr[ind]>arr[prev]){\\n            take = 1+help(ind+1,ind,arr,dp);\\n        }\\n        return dp[ind][prev+1]=max(nottake,take);\\n    }\\n     int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        //APPROACH 1\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return help(0,-1,nums,dp);\\n\\t\\t}\\n```\\nAPPROACH 2:- TABULATION\\n\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        //APPROACH 2\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int ind = n-1;ind>=0;ind--){\\n            for(int prev = ind-1;prev>=-1;prev--){\\n                \\n        int nottake = dp[ind+1][prev+1];\\n        int take =0;\\n        if(prev==-1 || nums[ind]>nums[prev]){\\n            take = 1+dp[ind+1][ind+1];\\n        }\\n        dp[ind][prev+1]=max(nottake,take);\\n            }\\n        }\\n        return dp[0][0];\\n\\t\\t}\\n        \\n```\\n\\nAPPROACH 3 :- TABULATION ( IMPROVED SPACE COMPLEXITY)\\n\\n```\\n int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t        //APPROACH 2 BETTER SPACE OPTIMIZATION\\n        vector<int> dp(n,1);\\n        int maxi=1;\\n        for(int ind = 1;ind<n;ind++){\\n            for(int prev =0;prev<ind;prev++){\\n                if(nums[ind] > nums[prev]){\\n                    dp[ind]=max(dp[ind],1+dp[prev]);\\n                }\\n             }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n        return maxi;\\n\\t\\t}\\n```\\n\\nAPPROACH 4 :- BINARY SEARCH (BEST TIME COMPLEXITY AMONG ALL OF THEM)\\n\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<int> temp;\\n        int len=1;\\n        temp.emplace_back(nums[0]);\\n        for(int i =1;i<n;i++){\\n            if(nums[i]>temp.back()){\\n            temp.emplace_back(nums[i]);\\n             len++;\\n            }else{\\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                temp[ind]=nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n```\\n\\nTime complexity for first 3 approaches is **T(C) = O(n^2)**\\nAnd For binary search it is **T(C) = O(n*log n)**\\n\\nNOTE:-\\nBUT MAKE A NOTE THAT IF YOU WISH TO PRINT THE SUBSEQUENCE YOU CAN ONLY DO THAT USING FIRST 3 METHODS AS WE ARE OVERWRITING THE ELEMENTS IN THE BINARY SEARCH JUST TO GET THE LENGTH IN BEST TIME COMPLEXITY.\\n\\nHope you understand this solution.\\nSuggestions are always welcomed ! :)\\nIf you like it please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //RECURSION + MEMOIZATION\\n    int help(int ind , int prev ,vector<int>& arr,vector<vector<int>> &dp){\\n        if(ind == arr.size())return 0;\\n            \\n        if(dp[ind][prev+1] != -1){\\n            return dp[ind][prev+1];\\n        }\\n        \\n        int nottake = help(ind+1,prev,arr,dp);\\n        int take =0;\\n        if(prev==-1 || arr[ind]>arr[prev]){\\n            take = 1+help(ind+1,ind,arr,dp);\\n        }\\n        return dp[ind][prev+1]=max(nottake,take);\\n    }\\n     int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        //APPROACH 1\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return help(0,-1,nums,dp);\\n\\t\\t}\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        //APPROACH 2\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int ind = n-1;ind>=0;ind--){\\n            for(int prev = ind-1;prev>=-1;prev--){\\n                \\n        int nottake = dp[ind+1][prev+1];\\n        int take =0;\\n        if(prev==-1 || nums[ind]>nums[prev]){\\n            take = 1+dp[ind+1][ind+1];\\n        }\\n        dp[ind][prev+1]=max(nottake,take);\\n            }\\n        }\\n        return dp[0][0];\\n\\t\\t}\\n        \\n```\n```\\n int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t        //APPROACH 2 BETTER SPACE OPTIMIZATION\\n        vector<int> dp(n,1);\\n        int maxi=1;\\n        for(int ind = 1;ind<n;ind++){\\n            for(int prev =0;prev<ind;prev++){\\n                if(nums[ind] > nums[prev]){\\n                    dp[ind]=max(dp[ind],1+dp[prev]);\\n                }\\n             }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n        return maxi;\\n\\t\\t}\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<int> temp;\\n        int len=1;\\n        temp.emplace_back(nums[0]);\\n        for(int i =1;i<n;i++){\\n            if(nums[i]>temp.back()){\\n            temp.emplace_back(nums[i]);\\n             len++;\\n            }else{\\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                temp[ind]=nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031963,
                "title": "python-o-n-log-n-solution",
                "content": "```\\nclass Solution:\\n    # Dynamic Programming with Binary Search\\n    # Time complexity : O(nlogn). Binary search takes nlogn time and it is called n times.\\n    # Space complexity : O(n). dp array of size n is used.\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # dp keeps some of the visited element in a sorted list, and its size is lengthOfLIS sofar.\\n        # It always keeps the our best chance to build a LIS in the future.\\n        dp = []\\n        for num in nums:\\n            i = bisect.bisect_left(dp, num)\\n            if i == len(dp):\\n                # If num is the biggest, we should add it into the end of dp.\\n                dp.append(num)\\n            else:\\n                # If num is not the biggest, we should keep it in dp and replace the previous num\\n                # in this position. Because even if num can\\'t build longer LIS directly, it can\\n                # help build a smaller dp, and we will have the best chance to build a LIS in the\\n                # future. All elements before this position will be the best(smallest) LIS sor far. \\n                dp[i] = num\\n        return len(dp)       \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    # Dynamic Programming with Binary Search\\n    # Time complexity : O(nlogn). Binary search takes nlogn time and it is called n times.\\n    # Space complexity : O(n). dp array of size n is used.\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # dp keeps some of the visited element in a sorted list, and its size is lengthOfLIS sofar.\\n        # It always keeps the our best chance to build a LIS in the future.\\n        dp = []\\n        for num in nums:\\n            i = bisect.bisect_left(dp, num)\\n            if i == len(dp):\\n                # If num is the biggest, we should add it into the end of dp.\\n                dp.append(num)\\n            else:\\n                # If num is not the biggest, we should keep it in dp and replace the previous num\\n                # in this position. Because even if num can\\'t build longer LIS directly, it can\\n                # help build a smaller dp, and we will have the best chance to build a LIS in the\\n                # future. All elements before this position will be the best(smallest) LIS sor far. \\n                dp[i] = num\\n        return len(dp)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 74970,
                "title": "o-1-space-o-n-log-n-time-short-solution-without-additional-memory-java",
                "content": "    public class Solution {\\n        public int lengthOfLIS(int[] nums) {\\n            int N = 0, idx, x;\\n            for(int i = 0; i < nums.length; i++) {\\n                x = nums[i];\\n                if (N < 1 || x > nums[N-1]) {\\n                    nums[N++] = x;\\n                } else if ((idx = Arrays.binarySearch(nums, 0, N, x)) < 0) {\\n                    nums[-(idx + 1)] = x;\\n                }\\n            }\\n            return N;\\n        }\\n    }\\n\\nRe-use the array given as input for storing the tails.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int lengthOfLIS(int[] nums) {\\n            int N = 0, idx, x;\\n            for(int i = 0; i < nums.length; i++) {\\n                x = nums[i];\\n                if (N < 1 || x > nums[N-1]) {\\n                    nums[N++] = x;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 74969,
                "title": "o-nlogn-and-o-n-2-java-solutions",
                "content": "   \\n\\n     public class Solution {\\n        // O(n^2) Solution\\n        public int lengthOfLIS(int[] nums) {\\n            int N = nums.length;\\n            if (N == 0) return 0;\\n            int[] dp = new int[N];\\n            Arrays.fill(dp, 1);\\n            int res = 1;\\n            for (int i = 1; i < N; i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (nums[j] < nums[i]) {\\n                        dp[i] = Math.max(dp[j] + 1, dp[i]);\\n                    }\\n                }\\n                res = Math.max(res, dp[i]);\\n            }\\n            return res;\\n        }\\n        // O(n^log(n)) Solution.\\n        // http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/\\n        public int lengthOfLIS(int[] nums) {\\n            if (nums.length == 0) return 0;\\n            int len = 0, N = nums.length;\\n            int[] tailTable = new int[N];   \\n            tailTable[len++] = nums[0];\\n            for (int i = 1; i < N; i++) {\\n                if (nums[i] < tailTable[0]) tailTable[0] = nums[i];\\n                else if (nums[i] > tailTable[len - 1]) tailTable[len++] = nums[i];\\n                else {\\n                    tailTable[binarySearch(tailTable, 0, len - 1, nums[i])] = nums[i];\\n                }\\n            }\\n            return len;\\n        }\\n        private int binarySearch(int[] tails, int start, int end, int target) {\\n            while (start < end) {\\n                int mid = start + (end - start)/2;\\n                if (tails[mid] >= target) end = mid;\\n                else start = mid + 1;\\n            }\\n            return end;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // O(n^2) Solution\\n        public int lengthOfLIS(int[] nums) {\\n            int N = nums.length;\\n            if (N == 0) return 0;\\n            int[] dp = new int[N];\\n            Arrays.fill(dp, 1);\\n            int res = 1;\\n            for (int i = 1; i < N; i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (nums[j] < nums[i]) {\\n                        dp[i] = Math.max(dp[j] + 1, dp[i]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1141609,
                "title": "the-art-of-cracking-dp-problems-from-recursion-to-dp",
                "content": "If you are still nervous about how to crack DP problems, like I was, please go through the art of cracking DP problems on this [link](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.)\\n\\n**Step 1** - Figure out the Recursive Relation\\n\\nAny problem at hand with two options can be visualized as Binary Tree. For example take an array [1, 2, 3, 0, 2]. To solve this problem we would iterate through the array using index i. \\nWe can either select the value for our longest subsequence or we can pass/ skip it. So Binary Tree visualization for it would be:\\n\\n i = 0, value = 1\\n ```\\n              Tree Node\\n\\t\\t        //        \\\\\\\\\\nselect value 1\\t\\t     skip value 1\\n\\nNow let\\'s use this recursion principle in our code below\\n```\\n\\n```\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        if (nums.length == 1)\\n            return 1;\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE);       \\n    }\\n    \\n    \\n    public int recursion(int[] nums, int idx, int prev){\\n        if (idx >= nums.length){\\n            return 0;\\n        }\\n        \\n        int curr = nums[idx];\\n        \\n        if (curr <= prev){\\n            return 0;    \\n        }\\n        \\n        // either select the idx\\n        int left = 1 + recursion(nums, idx+1, curr);\\n        \\n        // or don\\'t select the idx\\n        int right = recursion(nums, idx+1, prev);\\n        \\n        return Math.max(left, right);\\n        \\n        \\n    }\\n```\\n\\n**Step 2**: Recursion + Memoization\\n\\n```\\n\\npublic int lengthOfLIS(int[] nums) {\\n        \\n        if (nums.length == 1)\\n            return 1;\\n            \\n         int[] dp = new int[nums.length];\\n         Arrays.fill(dp, Integer.MIN_VALUE);\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE, dp);       \\n    }\\n    \\n    \\n    public int recursion(int[] nums, int idx, int prev, int[] dp){\\n        if (idx >= nums.length){\\n            return 0;\\n        }\\n        \\n        int curr = nums[idx];\\n        \\n        int left = 0, right = 0;\\n        // select the idx\\n        if (curr > prev){\\n            if (dp[idx] == Integer.MIN_VALUE)\\n               dp[idx] = 1 + recursion(nums, idx+1, curr, dp);\\n            left = dp[idx];\\n        }\\n        // or don\\'t select the idx\\n        right = recursion(nums, idx+1, prev, dp);\\n        \\n        return Math.max(left, right);\\n        \\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n              Tree Node\\n\\t\\t        //        \\\\\\\\\\nselect value 1\\t\\t     skip value 1\\n\\nNow let\\'s use this recursion principle in our code below\\n```\n```\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        if (nums.length == 1)\\n            return 1;\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE);       \\n    }\\n    \\n    \\n    public int recursion(int[] nums, int idx, int prev){\\n        if (idx >= nums.length){\\n            return 0;\\n        }\\n        \\n        int curr = nums[idx];\\n        \\n        if (curr <= prev){\\n            return 0;    \\n        }\\n        \\n        // either select the idx\\n        int left = 1 + recursion(nums, idx+1, curr);\\n        \\n        // or don\\'t select the idx\\n        int right = recursion(nums, idx+1, prev);\\n        \\n        return Math.max(left, right);\\n        \\n        \\n    }\\n```\n```\\n\\npublic int lengthOfLIS(int[] nums) {\\n        \\n        if (nums.length == 1)\\n            return 1;\\n            \\n         int[] dp = new int[nums.length];\\n         Arrays.fill(dp, Integer.MIN_VALUE);\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE, dp);       \\n    }\\n    \\n    \\n    public int recursion(int[] nums, int idx, int prev, int[] dp){\\n        if (idx >= nums.length){\\n            return 0;\\n        }\\n        \\n        int curr = nums[idx];\\n        \\n        int left = 0, right = 0;\\n        // select the idx\\n        if (curr > prev){\\n            if (dp[idx] == Integer.MIN_VALUE)\\n               dp[idx] = 1 + recursion(nums, idx+1, curr, dp);\\n            left = dp[idx];\\n        }\\n        // or don\\'t select the idx\\n        right = recursion(nums, idx+1, prev, dp);\\n        \\n        return Math.max(left, right);\\n        \\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754004,
                "title": "brute-force-dp-explained-thinking-process-must-read",
                "content": "I wanted to post all the solutions you may come up by intuition and how you would think about such question in an interview. If you find it helpful vote it up so we can help other leetcoders crack them!\\n\\n#### Intuition: Brute force\\nFirst of all, intuitively we can say \"Let\\'s generate all subsets of our set and return the longest increasing subset\".\\nThat will work but it will be too slow.\\nIt takes 2^n to generate all our subsets and then we have to run over our generated subsets and find the longest increasing.\\nSuch solution would take us:\\n2^n -> Generate all subsets\\nn * 2^n -> Run over all subsets, and then over each set (worst case longest set will be length of our initial list) to check if it\\'s increasing or not.\\n\\nTime Complexity: O(n * 2^n)\\n\\n**Code** (This solution will time out)\\n```\\ndef generate_all_subsequences(self, nums, sequence):\\n        if not nums:\\n            self.all_sequences.append([*sequence])\\n            return\\n        \\n        # We have a branching factor of 2, backtracking movement can either take or not take\\n        sequence.append(nums[0])\\n        self.generate_all_subsequences(nums[1:], sequence)\\n        \\n        # We backtrack to remove the last appended item\\n        sequence.pop()\\n        \\n        # Explor another possibility\\n        self.generate_all_subsequences(nums[1:], sequence)\\n        \\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        self.all_sequences = []\\n        self.generate_all_subsequences(nums, [])\\n        longest = 0\\n        \\n        # We can simply run over all subsets and see if they are increasing or not.\\n        for subset in self.all_sequences:\\n            is_increasing_subset = True\\n            for i in range(len(subset)):\\n                if i > 0 and subset[i] < subset[i - 1]:\\n                    is_increasing_subset = False\\n                    break\\n            \\n            if is_increasing_subset:\\n                longest = max(longest, len(subset))\\n            \\n        return longest\\n```\\n\\n#### Intuition: \\nOk, our brute force solution isn\\'t good enough. How can we optimize it?\\n2 Key points:\\n1. Don\\'t solve solutions you already solved (DP)\\n2. Nobody asked us to generate all subsets, but only to return the longest increasing subset (Don\\'t over compute in your solutions)\\n\\nWe can Take a list [10, 9, 2, 5] and compute every subset until the index i (0 <= i < n). \\nSo for example on index 0 our longest increasing subset going to be 1 (the number 10).\\nWhen we move to index 1 (number 9), we can either extend the subsequence, or again, be 1. So we check if 9 is bigger than 10, which it isn\\'t... so our result just going to be 1 (longest increasing subsequence is 1 until number 9). We do this operation for the whole array, comparing if we can add to an eariler subsequence or just take 1, we will compare our current index *i* with all previous indexes to check if we can add to *any* of the subsequences earlier.\\n\\nWe will run a nested for loop to do this, hence our time complexity will be O(n^2).\\nSpace complexity: O(n). We will use an auxilary table (dp table) to compute previous results..\\n\\n**Let\\'s code.**\\n\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        \\n        n = len(nums)\\n        dp = [1] * n # All initial subsets are of length 1\\n        \\n        \\n        for i in range(1, n): # No point over running index 0 at the beginning, it\\'s 1\\n            for j in range(i):\\n                if nums[i] > nums[j]: # we have an increasing subsequence\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n                \\n        return max(dp)\\n```\\n\\nFurther thinking:\\nWe could optimize by holding a variable for the longest subsequence seen, and it will prevent a max(dp).\\n\\nLet me know if this helped :)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef generate_all_subsequences(self, nums, sequence):\\n        if not nums:\\n            self.all_sequences.append([*sequence])\\n            return\\n        \\n        # We have a branching factor of 2, backtracking movement can either take or not take\\n        sequence.append(nums[0])\\n        self.generate_all_subsequences(nums[1:], sequence)\\n        \\n        # We backtrack to remove the last appended item\\n        sequence.pop()\\n        \\n        # Explor another possibility\\n        self.generate_all_subsequences(nums[1:], sequence)\\n        \\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        self.all_sequences = []\\n        self.generate_all_subsequences(nums, [])\\n        longest = 0\\n        \\n        # We can simply run over all subsets and see if they are increasing or not.\\n        for subset in self.all_sequences:\\n            is_increasing_subset = True\\n            for i in range(len(subset)):\\n                if i > 0 and subset[i] < subset[i - 1]:\\n                    is_increasing_subset = False\\n                    break\\n            \\n            if is_increasing_subset:\\n                longest = max(longest, len(subset))\\n            \\n        return longest\\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        \\n        n = len(nums)\\n        dp = [1] * n # All initial subsets are of length 1\\n        \\n        \\n        for i in range(1, n): # No point over running index 0 at the beginning, it\\'s 1\\n            for j in range(i):\\n                if nums[i] > nums[j]: # we have an increasing subsequence\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n                \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 74954,
                "title": "5-lines-o-n-log-n-c-solution",
                "content": "Like most ACed solutions, we can use Binary Search to speed up the original O(n^2) DP solution.\\n\\n    // C++ Code\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int a : nums)\\n            if (ans.size() == 0 || a > ans.back()) ans.push_back(a);\\n            else *lower_bound(ans.begin(), ans.end(), a) = a;\\n        return ans.size();\\n    }\\n\\nRuntime = O(n log n).",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "Like most ACed solutions, we can use Binary Search to speed up the original O(n^2) DP solution.\\n\\n    // C++ Code\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int a : nums)\\n            if (ans.size() == 0 || a > ans.back()) ans.push_back(a);\\n            else *lower_bound(ans.begin(), ans.end(), a) = a;\\n        return ans.size();\\n    }\\n\\nRuntime = O(n log n).",
                "codeTag": "Unknown"
            },
            {
                "id": 1985439,
                "title": "recursion-memoization-tabulation-optimization-print-longest-increasing-subsequence",
                "content": "**Recursion**:\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        \\n        return help(0,-1,a);\\n    }\\n    public static int help(int i, int prev, int[] a){\\n        if(i == a.length) return 0;\\n        \\n        int notPick = help(i+1,prev,a);\\n        int pick = -1;\\n        if(prev == -1 || a[i] > a[prev]){\\n            pick = 1 + help(i+1,i,a);\\n        }\\n        return Math.max(pick,notPick);\\n    }\\n}\\n```\\n**Memoization**:\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[][] dp=new int[n][n+1];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        return help(0,-1,a,dp);\\n    }\\n    public static int help(int i, int prev, int[] a,int[][] dp){\\n        if(i == a.length) return 0;\\n        \\n        if(dp[i][prev+1] != -1) return dp[i][prev+1];\\n        \\n        int notPick = help(i+1,prev,a,dp);\\n        int pick = -1;\\n        if(prev == -1 || a[i] > a[prev]){\\n            pick = 1 + help(i+1,i,a,dp);\\n        }\\n        return dp[i][prev+1] = Math.max(pick,notPick);\\n    }\\n}\\n```\\n**Tabulation**:\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[][] dp=new int[n+1][n+1];\\n        for(int i=n-1; i>= 0; i--){\\n            for(int prev=i-1; prev >= -1; prev--){\\n                int notPick = dp[i+1][prev+1];\\n                int pick = -1;\\n                if(prev == -1 || a[i]>a[prev])\\n                    pick = 1 + dp[i+1][i+1];\\n                dp[i][prev+1] = Math.max(pick,notPick);\\n            }\\n        }\\n        return dp[0][0];\\n    } \\n}\\n\\n```\\n**Space Optimization:**\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[] dp=new int[n+1];\\n        for(int i=n-1; i>= 0; i--){\\n            int[] curr=new int[n+1];\\n            for(int prev=i-1; prev >= -1; prev--){\\n                int notPick = dp[prev+1];\\n                int pick = -1;\\n                if(prev == -1 || a[i]>a[prev])\\n                    pick = 1 + dp[i+1];\\n                curr[prev+1] = Math.max(pick,notPick);\\n            }\\n            dp=curr;\\n        }\\n        return dp[0];\\n    } \\n}\\n\\n```\\n**Another Approach:**\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[] dp=new int[n+1];\\n        Arrays.fill(dp,1);\\n        int[] hash=new int[n+1];\\n        int lastIndex = 0;\\n        int maxi = 1;\\n        for(int i=0; i<n; i++){\\n            hash[i] = i;\\n            for(int prev=0; prev<i; prev++){\\n                if(a[i] > a[prev] && 1+dp[prev] > dp[i]){\\n                    dp[i] = 1+dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        int[] result=new int[maxi];\\n        int index = maxi-1;\\n        result[index] = a[lastIndex];\\n        index--;\\n        while(lastIndex != hash[lastIndex]){\\n            lastIndex = hash[lastIndex];\\n            result[index] = a[lastIndex];\\n            index--;\\n        }\\n        \\n        for(int i: result) System.out.print(i+\" \");\\n        \\n        return maxi;\\n    } \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        \\n        return help(0,-1,a);\\n    }\\n    public static int help(int i, int prev, int[] a){\\n        if(i == a.length) return 0;\\n        \\n        int notPick = help(i+1,prev,a);\\n        int pick = -1;\\n        if(prev == -1 || a[i] > a[prev]){\\n            pick = 1 + help(i+1,i,a);\\n        }\\n        return Math.max(pick,notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[][] dp=new int[n][n+1];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        return help(0,-1,a,dp);\\n    }\\n    public static int help(int i, int prev, int[] a,int[][] dp){\\n        if(i == a.length) return 0;\\n        \\n        if(dp[i][prev+1] != -1) return dp[i][prev+1];\\n        \\n        int notPick = help(i+1,prev,a,dp);\\n        int pick = -1;\\n        if(prev == -1 || a[i] > a[prev]){\\n            pick = 1 + help(i+1,i,a,dp);\\n        }\\n        return dp[i][prev+1] = Math.max(pick,notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[][] dp=new int[n+1][n+1];\\n        for(int i=n-1; i>= 0; i--){\\n            for(int prev=i-1; prev >= -1; prev--){\\n                int notPick = dp[i+1][prev+1];\\n                int pick = -1;\\n                if(prev == -1 || a[i]>a[prev])\\n                    pick = 1 + dp[i+1][i+1];\\n                dp[i][prev+1] = Math.max(pick,notPick);\\n            }\\n        }\\n        return dp[0][0];\\n    } \\n}\\n\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[] dp=new int[n+1];\\n        for(int i=n-1; i>= 0; i--){\\n            int[] curr=new int[n+1];\\n            for(int prev=i-1; prev >= -1; prev--){\\n                int notPick = dp[prev+1];\\n                int pick = -1;\\n                if(prev == -1 || a[i]>a[prev])\\n                    pick = 1 + dp[i+1];\\n                curr[prev+1] = Math.max(pick,notPick);\\n            }\\n            dp=curr;\\n        }\\n        return dp[0];\\n    } \\n}\\n\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] a) {\\n        int n = a.length;\\n        int[] dp=new int[n+1];\\n        Arrays.fill(dp,1);\\n        int[] hash=new int[n+1];\\n        int lastIndex = 0;\\n        int maxi = 1;\\n        for(int i=0; i<n; i++){\\n            hash[i] = i;\\n            for(int prev=0; prev<i; prev++){\\n                if(a[i] > a[prev] && 1+dp[prev] > dp[i]){\\n                    dp[i] = 1+dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        int[] result=new int[maxi];\\n        int index = maxi-1;\\n        result[index] = a[lastIndex];\\n        index--;\\n        while(lastIndex != hash[lastIndex]){\\n            lastIndex = hash[lastIndex];\\n            result[index] = a[lastIndex];\\n            index--;\\n        }\\n        \\n        for(int i: result) System.out.print(i+\" \");\\n        \\n        return maxi;\\n    } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124603,
                "title": "top-down-backtracking-memoization",
                "content": "Idea :- \\n\\nWhat is the longest increasing subsequence starting from each index ?\\n\\nEx :-\\n 0 1 2 3 4.5\\n[5,2,3,1,7,4]\\n\\n MAX(lis(0), lis(1),list(2),list(3) ....list(5)) is the answer  \\n       \\n\\n```\\nprivate static int lengthOfLIS(int [] input) {\\n        int max = Integer.MIN_VALUE;\\n        int [] cache = new int [input.length];\\n        for (int i = 0; i < input.length; ++i) {\\n            max = Math.max(max, lengthOfLIS(input,i, cache));\\n        }\\n        return Math.max(1,max);\\n    } \\n\\n    private static int lengthOfLIS(int[] input, int start, int [] cache) {\\n\\n        if (start >= input.length) return 0;\\n        if (cache[start] != 0) return cache[start];\\n\\n        int max = Integer.MIN_VALUE;\\n        for (int i = start; i < input.length; ++i) {\\n            if (input[i] > input[start]) {\\n                max = Math.max(max,1 + lengthOfLIS(input, i, cache));\\n            }\\n        }\\n        cache[start] = Math.max(max,1);\\n        return cache[start];\\n    }\\n\\n```\\n\\n* Top Down approach. \\n* Use backtracking to avoid scanning sequences which will not lead to any solution. \\n* Using a cache to memoize solutions.\\n",
                "solutionTags": [],
                "code": "```\\nprivate static int lengthOfLIS(int [] input) {\\n        int max = Integer.MIN_VALUE;\\n        int [] cache = new int [input.length];\\n        for (int i = 0; i < input.length; ++i) {\\n            max = Math.max(max, lengthOfLIS(input,i, cache));\\n        }\\n        return Math.max(1,max);\\n    } \\n\\n    private static int lengthOfLIS(int[] input, int start, int [] cache) {\\n\\n        if (start >= input.length) return 0;\\n        if (cache[start] != 0) return cache[start];\\n\\n        int max = Integer.MIN_VALUE;\\n        for (int i = start; i < input.length; ++i) {\\n            if (input[i] > input[start]) {\\n                max = Math.max(max,1 + lengthOfLIS(input, i, cache));\\n            }\\n        }\\n        cache[start] = Math.max(max,1);\\n        return cache[start];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74994,
                "title": "c-o-nlogn-solution-with-explainations-4ms",
                "content": "The solution is building a ladder for numbers, with level number labels the max sequence for all numbers on that level; \\nwhen a new number comes in, compare it with the smallest number in each level--starting from the highest level, if larger than the (smallest) number in that level, the new number is insert into level+1  \\nelse compare with the smallest number in second highest level ...\\n\\ne.g.  [10, 9, 2, 5, 3, 7, 101, 18]\\n\\nlevel: numbers\\n \\n4: 101, **18**\\n\\n3: **7**\\n\\n2: 5, **3**\\n\\n1: 10, 9, **2**\\n\\nSince we only use the **smallest number** in each level, we do not need save the others, an extra vector<int> of size m(=max level) would be enough \\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ladder(1);\\n        if(nums.empty()) return 0;\\n        ladder[0]=nums[0];\\n        for(int i=1; i<nums.size(); ++i){\\n            int m=int(ladder.size());\\n            bool foundless=false;\\n            for(int j=m-1;j>=0;--j){\\n                if(nums[i] > ladder[j]){\\n                    if(j+1==ladder.size()){\\n                        ladder.push_back(nums[i]);\\n                    }\\n                    else{\\n                        ladder[j+1]=min(ladder[j+1],nums[i]);\\n                    }\\n                    foundless=true;\\n                    break;\\n                }\\n            }\\n            if(!foundless) ladder[0]=min(ladder[0],nums[i]);\\n        }\\n        return ladder.size();\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The solution is building a ladder for numbers, with level number labels the max sequence for all numbers on that level; \\nwhen a new number comes in, compare it with the smallest number in each level--starting from the highest level, if larger than the (smallest) number in that level, the new number is insert into level+1  \\nelse compare with the smallest number in second highest level ...\\n\\ne.g.  [10, 9, 2, 5, 3, 7, 101, 18]\\n\\nlevel: numbers\\n \\n4: 101, **18**\\n\\n3: **7**\\n\\n2: 5, **3**\\n\\n1: 10, 9, **2**\\n\\nSince we only use the **smallest number** in each level, we do not need save the others, an extra vector<int> of size m(=max level) would be enough \\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ladder(1);\\n        if(nums.empty()) return 0;\\n        ladder[0]=nums[0];\\n        for(int i=1; i<nums.size(); ++i){\\n            int m=int(ladder.size());\\n            bool foundless=false;\\n            for(int j=m-1;j>=0;--j){\\n                if(nums[i] > ladder[j]){\\n                    if(j+1==ladder.size()){\\n                        ladder.push_back(nums[i]);\\n                    }\\n                    else{\\n                        ladder[j+1]=min(ladder[j+1],nums[i]);\\n                    }\\n                    foundless=true;\\n                    break;\\n                }\\n            }\\n            if(!foundless) ladder[0]=min(ladder[0],nums[i]);\\n        }\\n        return ladder.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2395662,
                "title": "python-binary-search",
                "content": "This is an implementation of a solution provided [here](https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308/C%2B%2BPython-DP-Binary-Search-BIT-Solutions-Picture-explain-O(NlogN)).\\n\\n**Solution**:\\nA bottom-up dp approach would requires look back through previous numbers to find the longest increasing subsequence that the current number can contribute to. Thus, the overall running time will be O(n**2) \\n\\nA faster approach is to use a binary search with greedy approach to solve this problem. Iterate through all numbers. For each number, append it to the result if it is larger than the last number in the result. Else, replace such number with the smallest number in the result that is greater than or equal to it. Lastly, return the length of the result as the solution. \\n\\nThis approach works because an increasing subsequence of some arbitrary length will only be fully replaced if there is another increasing subsequence of identical length but contains smaller values. Thus, the last numbers in the result will always be the smallest overall of the last number of all increasing subsequence of that size. So if the next number is larger than the last number of the result, it guarantees to increasing the length of at least one increasing subsequence.  \\n\\n    Ex: nums = [10,11,12,1,2,3,4]    \\n        i   Result          Longest Increasing Sequences\\n        0   [10]            [10] \\n        1   [10, 11]        [10, 11] \\n        2   [10, 11, 12]    [10, 11, 12]\\n        3   [1, 11, 12]     [10, 11, 12]\\n        4   [1, 2, 12]      [10, 11, 12]\\n        5   [1, 2, 3]       [10, 11, 12]\\n                            [1, 2, 3]\\n        6   [1, 2, 3, 4]    [1, 2, 3, 4]\\n\\n    Ex: nums = [10,11,12,1,2,3,13]    \\n        i   Result          Longest Increasing Sequences\\n        0   [10]            [10] \\n        1   [10, 11]        [10, 11] \\n        2   [10, 11, 12]    [10, 11, 12]\\n        3   [1, 11, 12]     [10, 11, 12]\\n        4   [1, 2, 12]      [10, 11, 12]\\n        5   [1, 2, 3]       [10, 11, 12]\\n                            [1, 2, 3]\\n        6   [1, 2, 3, 13]   [10, 11, 12, 13]\\n                            [1, 2, 3, 13]\\n\\n**Complexity**:\\n    Time: O(nlogn)\\n    Space: O(n)\\n\\t\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: list[int]) -> int:\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Binary search to find the index of the smallest number in result that is greater than or equal to the target\\n        def binarySearch(l, r, target):\\n\\n            nonlocal res\\n\\n            # If the left and right pointers meet, we have found the smallest number that is greater than the target\\n            if l == r:\\n                return l\\n\\n            # Find the mid pointer\\n            m = (r - l) // 2 + l\\n\\n            # If the number at the mid pointer is equal to the target, we have found a number that is equal to the target\\n            if res[m] == target:\\n                return m\\n\\n            # Else if the number at the mid poitner is less than the target, we search the right side\\n            elif res[m] < target:\\n                return binarySearch(m + 1, r, target)\\n\\n            # Else, we search the left side including the number at mid pointer because it is one of the possible solution since it is greater than the target\\n            else:\\n                return binarySearch(l, m, target)\\n\\n        # Iterate through all numbers\\n        for n in nums:\\n\\n            # If the last number in the result is less than the current number\\n            if not res or res[-1] < n:\\n\\n                # Append the current number to the result\\n                res.append(n)\\n\\n                continue\\n\\n            # Else, find the index of the smallest number in the result that is greater than or equal to the current number\\n            i = binarySearch(0, len(res) - 1, n)\\n\\n            # Replace the current number at such index\\n            res[i] = n\\n\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: list[int]) -> int:\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Binary search to find the index of the smallest number in result that is greater than or equal to the target\\n        def binarySearch(l, r, target):\\n\\n            nonlocal res\\n\\n            # If the left and right pointers meet, we have found the smallest number that is greater than the target\\n            if l == r:\\n                return l\\n\\n            # Find the mid pointer\\n            m = (r - l) // 2 + l\\n\\n            # If the number at the mid pointer is equal to the target, we have found a number that is equal to the target\\n            if res[m] == target:\\n                return m\\n\\n            # Else if the number at the mid poitner is less than the target, we search the right side\\n            elif res[m] < target:\\n                return binarySearch(m + 1, r, target)\\n\\n            # Else, we search the left side including the number at mid pointer because it is one of the possible solution since it is greater than the target\\n            else:\\n                return binarySearch(l, m, target)\\n\\n        # Iterate through all numbers\\n        for n in nums:\\n\\n            # If the last number in the result is less than the current number\\n            if not res or res[-1] < n:\\n\\n                # Append the current number to the result\\n                res.append(n)\\n\\n                continue\\n\\n            # Else, find the index of the smallest number in the result that is greater than or equal to the current number\\n            i = binarySearch(0, len(res) - 1, n)\\n\\n            # Replace the current number at such index\\n            res[i] = n\\n\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484417,
                "title": "python-o-nlogn",
                "content": "* Traditional `O(N^2)` solution finds both the LIS and its length\\n* Faster `O(N log N)` solution finds **only the LIS length**, and not the LIS\\n* Example - building `arr` from  `1 2 4 5 3 11`\\n\\t* Insert `1` --> `1`\\n\\t* Insert `2` --> `1 2`\\n\\t* Insert `4` --> `1 2 4`\\n\\t* Insert `5` --> `1 2 4 5`\\n\\t* Insert `3` --> `1 2 3 5` (replace the smallest number >=3 by `3`)\\n\\t* Insert `11` --> `1 2 3 5 11` (note that this is **not the LIS**)\\n* We can binary search for the insertion position of `num` in `arr`\\n\\n\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        arr = []\\n        \\n        for num in nums:\\n            insertion_pos = bisect_left(arr, num)\\n            \\n            if insertion_pos == len(arr):\\n                arr.append(num)\\n            else:\\n                arr[insertion_pos] = num\\n        \\n        return len(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        arr = []\\n        \\n        for num in nums:\\n            insertion_pos = bisect_left(arr, num)\\n            \\n            if insertion_pos == len(arr):\\n                arr.append(num)\\n            else:\\n                arr[insertion_pos] = num\\n        \\n        return len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326745,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size(), ans = INT_MIN;\\n        vector<int>dp(n, 1);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j]) dp[i] = max(dp[i], 1+dp[j]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size(), ans = INT_MIN;\\n        vector<int>dp(n, 1);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j]) dp[i] = max(dp[i], 1+dp[j]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867378,
                "title": "python-patience-sort-n-log-n-99-24",
                "content": "By layering numbers in the style of the game of patience and adding to an existing pile if the current number is less than the bottom of a pile and adding a pile if the number is greater than all the piles we can improve the classic dp solution to n log n.\\n\\ne.g for the input `[50, 3, 10, 7, 40, 80]` visually it would look like this\\n\\n```\\n50  10  40  80\\n3   7\\n```\\n\\nAs we only care about the bottom number we don\\'t need to create an array of arrays, just replace the number in the array where we want to insert it e.g.\\n\\n```\\n3  7  40  80\\n```\\n\\nAs this is always ordered, it means we can use a binary search whenever we\\'re looking for where the number should go (bisect_left).\\n\\nGreat explanation of this algorithm here: https://www.youtube.com/watch?v=22s1xxRvy28\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, arr: List[int]) -> int:\\n        res = []\\n\\n        for num in nums:\\n            if not res or num > res[-1]:\\n                res.append(num)\\n            else:\\n                idx = bisect.bisect_left(res,num)\\n                res[idx] = num\\n\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n50  10  40  80\\n3   7\\n```\n```\\n3  7  40  80\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, arr: List[int]) -> int:\\n        res = []\\n\\n        for num in nums:\\n            if not res or num > res[-1]:\\n                res.append(num)\\n            else:\\n                idx = bisect.bisect_left(res,num)\\n                res[idx] = num\\n\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502877,
                "title": "c-o-nlogn-solution-beats-100-in-time-detailed-explnanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/longest-increasing-subsequence/\\n    \\n    LIS using binary search\\n    TC: O(nlogn)\\n*/\\nclass Solution {\\npublic:\\n    // Maintain an array of numbers increasing order. Initially empty.\\n    // Idea is traverse the array, for a given position \\'i\\', find the first greater number\\n    // than current in that array using binary search, if there is no such number add current to that array.\\n    // If a number is found greater than current don\\'t add to that array. \\n    // In the end that array will be filled with numbers in increasing order\\n    int lisBinarySearch(vector<int>& nums) {\\n        // vector for storing longest increasing subsequence\\n        vector<int> lis;\\n        for(const int& num: nums) {\\n            // find the first number greater than current in LIS\\n            auto it = lower_bound(lis.begin(), lis.end(), num);\\n            \\n            // if no such number is found, we can add the current\\n            if(it == lis.end()) {\\n                lis.emplace_back(num);\\n            }\\n            // if a number greater exists, then replace it with current, this is\\n            // because putting the smaller number in place of a bigger number will allow\\n            // more numbers greater than current to be part of LIS\\n            else if(*it > num)\\n                *it = num;\\n        }\\n        return lis.size();\\n    }\\n    \\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        return lisBinarySearch(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/longest-increasing-subsequence/\\n    \\n    LIS using binary search\\n    TC: O(nlogn)\\n*/\\nclass Solution {\\npublic:\\n    // Maintain an array of numbers increasing order. Initially empty.\\n    // Idea is traverse the array, for a given position \\'i\\', find the first greater number\\n    // than current in that array using binary search, if there is no such number add current to that array.\\n    // If a number is found greater than current don\\'t add to that array. \\n    // In the end that array will be filled with numbers in increasing order\\n    int lisBinarySearch(vector<int>& nums) {\\n        // vector for storing longest increasing subsequence\\n        vector<int> lis;\\n        for(const int& num: nums) {\\n            // find the first number greater than current in LIS\\n            auto it = lower_bound(lis.begin(), lis.end(), num);\\n            \\n            // if no such number is found, we can add the current\\n            if(it == lis.end()) {\\n                lis.emplace_back(num);\\n            }\\n            // if a number greater exists, then replace it with current, this is\\n            // because putting the smaller number in place of a bigger number will allow\\n            // more numbers greater than current to be part of LIS\\n            else if(*it > num)\\n                *it = num;\\n        }\\n        return lis.size();\\n    }\\n    \\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        return lisBinarySearch(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133496,
                "title": "javascript-solution",
                "content": "```js\\nfunction lengthOfLIS(nums) {\\n  if (!nums.length) return 0;\\n\\n  let arr = new Array(nums.length).fill(1);\\n\\t\\n  for (let i = 1; i < nums.length; i++) {\\n    for (let j = 0; j < i; j++) {\\n      if (nums[j] < nums[i]) arr[i] = Math.max(arr[i], arr[j] + 1);\\n    }\\n  }\\n  \\n  return Math.max(...arr);\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction lengthOfLIS(nums) {\\n  if (!nums.length) return 0;\\n\\n  let arr = new Array(nums.length).fill(1);\\n\\t\\n  for (let i = 1; i < nums.length; i++) {\\n    for (let j = 0; j < i; j++) {\\n      if (nums[j] < nums[i]) arr[i] = Math.max(arr[i], arr[j] + 1);\\n    }\\n  }\\n  \\n  return Math.max(...arr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74979,
                "title": "javascript-solution-o-2",
                "content": "    function lengthOfLIS(nums) {\\n    \\tvar lis = [];\\n    \\tfor (var i = 0; i < nums.length; i++) {\\n    \\t\\tlis.push(1);\\n    \\t\\tfor (var j = 0; j < i; j++) {\\n    \\t\\t\\tif (nums[j] < nums[i]) lis[i] = Math.max(lis[i], lis[j] + 1);\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.length ? Math.max.apply(null, lis) : 0;\\n    }",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "    function lengthOfLIS(nums) {\\n    \\tvar lis = [];\\n    \\tfor (var i = 0; i < nums.length; i++) {\\n    \\t\\tlis.push(1);\\n    \\t\\tfor (var j = 0; j < i; j++) {\\n    \\t\\t\\tif (nums[j] < nums[i]) lis[i] = Math.max(lis[i], lis[j] + 1);\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.length ? Math.max.apply(null, lis) : 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74849,
                "title": "another-o-n-log-n-python",
                "content": "`minend[i]` is the minimum ending of an increasing subsequence of length `i+1`.\\n\\n    def lengthOfLIS(self, nums):\\n        minend = [float('inf')] * (len(nums) + 1)\\n        for num in nums:\\n            minend[bisect.bisect_left(minend, num)] = num\\n        return minend.index(float('inf'))",
                "solutionTags": [
                    "Python"
                ],
                "code": "`minend[i]` is the minimum ending of an increasing subsequence of length `i+1`.\\n\\n    def lengthOfLIS(self, nums):\\n        minend = [float('inf')] * (len(nums) + 1)\\n        for num in nums:\\n            minend[bisect.bisect_left(minend, num)] = num\\n        return minend.index(float('inf'))",
                "codeTag": "Python3"
            },
            {
                "id": 1333405,
                "title": "patience-sort-o-nlogn-solution-with-explanation",
                "content": "**Patience sort** \\nThe algorithm\\'s name derives from a simplified variant of the patience card game. The game begins with a shuffled deck of cards. The cards are dealt one by one into a sequence of piles on the table, according to the following rules.\\n\\n1. Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.\\n2. Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or equal to the new card\\'s value, or to the right of all of the existing piles, thus forming a new pile.\\n\\nIf you have played solitaire before, it\\'s kind of similar.\\n\\n**Explanation** \\nSimilar to patience card game, we\\'ll be forming piles of numbers with decreasing subsequence, if a number couldn\\u2019t fit in any of the piles, we create a new pile.\\ne.g. **[10,9,2,5,3,7,101,18]**\\nWe\\'ll take piles as a 2D array for better understanding.\\npiles = [[]]\\nInsert 10 - No existing pile found, create a new pile, pile = [10], insert it to piles.\\n `piles` = [[10]]\\nInsert 9 - We start searching for leftmost pile with top card\\'s value >= 9. Insert it to that pile. update the piles array, \\n`piles` = [[10, 9]]\\nInsert 2 -  Start searching for leftmost pile with top card\\'s value >= 2. Insert it to that pile. update the piles array, \\n`piles` = [[10, 9, 2]]\\nInsert 5 - Search for pile with top card\\'s value >= 5. No pile found,  create a new pile, pile = [5], insert it to piles.\\n\\t\\t\\t\\t `piles` = [[10, 9, 2], [5]]\\nInsert 3 -  Start searching for leftmost pile with top card\\'s value >= 3. Insert it to that pile. update the piles array,\\n `piles` =  [[10, 9, 2], [5, 3]]\\nInsert 7 - Search for pile with top card\\'s value >= 7. No pile found,  create a new pile, pile = [7], insert it to piles.\\n\\t\\t\\t\\t `piles` = [[10, 9, 2], [5, 3], [7]]\\nInsert 101 - Search for pile with top card\\'s value >= 101. No pile found,  create a new pile, pile = [101], insert it to piles.\\n\\t\\t\\t\\t `piles` = [[10, 9, 2], [5, 3], [7], [101]]\\nInsert 18 -  Start searching for leftmost pile with top card\\'s value >= 18. Insert it to that pile. update the piles array,\\n `piles` =   [[10, 9, 2], [5, 3], [7], [101, 18]]\\n\\nIf we observe, the top card (last element) of every pile when taken together, forms an increasing sequence.\\n[2,3,7,18] (We needed to create a new pile for an element only because we couldn\\u2019t find a top card having value greater than current element. Even if a new element gets inserted to current element\\'s left, it\\'ll be smaller than current element. Therefore, all the top cards to the element\\'s left are smaller than current card)\\n\\nFurther we can observe that we only need the top card (tail) of every pile for comparison, so piles can be reduced to just the tail values instead of maintaining a 2D array. \\nIterate over the original nums array for making piles and store the top card in tails array. Since, our tails array is always going to be an increasing sequence, we can perform binary search to find the position of current element in tails array (Finding an element >= current in tails array, insert it to tails if no position is found)\\n`nums` - [10,9,2,5,3,7,101,18]\\n\\n`tails array`  \\n[10]\\n[9]\\n[2]\\n[2,5]\\n[2,5,7]\\n[2,5,7,101]\\n[2,5,7,18]\\n\\n**Code**\\n```\\ndef length_of_lis(nums)\\n    tails = Array.new\\n    k = 0 # k is length of tails array\\n    nums.each do |num|\\n        start, finish = 0, k\\n        while start != finish\\n            mid = (start + finish)/2\\n            if tails[mid] < num\\n                start = mid + 1\\n            else\\n                finish = mid\\n            end\\n        end\\n        tails[start] = num\\n        k += 1 if start == k # new insertion in tails array, increase size of tails\\n    end\\n    return k # longest increasing subsequence size\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef length_of_lis(nums)\\n    tails = Array.new\\n    k = 0 # k is length of tails array\\n    nums.each do |num|\\n        start, finish = 0, k\\n        while start != finish\\n            mid = (start + finish)/2\\n            if tails[mid] < num\\n                start = mid + 1\\n            else\\n                finish = mid\\n            end\\n        end\\n        tails[start] = num\\n        k += 1 if start == k # new insertion in tails array, increase size of tails\\n    end\\n    return k # longest increasing subsequence size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 988572,
                "title": "c-recursion-memoization-easy-understanding",
                "content": "```\\n//recursion [22 / 54 test cases passed]\\nclass Solution {\\npublic:\\n    int lis_ending_here(vector<int>& arr, int curr){\\n        // Only one subsequence ends at first index, the number itself\\n        if(curr == 0)\\n            return 1;\\n        int ans = 1;\\n        for(int i = curr-1;i>=0;i--)\\n            if(arr[i] < arr[curr])\\n                ans = max(ans, 1 + lis_ending_here(arr, i));\\n        return ans;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int max_ans = 1;\\n        for(int i = 0 ;i<nums.size();i++)\\n            max_ans = max(max_ans, lis_ending_here(nums, i));\\n        return max_ans;\\n    }\\n};\\n```\\n```\\n//MEMOIZATION \\nclass Solution {\\npublic:\\n    int memo[2501];\\n    int lis_ending_here(vector<int>& arr, int curr){\\n        if(curr == 0)\\n            return 1;\\n        if(memo[curr]!=-1)\\n            return memo[curr];\\n        int ans = 1;\\n        for(int i = curr-1;i>=0;i--)\\n            if(arr[i] < arr[curr])\\n                ans = max(ans, 1 + lis_ending_here(arr, i));\\n        return memo[curr]=ans;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(memo,-1,sizeof(memo));\\n        int max_ans = 1;\\n        for(int i = 0 ;i<nums.size();i++)\\n            max_ans = max(max_ans, lis_ending_here(nums, i));\\n        return max_ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//recursion [22 / 54 test cases passed]\\nclass Solution {\\npublic:\\n    int lis_ending_here(vector<int>& arr, int curr){\\n        // Only one subsequence ends at first index, the number itself\\n        if(curr == 0)\\n            return 1;\\n        int ans = 1;\\n        for(int i = curr-1;i>=0;i--)\\n            if(arr[i] < arr[curr])\\n                ans = max(ans, 1 + lis_ending_here(arr, i));\\n        return ans;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int max_ans = 1;\\n        for(int i = 0 ;i<nums.size();i++)\\n            max_ans = max(max_ans, lis_ending_here(nums, i));\\n        return max_ans;\\n    }\\n};\\n```\n```\\n//MEMOIZATION \\nclass Solution {\\npublic:\\n    int memo[2501];\\n    int lis_ending_here(vector<int>& arr, int curr){\\n        if(curr == 0)\\n            return 1;\\n        if(memo[curr]!=-1)\\n            return memo[curr];\\n        int ans = 1;\\n        for(int i = curr-1;i>=0;i--)\\n            if(arr[i] < arr[curr])\\n                ans = max(ans, 1 + lis_ending_here(arr, i));\\n        return memo[curr]=ans;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(memo,-1,sizeof(memo));\\n        int max_ans = 1;\\n        for(int i = 0 ;i<nums.size();i++)\\n            max_ans = max(max_ans, lis_ending_here(nums, i));\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922318,
                "title": "dfs-dp-progression-with-explanation-27-60",
                "content": "In this problem, we are tasked to find the longest increasing subsequence.  As a first approach, the solution would then be to look through all possible subsequences, and return the longest increasing subsequence.  DFS is a great tool to use to visualize this type of problem, as we can think of an instance of the function as a state, and its recursive calls as the possible actions you can take from that state to a new state.\\n```\\ndef dfs(nums, prev):\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tlongest = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > prev:\\n\\t\\t\\tcurr = 1 + dfs(nums[i + 1:], nums[i])\\n\\t\\t\\tlongest = max(longest, curr)\\n\\treturn longest\\nreturn dfs(nums, -float(\"inf\"))\\n```\\nLet\\'s take a look at what the DFS tree for this looks like, where the dotted paths represent non-valid actions (node > child)\\n![image](https://assets.leetcode.com/users/images/ea003933-195d-41f2-9533-f0815c533da0_1604425172.4121287.png)\\nThis problem follows a very common pattern where the solution resides in traversing the DFS tree from root -> leaf, accumulating some _cost_ at each node, and return the maximum cost path.  As we are only counting the length of the longest increasing subsequence, the cost for each node would be 1.  Therefore, we are simply looking for the longest root -> leaf path in the DFS tree.\\nThis solves the problem, however takes far far too long and times out.  Why is that?  If we take another look at the DFS tree, notice the amount of redundancy, specifically in the `3` node.  We see it in two places, the `3` branches to `2` and `4`.  In both places, the calculation will yield the same result `(3 -> 4 with a path length of 2)`, and thus we are wasting time recalculating it.  This issue becomes exponentially worse as the input size grows larger, causing the DFS tree to become taller.  This is where the DP solution comes in.\\nThe DFS approach solves this problem from the top-down, meaning we have to recurse all the way downwards before we hit the base case `(if not nums: return 0)`, to understand how long a certain path is, which causes the redundant calculations.  What if instead we built the solution from the ground up, saving the solution up to that point at each step in an array, so we can simply reference again if we see it later.\\n```\\ndef dp(nums):\\n\\tA = [1 for _ in range(len(nums))]\\n\\tfor j in range(len(nums)):\\n\\t\\tfor i in range(j):\\n\\t\\t\\tif nums[j] > nums[i]:\\n\\t\\t\\t\\tA[j] = max(A[j], A[i] + 1)\\n\\treturn max(A)\\nreturn dp(nums)\\n```\\nNotice the recursion relation is exactly the same as the DFS approach, except now we are just referencing previously calculated solutions.  This solves the problem much more efficiently in `O(n^2)` time.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(nums, prev):\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tlongest = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > prev:\\n\\t\\t\\tcurr = 1 + dfs(nums[i + 1:], nums[i])\\n\\t\\t\\tlongest = max(longest, curr)\\n\\treturn longest\\nreturn dfs(nums, -float(\"inf\"))\\n```\n```\\ndef dp(nums):\\n\\tA = [1 for _ in range(len(nums))]\\n\\tfor j in range(len(nums)):\\n\\t\\tfor i in range(j):\\n\\t\\t\\tif nums[j] > nums[i]:\\n\\t\\t\\t\\tA[j] = max(A[j], A[i] + 1)\\n\\treturn max(A)\\nreturn dp(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 326122,
                "title": "clean-javascript-solution-dp-bs",
                "content": "JavaScript version of a great solution offered by @davidluoyes in the comment of the popular solution: https://leetcode.com/problems/longest-increasing-subsequence/discuss/74825/Short-Java-solution-using-DP-O(n-log-n)\\n\\nI find it easy to understand, hope it helps you too!\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar lengthOfLIS = function(nums) {\\n    const binarySearchPosition = (dp, target, hi) => {\\n        let lo = 0;\\n        while (lo <= hi) {\\n            let mid = Math.floor((lo+hi)/2);\\n            if (target === dp[mid]) return mid;\\n            else if (target < dp[mid]) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    if (nums === null || nums.length===0) return 0;\\n    if (nums.length === 1) return 1;\\n    let dp = new Array(nums.length).fill(Number.MAX_SAFE_INTEGER);\\n    for (let i=0; i<nums.length; i++){\\n        let pos = binarySearchPosition(dp, nums[i], i);\\n        dp[pos] = nums[i];\\n    }\\n\\n    for (let i = dp.length-1; i >= 0; i--){\\n        if (dp[i] !== Number.MAX_SAFE_INTEGER) return i+1;\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar lengthOfLIS = function(nums) {\\n    const binarySearchPosition = (dp, target, hi) => {\\n        let lo = 0;\\n        while (lo <= hi) {\\n            let mid = Math.floor((lo+hi)/2);\\n            if (target === dp[mid]) return mid;\\n            else if (target < dp[mid]) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    if (nums === null || nums.length===0) return 0;\\n    if (nums.length === 1) return 1;\\n    let dp = new Array(nums.length).fill(Number.MAX_SAFE_INTEGER);\\n    for (let i=0; i<nums.length; i++){\\n        let pos = binarySearchPosition(dp, nums[i], i);\\n        dp[pos] = nums[i];\\n    }\\n\\n    for (let i = dp.length-1; i >= 0; i--){\\n        if (dp[i] !== Number.MAX_SAFE_INTEGER) return i+1;\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579188,
                "title": "c-3-methods-dp-lower-bound-recursion",
                "content": "**APPROACH 1 :** Dynamic Programming\\n* **Time Complexity :** O(N^2)\\n* **Auxiliary Space :** O(N)\\n\\n  **Code :**\\n  ```\\n  class Solution {\\n  public:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(), 1);  //Maintain a list, traverse the array, and for every element  each time you find an element less than that on it\\'s left side, increase the length of the  sequnce in the list\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(lis[i]<lis[j]+1 && nums[i]>nums[j]) lis[i]=lis[j]+1;\\n            }\\n        }\\n        \\n        return *max_element(lis.begin(), lis.end());\\n    }\\n    \\n   }; \\n   ```\\n   \\n**APPROACH 2 :** Using std::lower_bound()\\n* **Time Complexity :** O(NlogN)\\n* **Auxiliary Space :** O(N)\\n   **Code :**\\n  ```\\n  class Solution {\\n  public:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> v;\\n        for (int i = 0; i<nums.size(); i++) {\\n            auto p = lower_bound(v.begin(), v.end(), nums[i]);\\n            if (p == v.end())  v.push_back(nums[i])\\n\\t\\t\\telse  *p = nums[i];\\n        }\\n        return v.size();\\n    }\\n\\t};\\n    ```\\n   \\n**APPROACH 3 :** Recursion \\n* If we closely observe the problem then we can convert this problem to the \"Longest Common Subsequence\" problem, where the first array is \\'nums\\' and the second array is \\'nums\\' sorted in ascending order.\\n* Firstly we will create another array of unique elements of \\'nums\\' and sort it. \\n* Now the longest increasing subsequence of \\'nums\\' must be present as a subsequence in our sorted array. \\n* That\\u2019s why our problem is now reduced to finding the **longest common subsequence between the two arrays**.\\n\\n  **Code :**\\n  ```\\n  class Solution {\\n  public:\\n      int lengthOfLIS(vector<int>& nums) {\\n\\t\\t  vector<int> nums2 = nums;\\n\\t\\t  sort(nums2.begin(), nums2.end());\\n\\t\\t  \\n\\t\\t  return lengthOfLCS(nums, nums2, nums.size(), nums2.size());\\t\\t  \\n      }   \\n\\t  \\n\\t  int lengthOfLCS(vector<int> nums1, vector<int> nums2, int m, int n){\\n\\t\\t  if(m-1==0 || n-1==0) return 0;\\n\\n        if(nums1[m-1]==nums2[n-1]) return 1+lengthOfLCS(nums1, nums2, m-1, n-1);\\n\\n        else return max(lengthOfLCS(nums1, nums2, m, n-1),  lengthOfLCS(nums1, nums2, m-1, n));\\n\\t  }\\n\\t  \\n\\t}; \\n   ```\\n   \\n **If you like my solutions and explanation, please upvote :)**\\n  \\n\\n\\n\\n\\n\\n\\n\\n \\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n  class Solution {\\n  public:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(), 1);  //Maintain a list, traverse the array, and for every element  each time you find an element less than that on it\\'s left side, increase the length of the  sequnce in the list\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(lis[i]<lis[j]+1 && nums[i]>nums[j]) lis[i]=lis[j]+1;\\n            }\\n        }\\n        \\n        return *max_element(lis.begin(), lis.end());\\n    }\\n    \\n   }; \\n   ```\n```\\n  class Solution {\\n  public:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> v;\\n        for (int i = 0; i<nums.size(); i++) {\\n            auto p = lower_bound(v.begin(), v.end(), nums[i]);\\n            if (p == v.end())  v.push_back(nums[i])\\n\\t\\t\\telse  *p = nums[i];\\n        }\\n        return v.size();\\n    }\\n\\t};\\n    ```\n```\\n  class Solution {\\n  public:\\n      int lengthOfLIS(vector<int>& nums) {\\n\\t\\t  vector<int> nums2 = nums;\\n\\t\\t  sort(nums2.begin(), nums2.end());\\n\\t\\t  \\n\\t\\t  return lengthOfLCS(nums, nums2, nums.size(), nums2.size());\\t\\t  \\n      }   \\n\\t  \\n\\t  int lengthOfLCS(vector<int> nums1, vector<int> nums2, int m, int n){\\n\\t\\t  if(m-1==0 || n-1==0) return 0;\\n\\n        if(nums1[m-1]==nums2[n-1]) return 1+lengthOfLCS(nums1, nums2, m-1, n-1);\\n\\n        else return max(lengthOfLCS(nums1, nums2, m, n-1),  lengthOfLCS(nums1, nums2, m-1, n));\\n\\t  }\\n\\t  \\n\\t}; \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1469714,
                "title": "javascript-1-reduce-100-90",
                "content": "![image](https://assets.leetcode.com/users/images/792ee274-e55a-459f-9288-a0a9cc9e1ac3_1631929723.341068.png)\\n\\nDoing the Blind 75 List and posting all solutions.\\n\\nMethod using one reduce.\\n```\\nvar lengthOfLIS = nums => {\\n  return nums.reduce((sequence, num) => {\\n    if (num > sequence[sequence.length - 1]) sequence.push(num);\\n    else sequence[sequence.findIndex(val => val >= num)] = num;\\n    return sequence;\\n  }, [nums[0]]).length\\n};\\n```\\n\\nMaybe more readable method using forEach.\\n```\\nconst lengthOfLIS = nums => {\\n  let sequence = [nums[0]];\\n  nums.forEach((num, idx) => {\\n    if (num > sequence[sequence.length - 1]) sequence.push(num);\\n    else sequence[sequence.findIndex(val => val >= num)] = num;\\n  })\\n  return sequence.length;\\n}\\n```\\n\\nDP array build up solution: (This is Widely regarded as a DP problem, and I agree, the pattern is Definitely there.  That said, this isn\\'t even close to the optimal solution.  But, it\\'s recognizable, and will likely carry you through an interview pretty well.  Cheers.)\\n```\\nconst lengthOfLIS = nums => {\\n  let sequence = Array(nums.length).fill(1);\\n  for (let i = 0; i <= nums.length; i++) {\\n    for (let j = i - 1; j >= 0; j--) {\\n      if (nums[j] < nums[i]) sequence[i] = Math.max(sequence[i], sequence[j] + 1);\\n    }\\n  }\\n  return Math.max(...sequence)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lengthOfLIS = nums => {\\n  return nums.reduce((sequence, num) => {\\n    if (num > sequence[sequence.length - 1]) sequence.push(num);\\n    else sequence[sequence.findIndex(val => val >= num)] = num;\\n    return sequence;\\n  }, [nums[0]]).length\\n};\\n```\n```\\nconst lengthOfLIS = nums => {\\n  let sequence = [nums[0]];\\n  nums.forEach((num, idx) => {\\n    if (num > sequence[sequence.length - 1]) sequence.push(num);\\n    else sequence[sequence.findIndex(val => val >= num)] = num;\\n  })\\n  return sequence.length;\\n}\\n```\n```\\nconst lengthOfLIS = nums => {\\n  let sequence = Array(nums.length).fill(1);\\n  for (let i = 0; i <= nums.length; i++) {\\n    for (let j = i - 1; j >= 0; j--) {\\n      if (nums[j] < nums[i]) sequence[i] = Math.max(sequence[i], sequence[j] + 1);\\n    }\\n  }\\n  return Math.max(...sequence)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395734,
                "title": "c-solution-with-comments-and-representation-binary-search-dp-recursion",
                "content": "***Please upvote if it helps.....***\\n****\\n***Intuition:***\\n****\\n****\\nLet us take an example and build up the intuition from here to solve this problem using binary search.\\n* ![image](https://assets.leetcode.com/users/images/17040d90-d21e-4c38-b81e-7b415d54ac11_1659927068.6900947.jpeg)\\n\\n\\nNow let us loop through every element and try to form a new subsequence.\\n\\n(i) index = 0, arr[i] is 1.\\n* ![image](https://assets.leetcode.com/users/images/787ede4d-22ca-41e7-bf01-b124472e6584_1659927091.0925066.jpeg)\\n\\n\\nWe can start forming the LIS from this index. Currently the LIS formed will be [1].\\n\\n(ii) index = 1, arr[i] is 7.\\n* ![image](https://assets.leetcode.com/users/images/deeceab5-2116-49d1-9694-20eae7f6e669_1659927104.782574.jpeg)\\n\\n\\nAs 7 is greater than the last element of the LIS, i.e 0; we can push it to the LIS array. \\n\\n(iii) index = 2, arr[i] is 8.\\n* ![image](https://assets.leetcode.com/users/images/2f844979-6850-4ba8-950c-f3ff7c3bc2e1_1659927123.4150376.jpeg)\\n\\n\\nAs 8 is greater than the last element of the LIS, i.e 7; we can push it to the LIS array.\\n\\n (iv) index = 3, arr[i] is 4.\\n* ![image](https://assets.leetcode.com/users/images/9b5e69ea-aa67-45c1-91de-aecada6af2ed_1659927135.7234867.jpeg)\\n\\n\\nNow, 4 is less than 8, the last element of the LIS array, therefore we can\\u2019t push it like before. Rather we can make a second LIS array as shown in the figure above for the time being.\\n\\n (v) index = 4, arr[i] is 5.\\n* ![image](https://assets.leetcode.com/users/images/fa9ffbbe-4fa8-4185-87fb-da1de052b614_1659927147.8617926.jpeg)\\n\\n\\n5 is not greater than 8, but it is greater than 4, the last element of the second LIS array that we made so we push it there.\\n\\n(vi) index = 5, arr[i] is 6\\n* ![image](https://assets.leetcode.com/users/images/2bcf570b-0a61-449e-93e1-eed06219fcd4_1659927159.8740659.jpeg)\\n\\n\\n6 is not greater than 8, but it is greater than 5, the last element of the second LIS array that we made so we push it there.\\n\\n(vii) index = 6, arr[i] is -1\\n* ![image](https://assets.leetcode.com/users/images/a31be868-5d7a-4f9a-9f22-a0be45fde611_1659927171.377665.jpeg)\\n\\n\\n-1 is smaller than all the elements of both arrays, therefore we can\\u2019t push it anywhere in the first two LIS arrays. Therefore, we make a separate LIS array as shown in the figure.\\n\\n(viii) index = 7, arr[i] is 9\\n* ![image](https://assets.leetcode.com/users/images/039d711a-fba1-4002-9a7a-e2e9f81e529f_1659927183.0411026.jpeg)\\n\\n\\n9 is greater than the last elements of all three LIS arrays, therefore we can push it to the last of all three.\\n\\nNow, we can return the length of the longest LIS array among the three, [1,  4,  5,  6,  9] i.e 5 as the final answer.\\n\\nThis is the basic intuition of the algorithm. If we make a new LIS array at every junction, it will take up a lot of space. Now the question arises, do we need to store all these extra LIS arrays in a data structure to keep track of all the LIS formed as we traverse the array?\\n\\nThe answer is No, We can maintain a single array (say temp) and rewrite this temp array again in order to find the length of the LIS. We are concerned about the length of the LIS rather than the LIS itself.\\n****\\n****\\n***Intuition for rewriting the temp array***\\n****\\nNow we will revisit this example again and find out how we can maintain a single array (temp) that gives us the length of the LIS.\\n\\nWe can straight away to index = 3, where we originally made the second LIS array.\\n* ![image](https://assets.leetcode.com/users/images/797832ab-d36f-4e6f-abb3-d9ed1236e3f0_1659927212.974964.jpeg)\\n\\n\\nNow, instead of creating a second LIS array, we will try to place it in the first LIS array (renamed as a temp). As temp is an increasing subsequence, 4 will come in place of 7 in the temp array as shown below.\\n\\n* ![image](https://assets.leetcode.com/users/images/46e9c021-d57f-4859-bae2-65556e091e85_1659927226.8882444.jpeg)\\n\\nNow, let us dig in to answer these three basic question that arises from this step:\\n\\n***What is the purpose of replacing 7 with 4?***\\n\\n* The purpose is to maintain a single array that can be used to calculate the length of LIS.\\n\\n***Will this not affect the answer already calculated?***\\n\\n* The answer is no. Before this replacement, the length of the LIS was 3. We know that already. By this replacement of 7 with 4, we are not changing the length of the temp array. Suppose a number 9 comes later we will simply append it to temp and its length will increase. In no way is this replacement affecting the length of the temp array from which we deduce the answer. Readers are highly advised to take some random examples and try to implement this step and understand how this step is not affecting the answer.\\n\\n***What is this temp array?***\\n* The \\u2018temp\\u2019 array is not the LIS. It is a simple array we maintain to figure out the length of the LIS of the given array. It will always have one property that the elements that are present inside it will always be sorted.\\n\\nIt is due to all these factors discussed above that instead of creating two separate arrays to store subsequences, we can maintain a single array (temp) and overwrite it again and again.\\n\\nNext, we have i = 4, arr[i] = 5 which will also be replaced in a similar way.\\n* ![image](https://assets.leetcode.com/users/images/7a1fbd18-07ed-409a-ae7d-0653fd242f23_1659927305.3770325.jpeg)\\n\\n\\nNext we have i=5, arr[i] = 6. As 6 is greater than the last element of the temp array, i.e 5, we append it to the temp array.\\n*  ![image](https://assets.leetcode.com/users/images/0d27415e-9101-42ae-b9b7-caec8e9ac885_1659927314.912361.jpeg)\\n\\n\\nNext, we have i = 6, arr[i] = -1. We replace it with 1 in the array.\\n* ![image](https://assets.leetcode.com/users/images/cc029269-ee48-4df6-bfd8-5b992423fcd3_1659927322.0779297.jpeg)\\n\\n\\nNext, we have i = 7, arr[i] = 9. We simply append it to the temp array.\\n* ![image](https://assets.leetcode.com/users/images/19221dc2-6026-44e7-8700-299951bee70d_1659927330.8958817.jpeg)\\n\\n\\nNow, we see that the final temp array is not the LIS, but its length is giving us the answer (i.e the length of LIS of the original array).\\n\\nNow, the main part left is to find the index at which we need to do the replacement. If we have to insert an element X in the temp array, the following properties should be satisfied: \\n\\n* The elements smaller than X should be present on the left side of X after replacement.\\n* The elements greater than or equal to X should be on the right side after replacement.\\n\\nNow as we are inserting in this particular manner, the array will always be sorted. Therefore we can search for the index by using binary search. In C++ the lower_bound function can be used to give us the particular index.\\n\\nThe lower bound function(X) returns us the iterator (or in simple terms the index) of :\\n\\n* The element X itself, if it is present.\\n* Or the next largest element, if the element is not present.\\n****\\n****\\n***Approach:***\\n****\\nNow, as we have understood the entire intuition of the algorithm we will summarize the approach:\\n\\n* Initialize a temp array.\\n* Push the first element of the array to temp.\\n* Iterate over the next elements.\\n* In every iteration, if arr[i] is greater than the last element of the temp array simply push it to the temp array.\\n* Else, just find the lower_bound index of that element in the temp array (say ind). THen simply initialize temp[ind] = arr[i] (// replacement step).\\n* Maintain a len variable to calculate the length of the temp array in the iteration itself.\\n****\\n****\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint getAns(int arr[], int n,  int ind, int prev_index, vector<vector<int>>& dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = max(notTake,take);\\n}\\n\\n\\nint longestIncreasingSubsequence(int arr[], int n){\\n    \\n    vector<int> temp;\\n    temp.push_back(arr[0]);\\n    \\n    int len = 1;\\n    \\n    for(int i=1; i<n; i++){\\n        if(arr[i]>temp.back()){\\n           // arr[i] > the last element of temp array \\n           \\n           temp.push_back(arr[i]);\\n           len++;\\n           \\n        } \\n        else{\\n\\t// replacement step\\n            int ind = lower_bound(temp.begin(),temp.end(),arr[i]) - temp.begin();\\n            temp[ind] = arr[i];\\n        }\\n        \\n    }\\n    \\n    return len;\\n}\\n    \\n\\nint main() {\\n\\t\\n\\tint arr[] = {10,9,2,5,3,7,101,18};\\n\\t\\n\\tint n = sizeof(arr)/sizeof(arr[0]);\\n\\t\\n\\tcout<<\"The length of the longest increasing subsequence is \"\\n        <<longestIncreasingSubsequence(arr,n);\\n\\t\\n\\treturn 0;\\n}\\n```\\n****\\n****\\n***Output:***\\n****\\nThe length of the longest increasing subsequence is 4\\n****\\n***Time Complexity: O(NxlogN)***\\n\\nReason: We iterate over the array of size N and in every iteration, we perform a binary search which takes logN time.\\n\\n***Space Complexity: O(N)***\\n\\nReason: We are using an extra array of size N to store the temp variable.\\n****\\n****\\n***Please upvote if it helps.....***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint getAns(int arr[], int n,  int ind, int prev_index, vector<vector<int>>& dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = max(notTake,take);\\n}\\n\\n\\nint longestIncreasingSubsequence(int arr[], int n){\\n    \\n    vector<int> temp;\\n    temp.push_back(arr[0]);\\n    \\n    int len = 1;\\n    \\n    for(int i=1; i<n; i++){\\n        if(arr[i]>temp.back()){\\n           // arr[i] > the last element of temp array \\n           \\n           temp.push_back(arr[i]);\\n           len++;\\n           \\n        } \\n        else{\\n\\t// replacement step\\n            int ind = lower_bound(temp.begin(),temp.end(),arr[i]) - temp.begin();\\n            temp[ind] = arr[i];\\n        }\\n        \\n    }\\n    \\n    return len;\\n}\\n    \\n\\nint main() {\\n\\t\\n\\tint arr[] = {10,9,2,5,3,7,101,18};\\n\\t\\n\\tint n = sizeof(arr)/sizeof(arr[0]);\\n\\t\\n\\tcout<<\"The length of the longest increasing subsequence is \"\\n        <<longestIncreasingSubsequence(arr,n);\\n\\t\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 646716,
                "title": "brute-force-recursion-with-memoization-bottom-up-approach-with-comment-c-code",
                "content": "***Brute Force***\\n```\\nint findLis(vector<int>& nums,int n,int currIndex,int currEle){\\n    \\n    if(currIndex >= n){\\n        return 1;\\n    }\\n    \\n    int nextEle = nums[currIndex];\\n    \\n    if(nextEle <= currEle){\\n        return findLis(nums,n,currIndex+1,currEle);\\n    }\\n    \\n    int opt1 = 1 + findLis(nums,n,currIndex+1,nextEle);\\n    int opt2 = findLis(nums,n,currIndex+1,currEle);\\n    return max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //first we will try to solve this problem by using recursion only\\n        //so this is just recursion approach\\n        \\n        int n = nums.size();\\n        if(n == 0 || n == 1)  return n;\\n        \\n        int maxLis = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            //single element always forms a lis\\n            //you have to start dearching from the i+1 index in the nums array\\n            int currLenOfLis = findLis(nums,n,i+1,nums[i]);\\n            \\n            if(currLenOfLis > maxLis){\\n                maxLis = currLenOfLis;\\n            }\\n            \\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```\\n***Top-Down***\\nHere memoization can be done only using the 2-d array, no scope for using 1-D array for this purpose.\\n```\\nint findLis(vector<int>& nums,int n,int currIndex,int currEle,int prevIndex,vector<vector<int>>& dp){\\n    \\n    if(currIndex >= n){\\n        return 1;\\n    }\\n    if(dp[prevIndex][currIndex] != -1)  return dp[prevIndex][currIndex];    \\n    int nextEle = nums[currIndex];\\n    \\n    if(nextEle <= currEle){\\n        return findLis(nums,n,currIndex+1,currEle,prevIndex,dp);\\n    }\\n    \\n    int opt1 = 1 + findLis(nums,n,currIndex+1,nextEle,currIndex,dp);\\n    int opt2 = findLis(nums,n,currIndex+1,currEle,prevIndex,dp);\\n    return dp[prevIndex][currIndex] =  max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //first we will try to solve this problem by using recursion only\\n        //so this is just recursion approach\\n        \\n        int n = nums.size();\\n        if(n == 0 || n == 1)  return n;\\n        \\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        \\n        int maxLis = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            //single element always forms a lis\\n            //you have to start dearching from the i+1 index in the nums array\\n            int currLenOfLis = findLis(nums,n,i+1,nums[i],i,dp);\\n            \\n            if(currLenOfLis > maxLis){\\n                maxLis = currLenOfLis;\\n            }\\n            \\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```\\n***Bottom-Up***\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //now we will try bottom-up approach\\n        int n = nums.size();\\n        if(n == 0 || n == 1)    return n;\\n        vector<int> dp(n,1);\\n        int maxLen = 1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<i;j++){\\n                if(nums[j] < nums[i]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }    \\n            }\\n            if(dp[i] > maxLen)  maxLen = dp[i];\\n            \\n        }\\n        \\n        \\n        return maxLen;\\n    }\\n};\\n```\\n***Binary Search***\\n```\\nint findUsingBinarySearch(vector<int>& temp,int start,int end,int currEle){\\n    \\n    while(start <= end){\\n        \\n        int middle = (start+end)/2;\\n        \\n        if(temp[middle] > currEle){\\n            if(middle == 0) return middle;\\n            if(temp[middle-1] < currEle){\\n                return middle;\\n            }\\n        }\\n        \\n        if(temp[middle] < currEle){\\n            start = middle+1;\\n        }else{\\n            end = middle-1;\\n        }\\n        \\n    }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //we will be using binary search to find out the lis\\n        //time complexity for this code will be O(nlogn)\\n        \\n        int n = nums.size();\\n        if(n  == 0 || n == 1)   return n;\\n        \\n        vector<int> temp;\\n        \\n        int maxLen = 1;\\n        \\n        for(int i=0;i<n;i++){\\n            int currEle = nums[i];\\n            int len = temp.size();\\n            \\n            if(temp.size() == 0){\\n                temp.push_back(currEle);\\n            }else{\\n                if(temp[len-1] < currEle){\\n                    temp.push_back(currEle);\\n                }else{\\n                    //find and replace using binary search\\n                    int index = findUsingBinarySearch(temp,0,len-1,currEle);\\n                    if(index != -1)\\n                        temp[index] = currEle;\\n                }\\n            }\\n            \\n            if(temp.size() > maxLen){\\n                maxLen = temp.size();\\n            }\\n            \\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```\\n\\nhope it helps!!\\n\\nhope it helps!!",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nint findLis(vector<int>& nums,int n,int currIndex,int currEle){\\n    \\n    if(currIndex >= n){\\n        return 1;\\n    }\\n    \\n    int nextEle = nums[currIndex];\\n    \\n    if(nextEle <= currEle){\\n        return findLis(nums,n,currIndex+1,currEle);\\n    }\\n    \\n    int opt1 = 1 + findLis(nums,n,currIndex+1,nextEle);\\n    int opt2 = findLis(nums,n,currIndex+1,currEle);\\n    return max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //first we will try to solve this problem by using recursion only\\n        //so this is just recursion approach\\n        \\n        int n = nums.size();\\n        if(n == 0 || n == 1)  return n;\\n        \\n        int maxLis = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            //single element always forms a lis\\n            //you have to start dearching from the i+1 index in the nums array\\n            int currLenOfLis = findLis(nums,n,i+1,nums[i]);\\n            \\n            if(currLenOfLis > maxLis){\\n                maxLis = currLenOfLis;\\n            }\\n            \\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```\n```\\nint findLis(vector<int>& nums,int n,int currIndex,int currEle,int prevIndex,vector<vector<int>>& dp){\\n    \\n    if(currIndex >= n){\\n        return 1;\\n    }\\n    if(dp[prevIndex][currIndex] != -1)  return dp[prevIndex][currIndex];    \\n    int nextEle = nums[currIndex];\\n    \\n    if(nextEle <= currEle){\\n        return findLis(nums,n,currIndex+1,currEle,prevIndex,dp);\\n    }\\n    \\n    int opt1 = 1 + findLis(nums,n,currIndex+1,nextEle,currIndex,dp);\\n    int opt2 = findLis(nums,n,currIndex+1,currEle,prevIndex,dp);\\n    return dp[prevIndex][currIndex] =  max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //first we will try to solve this problem by using recursion only\\n        //so this is just recursion approach\\n        \\n        int n = nums.size();\\n        if(n == 0 || n == 1)  return n;\\n        \\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        \\n        int maxLis = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            //single element always forms a lis\\n            //you have to start dearching from the i+1 index in the nums array\\n            int currLenOfLis = findLis(nums,n,i+1,nums[i],i,dp);\\n            \\n            if(currLenOfLis > maxLis){\\n                maxLis = currLenOfLis;\\n            }\\n            \\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //now we will try bottom-up approach\\n        int n = nums.size();\\n        if(n == 0 || n == 1)    return n;\\n        vector<int> dp(n,1);\\n        int maxLen = 1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<i;j++){\\n                if(nums[j] < nums[i]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }    \\n            }\\n            if(dp[i] > maxLen)  maxLen = dp[i];\\n            \\n        }\\n        \\n        \\n        return maxLen;\\n    }\\n};\\n```\n```\\nint findUsingBinarySearch(vector<int>& temp,int start,int end,int currEle){\\n    \\n    while(start <= end){\\n        \\n        int middle = (start+end)/2;\\n        \\n        if(temp[middle] > currEle){\\n            if(middle == 0) return middle;\\n            if(temp[middle-1] < currEle){\\n                return middle;\\n            }\\n        }\\n        \\n        if(temp[middle] < currEle){\\n            start = middle+1;\\n        }else{\\n            end = middle-1;\\n        }\\n        \\n    }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        //we will be using binary search to find out the lis\\n        //time complexity for this code will be O(nlogn)\\n        \\n        int n = nums.size();\\n        if(n  == 0 || n == 1)   return n;\\n        \\n        vector<int> temp;\\n        \\n        int maxLen = 1;\\n        \\n        for(int i=0;i<n;i++){\\n            int currEle = nums[i];\\n            int len = temp.size();\\n            \\n            if(temp.size() == 0){\\n                temp.push_back(currEle);\\n            }else{\\n                if(temp[len-1] < currEle){\\n                    temp.push_back(currEle);\\n                }else{\\n                    //find and replace using binary search\\n                    int index = findUsingBinarySearch(temp,0,len-1,currEle);\\n                    if(index != -1)\\n                        temp[index] = currEle;\\n                }\\n            }\\n            \\n            if(temp.size() > maxLen){\\n                maxLen = temp.size();\\n            }\\n            \\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160546,
                "title": "tc-o-n-log-n-best-solution-recursion-memoization-tabulation-space-optimization-dp-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n->Recursion\\n    \\n//tc= o(2^n)\\n//sc=o(n)\\n\\nclass Solution {\\npublic:\\n    \\n    int f(int ind,int prev,vector<int>&nums,int n)\\n    {\\n        if(ind==n) return 0;\\n        int len= 0 + f(ind+1,prev,nums,n);\\n\\n        if(prev==-1 || nums[ind]>nums[prev])\\n        len=max(len,1+f(ind+1,ind,nums,n));\\n\\n        return len;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        return f(0,-1,nums,n);\\n    }\\n};\\n\\n---------------------------------------------------------------------\\n        \\n-Memoization\\n\\nclass Solution {\\npublic:\\n\\n    int ff(int ind,int prev,vector<int>&nums,int n,vector<vector<int>>&dp)\\n    {\\n        if(ind==n) return 0;\\n        if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];\\n        int len= 0 + ff(ind+1,prev,nums,n,dp);\\n\\n        if(prev==-1 || nums[ind]>nums[prev])\\n        len=max(len,1+ff(ind+1,ind,nums,n,dp));\\n\\n        return dp[ind][prev+1]=len;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        return ff(0,-1,nums,n,dp);\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n\\n->Tabulation\\n\\nclass Solution {\\npublic:\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=ind-1;prev>=-1;prev--)\\n            {\\n                int len=0+dp[ind+1][prev+1];\\n\\n                if(prev==-1 || nums[ind]>nums[prev])\\n                len=max(len,1+dp[ind+1][ind+1]);\\n\\n                dp[ind][prev+1]=len;\\n            }\\n        }\\n        return dp[0][-1+1];\\n    }\\n};\\n\\n---------------------------------------------------------------------\\n\\n->Space Optimized\\n\\n//tc=o(n^2)\\n//sc=o(n)*2\\n\\nclass Solution {\\npublic:\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>next(n+1,0),curr(n+1,0);\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=ind-1;prev>=-1;prev--)\\n            {\\n                int len=0+next[prev+1];\\n\\n                if(prev==-1 || nums[ind]>nums[prev])\\n                len=max(len,1+next[ind+1]);\\n\\n                curr[prev+1]=len;\\n            }\\n            next=curr;\\n        }\\n        return next[-1+1];\\n    }\\n};\\n\\n---------------------------------------------------------------------\\n\\n->More Optimized\\n\\nclass Solution {\\npublic:\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        int maxi=0;\\n        for(int ind=0;ind<n;ind++)\\n        {\\n            for(int prev=0;prev<ind;prev++)\\n            {\\n                if(nums[prev]<nums[ind])\\n                dp[ind]=max(dp[ind],1+dp[prev]);\\n            }\\n            maxi=max(maxi,dp[ind]);\\n        }\\n        return maxi;\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n\\n->Binary Search Method\\n\\nclass Solution {\\npublic:\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        temp.push_back(nums[0]);\\n        int len=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>temp.back())\\n            {\\n                temp.push_back(nums[i]);\\n                len++;\\n            }\\n            else\\n            {\\n                int ind=lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                temp[ind]=nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int ind,int prev,vector<int>&nums,int n)\\n    {\\n        if(ind==n) return 0;\\n        int len= 0 + f(ind+1,prev,nums,n);\\n\\n        if(prev==-1 || nums[ind]>nums[prev])\\n        len=max(len,1+f(ind+1,ind,nums,n));\\n\\n        return len;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2396727,
                "title": "simple-short-explained-solution-by-mr-coder",
                "content": "**YOU CAN WATCH THIS VIDEO FOR THE EXPLANATION**\\n**Recommended- **\\nhttps://www.youtube.com/watch?v=sokaFqeYaww\\n\\nMust Not Forget To Upvote this-\\n\\nclass Solution {\\npublic:\\n    int sol(int index, int prev, vector<int>& nums,int n,  vector<vector<int>> &v ){\\n      \\n        if(index==n) return 0;// base\\n        if(v[index][prev+1]!=-1) return v[index][prev+1];\\n       int len= 0+ sol(index+1, prev, nums,n, v);\\n        if(prev==-1 || nums[index]> nums[prev])\\n        {\\n          len= max(len,1+ sol(index+1, index, nums,n, v));  \\n            \\n        }\\n        return v[index][prev+1]= len;\\n    }\\n    \\n    \\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n       int n=  nums.size();// vector size\\n        vector<vector<int>> v(n, vector<int>(n+1, -1));\\n      \\n        return sol(0, -1, nums,n,v);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sol(int index, int prev, vector<int>& nums,int n,  vector<vector<int>> &v ){\\n      \\n        if(index==n) return 0;// base\\n        if(v[index][prev+1]!=-1) return v[index][prev+1];\\n       int len= 0+ sol(index+1, prev, nums,n, v);\\n        if(prev==-1 || nums[index]> nums[prev])\\n        {\\n          len= max(len,1+ sol(index+1, index, nums,n, v));  \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 719603,
                "title": "python-recursion-with-memo-with-pictures",
                "content": "The recursive solution cannot reliably pass all the tests. Kind of hit or miss. But the thinking is \\nrather straightforward.\\n\\nWe build the tree by iterating from the list. And every step one can make a\\n    decision to take or not to take that value at each level. Hence, we grow \\n    that has `2^n` nodes basing off a list of size n.\\n\\t\\nso in a nutshell, it\\'s `max(take, notake)`. Post order traversal if you will. \\n    take would be left tree, and notake would be the right tree.\\n\\t\\nin the case of take, there is two situations: if the last value in the previous \\n    sequence is smaller than the value we intend to take, then the length of sequence \\n    is +1. However, if it\\'s not, then we got something like [9,2] and the result will \\n    be invalid. And that\\'s why I\\'d reset it to -inf every time this happens.\\n    \\n\\n![image](https://assets.leetcode.com/users/images/95e9667a-c091-4d69-ba1d-31b1ae0dd5c3_1593885245.8503244.png)\\n\\n\\n```\\nclass Solution:\\n    from math import inf\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def length_of_longest_sequence(prev_largest, curr_position):\\n            if curr_position == len(nums):\\n                return 0\\n            if (prev_largest, curr_position) in memo:\\n                return memo[(prev_largest, curr_position)]\\n            take = -inf\\n            notake = length_of_longest_sequence(prev_largest, curr_position + 1)\\n            c_val = nums[curr_position]\\n            if c_val > prev_largest:\\n                take = length_of_longest_sequence(c_val, curr_position + 1) + 1\\n\\n            result = max(take, notake)\\n            memo[(prev_largest, curr_position)] = result\\n            return result\\n\\n        return length_of_longest_sequence(-inf, 0)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    from math import inf\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def length_of_longest_sequence(prev_largest, curr_position):\\n            if curr_position == len(nums):\\n                return 0\\n            if (prev_largest, curr_position) in memo:\\n                return memo[(prev_largest, curr_position)]\\n            take = -inf\\n            notake = length_of_longest_sequence(prev_largest, curr_position + 1)\\n            c_val = nums[curr_position]\\n            if c_val > prev_largest:\\n                take = length_of_longest_sequence(c_val, curr_position + 1) + 1\\n\\n            result = max(take, notake)\\n            memo[(prev_largest, curr_position)] = result\\n            return result\\n\\n        return length_of_longest_sequence(-inf, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223258,
                "title": "javascript-binary-search-nlog-n",
                "content": "Solution inspired by https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/\\n\\n```\\nvar lengthOfLIS = function(nums) {\\n    \\n    if(!nums.length) return 0;\\n    \\n    // dynamic length because JavaScript is awesome like that :)\\n    // hence we don\\'t need to track of the current running length of tails\\n    const tails = [];\\n    \\n    tails[0] = nums[0];\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        \\n        // replace current nums[i] with head if it\\'s smaller\\n        if(nums[i] < tails[0]) {\\n            tails[0] = nums[i];     \\n        // if current nums[i] is bigger than the largest value we\\'ve recorded\\n        // we can extend our tails by current nums[i]\\n        } else if(nums[i] > tails[tails.length-1]) {\\n            tails.push(nums[i]);\\n        } else {\\n            // using binary search to find the insertion point of current nums[i]\\n            // return r because we\\'re looking to replace index of tail that\\'s greater than nums[i]\\n            let l = 0;\\n            let r = tails.length-1;\\n            while(l < r) {\\n                const mid = (l+r)/2 >> 0;\\n                if(tails[mid] >= nums[i]) {\\n                    r = mid\\n                } else {\\n                    l = mid + 1;\\n                }\\n            }\\n            tails[r] = nums[i];\\n        }\\n        \\n    }\\n    \\n    return tails.length;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar lengthOfLIS = function(nums) {\\n    \\n    if(!nums.length) return 0;\\n    \\n    // dynamic length because JavaScript is awesome like that :)\\n    // hence we don\\'t need to track of the current running length of tails\\n    const tails = [];\\n    \\n    tails[0] = nums[0];\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        \\n        // replace current nums[i] with head if it\\'s smaller\\n        if(nums[i] < tails[0]) {\\n            tails[0] = nums[i];     \\n        // if current nums[i] is bigger than the largest value we\\'ve recorded\\n        // we can extend our tails by current nums[i]\\n        } else if(nums[i] > tails[tails.length-1]) {\\n            tails.push(nums[i]);\\n        } else {\\n            // using binary search to find the insertion point of current nums[i]\\n            // return r because we\\'re looking to replace index of tail that\\'s greater than nums[i]\\n            let l = 0;\\n            let r = tails.length-1;\\n            while(l < r) {\\n                const mid = (l+r)/2 >> 0;\\n                if(tails[mid] >= nums[i]) {\\n                    r = mid\\n                } else {\\n                    l = mid + 1;\\n                }\\n            }\\n            tails[r] = nums[i];\\n        }\\n        \\n    }\\n    \\n    return tails.length;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74863,
                "title": "2-o-n-2-dp-solutions-explanation-for-people-who-has-difficulty-in-understanding-the-dp-approach",
                "content": "I want to share 2 DP solutions for this problem. \\nFirst one came to my mind at first. It is slower but I think it can help people who is new to DP and having difficulty in visualizing it. So I want to share:\\n\\nLet's take the array in the problem \\n[10, 9, 2, 5, 3, 7, 101, 18]\\nFor each element we write the elements bigger than it into a list (will form an array of lists)\\n10 -> 101,18\\n9 -> 101,18\\n2 -> 5,3,7,101,18\\n5 -> 7,101,18\\n3 -> 7,101,18\\n7 -> 101,18\\n101 -> no element\\n18 -> no element since it is the last element\\n\\nThen we define our dp array. And dp[len-1] = 1 which stands for 18. It is 1 because 18 is the only element in the subsequence that can be formed since it is the last element.\\n\\nWe traverse the array reverse and assign each dp element by this way:\\nFor 101 : there is no element in its list so dp[len-2] = 1 \\nFor 7: There are 18 and 101 in its list so two subsequence alternatives are 7-18 or 7-101. So we see that our dp equation is dp[7] = Max(dp[101],dp[18]) + 1 = 1 + 1 = 2. We add 1 because 7 will also be included in the subsequence (I wrote the numbers in the square brackets for easiness, they are related indexes in fact)\\nFor 3: dp[3] = Max(dp[7],dp[101],dp[18]) + 1 = 2 + 1 = 3. This means that the subsequence is 3-7-101 or 3-7-18.\\nWe continue for the remaining elements in the array and when the dp is fulled totally we return the maximum number in the dp:\\n\\nHere is the code:\\n```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums) {\\n        \\n        int len = nums.Length;\\n        if (len <= 1) return len;\\n        \\n        int[] dp = new int[len];\\n        List<int>[] arrList = new List<int>[len - 1];\\n        \\n        for (int i = 0; i < len - 1; i++){\\n            arrList[i] = new List<int>();\\n            for (int j  = i + 1; j < len; j++){\\n                if (nums[j] > nums[i])\\n                    arrList[i].Add(j);\\n            }\\n        }\\n        int max = 1;\\n        dp[len - 1] = 1;\\n        for (int i = len - 2; i >= 0; i--){\\n            for (int j = 0; j < arrList[i].Count; j++){\\n                dp[i] = Math.Max(dp[i], dp[arrList[i][j]]);\\n            }\\n            dp[i]++;\\n            max = Math.Max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\\nThis code has the time complexity of O(2(n^2)) which is O(n^2). Its performance is slow (beats 3-4%)\\n\\nThe faster O(n^2) code is:\\n```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums) {\\n        \\n        int len = nums.Length;\\n        if (len <= 1) return len;\\n        \\n        int max = 1;\\n        int[] dp = new int[len];\\n        dp[0] = 1;\\n        for (int i = 1; i < len; i++){\\n            for (int j  = 0; j < i; j++){\\n                if (nums[j] < nums[i])\\n                    dp[i] = Math.Max(dp[i], dp[j]);\\n            }\\n            dp[i]++;\\n            max = Math.Max(max, dp[i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\nThis is faster than the previos one (beats 10-11%). But still slow since there is an O(nlogn) solution for this problem.\\n\\nIt has been a long post :)\\nI hope it helps..",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums) {\\n        \\n        int len = nums.Length;\\n        if (len <= 1) return len;\\n        \\n        int[] dp = new int[len];\\n        List<int>[] arrList = new List<int>[len - 1];\\n        \\n        for (int i = 0; i < len - 1; i++){\\n            arrList[i] = new List<int>();\\n            for (int j  = i + 1; j < len; j++){\\n                if (nums[j] > nums[i])\\n                    arrList[i].Add(j);\\n            }\\n        }\\n        int max = 1;\\n        dp[len - 1] = 1;\\n        for (int i = len - 2; i >= 0; i--){\\n            for (int j = 0; j < arrList[i].Count; j++){\\n                dp[i] = Math.Max(dp[i], dp[arrList[i][j]]);\\n            }\\n            dp[i]++;\\n            max = Math.Max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums) {\\n        \\n        int len = nums.Length;\\n        if (len <= 1) return len;\\n        \\n        int max = 1;\\n        int[] dp = new int[len];\\n        dp[0] = 1;\\n        for (int i = 1; i < len; i++){\\n            for (int j  = 0; j < i; j++){\\n                if (nums[j] < nums[i])\\n                    dp[i] = Math.Max(dp[i], dp[j]);\\n            }\\n            dp[i]++;\\n            max = Math.Max(max, dp[i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398394,
                "title": "binary-search-approach-o-n-logn-time",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] a=new int[nums.length];int k=0;\\n        a[k]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<a[k]){\\n                int lb=0,ub=k;\\n                while(lb<=ub){\\n                    int mid=(lb+ub)/2;\\n                    if(a[mid]<nums[i])\\n                        lb=mid+1;\\n                    else\\n                        ub=mid-1;\\n                }\\n                a[lb]=nums[i];\\n            }\\n            else if(a[k]!=nums[i]){\\n                k++;\\n                a[k]=nums[i];\\n            } \\n        }\\n        return k+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] a=new int[nums.length];int k=0;\\n        a[k]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<a[k]){\\n                int lb=0,ub=k;\\n                while(lb<=ub){\\n                    int mid=(lb+ub)/2;\\n                    if(a[mid]<nums[i])\\n                        lb=mid+1;\\n                    else\\n                        ub=mid-1;\\n                }\\n                a[lb]=nums[i];\\n            }\\n            else if(a[k]!=nums[i]){\\n                k++;\\n                a[k]=nums[i];\\n            } \\n        }\\n        return k+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397960,
                "title": "java-dp-solution",
                "content": "class Solution {\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        int result = 1;\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                \\n                if(nums[i] > nums[j]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    result = Math.max(result, dp[i]);\\n                }\\n            }\\n        }\\n\\n    return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        int result = 1;\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                \\n                if(nums[i] > nums[j]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    result = Math.max(result, dp[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1643127,
                "title": "detailed-binary-search-dp-code",
                "content": "class Solution {\\npublic:\\n    \\n    int lower_bond(vector<int> &seq,int element){\\n        int lo=0;\\n        int hi=seq.size()-1;\\n        int mid;\\n        while(lo<hi){\\n            mid=lo+(hi-lo)/2;\\n            if(element<=seq[mid])\\n                hi=mid;\\n            else{\\n                lo=mid+1;\\n            }\\n            \\n        }\\n        return lo;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        vector<int> seq;\\n        seq.push_back(nums[0]);\\n        \\n        for(int i=0;    i<nums.size();  i++){\\n            if(seq.back()<nums[i]){\\n                seq.push_back(nums[i]);\\n            }\\n            else{\\n                int ind=lower_bond(seq,nums[i]);\\n                seq[ind]=nums[i];\\n            }\\n        }\\n        return  seq.size();\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int lower_bond(vector<int> &seq,int element){\\n        int lo=0;\\n        int hi=seq.size()-1;\\n        int mid;\\n        while(lo<hi){\\n            mid=lo+(hi-lo)/2;\\n            if(element<=seq[mid])\\n                hi=mid;\\n            else{\\n                lo=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1640922,
                "title": "python-o-n-lg-n-by-solitaire-dp-w-example-dp",
                "content": "**Hint**:\\n\\nPut each number in Solitarie order in American, Patience order in EU language, \\u63A5\\u9F8D\\u9806\\u5E8F in Chinese, \\uC194\\uB9AC\\uD14C\\uC5B4 in Korean, \\u30BD\\u30EA\\u30C6\\u30A3\\u30A2 in Japanese. \\n\\nthen **total slot number**  is the **length of longest increasing subsequence**.\\n\\n![image](https://assets.leetcode.com/users/images/a542159a-6bb0-4d8a-884e-357f469ec954_1640179049.307748.png)\\n[Image source: Wiki](https://en.wikipedia.org/wiki/Solitaire)\\n\\n\\n\\n---\\n\\n**Example**\\n\\n Given input = [10,9,2,5,3,7,101,18]\\n\\nOn **10**, no leftmost feasible slot, put 10 on new slot\\n\\n```\\n10\\n```\\n\\n---\\n\\nOn **9**, because 9<= 10, put 9 on leftmost feasible slot #0 \\n\\n```\\n10\\n9\\n```\\n\\n---\\n\\nOn **2**, because 2 <= 9, put 2 on leftmost feasible slot #0 \\n\\n```\\n10\\n9\\n2\\n```\\n\\n---\\n\\nOn **5**, because 5 > 2, there is no leftmost feasible slot, put 5 on new slot #1\\n\\n```\\n10  5\\n9\\n2\\n```\\n\\n---\\n\\nOn **3**, because 3 <= 5, put 3 on leftmost feasible slot is slot #1\\n\\n```\\n10  5\\n9   3\\n2\\n```\\n\\n---\\n\\nOn **7**, because 7 > 3, there is no leftmost feasible slot, put 7 on new slot #2\\n\\n```\\n10  5  7\\n9   3\\n2\\n```\\n\\n---\\n\\nOn **101**, because 101 > 7, there is no leftmost feasible slot, put 101 on new slot #3\\n\\n```\\n10  5  7  101\\n9   3\\n2\\n```\\n\\n---\\n\\nOn **18**, because 18 <= 101, put 18 on leftmost feasible slot is slot #3\\n\\n```\\n10  5  7  101\\n9   3      18\\n2\\n```\\n\\n---\\n\\nFinally, **length of longest increasing subsequence** = **total slot number** = 4\\n\\n**LIS = 4**\\nwith 2 -> 3 -> 7 -> 101 or 2 -> 3 -> 7 -> 18\\n\\n---\\n\\n**Implementation** by Solitaire order with O( n lg n ):\\n\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        Rightmost = -1\\n        poker_slot = []\\n        \\n        for number in nums:\\n            \\n            if not poker_slot or poker_slot[Rightmost] < number:\\n                poker_slot.append( number)\\n            \\n            else:\\n                inser_index = bisect.bisect_left(poker_slot, number)\\n                poker_slot[ inser_index ] = number\\n        \\n        return len(poker_slot)\\n```\\n\\n---\\n\\nor \\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        slots = [0 for _ in range(n)]\\n        \\n        valid_slot = 0\\n        \\n        for number in nums:\\n            \\n            # put number in solitarie order\\n            left, right = 0, valid_slot\\n            \\n            # binary search to find leftmost feasible slot index\\n            while left < right:\\n                \\n                mid = left + (right - left)//2\\n                \\n                if number > slots[mid]:\\n                    left = mid+1\\n                \\n                else:\\n                    right = mid\\n            \\n            # put current number to leftmost feasible slot\\n            put_index = left\\n            slots[put_index] = number\\n            valid_slot = max(put_index+1, valid_slot)\\n        \\n        return valid_slot\\n```\\n\\n---\\n\\n\\n[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ya4r7LZRl7E)\\n\\nShare another implementation with bottom-up 2D DP with O(n^2)\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:    \\n        \\n        size = len(nums)\\n        \\n        # default value is 1, because each array element itself can be smallest LIS with length = 1\\n        len_LIS = [1 for _ in range(size)]\\n        \\n        # for each subsequence ending at index i\\n        for i in range(size):\\n            \\n            # for each prefix subsequence ending at k\\n            for k in range(i):\\n            \\n                if nums[k] < nums[i]:\\n                    \\n                    # check if we can extend LIS length from prefix subsequence\\n                    len_LIS[i] = max(len_LIS[i], len_LIS[k]+1)\\n                    \\n        \\n        return max(len_LIS)\\n```\\n\\n---\\n\\nTime Complexity: O( n^2 ) on two-level nested loops\\n\\nSpace Complexity: O( n ) on DP table, len_LIS\\n\\n\\n\\n\\n---\\n\\n\\nShare another implementation with top-down 2D DP with O(n^2)\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:    \\n        \\n        # Use python native cache as memoization for DP\\n        @cache\\n        def dp( i ):\\n            # input: index i of array\\n            # output: solve LCS with array ending at index i\\n            \\n            if i == 0:\\n                ## Base case\\n                # nums[0] itself is the smallest increasing subsequence\\n                return 1\\n            \\n            ## General cases\\n            prev_LIS = [ dp(k) for k in range(i) ]\\n            cur_LIS = max( prev_LIS[k]+1 if (nums[k] < nums[i]) else 1 for k in range(i) )\\n            \\n            # update global LIS length\\n            dp.global_LIS_length = max(dp.global_LIS_length, cur_LIS)\\n            \\n            return cur_LIS\\n\\n        # ----------------------\\n\\n        \\n        # smallest LIS length is 1, because each array number itself can be the smallest LIS\\n        dp.global_LIS_length = 1\\n        \\n        dp( len(nums)-1 )\\n\\n        return dp.global_LIS_length\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n10\\n```\n```\\n10\\n9\\n```\n```\\n10\\n9\\n2\\n```\n```\\n10  5\\n9\\n2\\n```\n```\\n10  5\\n9   3\\n2\\n```\n```\\n10  5  7\\n9   3\\n2\\n```\n```\\n10  5  7  101\\n9   3\\n2\\n```\n```\\n10  5  7  101\\n9   3      18\\n2\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        Rightmost = -1\\n        poker_slot = []\\n        \\n        for number in nums:\\n            \\n            if not poker_slot or poker_slot[Rightmost] < number:\\n                poker_slot.append( number)\\n            \\n            else:\\n                inser_index = bisect.bisect_left(poker_slot, number)\\n                poker_slot[ inser_index ] = number\\n        \\n        return len(poker_slot)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        slots = [0 for _ in range(n)]\\n        \\n        valid_slot = 0\\n        \\n        for number in nums:\\n            \\n            # put number in solitarie order\\n            left, right = 0, valid_slot\\n            \\n            # binary search to find leftmost feasible slot index\\n            while left < right:\\n                \\n                mid = left + (right - left)//2\\n                \\n                if number > slots[mid]:\\n                    left = mid+1\\n                \\n                else:\\n                    right = mid\\n            \\n            # put current number to leftmost feasible slot\\n            put_index = left\\n            slots[put_index] = number\\n            valid_slot = max(put_index+1, valid_slot)\\n        \\n        return valid_slot\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:    \\n        \\n        size = len(nums)\\n        \\n        # default value is 1, because each array element itself can be smallest LIS with length = 1\\n        len_LIS = [1 for _ in range(size)]\\n        \\n        # for each subsequence ending at index i\\n        for i in range(size):\\n            \\n            # for each prefix subsequence ending at k\\n            for k in range(i):\\n            \\n                if nums[k] < nums[i]:\\n                    \\n                    # check if we can extend LIS length from prefix subsequence\\n                    len_LIS[i] = max(len_LIS[i], len_LIS[k]+1)\\n                    \\n        \\n        return max(len_LIS)\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:    \\n        \\n        # Use python native cache as memoization for DP\\n        @cache\\n        def dp( i ):\\n            # input: index i of array\\n            # output: solve LCS with array ending at index i\\n            \\n            if i == 0:\\n                ## Base case\\n                # nums[0] itself is the smallest increasing subsequence\\n                return 1\\n            \\n            ## General cases\\n            prev_LIS = [ dp(k) for k in range(i) ]\\n            cur_LIS = max( prev_LIS[k]+1 if (nums[k] < nums[i]) else 1 for k in range(i) )\\n            \\n            # update global LIS length\\n            dp.global_LIS_length = max(dp.global_LIS_length, cur_LIS)\\n            \\n            return cur_LIS\\n\\n        # ----------------------\\n\\n        \\n        # smallest LIS length is 1, because each array number itself can be the smallest LIS\\n        dp.global_LIS_length = 1\\n        \\n        dp( len(nums)-1 )\\n\\n        return dp.global_LIS_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395285,
                "title": "javascript-all-3-solutions",
                "content": "Solution 1, Dynamic programming\\nIn this solution we initialize a dp array\\n\\nFor this solution, and each index i, \\nif the current value `nums[i]` is greater than the previous value, `nums[j]` (since we index i from 1, and j from 0)\\n\\tWe have to ask ourselves, is the current state `dp[i]`, greater than the previous letter\\'s state, plus the current character, hence `dp[j]+1`\\n\\n```\\n\\tvar lengthOfLIS = function(nums){\\n\\t\\tconst dp = Array(nums.length).fill(1);\\n\\t\\tlet max = 1;\\n\\t\\tfor(let i = 0; i < nums.length; i++){\\n\\t\\t\\tfor(let = j = 1; j < i; j++){\\n\\t\\t\\t\\tif(nums[i] > nums[j]){\\n\\t\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j]+1);\\n\\t\\t\\t\\t\\tmax = Math.max(dp[i], max);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max\\n\\t}\\n```\\n\\nSolution 2, intelligent substring building\\nWhile the first solution requires us to loop from 0, to less than i in the `nums` array, this solution will require us to loop from inside the substring that we are building. \\nWe don\\'t need to initalize a dp array, however we will have a an array called `sub`\\n\\n```\\nvar lengthOfLIS = function(nums) {\\n    // implementing solution 2\\n    let sub = [nums[0]]; \\n    for(let i = 1; i< nums.length; i++){\\n        let currVal = nums[i]; \\n\\t\\t// important, this is from sub\\n        let prevVal = sub[i-1];\\n        if(currVal > prevVal){\\n            // meaning there is increasing\\n            // because prevVal is < currVal\\n            // push into subsequence array\\n            sub.push(currVal)\\n        } else {\\n            // currVal is smaller than previous\\n            // so this is not a continously increasing value\\n            // check from the beginning of our sub array\\n            let j = 0; \\n            while(currVal > sub[j]){\\n                j++;\\n            }\\n            sub[j] = currVal;\\n        }\\n        \\n    }\\n    return sub.length\\n};\\n```\\n\\nBinary search method\\n```\\nconst binarySearch = (array, currVal) => {\\n    let left = 0; \\n    let right = array.length - 1; \\n    while (left <= right) {\\n        let mid = Math.floor((left+right)/2);\\n    \\n        if(array[mid] < currVal){\\n            left = mid+1;\\n        } else {\\n            right = mid -1\\n        }\\n    }\\n    return left\\n}\\n\\nvar lengthOfLIS = function(nums) {\\n    const sub = [nums[0]]; \\n    for(let i = 1; i < nums.length; i++){\\n        const currVal = nums[i]; \\n        if(currVal > sub[sub.length-1]){\\n            sub.push(currVal);\\n        } else {\\n            const j = binarySearch(sub, currVal)\\n            sub[j] = currVal\\n        }\\n    }\\n    return sub.length\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tvar lengthOfLIS = function(nums){\\n\\t\\tconst dp = Array(nums.length).fill(1);\\n\\t\\tlet max = 1;\\n\\t\\tfor(let i = 0; i < nums.length; i++){\\n\\t\\t\\tfor(let = j = 1; j < i; j++){\\n\\t\\t\\t\\tif(nums[i] > nums[j]){\\n\\t\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j]+1);\\n\\t\\t\\t\\t\\tmax = Math.max(dp[i], max);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max\\n\\t}\\n```\n```\\nvar lengthOfLIS = function(nums) {\\n    // implementing solution 2\\n    let sub = [nums[0]]; \\n    for(let i = 1; i< nums.length; i++){\\n        let currVal = nums[i]; \\n\\t\\t// important, this is from sub\\n        let prevVal = sub[i-1];\\n        if(currVal > prevVal){\\n            // meaning there is increasing\\n            // because prevVal is < currVal\\n            // push into subsequence array\\n            sub.push(currVal)\\n        } else {\\n            // currVal is smaller than previous\\n            // so this is not a continously increasing value\\n            // check from the beginning of our sub array\\n            let j = 0; \\n            while(currVal > sub[j]){\\n                j++;\\n            }\\n            sub[j] = currVal;\\n        }\\n        \\n    }\\n    return sub.length\\n};\\n```\n```\\nconst binarySearch = (array, currVal) => {\\n    let left = 0; \\n    let right = array.length - 1; \\n    while (left <= right) {\\n        let mid = Math.floor((left+right)/2);\\n    \\n        if(array[mid] < currVal){\\n            left = mid+1;\\n        } else {\\n            right = mid -1\\n        }\\n    }\\n    return left\\n}\\n\\nvar lengthOfLIS = function(nums) {\\n    const sub = [nums[0]]; \\n    for(let i = 1; i < nums.length; i++){\\n        const currVal = nums[i]; \\n        if(currVal > sub[sub.length-1]){\\n            sub.push(currVal);\\n        } else {\\n            const j = binarySearch(sub, currVal)\\n            sub[j] = currVal\\n        }\\n    }\\n    return sub.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326968,
                "title": "c-greedy-binary-search-and-dp",
                "content": "Approach 1: binary search with greedy flavor\\nTime/Space Complexity: O(NlogN); O(N)\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {        \\n        vector<int> v;\\n        for (auto a : nums) {\\n            auto it = lower_bound(v.begin(), v.end(), a);\\n            if (it == v.end()) v.push_back(a);\\n            else *it = a;\\n        }        \\n\\u3000\\u3000\\u3000\\u3000 return v.size();\\n    }\\n};\\n```\\nNote: Althougth v.size() correctly keep the largest size for longest increasing subsequence, the final v is not necessarily contains the longest inscreasing subsequence.\\nFor example:\\nnums = [1,3,4,5,2,2,-1]\\nfinal v will be:  {-1, 2, 4, 5} \\n\\n\\nApproach 2: DP\\nTime/Space Complexity: O(N^2); O(N)\\ndp[i]:=  the length of the longest strictly increasing subsequence for nums[0:i] (include i)\\nor \\ndp[i]:=  the length of the longest strictly increasing subsequence for arrays ending in nums[i]\\ndp[i] = fucntion_of_relationship_between_i_and_its_neighbor(neighbor_of_i)\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n,1);\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j])\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```\\n\\nApproach 3: wrong DP (This is wrong solution. Only means to document my train of thinking)\\nThis is my initial response to the question.\\nI am wrong in 2 things: initial values and definition of neighbors.\\n1) initial value should be 1 instead of 0 since each num itself is a size=1 sequence\\n2) neihbors can be immediate left neighbors, can also be non-immediate left neighbors.\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n,0);\\n        for(int i = 0; i < n; i++)\\n            if(i > 0)\\n                dp[i] = nums[i-1] <nums[i] ? dp[i-1] + 1 : dp[i-1];\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {        \\n        vector<int> v;\\n        for (auto a : nums) {\\n            auto it = lower_bound(v.begin(), v.end(), a);\\n            if (it == v.end()) v.push_back(a);\\n            else *it = a;\\n        }        \\n\\u3000\\u3000\\u3000\\u3000 return v.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n,1);\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j])\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp(n,0);\\n        for(int i = 0; i < n; i++)\\n            if(i > 0)\\n                dp[i] = nums[i-1] <nums[i] ? dp[i-1] + 1 : dp[i-1];\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008117,
                "title": "python-3-brute-force-recursive-recursion-memo-dp-binary-search",
                "content": "**[Python 3] Brute force(Recursive) O(2N), Recursion + Memo O(N2), DP O(N2), Binary_search O(NlogN)**\\n```\\nclass Solution:\\n#     # Not used, just walk through algorithm, Brute force Recursively call \\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         if not nums:\\n#             return 0        \\n#         ret = 0\\n#         for i in range(len(nums)):\\n#             nxt = []\\n#             for j in range(i+1, len(nums)):\\n#                 # Bigger than ith element, put it into next recur call\\n#                 if nums[i] < nums[j]:\\n#                     nxt.append(nums[j])\\n            \\n#             # Call next recursive\\n#             # + 1 meaning is the next round can increase the result length\\n#             ret = max(ret, self.lengthOfLIS(nxt) + 1)\\n        \\n#         return ret\\n\\n#     # Brute force Recursively call \\n#     # TC: O(2**N) - the size of recurssion tree, \\n#     # SC: O(1)\\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         nums = [float(\"-inf\")] + nums\\n#         length_nums = len(nums)\\n        \\n#         def lis(arr, start, N):\\n#             ret = 0\\n#             for nxt in range(start + 1, N):\\n#                 if arr[start] < arr[nxt]:\\n#                     ret = max(ret, lis(arr, nxt, N) + 1)\\n\\n#             return ret\\n\\n#         return lis(nums, 0, length_nums)\\n\\n#     # Recursively call + Memoization: You can find the duplicate function call \\n#     # TC: O(N**2)\\n#     # e.i. 1 2 4 3 5\\n#     # lis([2,4,3,5]), 1 -> lis([2,4,3,5])\\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         nums = [float(\"-inf\")] + nums\\n#         length_nums = len(nums)\\n#         memo = [-1] * length_nums\\n\\n#         def lis(arr, start, cache, N):\\n#             if cache[start] != -1:\\n#                 return cache[start]\\n\\n#             ret = 0\\n#             for nxt in range(start+1, N):\\n#                 if arr[start] < arr[nxt]:\\n#                     ret = max(ret, lis(arr, nxt, cache, N) + 1)\\n\\n#             cache[start] = ret\\n#             return ret\\n\\n#         return lis(nums, 0, memo,length_nums)\\n    \\n    # Dynamic programming bottom up\\n    # TC: O(n**2) Two loop\\n    # SC: O(n) dp array of size n \\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [1] * N\\n        \\n        for i in range(N):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        \\n        return max(dp)\\n        \\n        \\n        \\n        \\n#   Binary search, only using it to get the length    \\n#   Add Bigger one, Update Smaller one\\n#   TC: O(nlogn)\\n#   SC: O(n)\\n# Do not need to sort, cause dp already sorted whenever we put the candidate\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def bSearch(arr, target): \\n            # Lower bound Bsearch\\n            i = 0\\n            j = len(arr)\\n            while i < j:\\n                mid = (i+j) // 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] < target:\\n                    i = mid+1\\n                else:\\n                    j = mid\\n            return i\\n                \\n        if not nums:\\n            return 0\\n        \\n        # Initialize\\n        dp = [nums[0]]\\n        for i in range(1, len(nums)):\\n            index = bSearch(dp, nums[i])\\n            if index == len(dp):\\n                # Add: nums[i] is bigger than the candidate\\n                dp.append(nums[i])\\n            else:\\n                # Update: nums[i] is smaller than other\\n                dp[index] = nums[i]\\n        return len(dp)\\n    \\n    \\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         def binarySearch(arr, start, end, target):\\n#             arr.sort()\\n#             l, r = start, end\\n#             while l < r:\\n#                 mid = (l+r)//2\\n#                 if arr[mid] < target:\\n#                     r = mid - 1\\n#                 else:\\n#                     l = mid + 1\\n#             return r\\n        \\n#         dp = [0 for _ in range(len(nums))]\\n#         n = 0\\n#         for num in nums:\\n#             i = binarySearch(dp, 0, n, num)\\n#             if i < 0:\\n#                 i = -(i + 1)\\n            \\n#             dp[i] = num;\\n#             if i == n:\\n#                 n +=1\\n        \\n#         return n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "**[Python 3] Brute force(Recursive) O(2N), Recursion + Memo O(N2), DP O(N2), Binary_search O(NlogN)**\\n```\\nclass Solution:\\n#     # Not used, just walk through algorithm, Brute force Recursively call \\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         if not nums:\\n#             return 0        \\n#         ret = 0\\n#         for i in range(len(nums)):\\n#             nxt = []\\n#             for j in range(i+1, len(nums)):\\n#                 # Bigger than ith element, put it into next recur call\\n#                 if nums[i] < nums[j]:\\n#                     nxt.append(nums[j])\\n            \\n#             # Call next recursive\\n#             # + 1 meaning is the next round can increase the result length\\n#             ret = max(ret, self.lengthOfLIS(nxt) + 1)\\n        \\n#         return ret\\n\\n#     # Brute force Recursively call \\n#     # TC: O(2**N) - the size of recurssion tree, \\n#     # SC: O(1)\\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         nums = [float(\"-inf\")] + nums\\n#         length_nums = len(nums)\\n        \\n#         def lis(arr, start, N):\\n#             ret = 0\\n#             for nxt in range(start + 1, N):\\n#                 if arr[start] < arr[nxt]:\\n#                     ret = max(ret, lis(arr, nxt, N) + 1)\\n\\n#             return ret\\n\\n#         return lis(nums, 0, length_nums)\\n\\n#     # Recursively call + Memoization: You can find the duplicate function call \\n#     # TC: O(N**2)\\n#     # e.i. 1 2 4 3 5\\n#     # lis([2,4,3,5]), 1 -> lis([2,4,3,5])\\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         nums = [float(\"-inf\")] + nums\\n#         length_nums = len(nums)\\n#         memo = [-1] * length_nums\\n\\n#         def lis(arr, start, cache, N):\\n#             if cache[start] != -1:\\n#                 return cache[start]\\n\\n#             ret = 0\\n#             for nxt in range(start+1, N):\\n#                 if arr[start] < arr[nxt]:\\n#                     ret = max(ret, lis(arr, nxt, cache, N) + 1)\\n\\n#             cache[start] = ret\\n#             return ret\\n\\n#         return lis(nums, 0, memo,length_nums)\\n    \\n    # Dynamic programming bottom up\\n    # TC: O(n**2) Two loop\\n    # SC: O(n) dp array of size n \\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [1] * N\\n        \\n        for i in range(N):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        \\n        return max(dp)\\n        \\n        \\n        \\n        \\n#   Binary search, only using it to get the length    \\n#   Add Bigger one, Update Smaller one\\n#   TC: O(nlogn)\\n#   SC: O(n)\\n# Do not need to sort, cause dp already sorted whenever we put the candidate\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def bSearch(arr, target): \\n            # Lower bound Bsearch\\n            i = 0\\n            j = len(arr)\\n            while i < j:\\n                mid = (i+j) // 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] < target:\\n                    i = mid+1\\n                else:\\n                    j = mid\\n            return i\\n                \\n        if not nums:\\n            return 0\\n        \\n        # Initialize\\n        dp = [nums[0]]\\n        for i in range(1, len(nums)):\\n            index = bSearch(dp, nums[i])\\n            if index == len(dp):\\n                # Add: nums[i] is bigger than the candidate\\n                dp.append(nums[i])\\n            else:\\n                # Update: nums[i] is smaller than other\\n                dp[index] = nums[i]\\n        return len(dp)\\n    \\n    \\n#     def lengthOfLIS(self, nums: List[int]) -> int:\\n#         def binarySearch(arr, start, end, target):\\n#             arr.sort()\\n#             l, r = start, end\\n#             while l < r:\\n#                 mid = (l+r)//2\\n#                 if arr[mid] < target:\\n#                     r = mid - 1\\n#                 else:\\n#                     l = mid + 1\\n#             return r\\n        \\n#         dp = [0 for _ in range(len(nums))]\\n#         n = 0\\n#         for num in nums:\\n#             i = binarySearch(dp, 0, n, num)\\n#             if i < 0:\\n#                 i = -(i + 1)\\n            \\n#             dp[i] = num;\\n#             if i == n:\\n#                 n +=1\\n        \\n#         return n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 74851,
                "title": "share-java-o-n-logn-solution",
                "content": "I saw this solution [here][1] a long time ago, for me it's really hard to think of it :)\\n\\n    public class Solution {\\n      public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        \\n        int n = nums.length, len = 1;\\n        int[] tailTable = new int[n];\\n        \\n        tailTable[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n          if (nums[i] < tailTable[0]) {\\n            // new smallest value\\n            tailTable[0] = nums[i];\\n          } else if (nums[i] > tailTable[len - 1]) {\\n            // nums[i] wants to extend largest subsequence\\n            tailTable[len++] = nums[i];\\n          } else {\\n            // nums[i] wants to be current end candidate of an existing subsequence\\n            // It will replace ceil value in tailTable\\n            tailTable[ceilIndex(tailTable, -1, len - 1, nums[i])] = nums[i];\\n          }\\n        }\\n    \\n        return len;\\n      }\\n      \\n      // binary search helper\\n      int ceilIndex(int[] tailTable, int lo, int hi, int key) {\\n        while (hi - lo > 1) {\\n          int mid = lo + (hi - lo) / 2;\\n            \\n          if (tailTable[mid] >= key) {\\n            hi = mid;\\n          } else {\\n            lo = mid;\\n          }\\n        }\\n        \\n        return hi;\\n      }\\n    }\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        \\n        int n = nums.length, len = 1;\\n        int[] tailTable = new int[n];\\n        \\n        tailTable[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n          if (nums[i] < tailTable[0]) {\\n            // new smallest value\\n            tailTable[0] = nums[i];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3755978,
                "title": "3-approaches-recursion-memoization-tabulation",
                "content": "### 1. Recusrion based approach\\n\\n```\\n    int solve(int cur, int prev, vector<int>& nums, int n){\\n        if(cur==n){return 0;}\\n        int len = 0 + solve(cur+1,prev,nums,n);\\n        if(prev==-1 || nums[cur]>nums[prev]){\\n            len = max(len,1+ solve(cur+1,cur,nums,n));\\n        }\\n        return len;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(0,-1,nums,nums.size());\\n    }\\n```\\n\\n### 2. Memoization\\n\\n```\\n    int solve(int cur, int prev, vector<int>& nums, int n, vector<vector<int>> & dp){\\n        if(cur==n){return 0;}\\n        if(dp[cur][prev+1]!=-1){return dp[cur][prev+1];}\\n        int len = 0 + solve(cur+1,prev,nums,n,dp);\\n        if(prev==-1 || nums[cur]>nums[prev]){\\n            len = max(len,1+ solve(cur+1,cur,nums,n,dp));\\n        }\\n        return dp[cur][prev+1]=len;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return solve(0,-1,nums,nums.size(),dp);\\n    }\\n```\\n\\n### 3. Tabulation\\n\\n```\\n    int lengthOfLIS(vector<int>& nums) {\\n            int nums_size = nums.size();\\n        vector<int> dp(nums_size,1);\\n        for(int i = nums_size - 2; i >= 0; --i){\\n            for(int j = i + 1; j<nums_size; ++j){\\n                if(nums[i] < nums[j]){\\n                    dp[i] = max(dp[i], 1+dp[j]);\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    int solve(int cur, int prev, vector<int>& nums, int n){\\n        if(cur==n){return 0;}\\n        int len = 0 + solve(cur+1,prev,nums,n);\\n        if(prev==-1 || nums[cur]>nums[prev]){\\n            len = max(len,1+ solve(cur+1,cur,nums,n));\\n        }\\n        return len;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve(0,-1,nums,nums.size());\\n    }\\n```\n```\\n    int solve(int cur, int prev, vector<int>& nums, int n, vector<vector<int>> & dp){\\n        if(cur==n){return 0;}\\n        if(dp[cur][prev+1]!=-1){return dp[cur][prev+1];}\\n        int len = 0 + solve(cur+1,prev,nums,n,dp);\\n        if(prev==-1 || nums[cur]>nums[prev]){\\n            len = max(len,1+ solve(cur+1,cur,nums,n,dp));\\n        }\\n        return dp[cur][prev+1]=len;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return solve(0,-1,nums,nums.size(),dp);\\n    }\\n```\n```\\n    int lengthOfLIS(vector<int>& nums) {\\n            int nums_size = nums.size();\\n        vector<int> dp(nums_size,1);\\n        for(int i = nums_size - 2; i >= 0; --i){\\n            for(int j = i + 1; j<nums_size; ++j){\\n                if(nums[i] < nums[j]){\\n                    dp[i] = max(dp[i], 1+dp[j]);\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433920,
                "title": "c-beats-100",
                "content": "![Screenshot (181).png](https://assets.leetcode.com/users/images/d6098bf3-7e02-4d56-8af0-aeb07814ba43_1681888686.6856155.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& v) {\\n        vector<int>a;\\n        a.push_back(v[0]);\\n        for(int i=1;i<v.size();i++){\\n            int in=lower_bound(a.begin(),a.end(),v[i])-a.begin();\\n            if(in>=a.size())a.push_back(v[i]);\\n            else a[in]=v[i];\\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& v) {\\n        vector<int>a;\\n        a.push_back(v[0]);\\n        for(int i=1;i<v.size();i++){\\n            int in=lower_bound(a.begin(),a.end(),v[i])-a.begin();\\n            if(in>=a.size())a.push_back(v[i]);\\n            else a[in]=v[i];\\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769922,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(ans.size()==0){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                int idx=lower_bound(ans.begin(),ans.end(),nums[i])-ans.begin();\\n                if(idx>=ans.size()){\\n                    ans.push_back(nums[i]);\\n                }\\n                else{\\n                    ans[idx]=nums[i];\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(ans.size()==0){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                int idx=lower_bound(ans.begin(),ans.end(),nums[i])-ans.begin();\\n                if(idx>=ans.size()){\\n                    ans.push_back(nums[i]);\\n                }\\n                else{\\n                    ans[idx]=nums[i];\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395661,
                "title": "python-99-65-clear-explanation-binary-search-easy-simple-approach",
                "content": "Basically, we just neet an array to keep tracking of small numbers, and replace the large one. \\nSo, here\\'s the solution to the problem:\\n![image](https://assets.leetcode.com/users/images/5a440fed-6dce-4973-be58-cd5d0a8b0931_1659925344.8676472.png)\\n\\ncode:\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        ans = [nums.pop(0)]         # use this list to track increasing\\n        \\n        for num in nums:            # add current number into the list\\n            if num > ans[-1]:\\n                ans.append(num)\\n            else:\\n                ans[bisect_left(ans, num)] = num\\n                \\n        return len(ans)\\n```\\n**Please UPVOTE if you LIKE !!**\\n![image](https://assets.leetcode.com/users/images/3a759dab-b066-4531-8c21-0d72f49332da_1659925417.8529832.png)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        \\n        ans = [nums.pop(0)]         # use this list to track increasing\\n        \\n        for num in nums:            # add current number into the list\\n            if num > ans[-1]:\\n                ans.append(num)\\n            else:\\n                ans[bisect_left(ans, num)] = num\\n                \\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395428,
                "title": "daily-leetcoding-challenge-august-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Intelligently Build a Subsequence\n\n  \n**Approach 3:** Improve With Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1798747,
                "title": "dp-based-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        int* output = new int[n];\\n        output[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            output[i]=1;\\n            \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]>=nums[i])\\n                {\\n                    continue;\\n                }\\n                \\n                int posbAns= output[j] + 1;\\n                if(posbAns > output[i])\\n                   output[i]=posbAns;\\n            \\n              }\\n        }\\n        \\n        int best=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(best < output[i])\\n                best=output[i];\\n        }\\n        delete [] output;\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        int* output = new int[n];\\n        output[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            output[i]=1;\\n            \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]>=nums[i])\\n                {\\n                    continue;\\n                }\\n                \\n                int posbAns= output[j] + 1;\\n                if(posbAns > output[i])\\n                   output[i]=posbAns;\\n            \\n              }\\n        }\\n        \\n        int best=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(best < output[i])\\n                best=output[i];\\n        }\\n        delete [] output;\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633874,
                "title": "2-solutions-binary-search-dynamic-progg",
                "content": "METHOD -1 \\n\\nBinary Search Solution\\nTime - O(n logn)\\nSpace - O(n)\\n\\n\\tAccepted\\t4 ms\\t10.3 MB\\tcpp\\n\\n* Let\\'s construct the idea from following example.\\n* Consider the example nums = [2, 6, 8, 3, 4, 5, 1], let\\'s try to build the increasing subsequences starting with an empty one: sub1 = [].\\n* Let pick the first element, sub1 = [2].\\n* 6 is greater than previous number, sub1 = [2, 6]\\n*  8 is greater than previous number, sub1 = [2, 6, 8]\\n* 3 is less than previous number, we can\\'t extend the subsequence sub1, but we must keep 3 because in the future there may have the longest subsequence start with [2, 3], sub1 = [2, 6, 8], sub2 = [2, 3].\\n* With 4, we can\\'t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4].\\n* With 5, we can\\'t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5].\\n* With 1, we can\\'t extend neighter sub1 nor sub2, but we need to keep 1, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1].\\n* Finally, length of longest increase subsequence = len(sub2) = 4.\\n\\nIn the above steps, we need to keep different sub arrays (sub1, sub2..., subk) which causes poor performance. But we notice that we can just keep one sub array, when new number x is not greater than the last element of the subsequence sub, we do binary search to find the smallest element >= x in sub, and replace with number x.\\n\\n* Let\\'s run that example nums = [2, 6, 8, 3, 4, 5, 1] again:\\n* Let pick the first element, sub = [2].\\n* 6 is greater than previous number, sub = [2, 6]\\n* 8 is greater than previous number, sub = [2, 6, 8]\\n* 3 is less than previous number, so we can\\'t extend the subsequence sub. We need to find the smallest number >= 3 in sub, it\\'s 6. Then we overwrite it, now sub = [2, 3, 8].\\n* 4 is less than previous number, so we can\\'t extend the subsequence sub. We overwrite 8 by 4, so sub = [2, 3, 4].\\n* 5 is greater than previous number, sub = [2, 3, 4, 5].\\n* 1 is less than previous number, so we can\\'t extend the subsequence sub. We overwrite 2 by 1, so sub = [1, 3, 4, 5].\\n* Finally, length of longest increase subsequence = len(sub) = 4.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>v;\\n        \\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[v.size()-1]<nums[i])\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else if(v[v.size()-1]>nums[i])\\n            {\\n                auto it = lower_bound(v.begin(),v.end(),nums[i]);\\n                *it = nums[i];\\n            }\\n        }\\n        \\n        return v.size();\\n    }\\n};\\n\\n// example\\n// 4 5 6 1 2 7 8 9 \\n\\n// v1 = 4\\n// v1 = 4 5 \\n// v1 =  4 5 6\\n// v1 = 4 5 6 , v2 = 1\\n// v1 = 4 5 6 , v2 = 1 2 \\n// v1 = 4 5 6 7 , v2 = 1 2 7\\n// v1 = 4 5 6 7 8, v2 = 1 2 7 8\\n// v1 = 4 5 6 7 8 9, v2 = 1 2 7 8 9 \\n\\n// 4\\n// 4 5\\n// 4 5 6\\n// 1 5 6\\n// 1 2 6\\n// 1 2 6 7\\n// 1 2 6 7 8\\n// 1 2 6 7 8 9\\n```\\n\\nMETHOD - 2\\n\\nDP Solution\\nTime - O(n^2)\\nSpace - O(n)\\n\\n\\tAccepted\\t192 ms\\t10.2 MB\\tcpp\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size(),maxa,ans=INT_MIN;\\n        int dp[n];\\n        dp[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            maxa=-1;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[j]>maxa)\\n                    {\\n                        maxa=dp[j];\\n                    }\\n                }\\n            }\\n            if(maxa==-1)\\n                dp[i]=1;\\n            else\\n                dp[i]=maxa+1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>v;\\n        \\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[v.size()-1]<nums[i])\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else if(v[v.size()-1]>nums[i])\\n            {\\n                auto it = lower_bound(v.begin(),v.end(),nums[i]);\\n                *it = nums[i];\\n            }\\n        }\\n        \\n        return v.size();\\n    }\\n};\\n\\n// example\\n// 4 5 6 1 2 7 8 9 \\n\\n// v1 = 4\\n// v1 = 4 5 \\n// v1 =  4 5 6\\n// v1 = 4 5 6 , v2 = 1\\n// v1 = 4 5 6 , v2 = 1 2 \\n// v1 = 4 5 6 7 , v2 = 1 2 7\\n// v1 = 4 5 6 7 8, v2 = 1 2 7 8\\n// v1 = 4 5 6 7 8 9, v2 = 1 2 7 8 9 \\n\\n// 4\\n// 4 5\\n// 4 5 6\\n// 1 5 6\\n// 1 2 6\\n// 1 2 6 7\\n// 1 2 6 7 8\\n// 1 2 6 7 8 9\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size(),maxa,ans=INT_MIN;\\n        int dp[n];\\n        dp[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            maxa=-1;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[j]>maxa)\\n                    {\\n                        maxa=dp[j];\\n                    }\\n                }\\n            }\\n            if(maxa==-1)\\n                dp[i]=1;\\n            else\\n                dp[i]=maxa+1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326856,
                "title": "longest-increasing-subsequence-o-n-logn-c-java-python-simple-code-explained",
                "content": "The trick is to **take the minimum possible element**.\\n\\nWe simply traverse the input one by one.\\n\\nI will be explaining from most simple test case:\\n1. **`==> [10]`**\\n\\there we see one element push it in our current sequence.\\n\\tThe answer is simply one (size of sequence **[10]**).\\n\\t\\n2. **`==> [10,  9]`**\\n\\tAs you can see the Longest Increasing subsequence can be of size 1.\\n\\tEither taking **[10]** or **[9]** as we cannot take [10, 9].\\n\\tWe first encounter 10.\\n\\t- Push it into our subsequence.\\n\\t  - Now we have the subsequence as **[10]**.\\n\\t- Next element we encounter is **9**. We remove **10** and put **9** since we **want to be able to add more possible numbers into our subsequence; we take smaller number.**\\n\\tThe answer is 1 here in this case (size of final subsequence **[9]**)\\n\\n3. **`==> [10, 9, 2]`**\\n\\tProceeding as done in the above test case:\\n\\t- `Encounter 10:` add it to the subsequence (now **[10]**)\\n\\t- `Encounter 9:` Check `9` is not the greatest element till now, remove `10` and put `9`.\\n\\t- - Subsequence is now **[9]**.\\n\\t- `Encounter 2:` Check `2` is not the greatest element till now, remove `9` and put `2`.\\n\\t- - Subsequence is now **[2]**.\\n\\tThe answer to this test case is 1 here too case the size of final susbsequence **[2]** is still 1.\\n\\t\\n4. **`==> [10, 9, 2, 8]`**\\n\\tYou might be able to see now why we removed `10` (greater elements) by `9` (smaller element) and again by `2` (more smaller element).\\n\\tThat is to **simply ensure next numbers to fit well in the subsequence**.\\n\\tContinuing from previous test cases:\\n\\twe will have subsequence **[2]** after encountering the third element.\\n\\t- `For 4th element 8:` We check if `8` is not the greatest element in the subsequence. Since it is, we simply push it, now **[2, 8]**\\n\\tThe answer in this test case will be 2. size of **[2, 8]**\\n---\\nDry Run for example 1:\\n**`[10, 9, 2, 5, 3, 7, 101, 18]`**\\n```\\n\\tcurrent element = 10.   --> (Push the first element always)\\n\\tsubsequence: [10]\\n\\ni=1\\n\\tcurrent element = 9.    --> (remove 10 and put 9)\\n\\tsubsequence: [9]\\ni=2\\n\\tcurrent element = 2.    --> (remove 9 and put 2)\\n\\tsubsequence: [2]\\ni=3\\n\\tcurrent element = 5.    --> push 5 (greatest till now)\\n\\tsubsequence: [2, 5]\\ni=4\\n\\tcurrent element = 3.    --> search for next greater element (remove it and put 3)\\n\\tsubsequence: [2, 3]\\ni=5\\n\\tcurrent element = 7.    -->  push 7 (greatest till now)\\n\\tsubsequence: [2, 3, 7]\\ni=6\\n\\tcurrent element = 101. --> push 101 (greatest till now)\\n\\tsubsequence: [2, 3, 7, 101]\\ni=7\\n\\tcurrent element = 18.    --> search for next greater element (remove it and put 18)\\n\\tsubsequence: [2, 3, 7, 18]\\n\\nFinal Answer = size of subsequence = 4\\n```\\n\\nTime Complexity: **`O ( N * log N ) `**\\n- traversing takes `N` time\\n  - For each we binary search the next greater element if need be. `log N` time\\n\\n\\uD83D\\uDCBB **C++ Code**:\\n```\\n\\tint lengthOfLIS(vector<int>& nums) {\\n        vector<int> v(1, nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            if(v.back()<nums[i])\\n                v.push_back(nums[i]);\\n            else\\n                v[lower_bound(v.begin(), v.end(), nums[i])-v.begin()]=nums[i];\\n        return v.size();\\n    }\\n```\\n---\\n\\uD83D\\uDCBB **JAVA Code**:\\n```\\n\\tpublic int lengthOfLIS(int[] n) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(n[0]);\\n        for(int i=1;i<n.length;i++)\\n            if(al.get(al.size()-1) < n[i]) al.add(n[i]);\\n            else {\\n                int ind = Collections.binarySearch(al, n[i]);\\n                if(ind<0)al.set(-(ind+1), n[i]);\\n            }\\n        return al.size();\\n    }\\n```\\n---\\n\\uD83D\\uDCBB **PYTHON Code**:\\n```\\n\\t def lengthOfLIS(self, n):\\n        l = [n[0]]\\n        for i in n[1:]:\\n            if l[-1] < i:\\n                l.append(i)\\n            else:\\n                l[bisect_left(l,i)]=i\\n        return len(l)\\n```\\n---\\nWill soon update with other languages\\nHope its worth a vote and pls comment if you find anything off",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\tcurrent element = 10.   --> (Push the first element always)\\n\\tsubsequence: [10]\\n\\ni=1\\n\\tcurrent element = 9.    --> (remove 10 and put 9)\\n\\tsubsequence: [9]\\ni=2\\n\\tcurrent element = 2.    --> (remove 9 and put 2)\\n\\tsubsequence: [2]\\ni=3\\n\\tcurrent element = 5.    --> push 5 (greatest till now)\\n\\tsubsequence: [2, 5]\\ni=4\\n\\tcurrent element = 3.    --> search for next greater element (remove it and put 3)\\n\\tsubsequence: [2, 3]\\ni=5\\n\\tcurrent element = 7.    -->  push 7 (greatest till now)\\n\\tsubsequence: [2, 3, 7]\\ni=6\\n\\tcurrent element = 101. --> push 101 (greatest till now)\\n\\tsubsequence: [2, 3, 7, 101]\\ni=7\\n\\tcurrent element = 18.    --> search for next greater element (remove it and put 18)\\n\\tsubsequence: [2, 3, 7, 18]\\n\\nFinal Answer = size of subsequence = 4\\n```\n```\\n\\tint lengthOfLIS(vector<int>& nums) {\\n        vector<int> v(1, nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            if(v.back()<nums[i])\\n                v.push_back(nums[i]);\\n            else\\n                v[lower_bound(v.begin(), v.end(), nums[i])-v.begin()]=nums[i];\\n        return v.size();\\n    }\\n```\n```\\n\\tpublic int lengthOfLIS(int[] n) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(n[0]);\\n        for(int i=1;i<n.length;i++)\\n            if(al.get(al.size()-1) < n[i]) al.add(n[i]);\\n            else {\\n                int ind = Collections.binarySearch(al, n[i]);\\n                if(ind<0)al.set(-(ind+1), n[i]);\\n            }\\n        return al.size();\\n    }\\n```\n```\\n\\t def lengthOfLIS(self, n):\\n        l = [n[0]]\\n        for i in n[1:]:\\n            if l[-1] < i:\\n                l.append(i)\\n            else:\\n                l[bisect_left(l,i)]=i\\n        return len(l)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1326832,
                "title": "longest-increasing-subsequence-python-simple-efficient-3-approaches",
                "content": "```\\n        #Simpler version: O(N^2):Dynamic Programming         --> A1\\n        dp = [1]*len(nums)    #base case\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    dp[i]=max(dp[j]+1,dp[i])\\n        return max(dp)  \\n```\\n```\\n        #Optimal solution of A1: O(N^2): Better in Average and Best case than A1        --> A2\\n        sub = [nums[0]]\\n        for num in nums[1:]:\\n            if sub[-1]<num:\\n                sub.append(num)\\n            else:\\n                i=0\\n                while num > sub[i]:\\n                    i+=1\\n                sub[i]=num\\n        return len(sub)\\n```\\n```\\n        #Efficient solution: O(N.lnN): binary_search takes O(lnN)        --> A2\\n        sub=[]\\n        for num in nums:\\n            i = bisect_left(sub, num)\\n            if i == len(sub):\\n                sub.append(num)\\n            else:\\n                sub[i] = num\\n        return len(sub)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        #Simpler version: O(N^2):Dynamic Programming         --> A1\\n        dp = [1]*len(nums)    #base case\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    dp[i]=max(dp[j]+1,dp[i])\\n        return max(dp)  \\n```\n```\\n        #Optimal solution of A1: O(N^2): Better in Average and Best case than A1        --> A2\\n        sub = [nums[0]]\\n        for num in nums[1:]:\\n            if sub[-1]<num:\\n                sub.append(num)\\n            else:\\n                i=0\\n                while num > sub[i]:\\n                    i+=1\\n                sub[i]=num\\n        return len(sub)\\n```\n```\\n        #Efficient solution: O(N.lnN): binary_search takes O(lnN)        --> A2\\n        sub=[]\\n        for num in nums:\\n            i = bisect_left(sub, num)\\n            if i == len(sub):\\n                sub.append(num)\\n            else:\\n                sub[i] = num\\n        return len(sub)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166679,
                "title": "java-recursive-memoization-easy-understanding",
                "content": "recursive solution\\n\\n```\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return solve(nums, Integer.MIN_VALUE, 0);\\n    }\\n    \\n    public int solve(int[] nums, int prev, int curr){\\n        if(curr==nums.length){\\n            return 0;\\n        }\\n        \\n        if(nums[curr]>prev){\\n           return Math.max(1+solve(nums, nums[curr], curr+1),\\n                          solve(nums, prev, curr+1));\\n        }\\n         else{\\n             return solve(nums, prev, curr+1);\\n         }\\n    }\\n}\\n```\\nrecursive + memoization code:-\\n```\\nclass Solution{\\n    public int lengthOfLIS(int[] nums){\\n        //there were two chaning variable in recursive solution curr and prev\\n        //so we need a 2d matrix\\n        //length decision:-prev will go max upto nums.length so will take nums.length+1\\n                         // curr will go max upto nums.length-1 so will take nums.length\\n        //for initialization of dp matrix initialize it with -1\\n        \\n        int[][] dp = new int[nums.length+1][nums.length];\\n        for(int[] x: dp){\\n            Arrays.fill(x, -1);\\n        }\\n        return solve(nums, -1, 0, dp);\\n    }\\n    \\n    public int solve(int[] nums, int prevIndex, int curr, int[][] dp){\\n        if(curr == nums.length){\\n            return 0;\\n        }\\n        \\n        if(dp[prevIndex+1][curr]!=-1){\\n            return dp[prevIndex+1][curr];\\n        }\\n            \\n        if(prevIndex<0 || nums[curr]>nums[prevIndex]){\\n            dp[prevIndex+1][curr]=Math.max(1+solve(nums, curr, curr+1, dp),\\n                                          solve(nums, prevIndex, curr+1, dp));\\n        }\\n        \\n        else{\\n            dp[prevIndex+1][curr]=solve(nums, prevIndex, curr+1, dp);\\n        }\\n        return dp[prevIndex+1][curr];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return solve(nums, Integer.MIN_VALUE, 0);\\n    }\\n    \\n    public int solve(int[] nums, int prev, int curr){\\n        if(curr==nums.length){\\n            return 0;\\n        }\\n        \\n        if(nums[curr]>prev){\\n           return Math.max(1+solve(nums, nums[curr], curr+1),\\n                          solve(nums, prev, curr+1));\\n        }\\n         else{\\n             return solve(nums, prev, curr+1);\\n         }\\n    }\\n}\\n```\n```\\nclass Solution{\\n    public int lengthOfLIS(int[] nums){\\n        //there were two chaning variable in recursive solution curr and prev\\n        //so we need a 2d matrix\\n        //length decision:-prev will go max upto nums.length so will take nums.length+1\\n                         // curr will go max upto nums.length-1 so will take nums.length\\n        //for initialization of dp matrix initialize it with -1\\n        \\n        int[][] dp = new int[nums.length+1][nums.length];\\n        for(int[] x: dp){\\n            Arrays.fill(x, -1);\\n        }\\n        return solve(nums, -1, 0, dp);\\n    }\\n    \\n    public int solve(int[] nums, int prevIndex, int curr, int[][] dp){\\n        if(curr == nums.length){\\n            return 0;\\n        }\\n        \\n        if(dp[prevIndex+1][curr]!=-1){\\n            return dp[prevIndex+1][curr];\\n        }\\n            \\n        if(prevIndex<0 || nums[curr]>nums[prevIndex]){\\n            dp[prevIndex+1][curr]=Math.max(1+solve(nums, curr, curr+1, dp),\\n                                          solve(nums, prevIndex, curr+1, dp));\\n        }\\n        \\n        else{\\n            dp[prevIndex+1][curr]=solve(nums, prevIndex, curr+1, dp);\\n        }\\n        return dp[prevIndex+1][curr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124988,
                "title": "python-easy-dp-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # initilize the entire dp with 1 as the LIS of an element is 1\\n        dp = [1]*len(nums)\\n        # start from the 2nd element as the 1st element is already fgured out\\n        for i in range(1, len(nums)):\\n            # check j till i and update the max\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[j] + 1, dp[i])\\n        return max(dp)\\n    \\n\\tTime complexity - O(n^2)\\n\\tSpace complexity - O(n) where n is the size of the list\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # initilize the entire dp with 1 as the LIS of an element is 1\\n        dp = [1]*len(nums)\\n        # start from the 2nd element as the 1st element is already fgured out\\n        for i in range(1, len(nums)):\\n            # check j till i and update the max\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    dp[i] = max(dp[j] + 1, dp[i])\\n        return max(dp)\\n    \\n\\tTime complexity - O(n^2)\\n\\tSpace complexity - O(n) where n is the size of the list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806538,
                "title": "java-c-short-solution-with-o-nlogn-time-complexity",
                "content": "This is more like a greedy question rather than DP.\\nEach time we see a new element, we try to insert into the BBST and replace the ceiling key.\\nJava\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : nums) {\\n            Integer a = set.ceiling(i);\\n            if (a != null) set.remove(a);\\n            set.add(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        set<int> s;\\n        for (auto num : nums) {\\n            if (s.count(num)) continue;\\n            auto a = s.upper_bound(num);\\n            if (a != s.end()) s.erase(a);\\n            s.insert(num);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : nums) {\\n            Integer a = set.ceiling(i);\\n            if (a != null) set.remove(a);\\n            set.add(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        set<int> s;\\n        for (auto num : nums) {\\n            if (s.count(num)) continue;\\n            auto a = s.upper_bound(num);\\n            if (a != s.end()) s.erase(a);\\n            s.insert(num);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329499,
                "title": "python-monotonic-stack-o-nlogn",
                "content": "Here we use a monotonic stack to store the result. When talking about monotonic queue, the key is to find the left and right bound. Since the question hints that we can do it in O(NLogN), we can definitely use Binary Search to help us to find the bound. \\n\\nHere we have to use binary search to find the lowerbound for every element that is smaller than the top element of the stack since the final result is not necessary to be consequtive (which makes our life easier since we do not have to continuously pop out elements like what monotonic queue problem usually requires). Once we find the lowerbound in our stack, we replace the element in the stack with the new element from nums. \\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        stack=[] #sorted\\n        for num in nums:\\n            # print(num,stack)\\n            if not stack or stack[-1]<num:\\n                stack.append(num)\\n                continue\\n            #now stack[-1]>=num\\n            lowerbound=self.lowerbound(stack,num)\\n            stack[lowerbound]=num\\n        return len(stack)\\n    \\n    def lowerbound(self,nums,target):\\n        left=0\\n        right=len(nums)\\n        while left < right:\\n            mid=left+(right-left)//2\\n            if nums[mid]>=target:\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        stack=[] #sorted\\n        for num in nums:\\n            # print(num,stack)\\n            if not stack or stack[-1]<num:\\n                stack.append(num)\\n                continue\\n            #now stack[-1]>=num\\n            lowerbound=self.lowerbound(stack,num)\\n            stack[lowerbound]=num\\n        return len(stack)\\n    \\n    def lowerbound(self,nums,target):\\n        left=0\\n        right=len(nums)\\n        while left < right:\\n            mid=left+(right-left)//2\\n            if nums[mid]>=target:\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75007,
                "title": "4ms-o-nlogn-non-recursive-easy-to-understand-java-solution",
                "content": " \\n    public int lengthOfLIS(int[] nums) {\\n        List<Integer> seq = new ArrayList<>(nums.length);     \\n\\n        for(int num: nums){\\n            if(   seq.size()              == 0\\n               || seq.get(seq.size() - 1) <  num  ){                \\n               seq.add(num);\\n            }else{\\n                seq.set(binarySearch(seq, num - 0.5), num);\\n            }\\n        }      \\n\\n        return seq.size();\\n    }\\n    \\n    private int binarySearch(List<Integer> seq, double target){\\n        int st  = 0;\\n        int ed  = seq.size() - 1;\\n        int mid = 0;    \\n\\n        while(st <= ed){\\n            mid = st + (ed - st)/2;\\n            \\n            if(seq.get(mid) > target){\\n                ed = mid - 1;\\n            }else{\\n                st = mid + 1;\\n            }\\n        }\\n        \\n        return st;\\n    }",
                "solutionTags": [],
                "code": " \\n    public int lengthOfLIS(int[] nums) {\\n        List<Integer> seq = new ArrayList<>(nums.length);     \\n\\n        for(int num: nums){\\n            if(   seq.size()              == 0\\n               || seq.get(seq.size() - 1) <  num  ){                \\n               seq.add(num);\\n            }else{\\n                seq.set(binarySearch(seq, num - 0.5), num);\\n            }\\n        }      \\n\\n        return seq.size();\\n    }\\n    \\n    private int binarySearch(List<Integer> seq, double target){\\n        int st  = 0;\\n        int ed  = seq.size() - 1;\\n        int mid = 0;    \\n\\n        while(st <= ed){\\n            mid = st + (ed - st)/2;\\n            \\n            if(seq.get(mid) > target){\\n                ed = mid - 1;\\n            }else{\\n                st = mid + 1;\\n            }\\n        }\\n        \\n        return st;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3331297,
                "title": "dynamic-programming-logic",
                "content": "\\n\\n# Dynamic Programming--->O(N^2)\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]<nums[j]:\\n                    dp[i]=max(dp[i],1+dp[j])\\n        return max(dp)\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]<nums[j]:\\n                    dp[i]=max(dp[i],1+dp[j])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206456,
                "title": "easy-to-understand-dynamic-programming-solution-c-code",
                "content": "``` class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = 1;\\n        int maxl = 0;\\n        for(int i = 1; i < n; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(nums[j] < nums[i]){\\n                    if(dp[j] + 1 > dp[i]) dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] > maxl) maxl = dp[i];\\n        }\\n        return maxl;\\n    }\\n}; \\n```\\n\\nI am given an array of integers, and I am required to find the longest increasing subsequence. I am initialising an array (named dp in this case) of the array size and set the dp[0] = 1. This is because the first element does not have previous elements to be compared with.\\n\\nIn the next for loop I am comparing the each element with the previous elements. The element with dp of highest value plus 1 is set as the dp of the current value. In this way at the end of the loop I have an array where each index stores the length of the longest possible subsequence of the given array up to that index. As we want the longest possible subsequence, we return the maximum value of the dp array.\\nTest Case-\\n\\nI think dry running a test case will make you understand the code better, so here you go.\\n\\nnums = [10,9,2,5,3,7,101,18]\\n\\nConsider the above test case. Initialise dp[8] and set dp[0] = 1.\\n\\ndp[1] = 1 (Since nums[0] > nums[1])\\n\\ndp[2] = 1 (Since nums[2] is lesser than the previous elements)\\n\\ndp[3] = dp[2] + 1 = 2 (Since nums[3] > nums[2])\\n\\ndp[4] = dp[2] + 1 = 2(Since nums[4] > nums[2])\\n\\ndp[5] = dp[3] + 1 = 3(nums[5] is greater than 3rd, 4th and 5th element, but dp is set to the maximum possible value)\\n\\ndp[6] = dp[5] + 1 = 4\\n\\ndp[7] = dp[5] + 1 = 4\\n\\nIt is clear that the maximum possible length of sub sequence is 4.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = 1;\\n        int maxl = 0;\\n        for(int i = 1; i < n; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(nums[j] < nums[i]){\\n                    if(dp[j] + 1 > dp[i]) dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] > maxl) maxl = dp[i];\\n        }\\n        return maxl;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592467,
                "title": "c-all-approaches",
                "content": "**PLEASE UPVOTE. THANK YOU.**\\nRecursion with Memoisation\\n```\\nclass Solution {\\n    // Memoisation solution\\n    int recursion(vector < int > & nums, int n, int ind, int prevInd, vector < vector < int >> & dp) {\\n        if (ind == n) return 0;\\n\\n        if (dp[ind][prevInd + 1] != -1) return dp[ind][prevInd + 1];\\n\\n        int take = 0, notTake = 0;\\n\\n        notTake = recursion(nums, n, ind + 1, prevInd, dp);\\n\\n        if (prevInd == -1 || nums[ind] > nums[prevInd])\\n            take = 1 + recursion(nums, n, ind + 1, ind, dp);\\n\\n        return dp[ind][prevInd + 1] = max(notTake, take);\\n    }\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < vector < int >> dp(n, vector < int > (n + 1, -1));\\n        return recursion(nums, n, 0, -1, dp);\\n    }\\n};\\n```\\n\\n2-D DP Bottom Up Approach:\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < vector < int >> dp(n + 1, vector < int > (n + 1, 0));\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int prevInd = ind - 1; prevInd >= -1; prevInd--) {\\n                int notTake = 0, take = 0;\\n                notTake = dp[ind + 1][prevInd + 1];\\n\\n                if (prevInd == -1 || nums[ind] > nums[prevInd])\\n                    take = 1 + dp[ind + 1][ind + 1];\\n\\n                dp[ind][prevInd + 1] = max(notTake, take);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\nSpace Optimisation into from O(N * N) to -> O(2 * N) Space\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < int > next(n + 1, 0), cur(n + 1, 0);\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int prevInd = ind - 1; prevInd >= -1; prevInd--) {\\n                int notTake = 0, take = 0;\\n                notTake = next[prevInd + 1];\\n\\n                if (prevInd == -1 || nums[ind] > nums[prevInd])\\n                    take = 1 + next[ind + 1];\\n\\n                cur[prevInd + 1] = max(notTake, take);\\n            }\\n            next = cur;\\n        }\\n        return next[0];\\n    }\\n};\\n```\\n\\nO(N) Space Approach Along with Hashing to also store and print the LIS along with it\\'s length:\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < int > dp(n, 1), hash(n, 0);\\n\\n        int maxi = 1, lastIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            hash[i] = i;\\n            for (int prev = 0; prev <= i - 1; prev++) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n            if (maxi < dp[i]) {\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        vector < int > LIS;\\n        LIS.push_back(nums[lastIndex]);\\n        while (hash[lastIndex] != lastIndex) {\\n            lastIndex = hash[lastIndex];\\n            LIS.push_back(nums[lastIndex]);\\n        }\\n        reverse(LIS.begin(), LIS.end());\\n        for (auto it: LIS) cout << it << \" \";\\n        return maxi;\\n    }\\n};\\n```\\n\\nBinary Search Solution to just calculate length:\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        \\n        int len = 1;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > temp.back()) {\\n                temp.push_back(nums[i]);\\n                len++;\\n            }\\n            else{\\n                int ind = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // Memoisation solution\\n    int recursion(vector < int > & nums, int n, int ind, int prevInd, vector < vector < int >> & dp) {\\n        if (ind == n) return 0;\\n\\n        if (dp[ind][prevInd + 1] != -1) return dp[ind][prevInd + 1];\\n\\n        int take = 0, notTake = 0;\\n\\n        notTake = recursion(nums, n, ind + 1, prevInd, dp);\\n\\n        if (prevInd == -1 || nums[ind] > nums[prevInd])\\n            take = 1 + recursion(nums, n, ind + 1, ind, dp);\\n\\n        return dp[ind][prevInd + 1] = max(notTake, take);\\n    }\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < vector < int >> dp(n, vector < int > (n + 1, -1));\\n        return recursion(nums, n, 0, -1, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < vector < int >> dp(n + 1, vector < int > (n + 1, 0));\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int prevInd = ind - 1; prevInd >= -1; prevInd--) {\\n                int notTake = 0, take = 0;\\n                notTake = dp[ind + 1][prevInd + 1];\\n\\n                if (prevInd == -1 || nums[ind] > nums[prevInd])\\n                    take = 1 + dp[ind + 1][ind + 1];\\n\\n                dp[ind][prevInd + 1] = max(notTake, take);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < int > next(n + 1, 0), cur(n + 1, 0);\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int prevInd = ind - 1; prevInd >= -1; prevInd--) {\\n                int notTake = 0, take = 0;\\n                notTake = next[prevInd + 1];\\n\\n                if (prevInd == -1 || nums[ind] > nums[prevInd])\\n                    take = 1 + next[ind + 1];\\n\\n                cur[prevInd + 1] = max(notTake, take);\\n            }\\n            next = cur;\\n        }\\n        return next[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector < int > & nums) {\\n        int n = nums.size();\\n        vector < int > dp(n, 1), hash(n, 0);\\n\\n        int maxi = 1, lastIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            hash[i] = i;\\n            for (int prev = 0; prev <= i - 1; prev++) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n            if (maxi < dp[i]) {\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        vector < int > LIS;\\n        LIS.push_back(nums[lastIndex]);\\n        while (hash[lastIndex] != lastIndex) {\\n            lastIndex = hash[lastIndex];\\n            LIS.push_back(nums[lastIndex]);\\n        }\\n        reverse(LIS.begin(), LIS.end());\\n        for (auto it: LIS) cout << it << \" \";\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        \\n        int len = 1;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > temp.back()) {\\n                temp.push_back(nums[i]);\\n                len++;\\n            }\\n            else{\\n                int ind = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2450827,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=sokaFqeYaww\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\n\\nclass Solution {\\npublic:\\nint sol(int index, int prev, vector& nums,int n, vector<vector> &v ){\\n\\n    if(index==n) return 0;// base\\n    if(v[index][prev+1]!=-1) return v[index][prev+1];\\n   int len= 0+ sol(index+1, prev, nums,n, v);\\n    if(prev==-1 || nums[index]> nums[prev])\\n    {\\n      len= max(len,1+ sol(index+1, index, nums,n, v));  \\n        \\n    }\\n    return v[index][prev+1]= len;\\n}\\n\\n\\n\\nint lengthOfLIS(vector<int>& nums) {\\n   int n=  nums.size();// vector size\\n    vector<vector<int>> v(n, vector<int>(n+1, -1));\\n  \\n    return sol(0, -1, nums,n,v);\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n       \\n        dp[0] = 1;\\n        int result = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int max = 0;\\n            \\n            for (int j = 0; j < i; j++)\\n                if(nums[j] < nums[i])\\n                    max = Math.max(dp[j],max);\\n            \\n            dp[i] = max + 1;\\n            result = Math.max(dp[i], result);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # Solution - maintaining sorted sequence \\n        # Time - O(NlogN)\\n        # Space - O(N)\\n        \\n        arr = []\\n        for i in range(len(nums)):\\n            if not arr:\\n                arr.append(nums[i])\\n            else:\\n                if arr[-1] < nums[i]:\\n                    arr.append(nums[i])\\n                else:\\n                    idx = bisect.bisect_left(arr, nums[i])\\n                    arr[idx] = nums[i]\\n        return len(arr)\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nint sol(int index, int prev, vector& nums,int n, vector<vector> &v ){\\n\\n    if(index==n) return 0;// base\\n    if(v[index][prev+1]!=-1) return v[index][prev+1];\\n   int len= 0+ sol(index+1, prev, nums,n, v);\\n    if(prev==-1 || nums[index]> nums[prev])\\n    {\\n      len= max(len,1+ sol(index+1, index, nums,n, v));  \\n        \\n    }\\n    return v[index][prev+1]= len;\\n}\\n\\n\\n\\nint lengthOfLIS(vector<int>& nums) {\\n   int n=  nums.size();// vector size\\n    vector<vector<int>> v(n, vector<int>(n+1, -1));\\n  \\n    return sol(0, -1, nums,n,v);\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n       \\n        dp[0] = 1;\\n        int result = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int max = 0;\\n            \\n            for (int j = 0; j < i; j++)\\n                if(nums[j] < nums[i])\\n                    max = Math.max(dp[j],max);\\n            \\n            dp[i] = max + 1;\\n            result = Math.max(dp[i], result);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # Solution - maintaining sorted sequence \\n        # Time - O(NlogN)\\n        # Space - O(N)\\n        \\n        arr = []\\n        for i in range(len(nums)):\\n            if not arr:\\n                arr.append(nums[i])\\n            else:\\n                if arr[-1] < nums[i]:\\n                    arr.append(nums[i])\\n                else:\\n                    idx = bisect.bisect_left(arr, nums[i])\\n                    arr[idx] = nums[i]\\n        return len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430936,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=sokaFqeYaww\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\n\\nclass Solution {\\npublic:\\nint sol(int index, int prev, vector& nums,int n, vector<vector> &v ){\\n\\n    if(index==n) return 0;// base\\n    if(v[index][prev+1]!=-1) return v[index][prev+1];\\n   int len= 0+ sol(index+1, prev, nums,n, v);\\n    if(prev==-1 || nums[index]> nums[prev])\\n    {\\n      len= max(len,1+ sol(index+1, index, nums,n, v));  \\n        \\n    }\\n    return v[index][prev+1]= len;\\n}\\n\\n\\n\\nint lengthOfLIS(vector<int>& nums) {\\n   int n=  nums.size();// vector size\\n    vector<vector<int>> v(n, vector<int>(n+1, -1));\\n  \\n    return sol(0, -1, nums,n,v);\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n       \\n        dp[0] = 1;\\n        int result = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int max = 0;\\n            \\n            for (int j = 0; j < i; j++)\\n                if(nums[j] < nums[i])\\n                    max = Math.max(dp[j],max);\\n            \\n            dp[i] = max + 1;\\n            result = Math.max(dp[i], result);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # Solution - maintaining sorted sequence \\n        # Time - O(NlogN)\\n        # Space - O(N)\\n        \\n        arr = []\\n        for i in range(len(nums)):\\n            if not arr:\\n                arr.append(nums[i])\\n            else:\\n                if arr[-1] < nums[i]:\\n                    arr.append(nums[i])\\n                else:\\n                    idx = bisect.bisect_left(arr, nums[i])\\n                    arr[idx] = nums[i]\\n        return len(arr)\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nint sol(int index, int prev, vector& nums,int n, vector<vector> &v ){\\n\\n    if(index==n) return 0;// base\\n    if(v[index][prev+1]!=-1) return v[index][prev+1];\\n   int len= 0+ sol(index+1, prev, nums,n, v);\\n    if(prev==-1 || nums[index]> nums[prev])\\n    {\\n      len= max(len,1+ sol(index+1, index, nums,n, v));  \\n        \\n    }\\n    return v[index][prev+1]= len;\\n}\\n\\n\\n\\nint lengthOfLIS(vector<int>& nums) {\\n   int n=  nums.size();// vector size\\n    vector<vector<int>> v(n, vector<int>(n+1, -1));\\n  \\n    return sol(0, -1, nums,n,v);\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n       \\n        dp[0] = 1;\\n        int result = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int max = 0;\\n            \\n            for (int j = 0; j < i; j++)\\n                if(nums[j] < nums[i])\\n                    max = Math.max(dp[j],max);\\n            \\n            dp[i] = max + 1;\\n            result = Math.max(dp[i], result);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        # Solution - maintaining sorted sequence \\n        # Time - O(NlogN)\\n        # Space - O(N)\\n        \\n        arr = []\\n        for i in range(len(nums)):\\n            if not arr:\\n                arr.append(nums[i])\\n            else:\\n                if arr[-1] < nums[i]:\\n                    arr.append(nums[i])\\n                else:\\n                    idx = bisect.bisect_left(arr, nums[i])\\n                    arr[idx] = nums[i]\\n        return len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395572,
                "title": "c-2-solutions-n-log-n-n-2",
                "content": "**Solved live on stream.  everyday 6pm PT.  Link in profile.**\\n\\nn^2 solutions\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 0;\\n        int n =nums.size();\\n        vector<int> dp(n, 1);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[j] > nums[i]) {\\n                    dp[j] = max(dp[j], dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        for(int x : dp) {\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n\\nnlogn solution:\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        vector<int> sub;\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            auto it = lower_bound(sub.begin(), sub.end(), nums[i]);\\n            if(it != sub.end()) {\\n                *it = nums[i];\\n            } else {\\n                sub.push_back(nums[i]);\\n            }\\n        }\\n        return sub.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int ans = 0;\\n        int n =nums.size();\\n        vector<int> dp(n, 1);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[j] > nums[i]) {\\n                    dp[j] = max(dp[j], dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        for(int x : dp) {\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        vector<int> sub;\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            auto it = lower_bound(sub.begin(), sub.end(), nums[i]);\\n            if(it != sub.end()) {\\n                *it = nums[i];\\n            } else {\\n                sub.push_back(nums[i]);\\n            }\\n        }\\n        return sub.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171246,
                "title": "c-6-easy-solutions-dp-binary-search-iterative-recursion-memoization",
                "content": "**Recursion**\\n```\\nint solve(vector<int> &nums, int ind, int prev){\\n        if( ind == nums.size()) return 0;\\n        \\n        if( prev ==-1 || nums[ind]> nums[prev]){\\n            return max( 1+ solve(nums,ind+1, ind), solve( nums, ind+1, prev));\\n        }\\n        \\n        else{\\n            return solve(nums, ind+1, prev);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve( nums, 0, -1);\\n    }\\n```\\n\\n**Memoization**\\n```\\nint solve(vector<int> &nums, int ind, int prev, vector<vector<int>> &dp){\\n        if( ind == nums.size()) return 0;\\n        \\n        if( dp[ind][prev+1] != -1) return dp[ind][prev+1]; \\n        if( prev ==-1 || nums[ind]> nums[prev]){\\n            return dp[ind][prev+1]= max( 1+ solve(nums,ind+1, ind, dp), solve( nums, ind+1, prev, dp));\\n        }\\n        \\n        else{\\n            return dp[ind][prev+1]=  solve(nums, ind+1, prev, dp);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(), vector<int> (nums.size()+1, -1));\\n        return solve( nums, 0, -1, dp);\\n    }\\n\\t\\t\\n\\t\\t\\n```\\n**dp**\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<vector<int>> dp( n+1, vector<int> (n+1, 0));\\n        \\n        for( int ind = n-1; ind>=0; --ind){\\n            for( int prev = ind-1; prev>=-1; --prev){\\n                if( prev ==-1 || nums[ind] > nums[prev]){\\n                    dp[ind][prev+1] = max( 1+ dp[ind+1][ind+1], dp[ind+1][prev+1]);\\n                }\\n                else{\\n                    dp[ind][prev+1] = dp[ind+1][prev+1];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n\\n**SPACE OPTIMIZED - DP**\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n        for( int i = n-1; i>=0; --i){\\n            for(int j= i-1; j>=-1; --j){\\n                if( j ==-1 || nums[i]> nums[j]){\\n                    curr[j+1]= max( 1+ next[i+1], next[j+1]);\\n                }\\n\\n                else{\\n                    curr[j+1] =  next[j+1];\\n                }\\n            }\\n            next = curr;\\n        }\\n        return next[0];\\n    }\\n```\\n\\n\\n**Simple iterative Solution**\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp( n,1);\\n        int maxi = 1;\\n        for(int ind =0; ind <nums.size(); ind ++){\\n            for( int prev =0; prev<ind ; prev++){\\n                if( nums[ind]> nums[prev]){\\n                    dp[ind] = max( dp[ind], 1+ dp[prev]);\\n                }\\n            }\\n            maxi = max( maxi, dp[ind]);\\n        }\\n        return maxi;\\n    }\\n```\\n\\n\\n**Most Optimal approach - using binary search**\\n```\\n int lengthOfLIS(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> temp;\\n        temp.push_back( nums[0]);\\n        int len =1;\\n        for( int i=1; i<n; i++){\\n            if( nums[i] > temp.back()){\\n                temp.push_back( nums[i]);\\n                len++;\\n            }\\n            else{\\n                int ind = \\n                    lower_bound( temp.begin(), temp.end(), nums[i])- temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int> &nums, int ind, int prev){\\n        if( ind == nums.size()) return 0;\\n        \\n        if( prev ==-1 || nums[ind]> nums[prev]){\\n            return max( 1+ solve(nums,ind+1, ind), solve( nums, ind+1, prev));\\n        }\\n        \\n        else{\\n            return solve(nums, ind+1, prev);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        return solve( nums, 0, -1);\\n    }\\n```\n```\\nint solve(vector<int> &nums, int ind, int prev, vector<vector<int>> &dp){\\n        if( ind == nums.size()) return 0;\\n        \\n        if( dp[ind][prev+1] != -1) return dp[ind][prev+1]; \\n        if( prev ==-1 || nums[ind]> nums[prev]){\\n            return dp[ind][prev+1]= max( 1+ solve(nums,ind+1, ind, dp), solve( nums, ind+1, prev, dp));\\n        }\\n        \\n        else{\\n            return dp[ind][prev+1]=  solve(nums, ind+1, prev, dp);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(), vector<int> (nums.size()+1, -1));\\n        return solve( nums, 0, -1, dp);\\n    }\\n\\t\\t\\n\\t\\t\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<vector<int>> dp( n+1, vector<int> (n+1, 0));\\n        \\n        for( int ind = n-1; ind>=0; --ind){\\n            for( int prev = ind-1; prev>=-1; --prev){\\n                if( prev ==-1 || nums[ind] > nums[prev]){\\n                    dp[ind][prev+1] = max( 1+ dp[ind+1][ind+1], dp[ind+1][prev+1]);\\n                }\\n                else{\\n                    dp[ind][prev+1] = dp[ind+1][prev+1];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n        for( int i = n-1; i>=0; --i){\\n            for(int j= i-1; j>=-1; --j){\\n                if( j ==-1 || nums[i]> nums[j]){\\n                    curr[j+1]= max( 1+ next[i+1], next[j+1]);\\n                }\\n\\n                else{\\n                    curr[j+1] =  next[j+1];\\n                }\\n            }\\n            next = curr;\\n        }\\n        return next[0];\\n    }\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp( n,1);\\n        int maxi = 1;\\n        for(int ind =0; ind <nums.size(); ind ++){\\n            for( int prev =0; prev<ind ; prev++){\\n                if( nums[ind]> nums[prev]){\\n                    dp[ind] = max( dp[ind], 1+ dp[prev]);\\n                }\\n            }\\n            maxi = max( maxi, dp[ind]);\\n        }\\n        return maxi;\\n    }\\n```\n```\\n int lengthOfLIS(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> temp;\\n        temp.push_back( nums[0]);\\n        int len =1;\\n        for( int i=1; i<n; i++){\\n            if( nums[i] > temp.back()){\\n                temp.push_back( nums[i]);\\n                len++;\\n            }\\n            else{\\n                int ind = \\n                    lower_bound( temp.begin(), temp.end(), nums[i])- temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138372,
                "title": "java-o-nlogn-solution-14ms-using-patience-sort-and-treeset",
                "content": "I was searching for a better solution to the LIS problem and I came across this. I found it fascinating and it\\'s easy to implement. Using tree set avoids the need to implement your own binary search which can be error prone during a high stress interview.\\n```\\n\\tpublic int lengthOfLIS(int[] nums) {\\n        TreeSet<Integer> t = new TreeSet<>();\\n        for (int x: nums) {\\n            Integer c = t.ceiling(x);\\n            if (c != null) {\\n                t.remove(c);\\n            }\\n            t.add(x);\\n        }\\n        return t.size();\\n    }\\n```\\n\\nVideo for reference: https://www.youtube.com/watch?v=K9M6g7BiBX4",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n\\tpublic int lengthOfLIS(int[] nums) {\\n        TreeSet<Integer> t = new TreeSet<>();\\n        for (int x: nums) {\\n            Integer c = t.ceiling(x);\\n            if (c != null) {\\n                t.remove(c);\\n            }\\n            t.add(x);\\n        }\\n        return t.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922119,
                "title": "c-o-nlogn-binary-search-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        // temp array to store length of longest incr subsequence\\n        vector<int> temp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            \\n        // if the temp array is empty or the last element of\\n        // temp array is smaller than the current element of nums array\\n            if(temp.size() == 0 || temp.back() < nums[i])\\n                temp.push_back(nums[i]);\\n            else{\\n                \\n        // if the last element of temp is not smaller than the current element of nums array\\n        // then we will find the lowest element in temp array which is greater or equal to \\n        // nums[i] and replace it with nums[i] because by doing this the length of the longest \\n        // subsequence will not be affected and the value at each index in temp array will decrease             // which will help us to accomodate more elements to get the maximum incr subsequence\\n                int index = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin();\\n                temp[index] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n\\n\\n```\\n\\nPlease upvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        // temp array to store length of longest incr subsequence\\n        vector<int> temp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            \\n        // if the temp array is empty or the last element of\\n        // temp array is smaller than the current element of nums array\\n            if(temp.size() == 0 || temp.back() < nums[i])\\n                temp.push_back(nums[i]);\\n            else{\\n                \\n        // if the last element of temp is not smaller than the current element of nums array\\n        // then we will find the lowest element in temp array which is greater or equal to \\n        // nums[i] and replace it with nums[i] because by doing this the length of the longest \\n        // subsequence will not be affected and the value at each index in temp array will decrease             // which will help us to accomodate more elements to get the maximum incr subsequence\\n                int index = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin();\\n                temp[index] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720297,
                "title": "python-3-approaches-complexity",
                "content": "\\t# Pure Dynamic Proramming Solution\\n\\t# Time : O(n*(n+1)/2) - O(n^2)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tmaX = 0\\n\\t\\t\\t\\tfor j in range(i+1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\t\\t\\tif dp[j] > maX:\\n\\t\\t\\t\\t\\t\\t\\tmaX = dp[j]\\n\\t\\t\\t\\tdp[i] = maX+1\\n\\t\\t\\treturn max(dp)\\n\\n\\t# Dynamic Programming with Binary Search\\n\\t# Time: O(nlogn), logn for searching the position for the element\\'s and there are n steps.\\n\\t# Space: O(n)\\n\\tfrom bisect import bisect_left\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums):\\n\\t\\t\\tdp = []\\n\\t\\t\\tfor elem in nums:\\n\\t\\t\\t\\tidx = bisect_left(dp, elem)\\n\\t\\t\\t\\tif idx == len(dp):\\n\\t\\t\\t\\t\\tdp.append(elem)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[idx] = elem\\n\\t\\t\\treturn len(dp)\\n\\n\\t# Dynamic Programming with Binary Search\\n\\t# Time: O(nlogn), logn for searching the position for the element\\'s and there are n steps.\\n\\t# Space: O(1)\\n\\tfrom bisect import bisect_left\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t# Here we pass three arg\\'s, which means find the position of nums[i] in the nums array within index i.\\n\\t\\t\\t\\tidx = bisect_left(nums, nums[i], hi=i)\\n\\t\\t\\t\\tif idx != i:\\n\\t\\t\\t\\t\\tnums[idx], nums[i] = nums[i], float(inf)\\n\\t\\t\\treturn nums.index(float(inf)) if float(inf) in nums else n\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "\\t# Pure Dynamic Proramming Solution\\n\\t# Time : O(n*(n+1)/2) - O(n^2)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tmaX = 0\\n\\t\\t\\t\\tfor j in range(i+1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\t\\t\\tif dp[j] > maX:\\n\\t\\t\\t\\t\\t\\t\\tmaX = dp[j]\\n\\t\\t\\t\\tdp[i] = maX+1\\n\\t\\t\\treturn max(dp)\\n\\n\\t# Dynamic Programming with Binary Search\\n\\t# Time: O(nlogn), logn for searching the position for the element\\'s and there are n steps.\\n\\t# Space: O(n)\\n\\tfrom bisect import bisect_left\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums):\\n\\t\\t\\tdp = []\\n\\t\\t\\tfor elem in nums:\\n\\t\\t\\t\\tidx = bisect_left(dp, elem)\\n\\t\\t\\t\\tif idx == len(dp):\\n\\t\\t\\t\\t\\tdp.append(elem)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[idx] = elem\\n\\t\\t\\treturn len(dp)\\n\\n\\t# Dynamic Programming with Binary Search\\n\\t# Time: O(nlogn), logn for searching the position for the element\\'s and there are n steps.\\n\\t# Space: O(1)\\n\\tfrom bisect import bisect_left\\n\\tclass Solution:\\n\\t\\tdef lengthOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t# Here we pass three arg\\'s, which means find the position of nums[i] in the nums array within index i.\\n\\t\\t\\t\\tidx = bisect_left(nums, nums[i], hi=i)\\n\\t\\t\\t\\tif idx != i:\\n\\t\\t\\t\\t\\tnums[idx], nums[i] = nums[i], float(inf)\\n\\t\\t\\treturn nums.index(float(inf)) if float(inf) in nums else n\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1326843,
                "title": "c-4-approaches-and-fully-explained-patience-sorting-with-example",
                "content": "More interview Qns : https://github.com/MAZHARMIK/Interview_DS_Algo\\nJuly Challenge Full Solution till now : https://github.com/MAZHARMIK/Leetcode-July-Challenge-2021/blob/main/README.md\\n```\\n//Approach-1 (TopDown: Recur+Memo) O(n*n)\\nclass Solution {\\npublic:\\n    int n;\\n    int t[2501][2501];\\n    int lis(vector<int>& nums, int prev, int curr) {\\n       if(curr == n)\\n           return 0;\\n        \\n        if(prev != -1 && t[prev][curr] != -1)\\n            return t[prev][curr];\\n        \\n        int taken = 0;\\n        if(prev == -1 || nums[curr] > nums[prev])\\n            taken = 1 + lis(nums, curr, curr+1);\\n        \\n        int not_taken = lis(nums, prev, curr+1);\\n        \\n        if(prev != -1)\\n            t[prev][curr] =  max(taken, not_taken);\\n        \\n        return max(taken, not_taken);\\n            \\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(t, -1, sizeof(t));\\n        n = nums.size();\\n        //prev = -1 (prev index)\\n        //curr = 0 (curr index)\\n        return lis(nums, -1, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Bottom Up DP) O(n*n)\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> t(n, 1);\\n        int maxL = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(nums[j] < nums[i]) {\\n                    t[i] = max(t[i], t[j]+1);\\n                    maxL = max(maxL, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Converting the question to Longest Common Subsequence) O(n*n)\\n/*\\n\\tIf we find LCS between nums and it\\'s sorted form, we will find LIS :-)\\n*/\\nclass Solution {\\npublic:\\n    int LCS(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        vector<vector<int>> t(m+1, vector<int>(n+1));\\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n\\t\\t\\t\\tif(i == 0 || j == 0) continue;\\n\\t\\t\\t\\t\\n                if(nums1[i-1] == nums2[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        //We need unique elements only\\n\\t\\t//because we want\\'Longest \"Increasing\" Subseqnece\\'\\n        set<int> st(begin(nums), end(nums));\\n        \\n        vector<int> nums2(begin(st), end(st));\\n        \\n        return LCS(nums, nums2);\\n        \\n    }\\n};\\n```\\n\\n```\\n//Approacj-4 (Using concept of Patience Sorting (O(nlogn))\\n/*\\n\\tYou can write the code very easily if you understand the dry run below (example):\\n    Patience Sorting\\n    \\n    Input : {3, 10, 2, 1, 20}\\n    \\n    sorted : {}\\n    \\n----------------------------------\\n    we are at 3\\n    Since sorted is empty, insert 3\\n    sorted : {3}\\n    \\n----------------------------------\\n    We are now at 10\\n    If we find an element which is greater or equal than 10, we put this 10 under that\\n    Since, 3 < 10, we can\\'t put 10 under it. So, we create another bucket for 10 (i.e. insert in sorted)\\n    sorted : {3, 10}\\n----------------------------------\\n    We are now at 2\\n    If we find an element which is greater or equal than 2, we put this 2 under that\\n    Since, 3 > 2 and 10 > 2 as well, we put 2 under the one which is smallest\\n    So, we put 2 under 3\\n    \\n    sorted : {3, 10}\\n              |\\n              2\\n              \\n----------------------------------\\n    We are now at 1\\n    If we find an element which is greater or equal than 1, we put this 1 under that\\n    Since, 2 > 1 and 10 > 1 as well, we put 2 under the one which is smallest\\n    So, we put 1 under 2\\n    \\n    sorted : {3, 10}\\n              |\\n              2\\n              |\\n              1\\n              \\n-----------------------------------\\n    We are now at 20\\n    If we find an element which is greater or equal than 20, we put this 20 under that\\n    Since, 1 < 20 and 10 < 20, So, we create another bucket for 20 (i.e. insert in sorted)\\n    \\n    sorted : {3, 10, 20}\\n              |\\n              2\\n              |\\n              1\\n    \\n    \\n    So, we are done.\\n    If we start from 1 and move to 2 and then to 3, \\n    Then to 10 and to 20\\n    So, at the end you see that the array is sorted.\\n    \\n    It\\'s O(nlogn) Because we iterate in Input array and for finding the element just greater than current element\\n    we take O(logn) time.\\n    \\n-----------------------------------\\nIf you notice, for getting an increasing subsequence, we can pick one element from each bucket from sorted.\\nExample : \\n    1, 10, 20\\n    2, 10, 20\\n    3, 10, 20\\n    These are largest inceasing subsequence that we can get. And length will be size of sorted.\\n    i.e. LIS = size of sorted.\\n    \\n    To make things simple, instead of appending 2, 1 under 3, we will replace 3 with current element (2 and then 1)\\n    i.e. Input : {3, 10, 2, 1, 10}\\n sorted =   {3}\\n    Now I have 10. Since it\\'s greatest, we simply insert it in sorted\\n sorted =   {3, 10}\\n    Now, I have 2. Since it\\'s next greatest is 3, we will replace 3 with 2\\n sorted =   {2, 10}\\n    Now, I have 1. Since it\\'s next greatest is 2, we will replace 2 with 1\\n sorted =   {1, 10}\\n    Now, I have 20. Since it\\'s greatest, we will insert it in sorted\\n sorted = {1, 10, 20}\\n \\n size of sorted = 3 = LIS\\n*/\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> sorted;\\n        \\n        for(int i = 0; i<n; i++) {\\n            /*\\n\\t\\t\\t     Why lower bound ?\\n\\t\\t\\t\\t We want increasing subsequence and  hence \\n\\t\\t\\t\\t we want to eliminate the duplicates as well.\\n\\t\\t\\t\\t lower_bound returns iterator to \"next greater or equal to\"\\n\\t\\t\\t*/\\n            auto it = lower_bound(begin(sorted), end(sorted), nums[i]);\\n            \\n            if(it == end(sorted))\\n                sorted.push_back(nums[i]); //greatest : so insert it\\n            else\\n                *it = nums[i]; //replace\\n        }\\n        \\n        return (int)sorted.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (TopDown: Recur+Memo) O(n*n)\\nclass Solution {\\npublic:\\n    int n;\\n    int t[2501][2501];\\n    int lis(vector<int>& nums, int prev, int curr) {\\n       if(curr == n)\\n           return 0;\\n        \\n        if(prev != -1 && t[prev][curr] != -1)\\n            return t[prev][curr];\\n        \\n        int taken = 0;\\n        if(prev == -1 || nums[curr] > nums[prev])\\n            taken = 1 + lis(nums, curr, curr+1);\\n        \\n        int not_taken = lis(nums, prev, curr+1);\\n        \\n        if(prev != -1)\\n            t[prev][curr] =  max(taken, not_taken);\\n        \\n        return max(taken, not_taken);\\n            \\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(t, -1, sizeof(t));\\n        n = nums.size();\\n        //prev = -1 (prev index)\\n        //curr = 0 (curr index)\\n        return lis(nums, -1, 0);\\n    }\\n};\\n```\n```\\n//Approach-2 (Bottom Up DP) O(n*n)\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> t(n, 1);\\n        int maxL = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(nums[j] < nums[i]) {\\n                    t[i] = max(t[i], t[j]+1);\\n                    maxL = max(maxL, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\n```\\n//Approach-3 (Converting the question to Longest Common Subsequence) O(n*n)\\n/*\\n\\tIf we find LCS between nums and it\\'s sorted form, we will find LIS :-)\\n*/\\nclass Solution {\\npublic:\\n    int LCS(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        vector<vector<int>> t(m+1, vector<int>(n+1));\\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n\\t\\t\\t\\tif(i == 0 || j == 0) continue;\\n\\t\\t\\t\\t\\n                if(nums1[i-1] == nums2[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        //We need unique elements only\\n\\t\\t//because we want\\'Longest \"Increasing\" Subseqnece\\'\\n        set<int> st(begin(nums), end(nums));\\n        \\n        vector<int> nums2(begin(st), end(st));\\n        \\n        return LCS(nums, nums2);\\n        \\n    }\\n};\\n```\n```\\n//Approacj-4 (Using concept of Patience Sorting (O(nlogn))\\n/*\\n\\tYou can write the code very easily if you understand the dry run below (example):\\n    Patience Sorting\\n    \\n    Input : {3, 10, 2, 1, 20}\\n    \\n    sorted : {}\\n    \\n----------------------------------\\n    we are at 3\\n    Since sorted is empty, insert 3\\n    sorted : {3}\\n    \\n----------------------------------\\n    We are now at 10\\n    If we find an element which is greater or equal than 10, we put this 10 under that\\n    Since, 3 < 10, we can\\'t put 10 under it. So, we create another bucket for 10 (i.e. insert in sorted)\\n    sorted : {3, 10}\\n----------------------------------\\n    We are now at 2\\n    If we find an element which is greater or equal than 2, we put this 2 under that\\n    Since, 3 > 2 and 10 > 2 as well, we put 2 under the one which is smallest\\n    So, we put 2 under 3\\n    \\n    sorted : {3, 10}\\n              |\\n              2\\n              \\n----------------------------------\\n    We are now at 1\\n    If we find an element which is greater or equal than 1, we put this 1 under that\\n    Since, 2 > 1 and 10 > 1 as well, we put 2 under the one which is smallest\\n    So, we put 1 under 2\\n    \\n    sorted : {3, 10}\\n              |\\n              2\\n              |\\n              1\\n              \\n-----------------------------------\\n    We are now at 20\\n    If we find an element which is greater or equal than 20, we put this 20 under that\\n    Since, 1 < 20 and 10 < 20, So, we create another bucket for 20 (i.e. insert in sorted)\\n    \\n    sorted : {3, 10, 20}\\n              |\\n              2\\n              |\\n              1\\n    \\n    \\n    So, we are done.\\n    If we start from 1 and move to 2 and then to 3, \\n    Then to 10 and to 20\\n    So, at the end you see that the array is sorted.\\n    \\n    It\\'s O(nlogn) Because we iterate in Input array and for finding the element just greater than current element\\n    we take O(logn) time.\\n    \\n-----------------------------------\\nIf you notice, for getting an increasing subsequence, we can pick one element from each bucket from sorted.\\nExample : \\n    1, 10, 20\\n    2, 10, 20\\n    3, 10, 20\\n    These are largest inceasing subsequence that we can get. And length will be size of sorted.\\n    i.e. LIS = size of sorted.\\n    \\n    To make things simple, instead of appending 2, 1 under 3, we will replace 3 with current element (2 and then 1)\\n    i.e. Input : {3, 10, 2, 1, 10}\\n sorted =   {3}\\n    Now I have 10. Since it\\'s greatest, we simply insert it in sorted\\n sorted =   {3, 10}\\n    Now, I have 2. Since it\\'s next greatest is 3, we will replace 3 with 2\\n sorted =   {2, 10}\\n    Now, I have 1. Since it\\'s next greatest is 2, we will replace 2 with 1\\n sorted =   {1, 10}\\n    Now, I have 20. Since it\\'s greatest, we will insert it in sorted\\n sorted = {1, 10, 20}\\n \\n size of sorted = 3 = LIS\\n*/\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> sorted;\\n        \\n        for(int i = 0; i<n; i++) {\\n            /*\\n\\t\\t\\t     Why lower bound ?\\n\\t\\t\\t\\t We want increasing subsequence and  hence \\n\\t\\t\\t\\t we want to eliminate the duplicates as well.\\n\\t\\t\\t\\t lower_bound returns iterator to \"next greater or equal to\"\\n\\t\\t\\t*/\\n            auto it = lower_bound(begin(sorted), end(sorted), nums[i]);\\n            \\n            if(it == end(sorted))\\n                sorted.push_back(nums[i]); //greatest : so insert it\\n            else\\n                *it = nums[i]; //replace\\n        }\\n        \\n        return (int)sorted.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168045,
                "title": "c-binary-search-nlogn-with-explanation",
                "content": "```\\n// \\u65E2\\u7136\\u9898\\u76EE\\u63D0\\u793A\\u6211\\u4EEC\\u8FD9\\u9898\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u53EF\\u4EE5\\u4F18\\u5316\\u5230 O(nlogn)\\n// Since the question suggests that the time complexity of this question can be optimized to O(nlogn)\\n// logn \\u7684\\u590D\\u6742\\u5EA6\\u53EA\\u6709\\u4E8C\\u5206\\u6CD5\\u80FD\\u529E\\u5230\\u4E86\\n// The complexity can only be achieved by dichotomy.\\n// \\u6211\\u4EEC\\u628A\\u8FD9\\u4E9B\\u6570\\u5206\\u6210\\u8BB8\\u591A\\u5806, \\u6309\\u7167\\u4E0B\\u9762\\u5B9A\\u4E49\\u7684\\u89C4\\u5219:\\n// We divide these numbers into many piles, according to the rules defined below:\\n// 1. \\u4F9D\\u6B21\\u4ECE\\u6570\\u7EC4\\u4E2D\\u62FF\\u51FA\\u4E00\\u4E2A\\u6570, \\u9996\\u5148\\u7B2C\\u4E00\\u4E2A\\u6570\\u5C31\\u653E\\u5728\\u7B2C 1 \\u4E2A\\u5806\\u5C31\\u884C\\n// 1. Take a number from the array in turn, and put the first number on the first pile.\\n// 2. \\u4E4B\\u540E\\u6BCF\\u6B21\\u53D6\\u51FA\\u7684\\u6570\\u5FC5\\u987B\\u653E\\u5728\\u6240\\u6709\\u5806\\u9876\\u7684\\u4E0D\\u5C0F\\u4E8E\\u5B83\\u7684\\u6570\\u4E0A\\u9762\\n// 2. After that, the number taken out each time must be placed on top of all the numbers at the top of the pile that are not less than it.\\n// 3. \\u5982\\u679C\\u6709\\u591A\\u4E2A\\u5806\\u9876\\u7684\\u6570\\u90FD\\u4E0D\\u5C0F\\u4E8E\\u5B83, \\u5C31\\u653E\\u5728\\u6700\\u9760\\u5DE6\\u8FB9\\u7684\\u5806\\u4E0A\\u9762\\n// 3. If the number at the top of multiple piles is not less than it, put it on the leftmost pile.\\n// 4. \\u5982\\u679C\\u6CA1\\u6709\\u8FD9\\u6837\\u7684\\u5806, \\u5C31\\u4ECE\\u53F3\\u8FB9\\u65B0\\u8D77\\u4E00\\u4E2A\\u5806\\u653E\\n// 4. If there is no such pile, start a new one on the right.\\n// \\u8FD9\\u4E2A\\u89C4\\u5219\\u7684\\u9650\\u5236\\u4E0B, \\u6240\\u6709\\u5806\\u9876\\u7684\\u5143\\u7D20\\u4ECE\\u5DE6\\u5230\\u53F3\\u59CB\\u7EC8\\u90FD\\u662F\\u6709\\u5E8F\\u7684\\n// Under the restriction of this rule, all the elements at the top of the piles are always ordered from left to right.\\n// \\u8FD9\\u6837\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5E94\\u7528\\u4E8C\\u5206\\u641C\\u7D22, \\u6765\\u627E\\u7B2C 1 \\u4E2A\\u5806\\u9876\\u7684\\u6570\\u4E0D\\u5C0F\\u4E8E\\u5F85\\u653E\\u6570\\u7684\\u5806\\u4E86\\n// In this way, we can use binary search to find the first pile, and the number at the top of it is not less than the number waiting to be placed.\\n// \\u90A3\\u4E48\\u8FD9\\u548C\\u6211\\u4EEC\\u7684\\u95EE\\u9898: \\u5BFB\\u627E\\u6700\\u957F\\u9012\\u589E\\u5B50\\u5E8F\\u5217\\u6709\\u4EC0\\u4E48\\u5173\\u7CFB\\u5462\\uFF1F\\n// So what does this have to do with our question: finding the longest increasing subsequence?\\n// \\u53EF\\u4EE5\\u8BC1\\u660E, \\u6700\\u957F\\u9012\\u589E\\u5B50\\u5E8F\\u5217\\u5C31\\u662F\\u5806\\u7684\\u4E2A\\u6570\\n// It can be proved that the longest increasing subsequence is the number of piles.\\nint lengthOfLIS(vector<int>& nums)\\n{\\n    int n = nums.size();\\n    vector<int> pilesTop;\\n    // \\u6700\\u591A\\u5206\\u4E86 n \\u4E2A\\u5806, \\u6211\\u4EEC\\u63D0\\u524D\\u5206\\u914D\\u7A7A\\u95F4\\u63D0\\u5347\\u6548\\u7387\\n\\t// There are no more than n piles, so we allocate space in advance to improve efficiency.\\n    pilesTop.reserve(n);\\n    for(int i = 0; i < n; i++)\\n    {\\n        // \\u5BFB\\u627E\\u5DE6\\u8FB9\\u754C\\u4E8C\\u5206\\u641C\\u7D22\\n\\t\\t// Search for left boundary\\n        auto left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]);\\n        // \\u5982\\u679C\\u6CA1\\u6709\\u627E\\u5230\\u5408\\u9002\\u7684\\u5806, \\u72EC\\u81EA\\u653E\\u5728\\u6700\\u53F3\\u8FB9\\n\\t\\t// If you don\\'t find a suitable pile, put it on the far right alone.\\n        if(left == pilesTop.end())\\n            pilesTop.push_back(nums[i]);\\n        // \\u5426\\u5219, \\u653E\\u5806\\u9876\\u4E0A\\n\\t\\t// Otherwise, put it on top of the pile.\\n        else\\n            *left = nums[i];\\n    }\\n    return pilesTop.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// \\u65E2\\u7136\\u9898\\u76EE\\u63D0\\u793A\\u6211\\u4EEC\\u8FD9\\u9898\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u53EF\\u4EE5\\u4F18\\u5316\\u5230 O(nlogn)\\n// Since the question suggests that the time complexity of this question can be optimized to O(nlogn)\\n// logn \\u7684\\u590D\\u6742\\u5EA6\\u53EA\\u6709\\u4E8C\\u5206\\u6CD5\\u80FD\\u529E\\u5230\\u4E86\\n// The complexity can only be achieved by dichotomy.\\n// \\u6211\\u4EEC\\u628A\\u8FD9\\u4E9B\\u6570\\u5206\\u6210\\u8BB8\\u591A\\u5806, \\u6309\\u7167\\u4E0B\\u9762\\u5B9A\\u4E49\\u7684\\u89C4\\u5219:\\n// We divide these numbers into many piles, according to the rules defined below:\\n// 1. \\u4F9D\\u6B21\\u4ECE\\u6570\\u7EC4\\u4E2D\\u62FF\\u51FA\\u4E00\\u4E2A\\u6570, \\u9996\\u5148\\u7B2C\\u4E00\\u4E2A\\u6570\\u5C31\\u653E\\u5728\\u7B2C 1 \\u4E2A\\u5806\\u5C31\\u884C\\n// 1. Take a number from the array in turn, and put the first number on the first pile.\\n// 2. \\u4E4B\\u540E\\u6BCF\\u6B21\\u53D6\\u51FA\\u7684\\u6570\\u5FC5\\u987B\\u653E\\u5728\\u6240\\u6709\\u5806\\u9876\\u7684\\u4E0D\\u5C0F\\u4E8E\\u5B83\\u7684\\u6570\\u4E0A\\u9762\\n// 2. After that, the number taken out each time must be placed on top of all the numbers at the top of the pile that are not less than it.\\n// 3. \\u5982\\u679C\\u6709\\u591A\\u4E2A\\u5806\\u9876\\u7684\\u6570\\u90FD\\u4E0D\\u5C0F\\u4E8E\\u5B83, \\u5C31\\u653E\\u5728\\u6700\\u9760\\u5DE6\\u8FB9\\u7684\\u5806\\u4E0A\\u9762\\n// 3. If the number at the top of multiple piles is not less than it, put it on the leftmost pile.\\n// 4. \\u5982\\u679C\\u6CA1\\u6709\\u8FD9\\u6837\\u7684\\u5806, \\u5C31\\u4ECE\\u53F3\\u8FB9\\u65B0\\u8D77\\u4E00\\u4E2A\\u5806\\u653E\\n// 4. If there is no such pile, start a new one on the right.\\n// \\u8FD9\\u4E2A\\u89C4\\u5219\\u7684\\u9650\\u5236\\u4E0B, \\u6240\\u6709\\u5806\\u9876\\u7684\\u5143\\u7D20\\u4ECE\\u5DE6\\u5230\\u53F3\\u59CB\\u7EC8\\u90FD\\u662F\\u6709\\u5E8F\\u7684\\n// Under the restriction of this rule, all the elements at the top of the piles are always ordered from left to right.\\n// \\u8FD9\\u6837\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5E94\\u7528\\u4E8C\\u5206\\u641C\\u7D22, \\u6765\\u627E\\u7B2C 1 \\u4E2A\\u5806\\u9876\\u7684\\u6570\\u4E0D\\u5C0F\\u4E8E\\u5F85\\u653E\\u6570\\u7684\\u5806\\u4E86\\n// In this way, we can use binary search to find the first pile, and the number at the top of it is not less than the number waiting to be placed.\\n// \\u90A3\\u4E48\\u8FD9\\u548C\\u6211\\u4EEC\\u7684\\u95EE\\u9898: \\u5BFB\\u627E\\u6700\\u957F\\u9012\\u589E\\u5B50\\u5E8F\\u5217\\u6709\\u4EC0\\u4E48\\u5173\\u7CFB\\u5462\\uFF1F\\n// So what does this have to do with our question: finding the longest increasing subsequence?\\n// \\u53EF\\u4EE5\\u8BC1\\u660E, \\u6700\\u957F\\u9012\\u589E\\u5B50\\u5E8F\\u5217\\u5C31\\u662F\\u5806\\u7684\\u4E2A\\u6570\\n// It can be proved that the longest increasing subsequence is the number of piles.\\nint lengthOfLIS(vector<int>& nums)\\n{\\n    int n = nums.size();\\n    vector<int> pilesTop;\\n    // \\u6700\\u591A\\u5206\\u4E86 n \\u4E2A\\u5806, \\u6211\\u4EEC\\u63D0\\u524D\\u5206\\u914D\\u7A7A\\u95F4\\u63D0\\u5347\\u6548\\u7387\\n\\t// There are no more than n piles, so we allocate space in advance to improve efficiency.\\n    pilesTop.reserve(n);\\n    for(int i = 0; i < n; i++)\\n    {\\n        // \\u5BFB\\u627E\\u5DE6\\u8FB9\\u754C\\u4E8C\\u5206\\u641C\\u7D22\\n\\t\\t// Search for left boundary\\n        auto left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]);\\n        // \\u5982\\u679C\\u6CA1\\u6709\\u627E\\u5230\\u5408\\u9002\\u7684\\u5806, \\u72EC\\u81EA\\u653E\\u5728\\u6700\\u53F3\\u8FB9\\n\\t\\t// If you don\\'t find a suitable pile, put it on the far right alone.\\n        if(left == pilesTop.end())\\n            pilesTop.push_back(nums[i]);\\n        // \\u5426\\u5219, \\u653E\\u5806\\u9876\\u4E0A\\n\\t\\t// Otherwise, put it on top of the pile.\\n        else\\n            *left = nums[i];\\n    }\\n    return pilesTop.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135141,
                "title": "java-simple-and-easy-to-understand-solution-backtracking-with-memoization-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    int[][] cache;\\n    \\n    public int lengthOfLIS(int[] nums) {\\n        cache = new int[nums.length + 1][nums.length];\\n        \\n        //fill default value\\n        for(int[] row : cache){\\n            Arrays.fill(row, - 1);\\n        }\\n        \\n        return lengthOfLIS(nums, -1, 0);\\n    }\\n    \\n    \\n    private int lengthOfLIS(int[] nums, int prevIndex, int currIndex) {\\n        if(currIndex == nums.length) return 0;\\n        \\n        \\n        //take the already computed result\\n        if(cache[prevIndex + 1][currIndex] > -1) \\n            return cache[prevIndex + 1][currIndex];\\n        \\n        //when current element is considered \\n        int taken =  0;\\n        if(prevIndex < 0 || nums[currIndex] > nums[prevIndex])\\n            taken = 1 + lengthOfLIS(nums, currIndex, currIndex + 1);\\n        \\n        //when current element is ignored \\n        int notTaken = lengthOfLIS(nums, prevIndex, currIndex + 1);\\n        \\n        \\n        //store the result\\n        cache[prevIndex + 1][currIndex] = Math.max(notTaken, taken);\\n        \\n        return cache[prevIndex + 1][currIndex];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] cache;\\n    \\n    public int lengthOfLIS(int[] nums) {\\n        cache = new int[nums.length + 1][nums.length];\\n        \\n        //fill default value\\n        for(int[] row : cache){\\n            Arrays.fill(row, - 1);\\n        }\\n        \\n        return lengthOfLIS(nums, -1, 0);\\n    }\\n    \\n    \\n    private int lengthOfLIS(int[] nums, int prevIndex, int currIndex) {\\n        if(currIndex == nums.length) return 0;\\n        \\n        \\n        //take the already computed result\\n        if(cache[prevIndex + 1][currIndex] > -1) \\n            return cache[prevIndex + 1][currIndex];\\n        \\n        //when current element is considered \\n        int taken =  0;\\n        if(prevIndex < 0 || nums[currIndex] > nums[prevIndex])\\n            taken = 1 + lengthOfLIS(nums, currIndex, currIndex + 1);\\n        \\n        //when current element is ignored \\n        int notTaken = lengthOfLIS(nums, prevIndex, currIndex + 1);\\n        \\n        \\n        //store the result\\n        cache[prevIndex + 1][currIndex] = Math.max(notTaken, taken);\\n        \\n        return cache[prevIndex + 1][currIndex];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832972,
                "title": "java-solution-with-backtracking-14ms",
                "content": "I tried to use backtracking to come up with solution, cause I can\\'t come up with DP solution within 45 minutes. I need more practice with DP !!\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] input) {\\n        int maxLength = 0;\\n        for(int i = 0; i < input.length  && input.length - i > maxLength; i++) {\\n            maxLength = Math.max(maxLength, maxIncreasingSubsequenceLength(input, input[i], i+1, 1, 0));\\n        }  \\n        return maxLength;\\n    }\\n    \\n    int maxIncreasingSubsequenceLength(int[] input, int prevValue, int nextIndex, int lengthSoFar, int maxLength) {\\n        if(nextIndex >= input.length)  {\\n            return lengthSoFar;\\n        }\\n        for(int i = nextIndex; i < input.length; i++) {\\n            if (prevValue < input[i]) {\\n                // Get max length by considering current element\\n                int lengthWithCurrent = maxIncreasingSubsequenceLength(input, input[i], i+1, lengthSoFar + 1, maxLength);\\n\\t\\t\\t\\t\\n                // if length by considering current element is greater than or equal to :\\n                // remaining elements to be scanned - 1\\n                // Treat lengthWithCurrent element as maxLength\\n                if (lengthWithCurrent >= input.length - nextIndex) {\\n                    return lengthWithCurrent;\\n                }\\n\\t\\t\\t\\t\\n                // Get max length without considering current element\\n                int lengthWithoutCurrent = maxIncreasingSubsequenceLength(input, prevValue, i+1, lengthSoFar, maxLength);\\n\\t\\t\\t\\t\\n                // get max of above and maxLength\\n\\t\\t\\t\\tmaxLength = Math.max(maxLength, Math.max(withCurrent, withoutCurrent));\\n            }\\n        }\\n        return Math.max(lengthSoFar, maxLength);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] input) {\\n        int maxLength = 0;\\n        for(int i = 0; i < input.length  && input.length - i > maxLength; i++) {\\n            maxLength = Math.max(maxLength, maxIncreasingSubsequenceLength(input, input[i], i+1, 1, 0));\\n        }  \\n        return maxLength;\\n    }\\n    \\n    int maxIncreasingSubsequenceLength(int[] input, int prevValue, int nextIndex, int lengthSoFar, int maxLength) {\\n        if(nextIndex >= input.length)  {\\n            return lengthSoFar;\\n        }\\n        for(int i = nextIndex; i < input.length; i++) {\\n            if (prevValue < input[i]) {\\n                // Get max length by considering current element\\n                int lengthWithCurrent = maxIncreasingSubsequenceLength(input, input[i], i+1, lengthSoFar + 1, maxLength);\\n\\t\\t\\t\\t\\n                // if length by considering current element is greater than or equal to :\\n                // remaining elements to be scanned - 1\\n                // Treat lengthWithCurrent element as maxLength\\n                if (lengthWithCurrent >= input.length - nextIndex) {\\n                    return lengthWithCurrent;\\n                }\\n\\t\\t\\t\\t\\n                // Get max length without considering current element\\n                int lengthWithoutCurrent = maxIncreasingSubsequenceLength(input, prevValue, i+1, lengthSoFar, maxLength);\\n\\t\\t\\t\\t\\n                // get max of above and maxLength\\n\\t\\t\\t\\tmaxLength = Math.max(maxLength, Math.max(withCurrent, withoutCurrent));\\n            }\\n        }\\n        return Math.max(lengthSoFar, maxLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191468,
                "title": "java-recursion-dp-solution-for-learner-new-to-dp",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[] memo = new int[arr.length + 1];\\n        Arrays.fill(memo, -1 );\\n        int res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = Math.max(res, dp(arr, i, memo));\\n        }\\n\\n        return res;\\n    }\\n\\n    private static int dp(int[] arr, int i, int[]memo) {\\n\\n        if (memo[i] != -1) {\\n            return memo[i];\\n        }\\n        int res = 1;\\n        for (int j = 0; j < i; j++) {\\n            if (arr[i] > arr[j]) {\\n                res = Math.max(res, 1 + dp(arr, j, memo));\\n            }\\n        }\\n        memo[i] = res;\\n        return memo[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] arr) {\\n        int[] memo = new int[arr.length + 1];\\n        Arrays.fill(memo, -1 );\\n        int res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = Math.max(res, dp(arr, i, memo));\\n        }\\n\\n        return res;\\n    }\\n\\n    private static int dp(int[] arr, int i, int[]memo) {\\n\\n        if (memo[i] != -1) {\\n            return memo[i];\\n        }\\n        int res = 1;\\n        for (int j = 0; j < i; j++) {\\n            if (arr[i] > arr[j]) {\\n                res = Math.max(res, 1 + dp(arr, j, memo));\\n            }\\n        }\\n        memo[i] = res;\\n        return memo[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74858,
                "title": "c-solution",
                "content": "```\\npublic int LengthOfLIS(int[] nums)\\n        {\\n            if (nums == null || nums.Length == 0)\\n                return 0;\\n            else if (nums.Length == 1)\\n                return 1;\\n\\n            int currentLength = 1;\\n            int[] continousLength = new int[nums.Length];\\n\\n            for (int i = 0; i <= nums.Length - 1; i++)\\n            {\\n                continousLength[i] = 1;\\n\\n                for (int j = 0; j < i; j++)\\n                    if (nums[j] < nums[i])\\n                        continousLength[i] = Math.Max(continousLength[j] + 1, continousLength[i]);\\n\\n                currentLength = Math.Max(continousLength[i], currentLength);\\n            }\\n\\n            return currentLength;\\n        }",
                "solutionTags": [],
                "code": "```\\npublic int LengthOfLIS(int[] nums)\\n        {\\n            if (nums == null || nums.Length == 0)\\n                return 0;\\n            else if (nums.Length == 1)\\n                return 1;\\n\\n            int currentLength = 1;\\n            int[] continousLength = new int[nums.Length];\\n\\n            for (int i = 0; i <= nums.Length - 1; i++)\\n            {\\n                continousLength[i] = 1;\\n\\n                for (int j = 0; j < i; j++)\\n                    if (nums[j] < nums[i])\\n                        continousLength[i] = Math.Max(continousLength[j] + 1, continousLength[i]);\\n\\n                currentLength = Math.Max(continousLength[i], currentLength);\\n            }\\n\\n            return currentLength;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 74866,
                "title": "golang-o-nlogn-solution",
                "content": "The idea pretty much borrowed from this:\\nhttps://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation\\nI really am not confident that I can come up with this without having an experience of at least once solving a similar problem...\\n\\n```\\nfunc lengthOfLIS(nums []int) int {\\n\\tvar tails []int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\ttlen := len(tails)\\n\\t\\tif tlen == 0 {\\n\\t\\t\\ttails = []int{nums[i]}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif nums[i] > tails[tlen-1] {\\n\\t\\t\\ttails = append(tails, nums[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tstart, end, mid := 0, tlen-1, 0\\n\\t\\tfor start != end {\\n\\t\\t\\tmid = start + (end-start)/2\\n\\t\\t\\tif nums[i] > tails[mid] {\\n\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttails[end] = nums[i]\\n\\t}\\n\\treturn len(tails)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lengthOfLIS(nums []int) int {\\n\\tvar tails []int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\ttlen := len(tails)\\n\\t\\tif tlen == 0 {\\n\\t\\t\\ttails = []int{nums[i]}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif nums[i] > tails[tlen-1] {\\n\\t\\t\\ttails = append(tails, nums[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tstart, end, mid := 0, tlen-1, 0\\n\\t\\tfor start != end {\\n\\t\\t\\tmid = start + (end-start)/2\\n\\t\\t\\tif nums[i] > tails[mid] {\\n\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttails[end] = nums[i]\\n\\t}\\n\\treturn len(tails)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74883,
                "title": "c-o-nlogn-solution-including-a-very-helpful-link",
                "content": "As I stated in my previous post [O(n^2 solution)](https://discuss.leetcode.com/topic/69931/2-o-n-2-dp-solutions-explanation-for-people-who-has-difficulty-in-understanding-the-dp-approach) , the fastest way is using an O(nlogn) algorithm for this problem.\\n\\nI found this [link](http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/) very helpful and easy to understand. I strongly recommend to the people having difficulty in understanding the O(nlogn) approaches to LIS.\\n\\nHere is the C# implementation (beats 85.22%)\\n```\\npublic class Solution {\\n    public int BinarySearchCeil(int[] a, int left, int right, int element){\\n        while (right - left > 1){\\n            int middle = (right + left) / 2;\\n            if (a[middle] >= element)\\n                right = middle;\\n            else\\n                left = middle;\\n        }\\n        return right;\\n    }    \\n    public int LengthOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        int len = 0;\\n        if (n > 0){\\n            len = 1;\\n            int[] dp = new int[n];\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++){\\n                if (nums[i] < dp[0])\\n                    dp[0] = nums[i];\\n                else if (nums[i] > dp[len - 1])\\n                    dp[len++] = nums[i];\\n                else\\n                    dp[BinarySearchCeil(dp, -1, len - 1, nums[i])] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int BinarySearchCeil(int[] a, int left, int right, int element){\\n        while (right - left > 1){\\n            int middle = (right + left) / 2;\\n            if (a[middle] >= element)\\n                right = middle;\\n            else\\n                left = middle;\\n        }\\n        return right;\\n    }    \\n    public int LengthOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        int len = 0;\\n        if (n > 0){\\n            len = 1;\\n            int[] dp = new int[n];\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++){\\n                if (nums[i] < dp[0])\\n                    dp[0] = nums[i];\\n                else if (nums[i] > dp[len - 1])\\n                    dp[len++] = nums[i];\\n                else\\n                    dp[BinarySearchCeil(dp, -1, len - 1, nums[i])] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238696,
                "title": "300-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this solution, we maintain an array tails, which stores the smallest tail of all increasing subsequences with length i+1. We loop through the input array, and for each element, we use binary search to find the position where we can insert the current element in our existing subsequence to maintain its order.\\n\\nIf we find a position i such that tails[i] is less than the current element, we update the tails array at that position with the current element. If we don\\'t find such a position, we update the tails array at position 0 with the current element.\\n\\nFinally, we return the size variable, which stores the length of the longest increasing subsequence.\\n\\nTime complexity: O(n log(n))\\nSpace complexity: O(n)\\n\\n\\n# Complexity\\n- Time complexity:\\n85.60%\\n\\n- Space complexity:\\n80.29%\\n\\n# Code\\n```\\nclass Solution:\\n  def lengthOfLIS(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    tails = [0] * n # initialize tails array with 0\\n    size = 0\\n    for num in nums:\\n        i, j = 0, size\\n        while i != j:\\n            m = (i + j) // 2\\n            if tails[m] < num:\\n                i = m + 1\\n            else:\\n                j = m\\n        tails[i] = num\\n        size = max(i + 1, size)\\n\\n    return size\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def lengthOfLIS(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    tails = [0] * n # initialize tails array with 0\\n    size = 0\\n    for num in nums:\\n        i, j = 0, size\\n        while i != j:\\n            m = (i + j) // 2\\n            if tails[m] < num:\\n                i = m + 1\\n            else:\\n                j = m\\n        tails[i] = num\\n        size = max(i + 1, size)\\n\\n    return size\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163835,
                "title": "3-different-approach-solution-binary-search-dp-lower-bound",
                "content": "#  DP Approach|Recursion & memoization\\ntake/not take approach\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int lis(vector<int>& nums,int ind,int prev, vector<vector<int>>&dp){\\n        if(ind==nums.size()){  //base case\\n            return 0;\\n        }\\n        if(dp[ind][prev+1]!=-1){   // memoization \\n            return dp[ind][prev+1];\\n        }\\n        int len=0;\\n        if(prev==-1 || nums[ind]>nums[prev]){  //take \\n            len=1+lis(nums,ind+1,ind,dp);\\n        }\\n        int dlen= lis(nums,ind+1,prev,dp);  // not take\\n         len=max(len,dlen); \\n        return dp[ind][prev+1]=len;  //store value in dp and return \\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<vector<int>>dp(n,vector<int>(n+1,-1)); // 2d dp vector initialized with -1\\n       int ans= lis(nums,0,-1,dp); //calling function\\n       return ans; \\n    }\\n};\\n```\\n#  DP Approach|Iterative DP\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<int>dp(n+1,1);  //1d dp vector\\n       int ans=0;\\n       for(int i=0;i<nums.size();i++){\\n         for(int j=i-1;j>=0;j--){\\n             if(nums[i]>nums[j]){\\n                 dp[i]=max(dp[i],dp[j]+1);\\n             }\\n         }\\n         ans=max(ans,dp[i]);\\n       }\\n       return ans;  //return ans\\n    }\\n};\\n```\\n#  Binary Search|lower bound\\n# Complexity\\n- Time complexity:\\nO(nlog n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<int>dp;\\n       for(int i=0;i<nums.size();i++){\\n         int pos=lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin();\\n         if(pos==dp.size()){\\n             dp.push_back(nums[i]);\\n         }\\n         else{\\n             dp[pos]=nums[i];\\n         }\\n       }\\n       int ans=dp.size();\\n       return ans; \\n    }\\n};\\n```\\n\\u2705Upvote if you like it\\u2705",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int lis(vector<int>& nums,int ind,int prev, vector<vector<int>>&dp){\\n        if(ind==nums.size()){  //base case\\n            return 0;\\n        }\\n        if(dp[ind][prev+1]!=-1){   // memoization \\n            return dp[ind][prev+1];\\n        }\\n        int len=0;\\n        if(prev==-1 || nums[ind]>nums[prev]){  //take \\n            len=1+lis(nums,ind+1,ind,dp);\\n        }\\n        int dlen= lis(nums,ind+1,prev,dp);  // not take\\n         len=max(len,dlen); \\n        return dp[ind][prev+1]=len;  //store value in dp and return \\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<vector<int>>dp(n,vector<int>(n+1,-1)); // 2d dp vector initialized with -1\\n       int ans= lis(nums,0,-1,dp); //calling function\\n       return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<int>dp(n+1,1);  //1d dp vector\\n       int ans=0;\\n       for(int i=0;i<nums.size();i++){\\n         for(int j=i-1;j>=0;j--){\\n             if(nums[i]>nums[j]){\\n                 dp[i]=max(dp[i],dp[j]+1);\\n             }\\n         }\\n         ans=max(ans,dp[i]);\\n       }\\n       return ans;  //return ans\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n       vector<int>dp;\\n       for(int i=0;i<nums.size();i++){\\n         int pos=lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin();\\n         if(pos==dp.size()){\\n             dp.push_back(nums[i]);\\n         }\\n         else{\\n             dp[pos]=nums[i];\\n         }\\n       }\\n       int ans=dp.size();\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408159,
                "title": "c-all-possible-solutions-recursion-bottom-up-space-optimized-algorithmic-binary-search",
                "content": "**Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, int prev, vector<int>&nums, vector<vector<int>>&dp){\\n        if(ind==nums.size()) return 0;\\n        \\n        if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];\\n        \\n        int len= 0+ f(ind+1,prev,nums,dp); //not take\\n        if(prev==-1 or nums[ind]>nums[prev])\\n            len= max(len,1+ f(ind+1,ind,nums,dp)); //take\\n        \\n        return dp[ind][prev+1]=len;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n, vector<int>(n+1,-1));\\n        return f(0,-1,nums,dp);   \\n\\t}\\n};\\n```\\n\\n**Bottom-up (Tabular) DP**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) { \\n        //tabular\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1,0));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i-1;j>=-1;j--){\\n                int len= 0+ dp[i+1][j+1]; //not take  //+1 in 2nd parameter for index shifting as we are using -1\\n                if(j==-1 or nums[i]>nums[j])\\n                    len= max(len,1+ dp[i+1][i+1]); //take\\n\\n                dp[i][j+1]=len;\\n            }\\n        }\\n        return dp[0][0];\\n\\t\\t}\\n};\\n```\\n**Bottom-up Space Optimized DP**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //tabular space opt\\n        int n=nums.size();\\n        vector<int> next(n+1,0), curr(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i-1;j>=-1;j--){\\n                int len= 0+ next[j+1]; //not take  \\n                if(j==-1 or nums[i]>nums[j])\\n                    len= max(len,1+ next[i+1]); //take\\n\\n                curr[j+1]=len;\\n            }\\n            next=curr;\\n        }\\n        return next[0];\\n\\t\\t}\\n};\\n```\\n**Algorithmic Approach**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //Algorithmic approach\\n        int n=nums.size();\\n        vector<int> dp(n,1);\\n        int mx=1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){  //  check all previous values before i\\n                if(nums[j]<nums[i])\\n                    dp[i]=max(dp[i], 1+dp[j]);\\n            }\\n            mx=max(mx,dp[i]); // max val in dp array will be the ans\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\\n**Binary Search method**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //binary search\\n        vector<int> temp;\\n        int n= nums.size();\\n        temp.push_back(nums[0]);\\n\\n        int len = 1;\\n        \\n        //NOTE: temp is not the LIS\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i]>temp.back()){\\n               // nums[i] > the last element of temp array \\n\\n               temp.push_back(nums[i]);\\n               len++; //stores the size of the LIS\\n\\n            } \\n            else{\\n            // replacing the values \\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n\\n        }\\n    \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, int prev, vector<int>&nums, vector<vector<int>>&dp){\\n        if(ind==nums.size()) return 0;\\n        \\n        if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];\\n        \\n        int len= 0+ f(ind+1,prev,nums,dp); //not take\\n        if(prev==-1 or nums[ind]>nums[prev])\\n            len= max(len,1+ f(ind+1,ind,nums,dp)); //take\\n        \\n        return dp[ind][prev+1]=len;\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n, vector<int>(n+1,-1));\\n        return f(0,-1,nums,dp);   \\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) { \\n        //tabular\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1,0));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i-1;j>=-1;j--){\\n                int len= 0+ dp[i+1][j+1]; //not take  //+1 in 2nd parameter for index shifting as we are using -1\\n                if(j==-1 or nums[i]>nums[j])\\n                    len= max(len,1+ dp[i+1][i+1]); //take\\n\\n                dp[i][j+1]=len;\\n            }\\n        }\\n        return dp[0][0];\\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //tabular space opt\\n        int n=nums.size();\\n        vector<int> next(n+1,0), curr(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i-1;j>=-1;j--){\\n                int len= 0+ next[j+1]; //not take  \\n                if(j==-1 or nums[i]>nums[j])\\n                    len= max(len,1+ next[i+1]); //take\\n\\n                curr[j+1]=len;\\n            }\\n            next=curr;\\n        }\\n        return next[0];\\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //Algorithmic approach\\n        int n=nums.size();\\n        vector<int> dp(n,1);\\n        int mx=1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){  //  check all previous values before i\\n                if(nums[j]<nums[i])\\n                    dp[i]=max(dp[i], 1+dp[j]);\\n            }\\n            mx=max(mx,dp[i]); // max val in dp array will be the ans\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //binary search\\n        vector<int> temp;\\n        int n= nums.size();\\n        temp.push_back(nums[0]);\\n\\n        int len = 1;\\n        \\n        //NOTE: temp is not the LIS\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i]>temp.back()){\\n               // nums[i] > the last element of temp array \\n\\n               temp.push_back(nums[i]);\\n               len++; //stores the size of the LIS\\n\\n            } \\n            else{\\n            // replacing the values \\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n\\n        }\\n    \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397429,
                "title": "simplest-o-n-logn-solution-ever",
                "content": "**Simply u have to check  if next one is greater than previous  and u have to look for the maximum sequence so u should store the lower bound of those which are not greater than pervoius because lower bound will give us the index of element which is striclty greater than our element   and thus we can know how many elements are smaller than the given element and at last we can return the size of vector in which we store these numbers **\\nFor better understanding look at he code and dry run it on some testcases \\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        vector<int>temp;\\n        for(auto x:nums){\\n            if(temp.empty()|| x>temp.back()){\\n                temp.push_back(x);\\n            }\\n            else{\\n                int ind=lower_bound(temp.begin(),temp.end(),x)-temp.begin();\\n                temp[ind]=x;\\n            }\\n        }\\n        return temp.size();\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nint lengthOfLIS(vector<int>& nums) {\\n        vector<int>temp;\\n        for(auto x:nums){\\n            if(temp.empty()|| x>temp.back()){\\n                temp.push_back(x);\\n            }\\n            else{\\n                int ind=lower_bound(temp.begin(),temp.end(),x)-temp.begin();\\n                temp[ind]=x;\\n            }\\n        }\\n        return temp.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2396447,
                "title": "c-nlogn-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> res; res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            int p=nums[i];\\n            if(p>res.back())\\n                {res.push_back(p);continue;}\\n            int idx=lower_bound(res.begin(),res.end(),p)-res.begin();\\n            if(idx==res.size()) \\n                continue;\\n            res[idx]=p;\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> res; res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            int p=nums[i];\\n            if(p>res.back())\\n                {res.push_back(p);continue;}\\n            int idx=lower_bound(res.begin(),res.end(),p)-res.begin();\\n            if(idx==res.size()) \\n                continue;\\n            res[idx]=p;\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395433,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public int lengthOfLIS(int[] nums) {\\n        list.add(nums[0]);\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num > list.get(list.size() - 1)) list.add(num); \\n            else list.set(binarySearch(num), num);\\n        }\\n        return list.size();\\n    }\\n    \\n    private int binarySearch(int num) {\\n        int left = 0, right = list.size() - 1;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (list.get(mid) == num)  return mid;\\n            if (list.get(mid) < num) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public int lengthOfLIS(int[] nums) {\\n        list.add(nums[0]);\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num > list.get(list.size() - 1)) list.add(num); \\n            else list.set(binarySearch(num), num);\\n        }\\n        return list.size();\\n    }\\n    \\n    private int binarySearch(int num) {\\n        int left = 0, right = list.size() - 1;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (list.get(mid) == num)  return mid;\\n            if (list.get(mid) < num) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153838,
                "title": "java-all-in-one-dp-binary-similar-problems",
                "content": "https://www.youtube.com/watch?v=ekcwMsSIzVc&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=42\\n\\n**Recursion (TLE): `O(2^n) / O(n)`**\\n```\\n    public int lengthOfLIS(int[] nums) {\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        \\n        int len = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            len = Math.max(len, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return len;\\n    }\\n```\\n**DP + Memoization: `O(n2)/ O(n2)`**\\n*Moemoziation is used wwhen order is not known.*\\n```\\n    public static int[][] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length][nums.length + 1];\\n        \\n        for(int[] row : dp)\\n            Arrays.fill(row ,-1);\\n\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        if(dp[i][prev + 1] != -1) return dp[i][prev + 1];\\n        \\n        int len = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            len = Math.max(len, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return dp[i][prev + 1] = len;\\n    }\\n```\\n**DP + Memoization + Space-optimized: `O(n2) / O(n)`**\\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length + 1];\\n        Arrays.fill(dp ,-1);\\n\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        if(dp[prev + 1] != -1) return dp[prev + 1];\\n        \\n        int dt = 0, t = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            dt = Math.max(t, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return dp[prev + 1] = Math.max(t, dt);\\n    }\\n```\\n**DP + Tabulation (Easy): `O(n2) / O(n)`**\\n*In tabulation we create our own order.*\\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        int chain = 1;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    chain = Math.max(chain, dp[i]);\\n                }\\n        }\\n        \\n        return chain;\\n    }\\n```\\n**Binary search (Easy): `O(n*log(n)) / O(1)`**\\n*Insert and update the value if sequence in possible till that position.*\\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length];\\n        int chain = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int l = 0, r = chain;\\n            \\n            while(l != r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if(dp[m] < nums[i])\\n                    l = m + 1;\\n                else\\n                    r = m;\\n            }\\n            \\n            dp[l] = nums[i];\\n            if(l == chain) chain++;\\n        }\\n        \\n        return chain;\\n    }\\n```\\n***Similar problems:-***\\n\\n**longest-string-chain**\\nhttps://leetcode.com/problems/longest-string-chain/\\n**largest-divisible-subset**\\nhttps://leetcode.com/problems/largest-divisible-subset/\\n\\n*comment down, If you know more questions realted to this.*\\n**Upvote^, If you liked it!**\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n    public int lengthOfLIS(int[] nums) {\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        \\n        int len = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            len = Math.max(len, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return len;\\n    }\\n```\n```\\n    public static int[][] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length][nums.length + 1];\\n        \\n        for(int[] row : dp)\\n            Arrays.fill(row ,-1);\\n\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        if(dp[i][prev + 1] != -1) return dp[i][prev + 1];\\n        \\n        int len = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            len = Math.max(len, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return dp[i][prev + 1] = len;\\n    }\\n```\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length + 1];\\n        Arrays.fill(dp ,-1);\\n\\n        return incSubSeq(0, -1, nums);\\n    }\\n    public int incSubSeq(int i, int prev, int[] nums) {\\n        if(i >= nums.length) return 0;\\n        if(dp[prev + 1] != -1) return dp[prev + 1];\\n        \\n        int dt = 0, t = incSubSeq(i + 1, prev, nums);                                  // don\\'t take case\\n         \\n        if(prev == -1 || nums[i] > nums[prev])                                   // take cases for subsequence\\n            dt = Math.max(t, 1 + incSubSeq(i + 1, i, nums));\\n        \\n        return dp[prev + 1] = Math.max(t, dt);\\n    }\\n```\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        int chain = 1;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++)\\n                if(nums[i] > nums[j]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    chain = Math.max(chain, dp[i]);\\n                }\\n        }\\n        \\n        return chain;\\n    }\\n```\n```\\n    public static int[] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new int[nums.length];\\n        int chain = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int l = 0, r = chain;\\n            \\n            while(l != r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if(dp[m] < nums[i])\\n                    l = m + 1;\\n                else\\n                    r = m;\\n            }\\n            \\n            dp[l] = nums[i];\\n            if(l == chain) chain++;\\n        }\\n        \\n        return chain;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085153,
                "title": "best-solution-using-4-approach",
                "content": "# **APPROACH #1 : Memoization (TLE)**\\n```\\nclass Solution {\\nprivate:\\n    int f(int ind,int prev,int n,vector<int>& nums,vector<vector<int>>& dp){\\n        if(ind==n) return 0;\\n        if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];\\n        int len = 0 + f(ind+1,prev,n,nums,dp);\\n        if(prev==-1 || nums[ind]>nums[prev]){\\n            len = max(len,1+f(ind+1,ind,n,nums,dp));\\n        }\\n        return dp[ind][prev+1] = len;\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return f(0,-1,n,nums,dp);\\n    }\\n};\\n```\\n\\n# **APPROACH#2 : Tabulation**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev=ind-1;prev>=-1;prev--){\\n                int len = 0 + dp[ind+1][prev+1];\\n                if(prev==-1 || nums[ind]>nums[prev]){\\n                    len = max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev+1] = len;\\n            }\\n        }\\n        return dp[0][-1+1];\\n    }\\n};\\n```\\n\\n# **APPROACH#3 : Tabulation(Space Optimisation)**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        int maxi = 1;\\n        vector<int> dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(nums[prev]<nums[i]) {\\n                    dp[i] = max(dp[i],1+dp[prev]);\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n        \\n        return maxi;\\n        \\n    }\\n};\\n```\\n\\n# **Approach#4 Binary Search(Optimal Approach)**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>temp.back()){\\n                temp.push_back(nums[i]);\\n            }\\n            else{\\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```\\n\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int f(int ind,int prev,int n,vector<int>& nums,vector<vector<int>>& dp){\\n        if(ind==n) return 0;\\n        if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];\\n        int len = 0 + f(ind+1,prev,n,nums,dp);\\n        if(prev==-1 || nums[ind]>nums[prev]){\\n            len = max(len,1+f(ind+1,ind,n,nums,dp));\\n        }\\n        return dp[ind][prev+1] = len;\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return f(0,-1,n,nums,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev=ind-1;prev>=-1;prev--){\\n                int len = 0 + dp[ind+1][prev+1];\\n                if(prev==-1 || nums[ind]>nums[prev]){\\n                    len = max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev+1] = len;\\n            }\\n        }\\n        return dp[0][-1+1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n =nums.size();\\n        int maxi = 1;\\n        vector<int> dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(nums[prev]<nums[i]) {\\n                    dp[i] = max(dp[i],1+dp[prev]);\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n        \\n        return maxi;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>temp.back()){\\n                temp.push_back(nums[i]);\\n            }\\n            else{\\n                int ind = lower_bound(temp.begin(),temp.end(),nums[i]) - temp.begin();\\n                temp[ind] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914674,
                "title": "java-using-treeset-o-n-logn",
                "content": "# Explanation.\\nTreeSet.ceiling return the leatest element greater than or equal to X, or null if there is no such element. \\nOn every step we add a new value to our set, but before remove the greatest to current. With this approach out set contains the longest subsequence on every step, and as a result at the end size of set is out goal.\\n\\n# Complexity. \\n**O(N  * logN)**, because we find the greater in the tree for every n of the numbers at each step.\\n*TreeSet.ceiling() ::= O(logN)*, because *logN* is a height of the tree\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        var set = new TreeSet<Integer>();\\n        for (var i = 0; i < nums.length; i++) {\\n            var currElem = set.ceiling(nums[i]); \\n            if (currElem != null) {\\n                set.remove(currElem);\\n            }\\n            set.add(nums[i]);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        var set = new TreeSet<Integer>();\\n        for (var i = 0; i < nums.length; i++) {\\n            var currElem = set.ceiling(nums[i]); \\n            if (currElem != null) {\\n                set.remove(currElem);\\n            }\\n            set.add(nums[i]);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764556,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) res.push_back(nums[i]);\\n            else{\\n                int index = lower_bound(res.begin(), res.end(), nums[i]) - res.begin();\\n                res[index] = nums[i];\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) res.push_back(nums[i]);\\n            else{\\n                int index = lower_bound(res.begin(), res.end(), nums[i]) - res.begin();\\n                res[index] = nums[i];\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439505,
                "title": "c-solution-descriptive-o-nlog-n-dp-binary-search",
                "content": "In the given problem we can apply a brute force solution with complexity  or Dynamic programming solution with complexity O(N2) fairly easily but bringing down the complexity to the O(Nlog(N)) is failrly challenging. \\n\\nThje method we use a combination of greedy approach couples with the use of binary search and an auxilary space to store our answer top lower the compelxity which and beat the overlapping subproblems.\\n\\nex N= 8 Array=[10 , 9 , 2 , 5, 3 , 7  , 101 ,18]\\n\\nWhen we start making our longest increeasing subsequence we  need to take somethings into consideration:\\n1. The elements here must be in the same order in our input array \\n2. The sequence must be increasing \\n3. We must always try to put the maximum number of elements inside  this output array.\\n* Output array dp[i] will represent the best ending or losest ending for the longest increasing subsequence of length i for the given array.\\n* So we have [10 , 9 , 2 , 5, 3 , 7  , 101 ,18] in input , our LIS for now is empty [] and indecx = 0 \\n* We put 10 into our empty array [] -> [10] and  we move forwards ,i=i+1\\n* Now we see that our ouput is no longer empty , and we must see if we should include arr[i] ,i.e. 9 in our output array or not . so , we cant add 9 after 10 , and we cant place it before 10 , because it will mess up the order , but if we think about it , replacing 10 by 9 will be more beneficial , because 10 is smaller than 9 and her it is more accomodating , and will let us add a value between 9 and 10 if we encounter it in the future . Replace 9 by its next largest value from output i.e. 10\\n* Now output has [9] and i becomes 2 , arr[i] = 2. We are again in the same positon and we cant put 2 after 9 to increase teh seq ,  nor before it , but we can replace 9 by 2 for sure , because in this manner we can accomodate more valuers in the future (values between 2 and 9 ) which would have been impossible moving forward with 9.\\n* Now our output array is, [2] and index/i becomes = 3,arr[3] = 5 and we can directly we see that there is no element larger than 5 here , here we append it to the array. [2] -> [2,5].\\n* Now we have index/i = 4 , arr[i] = 3 , we replace elemnt larger than 3 with 3 . [2,5] -> [2,3]\\n* i = 5 , arr[i] = 7 and the largest elemnt in our output is less than 7 , so append 7 to the LIS , [2,3] -> [2,3,7]\\n* i = 6 , arr[i] = 101 , 7 < 101 , so just append 101 , [2,3,7] -> [2,3,7,101] \\n* i = 7 , arr[i] = 18 , 101 is the elemnt in lis taht is larger than 18 , so swap 101 with 18 ,  [2,3,7,101] -> [2,3,7,18]\\n* i = 8 . i > n , we stop and we have our LIS - [2,3,7,18].\\n\\nSo our dry run gives the right answer and the logic can be written as follows \\n1. maintain a output and ush first elemennt in it.\\n2. Now iterate through input array .\\n3. if my elemmnt in input is larger than the max element in LIS/Output we append it to LIS, else we swap it with the elemnt just larger than itself.\\n4. We get the LIS in output array when the loop stops .\\n\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n\\n        vector<int> dp;//LIS \\n    \\n        dp.push_back(nums[0]);//insert first elememnt\\n        \\n        for(int i = 1 ;i < nums.size() ; i++){\\n          \\n            if(dp[dp.size() -1]<nums[i]){//if our elemnt is larger than largets then just append\\n                dp.push_back(nums[i]);\\n            }else{//esle just swap with the elemnt larger than ourself\\n               \\n            int ind = lower_bound(dp.begin() , dp.end() , nums[i]) - dp.begin();\\n            \\n                dp[ind] = nums[i];\\n            }\\n        }\\n        \\n        return dp.size();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n\\n        vector<int> dp;//LIS \\n    \\n        dp.push_back(nums[0]);//insert first elememnt\\n        \\n        for(int i = 1 ;i < nums.size() ; i++){\\n          \\n            if(dp[dp.size() -1]<nums[i]){//if our elemnt is larger than largets then just append\\n                dp.push_back(nums[i]);\\n            }else{//esle just swap with the elemnt larger than ourself\\n               \\n            int ind = lower_bound(dp.begin() , dp.end() , nums[i]) - dp.begin();\\n            \\n                dp[ind] = nums[i];\\n            }\\n        }\\n        \\n        return dp.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327535,
                "title": "python-top-down-recursive-with-memo-o-n-2",
                "content": "I think time complextiy for this one is O(N^2). The other recursive python solutions were giving a mix of TLE or MLE, and I wasn\\'t undersanding the point of having a prev pointer set to -1.\\n\\nIdea\\n* if we had a recursive function, ```rec(i)``` that gave the longest increasing sub array starting at ```nums[i]``` then we would add 1 to the previous call ```rec(i-1)``` only if ```nums[i] > nums[i-1]```\\n* if not, we dont take but just max for each reucrsive call\\n* we do this for all indes after ```i``` or ```for j in range(i+1,N)```\\n*  the actual recurisve call is O(N), but we invoke for each element nums again taking the max\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        N = len(nums)\\n        \\n        def rec(i):\\n            if i == N:\\n                return 0\\n            if i in memo:\\n                return memo[i]\\n            SUM = 0\\n            for j in range(i+1,N):\\n                if nums[j] > nums[i]:\\n                    SUM = max(SUM,1+rec(j))\\n            memo[i] = SUM\\n            return SUM\\n        \\n        #invoke for all elemnts in nums\\n        ans = 0\\n        for i in range(N):\\n            ans = max(ans,1+rec(i))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```rec(i)```\n```nums[i]```\n```rec(i-1)```\n```nums[i] > nums[i-1]```\n```i```\n```for j in range(i+1,N)```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        N = len(nums)\\n        \\n        def rec(i):\\n            if i == N:\\n                return 0\\n            if i in memo:\\n                return memo[i]\\n            SUM = 0\\n            for j in range(i+1,N):\\n                if nums[j] > nums[i]:\\n                    SUM = max(SUM,1+rec(j))\\n            memo[i] = SUM\\n            return SUM\\n        \\n        #invoke for all elemnts in nums\\n        ans = 0\\n        for i in range(N):\\n            ans = max(ans,1+rec(i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326673,
                "title": "longest-increasing-subsequence-c-code-with-o-nlogn-complexity",
                "content": "1.  Maintain an array of numbers increasing order. Initially empty.\\n\\n2.  Idea is traverse the array, for a given position \\'i\\', find the first greater number than current in that array using binary search, if there is no such number add current to that array.\\n\\n3.  If a number is found greater than current don\\'t add to that array. \\n\\n4.  In the end that array will be filled with numbers in increasing order find the first number greater than current in LIS\\n\\n5.  If no such number is found, we can add the current\\n\\n6.  If a number greater exists, then replace it with current, this is because putting the smaller number in place of a bigger number will allow more numbers greater than current to be part of LIS\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++) {\\n            auto it = std::lower_bound(ans.begin(), ans.end(), nums[i]);\\n            if(it==ans.end()){\\n                ans.push_back(nums[i]);\\n            }\\n            else {\\n                *it = nums[i];\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```\\nHope you find it useful..",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++) {\\n            auto it = std::lower_bound(ans.begin(), ans.end(), nums[i]);\\n            if(it==ans.end()){\\n                ans.push_back(nums[i]);\\n            }\\n            else {\\n                *it = nums[i];\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292036,
                "title": "dp-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277080,
                "title": "cpp-recursive-memo-with-explanation-and-comment",
                "content": "**Observation**\\n* The longest increasing subsequence (LIS) of an element E can be reused, since the search range and the elements of LIS are the same. (which can be memoized.)\\n\\n**Analysis**\\n(1) Base on the requirement, we can identify the valid subsequence should have a new element that is strictly greater than the most recent selected element.\\n(2) if we want to find the longest subsequence, the naive approach is to walk through all the subsequences and keep track of the longest result.  To walk through all the subsequences, we can simply use an index i to choose nums[i] as the first element (result length incremented by 1), and then find the longest subsequence in range of [i+1, nums.size()).\\n(3) The way to find the longest subsequence in range of [i+1, nums.size()) required to find the element E that fullfill (1) and find the LIS  in range of [E+1, nums.size() )........ -> Recursivly identify the LIS.\\n(4) Base case is when we have no element to scan (search index exceed the nums.size()). In this case we return 0.\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int res = 0;\\n        vector<int> dp(nums.size());\\n\\t\\t//(2) choose nums[i] as the first element of subsequence and keep track of the LIS.\\n        for(int i = 0; i < nums.size(); ++i){\\n            res = max(res, 1+helper(dp,nums, i));\\n        }\\n        return res;\\n    }\\n    \\n    int helper(vector<int>& dp, vector<int>& nums, int idx){\\n\\t\\t//(4) Base case, the search index exceed the nums index. Just return 0 so that it will not effect the result ( Just like do-nothing).\\n        if(idx==nums.size()) return 0;\\n        if(dp[idx]) return dp[idx];\\n        int res = 0;\\n        for(int i = idx+1; i<nums.size(); ++i){\\n\\t\\t\\t//(1) Find the strictly increasing element, denoted as E.\\n            if(nums[i]>nums[idx]){\\n\\t\\t\\t\\t//(3) calculate the LIS of E + nums[E+1,.....,nums.size()-1] and keep track of the longest.\\n                res = max(res, 1+helper(dp,nums,i));\\n            }\\n        }\\n        return dp[idx] = res;\\n    }\\n};\\n```\\n\\nRecently, I have practice the DP problem a lot. I think the hardest part of DP problem is to identify the optimal structure of a problem, which make it hard to identify the recusive approach. In the case of constructing a recusive solution, one can always identify what is the \"GOAL\" of each call, and how the results connected with each other. In this problem, the helper is called recursively, and the \"GOAL\" of this function is to find the LIS of give sequence. So the question is then became \"What decision we need to do to reach the goal?\". In this case, it will be finding the next strictly increasing element E (as required) and then E to a imaginary vector (you can actually use one to be more intuitive) and finally is where the result connected with each other. In this case, we want to find the LIS of the sequence after E (E+1 to nums.size()-1). As long as the mechanism of finding the LIS is correct, one can expect that recusion can give you the LIS in each call. (Quite similar with the \"FOR LOOP\" right?)\\n\\nAlthough this might not be a very concise solution, I hope this can help someone who are struggling to learn the recursion. If there is any suggestion or I misunderstanding something important (which might be possible since I am certainly not an expertise of recursion or DP, just a random guy trying to learn the beauty of recursion), feel free to comment below.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int res = 0;\\n        vector<int> dp(nums.size());\\n\\t\\t//(2) choose nums[i] as the first element of subsequence and keep track of the LIS.\\n        for(int i = 0; i < nums.size(); ++i){\\n            res = max(res, 1+helper(dp,nums, i));\\n        }\\n        return res;\\n    }\\n    \\n    int helper(vector<int>& dp, vector<int>& nums, int idx){\\n\\t\\t//(4) Base case, the search index exceed the nums index. Just return 0 so that it will not effect the result ( Just like do-nothing).\\n        if(idx==nums.size()) return 0;\\n        if(dp[idx]) return dp[idx];\\n        int res = 0;\\n        for(int i = idx+1; i<nums.size(); ++i){\\n\\t\\t\\t//(1) Find the strictly increasing element, denoted as E.\\n            if(nums[i]>nums[idx]){\\n\\t\\t\\t\\t//(3) calculate the LIS of E + nums[E+1,.....,nums.size()-1] and keep track of the longest.\\n                res = max(res, 1+helper(dp,nums,i));\\n            }\\n        }\\n        return dp[idx] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992907,
                "title": "java-a-textbook-dp-o-n-2-solution-with-explanations",
                "content": "This is a classic Dynamic Programming question. We saw different DP solutions posted in Discuss section. To understand those solutions, it is important to get clear -- What does that `int[] dp` store?\\n\\nPersonally, I think it is more important to understand the O(n^2) solution than memorizing the Binary Search O(nlogn) solution, because the standard DP solution can be used to resolve many other DP questinos. \\n\\nTextbook DP Solution\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0; \\n        int[] dp = new int[nums.length]; \\n        Arrays.fill(dp, 1);  // For each element in nums, by default the length of LIS is 1. i.e. nums = [1], return 1. \\n        \\n        for (int j = 1; j < nums.length; j++) { // j represents where we currently stand at. No need to check j = 0 case, dp array is already filled with 1\\n            for (int i = 0; i < j; i++) { // i loops through all the elements from 0 to j, so i starts from 0\\n                if (nums[j] > nums[i]) { // only if nums[j] > nums[i] could we append nums[j] to nums[i] to form a longer sequence \\n                    dp[j] = Math.max(dp[j], dp[i] + 1);  // which one is longer for dp[j]? previously calculated dp[i] or dp[j] append to the current nums[i]?\\n                }\\n            }\\n        }\\n        \\n        int finalmax = 0; \\n        \\n        /* Why dp[dp.length - 1] is not the correct answer? \\n           because this dp array stores the value of \"if append nums[j], what would the longest length be\", not \"the longest length so for at nums[j]\"\\n           so we need to loop through the whole dp array to find out the largest number */\\n        for (int i = 0; i < dp.length; i++) {\\n            finalmax = Math.max(finalmax, dp[i]); \\n        }\\n\\n        return finalmax; \\n    }\\n}\\n```\\n\\nWhat if we would like to avoid looping through dp array? Yes, it can be done. \\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0; \\n        int[] dp = new int[nums.length]; \\n        Arrays.fill(dp, 1); \\n        int finalmax = 1; \\n        \\n        for (int j = 1; j < nums.length; j++) {\\n            for (int i = 0; i < j; i++) { \\n                if (nums[j] > nums[i]) { \\n                    dp[j] = Math.max(dp[j], dp[i] + 1);  \\n                    finalmax = Math.max(finalmax, dp[j]); // update finalmax every time dp[j] is updated, to avoid looping through dp array later\\n                }\\n            }\\n        }\\n\\n        return finalmax; \\n    }\\n}\\n```\\nFor iteration details, this video might help. https://www.youtube.com/watch?v=fV-TF4OvZpk&ab_channel=BackToBackSWE\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0; \\n        int[] dp = new int[nums.length]; \\n        Arrays.fill(dp, 1);  // For each element in nums, by default the length of LIS is 1. i.e. nums = [1], return 1. \\n        \\n        for (int j = 1; j < nums.length; j++) { // j represents where we currently stand at. No need to check j = 0 case, dp array is already filled with 1\\n            for (int i = 0; i < j; i++) { // i loops through all the elements from 0 to j, so i starts from 0\\n                if (nums[j] > nums[i]) { // only if nums[j] > nums[i] could we append nums[j] to nums[i] to form a longer sequence \\n                    dp[j] = Math.max(dp[j], dp[i] + 1);  // which one is longer for dp[j]? previously calculated dp[i] or dp[j] append to the current nums[i]?\\n                }\\n            }\\n        }\\n        \\n        int finalmax = 0; \\n        \\n        /* Why dp[dp.length - 1] is not the correct answer? \\n           because this dp array stores the value of \"if append nums[j], what would the longest length be\", not \"the longest length so for at nums[j]\"\\n           so we need to loop through the whole dp array to find out the largest number */\\n        for (int i = 0; i < dp.length; i++) {\\n            finalmax = Math.max(finalmax, dp[i]); \\n        }\\n\\n        return finalmax; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0) return 0; \\n        int[] dp = new int[nums.length]; \\n        Arrays.fill(dp, 1); \\n        int finalmax = 1; \\n        \\n        for (int j = 1; j < nums.length; j++) {\\n            for (int i = 0; i < j; i++) { \\n                if (nums[j] > nums[i]) { \\n                    dp[j] = Math.max(dp[j], dp[i] + 1);  \\n                    finalmax = Math.max(finalmax, dp[j]); // update finalmax every time dp[j] is updated, to avoid looping through dp array later\\n                }\\n            }\\n        }\\n\\n        return finalmax; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910229,
                "title": "js-patience-sorting-o-nlogn-time-o-k-space",
                "content": "Didn\\'t see JS Patience Sorting, so here it is. Explanation from this youtube video (thanks to Solution thread for the link, not my video) \\nhttps://www.youtube.com/watch?v=22s1xxRvy28\\n\\n```\\n//   -------------\\n//   PATIENCE SORTING\\n//   -------------\\n  \\n//   start stacks of descending values left to right\\n//   always stack when possible, stack count is LIS\\n  \\n  if (!nums.length) return 0\\n  \\n  let stacks = []\\n  stacks[0] = nums[0]\\n  \\n  for (let i = 1; i < nums.length; ++i) {\\n    for (let j = 0; j < stacks.length; ++j) {\\n      if (nums[i] <= stacks[j]) {\\n        stacks[j] = nums[i]\\n        break;\\n      }\\n      if (j === stacks.length - 1) stacks.push(nums[i])\\n    } \\n  }\\n  return stacks.length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//   -------------\\n//   PATIENCE SORTING\\n//   -------------\\n  \\n//   start stacks of descending values left to right\\n//   always stack when possible, stack count is LIS\\n  \\n  if (!nums.length) return 0\\n  \\n  let stacks = []\\n  stacks[0] = nums[0]\\n  \\n  for (let i = 1; i < nums.length; ++i) {\\n    for (let j = 0; j < stacks.length; ++j) {\\n      if (nums[i] <= stacks[j]) {\\n        stacks[j] = nums[i]\\n        break;\\n      }\\n      if (j === stacks.length - 1) stacks.push(nums[i])\\n    } \\n  }\\n  return stacks.length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881391,
                "title": "o-n-2-time-o-n-space-intuituve-python-code",
                "content": "we maintain a look up table where we store the longest subsequence up untill the index.\\n\\nwe loop through all the elements\\nand maintain another loop which loops till the current element\\nwhenever we find an element smaller than the current element we know it is a potential match for the element in subsequence just smaller than the current element\\n\\nin that case we check the length of the already existing length of the subsequence stored\\nfor the inner loop index and add one to it\\n\\nIn case the above explanation is not clear please leave down a comment\\nill highly recommend to copy paste the code into pycharm and put debug points and check the behaviour\\n\\nalso leave down a comment if not clear\\nill try a better explanation\\nplease upvote if useful\\nkindly avoid downvoting\\n\\n```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n            \\n        maxCount = 0\\n        #this stores the longest subsequence untill the current index\\n        seq = [1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            current = nums[i]\\n            \\n            for j in range(i):\\n                prev = nums[j]\\n                \\n                if prev < current and seq[j]  + 1 > seq[i]:\\n                    seq[i]  = seq[j]  + 1\\n        return max(seq)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n            \\n        maxCount = 0\\n        #this stores the longest subsequence untill the current index\\n        seq = [1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            current = nums[i]\\n            \\n            for j in range(i):\\n                prev = nums[j]\\n                \\n                if prev < current and seq[j]  + 1 > seq[i]:\\n                    seq[i]  = seq[j]  + 1\\n        return max(seq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857107,
                "title": "7-line-python-solution-approach-3",
                "content": "class Solution:\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n\\t\\t#the shortest increasing subsequence for a non-empty list is 1\\n        lst = [1]*len(nums)\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n\\t\\t\\t\\t#compare ith element with every element befor it\\n                if nums[i]>nums[j]:\\n                    lst[i] = max(lst[i],lst[j]+1)\\n        return max(lst)\\nnums = [3, 6, 4, 8, 5, 7]\\nlst      = [1, 2, 2, 3, 3, 4]\\nThe longest subsequence is [3,4,5,7]\\t\\n\\t\\n\\t\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n\\t\\t#the shortest increasing subsequence for a non-empty list is 1\\n        lst = [1]*len(nums)\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n\\t\\t\\t\\t#compare ith element with every element befor it\\n                if nums[i]>nums[j]:\\n                    lst[i] = max(lst[i],lst[j]+1)\\n        return max(lst)\\nnums = [3, 6, 4, 8, 5, 7]\\nlst      = [1, 2, 2, 3, 3, 4]\\nThe longest subsequence is [3,4,5,7]\\t\\n\\t\\n\\t\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 817741,
                "title": "java-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] array) {\\n        int [] LIS = new int [array.length];\\n        int max=0;\\n        for (int i=0; i<array.length; i++) {\\n            LIS[i] = 1;\\n        }\\n        for (int i=1; i<array.length; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (array[i] > array[j] && LIS[i] < LIS[j] + 1)\\n                    LIS[i] = LIS[j] + 1;\\n            }\\n        }\\n        for (int i=0; i<LIS.length; i++) {\\n            if (max < LIS[i])\\n                max = LIS[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] array) {\\n        int [] LIS = new int [array.length];\\n        int max=0;\\n        for (int i=0; i<array.length; i++) {\\n            LIS[i] = 1;\\n        }\\n        for (int i=1; i<array.length; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (array[i] > array[j] && LIS[i] < LIS[j] + 1)\\n                    LIS[i] = LIS[j] + 1;\\n            }\\n        }\\n        for (int i=0; i<LIS.length; i++) {\\n            if (max < LIS[i])\\n                max = LIS[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654604,
                "title": "c-brute-force-to-textbook-dp-solution",
                "content": "**Longest Increasing Subsequence (LIS)**\\nThe LIS problem is an important problem when learning about Dynamic Programming (DP) as it presents a new qualification to add to our DP construction toolkit as compared to many previous DP problems seen thus far (think of DP problems like Longest Common Subsequence, Matching Regular Expressions, Climbing Stairs, etc.).\\n\\nI see a lot of the posts in the discussion just state what the final algorithm should be and/or what the code looks like.  I think this robs us of a valuable learning opporunity, especially given the importance of LIS in DP.  I hope this discussion can help guide others through the learning process like I was with my own mentors.\\n\\n**Overview**\\n  - Initial observations about LIS\\n  - Brute Force Solution (this helps us gain intuition about a problem)\\n  - Recognition of Dynamic Programming (DP)\\n  - DP Construction and Solution - Key learning point from LIS\\n\\n**Symbols**\\n```\\nA = array of integers\\nn = size of n\\ni = {0, 1, ..., n-1}\\nj = {0, 1, ..., i-1}\\nA[i].LIS = length of the LIS that ends at A[i]\\nA[i].maxVal = max number of the LIS that ends at A[i]\\n```\\n\\n**Initial observation(s) about the LIS**\\n  - Can only extend LIS if the current element is strictly larger than the last element of the subsequence we\\'re trying to extend (i.e. ```A[i] > some previous element```)\\n\\n**Brute Force (BF) Solution**\\nIt\\'s always a good to start here as it helps us gain insights into the problem and gives us a starting point.  The BF solution should be obvious as to its correctness.\\n\\nIn this case, we can find ALL subsequences of the array, then check each subsequence if it\\'s strictly increasing.  For subsequences that are strictly increasing, find the maximum length.\\n\\nTo find all subsequences of an array can be accomplished by picking or not-picking each element of the array.\\n\\n```\\nInput: [1, 2, 3]\\nOutput: [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]\\n```\\n\\n```\\nvoid GetAllSubSequences(const vector<int>& nums, vector<int> res, vector<vector<int>>& out)\\n{\\n    if (nums.size() == 0)\\n    {\\n        out.push_back(res);\\n        return;\\n    }\\n\\n    PrintAllSubSeqRecurse(vector<int>(nums.begin() + 1, nums.end()), res, out); // don\\'t choose element for res\\n\\n    res.push_back(nums[0]);\\n    PrintAllSubSeqRecurse(vector<int>(nums.begin() + 1, nums.end()), res, out); // choose element for res\\n\\n    return;\\n}\\n```\\n\\nRuntime: O(2^n)\\n  - At each element, we can make two choices/recursive calls\\n\\n**Recognition of Dynamic Programming (DP)**\\nBy now, we see that the LIS of can be built up from smaller sub-problems where the LIS for``` A = [1, 2, 3]``` can be found by examining the subsequences of smaller version of the original array: ```A[0..n-1] = [1, 2], A[0..n-2] = [1]```.  Therefore, this problem is a prime candidate for DP.\\n\\n**DP Construction and Solution - Key learning point from LIS**\\nThe nice thing about DP is that it follows a very structured approach.  We define our DP construction (defintiion), i.e. what our dp array/matrix represents, then create the Recurrence Relation (formulation) that matches our defintion.  We know the Recurrence Relation holds true for all of n because of the fact that DP problems are made up of sub-problems, therefore inductive reasoning proves that the Recurrence Relation will hold true if written correctly.\\n\\nHistorically, DP problems have defined the \"state\" construction as ```dp[i] := solution up until A[0..i]```.  For example, in the Staircase Problem, ```dp[i] := number of unique ways to get to step i```.  Then, we can step through each ```i = {0, 1, ... , n-1}``` then reference ```dp[n-1```] to get our answer.\\n\\nIf we begin our approach to this problem with the above defintion, we might come up with something like ```dp[i] := longest increasing subsequence from A[0..i]```.\\n```\\n  A = [2, 10, 3, 0, 4]\\n dp = [1, 2, 2, 2, 3]\\n```\\nAt this point, it looks like our definition can work, next we need to come up with our Recurrence Relation.  The Recurrence Relation represent all the choices we can make at any index i.  Note, the loop \"for j to i\" is necessary to compare A[i] against all previous LIS.  E.g. A[2] compare to dp[0] means we skip A[1].\\n```\\ndp[i] = max(dp[i-1],\\n            max(for j to i:\\n                  if A[i] > dp[j]:\\n                    dp[j] + 1\\n               )\\n            )\\n```\\nTesting this formulation reveals a flaw.\\n```\\ndp[0] = 1 -> base case\\ndp[1] = 2 -> because A[1] > dp[0]\\ndp[2] = ??? -> how do we know where we can extend the element 3 from?\\n  - Because we\\'ve defined our definition as the LIS from A[0..i], all we know is the length of the LIS which tells us nothing about whether or not we can actually extend a previous LIS.\\n```\\nRevisiting our DP definition, we need to keep track of both the length of LIS as well as the max value of the LIS.  ```dp[i] := LIS of A[0..i] and the largest value of the LIS```.  Let\\'s denote this as dp[i].LIS and dp[i].maxVal.  The new formulation will look something like:\\n```\\ndp[i] = max(dp[i-1],\\n            max(for j to i:\\n                  if A[i] > dp[j].maxVal:\\n                    dp[j].LIS + 1\\n               )\\n            )\\n```\\nNow, testing this formulation where ```<LIS>/<maxVal>```\\n```\\ndp[0] = 1/2 -> base case\\ndp[1] = 2/10 -> because A[1] > dp[0].maxVal\\ndp[2] = 2/3 -> because A[2] > dp[0].maxVal\\n...\\ndp = [1/2, 2/10, 2/3, 2/3, 3/4]\\n```\\nTechnically, we can stop here as the current definition and formulation gives us the correct answer.  However, the LIS is a classic DP problem that introduces a powerful new DP technique.  The observation is that in our formulation, ```dp[i-1]``` provides us no extra information.  If ```A[i]``` is no bigger than any ```maxVal``` element in the previous ```dp[0..j]```, then there we\\'ve found the start of a new increasing subsequence.  Removing that condition from our forumation:\\n```\\ndp[i] = max(for j to i:\\n                if A[i] > dp[j].maxVal:\\n                    dp[j].LIS + 1\\n            )\\n```\\nThis simplifies the formulation a little, but now the formulation is inconsistent with our definition of ```dp[i] := LIS of A[0..i] and the largest value of the LIS```.  E.g. ```dp[3] = not defined based on the above formulation```.\\n\\nTherefore, we can add an additional qualifier to our definition to match the formulation.\\n\\n```dp[i] := LIS of A[0..i] and the largest of the LIS *such that the LIS ends at A[i]*```\\n\\nGiven this new definition, the formulation looks like:\\n```\\ndp[i] = for j to i:\\n            if A[i] > dp[j].maxVal:\\n                { max(dp[i].LIS, dp[j].LIS + 1), A[i] }\\n            else\\n                { max(dp[i], 1), A[i] }\\n```\\nInitialize dp with ```1/INT_MIN```\\n```\\n  A = [1, 4, 2, 0, 3]\\n dp = [1/1, 2/4, 2/2, 1/0, 3/3]\\n```\\nGiven the new definition and formulation, at each ```dp[i]```, we see the LIS length/maxVal for the LIS that ends at ```A[i]```.  The formulation nearly writes itself in code.  I\\'m using a struct to represent each ```dp[i]``` state for clarity.\\n\\n```\\nstruct DPState\\n{\\n    int LISLenth;\\n    int maxVal\\n    DPState(int length = 1, int val = INT_MIN) : LISLength{ length }, maxVal{ val}\\n    {}\\n};\\n\\nint LengthOfLIS(vector<int>& nums)\\n{\\n    int res = INT_MIN;\\n    int n = nums.size();\\n\\n    if (n <= 1)\\n        return n;\\n\\n    vector<DPState> dp(n, DPState());\\n    dp[0] = DPState(1, nums[0]);\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = 0; j < i; j++)\\n        {\\n            if (nums[i] > dp[j].maxVal)\\n                dp[i] = DPState(max(dp[i].LISLength, dp[j].LISLength + 1), nums[i]);\\n            else\\n                dp[i] = DPState(max(dp[i].LISLength, 1), nums[i]);\\n        }\\n    }\\n\\n    for (const auto x : dp)\\n    {\\n        res = max(res, x.LISLength);\\n    }\\n\\n    return res;\\n}\\n```\\n\\nThe qualification of ```...such that the LIS ends at A[i]``` to the DP definition is a powerful construct and allows for DP constructions that were otherwise impossible before.  This is the key takeaway from the LIS DP problem.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nA = array of integers\\nn = size of n\\ni = {0, 1, ..., n-1}\\nj = {0, 1, ..., i-1}\\nA[i].LIS = length of the LIS that ends at A[i]\\nA[i].maxVal = max number of the LIS that ends at A[i]\\n```\n```A[i] > some previous element```\n```\\nInput: [1, 2, 3]\\nOutput: [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]\\n```\n```\\nvoid GetAllSubSequences(const vector<int>& nums, vector<int> res, vector<vector<int>>& out)\\n{\\n    if (nums.size() == 0)\\n    {\\n        out.push_back(res);\\n        return;\\n    }\\n\\n    PrintAllSubSeqRecurse(vector<int>(nums.begin() + 1, nums.end()), res, out); // don\\'t choose element for res\\n\\n    res.push_back(nums[0]);\\n    PrintAllSubSeqRecurse(vector<int>(nums.begin() + 1, nums.end()), res, out); // choose element for res\\n\\n    return;\\n}\\n```\n``` A = [1, 2, 3]```\n```A[0..n-1] = [1, 2], A[0..n-2] = [1]```\n```dp[i] := solution up until A[0..i]```\n```dp[i] := number of unique ways to get to step i```\n```i = {0, 1, ... , n-1}```\n```dp[n-1```\n```dp[i] := longest increasing subsequence from A[0..i]```\n```\\n  A = [2, 10, 3, 0, 4]\\n dp = [1, 2, 2, 2, 3]\\n```\n```\\ndp[i] = max(dp[i-1],\\n            max(for j to i:\\n                  if A[i] > dp[j]:\\n                    dp[j] + 1\\n               )\\n            )\\n```\n```\\ndp[0] = 1 -> base case\\ndp[1] = 2 -> because A[1] > dp[0]\\ndp[2] = ??? -> how do we know where we can extend the element 3 from?\\n  - Because we\\'ve defined our definition as the LIS from A[0..i], all we know is the length of the LIS which tells us nothing about whether or not we can actually extend a previous LIS.\\n```\n```dp[i] := LIS of A[0..i] and the largest value of the LIS```\n```\\ndp[i] = max(dp[i-1],\\n            max(for j to i:\\n                  if A[i] > dp[j].maxVal:\\n                    dp[j].LIS + 1\\n               )\\n            )\\n```\n```<LIS>/<maxVal>```\n```\\ndp[0] = 1/2 -> base case\\ndp[1] = 2/10 -> because A[1] > dp[0].maxVal\\ndp[2] = 2/3 -> because A[2] > dp[0].maxVal\\n...\\ndp = [1/2, 2/10, 2/3, 2/3, 3/4]\\n```\n```dp[i-1]```\n```A[i]```\n```maxVal```\n```dp[0..j]```\n```\\ndp[i] = max(for j to i:\\n                if A[i] > dp[j].maxVal:\\n                    dp[j].LIS + 1\\n            )\\n```\n```dp[i] := LIS of A[0..i] and the largest value of the LIS```\n```dp[3] = not defined based on the above formulation```\n```dp[i] := LIS of A[0..i] and the largest of the LIS *such that the LIS ends at A[i]*```\n```\\ndp[i] = for j to i:\\n            if A[i] > dp[j].maxVal:\\n                { max(dp[i].LIS, dp[j].LIS + 1), A[i] }\\n            else\\n                { max(dp[i], 1), A[i] }\\n```\n```1/INT_MIN```\n```\\n  A = [1, 4, 2, 0, 3]\\n dp = [1/1, 2/4, 2/2, 1/0, 3/3]\\n```\n```dp[i]```\n```A[i]```\n```dp[i]```\n```\\nstruct DPState\\n{\\n    int LISLenth;\\n    int maxVal\\n    DPState(int length = 1, int val = INT_MIN) : LISLength{ length }, maxVal{ val}\\n    {}\\n};\\n\\nint LengthOfLIS(vector<int>& nums)\\n{\\n    int res = INT_MIN;\\n    int n = nums.size();\\n\\n    if (n <= 1)\\n        return n;\\n\\n    vector<DPState> dp(n, DPState());\\n    dp[0] = DPState(1, nums[0]);\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = 0; j < i; j++)\\n        {\\n            if (nums[i] > dp[j].maxVal)\\n                dp[i] = DPState(max(dp[i].LISLength, dp[j].LISLength + 1), nums[i]);\\n            else\\n                dp[i] = DPState(max(dp[i].LISLength, 1), nums[i]);\\n        }\\n    }\\n\\n    for (const auto x : dp)\\n    {\\n        res = max(res, x.LISLength);\\n    }\\n\\n    return res;\\n}\\n```\n```...such that the LIS ends at A[i]```",
                "codeTag": "Unknown"
            },
            {
                "id": 567500,
                "title": "lis-o-nlogn-explanation-video-by-algods",
                "content": "Hey Guys,\\nHere is the link to the video solution for this question by **alGOds**.\\nhttps://youtu.be/nf3YG4CnTbg4\\nIt has the perfect explanation to solve this in **O(nlogn) complexity**.",
                "solutionTags": [],
                "code": "Hey Guys,\\nHere is the link to the video solution for this question by **alGOds**.\\nhttps://youtu.be/nf3YG4CnTbg4\\nIt has the perfect explanation to solve this in **O(nlogn) complexity**.",
                "codeTag": "Unknown"
            },
            {
                "id": 398234,
                "title": "binary-search-solution-with-c-nlogn-clear-and-explanation",
                "content": "My solution is inspired by greedy method.Below is the step how l solve this problem.\\n\\n`example:[0,8,4,12,2,10,6]`\\n\\n**Solution:**\\n```\\n[0]\\n[0,8]\\n[0.4]  // [0,4] is better than [0,8] for long increasing,because it skips less numbers.\\n[0,4,12]\\n[0,2] [0,4,12]  // when 2 comes in, we realize [0,2] is better than previous [0,4]. but the length of [0,2] is smaller than [0,4,12]. \\n...//but we still keep it for next time maybe will become better.\\n..\\n.\\n```\\n... when I keep doing this,I realize I will get many arrays, then find the max length one from them.\\n\\n**Improve:**\\n```\\n[0]\\n[0,8]\\n[0,4]\\n[0,2,12] // when 2 comes in, I just replace 4 with 2, so I no need to create a new array to save[0,2] again.\\n//but in fact, we don\\'t have 0 ,2,12 sequence in the array, but who cares. the key point is the length and last number.when we append value, we just compare with last number.(tricky part!!!!)\\n```\\n\\n**Rules:**\\n```\\n1.if it is bigger than last one, then we append it at the end.\\n2.if it is smaller or equal than last one, then we replace it in the sorted result.\\n```\\n\\n**Code:**\\n```\\nfunc lengthOfLIS(nums []int) int {\\n    if len(nums) == 0{\\n        return 0\\n    }\\n    \\n    res :=[]int{nums[0]}\\n    \\n    for _,v:=range nums{\\n        if v>res[len(res)-1]{\\n            res=append(res,v)\\n        }else{\\n            i:=binarySearch(res,v)\\n            res[i]=v\\n        }\\n    }\\n    \\n    return len(res)\\n}\\n\\nfunc binarySearch(source []int,target int)int{\\n    l:=0\\n    r:=len(source)-1\\n    \\n    for l<=r {\\n        m:=l+(r-l)/2\\n        \\n        if source[m]>=target{\\n            r = m-1\\n        }else{\\n            l=m+1\\n        }\\n    }\\n    \\n    return l\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n[0]\\n[0,8]\\n[0.4]  // [0,4] is better than [0,8] for long increasing,because it skips less numbers.\\n[0,4,12]\\n[0,2] [0,4,12]  // when 2 comes in, we realize [0,2] is better than previous [0,4]. but the length of [0,2] is smaller than [0,4,12]. \\n...//but we still keep it for next time maybe will become better.\\n..\\n.\\n```\n```\\n[0]\\n[0,8]\\n[0,4]\\n[0,2,12] // when 2 comes in, I just replace 4 with 2, so I no need to create a new array to save[0,2] again.\\n//but in fact, we don\\'t have 0 ,2,12 sequence in the array, but who cares. the key point is the length and last number.when we append value, we just compare with last number.(tricky part!!!!)\\n```\n```\\n1.if it is bigger than last one, then we append it at the end.\\n2.if it is smaller or equal than last one, then we replace it in the sorted result.\\n```\n```\\nfunc lengthOfLIS(nums []int) int {\\n    if len(nums) == 0{\\n        return 0\\n    }\\n    \\n    res :=[]int{nums[0]}\\n    \\n    for _,v:=range nums{\\n        if v>res[len(res)-1]{\\n            res=append(res,v)\\n        }else{\\n            i:=binarySearch(res,v)\\n            res[i]=v\\n        }\\n    }\\n    \\n    return len(res)\\n}\\n\\nfunc binarySearch(source []int,target int)int{\\n    l:=0\\n    r:=len(source)-1\\n    \\n    for l<=r {\\n        m:=l+(r-l)/2\\n        \\n        if source[m]>=target{\\n            r = m-1\\n        }else{\\n            l=m+1\\n        }\\n    }\\n    \\n    return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387332,
                "title": "python-solution-20ms-replacement-version-of-insertion-sort",
                "content": "Seems like not many people fully grasp the trick of this problem, which is simply the replacement version of insertion sort i.e. replace instead of insert, refer to the comment in the code below:\\n```\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        res = [nums[0]]\\n        for num in nums:\\n            if num <= res[0]: res[0] = num\\n            elif num > res[-1]: res.append(num)\\n            else:\\n                indx = self.binarysearch(res, 0, len(res), num)\\n                res[indx] = num   # in insertion sort you use insert(), here you simply replace it\\n        return len(res)\\n\\n    def binarysearch(self, nums, l, r, target):\\n        while l < r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target: l = mid + 1\\n            else: r = mid\\n        return l\\n```\\n\\nthe code can be shortened using the built-in bisect method, which can be easily adapted to solve Problem 354 Russian Doll Envelopes (https://leetcode.com/problems/russian-doll-envelopes/discuss/183277/Python-6-lines-bisect-solution)\\n```\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        res = []\\n        for num in nums:\\n            indx = bisect.bisect_left(res, num)\\n            if indx == len(res): res.append(num)\\n            else: res[indx] = num\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        res = [nums[0]]\\n        for num in nums:\\n            if num <= res[0]: res[0] = num\\n            elif num > res[-1]: res.append(num)\\n            else:\\n                indx = self.binarysearch(res, 0, len(res), num)\\n                res[indx] = num   # in insertion sort you use insert(), here you simply replace it\\n        return len(res)\\n\\n    def binarysearch(self, nums, l, r, target):\\n        while l < r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target: l = mid + 1\\n            else: r = mid\\n        return l\\n```\n```\\n    def lengthOfLIS(self, nums):\\n        if not nums: return 0\\n        res = []\\n        for num in nums:\\n            indx = bisect.bisect_left(res, num)\\n            if indx == len(res): res.append(num)\\n            else: res[indx] = num\\n        return len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 204367,
                "title": "python-bottom-up-dynamic-programming-solution-with-explanation",
                "content": "The subproblem of this DP question is: at index i, what is the longest subset up to and including nums[i]?\\n\\nDivide this problem into subproblems of nums[:1], nums[:2], nums[:3], \\u2026, nums[:len(nums)] and cache the solution of each subproblem into array, say \\u201Cres\\u201D.\\n\\nTo fill res[i], we must look at nums[0] to nums[i-1] and compare to nums[i]. As long as nums[j] (where 0 <= j < i) is less than nums[i], we need to consider res[j] when calculating res[i]. In fact, we need to find the greatest res[j] (where 0 <= j < i and nums[j] < nums[i]). Once we have that, add 1 to it. Now we have res[i].\\n\\nexample:\\nnums = [8,2,3,9,1]\\nres     = [1,1,2,3,1]\\nmax(res) = 3 = solution\\n\\nnote that 8-9 is technically an increasing subsequence at i=3, but we know 2-3-9 is the longer increasing subsequence. That is why at every index i we must look at res[j] from j=0 to j=i-1, to make sure we get the longest previous subsequence. Hence O(n * n) = O(n^2)\\n\\n```\\ndef lengthOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 1: return 0\\n        \\n        res = [0 for i in range(len(nums))]\\n        res[0] = 1\\n        longest = res[0]\\n        \\n        for i in range(1, len(nums)):\\n            longestPrevious = 0\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    longestPrevious = max(longestPrevious, res[j])\\n                \\n            res[i] = 1 + longestPrevious\\n            longest = max(longest, res[i])\\n        \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\ndef lengthOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 1: return 0\\n        \\n        res = [0 for i in range(len(nums))]\\n        res[0] = 1\\n        longest = res[0]\\n        \\n        for i in range(1, len(nums)):\\n            longestPrevious = 0\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    longestPrevious = max(longestPrevious, res[j])\\n                \\n            res[i] = 1 + longestPrevious\\n            longest = max(longest, res[i])\\n        \\n        return longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 129963,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return lengthOfLISFrom(nums, 0, -1);\\n    }\\n    \\n    private int lengthOfLISFrom(int[] nums, int currentIndex, int previousIndex) {\\n        if (currentIndex == nums.length)\\n            return 0;\\n        \\n        int lis = 0;\\n        if (previousIndex == -1 \\n            || nums[currentIndex] > nums[previousIndex]) {\\n            lis = 1 + lengthOfLISFrom(nums, currentIndex + 1, currentIndex);\\n        }\\n            \\n        lis = Math.max(lis, lengthOfLISFrom(nums, currentIndex + 1, previousIndex));\\n        return lis;\\n    }\\n}\\n```\\n### Top-down DP\\nTo overcome overlapping subproblems, we apply memoization:\\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new Integer[nums.length][nums.length + 1];\\n        return lengthOfLISFrom(nums, 0, -1);\\n    }\\n    \\n    private int lengthOfLISFrom(int[] nums, int currentIndex, int previousIndex) {\\n        if (currentIndex == nums.length)\\n            return 0;\\n        \\n        if (dp[previousIndex + 1][currentIndex] != null)\\n            return dp[previousIndex + 1][currentIndex];\\n        \\n        int lis = 0;\\n        if (previousIndex == -1 \\n            || nums[currentIndex] > nums[previousIndex]) {\\n            lis = 1 + lengthOfLISFrom(nums, currentIndex + 1, currentIndex);\\n        }\\n            \\n        lis = Math.max(lis, lengthOfLISFrom(nums, currentIndex + 1, previousIndex));\\n\\n        return dp[previousIndex + 1][currentIndex] = lis;\\n    }\\n}\\n```\\n### Bottom-up DP\\nIf the number at `currentIndex` is bigger than the number at `previousIndex`, we increment the count for LIS up to the `currentIndex`.\\n\\nBut if there is a bigger LIS without including the number at `currentIndex`, we take that instead.\\n\\nSo we need to find all the increasing subsequences for the number at index `i` and pick the longest one.\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n\\n        int maxLength = 1;\\n        for (int i = 1; i < nums.length; i++) { \\n            dp[i] = 1; \\n            for (int j = 0; j < i; j++) { \\n                if (nums[i] > nums[j] && dp[i] <= dp[j]) {\\n                    dp[i] = dp[j] + 1;  \\n                    maxLength = Math.max(maxLength, dp[i]);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        return lengthOfLISFrom(nums, 0, -1);\\n    }\\n    \\n    private int lengthOfLISFrom(int[] nums, int currentIndex, int previousIndex) {\\n        if (currentIndex == nums.length)\\n            return 0;\\n        \\n        int lis = 0;\\n        if (previousIndex == -1 \\n            || nums[currentIndex] > nums[previousIndex]) {\\n            lis = 1 + lengthOfLISFrom(nums, currentIndex + 1, currentIndex);\\n        }\\n            \\n        lis = Math.max(lis, lengthOfLISFrom(nums, currentIndex + 1, previousIndex));\\n        return lis;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int lengthOfLIS(int[] nums) {\\n        dp = new Integer[nums.length][nums.length + 1];\\n        return lengthOfLISFrom(nums, 0, -1);\\n    }\\n    \\n    private int lengthOfLISFrom(int[] nums, int currentIndex, int previousIndex) {\\n        if (currentIndex == nums.length)\\n            return 0;\\n        \\n        if (dp[previousIndex + 1][currentIndex] != null)\\n            return dp[previousIndex + 1][currentIndex];\\n        \\n        int lis = 0;\\n        if (previousIndex == -1 \\n            || nums[currentIndex] > nums[previousIndex]) {\\n            lis = 1 + lengthOfLISFrom(nums, currentIndex + 1, currentIndex);\\n        }\\n            \\n        lis = Math.max(lis, lengthOfLISFrom(nums, currentIndex + 1, previousIndex));\\n\\n        return dp[previousIndex + 1][currentIndex] = lis;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n\\n        int maxLength = 1;\\n        for (int i = 1; i < nums.length; i++) { \\n            dp[i] = 1; \\n            for (int j = 0; j < i; j++) { \\n                if (nums[i] > nums[j] && dp[i] <= dp[j]) {\\n                    dp[i] = dp[j] + 1;  \\n                    maxLength = Math.max(maxLength, dp[i]);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74874,
                "title": "fixed-c-run-time-calculation-problem-in-oj",
                "content": "Two solutions below use the same approach and have O(n * log n) complexity. However, they produce radically different run-time: ~150-200 ms vs. 6 ms. \\n\\nThe first solution should be even faster as we do not have the overhead of BST. So, I ran tests using 100K sequences (increasing, random, and shuffled), and, in average, the first solution was 4 times faster than the the second one (not ~30 times slower as in OJ).\\n```\\nint lengthOfLIS(vector<int>& nums) \\n{\\n    vector<int> dp;\\n    for (auto n : nums)\\n    {\\n        auto it = lower_bound(begin(dp), end(dp), n);\\n        if (it == dp.end()) dp.push_back(n);\\n        else *it = n;\\n    }\\n    return dp.size(); // ~150-200 ms\\n}\\n```\\n```\\nint lengthOfLIS(vector<int>& nums) {\\n    set<int> s;\\n    for (auto n : nums) {\\n        auto res = s.insert(n);\\n        if (res.second && next(res.first, 1) != s.end()) s.erase(next(res.first, 1));\\n    }\\n    return s.size(); // 6 ms\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint lengthOfLIS(vector<int>& nums) \\n{\\n    vector<int> dp;\\n    for (auto n : nums)\\n    {\\n        auto it = lower_bound(begin(dp), end(dp), n);\\n        if (it == dp.end()) dp.push_back(n);\\n        else *it = n;\\n    }\\n    return dp.size(); // ~150-200 ms\\n}\\n```\n```\\nint lengthOfLIS(vector<int>& nums) {\\n    set<int> s;\\n    for (auto n : nums) {\\n        auto res = s.insert(n);\\n        if (res.second && next(res.first, 1) != s.end()) s.erase(next(res.first, 1));\\n    }\\n    return s.size(); // 6 ms\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74975,
                "title": "java-simple-and-easy-understanding-nlogn-solution",
                "content": "    public class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int[] res = new int[nums.length];\\n        int len = 0;\\n        res[len] = nums[0];\\n        len++;\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] < res[0]) {\\n                res[0] = nums[i];\\n            }\\n            else if(nums[i] > res[len - 1]) {\\n                res[len] = nums[i];\\n                len++;\\n            }\\n            else {\\n                int index = doBinarySearch(res, 0, len - 1, nums[i]);\\n                res[index] = nums[i];\\n            }\\n        }\\n        return len;\\n    }\\n    private int doBinarySearch(int[] nums, int start, int end, int target) {\\n        while(start + 1 < end) {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(nums[mid] < target) {\\n                start = mid;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        if(nums[start] == target) {\\n            return start;\\n        }\\n        else {\\n            return end;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 75014,
                "title": "o-n-logn-python-solution-with-binary-search",
                "content": "Idea: keep an array *best* that stores for each index *i* the lowest ending value of a subsequence with length *i+1*.\\n\\n - best[0] = lowest value found so far\\n - best[1] = lowest ending value of a subsequence with length 2 found so far\\n - best[2] = lowest ending value of a subsequence with length 3 found so far\\n\\nAnd so on\\n\\nIn the end, the elements of **best** will contain *one* of the longest subsequences. It's length is the answer of the problem.\\n\\nTo have an **O(n logn)** time complexity, for each of the **n** elements in the input array *nums*, we binary-search the element of **best** to be updated. \\n\\n*best* has at most **n** elements, eventually much less (worst case being an increasingly sorted input array), hence the **logn**.\\n\\nFor the example input *[10,9,2,5,3,7,101,18]*, *best* will be in the end *[2, 3, 7, 18]*, with length 4.\\n\\n\\n    class Solution(object):\\n        def lengthOfLIS(self, nums):\\n            if not nums:  return 0\\n            best = [nums[0]]\\n            for i in range(1, len(nums)):\\n                index = self.upperBound(best, nums[i], 0, len(best))\\n                if index == len(best): best.append(nums[i])\\n                else: best[index] = nums[i]\\n            return len(best)\\n\\n        # Return smallest index i such that array[i] >= target\\n        # or return end+1 if none (target > all array elements)\\n        def upperBound(self, array, target, start, end):\\n            if start >= end: return start\\n            m = (end+start)//2\\n            if array[m] >= target:\\n                if m == start or array[m-1] < target: return m\\n                return self.upperBound(array, target, start, m)\\n            return self.upperBound(array, target, m+1, end)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Idea: keep an array *best* that stores for each index *i* the lowest ending value of a subsequence with length *i+1*.\\n\\n - best[0] = lowest value found so far\\n - best[1] = lowest ending value of a subsequence with length 2 found so far\\n - best[2] = lowest ending value of a subsequence with length 3 found so far\\n\\nAnd so on\\n\\nIn the end, the elements of **best** will contain *one* of the longest subsequences. It's length is the answer of the problem.\\n\\nTo have an **O(n logn)** time complexity, for each of the **n** elements in the input array *nums*, we binary-search the element of **best** to be updated. \\n\\n*best* has at most **n** elements, eventually much less (worst case being an increasingly sorted input array), hence the **logn**.\\n\\nFor the example input *[10,9,2,5,3,7,101,18]*, *best* will be in the end *[2, 3, 7, 18]*, with length 4.\\n\\n\\n    class Solution(object):\\n        def lengthOfLIS(self, nums):\\n            if not nums:  return 0\\n            best = [nums[0]]\\n            for i in range(1, len(nums)):\\n                index = self.upperBound(best, nums[i], 0, len(best))\\n                if index == len(best): best.append(nums[i])\\n                else: best[index] = nums[i]\\n            return len(best)\\n\\n        # Return smallest index i such that array[i] >= target\\n        # or return end+1 if none (target > all array elements)\\n        def upperBound(self, array, target, start, end):\\n            if start >= end: return start\\n            m = (end+start)//2\\n            if array[m] >= target:\\n                if m == start or array[m-1] < target: return m\\n                return self.upperBound(array, target, start, m)\\n            return self.upperBound(array, target, m+1, end)",
                "codeTag": "Java"
            },
            {
                "id": 3331109,
                "title": "all-4-methods-code-in-python",
                "content": "\\n# Top Down DP or Memoization \\n```\\nTime Complexity = O(n^2): Because for ever i we do (i-1) checks. \\nThe total number checks become 1+2+3...+n-1 = n*(n+1)/2 = O(n^2) \\n```\\n```\\nclass Solution:\\n    def rec(self,nums,n ):\\n        if( self.dp[n] != 0  ): return self.dp[n]\\n        ans = 1\\n        for i in range(0,n):\\n            if( nums[i] < nums[n]): \\n                ans = max(ans,1+self.rec(nums,i) )\\n        self.dp[n] = ans \\n        return ans\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        res = 0;\\n        self.dp = [0 for _ in range(0,len(nums))]\\n        for i in range(0,len(nums)): \\n            self.rec(nums,i)\\n        for i in range(0,len(nums)): \\n            res = max(res,self.dp[i]);\\n\\n        return res \\n```\\n\\n# Bottom Up DP \\n\\n```\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        n ,res= len(nums),0\\n        dp = [ 1 for _ in range(0,n)]\\n        \\n        for i in range(0,n):\\n            for j in range(0,i):\\n                if(nums[j] < nums[i] ):\\n                    dp[i] = max(dp[i],1+dp[j]);\\n            if(dp[i]>res): res = dp[i] \\n\\n        return res\\n```\\n\\n#  Without BS\\n```\\nT(n) = O(n*k) where k is lenghoflis \\n```\\n\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n    lis = []\\n    res = 1;\\n    for i in range(0,len(nums)):\\n        j = 0\\n        while(j<len(lis)):\\n            if(lis[j] >= nums[i]): break;\\n            j += 1\\n        if(j<len(lis)): lis[j] = nums[i]\\n        else:lis.append(nums[i])\\n        if(len(lis)>res):\\n            res = len(lis)\\n    return res\\n```\\n\\n# With binary Search (Fastest Solution)\\n```\\nT(n) = O(n*log(k)) where k is lengthoflis \\n```\\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n    lis = []\\n    res = 1;\\n    for i in range(0,len(nums)):\\n        j = bisect.bisect_left(lis,nums[i]);\\n        if(j<len(lis)): lis[j] = nums[i]\\n        else:lis.append(nums[i])\\n        if(len(lis)>res):\\n            res = len(lis)\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nTime Complexity = O(n^2): Because for ever i we do (i-1) checks. \\nThe total number checks become 1+2+3...+n-1 = n*(n+1)/2 = O(n^2) \\n```\n```\\nclass Solution:\\n    def rec(self,nums,n ):\\n        if( self.dp[n] != 0  ): return self.dp[n]\\n        ans = 1\\n        for i in range(0,n):\\n            if( nums[i] < nums[n]): \\n                ans = max(ans,1+self.rec(nums,i) )\\n        self.dp[n] = ans \\n        return ans\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        res = 0;\\n        self.dp = [0 for _ in range(0,len(nums))]\\n        for i in range(0,len(nums)): \\n            self.rec(nums,i)\\n        for i in range(0,len(nums)): \\n            res = max(res,self.dp[i]);\\n\\n        return res \\n```\n```\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        n ,res= len(nums),0\\n        dp = [ 1 for _ in range(0,n)]\\n        \\n        for i in range(0,n):\\n            for j in range(0,i):\\n                if(nums[j] < nums[i] ):\\n                    dp[i] = max(dp[i],1+dp[j]);\\n            if(dp[i]>res): res = dp[i] \\n\\n        return res\\n```\n```\\nT(n) = O(n*k) where k is lenghoflis \\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n    lis = []\\n    res = 1;\\n    for i in range(0,len(nums)):\\n        j = 0\\n        while(j<len(lis)):\\n            if(lis[j] >= nums[i]): break;\\n            j += 1\\n        if(j<len(lis)): lis[j] = nums[i]\\n        else:lis.append(nums[i])\\n        if(len(lis)>res):\\n            res = len(lis)\\n    return res\\n```\n```\\nT(n) = O(n*log(k)) where k is lengthoflis \\n```\n```\\ndef lengthOfLIS(self, nums: List[int]) -> int:\\n    lis = []\\n    res = 1;\\n    for i in range(0,len(nums)):\\n        j = bisect.bisect_left(lis,nums[i]);\\n        if(j<len(lis)): lis[j] = nums[i]\\n        else:lis.append(nums[i])\\n        if(len(lis)>res):\\n            res = len(lis)\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216021,
                "title": "c-easy-and-simple-striver-s-memoization-approach-made-even-easy-and-simple-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Well this approach is simple and clear also inspired from striver\\'s dp series\\n\\n### if we can get recursive solution we can memorise it very easily so lets focus on that \\n\\n### Here for every element on each index we have two options we can either take it or leave it ,\\n### if we pick it - curr index becomes prev and curr index moves to next element\\n### if we dont pick it - prev remains as it is and we move curr index\\n### but we have a constraint that it has to be increasing subsequence whose condition you find in else if staement where the  current element if picked it must greater than previous element\\n\\n### it is pretty simple and straight foward right but here it is twisted slightly where we have and extra condition where prev and curr_index are on same element \\n ### in that case,\\n### if we pick it the current index becomes prev and we move foward to next element (no change)\\n\\n### but if we dont pick we have to move curr and prev index to next bcz we still dont have prev element (this is a big catch) just think of a scenario that  we can start our subsequence from any index not neccesarily from first index and we have no prev element if we dont pick the starting element so just to keep it sync with current index we increment it until an element is picked.\\n### so in final if curr index== prev index \\n### we have not yet picked any element.\\n\\n#### hope you find this helpful and this is my first solution post on leetcode\\n\\n### Thank You and Upvote if u find this helpful.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return f(0,0,n,nums,dp);\\n    }\\n\\n  int f(int i,int prev,int n,vector<int>& nums,vector<vector<int>>&dp)\\n  {\\n      if(i==n)\\n      {\\n          return 0;\\n      }\\n      if(dp[i][prev]!=-1){return dp[i][prev];}\\n      \\n      int take=INT_MIN;\\n      int not_take=0+f(i+1,prev,n,nums,dp);\\n      if(prev==i){\\n       take=1+f(i+1,i,n,nums,dp);\\n       not_take=0+f(i+1,i+1,n,nums,dp);\\n      }\\n      else if(nums[i]>nums[prev])\\n      {\\n        take=1+f(i+1,i,n,nums,dp);\\n      }\\n      \\n      return dp[i][prev]=max(take,not_take);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return f(0,0,n,nums,dp);\\n    }\\n\\n  int f(int i,int prev,int n,vector<int>& nums,vector<vector<int>>&dp)\\n  {\\n      if(i==n)\\n      {\\n          return 0;\\n      }\\n      if(dp[i][prev]!=-1){return dp[i][prev];}\\n      \\n      int take=INT_MIN;\\n      int not_take=0+f(i+1,prev,n,nums,dp);\\n      if(prev==i){\\n       take=1+f(i+1,i,n,nums,dp);\\n       not_take=0+f(i+1,i+1,n,nums,dp);\\n      }\\n      else if(nums[i]>nums[prev])\\n      {\\n        take=1+f(i+1,i,n,nums,dp);\\n      }\\n      \\n      return dp[i][prev]=max(take,not_take);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824286,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] x = new int[n + 1];\\n        x[1] = nums[0];\\n        int size = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i] > x[size]) {\\n                x[++size] = nums[i];\\n            } else {\\n                int left = 1, right = size;\\n                while (left < right) {\\n                    int mid = (left + right) >> 1;\\n                    if (x[mid] >= nums[i]) {\\n                        right = mid;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                int p = x[left] >= nums[i] ? left : 1;\\n                x[p] = nums[i];\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] x = new int[n + 1];\\n        x[1] = nums[0];\\n        int size = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i] > x[size]) {\\n                x[++size] = nums[i];\\n            } else {\\n                int left = 1, right = size;\\n                while (left < right) {\\n                    int mid = (left + right) >> 1;\\n                    if (x[mid] >= nums[i]) {\\n                        right = mid;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                int p = x[left] >= nums[i] ? left : 1;\\n                x[p] = nums[i];\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794736,
                "title": "dynamic-programming-2-approaches-lcs-approach-using-set-and-sorting-and-1d-dp-approach",
                "content": "# Intuition\\nSOLUTION 1 Approach\\nThe logic is try to find the max common subsequence till an index i in the nums and store it in the result array\\n\\nSOLUTION 2 Approach\\nFinding the lcs with the unique increasing copy of array values gives us the desired result. Hence we will use set to elimiate duplicates since we wamt the increasing subsequence only. Sorting inorder to get increasing subsequence.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2) (for both the approached since both use dp)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: SOLUTION 1 - O(n)\\n                    SOLUTION 2 - O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n# SOLUTION 1 using the normal dp logic\\n    public int lengthOfLIS(int[] nums) {\\n        // The logic is try to find the max common subsequence till an index i in the nums and store it in the result array\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        result[0] =1;\\n//         the if you are on i traverse till the beginning and check if current number is greater the the number and if yes then add the subsequence count \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n                if(nums[i]>nums[j])\\n                    result[i] = Math.max(result[j]+1,result[i]);\\n                else\\n                    result[i]=Math.max(result[i],1);\\n        }\\n        int max=1;\\n        int i=0;\\n//         the result array has the max count for an index i hence for the whole array return the max count in the end.\\n        for(int k:result)\\n            max=Math.max(result[i++],max);\\n        \\n        return max;\\n    }\\n\\n\\n# SOLUTION 2\\n    public int lengthOfLIS(int[] nums) {\\n<!-- Using set to elimate duplicates -->\\n        Set<Integer> set = new HashSet<>();\\n        for(int ele:nums)\\n        set.add(ele);\\n        \\n\\n        int[] nums1 =new int[set.size()];\\n        int i=0;\\n        for(int ele:set)\\n            nums1[i++]=ele;\\n\\n<!-- sorting array to get the increasing subsequence -->\\n        Arrays.sort(nums1);\\n\\n<!-- finding the lcs to get the desired result -->\\n        return LCS(nums,nums1);\\n    }\\n\\n    int LCS(int[] nums, int[] nums1)\\n    {\\n        int m= nums.length;\\n        int n = nums1.length;\\n        int[][] dp= new int[m+1][n+1];\\n\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(nums[i-1]==nums1[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else\\n\\n                dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n//     Similar Problems: 300, 673, 368, 1105\\n// For more other topics similar problems, check out my GitHub.\\n// It took me a lots of time to make the solution. Becuase I want to help others like me.\\n// Please give me a star if you like it. Means a lot to me.\\n// https://github.com/wuduhren/leetcode-python\\n    \\n// longest-string-chain\\n// https://leetcode.com/problems/longest-string-chain/\\n// largest-divisible-subset\\n// https://leetcode.com/problems/largest-divisible-subset/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n# SOLUTION 1 using the normal dp logic\\n    public int lengthOfLIS(int[] nums) {\\n        // The logic is try to find the max common subsequence till an index i in the nums and store it in the result array\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        result[0] =1;\\n//         the if you are on i traverse till the beginning and check if current number is greater the the number and if yes then add the subsequence count \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n                if(nums[i]>nums[j])\\n                    result[i] = Math.max(result[j]+1,result[i]);\\n                else\\n                    result[i]=Math.max(result[i],1);\\n        }\\n        int max=1;\\n        int i=0;\\n//         the result array has the max count for an index i hence for the whole array return the max count in the end.\\n        for(int k:result)\\n            max=Math.max(result[i++],max);\\n        \\n        return max;\\n    }\\n\\n\\n# SOLUTION 2\\n    public int lengthOfLIS(int[] nums) {\\n<!-- Using set to elimate duplicates -->\\n        Set<Integer> set = new HashSet<>();\\n        for(int ele:nums)\\n        set.add(ele);\\n        \\n\\n        int[] nums1 =new int[set.size()];\\n        int i=0;\\n        for(int ele:set)\\n            nums1[i++]=ele;\\n\\n<!-- sorting array to get the increasing subsequence -->\\n        Arrays.sort(nums1);\\n\\n<!-- finding the lcs to get the desired result -->\\n        return LCS(nums,nums1);\\n    }\\n\\n    int LCS(int[] nums, int[] nums1)\\n    {\\n        int m= nums.length;\\n        int n = nums1.length;\\n        int[][] dp= new int[m+1][n+1];\\n\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(nums[i-1]==nums1[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else\\n\\n                dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n//     Similar Problems: 300, 673, 368, 1105\\n// For more other topics similar problems, check out my GitHub.\\n// It took me a lots of time to make the solution. Becuase I want to help others like me.\\n// Please give me a star if you like it. Means a lot to me.\\n// https://github.com/wuduhren/leetcode-python\\n    \\n// longest-string-chain\\n// https://leetcode.com/problems/longest-string-chain/\\n// largest-divisible-subset\\n// https://leetcode.com/problems/largest-divisible-subset/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603998,
                "title": "java-recursion-with-proper-intuition",
                "content": "**Intuition for DP question.** \\n1) We can see there can be n number of subsequences. So recursion is the way.\\n2) Then question is asking for Longest ( which is the optimal ask) so DP. \\n \\n**Understanding Recursion**\\n\\n- The question breaks down to a very familiar pattern of choose/not-choose. So keeping that in mind and following the question\\'s restriction which is **longest strictly increasing subsequence**\\n- If the condition is not valid i.e, the nums[index+1]th value is not greater to nums[index] then just move forward without choosing and also without increasing our count. \\n- Other part comes if the condition is actually valid. Even then we can have two options to choose or not choose. WHY? Consider this example [0,1,0,3,2,3], here we can have multiple subsequences [0,1,3], [0,1,2,3] and so on. \\n\\n``` class Solution {\\n    int count1, count2;\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE);\\n    }\\n    \\n    int recursion(int[] nums, int index, int prev) {\\n\\t// prev parameter we will be using to keep value of (index-1)th element\\n        if(index >= nums.length) return 0;\\n        \\n        if(nums[index] > prev) { /* when the condition matches either choose or not choose\\n\\t\\twhile choosing increase the count and change the prev to current value */\\n            return Math.max(1 + recursion( nums, index + 1, nums[index]), recursion(nums, index + 1, prev));\\n        }\\n        /* If the condition does not match then just move forward without choosing */\\n        return recursion(nums, index + 1, prev);\\n        \\n    }\\n\\t\\n\\tThis will give TLE. So we need to memoize this code ->DP bottom up -> check for any space optimization if possible. \\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int count1, count2;\\n    public int lengthOfLIS(int[] nums) {\\n        \\n        return recursion(nums, 0, Integer.MIN_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2397829,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2600][2600];\\n    int helper(vector<int>& arr, int i,int prev) {\\n        if(i>=arr.size())return 0;\\n        if(dp[i][prev]!=-1)return dp[i][prev];\\n        if(prev!=2550&&arr[i]<=arr[prev])return dp[i][prev]=helper(arr,i+1,prev);\\n        return dp[i][prev]=max(helper(arr,i+1,prev),1+helper(arr,i+1,i));\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,2550);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2600][2600];\\n    int helper(vector<int>& arr, int i,int prev) {\\n        if(i>=arr.size())return 0;\\n        if(dp[i][prev]!=-1)return dp[i][prev];\\n        if(prev!=2550&&arr[i]<=arr[prev])return dp[i][prev]=helper(arr,i+1,prev);\\n        return dp[i][prev]=max(helper(arr,i+1,prev),1+helper(arr,i+1,i));\\n    }\\n    int lengthOfLIS(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,2550);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396234,
                "title": "c-binary-search-short-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint ceil(vector<int>&v, int l, int r, int x){\\n        \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            \\n            if(v[mid]>=x) r=mid;\\n            else l=mid+1;\\n        }\\n        return r;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>v[v.size()-1]){\\n                v.push_back(nums[i]);\\n            }\\n            else{\\n                int idx=ceil(v,0,v.size()-1,nums[i]);\\n                v[idx]=nums[i];\\n            }\\n        }\\n        return v.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint ceil(vector<int>&v, int l, int r, int x){\\n        \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            \\n            if(v[mid]>=x) r=mid;\\n            else l=mid+1;\\n        }\\n        return r;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>v[v.size()-1]){\\n                v.push_back(nums[i]);\\n            }\\n            else{\\n                int idx=ceil(v,0,v.size()-1,nums[i]);\\n                v[idx]=nums[i];\\n            }\\n        }\\n        return v.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2335614,
                "title": "c-binary-search-easytounderstand-commented-o-nlogn",
                "content": "#  Please UP Vote if this solution helps you\\n\\n**Explanation**\\n\\nIn this apparoach we generally does not create a LIS but we create a temp vector which store all the elements which have to present in LIS then we return the length of that temp vector \\n\\n**Algo**\\n\\n1 : Create a temprorary vector temp to store the elements of LIS\\n2 : push nums[0] into vector\\n3 : Traverse nums from 1 to n-1\\n4 : In loop check if (num[i] greater than temp.back)\\n     push nums[i] in vector\\n5 : else by binary search find the place for nums[i] in temp vector and replace it by nums[i]\\n\\n6 : After completion of loop then return temp.size();\\n\\n\\n```\\n int lengthOfLIS(vector<int>& nums) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        if(n == 1)\\n        {\\n            return 1;\\n        }  \\n        vector<int> temp;   //The temp vector only carry the elements of LIS and not the LIS, Its only finding length\\n        temp.push_back(nums[0]);\\n        \\n        for(int i = 1;i<n;i++)\\n        {\\n            if(nums[i]>temp.back())\\n            {\\n                temp.push_back(nums[i]);\\n            }\\n            else\\n            {   //If the element is not greater than temp.back() then we simply place at equal element in temp or just next greater element \\n                int idx = lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                temp[idx] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n int lengthOfLIS(vector<int>& nums) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        if(n == 1)\\n        {\\n            return 1;\\n        }  \\n        vector<int> temp;   //The temp vector only carry the elements of LIS and not the LIS, Its only finding length\\n        temp.push_back(nums[0]);\\n        \\n        for(int i = 1;i<n;i++)\\n        {\\n            if(nums[i]>temp.back())\\n            {\\n                temp.push_back(nums[i]);\\n            }\\n            else\\n            {   //If the element is not greater than temp.back() then we simply place at equal element in temp or just next greater element \\n                int idx = lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                temp[idx] = nums[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181324,
                "title": "java-recursion-to-tabular-dp",
                "content": "Credits to Aditya Verma\\'s DP series which has helped me in being comfortable with DP concepts. \\nThis DP problem can be better understood by first writing the Recursive solution then deriving tabular approach from recursive solution. \\nThe recursive solution applies brute force approach to break down problem into subproblems. \\nJust like knapsack we can start tackling the array from the last element. We will first write the function definition of the recursive function. I have taken it as solve2(). Since the question asks to return length of longest increasing subsequence I take the return type of function as int. Next I want to know the parameters, obviously the nums array will be there and the element I am currently tackling will be there as nums and int i respectively. But note that I need another parameter to decisively tackle the current element as part of LIS or not and that will be the prev element for the LIS. This because based on prev element I will decided if the current element will be part of LIS or not. If this prev element is not taken then I will have no way to judge or tackle the current element. Hence based on this my current recursive definition will take 3 parameters, nums, int i and int prev [index of previous element part of LIS. It will be equal to nums.length for 1st iteration].\\nNext I derive the base condition. The base condition will be derived for smallest valid input. Which in our case will be when array has 0 element or when we are tackling i == 0. The LIS for array with 0 elements = 0 hence base condition is returning 0.\\nNext we come up with our choice diagram which is essentially the rest of the code.\\nSince our current element will have following choices : if element < num[prev] then we have two choices either take the element in LIS or not take element in LIS. Both will result in processing of the current element and us moving on to next element which will be i-1. Now for 1st choice when we take the element, the LIS will increase in size by 1 as well as the previous will get updated to current element. \\nFor 2nd choice when element is not picked in LIS, the previous remains the same. \\nThis choice diagram is denoted by code:\\n```\\nif(prev == nums.length || nums[i-1] < nums[prev])\\n        {\\n            return Math.max(solve2(nums, i-1, prev), solve2(nums,  i-1, i-1) + 1);\\n        }\\n```\\nNote we have another condition prev == nums.length, for the 1st iteration.\\nNow comes the case if the current element being tackled is either equal to previous element or greater than, in this case the element does not forms part of LIS in any condition hence we have just one choice to not take the element and prev remaining intact. This is denoted by this part of code:\\n```\\nelse\\n        {\\n            return solve2(nums, i-1, prev);\\n        }\\n```\\nThats it. This forms the recursive solution.\\n```\\npublic int lengthOfLIS(int[] nums) {\\n        //return solve(nums); \\n        return solve2(nums, nums.length, nums.length);\\n    }\\n\\n public int solve2(int nums[], int i, int prev)\\n    {\\n        if(i <= 0)\\n        {\\n            return 0;\\n        }\\n        if(prev == nums.length || nums[i-1] < nums[prev])\\n        {\\n            return Math.max(solve2(nums, i-1, prev), solve2(nums,  i-1, i-1) + 1);\\n        }\\n        else\\n        {\\n            return solve2(nums, i-1, prev);\\n        }\\n    }\\n```\\n\\nOnce you have the recursive solution the tabular approach is straight forward.\\nStep 1. you create a matrix of dimension equal to variables that are changing in the recursion. Since in recursion only 2 variables are changing, i and prev, we will have a 2d matrix. The maximum value of i is nums.length and of prev [which is an index of previous element of LIS] is nums.length. So you make a matrix of length = nums.length+1.\\nStep 2. You initialize for i == 0 t[i][j] = 0. As this was the base condition, read the recursive code.\\nStep 3. Apply two loops around the rest of the code and convert prev -> j and i -> i and change solve() to t[i][j] as shown here: \\n```\\nfor(int i =1; i< nums.length+1; i++)\\n        {\\n            for(int j =1; j<nums.length+1; j++)\\n            {\\n                if(j == nums.length || nums[i-1] < nums[j])\\n                {\\n                    t[i][j] = Math.max(t[i-1][j], t[i-1][i-1]+1);\\n                }\\n                else\\n                    t[i][j] = t[i-1][j];\\n                \\n            }\\n        }\\n```\\n. If you see deeply you will see that the equation is same as recursive equation except for step 3 mentioned changes.\\n\\nEntire code DP tabular code is:\\n```\\npublic int lengthOfLIS(int[] nums) {\\n        //return solve(nums); \\n        return solve2(nums, nums.length, nums.length);\\n    }\\n    \\n    public int solve(int nums[])\\n    {\\n        int t[][] = new int[nums.length+1][nums.length+1];\\n        for(int i =0; i< nums.length+1; i++)\\n        {\\n            for(int j =0; j<nums.length+1; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i =1; i< nums.length+1; i++)\\n        {\\n            for(int j =1; j<nums.length+1; j++)\\n            {\\n                if(j == nums.length || nums[i-1] < nums[j])\\n                {\\n                    t[i][j] = Math.max(t[i-1][j], t[i-1][i-1]+1);\\n                }\\n                else\\n                    t[i][j] = t[i-1][j];\\n                \\n            }\\n        }\\n        \\n        return t[nums.length][nums.length];\\n    }\\n    \\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nif(prev == nums.length || nums[i-1] < nums[prev])\\n        {\\n            return Math.max(solve2(nums, i-1, prev), solve2(nums,  i-1, i-1) + 1);\\n        }\\n```\n```\\nelse\\n        {\\n            return solve2(nums, i-1, prev);\\n        }\\n```\n```\\npublic int lengthOfLIS(int[] nums) {\\n        //return solve(nums); \\n        return solve2(nums, nums.length, nums.length);\\n    }\\n\\n public int solve2(int nums[], int i, int prev)\\n    {\\n        if(i <= 0)\\n        {\\n            return 0;\\n        }\\n        if(prev == nums.length || nums[i-1] < nums[prev])\\n        {\\n            return Math.max(solve2(nums, i-1, prev), solve2(nums,  i-1, i-1) + 1);\\n        }\\n        else\\n        {\\n            return solve2(nums, i-1, prev);\\n        }\\n    }\\n```\n```\\nfor(int i =1; i< nums.length+1; i++)\\n        {\\n            for(int j =1; j<nums.length+1; j++)\\n            {\\n                if(j == nums.length || nums[i-1] < nums[j])\\n                {\\n                    t[i][j] = Math.max(t[i-1][j], t[i-1][i-1]+1);\\n                }\\n                else\\n                    t[i][j] = t[i-1][j];\\n                \\n            }\\n        }\\n```\n```\\npublic int lengthOfLIS(int[] nums) {\\n        //return solve(nums); \\n        return solve2(nums, nums.length, nums.length);\\n    }\\n    \\n    public int solve(int nums[])\\n    {\\n        int t[][] = new int[nums.length+1][nums.length+1];\\n        for(int i =0; i< nums.length+1; i++)\\n        {\\n            for(int j =0; j<nums.length+1; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i =1; i< nums.length+1; i++)\\n        {\\n            for(int j =1; j<nums.length+1; j++)\\n            {\\n                if(j == nums.length || nums[i-1] < nums[j])\\n                {\\n                    t[i][j] = Math.max(t[i-1][j], t[i-1][i-1]+1);\\n                }\\n                else\\n                    t[i][j] = t[i-1][j];\\n                \\n            }\\n        }\\n        \\n        return t[nums.length][nums.length];\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1833677,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1570341,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1575443,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1570655,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1575557,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1567950,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569062,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569843,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1568057,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569585,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1833677,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1570341,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1575443,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1570655,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1575557,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1567950,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569062,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569843,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1568057,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1569585,
                "content": [
                    {
                        "username": "johnfredricks",
                        "content": "This shit is hard as shit"
                    },
                    {
                        "username": "user6849M",
                        "content": "Test case [4,10,4,3,8,9] \\nmy output 3 (4 8 9 / 3 8 9) but its failing as expected result is 4 how?"
                    },
                    {
                        "username": "ishowstruggle",
                        "content": "[@priyank9641](/priyank9641) [0,1,2,3] now count"
                    },
                    {
                        "username": "Adithyang",
                        "content": "coz u need to also resturn the equal element that is 4 4 8 9 "
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@priyank9641](/priyank9641) [0, 1, 2, 3]"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nhows the expected output 4 here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@pant_harshit007](/pant_harshit007) The question calls for a longest STRICTLY increasing subsequence. 3 is the correct answer here."
                    },
                    {
                        "username": "sans19",
                        "content": "no its showing expected result as 3 only"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "[@kanishkmewal](/kanishkmewal)  no i guess not because in test case 7777777 they pass result as 1\\n"
                    },
                    {
                        "username": "RainbowVenom",
                        "content": "i guess it is 4 4 8 9"
                    },
                    {
                        "username": "rwang778",
                        "content": "I think the hardest part of dynamic programming here is the initialization of dp array. I just set dp[0] to 1... damn"
                    },
                    {
                        "username": "bparanj",
                        "content": "The initialization of the DP array can indeed be tricky in dynamic programming problems because it forms the base of your problem solution.\\n\\nIn this problem, the DP array `dp` is used to keep track of the length of the longest increasing subsequence ending at each index `i`. \\n\\nYou\\'ve correctly initialized `dp[0]` to `1`, because the length of the longest increasing subsequence ending at the first element is always `1` (the element itself). \\n\\nThe rest of the array should also be initialized to `1` because at minimum, each element itself can be a subsequence of length `1`. So initializing the DP array as:\\n\\n```python\\ndp = [1]*len(nums)\\n```\\n\\nmakes sense, because it gives a starting point for the DP solution. It states that before checking any other elements, each element itself forms a strictly increasing subsequence of length `1`.\\n\\nAfter initialization, the DP array gets updated while iterating over `nums`. For each element at index `i`, you compare it with all elements at previous indices `j`. If `nums[i]` is greater than `nums[j]`, that means you can extend the subsequence ending at `j` to `i`. If this new subsequence is longer than any previously found subsequences ending at `i`, you update `dp[i]`.\\n\\nHence, the initialization of the DP array is an essential step in solving this problem using dynamic programming."
                    },
                    {
                        "username": "hexiecs",
                        "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe LIS problem can be solved by dynamic programming. The transition equation is  dp[i] = max(dp[j]) + 1, in which nums[j] < nums[i]. For each number, we need to iterate through the previous numbers to find the maximum dp, so overall time complexity is O(n^2).\\n\\nWe can use binary search to get an O(nlog(n)) algorithm. We use an array to store the minimum tail element of each LIS length. For example, tail[i] represents the minimum tail element of LIS whose length is i + 1. To maintain the attribute of the tail array, when we iterate through the nums array,  let\\'s say current number is cur. If tail[i - 1] < cur < tail[i], we can replace the tail[i] with cur because it\\'s less than tail[i] and it can also form an LIS whose length is i + 1,  so we can make sure the numbers stored in tail array are minimum. \\n\\nWe can prove the tail array is increasing. If tail[i - 1] > tail[i], we can replace tail[i - 1] with the second element from tail of LIS whose length is i + 1 to make tail[i - 1] smaller. So we can use binary search to find the appropriate position of current number in tail array."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your explanation for both the dynamic programming and binary search solutions is correct and well-structured. Good job! \\n\\nHere are a few minor suggestions to improve your description:\\n\\n1. **Dynamic Programming:** \\n   Instead of just saying \"The transition equation is dp[i] = max(dp[j]) + 1\", consider adding a bit more context. For instance, you could say, \"For every number at index \\'i\\', we iterate through all the previous numbers. If the current number is greater than a previous number (let\\'s call it \\'j\\'), it means that we can extend the increasing subsequence that ends with the number at \\'j\\'. Therefore, the transition equation is dp[i] = max(dp[j]) + 1, for all j such that nums[j] < nums[i].\"\\n\\n2. **Binary Search:**\\n   You\\'ve explained the tail array well, but you could also explain how the length of this tail array at the end of the process gives the length of the LIS. For example, you could say, \"By maintaining the tail array in this way, the final length of the tail array gives us the length of the longest increasing subsequence. This is because each index \\'i\\' of the tail array represents an increasing subsequence of length \\'i+1\\', and the value at tail[i] is the smallest tail element we could find for such a subsequence.\"\\n\\nThese small tweaks can add more clarity and help a listener or reader understand your explanation more quickly and easily. Overall, you\\'ve done a great job of summarizing these complex algorithms!"
                    },
                    {
                        "username": "qiuqiuj",
                        "content": "Here is an confusion fo mine when understanding **what really the dp[i]  is** in the method, hope it might help the people who face the same problem like me.\\n\\nWhen you do DP/Max-Travese method, actually your steps is like this:\\nFirst, give a start, here \\'[1] * len(nums)\\', becasue for each points in array, at least itself is a increasing subsequence;\\nThen, use DP/Max-Travese method to fill in the DP[] step by step, **here comes what confused me.**\\n\\n**What really DP[i] represents? **\\nYou might say, **\\'\\'DP[i] represents LIS of the array[start to i]\\'\\'**, but this kind of saying is only **partly right**, which is the key point of confusing, it needed to be added a constrain, together should be like this, \\'\\'DP[i] represents **\\'fake LIS\\' which ended by array[i]**  of the array [start to i]\\'\\'.\\n\\nNow let me explain with an example array, [2,5,4,3,1], and the related DP array is dp[],\\nif you consider the **\\'dp[i] represents LIS of the array[start to i]\\'**, the related dp[] should be,[1,2,2,2,**2**];\\nif you consider the **\\'dp[i] represents \\'fake LIS\\' which ended by array[i] of the array[start to i]\\'**, dp[], should be [1,2,2,2,**1**], and only by this is realy what the code says.\\n\\nThis \\'fake LIS\\' is really important, for it can help you to store an \\'fake LIS\\' ended by array[i],\\nso you can use it later to see if you can get a longer array after. But a \\'real LIS\\' can\\'t help store the result needed.\\n\\nThanks for your reading.\\n\\n\\n"
                    },
                    {
                        "username": "hxtang",
                        "content": "The first time I see the O(n log n) solution I really wonder where the design auxiliary array comes from and how one may even hypothesize the array to be monotonically increasing. But later I figured out there's a path to evolve from the O(n^2) to O(nlogn) solution.\\n\\n* Step1: the \"naive\" DP\\nThe O(n2) DP maintains an array L, with L[k] storing the max length of longest increasing subsequence (abbreviated as LIS below) ending with the k-th element of input. So the optimal substructure is **L[k] = max {L[j]+1 | j < k and nums[j]<nums[k]}**.\\n\\n* Step2: DP with a shorter auxiliary array\\nThe key of this step is to examine what may update L[k], and realize:\\n**there could be multiple indices j of the same L[j], and the LIS with the smallest tail suffice to render a candidate LIS with length L[j]+1.** <br>\\nThis implies that the O(n2) DP is wasting space, and hints that we should turn to cache ones causing most L[k] to potentially update -- they happen to be those LIS with smallest tail of each length. \\nThis gives us a new formulation of optimal substructure formulating **the min tail of increasing subsequence in nums[1...k] of length l**, which we denote as T[k, l]. It is trivial to make it a 1-D update by only maintaining the last two rows of T.<br>\\nNow we get a DP of complexity O(n * L[n]). It is already better than the naive DP with a long input whose increasing subsequences are all short. But there is more space to improve.\\n\\n* Step3: The O(nlogn) solution\\nA natural question to ask, if we'd want to optimize the above DP further, is when T[k, l] is updated to num[k]. It is easy to find out that this happens when **T[k-1, l-1] < nums[k] < T[k-1, l]**. The left \"<\" ensures nums[k] can be appened after T[k-1, l-1], while the right \"<\" makes an update. <br>\\nThis leads us to wonder about occasions where the updated positions is sparse and easy to search -- **when the row T[k-1, ] is monotonic we can do binary search**!  At this point it is all about make believe first and then prove this is indeed true."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@raghavjanamanchi](/raghavjanamanchi) Here is the explanation of his points:\\n\\nStep 1 - Naive Dynamic Programming (DP) Approach:\\nIn the first step, we start with a very straightforward method. We use dynamic programming to keep track of the longest increasing sequence that ends with each number in our array (nums). We do this by maintaining an array (L) where L[k] is the maximum length of the increasing sequence ending with the k-th number in nums. We can find the value for L[k] by looking at all the previous entries in L where the corresponding number in nums is smaller than the k-th number and choosing the maximum among them.\\n\\nStep 2 - A More Refined Dynamic Programming Approach:\\nIn this step, we make an observation that helps us to improve our algorithm. We notice that when updating L[k], the only previous L[j]s that matter are those that belong to the longest increasing sequences with the smallest end number. Thus, we can save space by only keeping track of these sequences. This leads us to create a new array, T, where T[k, l] is the smallest tail number of an increasing sequence of length l in the first k numbers of nums. Note that by only keeping the last two rows of T, we can reduce the space complexity to linear.\\n\\nStep 3 - Optimized Approach with Binary Search:\\nIn the third and final step, we notice that we only update T[k, l] to nums[k] if T[k-1, l-1] is smaller than nums[k], which is smaller than T[k-1, l]. This is because nums[k] can follow a sequence ending with T[k-1, l-1] and, being smaller than T[k-1, l], it could potentially start a longer increasing sequence. Importantly, we see that each row in T is sorted, or \\'monotonic\\'. This means we can use binary search, a very fast search algorithm, to find where to place each number. This brings the time complexity down to O(n log n), a significant improvement over the naive approach! \\n\\nPlease note that this is a relatively high-level explanation. Each step involves complex thoughts and careful design. It is quite normal to find this challenging at first, but with practice and study, these concepts will become clearer."
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "Boss your explanation is about as confusing as it can get"
                    },
                    {
                        "username": "gragus",
                        "content": "The problem descriptions says:\\n\\n> Given [10, 9, 2, 5, 3, 7, 101, 18].\\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\\n\\nHowever, this is incorrect. The provided subsequence is missing the 5 that has mysteriously disappeared.\\nIn fact, the longest increasing subsequence here is is [3, 7, 101] of length 3.\\n\\nAm I missing something or is the question phrased inappropriately?\\n\\nThank you!"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "2, 3, 7, 101 and 2, 5, 7, 101 are the same length (4)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "subsequences can be consecutive or not what matters is their order \\non the other hand sub-array is the one you are talking about.\\n\\nLeetIsCode\\nsub-Sequence: LeetCode\\nSub-Array: \\'LeetIs\\' or \\'IsCode\\'"
                    },
                    {
                        "username": "longchaoliu",
                        "content": "subsequences generally don\\'t have to be consecutive"
                    },
                    {
                        "username": "NaN-NaN-NaN",
                        "content": "Because problem states\\n> sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements\\n\\nIn that example, 5 is omitted"
                    },
                    {
                        "username": "sachinkg12",
                        "content": "Input: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Why the length is 4 ? --> why is 2 part of this answer when we have 5 in the middle. \\nShouldn\\'t the Output be 3? [3,7,101]"
                    },
                    {
                        "username": "sarthakvyadav",
                        "content": "Because subsequence is not like subarray subsequence means the elements may or may not be contigious but they have to be in the same order \\nfor eg - [1,2,3,4,5] here 1,3,5 is a susequence it\\'s not contigious but it is in the same order like 1 will always come before 3 and 3 before 5 \\nsimilarly [3,5] [2,,4,5] are also susequence \\nFor an array of length n it can have 2^n subsequence"
                    },
                    {
                        "username": "aksamvel",
                        "content": "[@aksamvel](/aksamvel) Seems because this sequence have few decisions..."
                    },
                    {
                        "username": "aksamvel",
                        "content": "Why answer is not 2,5,7,101?\\n"
                    },
                    {
                        "username": "tejtharun625",
                        "content": "This question is asking for subsequence and not sub-array. Subsequence can have some missing numbers, but order should be same\\n"
                    },
                    {
                        "username": "fluency03",
                        "content": "what if I ask: Longest Non-decreasing Subsequence?"
                    },
                    {
                        "username": "ankush920",
                        "content": "in that case we also  considered the equal to case ( i.e. when no are equal that case is also acceptable )\\nthere i write code in c++ for you\\n\\n int lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if( nums[i]< nums[j] )\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }  "
                    },
                    {
                        "username": "megaman14",
                        "content": "So, this question is asking for just the length of the LIS, but how would you go about returning the actual LIS? The solution that everyone seems to have for O(n logn) to just find the length seems to replace some of the values in the LIS array when small values are iterated over. Example: nums: [10, 2, 3, 1] should have LIS of [2, 3], but because you replace the 2 with this method, you would get [1,3] which is not the correct answer in the case of the actual LIS."
                    }
                ]
            },
            {
                "id": 1574217,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1573465,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1569740,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1573873,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 2020729,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1726507,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1573692,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1570592,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1572123,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1576173,
                "content": [
                    {
                        "username": "tagsense",
                        "content": "in the test case [10,9,2,5,3,7,101,18], is not [3,7,101] longest subsequence? why the answer is mentioned as 4? please explain."
                    },
                    {
                        "username": "rahulkr25",
                        "content": "its asking for subsequence, not substring"
                    },
                    {
                        "username": "makedon",
                        "content": "True BF solution would be to enumarate all subsequences, then search through them to find the longest increasing one."
                    },
                    {
                        "username": "jose_rafael_marcano",
                        "content": "why is n*n? \\nSpace complexity : O(n^2)\\n memo array of size n * n is used.\\n What does mean memo array? the stack used in recursion?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The dynamic programming solution for the Longest Increasing Subsequence (LIS) problem typically uses a one-dimensional DP array of size n, where n is the size of the input array. Each cell in the DP array represents the length of the longest increasing subsequence ending at that position. This approach has a space complexity of O(n).\\n\\nThe time complexity is O(n^2) because, for each element in the array, we potentially compare it with every element before it. This leads to n*(n-1)/2 comparisons in the worst case, which simplifies to O(n^2).\\n\\nIf we talk about a memo array of size n*n, it seems we are discussing a different problem or approach. For instance, in problems involving two sequences or strings (like the Longest Common Subsequence problem), we often use a two-dimensional memo table of size n*m (where n and m are the sizes of the two input sequences). Each cell in this 2D memo table typically represents a subproblem involving a prefix of each sequence.\\n\\nIf you\\'ve seen an n*n memo array used for the LIS problem, it could possibly be from a variant of the problem or a different solution approach. \\n"
                    },
                    {
                        "username": "urieluvd",
                        "content": "This probles is similar to other probles with sliding window approach but,\\nthe description says:\\n\\n\"Given an unsorted array of integers, find the length of longest increasing subsequence.\"\\n\\nFor the first case the input is\\n`[10,9,2,5,3,7,101,18]`\\n\\nthe longest increasing subsequence of that array is\\n`[3,7,101]`\\nwhich length is `3`\\n\\nBut the test case expects a `4`\\nAnd the animation of the solution shows that the input is \\n`[10,9,2,5,3,7,101]`\\nand the solution is\\n`[2,5,3,7,101]`, `4`\\n\\nThis solution does not match the input of the test case and ignores the number `5`\\nbreaking the increasing sequence.\\nThe description does not say that it should be \"strictly increasing\", \\nso lets say we are allowed to sort all numbers in the window , so the `5` in the sequence won\\'t break the condition.\\nBut following that approach it means you could fit the entire array `[10,9,2,5,3,7,101]` into that condition.\\nso the answer sould be `7`\\n\\nIs there something that i am missing?\\n"
                    },
                    {
                        "username": "nitissssh",
                        "content": "If someone is familiar with dp , one can solve this using intution  . But looking at the binary search solution really makes you wonder how sharp were those who came up this algo on there own . Also makes you question the fact what is actually yours as  I myself would use it in any other problem of similar pattern and act like I solved it but in reality one always learns from somebody else."
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "HELP - Tabulation\\n\\nHi can someone please help me I\\'m getting issues while converting my  this memoized working code to tabulation\\n\\npublic int lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int dp[][] = new int[n][n+1];\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return lengthOfLIS(nums, n-1, n, dp);\\n    }\\n    int lengthOfLIS(int[] nums, int i, int maxI, int dp[][]) {\\n        if(i<0) return 0;\\n\\n        if(dp[i][maxI-1]!=-1) return dp[i][maxI-1];\\n\\n        if(maxI==nums.length || nums[i]<nums[maxI]){\\n            return dp[i][maxI-1] = Math.max(1+lengthOfLIS(nums, i-1, i, dp), lengthOfLIS(nums, i-1, maxI, dp));\\n        }\\n        return dp[i][maxI-1] = lengthOfLIS(nums, i-1, maxI, dp);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Converting a memoized (top-down) DP solution to a tabulation (bottom-up) DP solution often involves rethinking the flow of your solution. A tabulation DP approach typically fills up a DP table iteratively, starting from the base cases and working its way up to the final solution.\\n\\nHere is how you can convert your memoized solution to a tabulation solution:\\n\\n```java\\npublic int lengthOfLIS(int[] nums) {\\n    int n = nums.length;\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, 1);  // each element is a subsequence of length 1\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        maxLength = Math.max(maxLength, dp[i]);\\n    }\\n\\n    return maxLength;\\n}\\n```\\n\\nIn the above code:\\n\\n- We first initialize all elements of `dp` to 1 since a single element is always a valid subsequence of length 1.\\n- For each number, we iterate through all previous numbers. If the current number `nums[i]` is greater than the previous number `nums[j]`, we can extend the subsequence ending at `j` to a longer subsequence ending at `i`. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`.\\n- Finally, we return the maximum value in the `dp` array, which represents the length of the longest increasing subsequence."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "I found a **very good video explanation** of the **nlogn approach** on Youtube. Hope it will help you guys.\\nHere is the link to the video solution for this question by alGOds.\\n**https://youtu.be/nf3YG4CnTbg4**\\n\\n\\n"
                    },
                    {
                        "username": "rahulranjan95",
                        "content": "![image](https://assets.leetcode.com/users/images/bafca9f2-ac54-4dbf-83aa-7cb24af6ccf2_1631271909.8612134.png)\\n\\nThis one is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/7a3237e3-386e-45a7-bf71-52aef39a8fdf_1631272018.1274722.png)\\n\\nYou can see a vast difference in accepted time. \\nPlease let me know if you need any detailed explanation.\\n"
                    },
                    {
                        "username": "yangfeiran",
                        "content": "Example:\\n\\nInput: [10,9,2,5,3,7,101,18]\\nOutput: 4 \\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \\n\\nthere is a 5 in between 2 and 3, so why is the increasing subseqeence is [2,3,7,101] but not [3,7,101]"
                    },
                    {
                        "username": "Isuru26",
                        "content": "subsequence means only the order matters. we don\\'t need to consider only the adjusent elemants like strng substring problems"
                    },
                    {
                        "username": "programwithsai",
                        "content": "Explained in video here: https://bit.ly/lc300-lis"
                    }
                ]
            },
            {
                "id": 1575631,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 2001703,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 2000587,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 2000246,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1996483,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1990015,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1989003,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1975924,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1968583,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1967055,
                "content": [
                    {
                        "username": "CrazyAlakazam",
                        "content": "Is there a problem here on LeetCode to find the actual longest increasing subsequence (values of the subsequence) instead of the length of LIS?\\nFor Example: \\nInput: nums = [10,9,2,5,3,7,101,18]\\nOutput: [2,3,7,101]"
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "why the solution gave me this runtime error : \"terminate called after throwing an instance of \\'std::bad_alloc\\'\\nwhat():  std::bad_alloc.\"\\nSolution: \\nconst lengthOfLIS = (arr) => {\\n    const LIS = (index, prev, memo) => {\\n        if (`${index},${prev}` in memo) {\\n            return memo[`${index},${prev}`];\\n        }\\n        if (index === arr.length) {\\n            return 0;\\n        }\\n\\n        let choice1 = LIS(index + 1, prev, memo);\\n        let choice2 = 0;\\n\\n        if (prev === arr.length || arr[index] > arr[prev]) {\\n            choice2 = LIS(index + 1, index, memo) + 1;\\n        }\\n\\n        memo[`${index},${prev}`] = Math.max(choice1, choice2);\\n        return memo[`${index},${prev}`];\\n    };\\n\\n    return LIS(0, arr.length, {});\\n};"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Just started to learn DP. Really boggles my mind"
                    },
                    {
                        "username": "imnegan",
                        "content": "What is wrong in this logic?\nThe test case is failing for the given test case below- \n\n```\nclass Solution:\n    cache = {}\n    def make_key(self, prev, curr):\n        return f'{prev}_{curr}'\n    def backtrack(self, prev, curr, nums, max_value):\n        if len(nums) == 1:\n            return 1\n        if len(nums) == curr:\n            return max_value\n        key = self.make_key(prev, curr)\n        if key in self.cache:\n            return self.cache[key]\n        # include\n        should_include = nums[prev] < nums[curr]\n        compare_arr = []\n        if should_include or prev == -1:\n            value = self.backtrack(curr, curr + 1, nums, max_value + 1)\n            self.cache[self.make_key(curr, curr + 1)] = value\n            compare_arr.append(value)\n        # exclude\n        value = self.backtrack(prev, curr + 1, nums, max_value)\n        self.cache[self.make_key(prev, curr + 1)] = value\n        compare_arr.append(value)\n        return max(compare_arr)\n    def lengthOfLIS(self, nums):\n        self.cache = dict()\n        return self.backtrack(-1, 0, nums, 0)\n```\n\n\nnums = [3,5,6,2,5,4,19,5,6,7,12]\nSolution().lengthOfLIS(nums)\n\n\n"
                    },
                    {
                        "username": "cherrychoco",
                        "content": "I\\'ve tried two kinds of DP solutions here. The first solution uses recursive + memoization, and the second solution is top-down DP. I think the time complexity for both solutions is O(n^2). However, the second one received a TLE (Time Limit Exceeded). I have faced similar issues when choosing between these two types of solutions.\\n\\nCould someone tell me how to choose between these two? And what is the time complexity difference between them? Thanks!\"\\n\\n\\n# First One\\n\\n      def lengthOfLIS(self, nums: List[int]) -> int:\\n          def dfs(start, prev_val, memo) :\\n            if start in memo.keys() :\\n                return memo[start]\\n            if start == len(nums) :\\n                return 0\\n            count = 0\\n            for i in range(start, len(nums)) :\\n                if nums[i] <= prev_val :\\n                    continue\\n                count = max(count, dfs(i + 1, nums[i], memo)+1)\\n            memo[start] = count\\n            return count\\n        \\n        return dfs(0, -float(\"inf\"), dict())\\n\\n# Second One\\n\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        def dp(i, prev, memo) :\\n            if i == len(nums) :\\n                return 0\\n            if (i,prev) in memo.keys() :\\n                return memo[(i,prev)]\\n            length = 0; case1 = 0; case2 = 0\\n            if prev == - 1 or nums[i] > nums[prev] :\\n                case1 = dp(i+1, i, memo) + 1\\n            case2 = dp(i+1, prev, memo)\\n            length = max(case1, case2)\\n            memo[(i,prev)] = length\\n            return length\\n  \\n        return dp(0, -1, dict())\\n            \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ritvikush",
                        "content": "[@bparanj](/bparanj) sorting, are you serious? Do you not read what ChatGPT has written after giving it prompts? \\n\\n0_0"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of the given solutions are aimed at solving the Longest Increasing Subsequence (LIS) problem, and they use different forms of Dynamic Programming (DP). Let\\'s analyze the differences and figure out why the second approach might lead to a Time Limit Exceeded (TLE) error.\\n\\n1. **First Solution (Recursive + Memoization):**\\n   - It relies on Depth First Search (DFS) and recursion.\\n   - It uses the current index and the previous value to define the state.\\n   - You have created a memo dictionary with `start` as the key, which means it doesn\\'t take the `prev_val` into account, making it a 1-dimensional DP.\\n   - The time complexity is closer to \\\\(O(n^2)\\\\) but may not cover all possible combinations of states.\\n\\n2. **Second Solution (Top-Down DP):**\\n   - It also uses recursion, but the structure is more traditional DP.\\n   - It uses the current index and previous index to define the state, making it a 2-dimensional DP.\\n   - The time complexity here is likely higher than \\\\(O(n^2)\\\\) due to the extra dimension.\\n\\n**Why the second one might lead to TLE?**\\n- Since the second solution is using a 2-dimensional state, it will traverse more possible states than the first one. This might lead to a higher time complexity, making it slower.\\n- In the first approach, by using the value rather than the index, you might be omitting some unnecessary states, which can make it faster in practice.\\n\\n**How to choose between these two?**\\n- It often depends on the problem and the constraints.\\n- If the 1-dimensional approach covers all necessary states, it is generally preferred since it will be more efficient in both time and space.\\n- If the problem requires considering more dimensions, then the 2-dimensional approach or even higher-dimensional approaches might be necessary.\\n\\nIn this particular case, the first approach seems to cover the problem\\'s requirements with a more compact state space, making it a better choice.\\n\\nIf you wanted to make the second approach more efficient, you could try to reduce the number of states by observing the specific characteristics of the problem. For instance, in this problem, sorting the input could reduce the complexity of the problem. Analyzing the problem and reducing the state space is a common way to optimize DP solutions."
                    },
                    {
                        "username": "HS_2k25_JMS",
                        "content": "CAN ANYONE TELL THE ERROR -\\n\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int dp[] = new int[nums.length+1];\\n        for(int i = 0; i<dp.length; i++)\\n        dp[i] = -1;\\n        return lengthlis(nums,0,-1,dp);\\n    }\\n\\n    public static int lengthlis(int nums[], int index, int prev, int dp[])\\n    {\\n        if(index >= nums.length)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        int smallAns1 = -1;\\n        int smallAns2 = -1;\\n\\n        if(prev == -1)\\n        {\\n            smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp); //pick\\n            smallAns2 = lengthlis(nums, index+1, prev, dp); //not pick\\n        }\\n        else\\n        {\\n            if(nums[index] > prev)\\n            {\\n                smallAns1 = 1 + lengthlis(nums, index+1, nums[index], dp);\\n                smallAns2 = lengthlis(nums, index+1, prev, dp);\\n            }\\n            else\\n            smallAns2 = lengthlis(nums, index+1, prev, dp);\\n        }\\n\\n        dp[index] = Math.max(smallAns1, smallAns2);\\n        return dp[index];\\n    }\\n}"
                    },
                    {
                        "username": "algoacer",
                        "content": "Try this question with making a binary search tree from the given values. Now answer will be the maximum depth of the tree. \\n\\nThis is an intuitive approach but you should eventually shift to binary search solution which is looking at this logic from other side.\\n[https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/](https://leetcode.com/problems/longest-increasing-subsequence/solutions/3824647/binary-search-solution-beats-100/)\\nProblems can test intelligence sometimes."
                    },
                    {
                        "username": "akalhan",
                        "content": "## Please help me understand why I am getting TLE in python but not in C++\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n        for i in range(n-1,-1,-1) :\n            for prev_index in range(i - 1,-2,-1) :\n                take = 0\n                not_take =  dp[i + 1][prev_index + 1]\n\n                if prev_index == -1 or nums[i] > nums[prev_index] :\n                    take = 1 + dp[i + 1][i + 1]\n\n                dp[i][prev_index + 1] = max(take,not_take) \n        \n        return dp[0][0]\n```\nThis code fails at the 54th test case, however I am unable to see which test case it fails because leetcode doesnt show the test case for some reason.\nI wrote the same logic in C++ and it got accepted, is the reason because of the time limit in Python or am I missing something?\nAny help is appreciated.\n\nMy C++ code\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n        for(int ind = n-1 ; ind >= 0 ; ind --){\n            for(int prev = ind-1; prev >= -1;prev --){\n\n                int not_take = 0 + dp[ind+1][prev + 1];\n                int take = 0;\n\n                if(prev == -1 || arr[ind] > arr[prev] ){\n                    take = 1 + dp[ind + 1][ind + 1];\n                }\n\n                dp[ind][prev + 1] = max(take,not_take);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\n```"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Just curious to understand, can we use a monotonic decreasing stack here ? "
                    },
                    {
                        "username": "jaggz01",
                        "content": "[@bparanj](/bparanj) Wonderful, thanks for the explanation. "
                    },
                    {
                        "username": "bparanj",
                        "content": "No, a monotonic decreasing stack would not be useful for solving the Longest Increasing Subsequence (LIS) problem.\\n\\nThe reason is that the LIS problem requires us to find the longest subsequence where each element is larger than the previous one, not smaller. A monotonic decreasing stack is used when we want to maintain a stack of elements where each successive element is smaller than or equal to the previous one. This is opposite to what we want for the LIS problem.\\n\\nMoreover, the LIS problem requires us to look at all the previous elements for each current element, not just the most recent one, which is what a stack provides. Therefore, the structure of a stack, whether decreasing or increasing, does not lend itself to a solution for the LIS problem.\\n\\nInstead, dynamic programming is the standard approach for solving the LIS problem, as it allows us to store and update the lengths of the longest increasing subsequences ending at each index in the array. Alternatively, binary search can be used to achieve a more optimized solution with time complexity O(n log n)."
                    },
                    {
                        "username": "layyy",
                        "content": "try greedy+binary search for O(NlogN)"
                    }
                ]
            },
            {
                "id": 1965110,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1951943,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1950760,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1935136,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1907168,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1904500,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1899953,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1886210,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1886069,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1859999,
                "content": [
                    {
                        "username": "Gladvenom",
                        "content": "Question :- I solved the question by creating a recursive dp when i passed the vector by value I got TLE\\nand when i passed vector by reference it was accepted \\ncan anybody explain me why that happened? "
                    },
                    {
                        "username": "psionl0",
                        "content": "When you pass a vector by value, you are copying every element in that vector. If you pass it by reference, you only pass a single number - the address of the vector."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "why is everyone\\'s memoization solution going from 0 till n . How to solve this is n to 0  using dp bcz I am having some taugh time handling the prevInd =-1 when I start that way."
                    },
                    {
                        "username": "bparanj",
                        "content": "Starting from `n` and going to `0` might indeed cause problems with initializing `prevInd = -1`. When we start from the beginning (`0` to `n`), it\\'s easy to set `prevInd = -1` because we haven\\'t encountered any elements yet. But if we start from the end, we would need to have some logic to handle the first iteration differently.\\n\\nHere\\'s an alternative approach which might help. In this approach, we start from `0` but instead of considering the subsequence ending at `i`, we consider the subsequence starting at `i`. This way, when `i` equals `n-1`, we will only have one element left, and the longest increasing subsequence starting at this point is of length `1`.\\n\\nHere\\'s the code for the bottom-up dynamic programming solution:\\n\\n```python\\ndef lengthOfLIS(nums):\\n    n = len(nums)\\n    dp = [1] * n\\n    for i in reversed(range(n-1)):\\n        for j in range(i+1, n):\\n            if nums[i] < nums[j]:\\n                dp[i] = max(dp[i], 1 + dp[j])\\n    return max(dp)\\n```\\n\\nIn this code, `dp[i]` stores the length of the longest increasing subsequence starting at `i`. We iterate `i` from `n-2` to `0` (since `dp[n-1]` is trivially `1`), and for each `i`, we iterate `j` from `i+1` to `n-1`. If `nums[i] < nums[j]`, we update `dp[i]` to be the maximum of the current `dp[i]` and `1 + dp[j]`.\\n\\nFinally, we return the maximum value in `dp` as the length of the longest increasing subsequence.\\n\\nNote that this approach still has a time complexity of O(n^2), so it is not as efficient as the binary search method, which has a time complexity of O(n log n)."
                    },
                    {
                        "username": "Shikhar_001",
                        "content": "top down approach\\n\\n int solveTopdown(vector<int>& a,int curr,int prev,vector<vector<int>> &dp){\\n        if(curr>=a.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){ // +1 isliye kra kyunki -1 koi valid index nahi he\\n            return dp[curr][prev+1];\\n        }\\n        int include=0;\\n        if(prev==-1 || a[curr]>a[prev]){    //prev -1 matlab subsequence array is empty \\n            include=1+solveTopdown(a,curr+1,curr,dp);// shift kr rahe he \\n        }\\n           \\n        \\n         int    exclude=solveTopdown(a,curr+1,prev,dp);\\n        \\n        return dp[curr][prev+1]= max(include,exclude);\\n    }\\n"
                    },
                    {
                        "username": "priyank9641",
                        "content": "Input: nums = [0,1,0,3,2,3]\\nOutput: 4\\nCan someone explain how the expected output is 4?"
                    },
                    {
                        "username": "priyank9641",
                        "content": "[@oops_moment](/oops_moment) thanks!"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey hi , it\\'s 0,1,2,3 hence total length is 4."
                    },
                    {
                        "username": "Yugeshjhamb_3108",
                        "content": "int func(int i,int prev,vector<int> nums){\\n\\n    if(i<0) return 0;\\n\\n    //not take\\n    int a = func(i-1,prev,nums);\\n    int b = 0;\\n    //take\\n    if(prev == -1 || nums[prev]>nums[i] ){\\n    b = func(i-1,i,nums) + 1;\\n    }\\n\\n    return max(a,b);\\n}\\n\\nThis is the recursion I wrote and it works fine, but i can\\'t solve the 2D tabulated version with i looping from 1 to n. Can someone please provide me with the logic to write the tabulated version for the same....."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your recursion logic is perfectly fine, it seems that you are considering whether to include the `i`th element in the longest increasing subsequence (LIS) or not. When you try to convert it to the tabulation (bottom-up dynamic programming), you can use a 2D table where `dp[i][j]` represents the length of the LIS ending at index `i` with `j` as the previous index.\\n\\nHere\\'s the corresponding bottom-up dynamic programming (tabulation) code:\\n\\n```cpp\\nint lengthOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n    // dp[i][j] represents the LIS from 0 to i with j as previous index\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    int maxLength = 0;\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][i] = 1;  // Single element is always a LIS\\n        for (int j = 0; j < i; ++j) {\\n            if (nums[i] > nums[j]) {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1] + 1);\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[j][i-1]);\\n            }\\n        }\\n        maxLength = max(maxLength, dp[i][i]);\\n    }\\n    return maxLength;\\n}\\n```\\n\\nIn this code, `dp[i][j]` represents the length of the longest increasing subsequence that ends at index `i` with `j` as the previous index. We initialize each `dp[i][i]` as `1` since a single element is always a LIS. Then, for each index `i` from `1` to `n-1`, and for each `j` from `0` to `i-1`, if `nums[i]` is greater than `nums[j]`, we update `dp[i][j]` to be the maximum of the current `dp[i][j]` and `dp[j][i-1] + 1`. If `nums[i]` is not greater than `nums[j]`, we simply update `dp[i][j]` to be `dp[j][i-1]`. Finally, we update `maxLength` with the maximum value of `dp[i][i]`.\\n\\nPlease note that this solution has a time complexity of O(n^2), where `n` is the size of the input array."
                    },
                    {
                        "username": "zalars",
                        "content": "There are more LISs in the 1st example:\n`[2,5,7,101]`, `[2,3,7,18]`, `[2,5,7,18]`."
                    },
                    {
                        "username": "altoid",
                        "content": "right.  and they are all of length 4.  there isn\\'t a longer increasing subsequence than that.\\n\\nnote that the problem doesn\\'t ask for the LIS, just its length.  there could be more than 1 with that length.  "
                    },
                    {
                        "username": "kabir20382",
                        "content": "Does anybody know about problem that uses similar approach to this question, i.e. the NlogN approach of creating piles and using binary search to locate and insert in that piles? I\\'ve done similar problem in the past but have been tirelessly searching for the problem without success. Any help would be appreciated. Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are several problems that use a similar NlogN approach with binary search to find solutions. Here are a few examples:\\n\\n1. \"Russian Doll Envelopes\" (LeetCode 354): This problem requires sorting a list of envelopes by width and height, then finding the longest increasing subsequence based on the heights.\\n\\n2. \"Minimum Number of Arrows to Burst Balloons\" (LeetCode 452): The problem can be solved by sorting the balloons by their end coordinates, then applying a greedy approach similar to finding the longest increasing subsequence.\\n\\n3. \"Longest Increasing Path in a Matrix\" (LeetCode 329): Although this problem uses Depth-First Search (DFS), it also involves finding the longest increasing path in a matrix, which can be thought of as a form of longest increasing subsequence.\\n\\n4. \"Maximum Length of Pair Chain\" (LeetCode 646): This problem requires sorting the pairs and then finding the longest chain, which is similar to finding the longest increasing subsequence.\\n\\n5. \"Box Stacking\" problem: In this classic dynamic programming problem, boxes need to be stacked such that each box is smaller in size than the box below it. This involves sorting and then finding the longest increasing subsequence.\\n\\nRemember, in all these problems, the key idea remains the same: sorting the input in a meaningful way, and then finding the longest increasing subsequence."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think I am not able to solve this problem in interviews. This problem is hard even binary solution is hard to find."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this is the most classic problem on dp. Atleast memoize it if you can\\'t process it. ><"
                    },
                    {
                        "username": "Anshul982",
                        "content": "can we do the question using upper bound()"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Longest Increasing Subsequence problem can be solved using the `upper_bound()` function. This is usually part of the efficient O(n log n) solution, where binary search is used to find the position of an element. In C++ STL, `upper_bound()` performs this binary search for you.\\n\\nHere\\'s a simple sketch of how you might use `upper_bound()` to solve this problem in C++:\\n\\n```cpp\\nvector<int> lis;\\nfor (int i = 0; i < nums.size(); i++) {\\n    // If the current number is greater than the last number in the \\'lis\\' vector\\n    // it can extend the current longest increasing subsequence\\n    if(lis.empty() || nums[i] > lis.back()){\\n        lis.push_back(nums[i]);\\n    }\\n    // If not, it can potentially start a new increasing subsequence of same length\\n    // Thus, we find the position of the first number in \\'lis\\' that is greater or equal to nums[i]\\n    // and replace it with nums[i]\\n    else{\\n        int pos = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n        lis[pos] = nums[i];\\n    }\\n}\\n// The length of the longest increasing subsequence is the length of \\'lis\\'\\nreturn lis.size();\\n```\\n\\nNote that this solution maintains a list of potential candidates for the longest increasing subsequence, rather than the subsequence itself. The actual longest increasing subsequence can be different, but its length will be the same as the length of this candidate list. \\n\\nRemember that the `upper_bound()` function returns an iterator pointing to the first element in the range [first, last) that is greater than `val`. If no such element is found, the function returns `last`. This function uses binary search and works in O(log n) time."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "The solution Approach 2: Intelligently Build a Subsequence, try this example:\\n    nums [1, 3, 6, 7, 9, 4, 10, 5, 6]\\nWhen it finishes, look at whats in \\'sub\\':\\nsub [1, 3, 4, 5, 6, 10] <-- order is wrong! 10 should be in front of 5 and 6. The function changed the order."
                    },
                    {
                        "username": "psionl0",
                        "content": "Numbers are only appended to the \\'sub\\' if they are larger than the largest number so far in the \\'sub\\' array.\\n\\nThis is what the \\'sub\\' looks like after the first 5 numbers have been processed: [1 ,3, 6, 7, 9]. The next number to be processed will be 4 which replaces the 6 in the \\'sub\\' indicating that the maximum length at that point is 3.\\nThe 10 is added after that to give a sub of [1,3,4,7,9,10] and a maximum length of 4 (previous length + 1).\\n\\nNext number is 5 but this will replace the 7 in the \\'sub\\' giving the following \\'sub\\' array and indicating a length of 4: [1,3,4,5,9,10]\\n\\nThe final number 6 replaces the 5 in the sub also indicating a maximum length of 5: [1,3,4,5,6,10]"
                    }
                ]
            },
            {
                "id": 1839007,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1838457,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1821209,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1807004,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1759500,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1746367,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1728469,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1716334,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1716268,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            },
            {
                "id": 1574130,
                "content": [
                    {
                        "username": "cheesebread",
                        "content": "I hate dp as much as the next guy, but I think this one is the one to really master or memorize one of the strategies off the top of your head. Because I\\'ve seen so many hard problems this week that are based off this, and it\\'s kinda annoying if I\\'ve never figured it out."
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s understandable to find dynamic programming (DP) challenging. It\\'s a technique that requires a good understanding of recursion, memoization, and problem decomposition, which can be hard to grasp. But you\\'re right, many hard problems in computer science and competitive programming can be solved effectively with DP.\\n\\nThe Longest Increasing Subsequence problem is a classic DP problem that serves as the foundation for many other problems. Here are a few tips to help you master this kind of problem:\\n\\n1. **Understand the problem**: Make sure you have a clear understanding of what the problem is asking. In this case, you\\'re looking for the longest subsequence (not necessarily contiguous) of an array that is in increasing order.\\n\\n2. **Identify subproblems**: Dynamic programming solutions usually break the problem down into smaller subproblems. In this case, the subproblem could be \"what\\'s the longest increasing subsequence ending at each position in the array?\"\\n\\n3. **Define the state and transition**: Define the DP state (i.e., the memoization table) to store the results of subproblems. In this case, a 1-D array where dp[i] represents the length of the longest increasing subsequence ending at index i. The transition function is the rule to move from one state to another.\\n\\n4. **Bottom-up calculation**: Start from the simplest subproblems and gradually tackle more complex ones. This often involves nested loops iterating over the DP state.\\n\\n5. **Trace the answer**: The final answer could be in one specific position of the DP table (like dp[n-1] if we have \\'n\\' states), or we may have to look through our DP table to find the answer.\\n\\nPractice is key to mastering DP. Start with simpler problems and gradually move on to more complex ones. It may be hard initially, but with enough practice, you\\'ll get the hang of it."
                    },
                    {
                        "username": "Tillu__",
                        "content": "class Solution {\npublic:\n    void util(vector<int>& nums, vector<int> curr, int i, int & maxLen){\n        if(i == nums.size()){\n            if(maxLen < curr.size()){\n                maxLen = curr.size();\n            }\n            return;\n        }\n        if(curr.size() == 0 || nums[i] > curr[curr.size() - 1]){\n            curr.push_back(nums[i]);\n            util(nums,curr,i+1,maxLen);\n            curr.pop_back();\n            util(nums,curr,i+1,maxLen);\n        }\n        else\n        util(nums,curr,i+1,maxLen);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int maxLen = INT_MIN;\n        util(nums,{},0,maxLen);\n        return maxLen;\n    }\n};\nwhy is this maxLen here isn't getting updated, being it less than curr.size() ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems fine and `maxLen` should be updated correctly as it is passed by reference into the `util` function. \\n\\nThe code is using a backtracking approach to find the longest increasing subsequence (LIS) in a given vector `nums`. It recursively checks all possible subsequences and updates `maxLen` whenever it finds a subsequence that is longer than the current `maxLen`. \\n\\nHere\\'s how it works:\\n\\n- `util(nums,{},0,maxLen)` is called from `lengthOfLIS`.\\n- This call checks if `i` equals `nums.size()`. If true, it means we\\'ve reached the end of the array, so it compares `maxLen` with the current subsequence length `curr.size()`. If `curr.size()` is larger, `maxLen` is updated to `curr.size()`.\\n- If the current index `i` hasn\\'t reached the end of the array yet, and if the current subsequence is empty or the current element `nums[i]` is larger than the last element in the subsequence, it appends the current element to the subsequence and makes a recursive call with `i+1`.\\n- Regardless of whether it appends the current element or not, it also makes a recursive call with `i+1` without appending the current element, thus exploring all possible subsequences.\\n\\nIf you\\'re experiencing issues where `maxLen` isn\\'t being updated as expected, you may want to check the input to your function or consider if there are any conditions preventing the updating branch of the code from executing."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `static int [][]dp;\\n    static int getAns(int arr[], int n,  int ind, int prev_index,int[][] dp){\\n    \\n    // base condition\\n    if(ind == n)\\n        return 0;\\n        \\n    if(dp[ind][prev_index+1]!=-1)\\n        return dp[ind][prev_index+1];\\n    \\n    int notTake = 0 + getAns(arr,n,ind+1,prev_index,dp);\\n    \\n    int take = 0;\\n    \\n    if(prev_index == -1 || arr[ind] > arr[prev_index]){\\n        take = 1 + getAns(arr,n,ind+1,ind,dp);\\n    }\\n    \\n    return dp[ind][prev_index+1] = Math.max(notTake,take);\\n}\\n    public int lengthOfLIS(int[] a) {\\n        int n=a.length;\\n        dp=new int[a.length+1][a.length+1];\\n        for(int []arr:dp)\\n            Arrays.fill(arr,-1);\\n       return getAns(a,n,0,-1,dp);\\n    }...`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "To decide if a bigger subsequence can be formed or not for the current element, I only need to know the last element of every subsequence that has been formed before. Also, we can have multiple subsequence for the same LIS size, so if we know the subsequence which has the minimum last element for each size, then it will make our job easier. To do this, we just need to know, the minimum last element for every subsequence size."
                    },
                    {
                        "username": "debabrata_gon",
                        "content": "Are they accepting Memorization solution or are they showing TLE?"
                    },
                    {
                        "username": "vinod-kumar",
                        "content": "was TLE for me"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple and understandable   code in c++\\nint lengthOfLIS(vector<int>& nums) {\\n        \\n          int n = nums.size() ;\\n\\n         \\n         int count= 1 ;\\n         vector<int>output(n,1) ; \\n\\n         for(int i =0 ; i<n ;++i)\\n         {   \\n            for(int j =i-1 ;j>=0 ;j--)\\n            {\\n                if(nums[i]<= nums[j])\\n                {\\n             continue;\\n                }\\n              int possible = 1+ output[j];\\n              \\n              if( possible > output[i])\\n              { \\n                   output[i]  =possible ;\\n\\n                   count = max( output[i], count );\\n              }\\n\\n            \\n            }\\n\\n         }\\n        \\n        return count;\\n    }"
                    },
                    {
                        "username": "yx428",
                        "content": "I did get why dp(i) = dp(j) + 1 if nums[I] > nums[j].\\nFor example, let us say we have nums =  [1,3,5,2,4,3,2].\\n\\nFor nums[3] = 2, we have dp[3] = 3 since the longest increasing subsquence before nums[3] is [1,3,5].\\n\\nBut at nums[4] = 4, why would we have dp(4) = dp(3) + 1 = 3+ 1= 4?\\nThe longest subsequence up to nums[4] = 4 is still [1,3,5], which has a length of 3, not 3+1 = 4.\\n\\nI am really confused with the DP solution. I will really appreciate it if someone can offer some clarification. \\n\\nThanks so much in advance. "
                    },
                    {
                        "username": "bparanj",
                        "content": "It seems there\\'s a slight misunderstanding regarding the nature of the dynamic programming (DP) solution for the longest increasing subsequence (LIS) problem. The key point is that each `dp[i]` stores the length of the longest increasing subsequence *ending at* `nums[i]`.\\n\\nWhen you compute `dp[i]`, you are considering all indices `j` before `i` such that `nums[j] < nums[i]`. If `nums[i]` is greater than `nums[j]`, it means that you can extend the increasing subsequence ending at `nums[j]` by appending `nums[i]`, and hence `dp[i] = dp[j] + 1`.\\n\\nIn your example, `nums = [1,3,5,2,4,3,2]`, the computation for `dp[4]` considers the sequence ending at `nums[4] = 4`. Now, we see that `4` can extend the subsequences ending at `nums[1] = 3` and `nums[3] = 2`. The subsequence ending at `nums[1]` is `[1, 3]` and the one ending at `nums[3]` is `[1, 2]`. So, the length of the longest subsequence that `4` can extend is `2 (from [1, 3]) + 1 (for 4 itself) = 3`. Therefore, `dp[4]` should be `3`, not `4`.\\n\\nSo, you\\'re correct in your assessment. The longest subsequence up to `nums[4] = 4` is indeed `[1,3,5]` and has a length of `3`, and not `4`."
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "By binary Search\\n\\nclass Solution {\\n\\n\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp= new int[n];\\n\\nint len = 1;\\n\\ndp[0] = nums[0];\\n\\nfor(int i=1; i<n; i++){\\n\\n    if(nums[i]<dp[0]){\\n       dp[0] = nums[i];\\n    }else if(nums[i]>dp[len-1]){\\n       dp[len]  =  nums[i];\\n       len++; \\n    }else{\\n       dp[binarySearch(dp,-1,len-1,nums[i])] = nums[i];\\n    }\\n}\\n\\nreturn len;\\n\\n    }\\n\\n    public int binarySearch(int[] dp,int left,int right,int target){\\n\\nwhile(right-left>1){\\n\\n    int mid = left + (right-left)/2;\\n\\n    if(dp[mid]>=target){\\n        right = mid;\\n    }else{\\n        left = mid;\\n    }\\n\\n\\n}\\nreturn right;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amanyadav6750",
                        "content": "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        \\nint n = nums.length;\\n\\nint[] dp = new int[n];\\n\\nint omax = 0;\\n\\n\\n\\nfor(int i=0; i<n; i++){\\n    int max = 0;\\n    for(int j=0; j<i; j++){\\n\\n        if(nums[j]<nums[i]){\\n            if(dp[j]>max){\\n                max = dp[j];\\n            }\\n        }\\n    }\\n\\n    dp[i] = max+1;\\n\\n    if(dp[i]>omax){\\n        omax=dp[i];\\n    }\\n\\n}\\n\\nreturn omax;\\n\\n    }\\n}"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "https://youtu.be/6Ev4dwaw4Lo\\nplease upvote if you liked it"
                    }
                ]
            }
        ]
    }
]