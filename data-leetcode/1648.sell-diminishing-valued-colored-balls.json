[
    {
        "title": "Binary Trees With Factors",
        "question_content": "Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: arr = [2,4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\n\nInput: arr = [2,4,5,10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 1000\n\t2 <= arr[i] <= 109\n\tAll the values of arr are unique.",
        "solutions": [
            {
                "id": 125794,
                "title": "c-java-python-dp-solution",
                "content": "Sort the list `A` at first. Scan `A` from small element to bigger.\\n\\nDP equation:\\n`dp[i] = sum(dp[j] * dp[i / j])`\\n`res  = sum(dp[i])`\\nwith `i, j, i / j` in the list `L`\\n\\n\\n**C++**\\n```cpp\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long)1e9 + 7;\\n        Arrays.sort(A);\\n        HashMap<Integer, Long> dp = new HashMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            dp.put(A[i], 1L);\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp.put(A[i], (dp.get(A[i]) + dp.get(A[j]) * dp.getOrDefault(A[i] / A[j], 0L)) % mod);\\n            res = (res + dp.get(A[i])) % mod;\\n        }\\n        return (int) res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def numFactoredBinaryTrees(self, A):\\n        dp = {}\\n        for a in sorted(A):\\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\\n        return sum(dp.values()) % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long)1e9 + 7;\\n        Arrays.sort(A);\\n        HashMap<Integer, Long> dp = new HashMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            dp.put(A[i], 1L);\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp.put(A[i], (dp.get(A[i]) + dp.get(A[j]) * dp.getOrDefault(A[i] / A[j], 0L)) % mod);\\n            res = (res + dp.get(A[i])) % mod;\\n        }\\n        return (int) res;\\n    }\\n```\n```py\\n    def numFactoredBinaryTrees(self, A):\\n        dp = {}\\n        for a in sorted(A):\\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126277,
                "title": "concise-java-solution-using-hashmap-with-detailed-explanation-easily-understand",
                "content": "```\\n/**sort the array\\n * and use HashMap to record each Integer, and the number of trees with that Integer as root\\n * (1) each integer A[i] will always have one tree with only itself\\n * (2) if A[i] has divisor (a) in the map, and if A[i]/a also in the map\\n *     then a can be the root of its left subtree, and A[i]/a can be the root of its right subtree;\\n *     the number of such tree is map.get(a) * map.get(A[i]/a)\\n * (3) sum over the map\\n */\\nclass Solution {    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Long> map = new HashMap();\\n        long count = 1;\\n        map.put(A[0], count);\\n        for (int i = 1; i < A.length; i++) {\\n            count = 1;\\n            for (Integer n : map.keySet()) {\\n                if (A[i] % n == 0 && map.containsKey(A[i] / n)) {\\n                    count += map.get(n) * map.get(A[i] / n);\\n                }\\n            }\\n            map.put(A[i], count);\\n        }\\n        long sum = 0;\\n        for (Integer n : map.keySet()) {\\n            sum = (sum + map.get(n)) % ((int) Math.pow(10, 9) + 7) ;\\n        }\\n        return (int) sum;\\n    }        \\n}",
                "solutionTags": [],
                "code": "class Solution {    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Long> map = new HashMap();\\n        long count = 1;\\n        map.put(A[0], count);\\n        for (int i = 1; i < A.length; i++) {\\n            count = 1;\\n            for (Integer n : map.keySet()) {\\n                if (A[i] % n == 0 && map.containsKey(A[i] / n)) {\\n                    count += map.get(n) * map.get(A[i] / n);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2399992,
                "title": "c-clean-code-explained",
                "content": "sort the array and use HashMap to record each Integer, and the number of trees with that Integer as root\\n(1) each integer A[i] will always have one tree with only itself\\n(2) if A[i] has divisor (a) in the map, and if A[i]/a also in the map then a can be the root of its left subtree, and A[i]/a can be the root of its right subtree;\\nthe number of such tree is map.get(a) * map.get(A[i]/a)\\n(3) sum over the map\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n     int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        unordered_map <int, long> rootWithCount;\\n        rootWithCount[arr[0]] = 1;\\n        for(int i = 1; i < arr.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(arr[i] % rootEle == 0 && rootWithCount.find(arr[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[arr[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[arr[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```\\n\\nTC: O(N^2)\\nSC: O(N)\\n\\n**IF YOU LIKE MY SOLUTION THEN JUST PLEASE PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        unordered_map <int, long> rootWithCount;\\n        rootWithCount[arr[0]] = 1;\\n        for(int i = 1; i < arr.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(arr[i] % rootEle == 0 && rootWithCount.find(arr[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[arr[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[arr[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400030,
                "title": "python-dp-detailed-explantion-dictionary-t-m-91-4-90-9-easy-to-understand",
                "content": "1.sort the array in ascending order\\n2.create a dictionary and initialize it\\n3.loop through the data\\n4.return sum of values\\n\\nTake this for example:\\n\\t`arr = [2, 4, 5, 10] `\\n![image](https://assets.leetcode.com/users/images/6eaaaab7-d9bc-4384-bafb-5bba4ab8ac04_1660010194.973968.png)\\n\\nCode:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please UPVOTE if you LIKE !!!**\\n![image](https://assets.leetcode.com/users/images/c6a55e6b-4ada-4103-ba39-c7a2197aee9b_1660008862.3782873.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107208,
                "title": "python-short-o-n-2-solution-explained",
                "content": "Let `dp(num)` be the answer to the question: how many binary trees exists such that their root equal to `num` and they follow the problem statement. We can calculate this number of trees, if we look at the left subtree and at the right subtree. So, first of all we create `s_arr`: set of possible values, and then for each `cand in s_arr`, we check:\\n\\n1. If `num % cand == 0`, that is number is divisible.\\n2. If `num//cand in s_arr`, that is if the second children also in set of admissible values.\\n3. We add `dp(cand)*dp(num//cand)` to `ans`, total number of trees we found. Note that we define `ans = 1`, because we can always have tree with one node.\\n\\n**Complexity**: time complexity is `O(n^2)`, because we have `n` different states and from each state we make at most `O(n)` steps. Space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        s_arr, N = set(arr), 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            ans = 1\\n            for cand in s_arr:\\n                if num % cand == 0 and num//cand in s_arr:\\n                    ans += dp(cand)*dp(num//cand)\\n            return ans\\n        \\n        return sum(dp(num) for num in s_arr) % N\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        s_arr, N = set(arr), 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            ans = 1\\n            for cand in s_arr:\\n                if num % cand == 0 and num//cand in s_arr:\\n                    ans += dp(cand)*dp(num//cand)\\n            return ans\\n        \\n        return sum(dp(num) for num in s_arr) % N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400159,
                "title": "java-easy-solution-using-hashmap",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107268,
                "title": "js-python-java-c-fastest-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick to this problem is realizing that we can break it down into smaller pieces. A number can always be a leaf, so the number of **ways** it can form a branch should always start at **1**.\\n\\nIf the number can be made from multiple factor pairs, then **ways** is our starting value of **1** plus the sum of all the ways to make those factor pairs. \\n\\nFor each existing factor pair (**fA** & **fB**), the number of ways to make that that particular pair configuration is the product of the number of ways to make **fA** and **fB**.\\n\\nSo we can see that each number relies on first solving the same question for each of its factors. This means that we should start by sorting our numbers array (**A**). Then we can iterate through **A** and figure out each number in ascending order, so that we will have completed any factors for larger numbers before we need to use them.\\n\\nThis means storing the information, which we can do in a **map**, so that we can look up the results by value.\\n\\nIn order to be more efficient when we attempt to find each factor pair, we only need to iterate through **A** up to the **square root** of the number in question, so that we don\\'t duplicate the same factor pairs going the opposite direction. That means we need to double every pair result where **fA** and **fB** are not the same.\\n\\nSince each number can be the head of a tree, our answer (**ans**) will be the sum of each number\\'s result. We shouldn\\'t forget to modulo at each round of summation.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava and C++, having typed variables, should use **long** for **ways** and **ans**, but will need to cast **ans** back to **int** before returning. They will also need an extra **continue** conditional when checking for factors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 43.8MB** (beats 100% / 82%).\\n```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)) % 1000000007\\n        }\\n        fmap.set(num, ways), ans = (ans + ways) % 1000000007\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **96ms / 14.4MB** (beats 99% / 74%).\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **10ms / 38.7MB** (beats 99% / 91%).\\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.1MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)) % 1000000007\\n        }\\n        fmap.set(num, ways), ans = (ans + ways) % 1000000007\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402569,
                "title": "python-detailed-explanation-easily-understood-dp-o-n-sqrt-n",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `DP`\\n\\nSince the parent node is the product of the children, the value of the parent nodes must larger than the values of its children.\\nThus, we can sort the `arr` first, and start to calculate the combination of products **from smallest node to the largest one**.\\nFor example, `arr = [18, 3, 6, 2]`\\nAfter sorting, `arr = [2, 3, 6, 18]`\\nThen, a dict `count_product_dict` needs to be created to store the count of combinations and all the initial values should be `1`.\\n\\n```\\nFor 2:\\n\\t- We can ignore the first number as the smallest number does not have a product of 2 smaller numbers.\\n\\nFor 3:\\n\\t- We can just scan the numbers smaller than 3\\n\\t\\t- Since 2 is larger than half of 3, it is rejected as 3 must not be a product of 2 and a integer.\\n\\nFor 6:\\n\\t- We can just scan the numbers smaller than 6\\n\\t\\t- 6 % 2 == 0 -> (2, 6 // 2)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\t\\t- 6 % 3 == 0 -> (3, 6 // 3)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\nAnd so on...\\nFinally, count_product_dict = {18: 7, 3: 1, 6: 3, 2: 1}\\n```\\n\\nCode:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\\n\\n**Time Complexity**: O(n ^ 2)\\n**Space Complexity**: O(n)\\n<br />",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nFor 2:\\n\\t- We can ignore the first number as the smallest number does not have a product of 2 smaller numbers.\\n\\nFor 3:\\n\\t- We can just scan the numbers smaller than 3\\n\\t\\t- Since 2 is larger than half of 3, it is rejected as 3 must not be a product of 2 and a integer.\\n\\nFor 6:\\n\\t- We can just scan the numbers smaller than 6\\n\\t\\t- 6 % 2 == 0 -> (2, 6 // 2)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\t\\t- 6 % 3 == 0 -> (3, 6 // 3)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\nAnd so on...\\nFinally, count_product_dict = {18: 7, 3: 1, 6: 3, 2: 1}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107269,
                "title": "binary-trees-with-factors-js-python-java-c-fastest-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick to this problem is realizing that we can break it down into smaller pieces. A number can always be a leaf, so the number of **ways** it can form a branch should always start at **1**.\\n\\nIf the number can be made from multiple factor pairs, then **ways** is our starting value of **1** plus the sum of all the ways to make those factor pairs. \\n\\nFor each existing factor pair (**fA** & **fB**), the number of ways to make that that particular pair configuration is the product of the number of ways to make **fA** and **fB**.\\n\\nSo we can see that each number relies on first solving the same question for each of its factors. This means that we should start by sorting our numbers array (**A**). Then we can iterate through **A** and figure out each number in ascending order, so that we will have completed any factors for larger numbers before we need to use them.\\n\\nThis means storing the information, which we can do in a **map**, so that we can look up the results by value.\\n\\nIn order to be more efficient when we attempt to find each factor pair, we only need to iterate through **A** up to the **square root** of the number in question, so that we don\\'t duplicate the same factor pairs going the opposite direction. That means we need to double every pair result where **fA** and **fB** are not the same.\\n\\nSince each number can be the head of a tree, our answer (**ans**) will be the sum of each number\\'s result. We shouldn\\'t forget to modulo at each round of summation.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava and C++, having typed variables, should use **long** for **ways** and **ans**, but will need to cast **ans** back to **int** before returning. They will also need an extra **continue** conditional when checking for factors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 43.8MB** (beats 100% / 82%).\\n```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways += fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)\\n        }\\n        fmap.set(num, ways), ans += ways\\n    }\\n    return ans % 1000000007\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **96ms / 14.4MB** (beats 99% / 74%).\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **10ms / 38.7MB** (beats 99% / 91%).\\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways += fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2);\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.1MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways += fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2);\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways += fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)\\n        }\\n        fmap.set(num, ways), ans += ways\\n    }\\n    return ans % 1000000007\\n};\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways += fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2);\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways += fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2);\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400901,
                "title": "simple-short-c-explained-solution-by-mr-coder",
                "content": "**\\u2190\\u2190Must Not Forget To Upvote this by clicking up side arrow**\\n**YOU CAN WATCH THIS VIDEO FOR THE BETTER EXPLANATION**\\n**Recommended- **\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ll ans =0;\\n        unordered_map<ll, ll> up;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i< arr.size(); i++){\\n            ll currentans=1;\\n            for(int j=0; j< i; j++)\\n            {\\n                if(arr[i]% arr[j]) continue;\\n                int ans1= arr[i]/ arr[j];\\n               int ans2=  arr[j];\\n                currentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n                \\n                \\n            }\\n            up[arr[i]]= currentans;\\n            ans = ans+ currentans;\\n            \\n        }\\n        return ans% MOD;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ll ans =0;\\n        unordered_map<ll, ll> up;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i< arr.size(); i++){\\n            ll currentans=1;\\n            for(int j=0; j< i; j++)\\n            {\\n                if(arr[i]% arr[j]) continue;\\n                int ans1= arr[i]/ arr[j];\\n               int ans2=  arr[j];\\n                currentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n                \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1376361,
                "title": "python-top-down-dp-clean-concise-o-n-2",
                "content": "**Idea**\\n- Convert `arr` into `arrSet` to we can check if an element exists in array in `O(1)`.\\n- Let `dp(root)` is number of binary trees which has root with value `root` and follow the problem rules.\\n- To calculate `dp(root)`\\n\\t- We try `cand` in `arrSet`:\\n\\t\\t- If `root % cand == 0` and `root // cand` in `arrSet`, then we can form a valid binary tree with values of 2 children nodes are `cand` and `root // cand`, so\\n\\t\\t\\t- Number of valid increase by `dp(cand) * dp(root // cand)`\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        MOD = 10**9+7\\n        arrSet = set(arr)\\n        \\n        @lru_cache(None)\\n        def dp(root):\\n            ans = 1\\n            for cand in arrSet:\\n                if root % cand == 0 and (root // cand) in arrSet:\\n                    ans += dp(cand) * dp(root // cand)\\n                    ans %= MOD\\n            return ans\\n        \\n        return sum(dp(x) for x in arrSet) % MOD\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is number of elements in the array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        MOD = 10**9+7\\n        arrSet = set(arr)\\n        \\n        @lru_cache(None)\\n        def dp(root):\\n            ans = 1\\n            for cand in arrSet:\\n                if root % cand == 0 and (root // cand) in arrSet:\\n                    ans += dp(cand) * dp(root // cand)\\n                    ans %= MOD\\n            return ans\\n        \\n        return sum(dp(x) for x in arrSet) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107283,
                "title": "python-dp",
                "content": "As we are counting a large number of trees it\\'s not a surprise this is dynamic programming. There\\'s some structure in the problem and we need to represent in in our DP. Here is how it proceeds: First sort the array (they don\\'t sort it for you, so help yourself). \\n\\nNow at every step we want to find the number of trees that end at value `x`. For that we consider every `y < x`. If `z = x//y` is such that `z*y = x` we can have `dp[y]*dp[z]` amount of trees that have children `y` and `z` and root `x`. Furthermore the set of `y,z` we consider are disjoint so we can sum them up to find all trees that end at root `z`. We used the two basic rules of counting: sum and product rules. It is important to note the pairs of `y,z` are disjoint, so that we can use simple summation (and not the Principle of Inclusion and Exclusion). We are left with one final question: we have `x`, we have `y`. How can we quickly access the counts for `z`? If we use the python built-in defaultdict, then if `z` cannot be achieved its count will be 0 and the product will evaluate to 0. This leads to the following short solution.\\n\\nIt\\'s trickier than it appears...\\n\\nNote: Also the question statement is ambiguous, as if you have a tree like `7 -> 7 -> 7 -> ... ` the one-children \"product\" is always the same as root, and the solution is always infinite. So it has to be noted that to be a valid product you need to have both children nodes. \\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        arr.sort()\\n        \\n        dp = collections.defaultdict(int)\\n        for x in arr:\\n            dp[x] = 1\\n        \\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                x, y, z = arr[i], arr[j], arr[i]//arr[j]\\n                if y*z == x:\\n                    dp[x] += dp[y]*dp[z]\\n                \\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        arr.sort()\\n        \\n        dp = collections.defaultdict(int)\\n        for x in arr:\\n            dp[x] = 1\\n        \\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                x, y, z = arr[i], arr[j], arr[i]//arr[j]\\n                if y*z == x:\\n                    dp[x] += dp[y]*dp[z]\\n                \\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637537,
                "title": "faqs-about-binary-trees-with-factors",
                "content": "Providing you some of the *Frequently Asked Questions* for this question.\\nI arranged the questions from less to more (frequency).\\nIf you don\\'t know about the solution please have a look at it before reading FAQs. I have attached it below!\\n\\n**Why hashmap?**\\nBecause we need to store count of trees which can be made with corresponding values of array.\\n\\n**Why count is initially mapped as 1?**\\nSince single element can make a tree!\\n\\n**Why sorted? (Most Frequently Asked Question)**\\nInorder to understand this answer, we need to look at another question (Follow up)\\n\\n**`Why it is A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end() ?`**\\n**`Why  A[i] % rootEle == 0 ? `**\\n We have to check whether any rootEle (previously stored value in hashmap) is a factor of A[i]. \\n As per the question, For a element to be valid root, we should have two childrens whose product is equal to root.\\n \\n*If we need to get element by multipling any two numbers, atleast one of it has to be its factor.*\\n **Example: Root -> 10; Childrens -> 5, 2 Both 5 and 2 are factors.**\\n \\n**` Why rootWithCount.find(A[i] / rootEle) != rootWithCount.end() ?`**\\n We found rootEle as a factor, is there are any element in the map, so that they multiplies to give the root value.\\n \\n Now coming back to our question (why sorted)\\n \\n **For every number, their factors will be less than it**. SIMPLE SO SORTED.\\n\\n\\n**Upvote. It would be encouraging.** Correct me if am wrong!\\n\\nHere is my C++ version of @Self_Learner Solution!\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        unordered_map <int, long> rootWithCount;\\n        \\n        rootWithCount[A[0]] = 1;\\n        for(int i = 1; i < A.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[A[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[A[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        unordered_map <int, long> rootWithCount;\\n        \\n        rootWithCount[A[0]] = 1;\\n        for(int i = 1; i < A.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[A[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[A[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126016,
                "title": "short-simple-python",
                "content": "My `t[a]` tells the number of trees with root value `a`. The `1` is for making a leaf (there\\'s one way to make a leaf with that value), the `sum` is for non-leaves (go over every possible left child value `b`).\\n\\n    def numFactoredBinaryTrees(self, A):\\n        t = {}\\n        for a in sorted(A):\\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\\n        return sum(t.values()) % (10**9 + 7)\\n",
                "solutionTags": [],
                "code": "My `t[a]` tells the number of trees with root value `a`. The `1` is for making a leaf (there\\'s one way to make a leaf with that value), the `sum` is for non-leaves (go over every possible left child value `b`).\\n\\n    def numFactoredBinaryTrees(self, A):\\n        t = {}\\n        for a in sorted(A):\\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\\n        return sum(t.values()) % (10**9 + 7)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2400378,
                "title": "c-dp-two-pointers-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int res = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int target = arr[i];\\n            int p = 0, q = i - 1; \\n            long ways = 1;\\n            while(p <= q)\\n            {\\n                long mul = (((long)arr[p]) * (arr[q]));\\n                if (mul == target) \\n                {\\n                    if (p == q) ways += (dp[p] * dp[q]) % mod;\\n                    else ways += ((dp[p] * dp[q]) * 2) % mod;\\n                    p++;\\n                    q--;\\n                }\\n                else if (mul < target) p++;\\n                else if (mul > target) q--;\\n            }\\n            dp[i] = ways;\\n            res  = (int)((res + dp[i]) % mod);\\n        }\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int res = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int target = arr[i];\\n            int p = 0, q = i - 1; \\n            long ways = 1;\\n            while(p <= q)\\n            {\\n                long mul = (((long)arr[p]) * (arr[q]));\\n                if (mul == target) \\n                {\\n                    if (p == q) ways += (dp[p] * dp[q]) % mod;\\n                    else ways += ((dp[p] * dp[q]) * 2) % mod;\\n                    p++;\\n                    q--;\\n                }\\n                else if (mul < target) p++;\\n                else if (mul > target) q--;\\n            }\\n            dp[i] = ways;\\n            res  = (int)((res + dp[i]) % mod);\\n        }\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401187,
                "title": "c-memoized-recursive-code",
                "content": "The readability of the code has somewhat decreased but still i will try explaning:\\n1. we sort the array to reduce the extra time in the for loop for bigger numbers than the number we want to find factors of. \\n2. we store the elements in a set so that accesing them will be simpler.\\n3. run the loop for each element and calculate the no of trees which can be formed.\\n4. Jumping to the helper function.\\n5. we keep the initial count as 1 , as we can form a tree of singlr node always.\\n6. then iterate over the array, check if the number we are on is smaller than the number we need find factors of else we break the loop.\\n7. then we check for its factors and see if they are present on the set if yes we call the helper function for the subtrees.\\n8. return the total count.\\n9. we use a map to memoize the code and store the results and return directly when a similar tree or subtree is formed.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long helper(vector<int> & arr,unordered_map<int,long long> &m,unordered_set<int> &st, int i)\\n    {\\n        if(m.find(i)!=m.end())\\n            return m[i];\\n        long long cnt =1;\\n        for(auto it:  arr)\\n        {\\n            if(it>i)\\n                break;\\n            if(i%it==0 && st.find(i/it)!=st.end())\\n                cnt= cnt%mod + (helper(arr,m,st,i/it)%mod)*(helper(arr,m,st,it)%mod);\\n        }\\n        return m[i]=cnt%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long> m;\\n        unordered_set<int> st;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr)\\n            st.insert(it);\\n        int ans=0;\\n        for(auto it : arr)\\n            ans = ans%mod + helper(arr,m,st,it)%mod;\\n        return ans%mod;\\n    }\\n};\\n```\\n**THANKS  FOR READING IF YOU DID I\\'M JUST TRYING TO GET BETTER AT EXPLANING THINGS.**\\n![image](https://assets.leetcode.com/users/images/274ca368-21b2-4830-a9ea-d278020fdc90_1660030690.2098832.jpeg)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long helper(vector<int> & arr,unordered_map<int,long long> &m,unordered_set<int> &st, int i)\\n    {\\n        if(m.find(i)!=m.end())\\n            return m[i];\\n        long long cnt =1;\\n        for(auto it:  arr)\\n        {\\n            if(it>i)\\n                break;\\n            if(i%it==0 && st.find(i/it)!=st.end())\\n                cnt= cnt%mod + (helper(arr,m,st,i/it)%mod)*(helper(arr,m,st,it)%mod);\\n        }\\n        return m[i]=cnt%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long> m;\\n        unordered_set<int> st;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr)\\n            st.insert(it);\\n        int ans=0;\\n        for(auto it : arr)\\n            ans = ans%mod + helper(arr,m,st,it)%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126261,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nFor each candidate root `x` of the input array `A`, consider `x = y * z` where `y` and `z` are candidates for the left/right subtrees of `x`, ie. we use the rule-of-product to accumulate the count `cnt` of subtrees, initially set to 1 for `x` as a tree comprised of a single root node.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        fun go(x: Int): Long {\\n            var cnt = 1L\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (seen.contains(z))\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            }\\n            return cnt\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(x: Int): Long {\\n            if (!m.contains(x)) {\\n                var cnt = 1L\\n                for (y in A) {\\n                    if (x % y != 0)\\n                        continue\\n                    var z = x / y\\n                    if (seen.contains(z))\\n                        cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n                }\\n                m[x] = cnt\\n            }\\n            return m[x]!!\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        for (x in A)\\n            m[x] = 1L\\n        A.sort()\\n        for (x in A) {\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (z in seen)\\n                    m[x] = (m[x]!! + (m[y]!! * m[z]!! % MOD)) % MOD\\n            }\\n        }\\n        var t = 0L\\n        for ((_, cnt) in m)\\n            t = (t + cnt) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), t = 0) => {\\n    let go = x => {\\n        let cnt = 1;\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n        }\\n        return cnt;\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    let go = x => {\\n        if (!m.has(x)) {\\n            let cnt = 1;\\n            for (let y of A) {\\n                if (x % y)\\n                    continue;\\n                let z = Math.floor(x / y);\\n                if (seen.has(z))\\n                    cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n            }\\n            m.set(x, cnt);\\n        }\\n        return m.get(x);\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A) {\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                m.set(x, m.get(x) + (m.get(y) * m.get(z) % MOD) % MOD);\\n        }\\n    }\\n    for (let [_, cnt] of m)\\n        t = (t + cnt) % MOD;\\n    return t;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        @cache\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7)) -> int:\\n        seen = set(A)\\n        m = {x: 1 for x in A}\\n        A.sort()\\n        for x in A:\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD)) % MOD\\n        return sum(m.values()) % MOD\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>) -> i64 {\\n            let MOD = (1e9 as i64 + 7);\\n            let mut cnt = 1 as i64;\\n            for y in A {\\n                if x % y != 0 {\\n                    continue;\\n                }\\n                let z = x / y;\\n                if seen.contains(&z) {\\n                    cnt = (cnt + go(A, *y, seen) * go(A, z, seen) % MOD) % MOD;\\n                }\\n            }\\n            return cnt;\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        let mut m = HashMap::new();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>, m: &mut HashMap<i32, i64>) -> i64 {\\n            if !m.contains_key(&x) {\\n                let MOD = (1e9 as i64 + 7);\\n                let mut cnt = 1 as i64;\\n                for y in A {\\n                    if x % y != 0 {\\n                        continue;\\n                    }\\n                    let z = x / y;\\n                    if seen.contains(&z) {\\n                        cnt = (cnt + go(A, *y, seen, m) * go(A, z, seen, m) % MOD) % MOD;\\n                    }\\n                }\\n                m.insert(x.clone(), cnt);\\n            }\\n            *m.get(&x).unwrap()\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen, &mut m)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\n// TODO: implement me!\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            auto cnt = 1LL;\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n            }\\n            return cnt;\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            if (m.find(x) == m.end()) {\\n                auto cnt = 1LL;\\n                for (auto y: A) {\\n                    if (x % y)\\n                        continue;\\n                    auto z = x / y;\\n                    if (seen.find(z) != seen.end())\\n                        cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n                }\\n                m[x] = cnt;\\n            }\\n            return m[x];\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        sort(A.begin(), A.end());\\n        for (auto x: A)\\n            m[x] = 1LL;\\n        for (auto x: A) {\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD) % MOD);\\n            }\\n        }\\n        for (auto [_, cnt]: m)\\n            t = (t + cnt) % MOD;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        fun go(x: Int): Long {\\n            var cnt = 1L\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (seen.contains(z))\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            }\\n            return cnt\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(x: Int): Long {\\n            if (!m.contains(x)) {\\n                var cnt = 1L\\n                for (y in A) {\\n                    if (x % y != 0)\\n                        continue\\n                    var z = x / y\\n                    if (seen.contains(z))\\n                        cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n                }\\n                m[x] = cnt\\n            }\\n            return m[x]!!\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        for (x in A)\\n            m[x] = 1L\\n        A.sort()\\n        for (x in A) {\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (z in seen)\\n                    m[x] = (m[x]!! + (m[y]!! * m[z]!! % MOD)) % MOD\\n            }\\n        }\\n        var t = 0L\\n        for ((_, cnt) in m)\\n            t = (t + cnt) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), t = 0) => {\\n    let go = x => {\\n        let cnt = 1;\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n        }\\n        return cnt;\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    let go = x => {\\n        if (!m.has(x)) {\\n            let cnt = 1;\\n            for (let y of A) {\\n                if (x % y)\\n                    continue;\\n                let z = Math.floor(x / y);\\n                if (seen.has(z))\\n                    cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n            }\\n            m.set(x, cnt);\\n        }\\n        return m.get(x);\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A) {\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                m.set(x, m.get(x) + (m.get(y) * m.get(z) % MOD) % MOD);\\n        }\\n    }\\n    for (let [_, cnt] of m)\\n        t = (t + cnt) % MOD;\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        @cache\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7)) -> int:\\n        seen = set(A)\\n        m = {x: 1 for x in A}\\n        A.sort()\\n        for x in A:\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD)) % MOD\\n        return sum(m.values()) % MOD\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>) -> i64 {\\n            let MOD = (1e9 as i64 + 7);\\n            let mut cnt = 1 as i64;\\n            for y in A {\\n                if x % y != 0 {\\n                    continue;\\n                }\\n                let z = x / y;\\n                if seen.contains(&z) {\\n                    cnt = (cnt + go(A, *y, seen) * go(A, z, seen) % MOD) % MOD;\\n                }\\n            }\\n            return cnt;\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        let mut m = HashMap::new();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>, m: &mut HashMap<i32, i64>) -> i64 {\\n            if !m.contains_key(&x) {\\n                let MOD = (1e9 as i64 + 7);\\n                let mut cnt = 1 as i64;\\n                for y in A {\\n                    if x % y != 0 {\\n                        continue;\\n                    }\\n                    let z = x / y;\\n                    if seen.contains(&z) {\\n                        cnt = (cnt + go(A, *y, seen, m) * go(A, z, seen, m) % MOD) % MOD;\\n                    }\\n                }\\n                m.insert(x.clone(), cnt);\\n            }\\n            *m.get(&x).unwrap()\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen, &mut m)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            auto cnt = 1LL;\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n            }\\n            return cnt;\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            if (m.find(x) == m.end()) {\\n                auto cnt = 1LL;\\n                for (auto y: A) {\\n                    if (x % y)\\n                        continue;\\n                    auto z = x / y;\\n                    if (seen.find(z) != seen.end())\\n                        cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n                }\\n                m[x] = cnt;\\n            }\\n            return m[x];\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        sort(A.begin(), A.end());\\n        for (auto x: A)\\n            m[x] = 1LL;\\n        for (auto x: A) {\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD) % MOD);\\n            }\\n        }\\n        for (auto [_, cnt]: m)\\n            t = (t + cnt) % MOD;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125815,
                "title": "java-accepted-solution",
                "content": "for num `i`, if `m * n == i`, number of trees for `i` is `1 + count(m) * count(n)`, means root `i` self, add number of trees when `m` is root times number of trees when `n` is root.\\n```\\n    public int numFactoredBinaryTrees(int[] A) {\\n        if(A==null || A.length==0)\\n            return 0;\\n        Map<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for(int i=0; i<A.length; i++){\\n            long count = 1;\\n            for(int j=0; j<i; j++){\\n                if(A[i]%A[j]==0 && map.containsKey(A[i]/A[j])){\\n                    count += map.get(A[i]/A[j]) * map.get(A[j]);\\n                }\\n            }\\n            map.put(A[i],count);\\n        }\\n        long sum = 0;\\n        for(long cnt : map.values())\\n            sum += cnt;\\n        return (int) (sum % (Math.pow(10,9) + 7));\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int numFactoredBinaryTrees(int[] A) {\\n        if(A==null || A.length==0)\\n            return 0;\\n        Map<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for(int i=0; i<A.length; i++){\\n            long count = 1;\\n            for(int j=0; j<i; j++){\\n                if(A[i]%A[j]==0 && map.containsKey(A[i]/A[j])){\\n                    count += map.get(A[i]/A[j]) * map.get(A[j]);\\n                }\\n            }\\n            map.put(A[i],count);\\n        }\\n        long sum = 0;\\n        for(long cnt : map.values())\\n            sum += cnt;\\n        return (int) (sum % (Math.pow(10,9) + 7));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400089,
                "title": "recursive-memo-c-java-detailed-explanation",
                "content": "**C++**\\n**Recursive Solution**\\n\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_set<int> st;\\nprivate:\\n    int factorCount(int root)\\n    {\\n        // count = 1 , root element will also be our one of the ans\\n        int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Recursion + Memoization**\\n\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_map<int, long long int> dp;\\n    unordered_set<int> st;\\nprivate:\\n    long long int factorCount(int root)\\n    {\\n        // check in dp, if count has been calculated already for this root\\n        if(dp.count(root))\\n            return dp[root];\\n        \\n        // count = 1 , root element will also be our one of the ans\\n        long long int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return dp[root] = count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n                \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Java (Recursion + Memo)**\\n```\\nclass Solution {\\n    private int mod = (int) 1e9 + 7;\\n    Set<Integer> st = new HashSet<>();\\n    Map<Integer, Long> dp = new HashMap<>();\\n    \\n    \\n    private long factorCount(int root)\\n    {\\n        if(dp.containsKey(root))\\n            return dp.get(root);\\n        \\n        // considering root as well into count, so only count = 1\\n        long count = 1;\\n        \\n        for(int val : st)\\n        {\\n            // check if its divisible or not\\n            if(root % val != 0) continue;\\n            \\n            int factor1 = val, factor2 = root/val;\\n            \\n            // check factors are in set\\n            if(st.contains(factor2))\\n            {\\n                // call recursively for its factors\\n                count += factorCount(val) * factorCount(factor2);\\n                count %= mod;\\n            }\\n        }\\n        \\n        // insert into map\\n        dp.put(root, count);\\n        \\n        return count;\\n    }\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        // add elements in set\\n        for(int val : arr)\\n            st.add(val);\\n        \\n        int res = 0;\\n        \\n        // iterate each element in arr, consider as root\\n        for(int curVal : arr)\\n        {\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_set<int> st;\\nprivate:\\n    int factorCount(int root)\\n    {\\n        // count = 1 , root element will also be our one of the ans\\n        int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_map<int, long long int> dp;\\n    unordered_set<int> st;\\nprivate:\\n    long long int factorCount(int root)\\n    {\\n        // check in dp, if count has been calculated already for this root\\n        if(dp.count(root))\\n            return dp[root];\\n        \\n        // count = 1 , root element will also be our one of the ans\\n        long long int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return dp[root] = count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n                \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int mod = (int) 1e9 + 7;\\n    Set<Integer> st = new HashSet<>();\\n    Map<Integer, Long> dp = new HashMap<>();\\n    \\n    \\n    private long factorCount(int root)\\n    {\\n        if(dp.containsKey(root))\\n            return dp.get(root);\\n        \\n        // considering root as well into count, so only count = 1\\n        long count = 1;\\n        \\n        for(int val : st)\\n        {\\n            // check if its divisible or not\\n            if(root % val != 0) continue;\\n            \\n            int factor1 = val, factor2 = root/val;\\n            \\n            // check factors are in set\\n            if(st.contains(factor2))\\n            {\\n                // call recursively for its factors\\n                count += factorCount(val) * factorCount(factor2);\\n                count %= mod;\\n            }\\n        }\\n        \\n        // insert into map\\n        dp.put(root, count);\\n        \\n        return count;\\n    }\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        // add elements in set\\n        for(int val : arr)\\n            st.add(val);\\n        \\n        int res = 0;\\n        \\n        // iterate each element in arr, consider as root\\n        for(int curVal : arr)\\n        {\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450830,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401118,
                "title": "c-2-approach-2-pointer-linear-and-map-find-dynamic-programming-maths",
                "content": "\\n\\nLet\\'s understand 2 basic things \\n\\n1. For any node, it can be root with total nodes in tree as 1 \\n2. If a root is having child1 and child2 as their left and right chidren then answer for that node as root of tree is 1 + (child1 as root * child2 as root)\\n\\n\\nThe basic idea is to store the no of trees that can be formed having node as the root, then we can solve the problem very easily\\nSo for any node we will find the children and update the answer as (ans(child1) * ans(child2) + 1)\\n\\nWe are adding 1 because each node can form a tree having itself as root and having no children\\n\\n**Okay so how to search the factors?**\\n\\n1. One way can be like we can create all factor pairs for the number and search it inside the map, but can you guess, how time consuming this process can be\\n2. The other way is that we can sort the array the if index i is that number, then we can clearly say that its factors lies from 0 to i-1 because any number in array greater than ith index will be greater than the number so we don\\'t need to look after that\\n\\n\\n**Now again how can we find the factors in 0 to i-1?**\\nAgain there are 2 ways\\n1. we iterate j  from  0 to i-1 and check wheather number is divided by arr[j], if it is divided then it is one of the factors then the other factor will be number / arr[j], as arr[j]*other factor = number, we find that the other factor is present in map or not\\n2. The other way is that we can have a 2-pointer search from 0 to i-1 \\n\\t\\tleft = 0 and right = i-1\\n\\t\\twe do a 2-pointer search and find that when arr[left]*arr[right] == number, then arr[left] and arr[right] are the factors \\n\\t\\there is also a crunch, in step 1 let us suppose [2, 5, 10 ], we will calculare answer for 2 and 5 saperately\\n\\t\\tbut in this case if we have child1 and child2 then we will directly multiply answer by 2 because [root, child1, child2] and [root, child2, child1] have same answer\\n\\n\\n\\nAlgorithm -\\n1. create an unordered map mp to store the answer for each particular node\\n2. sort the array for factors search\\n3. iterate the array and mp[arr[i]] = 1\\n\\tsearch the factor, if factor is fiund then update mp[arr[i]] = product of the answers of both the children for linear search and when doing 2-pointer search update the answer as mp[arr[i]] = product of answers of chilren * 2\\n\\n4. add mp[arr[i]] to answer \\n5. return answer\\n\\n\\n\\n\\n\\n\\n\\nLinear search Code\\n\\n\\n\\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            for(int j = 0 ; j < i ; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    int child1 = arr[j];\\n                    int child2 = arr[i]/arr[j];\\n                    if(mp.find(child2) != mp.end()){\\n                        mp[arr[i]] += (mp[child1] * mp[child2])%mod;\\n                        mp[arr[i]] %= mod;\\n                    }\\n                }\\n            }\\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\\n\\n\\n2-pointer Search Code\\n\\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left <= right){\\n                long long child1 = arr[left];\\n                long long child2 = arr[right];\\n                long long product = (child1 * child2);\\n                if(product == arr[i]){\\n                   if(left == right){\\n\\t\\t\\t\\t\\t   mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] )%mod;   \\n                   }\\n                  else{\\n                       mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] * 2)%mod;\\n                        \\n                    }\\n                  mp[arr[i]] %= mod;\\n                  left += 1;\\n                  right -= 1;\\n                }\\n                \\n             if(product < arr[i]){\\n                    left += 1;\\n             }\\n             else if(product > arr[i]){\\n                    right -= 1;\\n             }\\n           }\\n            \\n            \\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\\nBoth the approaches have same time complexity\\n\\nTime Complexity - O(N*N) \\nSpace Complexity - O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            for(int j = 0 ; j < i ; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    int child1 = arr[j];\\n                    int child2 = arr[i]/arr[j];\\n                    if(mp.find(child2) != mp.end()){\\n                        mp[arr[i]] += (mp[child1] * mp[child2])%mod;\\n                        mp[arr[i]] %= mod;\\n                    }\\n                }\\n            }\\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left <= right){\\n                long long child1 = arr[left];\\n                long long child2 = arr[right];\\n                long long product = (child1 * child2);\\n                if(product == arr[i]){\\n                   if(left == right){\\n\\t\\t\\t\\t\\t   mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] )%mod;   \\n                   }\\n                  else{\\n                       mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] * 2)%mod;\\n                        \\n                    }\\n                  mp[arr[i]] %= mod;\\n                  left += 1;\\n                  right -= 1;\\n                }\\n                \\n             if(product < arr[i]){\\n                    left += 1;\\n             }\\n             else if(product > arr[i]){\\n                    right -= 1;\\n             }\\n           }\\n            \\n            \\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400129,
                "title": "c-dp-map-easy-understanding",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        vector < long long > dp(arr.size(), 1);\\n        unordered_map<int, int> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            mp[arr[i]] = i;//store the index of various elements of the array\\n            for (int j = i - 1; j >= 0; j--)\\n            {\\n                if (arr[i] % arr[j] == 0)//to check whether arr[j] is a factor of arr[i] or not\\n                {\\n                    int temp = arr[i] / arr[j];\\n                    if (mp.count(temp)) dp[i] += (dp[j] *dp[mp[temp]]) % mod;//check the presence of the required no in map, If it is in the map then increase dp[i] by the product of the dp[j] and dp[mp[temp]] taking the modulus\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        ans = accumulate(dp.begin(), dp.end(), 0LL);\\n        return ans%mod;//return toatl sum after taking modulus\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        vector < long long > dp(arr.size(), 1);\\n        unordered_map<int, int> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            mp[arr[i]] = i;//store the index of various elements of the array\\n            for (int j = i - 1; j >= 0; j--)\\n            {\\n                if (arr[i] % arr[j] == 0)//to check whether arr[j] is a factor of arr[i] or not\\n                {\\n                    int temp = arr[i] / arr[j];\\n                    if (mp.count(temp)) dp[i] += (dp[j] *dp[mp[temp]]) % mod;//check the presence of the required no in map, If it is in the map then increase dp[i] by the product of the dp[j] and dp[mp[temp]] taking the modulus\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        ans = accumulate(dp.begin(), dp.end(), 0LL);\\n        return ans%mod;//return toatl sum after taking modulus\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400037,
                "title": "c-dp-maps",
                "content": "\\t\\t// Provided logic comprises of working with factors of given number ans storing them in a hashmap which helps to achieve dynamic programming \\n\\t\\t// Initially we create a map and keep on updating frequency as 1 for all elements in the given array, indicating that every element forms an independent tree\\n\\t\\t// Further we traverse through the whole array to check the factors of the element\\n\\t\\t// If we find one factor we have to check whether there is another factor available in the given array, whose product with current factor is the current element\\n\\t\\t// If we find such a pair then we multiply number of trees of both the elements and finally multiply it with 2 becasue one node can have 2 possibilities of trees, and add it to the number of trees of current element\\n\\t\\t// Further we check whether the square root of element is there or not, if it exists then we multiply the square root with itself and add it to number of trees\\n\\t\\t// Finally we calculate total number of trees for all elements and the above dicussed logic satisfies all the test cases\\n\\t\\tint mod = 1000000007;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tmap<int, long long> mp;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tfor(auto i:arr){\\n\\t\\t\\t\\tmp[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tfor(int j=2;j<sqrt(arr[i]);j++){\\n\\t\\t\\t\\t\\tif(arr[i]%j == 0 and (j * (arr[i]/j) == arr[i])){\\n\\t\\t\\t\\t\\t\\tif(mp.find(j)!=mp.end() and mp.find(arr[i]/j)!=mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[arr[i]]+= (((((mp[j]%mod)*(mp[arr[i]/j]%mod))%mod)*2)%mod);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(int(sqrt(arr[i]))*int(sqrt(arr[i])) == arr[i] and mp.find(sqrt(arr[i]))!=mp.end()){\\n\\t\\t\\t\\t\\tmp[arr[i]]+= (((mp[sqrt(arr[i])]%mod)*(mp[sqrt(arr[i])])%mod)%mod);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//here int gives wrong answer since the number of trees can exceed the integer \\n\\t\\t\\tlong s = 0;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\ts+= (i.second);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//mod of the final answer else it does not return an integer\\n\\t\\t\\treturn s%mod;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\t\\t// Provided logic comprises of working with factors of given number ans storing them in a hashmap which helps to achieve dynamic programming \\n\\t\\t// Initially we create a map and keep on updating frequency as 1 for all elements in the given array, indicating that every element forms an independent tree\\n\\t\\t// Further we traverse through the whole array to check the factors of the element\\n\\t\\t// If we find one factor we have to check whether there is another factor available in the given array, whose product with current factor is the current element\\n\\t\\t// If we find such a pair then we multiply number of trees of both the elements and finally multiply it with 2 becasue one node can have 2 possibilities of trees, and add it to the number of trees of current element\\n\\t\\t// Further we check whether the square root of element is there or not, if it exists then we multiply the square root with itself and add it to number of trees\\n\\t\\t// Finally we calculate total number of trees for all elements and the above dicussed logic satisfies all the test cases\\n\\t\\tint mod = 1000000007;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tmap<int, long long> mp;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tfor(auto i:arr){\\n\\t\\t\\t\\tmp[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tfor(int j=2;j<sqrt(arr[i]);j++){\\n\\t\\t\\t\\t\\tif(arr[i]%j == 0 and (j * (arr[i]/j) == arr[i])){\\n\\t\\t\\t\\t\\t\\tif(mp.find(j)!=mp.end() and mp.find(arr[i]/j)!=mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[arr[i]]+= (((((mp[j]%mod)*(mp[arr[i]/j]%mod))%mod)*2)%mod);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(int(sqrt(arr[i]))*int(sqrt(arr[i])) == arr[i] and mp.find(sqrt(arr[i]))!=mp.end()){\\n\\t\\t\\t\\t\\tmp[arr[i]]+= (((mp[sqrt(arr[i])]%mod)*(mp[sqrt(arr[i])])%mod)%mod);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//here int gives wrong answer since the number of trees can exceed the integer \\n\\t\\t\\tlong s = 0;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\ts+= (i.second);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//mod of the final answer else it does not return an integer\\n\\t\\t\\treturn s%mod;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2430958,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400249,
                "title": "c-based-on-concept-of-two-sum-really-easy-solution-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399859,
                "title": "daily-leetcoding-challenge-august-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-trees-with-factors/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-trees-with-factors/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1109498,
                "title": "c-clear-clean-understandable-solution",
                "content": "m stores for each integer in arr the count of binarytrees\\n  that can be represented when this integer is the head\\n\\n**Python**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        m = {}\\n        res = 0\\n        \\n        arr.sort()\\n        \\n        for head in arr:\\n            m[head] = 1\\n            for child1 in m.keys():\\n                child2 = head / child1\\n                if child2 in m:\\n                    tmp = (m[child1] * m[child2]) % mod\\n                    m[head] = (m[head] + tmp) % mod\\n                    \\n            res = (res + m[head]) % mod\\n            \\n        return res\\n```\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1e9 + 7;\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (int head : arr)\\n        {\\n            m[head] = 1;\\n            for (auto [child1, value] : m)\\n            {\\n                int child2 = head / child1;\\n                if (child1 *child2 == head && m.find(child2) != m.end())\\n                {\\n                    long tmp = ((long)m[child1] * (long)m[child2]) % mod;\\n                    m[head] = (m[head] + tmp) % mod;\\n                }\\n            }\\n            res = (res + m[head]) % mod;\\n        }\\n       \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        m = {}\\n        res = 0\\n        \\n        arr.sort()\\n        \\n        for head in arr:\\n            m[head] = 1\\n            for child1 in m.keys():\\n                child2 = head / child1\\n                if child2 in m:\\n                    tmp = (m[child1] * m[child2]) % mod\\n                    m[head] = (m[head] + tmp) % mod\\n                    \\n            res = (res + m[head]) % mod\\n            \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1e9 + 7;\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (int head : arr)\\n        {\\n            m[head] = 1;\\n            for (auto [child1, value] : m)\\n            {\\n                int child2 = head / child1;\\n                if (child1 *child2 == head && m.find(child2) != m.end())\\n                {\\n                    long tmp = ((long)m[child1] * (long)m[child2]) % mod;\\n                    m[head] = (m[head] + tmp) % mod;\\n                }\\n            }\\n            res = (res + m[head]) % mod;\\n        }\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107571,
                "title": "c-100-faster-95-space-efficient-easy-and-direct-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int size_ = arr.size();\\n        unordered_map<int, unsigned long long> umap_;\\n        int total = 0;\\n        int MOD = 1000000007;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < size_; i++) {\\n            int curr = arr[i];\\n            umap_[curr] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (arr[i]%arr[j] == 0) {\\n                    int a = arr[j];\\n                    int b = arr[i]/arr[j];\\n                    if (a > b) {\\n                        break;\\n                    }\\n                    else if (a == b) {\\n                        umap_[curr] += umap_[a]*umap_[a];\\n                    }\\n                    else if (umap_.count(b)) {\\n                        umap_[curr] += 2*umap_[a]*umap_[b];\\n                    }\\n                }\\n            }\\n            total = (total + umap_[curr])%MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int size_ = arr.size();\\n        unordered_map<int, unsigned long long> umap_;\\n        int total = 0;\\n        int MOD = 1000000007;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < size_; i++) {\\n            int curr = arr[i];\\n            umap_[curr] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (arr[i]%arr[j] == 0) {\\n                    int a = arr[j];\\n                    int b = arr[i]/arr[j];\\n                    if (a > b) {\\n                        break;\\n                    }\\n                    else if (a == b) {\\n                        umap_[curr] += umap_[a]*umap_[a];\\n                    }\\n                    else if (umap_.count(b)) {\\n                        umap_[curr] += 2*umap_[a]*umap_[b];\\n                    }\\n                }\\n            }\\n            total = (total + umap_[curr])%MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154329,
                "title": "concise-python-solution-which-beats-95",
                "content": "The idea is very simple. We can define subproblem dp[i] as the number of different trees rooted A[i]. \\nHere is the recurision formula: dp[i] = sum(dp[x] * dp[y] | x * y = i). To reduce the complexity we can only compute where x <= y, and plus x > y on the time x < y. \\n``` python\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        N = len(A)\\n        dp = {A[0]: 1}\\n        for i in range(1, N):\\n            dp[A[i]] = 1\\n            for j in range(i):\\n                div, mod = divmod(A[i], A[j])\\n                if div < A[j]: break\\n                if mod != 0: continue\\n                if div in dp: \\n                    mul = dp[div] * dp[A[j]]\\n                    dp[A[i]] += mul if div == A[j] else 2 * mul\\n                    \\n        return sum(dp.values()) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "``` python\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        N = len(A)\\n        dp = {A[0]: 1}\\n        for i in range(1, N):\\n            dp[A[i]] = 1\\n            for j in range(i):\\n                div, mod = divmod(A[i], A[j])\\n                if div < A[j]: break\\n                if mod != 0: continue\\n                if div in dp: \\n                    mul = dp[div] * dp[A[j]]\\n                    dp[A[i]] += mul if div == A[j] else 2 * mul\\n                    \\n        return sum(dp.values()) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 143127,
                "title": "java-easy-understanding-dp-solution-with-explanation",
                "content": "Start to calculate from the smallest element to the biggest element in ```int[] A```.\\nIf there are two elements ```A[s]```, ```A[e]``` where ```A[s]*A[e] == A[i] and s<i && e<i```\\nthat means we have found ```dp[s]*dp[e]``` more trees for element ```A[i]```.\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long) 1000000007;\\n        long[] dp = new long[A.length];\\n        Arrays.fill(dp,1);\\n        Arrays.sort(A);\\n        for(int i = 1; i < A.length; i++) {\\n            int s = 0, e = i-1;\\n            while(s <= e) {\\n                if(A[s]*A[e] > A[i])e--;\\n                else if(A[s]*A[e] < A[i])s++;\\n                else {\\n                    dp[i] = ((dp[s]*dp[e]*(A[s] == A[e]? 1:2)%mod+dp[i]))%mod;\\n                    s++;\\n                }\\n            }\\n        }\\n        for(long d: dp) {\\n            res = (d+res)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```int[] A```\n```A[s]```\n```A[e]```\n```A[s]*A[e] == A[i] and s<i && e<i```\n```dp[s]*dp[e]```\n```A[i]```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long) 1000000007;\\n        long[] dp = new long[A.length];\\n        Arrays.fill(dp,1);\\n        Arrays.sort(A);\\n        for(int i = 1; i < A.length; i++) {\\n            int s = 0, e = i-1;\\n            while(s <= e) {\\n                if(A[s]*A[e] > A[i])e--;\\n                else if(A[s]*A[e] < A[i])s++;\\n                else {\\n                    dp[i] = ((dp[s]*dp[e]*(A[s] == A[e]? 1:2)%mod+dp[i]))%mod;\\n                    s++;\\n                }\\n            }\\n        }\\n        for(long d: dp) {\\n            res = (d+res)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403219,
                "title": "easy-java-solution-using-hashmap-faster-than-77-87",
                "content": "**Please Upvote if  you like this approach**\\n\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int mod = 1000000007;\\n        HashMap<Integer,Long>map = new HashMap<Integer,Long>();\\n        long ans = 1;\\n        map.put(arr[0],ans);\\n        for(int i = 1; i<arr.length; i++)\\n        {\\n            long sum = 1;\\n            for(int j = 0; j<i ;j++)\\n            {\\n                if(arr[i]%arr[j] == 0 && map.containsKey(arr[i]/arr[j]))\\n                    sum = sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans = ans+sum;\\n        }\\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int mod = 1000000007;\\n        HashMap<Integer,Long>map = new HashMap<Integer,Long>();\\n        long ans = 1;\\n        map.put(arr[0],ans);\\n        for(int i = 1; i<arr.length; i++)\\n        {\\n            long sum = 1;\\n            for(int j = 0; j<i ;j++)\\n            {\\n                if(arr[i]%arr[j] == 0 && map.containsKey(arr[i]/arr[j]))\\n                    sum = sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans = ans+sum;\\n        }\\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402436,
                "title": "823-binary-trees-with-factors-in-c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n\\t//given in problem\\n\\tconst int mod = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\t//define n as zize of array\\n\\t\\tint n = arr.size();\\n\\t\\tvector < long long > dp(n, 1);\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t//iterate the loop\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\t//store the index of various elements of the array\\n\\t\\t\\tmp[arr[i]] = i;\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//to check whether arr[j] is a factor of arr[i] or not\\n\\t\\t\\t\\tif (arr[i] % arr[j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//store to temp\\n\\t\\t\\t\\t\\tint temp = arr[i] / arr[j];\\n\\t\\t\\t\\t\\t//now check if count of temp in map exists then\\n\\t\\t\\t\\t\\tif (mp.count(temp))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//check the presence of the required no in map,\\n\\t\\t\\t\\t\\t\\t//If it is in the map then increase dp[i] by the product of the dp[j]\\n\\t\\t\\t\\t\\t\\t//dp[mp[temp]] taking the modulus\\n\\t\\t\\t\\t\\t\\tdp[i] += (dp[j] * dp[mp[temp]]) % mod;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tans = accumulate(dp.begin(), dp.end(), 0LL);\\n\\t\\t//return total sum with mod\\n\\t\\treturn (ans % mod);\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//given in problem\\n\\tconst int mod = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\t//define n as zize of array\\n\\t\\tint n = arr.size();\\n\\t\\tvector < long long > dp(n, 1);\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t//iterate the loop\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\t//store the index of various elements of the array\\n\\t\\t\\tmp[arr[i]] = i;\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//to check whether arr[j] is a factor of arr[i] or not\\n\\t\\t\\t\\tif (arr[i] % arr[j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//store to temp\\n\\t\\t\\t\\t\\tint temp = arr[i] / arr[j];\\n\\t\\t\\t\\t\\t//now check if count of temp in map exists then\\n\\t\\t\\t\\t\\tif (mp.count(temp))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//check the presence of the required no in map,\\n\\t\\t\\t\\t\\t\\t//If it is in the map then increase dp[i] by the product of the dp[j]\\n\\t\\t\\t\\t\\t\\t//dp[mp[temp]] taking the modulus\\n\\t\\t\\t\\t\\t\\tdp[i] += (dp[j] * dp[mp[temp]]) % mod;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tans = accumulate(dp.begin(), dp.end(), 0LL);\\n\\t\\t//return total sum with mod\\n\\t\\treturn (ans % mod);\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401367,
                "title": "java-dp-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Map<Integer,Long>trees = new HashMap<>();\\n\\t\\tArrays.sort(arr);\\n        \\n        for (int i=0;i<arr.length;i++){\\n            long currentTreesNum=1;\\n            for (int j=0;j<i;j++){\\n                if (arr[i]%arr[j]==0 && trees.containsKey(arr[i]/arr[j])){\\n                    currentTreesNum=(currentTreesNum+(trees.get(arr[i]/arr[j])*trees.get(arr[j]))%mod)%mod;\\n                }\\n            }\\n            trees.put(arr[i], currentTreesNum);\\n        }\\n        long res = 0;\\n        for (long treeNum: trees.values())res=(res+treeNum)%mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Map<Integer,Long>trees = new HashMap<>();\\n\\t\\tArrays.sort(arr);\\n        \\n        for (int i=0;i<arr.length;i++){\\n            long currentTreesNum=1;\\n            for (int j=0;j<i;j++){\\n                if (arr[i]%arr[j]==0 && trees.containsKey(arr[i]/arr[j])){\\n                    currentTreesNum=(currentTreesNum+(trees.get(arr[i]/arr[j])*trees.get(arr[j]))%mod)%mod;\\n                }\\n            }\\n            trees.put(arr[i], currentTreesNum);\\n        }\\n        long res = 0;\\n        for (long treeNum: trees.values())res=(res+treeNum)%mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400751,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n                    A.sort()\\n                    fmap, ans = defaultdict(), 0\\n                    for num in A:\\n                        ways, lim = 1, sqrt(num)\\n                        for fA in A:\\n                            if fA > lim: break\\n                            fB = num / fA\\n                            if fB in fmap:\\n                                ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n                        fmap[num], ans = ways, (ans + ways)\\n                    return ans % 1000000007\\n            \\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n                    A.sort()\\n                    fmap, ans = defaultdict(), 0\\n                    for num in A:\\n                        ways, lim = 1, sqrt(num)\\n                        for fA in A:\\n                            if fA > lim: break\\n                            fB = num / fA\\n                            if fB in fmap:\\n                                ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n                        fmap[num], ans = ways, (ans + ways)\\n                    return ans % 1000000007\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400318,
                "title": "c-easy-solution-using-hashmap-tabulation-dp-easy-understanding",
                "content": "# **C++ Easy Solution Using Hashmap Tabulation || DP || Easy understanding**\\nPlease Consider *Upvote* if you like this Solution Thank You\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        unordered_map<long long,long long>m;\\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n            m[arr[i]]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int val=arr[i]/arr[j];\\n                if(val*arr[j]==arr[i]&&m.count(val)){\\n                    m[arr[i]]=m[arr[i]]+(m[val]*m[arr[j]]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n            sum=(sum+m[arr[i]])%mod;\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        unordered_map<long long,long long>m;\\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n            m[arr[i]]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int val=arr[i]/arr[j];\\n                if(val*arr[j]==arr[i]&&m.count(val)){\\n                    m[arr[i]]=m[arr[i]]+(m[val]*m[arr[j]]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n            sum=(sum+m[arr[i]])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399994,
                "title": "python-dp-with-perhaps-too-detailed-explanation-99-speed",
                "content": "**[Observation 1]** \\nGiven positive integers `a`, `b`, and `c`, if `c = a * b`, then `c >= a` and `c >= b`. Thus, only larger numbers can have children consisting of smaller numbers.\\n**[Strategy 1]** \\nWe first compute the valid trees with smaller numbers as the topmost parent, then append these trees as children to a larger number and see if they remain valid. In other words: we scan from small numbers to large numbers, and at each number (outer loop), we look back and see if there were some smaller numbers (inner loop) being the divisor as our current number. Therefore it\\'s a DP problem.\\n\\n**[Observation 2]** For positive integers `a`, `b`, and `c`, if `a * b = c` and `a <= b`, then the possibilities are:\\n` 1 * b = c      ->       b = c`\\n` 2 * b = c      ->       b = c/2`\\n` 3 * b = c      ->       b = c/3`\\n` 4 * b = c      ->       b = c/4`\\n`...`\\nOf course these may not all be true, depending on whether `c` really has 2, 3, 4, ... as its divisors, but you can see besides `b = c`, the largest possible value for b is no larger than `c/2`.\\n**[Strategy 2]** Given a current number `i` (outer loop), when we look back to smaller numbers (inner loop), we skip those that are greater than `i/2`.\\n\\n**[Observation 3]** Let `c = a * b` and let the numbers of possible trees for `a` and `b` be `na` and `nb`, respectively. If `a == b`, there\\'s only one way to append the trees: append `a(==b)` to both the left and the right. The total number of possible configurations is `na * na == nb * nb`.\\nHowever if `a != b`, then there are two ways to append the `a` and `b` trees to `c`, namely (1) `a` to the left and `b` to the right and (2) `a` to the right and `b` to the left. The total number of possible ways to append is then `na * nb * 2`.\\n**[Strategy 3]** The implication is that if we have `c = a * b` and `a < b`, then we will meet `a` in our inner loop first (because `a` is smaller), and we don\\'t need to check `b` later because we already take into account the configurations including `b` when we first meet `a`. Therefore, if at some `a` we find `a > c / a`, we can break out of the inner loop to save time.\\n\\n**[Code]**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\t\\t# use a hashmap to quickly look up checked numbers\\n\\t\\t# {key: value} = {n: number of trees with n as its topmost parent}\\n        d = {}\\n\\t\\t# observation 1\\n        for i in arr: # outer loop\\n\\t\\t\\t# an isolated i itself is always a valid tree\\n            d[i] = 1\\n            for j in arr: # inner loop\\n\\t\\t\\t\\t# observation 2 & 3\\n                if j == i or j > i//2+1 or j > i//j: break\\n\\t\\t\\t\\t# observation 3\\n                if i%j == 0 and i//j in d:\\n                    if j == i//j:\\n                        d[i] = d[i] + d[j]*d[i//j]\\n                    else:\\n                        d[i] = d[i] + d[j]*d[i//j]*2\\n        return sum(d.values())%(10**9+7)\\n```\\n\\nTime complexity: O(N^2)\\nSpace complexity: O(N)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\t\\t# use a hashmap to quickly look up checked numbers\\n\\t\\t# {key: value} = {n: number of trees with n as its topmost parent}\\n        d = {}\\n\\t\\t# observation 1\\n        for i in arr: # outer loop\\n\\t\\t\\t# an isolated i itself is always a valid tree\\n            d[i] = 1\\n            for j in arr: # inner loop\\n\\t\\t\\t\\t# observation 2 & 3\\n                if j == i or j > i//2+1 or j > i//j: break\\n\\t\\t\\t\\t# observation 3\\n                if i%j == 0 and i//j in d:\\n                    if j == i//j:\\n                        d[i] = d[i] + d[j]*d[i//j]\\n                    else:\\n                        d[i] = d[i] + d[j]*d[i//j]*2\\n        return sum(d.values())%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402508,
                "title": "c-dp-map-easy-sorting",
                "content": "\\n**Dynamic Programming and Map Approach\\nTime Complexity:- O(N*N)\\nSpace Complexity:- O(N)**\\n\\n***Note:-** In this Problem we need to calculate the factors of each numbers(which is  nothing but the leaf nodes) and checking whether its product is is equal to the values of the nodes or not. Also we need to use unordered map for storing the current values (No. of Binary trees obtained).*\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        // Map for checking whether the factors are present or not.\\n        unordered_map<ll,ll> mp;\\n        \\n        ll res=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // Curr value should be 1 i.e. Leaf Node\\n            ll curr = 1;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if((arr[i]%arr[j])>0){\\n                    continue;\\n                }\\n                \\n                ll n1 = arr[j], n2 = arr[i]/arr[j];\\n                \\n                curr = (curr + (mp[n1]*mp[n2])%mod)%mod;\\n            }\\n            \\n            //Updating the map\\n            \\n            mp[arr[i]] = curr;\\n            \\n            // Storing the number of binary trees obtained in a variable\\n            res = (res+curr)%mod;\\n        }\\n        \\n        \\n        //Returning the number of binary trees we can make \\n        \\n        return (int)res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        // Map for checking whether the factors are present or not.\\n        unordered_map<ll,ll> mp;\\n        \\n        ll res=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // Curr value should be 1 i.e. Leaf Node\\n            ll curr = 1;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if((arr[i]%arr[j])>0){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2400611,
                "title": "with-dp-two-pointer-combinotrics-maths-and-sorting",
                "content": "```\\n Hey Guys, How are You all !!\\n\\n Lets start Today\\'s problem solution.\\n \\n => Here, we have to find total valid binary tree which must follow below condition,\\n         1) every parent is product of his child.\\n\\n => To solve this question some steps we will be following,\\n       \\n\\t   1)  sort all array .\\n\\t          reason : because every element we are choosing as a root and we are finding two \\n\\t\\t\\t  element which product is this number another reason is we have to use two \\n\\t\\t\\t  pointer to find product so we need to sort.\\n\\t\\t\\t  \\n\\t\\t2)  taverse fron first and make that node as a root node and find two element which\\n\\t\\t    product is this root so that two number can be my child.\\n\\t\\t\\t\\n\\t\\t\\t=> now we need to use dp here because we are choosing child node but we need\\n\\t\\t\\t     to consider all subtree with this child node.\\n\\t\\t\\t\\n\\t\\t\\t      suppose, we have\\n\\t\\t\\t\\t           50  as a root and 25 and 2 as a child,\\n\\t\\t\\t\\t\\t\\t  25     2    \\n\\t\\t\\t\\t\\t\\t5   5\\n\\t\\t\\t\\t\\t we are taking all combination of child like,\\n\\t\\t\\t\\t    1)  50\\n\\t\\t\\t\\t    2)   50 \\n\\t\\t\\t\\t        25   2\\n\\t\\t\\t\\t\\t3)      50 \\n\\t\\t\\t\\t\\t     25   2\\n\\t\\t\\t\\t\\t  5    5\\n\\t\\t\\t\\t\\n\\t\\t\\t 3) so  that\\'s it we have all tree count in ith node so take sum of all dp and this is\\n\\t\\t\\t     our answer\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\n\\t\\nIf you not understood so take time and dry with pen and paper run because this problem uses concept of DP, Two-pointer, Combinotrics ( Maths ) and Sorting.\\n  \\n```\\n\\n **Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int f=0,e=i-1;\\n           unsigned long long tar=nums[i];\\n            \\n            while(f<=e)\\n            { \\n               unsigned long long pro=1LL*nums[f]*nums[e];\\n                \\n                if(pro==tar){\\n                    \\n                    dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                \\n                    if(f!=e){\\n                        dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                    }\\n                    \\n                    f++;\\n                    e--;\\n                }else if(pro<tar)\\n                {\\n                    f++;\\n                }else{\\n                    e--;\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n       \\n        for(int i=0;i<n;i++){\\n            ans= (ans + dp[i])%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n Hey Guys, How are You all !!\\n\\n Lets start Today\\'s problem solution.\\n \\n => Here, we have to find total valid binary tree which must follow below condition,\\n         1) every parent is product of his child.\\n\\n => To solve this question some steps we will be following,\\n       \\n\\t   1)  sort all array .\\n\\t          reason : because every element we are choosing as a root and we are finding two \\n\\t\\t\\t  element which product is this number another reason is we have to use two \\n\\t\\t\\t  pointer to find product so we need to sort.\\n\\t\\t\\t  \\n\\t\\t2)  taverse fron first and make that node as a root node and find two element which\\n\\t\\t    product is this root so that two number can be my child.\\n\\t\\t\\t\\n\\t\\t\\t=> now we need to use dp here because we are choosing child node but we need\\n\\t\\t\\t     to consider all subtree with this child node.\\n\\t\\t\\t\\n\\t\\t\\t      suppose, we have\\n\\t\\t\\t\\t           50  as a root and 25 and 2 as a child,\\n\\t\\t\\t\\t\\t\\t  25     2    \\n\\t\\t\\t\\t\\t\\t5   5\\n\\t\\t\\t\\t\\t we are taking all combination of child like,\\n\\t\\t\\t\\t    1)  50\\n\\t\\t\\t\\t    2)   50 \\n\\t\\t\\t\\t        25   2\\n\\t\\t\\t\\t\\t3)      50 \\n\\t\\t\\t\\t\\t     25   2\\n\\t\\t\\t\\t\\t  5    5\\n\\t\\t\\t\\t\\n\\t\\t\\t 3) so  that\\'s it we have all tree count in ith node so take sum of all dp and this is\\n\\t\\t\\t     our answer\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\n\\t\\nIf you not understood so take time and dry with pen and paper run because this problem uses concept of DP, Two-pointer, Combinotrics ( Maths ) and Sorting.\\n  \\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int f=0,e=i-1;\\n           unsigned long long tar=nums[i];\\n            \\n            while(f<=e)\\n            { \\n               unsigned long long pro=1LL*nums[f]*nums[e];\\n                \\n                if(pro==tar){\\n                    \\n                    dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                \\n                    if(f!=e){\\n                        dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                    }\\n                    \\n                    f++;\\n                    e--;\\n                }else if(pro<tar)\\n                {\\n                    f++;\\n                }else{\\n                    e--;\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n       \\n        for(int i=0;i<n;i++){\\n            ans= (ans + dp[i])%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400058,
                "title": "python-dp-with-hash-table",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        ans = 0\\n        dp = {}\\n        for n in arr:\\n            temp = 1\\n            for k in dp.keys():\\n                if n%k==0 and n//k in dp:\\n                    temp+=dp[k]*dp[n//k]\\n            ans+= temp\\n            dp[n] = temp\\n        return ans%(10**9+7)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        ans = 0\\n        dp = {}\\n        for n in arr:\\n            temp = 1\\n            for k in dp.keys():\\n                if n%k==0 and n//k in dp:\\n                    temp+=dp[k]*dp[n//k]\\n            ans+= temp\\n            dp[n] = temp\\n        return ans%(10**9+7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399914,
                "title": "python-3-as-short-as-it-gets-o-n-2-98-time-90-memory",
                "content": "This is as short as I could get my code: \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 1000 * 1000 * 1000 + 7\\n        arr =sorted(arr)\\n        dp = {a:1 for a in arr}\\n            \\n        for i,a in enumerate(arr):\\n            for j in range(i):\\n                b, c = arr[j], a//arr[j]\\n                if c < b:\\n                    break\\n                if a % b != 0 or c not in dp:\\n                    continue\\n                add = dp[b] * dp[c]\\n                dp[a] += add if b == c else 2 * add\\n            dp[a] = dp[a] % mod\\n        return sum(dp.values()) % mod\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 1000 * 1000 * 1000 + 7\\n        arr =sorted(arr)\\n        dp = {a:1 for a in arr}\\n            \\n        for i,a in enumerate(arr):\\n            for j in range(i):\\n                b, c = arr[j], a//arr[j]\\n                if c < b:\\n                    break\\n                if a % b != 0 or c not in dp:\\n                    continue\\n                add = dp[b] * dp[c]\\n                dp[a] += add if b == c else 2 * add\\n            dp[a] = dp[a] % mod\\n        return sum(dp.values()) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639558,
                "title": "c-dp-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n         int mod = 1e9 + 7;\\n        map<int, long long> mp;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n              mp[arr[i]] = 1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    mp[arr[i]] += (long long)(mp[arr[j]] * mp[arr[i] / arr[j]]) % mod;\\n                    mp[arr[i]] %= mod;\\n                }\\n            }\\n        }\\n          long long ans = 0;\\n        \\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n             ans= (ans + it->second)  % mod;\\n        }\\n           return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n         int mod = 1e9 + 7;\\n        map<int, long long> mp;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n              mp[arr[i]] = 1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    mp[arr[i]] += (long long)(mp[arr[j]] * mp[arr[i] / arr[j]]) % mod;\\n                    mp[arr[i]] %= mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1108175,
                "title": "java-simple-and-easy-to-understand-solution-using-dp-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    static int MOD = 1_000_000_007;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        \\n        Arrays.sort(arr);\\n        \\n        //consider as root for each number\\n        //save the count of BT\\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        //num to index mapping\\n        Map<Integer, Integer> mapIndex = new HashMap();\\n        for(int i = 0; i < n; i++)\\n            mapIndex.put(arr[i], i);\\n        \\n        for(int rootIndex = 0; rootIndex < n; rootIndex++){\\n            int root = arr[rootIndex];\\n            \\n            for(int leftIndex = 0; leftIndex < rootIndex; leftIndex++){\\n                int left = arr[leftIndex];\\n                \\n                if(root % left == 0){\\n                    int right = root / left;\\n                    \\n                    if(mapIndex.containsKey(right)){\\n                        int rightIndex = mapIndex.get(right);\\n                        \\n                        dp[rootIndex] = (dp[rootIndex] + (dp[leftIndex] * dp[rightIndex])) % MOD; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        //count all the trees\\n        long counts = 0;\\n        for(long count : dp) counts += count;\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static int MOD = 1_000_000_007;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        \\n        Arrays.sort(arr);\\n        \\n        //consider as root for each number\\n        //save the count of BT\\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        //num to index mapping\\n        Map<Integer, Integer> mapIndex = new HashMap();\\n        for(int i = 0; i < n; i++)\\n            mapIndex.put(arr[i], i);\\n        \\n        for(int rootIndex = 0; rootIndex < n; rootIndex++){\\n            int root = arr[rootIndex];\\n            \\n            for(int leftIndex = 0; leftIndex < rootIndex; leftIndex++){\\n                int left = arr[leftIndex];\\n                \\n                if(root % left == 0){\\n                    int right = root / left;\\n                    \\n                    if(mapIndex.containsKey(right)){\\n                        int rightIndex = mapIndex.get(right);\\n                        \\n                        dp[rootIndex] = (dp[rootIndex] + (dp[leftIndex] * dp[rightIndex])) % MOD; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        //count all the trees\\n        long counts = 0;\\n        for(long count : dp) counts += count;\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107566,
                "title": "cpp-easy-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)\\n            return 1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long>m1;\\n        for(int a:arr)\\n        {\\n            m1[a]=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    int r=arr[i]/arr[j];\\n                    if(m1[r]>0)\\n                    {\\n                        m1[arr[i]]+=m1[arr[j]]*m1[r];\\n                    }\\n                }\\n            }\\n        }\\n        long  int sum=0;\\n        for(auto it:m1)\\n        {\\n            sum+=it.second;\\n        }\\n        return int(sum%1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)\\n            return 1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long>m1;\\n        for(int a:arr)\\n        {\\n            m1[a]=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    int r=arr[i]/arr[j];\\n                    if(m1[r]>0)\\n                    {\\n                        m1[arr[i]]+=m1[arr[j]]*m1[r];\\n                    }\\n                }\\n            }\\n        }\\n        long  int sum=0;\\n        for(auto it:m1)\\n        {\\n            sum+=it.second;\\n        }\\n        return int(sum%1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107431,
                "title": "java-short-and-crisp-using-dp-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length ,mod = 1_000_000_007;\\n        long res=0, ways[] = new long[n];\\n        \\n        for(int i=0,l=0,r=0 ;i<n; i++){\\n            ways[i] = 1;\\n            //Two-poitner Approach\\n            l = 0; r = i-1;\\n            while(l <= r){\\n\\t\\t\\t/*Instead of checking arr[l]*arr[r] == arr[i], to prevent overflow\\n\\t\\t\\tuse arr[l] == arr[i]/arr[r]. */\\n                if( arr[l]*1.0 == arr[i]*1.0/arr[r]){         \\n                    ways[i] += ways[l]*ways[r]*( l==r ? 1 : 2 );\\n                    l++;r--;\\n                }\\n                else if ( arr[l]*1.0 > arr[i]*1.0/arr[r]) r--;\\n                else l++;\\n            }\\n            res = (res+ways[i]) % mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length ,mod = 1_000_000_007;\\n        long res=0, ways[] = new long[n];\\n        \\n        for(int i=0,l=0,r=0 ;i<n; i++){\\n            ways[i] = 1;\\n            //Two-poitner Approach\\n            l = 0; r = i-1;\\n            while(l <= r){\\n\\t\\t\\t/*Instead of checking arr[l]*arr[r] == arr[i], to prevent overflow\\n\\t\\t\\tuse arr[l] == arr[i]/arr[r]. */\\n                if( arr[l]*1.0 == arr[i]*1.0/arr[r]){         \\n                    ways[i] += ways[l]*ways[r]*( l==r ? 1 : 2 );\\n                    l++;r--;\\n                }\\n                else if ( arr[l]*1.0 > arr[i]*1.0/arr[r]) r--;\\n                else l++;\\n            }\\n            res = (res+ways[i]) % mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107384,
                "title": "why-is-sorting-required-here",
                "content": "Why do so many solutions use sorting here? My code works fine without sorting. Whats the need for sorting at all?\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        \\n        MOD = 10**9+7\\n        nodes = set(arr)\\n        \\n        @lru_cache(None)\\n        def rootTree(rootVal):\\n            \\n            count = 1\\n            for left in nodes:\\n                if rootVal%left == 0:\\n                    right = rootVal // left\\n                    if right in nodes:\\n                        count += rootTree(left)*rootTree(right)\\n                        \\n            return count\\n        \\n        \\n        count = 0\\n        for x in arr:\\n            count+=rootTree(x)\\n            \\n        return count % MOD\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        \\n        MOD = 10**9+7\\n        nodes = set(arr)\\n        \\n        @lru_cache(None)\\n        def rootTree(rootVal):\\n            \\n            count = 1\\n            for left in nodes:\\n                if rootVal%left == 0:\\n                    right = rootVal // left\\n                    if right in nodes:\\n                        count += rootTree(left)*rootTree(right)\\n                        \\n            return count\\n        \\n        \\n        count = 0\\n        for x in arr:\\n            count+=rootTree(x)\\n            \\n        return count % MOD\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934727,
                "title": "python3-two-approaches",
                "content": "Approach 1 - priority queue \\nThe essential argument is that if we find `x*y = z` in `A`, then `cnt[z] += cnt[x]*cnt[y]`. One caveat is that we have to process from small value to large value to make sure that when updating `z` the count of `x` and `y` are already accurate. \\n\\nOne straightforward approach is to use a priority queue to store `(z, x, y)` triplet, and process them one by one. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        As = set(A) # set for O(1) lookup \\n        pq = [] # min heap \\n        for x, y in product(A, A): \\n            if x*y in As: heappush(pq, (x*y, x, y))\\n        \\n        cnt = {x: 1 for x in A}\\n        while pq: \\n            z, x, y = heappop(pq)\\n            cnt[z] += cnt[x] * cnt[y]\\n        \\n        return sum(cnt.values()) % 1_000_000_007\\n```\\n\\nAnalysis\\nTime complexity `O(N^2)` on the assumption that `pq` is `O(N)`\\nSpace complexity `O(N)` \\n\\nApproach 2 - greedy \\nWe can solve this problem more directly via greedy approach. Scan through `A` from smallest to largest and collect its count. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        cnt = {}\\n        for x in sorted(A): \\n            cnt[x] = 1 + sum(cnt[xx]*cnt[x//xx] for xx in cnt if not x%xx and x//xx in cnt)\\n        return sum(cnt.values()) % 1_000_000_007\\n```\\n\\nAnalysis\\nTime complexity `O(N^2)`\\nSpace complexity `O(N)`\\n\\nEdited on 3/13/2021\\nAdding an easier to follow implementation\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        freq = {}\\n        for x in sorted(arr): \\n            freq[x] = 1\\n            for xx in freq: \\n                freq[x] += freq[xx] * freq.get(x/xx, 0)\\n        return sum(freq.values()) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        As = set(A) # set for O(1) lookup \\n        pq = [] # min heap \\n        for x, y in product(A, A): \\n            if x*y in As: heappush(pq, (x*y, x, y))\\n        \\n        cnt = {x: 1 for x in A}\\n        while pq: \\n            z, x, y = heappop(pq)\\n            cnt[z] += cnt[x] * cnt[y]\\n        \\n        return sum(cnt.values()) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        cnt = {}\\n        for x in sorted(A): \\n            cnt[x] = 1 + sum(cnt[xx]*cnt[x//xx] for xx in cnt if not x%xx and x//xx in cnt)\\n        return sum(cnt.values()) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        freq = {}\\n        for x in sorted(arr): \\n            freq[x] = 1\\n            for xx in freq: \\n                freq[x] += freq[xx] * freq.get(x/xx, 0)\\n        return sum(freq.values()) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682191,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    private static final long MOD = (long) 1e9 + 7;\\n    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        Map<Integer, Long> dp = new HashMap<>();\\n\\n        long answer = 0;\\n        for (int num : A) {\\n            dfs(dp, A, num);\\n            answer = (answer + dp.get(num)) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private long dfs(Map<Integer, Long> dp, int[] A, int cur) {\\n        if (cur < 0) {\\n            return 0;\\n        }\\n        \\n        if (cur == 1) {\\n            return 1;\\n        }\\n        \\n        if (dp.containsKey(cur)) {\\n            return dp.get(cur);\\n        }\\n        \\n        long answer = 0;\\n        for (int num : A) {\\n            if (cur % num == 0) {\\n                int quotient = cur / num;\\n                \\n                if (quotient == 1) {\\n                    answer = (answer + 1) % MOD;\\n                } else if (Arrays.binarySearch(A, quotient) >= 0) {\\n                    answer = (answer + dfs(dp, A, quotient) * dfs(dp, A, num)) % MOD;\\n                }\\n            }\\n        }\\n        \\n        dp.put(cur, answer);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final long MOD = (long) 1e9 + 7;\\n    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        Map<Integer, Long> dp = new HashMap<>();\\n\\n        long answer = 0;\\n        for (int num : A) {\\n            dfs(dp, A, num);\\n            answer = (answer + dp.get(num)) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private long dfs(Map<Integer, Long> dp, int[] A, int cur) {\\n        if (cur < 0) {\\n            return 0;\\n        }\\n        \\n        if (cur == 1) {\\n            return 1;\\n        }\\n        \\n        if (dp.containsKey(cur)) {\\n            return dp.get(cur);\\n        }\\n        \\n        long answer = 0;\\n        for (int num : A) {\\n            if (cur % num == 0) {\\n                int quotient = cur / num;\\n                \\n                if (quotient == 1) {\\n                    answer = (answer + 1) % MOD;\\n                } else if (Arrays.binarySearch(A, quotient) >= 0) {\\n                    answer = (answer + dfs(dp, A, quotient) * dfs(dp, A, num)) % MOD;\\n                }\\n            }\\n        }\\n        \\n        dp.put(cur, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412600,
                "title": "c-dp-using-unordered-map",
                "content": "```\\nint numFactoredBinaryTrees(vector<int>& A) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        unordered_map<int,long long int> dp; // key is the product, value is the count\\n        sort(A.begin(), A.end());\\n        dp[A[0]] = 1;\\n        for(int i=1; i<n; i++) {\\n            dp[A[i]] = 1;\\n            for(auto it=dp.begin(); it!=dp.end(); it++) {\\n                int p1 = it->first;\\n                if(A[i] % p1 != 0) continue;\\n                int p2 = A[i] / p1;\\n                if(!dp.count(p2)) continue;\\n                dp[A[i]] += it->second * dp[p2];\\n                dp[A[i]] %= 1000000007;\\n            }\\n        }\\n        int res = 0;\\n        for(auto it=dp.begin(); it!=dp.end(); it++) {\\n            res += it->second;\\n            res %= 1000000007;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& A) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        unordered_map<int,long long int> dp; // key is the product, value is the count\\n        sort(A.begin(), A.end());\\n        dp[A[0]] = 1;\\n        for(int i=1; i<n; i++) {\\n            dp[A[i]] = 1;\\n            for(auto it=dp.begin(); it!=dp.end(); it++) {\\n                int p1 = it->first;\\n                if(A[i] % p1 != 0) continue;\\n                int p2 = A[i] / p1;\\n                if(!dp.count(p2)) continue;\\n                dp[A[i]] += it->second * dp[p2];\\n                dp[A[i]] %= 1000000007;\\n            }\\n        }\\n        int res = 0;\\n        for(auto it=dp.begin(); it!=dp.end(); it++) {\\n            res += it->second;\\n            res %= 1000000007;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203398,
                "title": "cleaar-dp-python-solution",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        dp = collections.Counter()\\n        for i,num in enumerate(A):\\n            dp[num] = 1\\n            for j in range(i):\\n                if num % A[j] == 0:\\n                    dp[num] += dp[A[j]] * dp[num/A[j]]\\n            s += dp[num]\\n        return s % (10**9 + 7)\\n                    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        dp = collections.Counter()\\n        for i,num in enumerate(A):\\n            dp[num] = 1\\n            for j in range(i):\\n                if num % A[j] == 0:\\n                    dp[num] += dp[A[j]] * dp[num/A[j]]\\n            s += dp[num]\\n        return s % (10**9 + 7)\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 187964,
                "title": "c-dp-solution-with-two-pointer",
                "content": "Use two pointer to find out all combinations that product is A[i].\n```\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& A) {\n        long mod = 1000000007;\n        sort(A.begin(), A.end());\n        vector<long> dp(A.size());\n        \n        int result = 0;\n        for (int i = 0; i < dp.size(); ++i) {\n            dp[i] = 1;\n            int begin = 0;\n            int end = i-1;\n            while (begin <= end) {\n                if (A[begin]*A[end] > A[i]) {\n                    end--;\n                } else if (A[begin]*A[end] < A[i]) {\n                    begin++;\n                } else {\n                    dp[i] = (dp[i] + (dp[begin]*dp[end])*(begin == end ? 1 : 2)) % mod;\n                    begin++;\n                }\n            }\n            result  = (result + dp[i]) % mod;\n        }\n        return result;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& A) {\n        long mod = 1000000007;\n        sort(A.begin(), A.end());\n        vector<long> dp(A.size());\n        \n        int result = 0;\n        for (int i = 0; i < dp.size(); ++i) {\n            dp[i] = 1;\n            int begin = 0;\n            int end = i-1;\n            while (begin <= end) {\n                if (A[begin]*A[end] > A[i]) {\n                    end--;\n                } else if (A[begin]*A[end] < A[i]) {\n                    begin++;\n                } else {\n                    dp[i] = (dp[i] + (dp[begin]*dp[end])*(begin == end ? 1 : 2)) % mod;\n                    begin++;\n                }\n            }\n            result  = (result + dp[i]) % mod;\n        }\n        return result;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403437,
                "title": "c-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long ans=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,long> rootWithCount;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long currentAns = 1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                int a = arr[i]/arr[j];\\n                int b = arr[j];\\n                \\n                currentAns = (currentAns + rootWithCount[a]*rootWithCount[b]%MOD)%MOD;\\n            }\\n            rootWithCount[arr[i]] = currentAns;\\n            ans += currentAns;\\n        }\\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long ans=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,long> rootWithCount;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long currentAns = 1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                int a = arr[i]/arr[j];\\n                int b = arr[j];\\n                \\n                currentAns = (currentAns + rootWithCount[a]*rootWithCount[b]%MOD)%MOD;\\n            }\\n            rootWithCount[arr[i]] = currentAns;\\n            ans += currentAns;\\n        }\\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403334,
                "title": "c-simplified-solution-using-dp-c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long n=arr.size();\\n        long long mod=1e9+7;\\n        vector<int> ans(n, 1);\\n        sort(arr.begin(), arr.end());\\n        long long ans1=0;\\n        for(int i=0; i<n; i++){\\n            int in=0, en=i;\\n            int k=0;\\n            while(in<i && en>=0){\\n                if((long long)arr[in]*arr[en]==arr[i]){\\n                    long long k=(long long)ans[in]*ans[en]; k%=mod;\\n                    ans[i]+=k;\\n                    ans[i]%=mod;\\n                    in++; en--;\\n                }\\n                else if((long long)arr[in]*arr[en]>arr[i]){\\n                    en--;\\n                }\\n                else in++;\\n            } \\n        }\\n        for(int i=0; i<n; i++){ \\n            ans1+=ans[i];\\n            ans1%=mod;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long n=arr.size();\\n        long long mod=1e9+7;\\n        vector<int> ans(n, 1);\\n        sort(arr.begin(), arr.end());\\n        long long ans1=0;\\n        for(int i=0; i<n; i++){\\n            int in=0, en=i;\\n            int k=0;\\n            while(in<i && en>=0){\\n                if((long long)arr[in]*arr[en]==arr[i]){\\n                    long long k=(long long)ans[in]*ans[en]; k%=mod;\\n                    ans[i]+=k;\\n                    ans[i]%=mod;\\n                    in++; en--;\\n                }\\n                else if((long long)arr[in]*arr[en]>arr[i]){\\n                    en--;\\n                }\\n                else in++;\\n            } \\n        }\\n        for(int i=0; i<n; i++){ \\n            ans1+=ans[i];\\n            ans1%=mod;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402041,
                "title": "java-solution-easy-to-understand-hapmap-dp-38-ms-solution-inline-comments",
                "content": "**Java Hapmap | 38ms solution**\\n\\n\\n```\\n public int numFactoredBinaryTrees(int[] arr) {\\n        //sort the arr first \\n        int MOD=1000000007;//get mod because of ans to long\\n         Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>(); // declare map to keep track of arr value and they sum \\n        long ans=1;\\n        map.put(arr[0],ans); //key=2,vaule=1;\\n        for(int i=1;i<arr.length;i++)//i=1\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)//j=0\\n            {\\n                if(arr[i]%arr[j]==0 &&map.containsKey(arr[i]/arr[j]))\\n                    //(4%2==0&&keyinmap(4/2=2))ture\\n                    sum+=(map.get(arr[i]/arr[j])*map.get(arr[j]));//sum=(1*1)+1=2\\n            }\\n            map.put(arr[i],sum);//key=4,2\\n            ans+=sum;//3\\n        }\\n        return (int)(ans%MOD);//3%MOD\\n\\t\\t}\\n```\\n**TC : O(N^2)**\\n**SC: O(N)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int numFactoredBinaryTrees(int[] arr) {\\n        //sort the arr first \\n        int MOD=1000000007;//get mod because of ans to long\\n         Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>(); // declare map to keep track of arr value and they sum \\n        long ans=1;\\n        map.put(arr[0],ans); //key=2,vaule=1;\\n        for(int i=1;i<arr.length;i++)//i=1\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)//j=0\\n            {\\n                if(arr[i]%arr[j]==0 &&map.containsKey(arr[i]/arr[j]))\\n                    //(4%2==0&&keyinmap(4/2=2))ture\\n                    sum+=(map.get(arr[i]/arr[j])*map.get(arr[j]));//sum=(1*1)+1=2\\n            }\\n            map.put(arr[i],sum);//key=4,2\\n            ans+=sum;//3\\n        }\\n        return (int)(ans%MOD);//3%MOD\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402035,
                "title": "detailed-explanation-with-example-and-code-c-dp",
                "content": "Let\\'s say that **A** is a number that can be represented as\\n\\n**A = B * C** \\n**A = D * D**\\n**A = C * B**\\n\\nand The array **arr[]** contains all the numbers A,B,C, and D.  Now ,\\n\\n**N(A)** = Number of binary trees which has root node A\\n**N(B)** = Number of binary trees which has root node B\\n**N(C)** = Number of binary trees which has root node C\\n**N(D)** = Number of binary trees which has root node D\\n**N(T)** = Total Number of Nodes\\n\\n***N(A) = ( N(B)  N(C) )  + ( N(D)  N(D) )  +  ( N(C)  N(B) ) + 1 .  .... (1)***\\n\\n**N(B) * N(C)** now equals **N(C) * N(B)**. Therefore, the only thing we can do is multiply N(B) * N(C) by 2 .\\xA0 Equation (1) can therefore be expressed as\\n\\n***N(A) = ( N(B)  N(C) )  2  + ( N(D)  N(D) )  + 1 .  .... (2)***\\n\\n* If the left and right nodes are not the same, we can state that their product will be multiplied by two and added to the result.\\n* If the left and right nodes are not the same, we can state that their product will be multiplied by one and added to the result.\\n* 1 will be added to the answer because every node itself is a tree with one node only. \\n\\nTotal number of Nodes will be \\n**N(T) = N(A) + N(B) + N(C) + N(D)** \\n\\n\\nLet us apply the above formula for arr = [ 2, 4 , 8 , 16 ]\\n\\n* **2** : we will get only one binary tree  so , N(2) = 1  \\n* **4** :  4 = 2 * 2 .  As we know N(2) = 1  and here both the factors are same so we will multiply their product by 1 and add to the answer .  so, N(4) = ( N(2) * N(2) ) * 1 + 1 = (1 * 1) * 1 + 1 = 2 \\n* **8**:  8 = 2 * 4 .  as we know N(4) = 2 , N(2) = 1 and here both the factors are different so we will multiply their product by 2 and add to the answer. so, N(8) = ( (N(2) * N(4) ) * 2 + 1 = 5 .  now 8 can be also written as 8 = 4 * 2 . However, as we previously stated, we would only select one combination between (2, 4) and (4, 2), thus we multiplied the product of N(2) and N(4) by 2.  \\n* **16**: 16 = 4 * 4 and 16 = 2 * 8 . so we can say , N(16) = N(4) * N(4) * 1 + N(2) * N ( 8) * 2 + 1 = 2 * 2 * 1 + 5 * 1 * 2 + 1 = 15 . \\n\\nHere are the trees which have 2,4 and 8 as their root node respectively ,\\n\\n![image](https://assets.leetcode.com/users/images/d6ff0304-571c-4f24-9051-8f2c59873316_1660044028.5125227.png)\\nnow **N(T) = N(16) + N(8) + N(4) + N(2) = 15 + 5 + 2 + 1 = 23**\\n\\nRecursive DP Solution : \\n\\n```\\nclass Solution {\\npublic:\\n    map<int,int> factor;\\n    int MOD = 1e9 + 7 ;\\n    void setUp(vector<int>& arr) {\\n        for ( int i = 0 ; i < arr.size() ; i++) factor[arr[i]] = i+1 ;\\n    }\\n\\n    int solution(vector<int>& arr, vector<int>& dp, int index) {\\n        if ( index < 0) return 0 ;\\n        if ( dp[index] != -1) return dp[index];\\n        dp[index] = 1 ;\\n        for ( int i = 2 ; i*i <= arr[index] ; i++ ) {\\n            if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i]) {\\n                long long way1 = solution(arr,dp,factor[i]-1)%MOD;\\n                long long way2 = solution(arr,dp,factor[arr[index]/i]-1)%MOD;\\n                long long prod = (way1*way2)%MOD ;\\n                if ( i == arr[index]/i) dp[index] += prod;\\n                else dp[index] += ((2*prod)%MOD) ;\\n                dp[index] = dp[index]%MOD;\\n            }\\n        }\\n        return dp[index]%MOD;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        setUp(arr);\\n        vector <int> dp (arr.size()+2,-1);\\n        long long ans = 0 ;\\n        for ( int i = arr.size()-1 ; i >= 0 ; i-- ) ans += ((solution(arr,dp,i)%MOD)%MOD) ;   \\n        return ans%MOD ;\\n    }\\n};\\n```\\nNow let me explain some of lines of my code : \\n\\n* Suppose A = B * C and A = C * B ( Here, B < C ) line below will take only the pair B * C in count . \\n  \\n  ```\\n       for ( int i = 2 ; i*i <= arr[index] ; i++ )\\n  ```\\n*  Suppose A = D * D then we will mutiply N(D) * N (D) by 1 and if A = B * C then we will multiply N(B) * N(C) by 2 .\\n    ```\\n        if ( i == arr[index]/i) dp[index] += prod;\\n        else dp[index] += ((2*prod)%MOD) ;\\n    ```\\n\\n*  Every Node itself is a binary tree .\\n    ```\\n        dp[index] = 1 \\n   ```\\n\\n*  Let Us check if both the factors are presented in the array arr[] with the help of map which we constructed  . \\n   ```\\n      if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i])\\n   ```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> factor;\\n    int MOD = 1e9 + 7 ;\\n    void setUp(vector<int>& arr) {\\n        for ( int i = 0 ; i < arr.size() ; i++) factor[arr[i]] = i+1 ;\\n    }\\n\\n    int solution(vector<int>& arr, vector<int>& dp, int index) {\\n        if ( index < 0) return 0 ;\\n        if ( dp[index] != -1) return dp[index];\\n        dp[index] = 1 ;\\n        for ( int i = 2 ; i*i <= arr[index] ; i++ ) {\\n            if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i]) {\\n                long long way1 = solution(arr,dp,factor[i]-1)%MOD;\\n                long long way2 = solution(arr,dp,factor[arr[index]/i]-1)%MOD;\\n                long long prod = (way1*way2)%MOD ;\\n                if ( i == arr[index]/i) dp[index] += prod;\\n                else dp[index] += ((2*prod)%MOD) ;\\n                dp[index] = dp[index]%MOD;\\n            }\\n        }\\n        return dp[index]%MOD;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        setUp(arr);\\n        vector <int> dp (arr.size()+2,-1);\\n        long long ans = 0 ;\\n        for ( int i = arr.size()-1 ; i >= 0 ; i-- ) ans += ((solution(arr,dp,i)%MOD)%MOD) ;   \\n        return ans%MOD ;\\n    }\\n};\\n```\n```\\n       for ( int i = 2 ; i*i <= arr[index] ; i++ )\\n  ```\n```\\n        if ( i == arr[index]/i) dp[index] += prod;\\n        else dp[index] += ((2*prod)%MOD) ;\\n    ```\n```\\n        dp[index] = 1 \\n   ```\n```\\n      if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i])\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2401937,
                "title": "c-2-approaches-tc-o-n-2-sc-o-n",
                "content": "```\\n//Approach 1 : Top-Down Recursive Approach \\n/*\\n1 . First sort the array (Now we can say 2 number multiple is always its left side )\\n2 . Using 2 Pointer find out the 2 numbers (s=0 && e =n-1)\\n3 . if arr[s]*arr[e]==arr[curInd] It means arr[s] and arr[e] is 2 child (and increase s++ and decrese e--)\\n{\\nIf we found 2 no then again recursively call for child (total no of tree formed using both child)\\nchild1 = x\\nchild2 = y\\ntotal no of tree for current parent = x*y (if s==e)\\nor\\ntotal no of tree for current parent = 2 * x*y (if s!=e)\\n}\\n\\tif arr[s]*arr[e]>arr[curInd] then we have to decrease our e--\\n\\telse s++\\n4 .Using this approach we can find all no of pairs for every index \\n*/\\n/*\\nExample : 2 10 4 5\\n1 . sort the array :-> 2 4 5 10\\n2 . start from index 0 or n-1( here i am starting with n-1) \\ns = 0 \\ne = 3-1 = 2\\n2 4 5 10\\n^   ^\\nmul = 2*5 = 10\\nHere we got 10 (2,5 is one pair)\\n2!=5 (or s!=e)\\ndp[curInd] = 2 * dp[s]*dp[e]\\nagain call for n-1 recursively\\n*/\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod = 1000000007;\\n    long solve(vector<int>&arr,int ind){\\n        if(ind==-1) return 0; \\n        if(dp[ind]!=-1) return dp[ind];\\n        long cnt = 1;\\n        int s = 0;\\n        int e = ind-1;\\n        while(s<=e){\\n            long mul = (long)arr[s]*arr[e];\\n            if(mul==arr[ind]){\\n                long temp = (solve(arr,s) * solve(arr,e))%mod;\\n                if(s!=e) temp=temp*2;\\n                cnt = (cnt+temp)%mod;\\n                s++;\\n                e--;\\n            }\\n            else if(mul>arr[ind]) e--;\\n            else s++;\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n       sort(arr.begin(),arr.end());\\n      dp.resize(arr.size(),-1);\\n        long cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=(cnt+solve(arr,i))%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n//Approach 2 : Bottom-Up \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        vector<long> dp(arr.size(),1);\\n        int ans = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int s = 0;\\n            int e = i-1;\\n            while(s<=e){\\n                long mul = (long)arr[s]*arr[e];\\n                if(mul==arr[i]){\\n                    long cnt = (dp[s]*dp[e]) %mod;\\n                    if(s!=e) cnt*=2;\\n                    dp[i]= (dp[i]+cnt)%mod;\\n                    e--;\\n                    s++;\\n                }\\n                else if(mul>arr[i]) e--;\\n                else s++;\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Approach 1 : Top-Down Recursive Approach \\n/*\\n1 . First sort the array (Now we can say 2 number multiple is always its left side )\\n2 . Using 2 Pointer find out the 2 numbers (s=0 && e =n-1)\\n3 . if arr[s]*arr[e]==arr[curInd] It means arr[s] and arr[e] is 2 child (and increase s++ and decrese e--)\\n{\\nIf we found 2 no then again recursively call for child (total no of tree formed using both child)\\nchild1 = x\\nchild2 = y\\ntotal no of tree for current parent = x*y (if s==e)\\nor\\ntotal no of tree for current parent = 2 * x*y (if s!=e)\\n}\\n\\tif arr[s]*arr[e]>arr[curInd] then we have to decrease our e--\\n\\telse s++\\n4 .Using this approach we can find all no of pairs for every index \\n*/\\n/*\\nExample : 2 10 4 5\\n1 . sort the array :-> 2 4 5 10\\n2 . start from index 0 or n-1( here i am starting with n-1) \\ns = 0 \\ne = 3-1 = 2\\n2 4 5 10\\n^   ^\\nmul = 2*5 = 10\\nHere we got 10 (2,5 is one pair)\\n2!=5 (or s!=e)\\ndp[curInd] = 2 * dp[s]*dp[e]\\nagain call for n-1 recursively\\n*/\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod = 1000000007;\\n    long solve(vector<int>&arr,int ind){\\n        if(ind==-1) return 0; \\n        if(dp[ind]!=-1) return dp[ind];\\n        long cnt = 1;\\n        int s = 0;\\n        int e = ind-1;\\n        while(s<=e){\\n            long mul = (long)arr[s]*arr[e];\\n            if(mul==arr[ind]){\\n                long temp = (solve(arr,s) * solve(arr,e))%mod;\\n                if(s!=e) temp=temp*2;\\n                cnt = (cnt+temp)%mod;\\n                s++;\\n                e--;\\n            }\\n            else if(mul>arr[ind]) e--;\\n            else s++;\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n       sort(arr.begin(),arr.end());\\n      dp.resize(arr.size(),-1);\\n        long cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=(cnt+solve(arr,i))%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n//Approach 2 : Bottom-Up \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        vector<long> dp(arr.size(),1);\\n        int ans = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int s = 0;\\n            int e = i-1;\\n            while(s<=e){\\n                long mul = (long)arr[s]*arr[e];\\n                if(mul==arr[i]){\\n                    long cnt = (dp[s]*dp[e]) %mod;\\n                    if(s!=e) cnt*=2;\\n                    dp[i]= (dp[i]+cnt)%mod;\\n                    e--;\\n                    s++;\\n                }\\n                else if(mul>arr[i]) e--;\\n                else s++;\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401629,
                "title": "binary-tree-with-factors-c-explained-solution",
                "content": "The question here is quite good and needs some good observations. Lets try to find how will we count this number of trees. Lets take an array : **[2 , 4 , 5 , 10 , 20]**. Now we know that **2** and **5** will form only a single tree because they are prime. What about **4, 10 and 20 ?**. Lets see, basically every number can be a binary tree of single node with this number as the root but for composite numbers they can also be subdivided into its factors. Now lets take **4**, Now since 4 has only **2** as its other factor **( 1 is not considered cause it has been considered already when number itself is root, moreover array will contain numbers only greater than 1 )** . Since **2** and **4/2 = 2** are same only thus swapping them as right and left child will not create a new tree. Thus we need to count this only once. But lets take **10**, Now 10 can be single (root only) and **10** can be divided into **2** and **5** too. Since both of them are different and both of them are present in the array also thus for this pair we have **2 distinct trees**. Thus recursive relation looks something like :\\n\\n**ans = ans + ways(i) x ways(num/i)**\\n\\n**Note num should be divisible by i.  Secondly the value of ans = 1 initially, this is done to count the trees when tree consists of only a single node (number itself). We could also have used a loop for factorising num but by this way we would encounter a lot of numbers that are useless cause they might not be present inside the array. So its better that we focus on the numbers that are given in the array. By this way we also reduce the time complexity. Also we use a hashmap for storing DP states cause numbers are very big**. 2 Code implementations are given below :\\n\\n**Implementation 1 : Less Optimised**\\nTime Complexity :  O(N x Sum(root(A[i]))) for all i from **0 to N-1**\\nSpace Complexity : O(N), cause we store results only for numbers in the array.\\n**PS : You can also see that there is also a bit change in recursive relation in this implementation**\\n\\nCode :\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(ll j = 2; j*j<=val; j++){\\n            if(val%j==0){\\n                if(mp.find(j)!=mp.end() && mp.find(val/j)!=mp.end()){\\n                    if(j*j==val){\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                    else{\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        prod = (prod*2)%mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){            \\n\\t\\t\\tans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Implementation 2 : Most Optimised**\\nTime Complexity : O(N^2)\\nSpace Complexity : O(N), cause we are storing results for numbers that are present in array else not.\\n\\nCode : \\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(auto it : mp){\\n            ll j = it.first;\\n            if(val%j==0 && mp.find(val/j)!=mp.end()){\\n                ll prod = ways(j)*ways(val/j);\\n                prod%=mod;\\n                ans+=prod;\\n                ans%=mod;\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){\\n            ans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote If Found Helpful !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(ll j = 2; j*j<=val; j++){\\n            if(val%j==0){\\n                if(mp.find(j)!=mp.end() && mp.find(val/j)!=mp.end()){\\n                    if(j*j==val){\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                    else{\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        prod = (prod*2)%mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){            \\n\\t\\t\\tans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(auto it : mp){\\n            ll j = it.first;\\n            if(val%j==0 && mp.find(val/j)!=mp.end()){\\n                ll prod = ways(j)*ways(val/j);\\n                prod%=mod;\\n                ans+=prod;\\n                ans%=mod;\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){\\n            ans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401425,
                "title": "c-hashmap-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n= arr.size();\\n        vector<long long> dp(n,1);\\n        int mod= 1e9+7;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        //element --> index\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n; i++)\\n            mp[arr[i]] = i;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(arr[i]%arr[j]==0) {\\n                    int quo = arr[i]/arr[j];\\n                    if(mp.count(quo)) {\\n                        dp[i] += dp[j] * dp[mp[quo]];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long result = 0;\\n        for(auto &ele : dp) {\\n            result += ele;\\n        }\\n        \\n        return result%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n= arr.size();\\n        vector<long long> dp(n,1);\\n        int mod= 1e9+7;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        //element --> index\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n; i++)\\n            mp[arr[i]] = i;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(arr[i]%arr[j]==0) {\\n                    int quo = arr[i]/arr[j];\\n                    if(mp.count(quo)) {\\n                        dp[i] += dp[j] * dp[mp[quo]];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long result = 0;\\n        for(auto &ele : dp) {\\n            result += ele;\\n        }\\n        \\n        return result%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401291,
                "title": "c-solution-time-o-n-k-memory-o-n-easy-to-understand-dynamic-programming-dictionary",
                "content": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        Dictionary<int, long> memo = new ();\\n        \\n        HashSet<int> nums = new (arr);\\n        int ans = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n            ans = (ans + (int)Solve(arr[i])) % _mod;\\n        \\n        return ans;\\n        \\n        long Solve(int num) {\\n            if (memo.TryGetValue(num, out var memoizedResult)) return memoizedResult;\\n            \\n            long count = 0;\\n            if (nums.Contains(num)) {\\n                count++;\\n\\n                int sqrt = (int)Math.Sqrt(num);\\n                for (int i = 2; i <= sqrt; i++) {\\n                    if (num % i == 0) {\\n                        int t = num / i;\\n                        long p = Solve(i) * Solve(t) % _mod;\\n                        count = (count + (int)p) % _mod;\\n                        if (i != t) count = (count + (int)p) % _mod;\\n                    }\\n                }\\n            }\\n            \\n            memo[num] = count;\\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        Dictionary<int, long> memo = new ();\\n        \\n        HashSet<int> nums = new (arr);\\n        int ans = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n            ans = (ans + (int)Solve(arr[i])) % _mod;\\n        \\n        return ans;\\n        \\n        long Solve(int num) {\\n            if (memo.TryGetValue(num, out var memoizedResult)) return memoizedResult;\\n            \\n            long count = 0;\\n            if (nums.Contains(num)) {\\n                count++;\\n\\n                int sqrt = (int)Math.Sqrt(num);\\n                for (int i = 2; i <= sqrt; i++) {\\n                    if (num % i == 0) {\\n                        int t = num / i;\\n                        long p = Solve(i) * Solve(t) % _mod;\\n                        count = (count + (int)p) % _mod;\\n                        if (i != t) count = (count + (int)p) % _mod;\\n                    }\\n                }\\n            }\\n            \\n            memo[num] = count;\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401267,
                "title": "c-most-efficient-approach-beats-99",
                "content": "***Simple Approach***\\n1. Assume dp[i] is the number of combinations and the recurrence relation is:\\n***dp[i]=1+sum(dp[j]*dp[k]) for j=0 to i-1 and A[k]=A[i]/A[j]***\\n*we have to sort the array in ascending order so that the recurrence relation is correct.*\\n\\n2. Use the hash set to store all the numbers before i to save lookup time.\\nBe sure to use **long long** for **dp[j]*dp[k]**, otherwise it will overflow.\\nalso the accumulation has to use 0LL for the initial value to avoid overflow.\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n\\nPLEASE UPVOTE ****",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2401000,
                "title": "dp-rec-memo-tabul-c",
                "content": "So let\\'s underestand the problem,\\nInput: 2, 5, 6, 10, 4, 3\\nOutput: 11\\n\\nThat means by using these numbers we can create 11 unique binary trees by following the rule,\\n**root_val = left_child_val * right_child_val**\\n\\nFrom this, we can get the left and right values that need to be less than the root. So to efficiently check on fewer values we can sort the array so that all the indices less than will have scope to be its child node.\\n\\nNow let\\'s think of a recursive solution(top-down), For each number from left to right (n-1, 0) as root, let\\'s check how many trees can be made, and let\\'s sum it up.\\n\\nOn recursion, we can check on 0 to i - 1 for finding the left child value and right child value.\\n\\nIf we find left and right children we can run recursion on both of them as roots, and their results multiplication will give us the answer(multiplication to get different combinations). Sorry, I am not good at explanations.\\n\\n**Note**: Taking a map to store index after sort so we can easily check if the right child can be found for the respective left child.\\n\\n**Driver code:**\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\n\\tint n = arr.size();\\n\\tunordered_map<int, int> mp;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmp[arr[i]] = i;\\n\\t}\\n\\n\\tlong ans = 0; \\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tans = (ans + rec(arr, i, mp)) % MOD;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n**Recurssion:**\\n```\\nlong rec(vector<int>& arr, int i, unordered_map<int, int>& mp) {\\n\\tlong ans = 1;\\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = rec(arr, j, mp);\\n\\t\\t\\tlong right = rec(arr, mp[arr[i] / arr[j]], mp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nOptimizing this with DP memoization because this has overlaping sub problem. (Take the example input and try to draw the recursive call). DP can be implemented by few modifications.\\n\\n**Driver Code:**\\n```\\nvector<int> dp(n, -1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\t// Last parameter dp array\\n\\tans = (ans + memo(arr, i, mp, dp)) % MOD;\\n}\\n```\\n\\n**Memoization:**\\n```\\nlong memo(vector<int>& arr, int i, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tif (dp[i] != -1) return dp[i]; // Add on\\n\\tlong ans = 1; \\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = memo(arr, j, mp, dp);\\n\\t\\t\\tlong right = memo(arr, mp[arr[i] / arr[j]], mp, dp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn dp[i] = ans; // Add on\\n}\\n```\\n\\n\\nSo lets optimize memoization to reduce recursive stack space, we can use tabulation(bottom-up).\\n\\n**Driver Code:**\\n```\\nvector<int> dp(n, 0);\\ntabu(arr, n, mp, dp);\\nfor (int i = 0; i < n; i++) {\\n\\tans = (ans + dp[i]) % MOD;\\n}\\n\\nreturn ans;\\n```\\n\\n\\n**Tabulation Code:**\\n```\\nvoid tabu(vector<int>& arr, int n, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint ans = 1;\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\t\\tlong left = dp[j];\\n\\t\\t\\t\\tlong right = dp[mp[arr[i] / arr[j]]];\\n\\t\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = ans;\\n\\t}\\n}\\n```\\n\\nWe can\\'t further space optimaize this because of `dp[mp[arr[i] / arr[j]]]` which can be any previous index.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\n\\tint n = arr.size();\\n\\tunordered_map<int, int> mp;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmp[arr[i]] = i;\\n\\t}\\n\\n\\tlong ans = 0; \\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tans = (ans + rec(arr, i, mp)) % MOD;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\nlong rec(vector<int>& arr, int i, unordered_map<int, int>& mp) {\\n\\tlong ans = 1;\\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = rec(arr, j, mp);\\n\\t\\t\\tlong right = rec(arr, mp[arr[i] / arr[j]], mp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nvector<int> dp(n, -1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\t// Last parameter dp array\\n\\tans = (ans + memo(arr, i, mp, dp)) % MOD;\\n}\\n```\n```\\nlong memo(vector<int>& arr, int i, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tif (dp[i] != -1) return dp[i]; // Add on\\n\\tlong ans = 1; \\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = memo(arr, j, mp, dp);\\n\\t\\t\\tlong right = memo(arr, mp[arr[i] / arr[j]], mp, dp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn dp[i] = ans; // Add on\\n}\\n```\n```\\nvector<int> dp(n, 0);\\ntabu(arr, n, mp, dp);\\nfor (int i = 0; i < n; i++) {\\n\\tans = (ans + dp[i]) % MOD;\\n}\\n\\nreturn ans;\\n```\n```\\nvoid tabu(vector<int>& arr, int n, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint ans = 1;\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\t\\tlong left = dp[j];\\n\\t\\t\\t\\tlong right = dp[mp[arr[i] / arr[j]]];\\n\\t\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = ans;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400878,
                "title": "c-solution-dynamic-programming-explained",
                "content": "**Language Used: C++**\\n\\n*If you have any questions, feel free to ask. If you like the solution and explanation, please **upvote!***\\n\\nTime: O(n^2);\\nSpace: O(n)\\n\\n*  dp[i] := represents possible combinationswith ith element at its node;\\n*  Lets arr[] be {x, y, x*y}; dp[0]:= contains possible ans for x as its root.\\n*  Same goes for dp[1], but in dp[2] we need to check.\\n*  Check whether x divides (x*y), if yes then it might acct as left node.\\n*  Check whether right node is present (using hashmap).\\n*  Save results in dp (dp[i] += dp[left] * dp[right]).\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        constexpr int Mod = 1e9 + 7;\\n        const int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long> dp(n, 1);\\n        // Initialized with 1 because we can make atleast 1 BT with that number.\\n        \\n        unordered_map<int, int> Ind;\\n        \\n        for(int i{}; i<n; i++){\\n            Ind[arr[i]] = i;\\n        }\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    int rig = arr[i]/arr[j];\\n\\t\\t\\t\\t\\t// Checking whether right exists?\\n                    if(Ind.count(rig)){\\n                        dp[i] += dp[j] * dp[Ind[rig]];\\n                        dp[i] %= Mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return accumulate(dp.begin(), dp.end(), 0L)%Mod;\\n    }\\n};\\n```\\nKeep Coding\\n**`while(!success){ tryAgain(); } :)`**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        constexpr int Mod = 1e9 + 7;\\n        const int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long> dp(n, 1);\\n        // Initialized with 1 because we can make atleast 1 BT with that number.\\n        \\n        unordered_map<int, int> Ind;\\n        \\n        for(int i{}; i<n; i++){\\n            Ind[arr[i]] = i;\\n        }\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    int rig = arr[i]/arr[j];\\n\\t\\t\\t\\t\\t// Checking whether right exists?\\n                    if(Ind.count(rig)){\\n                        dp[i] += dp[j] * dp[Ind[rig]];\\n                        dp[i] %= Mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return accumulate(dp.begin(), dp.end(), 0L)%Mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400275,
                "title": "java-solution-using-sorting-and-dp",
                "content": "Main Points :\\nSort the array , as we have to find for each element present in arr[i] , **can we make it a parent node by multplying its children** , basically does **both factors of a element are present in order to make it a parent node.**\\nIf we find that the factors are indeed present **we further have to multiply the number of ways of both children** ,in which these children can be formed if they are present as parent node.\\nso for each element we store the number of ways in which it can be a parent element in a dp array.\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long trees = 0;\\n        long mod = (long)1e9+7;\\n\\t\\t// making a dp array to store at each point the numbers of ways to make a tree if the current element is taken as parent node\\n        long []dp = new long[n];\\n        \\n        for( int i=0; i<n; i++ ){\\n\\t\\t\\t// current trees initialized as 1 , as a number can always make a single by itself\\n            long curr = 1;\\n            \\n            int lo = 0;\\n            int hi = i-1;\\n            \\n\\t\\t\\t// two pointers approach to find the factors of current element and if both factors are present in the array\\n            while( lo <= hi ){\\n                \\n                long prod = arr[lo] * arr[hi];\\n\\t\\t\\t\\t// check to find factors and second check to make sure that the number is valid ( i did this check as i was encountering a problem in a testcase even though the numbers were big their product was small and coming out to be exact as current element)\\n                if( prod == ( arr[i] % mod ) && arr[lo] <= ( arr[i]/2 ) && arr[hi] <= ( arr[i]/2 ) ){\\n                    int diff = 2;\\n\\t\\t\\t\\t\\t// if both the numbers are same there is only one way we can arrange as either being on left or right is same for them\\n                    if( arr[lo] == arr[hi] ) diff = 1;\\n                    curr = ( curr +  ( ( ( dp[hi] * dp[lo] ) % mod ) * diff ) % mod ) % mod;\\n                    lo++;\\n                    hi--;\\n                }\\n                else if ( prod > arr[i] ) hi--;\\n                else lo++;\\n            }\\n            // storing the current trees\\n            dp[i] = curr;\\n\\t\\t\\t// storing total trees we can make\\n            trees = ( trees + curr )%mod;\\n        }\\n        \\n        return (int)trees;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long trees = 0;\\n        long mod = (long)1e9+7;\\n\\t\\t// making a dp array to store at each point the numbers of ways to make a tree if the current element is taken as parent node\\n        long []dp = new long[n];\\n        \\n        for( int i=0; i<n; i++ ){\\n\\t\\t\\t// current trees initialized as 1 , as a number can always make a single by itself\\n            long curr = 1;\\n            \\n            int lo = 0;\\n            int hi = i-1;\\n            \\n\\t\\t\\t// two pointers approach to find the factors of current element and if both factors are present in the array\\n            while( lo <= hi ){\\n                \\n                long prod = arr[lo] * arr[hi];\\n\\t\\t\\t\\t// check to find factors and second check to make sure that the number is valid ( i did this check as i was encountering a problem in a testcase even though the numbers were big their product was small and coming out to be exact as current element)\\n                if( prod == ( arr[i] % mod ) && arr[lo] <= ( arr[i]/2 ) && arr[hi] <= ( arr[i]/2 ) ){\\n                    int diff = 2;\\n\\t\\t\\t\\t\\t// if both the numbers are same there is only one way we can arrange as either being on left or right is same for them\\n                    if( arr[lo] == arr[hi] ) diff = 1;\\n                    curr = ( curr +  ( ( ( dp[hi] * dp[lo] ) % mod ) * diff ) % mod ) % mod;\\n                    lo++;\\n                    hi--;\\n                }\\n                else if ( prod > arr[i] ) hi--;\\n                else lo++;\\n            }\\n            // storing the current trees\\n            dp[i] = curr;\\n\\t\\t\\t// storing total trees we can make\\n            trees = ( trees + curr )%mod;\\n        }\\n        \\n        return (int)trees;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400239,
                "title": "java-based-on-concept-of-two-sum-really-easy-solution-fastest",
                "content": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int numFactoredBinaryTrees(int[] arr) \\n    {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long[] dp = new long[n];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int numFactoredBinaryTrees(int[] arr) \\n    {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long[] dp = new long[n];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400065,
                "title": "c-easy-understanding-top-down-dp-solution",
                "content": "The top-down idea is straightforward, just to find the total counts of each number, and sum up with sub-recursions. The sub-nodes can be found with simple factor calculation, each number will be calculated only once.\\n\\n```\\nclass Solution {\\n    unordered_set<int> set;\\n    unordered_map<int, long long> map;\\n    long long mod = 1e9+7;\\npublic:\\n    long long findCount(vector<int> &arr, int num1) {\\n        if(map.find(num1) != map.end()) return map[num1];\\n\\t\\t// for each number, at least counts itself as leaf\\n        long long cnt = 1;\\n        for(int num2: arr) {\\n\\t\\t\\t// find sub-nodes\\n            if(num2 <= num1 && num1 % num2 == 0 && set.count(num1 / num2)) {\\n                cnt += findCount(arr, num2) * findCount(arr, num1 / num2);\\n            }\\n        }\\n        return map[num1] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long ans = 0;\\n        set.insert(arr.begin(), arr.end());\\n        for(int num: arr) {\\n            ans += findCount(arr, num);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity: `O(n^2)`\\nSpace complexity: `O(n)`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<int> set;\\n    unordered_map<int, long long> map;\\n    long long mod = 1e9+7;\\npublic:\\n    long long findCount(vector<int> &arr, int num1) {\\n        if(map.find(num1) != map.end()) return map[num1];\\n\\t\\t// for each number, at least counts itself as leaf\\n        long long cnt = 1;\\n        for(int num2: arr) {\\n\\t\\t\\t// find sub-nodes\\n            if(num2 <= num1 && num1 % num2 == 0 && set.count(num1 / num2)) {\\n                cnt += findCount(arr, num2) * findCount(arr, num1 / num2);\\n            }\\n        }\\n        return map[num1] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long ans = 0;\\n        set.insert(arr.begin(), arr.end());\\n        for(int num: arr) {\\n            ans += findCount(arr, num);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958524,
                "title": "c-dp-solution-o-n-2",
                "content": "Runtime: 77 ms, faster than 71.87% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 9.2 MB, less than 77.68% of C++ online submissions for Binary Trees With Factors.\\n\\n\\n```\\nWe can get the tree count for current number from the tree count of the factors of the current number.\\nSo, Binary Tree count for num => DP[num] += DP[X] * DP[num/X] where X and num/X are factors\\n\\n1. Sort the numbers and process smaller numbers first as they will be the factor of larger number\\n2. Then loop from first to current number and check if previous values are factors of current number \\nupdate tree count for number using DP equation\\n3. User Hash Table to track the count of tree for each number as root\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n\\n        // track the tree count for each number as root\\n        unordered_map<int,long long>dp;\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[arr[i]] = 1L;    // each number is root itself\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if((arr[i] % arr[j]) == 0)\\n                {\\n                    // both factor present in dp, then add the tree count\\n                    if(dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]] =  (dp[arr[i]] + dp[arr[j]] * dp[arr[i]/arr[j]]) % MOD;\\n                }                \\n            }\\n            \\n            count = (count + dp[arr[i]]) % MOD;\\n        }\\n        \\n        return count;   // total tree count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nWe can get the tree count for current number from the tree count of the factors of the current number.\\nSo, Binary Tree count for num => DP[num] += DP[X] * DP[num/X] where X and num/X are factors\\n\\n1. Sort the numbers and process smaller numbers first as they will be the factor of larger number\\n2. Then loop from first to current number and check if previous values are factors of current number \\nupdate tree count for number using DP equation\\n3. User Hash Table to track the count of tree for each number as root\\n```\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n\\n        // track the tree count for each number as root\\n        unordered_map<int,long long>dp;\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[arr[i]] = 1L;    // each number is root itself\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if((arr[i] % arr[j]) == 0)\\n                {\\n                    // both factor present in dp, then add the tree count\\n                    if(dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]] =  (dp[arr[i]] + dp[arr[j]] * dp[arr[i]/arr[j]]) % MOD;\\n                }                \\n            }\\n            \\n            count = (count + dp[arr[i]]) % MOD;\\n        }\\n        \\n        return count;   // total tree count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400606,
                "title": "simple-python-dynamic-programming-solution",
                "content": "```\\nMOD = 1000000007\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # smaller numbers multiply to form a larger number\\n        # after sorting we only have to worry about numbers\\n        # to the left of the current number\\n        arr.sort()\\n        # let dp[x] be the number of possible binary trees we\\n        # can form using x as the root\\n        dp = {x: 1 for x in arr}\\n        # iterate through each number, using it as the root\\n        for i in range(len(arr)):\\n            # iterate through all numbers smaller than the current\\n            # number\\n            for j in range(i):\\n                # check if big/small is in array, if yes, there\\'d be\\n                # dp[small]*dp[big/small] possible trees with big as\\n                # root\\n                if arr[i]/arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]]*dp[arr[i]/arr[j]]\\n        \\n        return sum(dp[x] for x in dp) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nMOD = 1000000007\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # smaller numbers multiply to form a larger number\\n        # after sorting we only have to worry about numbers\\n        # to the left of the current number\\n        arr.sort()\\n        # let dp[x] be the number of possible binary trees we\\n        # can form using x as the root\\n        dp = {x: 1 for x in arr}\\n        # iterate through each number, using it as the root\\n        for i in range(len(arr)):\\n            # iterate through all numbers smaller than the current\\n            # number\\n            for j in range(i):\\n                # check if big/small is in array, if yes, there\\'d be\\n                # dp[small]*dp[big/small] possible trees with big as\\n                # root\\n                if arr[i]/arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]]*dp[arr[i]/arr[j]]\\n        \\n        return sum(dp[x] for x in dp) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108540,
                "title": "c-dp-o-n-2-88ms",
                "content": "\\n\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        std::sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        vector<long long> dp(n, 1);\\n        int mod = 1e9 + 7;\\n        std::unordered_map<int, int> pos;\\n        for(int i = 0; i < n; ++i) {\\n            pos[arr[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < i; ++j) {\\n                if (arr[i] % arr[j] > 0 ) continue;\\n                int current = arr[i] / arr[j];\\n                if (pos.find(current) != pos.end()) {\\n                    dp[i] += dp[pos[current]] * dp[j];\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(auto& c : dp) {\\n            res += c;\\n        }\\n        return res % mod;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        std::sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        vector<long long> dp(n, 1);\\n        int mod = 1e9 + 7;\\n        std::unordered_map<int, int> pos;\\n        for(int i = 0; i < n; ++i) {\\n            pos[arr[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < i; ++j) {\\n                if (arr[i] % arr[j] > 0 ) continue;\\n                int current = arr[i] / arr[j];\\n                if (pos.find(current) != pos.end()) {\\n                    dp[i] += dp[pos[current]] * dp[j];\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(auto& c : dp) {\\n            res += c;\\n        }\\n        return res % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1108077,
                "title": "javascript-simple-dp-approach",
                "content": "Time: `O(N^2)`\\nSpace: `O(N)`\\n```javascript\\nvar numFactoredBinaryTrees = function(arr) {\\n    const memo = new Map();\\n    const mod = 10**9 + 7\\n    \\n    arr.sort((a, b) => a - b);\\n    arr.forEach(num => memo.set(num, 1))\\n           \\n    for(let i = 1; i < arr.length; i++) {\\n        \\n        for(let j = i-1; j >= 0; j--) {\\n            \\n            if(arr[i] % arr[j]) continue; // if the number doesn\\'t divide \\n            \\n            const num2 = arr[i] / arr[j];;\\n            \\n            if(!memo.has(num2)) continue; // if the complimentary number doesn\\'t exit\\n            \\n            const waysToNum1 = memo.get(arr[j]);\\n            const waysToNum2 = memo.get(num2);\\n            const totalWays = waysToNum1 * waysToNum2;\\n            \\n            memo.set(arr[i], (memo.get(arr[i]) + totalWays));\\n        }\\n    }\\n    \\n    const totalTrees = [...memo.values()].reduce((acc, cur) => acc + cur, 0);\\n    return totalTrees % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(arr) {\\n    const memo = new Map();\\n    const mod = 10**9 + 7\\n    \\n    arr.sort((a, b) => a - b);\\n    arr.forEach(num => memo.set(num, 1))\\n           \\n    for(let i = 1; i < arr.length; i++) {\\n        \\n        for(let j = i-1; j >= 0; j--) {\\n            \\n            if(arr[i] % arr[j]) continue; // if the number doesn\\'t divide \\n            \\n            const num2 = arr[i] / arr[j];;\\n            \\n            if(!memo.has(num2)) continue; // if the complimentary number doesn\\'t exit\\n            \\n            const waysToNum1 = memo.get(arr[j]);\\n            const waysToNum2 = memo.get(num2);\\n            const totalWays = waysToNum1 * waysToNum2;\\n            \\n            memo.set(arr[i], (memo.get(arr[i]) + totalWays));\\n        }\\n    }\\n    \\n    const totalTrees = [...memo.values()].reduce((acc, cur) => acc + cur, 0);\\n    return totalTrees % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107886,
                "title": "c-dynamic-programming-two-pointer",
                "content": "This solution revolves around constructing solutions for larger numbers provided in `arr` by first building solutions for smaller numbers in `arr` and then building these solutions using dynamic programming.\\n\\nWe start by sorting `arr` so that we can traverse it in an increasing order, since larger numbers cannot be factors of smaller numbers that precede them, but smaller numbers in  `arr` can be factors of larger numbers in `arr`.\\n\\nThen, we build our `dp` array of type `long` and initialize all elements to 1. This is because every element in the `dp` represents something that appears in `arr`, and so by definition, there is *at least* one way to build said element as a binary tree (i.e. an empty tree rooted at that element). We use type `long` to avoid overflow error in our calculations.\\n\\nFrom here, we use `dppos` to represent the element in `arr` currently under consideration. For this element, we are aiming to answer the question ***for this element, using smaller elements in the array, how many ways can we represent this element as a binary tree under the rules stipulated in the problem description?*** To do so, we iterate through all elements in `arr` smaller than the given element using two pointers, with a left pointer starting at the smallest element and a right pointer starting at the highest element. At each point, we run into three cases:\\n1. If the product of `arr[left]` and `arr[right]` exceed the given element, we know our product is too large, so we decrement `right`.\\n2. If the product of `arr[left]` and `arr[right]` is less than the given element, we know our product is too small, so we increment `left`.\\n3. Otherwise, we have found a way to represent the given element as a factor of two smaller elements, so we increase our count of the number of ways to make the current element (i.e. `dp[dppos]`) by the product of the number of ways to make each of the smaller elements, because for each subtree rooted at the given element, we have a choice on which \"way\" we are going to make the factor of the larger element. Note that if we are multiplying the same element twice, we do not multiply the overall product by 2, since the same element is being used twice, creating an inherent symmetry in the tree.\\n\\nTo avoid overflow, we cast operand to type `long` and use the modulo operator at the end of each iteration. Using a global `total` variable allows us to keep track of the total number of trees capable of being made with this array as we go along, which we return as our final answer.\\n\\nThis method requires linear extra space in the number of elements in `arr` and requires quadratic time, since for each element in `arr` we are looping through elements smaller than it.\\n\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\tvector<long> dp(arr.size(), 1);\\n\\tint total = 0;\\n\\tfor (int dppos = 0; dppos < dp.size(); dppos++) {\\n\\t\\tint left = 0, right = dppos - 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tif (long(arr[left]) * arr[right] > arr[dppos]) {\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else if (long(arr[left]) * arr[right] < arr[dppos]) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\t\\tdp[dppos] += (dp[left] * dp[right]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[dppos] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttotal = ((total % 1000000007) + dp[dppos]) % 1000000007;   \\n\\t}\\n\\treturn total;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\tvector<long> dp(arr.size(), 1);\\n\\tint total = 0;\\n\\tfor (int dppos = 0; dppos < dp.size(); dppos++) {\\n\\t\\tint left = 0, right = dppos - 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tif (long(arr[left]) * arr[right] > arr[dppos]) {\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else if (long(arr[left]) * arr[right] < arr[dppos]) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\t\\tdp[dppos] += (dp[left] * dp[right]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[dppos] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttotal = ((total % 1000000007) + dp[dppos]) % 1000000007;   \\n\\t}\\n\\treturn total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107767,
                "title": "java-easy-to-understand-recursive",
                "content": "1. Go from each node as root and then try to find out number of tree from that number as a root\\n2. Creating Map `numToIndex` that can give Index of the number as well as if that number is present to verify factors are there\\n3. `dp` to store each number with number of trees it can form, for memoization\\n\\n```\\nclass Solution {\\n    final static int MOD = 1000_000_000 + 7;\\n    int[] arr;\\n    Map<Integer, Integer> numToIndex;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        numToIndex = new HashMap<>();\\n        this.arr = arr;\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp, -1);\\n        for(int i=0;i<arr.length;i++) numToIndex.put(arr[i], i);\\n        \\n        long total = 0;\\n        for(int i=0;i<arr.length;i++) {\\n            total += getNumBinaryTrees(arr[i], dp);\\n        }\\n        return (int) (total % MOD);\\n    }\\n    \\n    private long getNumBinaryTrees(int num, long[] dp) {\\n\\t\\t/// Don\\'t process this number if this number not even present in input `arr`\\n        if(!numToIndex.containsKey(num)) return 0;\\n        \\n        int index = numToIndex.get(num);\\n\\t\\t/// if for this `num` we already calculated the result, then return the result\\n        if(dp[index] != -1) return dp[index];\\n        \\n\\t\\t/// Very beginning single node can form a tree, so initialize count = 1\\n        long count = 1;\\n        \\n        for(int i=0;i<arr.length;i++) {\\n\\t\\t\\t// Check if this `arr[i]` is factor of parameter `num` as well as there is other factor `num / arr[i]` present in input \\n            if(num % arr[i] == 0 && numToIndex.containsKey(num / arr[i])) {\\n                count += (getNumBinaryTrees(arr[i], dp) * getNumBinaryTrees(num / arr[i], dp)); \\n            }\\n        }\\n\\t\\t/// Update DP with count we found\\n        dp[index] = count;\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    final static int MOD = 1000_000_000 + 7;\\n    int[] arr;\\n    Map<Integer, Integer> numToIndex;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        numToIndex = new HashMap<>();\\n        this.arr = arr;\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp, -1);\\n        for(int i=0;i<arr.length;i++) numToIndex.put(arr[i], i);\\n        \\n        long total = 0;\\n        for(int i=0;i<arr.length;i++) {\\n            total += getNumBinaryTrees(arr[i], dp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1107610,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\\n        let mut hm = arr.iter().map(|&n| (n, 1)).collect::<HashMap<_, _>>();\\n        let mut arr = arr;\\n        arr.sort_unstable();\\n        for i in 1..arr.len() {\\n            for j in 0..i {\\n                if arr[i] % arr[j] == 0 {\\n                    if let Some(&v) = hm.get(&(arr[i] / arr[j])) {\\n                        let vj = *hm.get_mut(&arr[j]).unwrap();\\n                        if let Some(vi) = hm.get_mut(&arr[i]) {\\n                            *vi = (*vi + vj * v) % MOD\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (hm.values().sum::<i64>() % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\\n        let mut hm = arr.iter().map(|&n| (n, 1)).collect::<HashMap<_, _>>();\\n        let mut arr = arr;\\n        arr.sort_unstable();\\n        for i in 1..arr.len() {\\n            for j in 0..i {\\n                if arr[i] % arr[j] == 0 {\\n                    if let Some(&v) = hm.get(&(arr[i] / arr[j])) {\\n                        let vj = *hm.get_mut(&arr[j]).unwrap();\\n                        if let Some(vi) = hm.get_mut(&arr[i]) {\\n                            *vi = (*vi + vj * v) % MOD\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (hm.values().sum::<i64>() % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107357,
                "title": "python-go-by-dp-w-diagram",
                "content": "**Hint**:\\n\\n1. **Sort** A to make it in **ascending order**\\n\\n2. **Scan each root** node value, and **decompose it to all possible factors** (i.e., the so-called child node value in binary tree).\\n\\n3. **Update the number of binary tree** into dp table by dp[ x ] += dp[ y ] * dp[ x / y ]\\n\\n4. Repeat step 2 and step 3 to build DP table in bottom-up order.\\n\\n5. Finally, **sum up the DP table\\'s value** and get the total count.\\n\\n6. **Don\\'t forget to take the mod** (10^9 + 7), which is defined by description.\\n\\n---\\n\\n**Diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/7e2920a0-022f-41d4-8030-3dde4f47e9d5_1615643306.8414311.png)\\n\\n\\n---\\n\\n**Implementation** by classic 2D DP\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(i):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    dp[cur_num] += dp[quotient] * dp[factor]\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for i, curNum := range arr{\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < i ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                dp[curNum] += dp[factor] * dp[quotient]\\n            }\\n            \\n        }\\n        \\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    \\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\\n\\n---\\n\\n**Implementation** by classic 2D DP with improvement on factor search upperbound\\n\\nPython:\\n\\n```\\n# native bisection module in Python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # upper bound is the index of largest factor to cur_num\\n            upperbound = bisect(A ,int(sqrt(cur_num)))\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(upperbound):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    \\n                    if quotient == factor:\\n                        # factor is square root of cur_num\\n                        dp[cur_num] += dp[quotient] * dp[factor]\\n                        \\n                    else:\\n                        # factor is not square root of cur_num\\n                        # (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                        dp[cur_num] += dp[quotient] * dp[factor] * 2\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for _, curNum := range arr{\\n        \\n        upperbound := sort.Search( len(arr), func(i int) bool { return arr[i] > int(math.Sqrt( float64(curNum) ) ) } )\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < upperbound ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                \\n                if quotient == factor{\\n                    \\n                    // factor is square root of cur_num\\n                    dp[curNum] += dp[factor] * dp[quotient]    \\n                    \\n                }else{\\n                    \\n                    // factor is not square root of cur_num\\n                    // (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                    dp[curNum] += dp[factor] * dp[quotient] * 2\\n                }\\n            }\\n            \\n        }\\n        //end of loop j\\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    //end of loop i\\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [MIT OCW: Dynamic Programming](https://youtu.be/OQ5jsbhAv_M)\\n\\n[2] [Python official docs about bisection module](https://docs.python.org/3/library/bisect.html)\\n\\n[3] [Golang official docs about sort and search](https://golang.org/pkg/sort/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(i):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    dp[cur_num] += dp[quotient] * dp[factor]\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for i, curNum := range arr{\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < i ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                dp[curNum] += dp[factor] * dp[quotient]\\n            }\\n            \\n        }\\n        \\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    \\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\n```\\n# native bisection module in Python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # upper bound is the index of largest factor to cur_num\\n            upperbound = bisect(A ,int(sqrt(cur_num)))\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(upperbound):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    \\n                    if quotient == factor:\\n                        # factor is square root of cur_num\\n                        dp[cur_num] += dp[quotient] * dp[factor]\\n                        \\n                    else:\\n                        # factor is not square root of cur_num\\n                        # (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                        dp[cur_num] += dp[quotient] * dp[factor] * 2\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for _, curNum := range arr{\\n        \\n        upperbound := sort.Search( len(arr), func(i int) bool { return arr[i] > int(math.Sqrt( float64(curNum) ) ) } )\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < upperbound ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                \\n                if quotient == factor{\\n                    \\n                    // factor is square root of cur_num\\n                    dp[curNum] += dp[factor] * dp[quotient]    \\n                    \\n                }else{\\n                    \\n                    // factor is not square root of cur_num\\n                    // (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                    dp[curNum] += dp[factor] * dp[quotient] * 2\\n                }\\n            }\\n            \\n        }\\n        //end of loop j\\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    //end of loop i\\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107218,
                "title": "simple-dp-solution-in-java-using-hashmap-and-sorting-explained",
                "content": "Notes before approaching the problem -\\n* The key to this problem is not thinking of it as a tree problem at all. \\n* Just have to think of it as number of ways of forming 3 numbers such that `number1 * number2 == number3 and number3 > number1 and number3 > number2`\\n* The fact that you can use any number any number of times actually makes it easier than complex. You are saved from the hassle of deleting the number or marking it visited etc.\\n\\nImportant points while approaching the problem - \\n* We need to give each element in the array a chance to be a root node and since its childrens\\' multiplication is supposed to equal it, it is better if we sort the array and then move an `i` pointer ahead being the root and `j` pointer moving till `i`. ie) `i from 0 to array.length` and `j from 0 to i - 1`. \\n* While moving with `i` pointer if we find a `j`  that divides `arr[i]`, then we might have a solution because - If `a * b == c`, where `a` is the `arr[j]` and `c` is the `arr[i]`, we have a solution because acco to the problem, `b` can be equal to `a` ie) can be repeated. If not, we can find a `b` eventually by setting a variable called `b= c / a` and see if it exists in the array and if it does, it is the other child of the a, b and c subtree/tree.\\n* Use a hashmap to map elements to indexes while finding the `b` as said above\\n* We can use a DP table to track this down where initially all elements of DP table are `1` because every element of the array without any children is a  tree in itself. If the last two points above help us find an `a, b, c` pair, update the `dp[c] = dp[a] * dp[b]` as it will cover all the cases like `c` being the root, `a` the right child and `b` left child and  `c` being the root, `a` the left child and `b` right child.\\n* The final solution will be sum of values of the DP table. Take care of `long` in case of Java, CPP or C.\\n\\nJava code - \\n\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1){\\n            return 1;\\n        }\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        long ans = 0;\\n        int remaining = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    remaining = arr[i] / arr[j];\\n                    if(map.containsKey(remaining)){\\n                        dp[i] += dp[j] * dp[map.get(remaining)];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(long v : dp){\\n            ans += v;\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1){\\n            return 1;\\n        }\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        long ans = 0;\\n        int remaining = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    remaining = arr[i] / arr[j];\\n                    if(map.containsKey(remaining)){\\n                        dp[i] += dp[j] * dp[map.get(remaining)];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(long v : dp){\\n            ans += v;\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086422,
                "title": "explained-short-dp-solution-cpp-similar-question-link-also",
                "content": "If you had already solved question in which you have to find the pairs in array whose sum is divisible by k (any integer) using hashmap then congratulations you already solved 80% of this question for remaining 20% let me help you.\\nnow first you have to sort the given array so that you can iterate over the elements before a particular element and consider it as a non-leaf node element and the elements before it as it\\'s childrens . now simply you have to find the pairs divisible by it and multiply thier value and add it to the result.\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         unordered_map<int,int64_t> freq;\\n         long long int count=0;\\n         long long int mod = pow(10,9)+7;\\n         sort(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++){\\n             int data = arr[i];\\n             freq[arr[i]]++;\\n             for(int j=i-1;j>=0;j--){\\n                 if(data%arr[j] == 0 && freq.count(data/arr[j])){\\n                     freq[data] = (freq[data]+(freq[arr[j]] * freq[data/arr[j]]))%mod;\\n                 }\\n             }\\n             count = (count+freq[data])%mod;\\n         }\\n         return count;\\n    }\\n};\\n```\\n\\nQuestion Link : https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/\\nKindly upvote if you like my solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         unordered_map<int,int64_t> freq;\\n         long long int count=0;\\n         long long int mod = pow(10,9)+7;\\n         sort(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++){\\n             int data = arr[i];\\n             freq[arr[i]]++;\\n             for(int j=i-1;j>=0;j--){\\n                 if(data%arr[j] == 0 && freq.count(data/arr[j])){\\n                     freq[data] = (freq[data]+(freq[arr[j]] * freq[data/arr[j]]))%mod;\\n                 }\\n             }\\n             count = (count+freq[data])%mod;\\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955960,
                "title": "java-beat-100-10ms-dp",
                "content": "```java\\npublic int numFactoredBinaryTrees(int[] A) {\\n\\tArrays.sort(A);\\n\\tMap<Long, Integer> numbers = new HashMap<>();\\n\\tfor(int i = 0; i < A.length; i++) {\\n\\t\\tnumbers.put((long) A[i], i);\\n\\t}\\n\\n\\tlong[] memo = new long[A.length];\\n\\tArrays.fill(memo, 1);\\n\\n\\tlong count = 0;\\n\\tfor(int idx = 0; idx < A.length; idx++) {\\n\\t\\t for(int i = 0; i <= idx; i++) {\\n\\t\\t\\tlong mul = ((long) A[i])*A[idx];\\n\\t\\t\\t if(mul > Integer.MAX_VALUE) {\\n\\t\\t\\t\\t break;\\n\\t\\t\\t }\\n\\t\\t\\tInteger pos = numbers.get(mul);\\n\\t\\t\\tif(pos != null) {\\n\\t\\t\\t\\tint factor = A[i] == A[idx] ? 1 : 2;\\n\\t\\t\\t\\tmemo[pos] += factor * memo[i] * memo[idx];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount += memo[idx];\\n\\t}\\n\\n\\treturn (int) (count % 1000000007);\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int numFactoredBinaryTrees(int[] A) {\\n\\tArrays.sort(A);\\n\\tMap<Long, Integer> numbers = new HashMap<>();\\n\\tfor(int i = 0; i < A.length; i++) {\\n\\t\\tnumbers.put((long) A[i], i);\\n\\t}\\n\\n\\tlong[] memo = new long[A.length];\\n\\tArrays.fill(memo, 1);\\n\\n\\tlong count = 0;\\n\\tfor(int idx = 0; idx < A.length; idx++) {\\n\\t\\t for(int i = 0; i <= idx; i++) {\\n\\t\\t\\tlong mul = ((long) A[i])*A[idx];\\n\\t\\t\\t if(mul > Integer.MAX_VALUE) {\\n\\t\\t\\t\\t break;\\n\\t\\t\\t }\\n\\t\\t\\tInteger pos = numbers.get(mul);\\n\\t\\t\\tif(pos != null) {\\n\\t\\t\\t\\tint factor = A[i] == A[idx] ? 1 : 2;\\n\\t\\t\\t\\tmemo[pos] += factor * memo[i] * memo[idx];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount += memo[idx];\\n\\t}\\n\\n\\treturn (int) (count % 1000000007);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835232,
                "title": "recursive-dp-intuition-c",
                "content": "It\\'s extremely slow, but I\\'m quite proud of what I came up with.\\nThe intuition goes like this: \\nSay we\\'re given an array such as [20, 10, 5, 4, 2] (doesn\\'t have to be sorted)\\nWe can choose to break up 20 with 10, 5, 4, or 2 and count trees(20) i.e. the number of trees 20 can form. Start with 10 as the left node of 20 and 20/10 = 2 (which we check if it is in the array). Then we break the problem down into a sub problem where we repeat the same with trees(10) and trees(2).\\nOnce we\\'re done finding trees(10) can form with trees(2), we multiply them together. This is because\\ntrees(2) = length of [[2]] and trees(10) = [[10, 2, 5], [10]] and we can make 20 by using their different combinations.\\nSince we\\'re going to run into 10 later in the list, we use dynamic programming to memoize trees(10), storing it in a map.\\nThe listed solution stores the index instead which is smarter to do since it\\'s faster to access and under 1e9. We mod by 1e9+7 along the way to make sure it\\'s under overflow.\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    unordered_map<int, long> dp;\\n    unordered_map<int, int> exists;\\n    long total = 0;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            exists.insert({A[i], i});\\n            dp.insert({A[i], 0});\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            total = (total + trees(A, i))%mod;\\n        }\\n        return total%mod;\\n    }\\n    \\n    long trees(vector<int>& A, int i) {\\n        auto searchdp = dp.find(A[i]);\\n        if (searchdp->second) return searchdp->second;\\n        searchdp->second = 1;\\n        for (int j = 0; j < A.size(); j++) {\\n            auto search = exists.find(A[i]/A[j]);\\n            if (!(A[i]%A[j]) && search != exists.end()) {\\n                searchdp->second = (searchdp->second + trees(A, j)*trees(A, search->second)) % mod;\\n            }\\n        }\\n        return searchdp->second;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    unordered_map<int, long> dp;\\n    unordered_map<int, int> exists;\\n    long total = 0;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            exists.insert({A[i], i});\\n            dp.insert({A[i], 0});\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            total = (total + trees(A, i))%mod;\\n        }\\n        return total%mod;\\n    }\\n    \\n    long trees(vector<int>& A, int i) {\\n        auto searchdp = dp.find(A[i]);\\n        if (searchdp->second) return searchdp->second;\\n        searchdp->second = 1;\\n        for (int j = 0; j < A.size(); j++) {\\n            auto search = exists.find(A[i]/A[j]);\\n            if (!(A[i]%A[j]) && search != exists.end()) {\\n                searchdp->second = (searchdp->second + trees(A, j)*trees(A, search->second)) % mod;\\n            }\\n        }\\n        return searchdp->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641851,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361866,
                "title": "simple-scala-solution",
                "content": "Intuition: \\n\\nFor each element `a` of the sorted array `A`, we filter out all the `k`-keys found so far such that `a % k == 0`. As stated in the main solution, if we have a `dp`-table that memoizes all solutions seen so far (in sorted order) and the root node of the tree (with value `v`) has children with values `left` and `right` (and `left * right == v`), then this contributes `dp(left) * dp(right)` possible ways to make this tree.\\n\\nWe fold the filtered values with a starting value of 1 (for the identity case in which the tree is a single element) and sum all the products, defaulting to 0 when the complementing child cannot be found.\\n\\n```\\nobject Solution {\\n    def numFactoredBinaryTrees(A: Array[Int]): Int = {\\n      var dp = Map[Int, Long]().withDefaultValue(0L)      \\n      for (a <- A.sorted) {\\n        val dpValue = dp\\n          .keys\\n          .filter(a % _ == 0)\\n          .foldLeft(1L)((x, y) => {x + dp(y) * dp.getOrElse(a / y, 0L)})\\n        dp += (a -> dpValue)\\n      }\\n      (dp.values.sum % 1000000007L).toInt\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def numFactoredBinaryTrees(A: Array[Int]): Int = {\\n      var dp = Map[Int, Long]().withDefaultValue(0L)      \\n      for (a <- A.sorted) {\\n        val dpValue = dp\\n          .keys\\n          .filter(a % _ == 0)\\n          .foldLeft(1L)((x, y) => {x + dp(y) * dp.getOrElse(a / y, 0L)})\\n        dp += (a -> dpValue)\\n      }\\n      (dp.values.sum % 1000000007L).toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 125916,
                "title": "c-dp-solution",
                "content": "assume dp[i] is the number of combinations and the recurrence relation is:\\ndp[i]=1+sum(dp[j]*dp[k]) for j=0 to i-1 and A[k]=A[i]/A[j]\\nwe have to sort the array in ascending order so that the recurrence relation is correct.\\n\\nUse the hash set to store all the numbers before i to save lookup time.\\nBe sure to use long long for dp[j]*dp[k], otherwise it will overflow.\\nalso the accumulation has to use 0LL for the initial value to avoid overflow.\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3863486,
                "title": "easy-implementation-using-sorting-and-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size(), mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        map<int,int>idx;\\n        map<int,long long>mp;\\n        for(int i=0; i<n; i++){\\n            idx[arr[i]] = i;\\n            mp[i] = 1;\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0 && idx.find(arr[i]/arr[j]) != idx.end()){\\n                    mp[i] += (mp[j] * mp[idx[arr[i]/arr[j]]]);\\n                    mp[i] = mp[i]%mod;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(auto i : mp){\\n            ans += i.second;\\n            ans %= mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size(), mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        map<int,int>idx;\\n        map<int,long long>mp;\\n        for(int i=0; i<n; i++){\\n            idx[arr[i]] = i;\\n            mp[i] = 1;\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0 && idx.find(arr[i]/arr[j]) != idx.end()){\\n                    mp[i] += (mp[j] * mp[idx[arr[i]/arr[j]]]);\\n                    mp[i] = mp[i]%mod;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(auto i : mp){\\n            ans += i.second;\\n            ans %= mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481564,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n         sort(arr.begin(), arr.end());\\n        int len = arr.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : arr) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = arr[0]; fA <= lim; fA = arr[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        long [] dp = new long[arr.length];\\n        Arrays.fill(dp,1);\\n        long MOD=(int)1e9+7,ans=1;\\n        dp[0]=1;\\n        Map<Integer,Integer> index = new HashMap<Integer,Integer>();\\n        index.put(arr[0],0);\\n\\n        for(int i=1;i<dp.length;i++){\\n            index.put(arr[i],i);\\n\\n            for(int j=0;arr[j]<=Math.sqrt(arr[i]);j++){\\n                if(arr[j]*(long )arr[j]==arr[i]){\\n                    dp[i]+=dp[j] *(long ) dp[j]%MOD;\\n                    dp[i]%=MOD;\\n                }\\n                else if(arr[i]%arr[j]==0&&index.containsKey(arr[i]/arr[j])){\\n                    dp[i]+=dp[j]*dp[index.get(arr[i]/arr[j])]*2%MOD;\\n                }\\n            }\\n            ans=(ans+dp[i])%MOD;\\n        }\\n        return (int)ans;\\n     }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n         sort(arr.begin(), arr.end());\\n        int len = arr.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : arr) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = arr[0]; fA <= lim; fA = arr[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\n```Java []\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        long [] dp = new long[arr.length];\\n        Arrays.fill(dp,1);\\n        long MOD=(int)1e9+7,ans=1;\\n        dp[0]=1;\\n        Map<Integer,Integer> index = new HashMap<Integer,Integer>();\\n        index.put(arr[0],0);\\n\\n        for(int i=1;i<dp.length;i++){\\n            index.put(arr[i],i);\\n\\n            for(int j=0;arr[j]<=Math.sqrt(arr[i]);j++){\\n                if(arr[j]*(long )arr[j]==arr[i]){\\n                    dp[i]+=dp[j] *(long ) dp[j]%MOD;\\n                    dp[i]%=MOD;\\n                }\\n                else if(arr[i]%arr[j]==0&&index.containsKey(arr[i]/arr[j])){\\n                    dp[i]+=dp[j]*dp[index.get(arr[i]/arr[j])]*2%MOD;\\n                }\\n            }\\n            ans=(ans+dp[i])%MOD;\\n        }\\n        return (int)ans;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514113,
                "title": "c-simple-and-straight-forword-solution",
                "content": "**Please upvote if you like this solution**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long int ans=1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        mp[arr[0]]++;\\n        for(int i=1;i<arr.size();i++){\\n            mp[arr[i]]++;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp[arr[i]/arr[j]]>0){\\n                         mp[arr[i]]+= (mp[arr[j]]*mp[arr[i]/arr[j]]);\\n                    }\\n                }\\n            }\\n            ans+=mp[arr[i]];\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long int ans=1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        mp[arr[0]]++;\\n        for(int i=1;i<arr.size();i++){\\n            mp[arr[i]]++;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp[arr[i]/arr[j]]>0){\\n                         mp[arr[i]]+= (mp[arr[j]]*mp[arr[i]/arr[j]]);\\n                    }\\n                }\\n            }\\n            ans+=mp[arr[i]];\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430488,
                "title": "golang-math",
                "content": "If x%a == 0 and x%b == 0\\nand a,b are already in the map, (since the arr is sorted, the factors would come before the actual num) \\nthen num of factors of mem[x] = mem[a] * mem[b]\\nwhere mem[i] is the number of factors of i\\n```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    mem := make(map[int]int, 0)\\n    \\n    sort.Slice(arr, func(i,j int) bool {return arr[i] < arr[j]})\\n    \\n    result := 0\\n    \\n    for i:=0; i<len(arr); i++ {\\n        \\n        for key, _ := range mem {\\n            if arr[i] % key == 0 {\\n                quotient := arr[i]/key\\n                \\n                if _, ok := mem[quotient]; ok {\\n                    mem[arr[i]] += (mem[key] % (1e9 + 7)) * (mem[quotient] % (1e9 + 7))\\n                }\\n            }\\n        }\\n        mem[arr[i]] += 1\\n        result += mem[arr[i]] % (1e9 + 7)\\n    }\\n    \\n    return result % (1e9 + 7)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "If x%a == 0 and x%b == 0\\nand a,b are already in the map, (since the arr is sorted, the factors would come before the actual num) \\nthen num of factors of mem[x] = mem[a] * mem[b]\\nwhere mem[i] is the number of factors of i\\n```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    mem := make(map[int]int, 0)\\n    \\n    sort.Slice(arr, func(i,j int) bool {return arr[i] < arr[j]})\\n    \\n    result := 0\\n    \\n    for i:=0; i<len(arr); i++ {\\n        \\n        for key, _ := range mem {\\n            if arr[i] % key == 0 {\\n                quotient := arr[i]/key\\n                \\n                if _, ok := mem[quotient]; ok {\\n                    mem[arr[i]] += (mem[key] % (1e9 + 7)) * (mem[quotient] % (1e9 + 7))\\n                }\\n            }\\n        }\\n        mem[arr[i]] += 1\\n        result += mem[arr[i]] % (1e9 + 7)\\n    }\\n    \\n    return result % (1e9 + 7)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2426630,
                "title": "python3-solution-using-bottom-up-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr = sorted(arr)\\n        dp = {x: 1 for x in arr}\\n        count = 1\\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                if arr[i] % arr[j] == 0 and arr[i] / arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]] * dp[arr[i] / arr[j]]\\n            count += dp[arr[i]]\\n        return count % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr = sorted(arr)\\n        dp = {x: 1 for x in arr}\\n        count = 1\\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                if arr[i] % arr[j] == 0 and arr[i] / arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]] * dp[arr[i] / arr[j]]\\n            count += dp[arr[i]]\\n        return count % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411219,
                "title": "go-75",
                "content": "```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    sort.Ints(arr)\\n    mod := int(1e9 + 7)\\n    dp := map[int]int{}\\n    for _, num := range arr {\\n        dp[num] = 1\\n    }\\n    \\n    for i, num := range arr {\\n        for _, x := range arr[:i] {\\n            if num % x != 0 {\\n                continue\\n            }\\n            if v, ok := dp[num / x]; ok {\\n                dp[num] += dp[x] * v\\n                dp[num] %= mod\\n            }\\n        } \\n    }\\n    \\n    sum := 0\\n    for _, v := range dp {\\n        sum += v\\n    }\\n    return sum % mod\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    sort.Ints(arr)\\n    mod := int(1e9 + 7)\\n    dp := map[int]int{}\\n    for _, num := range arr {\\n        dp[num] = 1\\n    }\\n    \\n    for i, num := range arr {\\n        for _, x := range arr[:i] {\\n            if num % x != 0 {\\n                continue\\n            }\\n            if v, ok := dp[num / x]; ok {\\n                dp[num] += dp[x] * v\\n                dp[num] %= mod\\n            }\\n        } \\n    }\\n    \\n    sum := 0\\n    for _, v := range dp {\\n        sum += v\\n    }\\n    return sum % mod\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409005,
                "title": "python-simple-and-easy-solution-clean-code-faster-than-99",
                "content": "# Approach:\\n\\nFor every parent we want to see how many pairs of child exist \\n\\nLets take an example: `[4,2,8]`\\nFor `8` we can have `(4,2)`, `(2,4)`  and then for `4` we can have `(2,2)`\\nBuilding up on the solution of `4`, for `8` there are 5 ways: \\n`8 -> ((2,2), 2)` \\n`8 -> (2, (2,2))` \\n`8 -> (4, 2)` \\n`8 -> (2, 4)`\\n`8 `\\n\\n\\n# Solution: \\n\\nFirst we sort the array in ascending order: `[2,4,8]` so that we can build (no of ways) from smallest element\\nand then build up the solution for parent:\\n\\n`no_of_ways[parent] = no_of_ways[child] * no_of_ways[other_child]`\\n\\n\\nSee solution below:\\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        \\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n            \\n            for child in arr:\\n                other_child = parent/child\\n                if other_child in mem:\\n                    mem[parent] += (mem[other_child] * mem[child]) % 1000000007\\n\\n        \\n        \\n        return (sum(mem.values()) % 1000000007)\\n```\\n\\nAbove solution has `O(n^2)` time complexity.\\n\\nTo optimise this further, we can run the inner loop till `sqrt(n)` (since we will identify all the factors for the parent present in the array)\\n\\nNote: But if the two children are different they are to be counted separatem eg: `(2,4)` and `(4,2)` \\nand when the two children are same they are to be counted as one eg: `(2,2)`\\n\\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n\\n            for child in arr:\\n                if child > math.sqrt(parent):\\n                    break\\n\\n                other_child = parent / child\\n                if other_child in mem:\\n                    mem[parent] += (\\n                        (mem[other_child] * mem[child])\\n                        * (1 if other_child == child else 2)\\n                    ) % 1000000007\\n\\n        return sum(mem.values()) % 1000000007\\n```\\n\\nFor worst cases time complexity is still `O(n^2)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        \\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n            \\n            for child in arr:\\n                other_child = parent/child\\n                if other_child in mem:\\n                    mem[parent] += (mem[other_child] * mem[child]) % 1000000007\\n\\n        \\n        \\n        return (sum(mem.values()) % 1000000007)\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n\\n            for child in arr:\\n                if child > math.sqrt(parent):\\n                    break\\n\\n                other_child = parent / child\\n                if other_child in mem:\\n                    mem[parent] += (\\n                        (mem[other_child] * mem[child])\\n                        * (1 if other_child == child else 2)\\n                    ) % 1000000007\\n\\n        return sum(mem.values()) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403783,
                "title": "java-detailed-solution-using-dp",
                "content": "Hopefully everyone get the solution with the help of comments...\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        //returning 0 if the length of the array is 0 because binary tree should is not possible.\\n        if(n == 0)\\n            return 0;\\n        //sort will help to track the elements\\n        Arrays.sort(arr);\\n        \\n        //map will remember for already occured elements\\n        HashMap<Integer, Long> mp = new HashMap<>();\\n        \\n        //i will not change so treating like a constant only\\n        int i = 0;\\n        for(; i < n; i++){\\n            //count is 1(l is for long) because every element is a tree in itself\\n            long count = 1l;\\n            for(int j = 0; j < i; j++){\\n                //this will check is arr[j] can be the child of arr[i] and if yes then we check if\\n                //arr[i]/arr[j] had an element in map then we can say it is the valid relation\\n                //else count is 1 only.\\n                if((arr[i] % arr[j] == 0) && (mp.containsKey(arr[i] / arr[j]) == true)){\\n                    // this line calculating count = 1 + (count of ways generating arr[j] and arr[i]/arr[j])\\n                    count += mp.get(arr[j]) * mp.get(arr[i] / arr[j]); \\n                }\\n            }\\n            mp.put(arr[i], count);\\n        }\\n        long ans = 0;\\n        //adding up all the values(counts) of the map values to get the total number of trees geneated\\n        for(Map.Entry<Integer, Long> entry: mp.entrySet()){\\n            ans += (entry.getValue() % 1000000007);\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\nComment below for any kind of doubt ;)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        //returning 0 if the length of the array is 0 because binary tree should is not possible.\\n        if(n == 0)\\n            return 0;\\n        //sort will help to track the elements\\n        Arrays.sort(arr);\\n        \\n        //map will remember for already occured elements\\n        HashMap<Integer, Long> mp = new HashMap<>();\\n        \\n        //i will not change so treating like a constant only\\n        int i = 0;\\n        for(; i < n; i++){\\n            //count is 1(l is for long) because every element is a tree in itself\\n            long count = 1l;\\n            for(int j = 0; j < i; j++){\\n                //this will check is arr[j] can be the child of arr[i] and if yes then we check if\\n                //arr[i]/arr[j] had an element in map then we can say it is the valid relation\\n                //else count is 1 only.\\n                if((arr[i] % arr[j] == 0) && (mp.containsKey(arr[i] / arr[j]) == true)){\\n                    // this line calculating count = 1 + (count of ways generating arr[j] and arr[i]/arr[j])\\n                    count += mp.get(arr[j]) * mp.get(arr[i] / arr[j]); \\n                }\\n            }\\n            mp.put(arr[i], count);\\n        }\\n        long ans = 0;\\n        //adding up all the values(counts) of the map values to get the total number of trees geneated\\n        for(Map.Entry<Integer, Long> entry: mp.entrySet()){\\n            ans += (entry.getValue() % 1000000007);\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403709,
                "title": "java-hashmap-optimized",
                "content": "```\\n\\tpublic int numFactoredBinaryTrees(int[] arr) {\\n\\t\\t//sort the array so that for any larger element we would already traversed \\n\\t\\t//smaller elements(maybe its factors)\\n        Arrays.sort(arr);\\n\\t\\t\\n\\t\\t//map stores elemenst and no of trees that can be formed using it as non leaf.\\n        HashMap<Integer, Long> map = new HashMap<>();\\n\\t\\t\\n\\t\\t//initialize the map with first element and count = 1 \\n        long count = 1;\\n        map.put(arr[0], count);\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            long sum = 1;\\n\\t\\t\\t\\n\\t\\t\\t//for each arr[i] check if its factors exist in hashmap, \\n\\t\\t\\t//if yes then add product of no. of trees formed by keeping them as non leaf\\n            for(int num : map.keySet()){\\n                if(arr[i] % num == 0 && map.containsKey(arr[i] / num)){\\n                    sum += (map.get(arr[i]/num) * map.get(num));\\n                }\\n            }\\n\\t\\t\\t//add no. of trees formed using arr[i] i.e. sum to count and set sum against arr[i]\\n            count += sum;\\n            map.put(arr[i], sum);\\n        }\\n        return (int)(count%1000000007);\\n    }\\n\\t\\n\\t\\nConsider example [2,4]\\nInitially map = {2, 1}, for 4 we check if arr[i]%num== 0 which is true but \\nwe also need to check if the factor is present in the map so for that we are checking \\nmap.containsKey(arr[i]/num)) \\nif both conditions are true then we consider map.get(num) as no of trees formed using num as non-leaf node and \\nmap.get(arr[i]/num) as no of trees formed using arr[i]/num as non-leaf node, and \\nproduct of these two will give no of Trees can be formed using arr[i] as non-leaf. Keep adding them as you move forward.\\n\\n\\nLet\\'s take another example of [2, 10]\\nInitially map = {2, 1}\\nAgain for this 10%2 == 0 but map doesn\\'t contain 10/2 ie 5 so we can not create any other tree using 10 as non-leaf,\\nso the only valid tress will [2] and [10] so the ans would be 2 only.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int numFactoredBinaryTrees(int[] arr) {\\n\\t\\t//sort the array so that for any larger element we would already traversed \\n\\t\\t//smaller elements(maybe its factors)\\n        Arrays.sort(arr);\\n\\t\\t\\n\\t\\t//map stores elemenst and no of trees that can be formed using it as non leaf.\\n        HashMap<Integer, Long> map = new HashMap<>();\\n\\t\\t\\n\\t\\t//initialize the map with first element and count = 1 \\n        long count = 1;\\n        map.put(arr[0], count);\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            long sum = 1;\\n\\t\\t\\t\\n\\t\\t\\t//for each arr[i] check if its factors exist in hashmap, \\n\\t\\t\\t//if yes then add product of no. of trees formed by keeping them as non leaf\\n            for(int num : map.keySet()){\\n                if(arr[i] % num == 0 && map.containsKey(arr[i] / num)){\\n                    sum += (map.get(arr[i]/num) * map.get(num));\\n                }\\n            }\\n\\t\\t\\t//add no. of trees formed using arr[i] i.e. sum to count and set sum against arr[i]\\n            count += sum;\\n            map.put(arr[i], sum);\\n        }\\n        return (int)(count%1000000007);\\n    }\\n\\t\\n\\t\\nConsider example [2,4]\\nInitially map = {2, 1}, for 4 we check if arr[i]%num== 0 which is true but \\nwe also need to check if the factor is present in the map so for that we are checking \\nmap.containsKey(arr[i]/num)) \\nif both conditions are true then we consider map.get(num) as no of trees formed using num as non-leaf node and \\nmap.get(arr[i]/num) as no of trees formed using arr[i]/num as non-leaf node, and \\nproduct of these two will give no of Trees can be formed using arr[i] as non-leaf. Keep adding them as you move forward.\\n\\n\\nLet\\'s take another example of [2, 10]\\nInitially map = {2, 1}\\nAgain for this 10%2 == 0 but map doesn\\'t contain 10/2 ie 5 so we can not create any other tree using 10 as non-leaf,\\nso the only valid tress will [2] and [10] so the ans would be 2 only.",
                "codeTag": "Unknown"
            },
            {
                "id": 2403426,
                "title": "concise-java-solution-o-n-2",
                "content": "class Solution {\\n\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int MOD = 1000000007;\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++){\\n            long count = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        count += map.get(arr[i]/arr[j])*map.get(arr[j]); \\n                    }\\n                }\\n            }\\n            map.put(arr[i],count+1);\\n        }\\n        long res = 0;\\n        for(long i : map.values()){\\n            res += i;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int MOD = 1000000007;\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++){\\n            long count = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        count += map.get(arr[i]/arr[j])*map.get(arr[j]); \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2403388,
                "title": "100-00-of-c-concise-hashmap-soln-clean-code",
                "content": "**If you found this solution helpful Please upvote it**\\n\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        map<int , long long int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // mp[arr[i]]=1;\\n            mp.insert({arr[i] , 1});\\n            \\n        }\\n        sort(arr.begin() , arr.end());\\n        \\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            auto it3 = mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                \\n                if(arr[i]%arr[j]==0){\\n                    auto it = mp.find(arr[i]/arr[j]);\\n                    auto it2 = mp.find(arr[j]);\\n                    if(it!=mp.end()){\\n                        count+=(it->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it3->second+=count;\\n        }\\n        long long int sum=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            sum+=it->second;\\n            \\n        }\\n        return sum % (1000000007);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        map<int , long long int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // mp[arr[i]]=1;\\n            mp.insert({arr[i] , 1}",
                "codeTag": "Java"
            },
            {
                "id": 2403265,
                "title": "c-two-sum-approach-easy-and-intuitive-solution",
                "content": "# Guys! Please Upvote it\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<ll> dp(n);\\n        dp[0] = 1;\\n        ll ans = 1;\\n        for(int idx = 1;idx<n;idx++)\\n        {\\n            ll target = arr[idx];\\n            int i=0,j=idx-1;\\n            ll ways = 1;\\n            while(i<=j)\\n            {\\n                ll mul = (((long)arr[i])*(arr[j]));\\n                if(mul == target)\\n                {\\n                    if(i == j)\\n                    {\\n                        ways += (dp[i]*dp[j])%mod;\\n                    }\\n                    else\\n                    {\\n                        ways += (((long)dp[i]*(long)dp[j])*2)%mod;\\n                    }\\n                    i++,j--;\\n                }\\n                else if(mul > target)\\n                {\\n                    j--;\\n                }\\n                else if(mul < target)\\n                {\\n                    i++;\\n                }\\n            }\\n            dp[idx] = ways;\\n            ans = (long)(ans + dp[idx])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<ll> dp(n);\\n        dp[0] = 1;\\n        ll ans = 1;\\n        for(int idx = 1;idx<n;idx++)\\n        {\\n            ll target = arr[idx];\\n            int i=0,j=idx-1;\\n            ll ways = 1;\\n            while(i<=j)\\n            {\\n                ll mul = (((long)arr[i])*(arr[j]));\\n                if(mul == target)\\n                {\\n                    if(i == j)\\n                    {\\n                        ways += (dp[i]*dp[j])%mod;\\n                    }\\n                    else\\n                    {\\n                        ways += (((long)dp[i]*(long)dp[j])*2)%mod;\\n                    }\\n                    i++,j--;\\n                }\\n                else if(mul > target)\\n                {\\n                    j--;\\n                }\\n                else if(mul < target)\\n                {\\n                    i++;\\n                }\\n            }\\n            dp[idx] = ways;\\n            ans = (long)(ans + dp[idx])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403249,
                "title": "java-using-hashmap",
                "content": "class Solution {\\n     \\n    public int numFactoredBinaryTrees(int[] arr) {\\n          Arrays.sort(arr);\\n        Map<Integer,Long> map=new HashMap<>();//val,count\\n        long ans=0;\\n      for(int i=0;i<arr.length;i++){\\n            long count=1;\\n            for(int j=0;j<i;j++){\\n             if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j])){//found two factors as arr[j],arr[i]/arr[j]\\n                    count+=map.get(arr[j])*map.get(arr[i]/arr[j]);\\n                }\\n            }\\n            map.put(arr[i],count);\\n            ans=ans+count;//value of every key in map sum up to ans\\n        }\\n        return (int)(ans%(1000000000+7));\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     \\n    public int numFactoredBinaryTrees(int[] arr) {\\n          Arrays.sort(arr);\\n        Map<Integer,Long> map=new HashMap<>();//val,count\\n        long ans=0;\\n      for(int i=0;i<arr.length;i++){\\n            long count=1;\\n            for(int j=0;j<i;j++){\\n             if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j])){//found two factors as arr[j],arr[i]/arr[j]\\n                    count+=map.get(arr[j])*map.get(arr[i]/arr[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2403118,
                "title": "java-dp-tabulation-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp,1L);\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i] % arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        dp[i] += dp[map.get(arr[i]/arr[j])] * dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        int mod = 1000000007;\\n        long sum = 0;\\n        for(long val:dp){\\n            sum+=val;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp,1L);\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i] % arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        dp[i] += dp[map.get(arr[i]/arr[j])] * dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        int mod = 1000000007;\\n        long sum = 0;\\n        for(long val:dp){\\n            sum+=val;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403016,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, array: List[int]) -> int:\\n\\n        array.sort() \\n\\n        dct = dict(zip(array,range(1,len(array) + 1)))\\n        \\n        lst = [1] * len(array)\\n        \\n        exp = 10**9 + 7\\n\\n        for i in range(len(array)):\\n            for j in range(i):\\n                if array[i] % array[j] == 0 and dct.get(array[i] // array[j],0):\\n                        lst[i] = lst[i] + lst[j] * lst[dct[array[i] // array[j]]-1]\\n        return sum(lst) % exp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, array: List[int]) -> int:\\n\\n        array.sort() \\n\\n        dct = dict(zip(array,range(1,len(array) + 1)))\\n        \\n        lst = [1] * len(array)\\n        \\n        exp = 10**9 + 7\\n\\n        for i in range(len(array)):\\n            for j in range(i):\\n                if array[i] % array[j] == 0 and dct.get(array[i] // array[j],0):\\n                        lst[i] = lst[i] + lst[j] * lst[dct[array[i] // array[j]]-1]\\n        return sum(lst) % exp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402683,
                "title": "javascript-sort-tc-o-n-2-sc-o-n",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar numFactoredBinaryTrees = function(arr) {\\n    const mod = 10 ** 9 + 7;\\n    \\n    arr.sort((a, b) => a - b);\\n    \\n    const dp = {};\\n    \\n    for (const num of arr) {\\n        dp[num] = 1;\\n    }\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] % arr[j] === 0) {\\n                const k = arr[i] / arr[j];\\n                if (dp[k]) {\\n                    dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    Object.values(dp).forEach(v => ans += v);\\n    return ans % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar numFactoredBinaryTrees = function(arr) {\\n    const mod = 10 ** 9 + 7;\\n    \\n    arr.sort((a, b) => a - b);\\n    \\n    const dp = {};\\n    \\n    for (const num of arr) {\\n        dp[num] = 1;\\n    }\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] % arr[j] === 0) {\\n                const k = arr[i] / arr[j];\\n                if (dp[k]) {\\n                    dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    Object.values(dp).forEach(v => ans += v);\\n    return ans % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402680,
                "title": "very-easy-java-solution-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n       int mod=1000000007;\\n       int N=arr.length; \\n       long dp[]=new long[N];\\n       Arrays.fill(dp,1);\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       Arrays.sort(arr);\\n       for(int i=0;i<arr.length;i++){\\n           map.put(arr[i],i);\\n       }\\n       for(int i=0;i<N;i++){\\n           for(int j=0;j<i;j++){\\n               if(arr[i]%arr[j]==0){ \\n                   //left child ( so that right is integer)\\n                int right=arr[i]/arr[j];\\n                int idx=map.getOrDefault(right,-1);\\n                if(idx!=-1) dp[i]=(dp[i]+dp[idx]*dp[j])%mod;   \\n           }\\n       } \\n    }\\n    long ans=0;\\n    for(long x:dp) ans+=x;\\n    return (int)(ans%mod);    \\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n       int mod=1000000007;\\n       int N=arr.length; \\n       long dp[]=new long[N];\\n       Arrays.fill(dp,1);\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       Arrays.sort(arr);\\n       for(int i=0;i<arr.length;i++){\\n           map.put(arr[i],i);\\n       }\\n       for(int i=0;i<N;i++){\\n           for(int j=0;j<i;j++){\\n               if(arr[i]%arr[j]==0){ \\n                   //left child ( so that right is integer)\\n                int right=arr[i]/arr[j];\\n                int idx=map.getOrDefault(right,-1);\\n                if(idx!=-1) dp[i]=(dp[i]+dp[idx]*dp[j])%mod;   \\n           }\\n       } \\n    }\\n    long ans=0;\\n    for(long x:dp) ans+=x;\\n    return (int)(ans%mod);    \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402372,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& v) {\\n        \\n        vector<long long int>arr(v.size());\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++) arr[i] = v[i];\\n        \\n        long long int ans = 0 , MOD = pow(10,9) + 7;\\n        \\n        sort(arr.begin(),arr.end());\\n        set<long long int>s;\\n        \\n        for(int i=0;i<n;i++) s.insert(arr[i]);\\n        \\n        unordered_map<long long int,long long int>dp;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            long long int ele = arr[i];\\n            \\n            //Calculate answer for arr[i] as a root.\\n            long long int cnt = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                long long int mul = arr[j]*arr[j];\\n                if(mul > ele) break;\\n                if(j > 0 && arr[j] == arr[j-1]) continue;\\n                long long int cc = ele/arr[j];\\n                \\n                if(ele%arr[j] == 0 && s.count(cc))\\n                {\\n                    if(arr[j] != cc) cnt = (cnt + 2*dp[arr[j]]*dp[cc])%MOD;\\n            \\n                    else cnt = (cnt + dp[arr[j]]*dp[cc])%MOD;\\n                }\\n            } \\n            \\n            //store answer in dp for arr[i] as a root\\n            dp[ele] = cnt;\\n            ans = (ans + cnt)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& v) {\\n        \\n        vector<long long int>arr(v.size());\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++) arr[i] = v[i];\\n        \\n        long long int ans = 0 , MOD = pow(10,9) + 7;\\n        \\n        sort(arr.begin(),arr.end());\\n        set<long long int>s;\\n        \\n        for(int i=0;i<n;i++) s.insert(arr[i]);\\n        \\n        unordered_map<long long int,long long int>dp;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            long long int ele = arr[i];\\n            \\n            //Calculate answer for arr[i] as a root.\\n            long long int cnt = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                long long int mul = arr[j]*arr[j];\\n                if(mul > ele) break;\\n                if(j > 0 && arr[j] == arr[j-1]) continue;\\n                long long int cc = ele/arr[j];\\n                \\n                if(ele%arr[j] == 0 && s.count(cc))\\n                {\\n                    if(arr[j] != cc) cnt = (cnt + 2*dp[arr[j]]*dp[cc])%MOD;\\n            \\n                    else cnt = (cnt + dp[arr[j]]*dp[cc])%MOD;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2402315,
                "title": "dp-c-modular-arithmetic",
                "content": "```\\n\\ntypedef long T;\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    T modMul(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a *=  b;\\n        a %= mod;\\n        return a;\\n    }\\n    T modAdd(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        \\n        map<T,T> mp;\\n        for(auto &x : arr){\\n            mp[x] = 1;\\n        }\\n        int i,j;\\n        T sum = 1;\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp.find(arr[i]/arr[j]) != mp.end()){\\n                        // mp[ arr[i] ] =(mp[arr[i]]+mp[arr[j]] * mp[ arr[i]/arr[j] ])%mod;\\n                        mp[ arr[i] ] = modAdd( mp[arr[i]], modMul( mp[arr[j]], mp[arr[i] / arr[j] ] ) );\\n                    \\n                    }\\n                }\\n            }\\n            // sum = (sum + mp[arr[i]])%mod;\\n            sum = modAdd( sum , mp[arr[i]] );\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef long T;\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    T modMul(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a *=  b;\\n        a %= mod;\\n        return a;\\n    }\\n    T modAdd(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        \\n        map<T,T> mp;\\n        for(auto &x : arr){\\n            mp[x] = 1;\\n        }\\n        int i,j;\\n        T sum = 1;\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp.find(arr[i]/arr[j]) != mp.end()){\\n                        // mp[ arr[i] ] =(mp[arr[i]]+mp[arr[j]] * mp[ arr[i]/arr[j] ])%mod;\\n                        mp[ arr[i] ] = modAdd( mp[arr[i]], modMul( mp[arr[j]], mp[arr[i] / arr[j] ] ) );\\n                    \\n                    }\\n                }\\n            }\\n            // sum = (sum + mp[arr[i]])%mod;\\n            sum = modAdd( sum , mp[arr[i]] );\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402265,
                "title": "need-help-to-understand-why-my-code-fails",
                "content": "Hello folks need your help to understand why below written code is failing for some of the test case. Since the test case for which it is failing is very large i am not able to dry run on it to find the issue.\\n\\nPlease let me know in comment section if you want to know the thought process for below mentioned code.\\n\\n\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n        \\n\\t\\t\\n\\t\\tclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int mod = 1_000_000_007;\\n        \\n        for(int i=0; i<arr.length; i++)\\n        {\\n            hm.put(arr[i], 0);\\n        }\\n        \\n        for(int num: arr)\\n        {         \\n            for(int j=2; j<=num/2; j++)\\n            {\\n                if((num%j) == 0)\\n                {\\n                    int a = j; \\n                    int b = num/j;\\n                    \\n                    if(a!=b && hm.containsKey(a) && hm.containsKey(b))\\n                    {\\n                        hm.put(num, (hm.get(num)+(hm.get(a)*hm.get(b))%mod));\\n                    }\\n                    else if(a==b && hm.containsKey(a))\\n                    {\\n                        hm.put(num,(hm.get(num)+hm.get(a))%mod);\\n                    }\\n                }\\n                \\n            }\\n            hm.put(num, hm.get(num)+1);\\n        }\\n        \\n        long sum = 0;\\n        for(int num:arr)\\n        {\\n            sum += hm.get(num);\\n        }\\n        \\n        return (int)(sum%mod);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int mod = 1_000_000_007;\\n        \\n        for(int i=0; i<arr.length; i++)\\n        {\\n            hm.put(arr[i], 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2402227,
                "title": "c-solution-sort-dp-map",
                "content": "Let\\'s think naive solution. We pick up any number from the `arr` and make it a root. Then we iterate over all the pair of divisors of `arr[i]` and check if both the numbers are present in the array. We can identify the redundant computation. If the two divisors of `arr[i]` are present at `j` and `k` index, then we don\\'t need to compute their answer again. Their answer can be computed and stored in a `dp` vector.\\n\\nAlso, we don\\'t need to find all the divisors of `arr[i]`. Rather than that, we can traverse over all the numbers that are smaller than `arr[i]` and check if they divide `arr[i]`. To do this efficiently, we sort the array first. Lets say for `arr[i]`, there is an index `j` such that `arr[j]` divides `arr[i]`. Let `m = arr[i] / arr[j]`. Now we need to check if `m` exist in the array. Let `arr[k] = m`. Keep a map of value to index to retrieve the index `k` efficiently. Since all the numbers are unique, there would exactly be one index for any value present in the array. Then for ther are `dp[j]*dp[k]` more ways such that `arr[i]` can be root. Do this for all `j < i`. Final answer is sum of entire `dp` vector.\\n\\nSome points to consider:\\n1. `j` can be both left and right child. Then we need to add `2*dp[j]*dp[k]` to `dp[i]`. But that will be redundant since you will come across `k` as well. So always consider `j` as one of the child.\\n2. Consider the case where `m = arr[j]`. You don\\'t need to worry about adding extra to the answer to `dp[i]` if you follow point 1.\\n\\nComplexity:\\nTime => `O(n^2)`\\nSpace => `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        long long int modn = 1000000007;\\n        vector<long long int> dp(n, 1);\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j]){\\n                    continue;\\n                }\\n                int m = arr[i] / arr[j];\\n                if(index.find(m) != index.end()){\\n                    dp[i] += 1L*dp[j]*dp[index[m]];\\n                    dp[i] %= modn;\\n                }\\n            }\\n            index[arr[i]] = i;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0L)%modn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        long long int modn = 1000000007;\\n        vector<long long int> dp(n, 1);\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j]){\\n                    continue;\\n                }\\n                int m = arr[i] / arr[j];\\n                if(index.find(m) != index.end()){\\n                    dp[i] += 1L*dp[j]*dp[index[m]];\\n                    dp[i] %= modn;\\n                }\\n            }\\n            index[arr[i]] = i;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0L)%modn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402188,
                "title": "java-dp-solution-explained",
                "content": "```\\nclass Solution {\\n    /*\\n    -> Start from node and check if how may trees are possible, by following the given conditions\\n    -> dp works as visited array, if we already counter trees from a perticular root do not calculate it again\\n    */\\n    private int MOD = (int)(1e9+7);\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        long res = 0;\\n        Set<Integer> nodes = new HashSet(); \\n        Map<Integer, Long> dp = new HashMap<>();\\n        for(int n: arr) nodes.add(n);\\n        for(int n: arr) solve(n, nodes, dp);\\n        // Finally add all the trees possible from each value as node\\n        for(Map.Entry<Integer, Long> e: dp.entrySet()){\\n            res = (res + e.getValue()%MOD) % MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n    private long solve(int root, Set<Integer> nodes, Map<Integer, Long> dp){\\n        if(dp.containsKey(root)) return dp.get(root);\\n        long res = 1;\\n        Set<Integer> usedNodes = new HashSet<>();\\n        for(int n: nodes){\\n            if(n * (root/n) != root) continue;\\n            if(!usedNodes.contains(n) && nodes.contains(n) && nodes.contains(root/n)){\\n                long cur = solve(n, nodes, dp) * solve(root/n, nodes, dp);\\n                // if left and right child of tree are not same, the two trees are possible\\n                if(n != root/n) res+=cur*2;\\n                else res+=cur;\\n                usedNodes.add(n);\\n                usedNodes.add(root/n);\\n                res %= MOD;\\n            }\\n        }\\n        dp.put(root, res);\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    -> Start from node and check if how may trees are possible, by following the given conditions\\n    -> dp works as visited array, if we already counter trees from a perticular root do not calculate it again\\n    */\\n    private int MOD = (int)(1e9+7);\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        long res = 0;\\n        Set<Integer> nodes = new HashSet(); \\n        Map<Integer, Long> dp = new HashMap<>();\\n        for(int n: arr) nodes.add(n);\\n        for(int n: arr) solve(n, nodes, dp);\\n        // Finally add all the trees possible from each value as node\\n        for(Map.Entry<Integer, Long> e: dp.entrySet()){\\n            res = (res + e.getValue()%MOD) % MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n    private long solve(int root, Set<Integer> nodes, Map<Integer, Long> dp){\\n        if(dp.containsKey(root)) return dp.get(root);\\n        long res = 1;\\n        Set<Integer> usedNodes = new HashSet<>();\\n        for(int n: nodes){\\n            if(n * (root/n) != root) continue;\\n            if(!usedNodes.contains(n) && nodes.contains(n) && nodes.contains(root/n)){\\n                long cur = solve(n, nodes, dp) * solve(root/n, nodes, dp);\\n                // if left and right child of tree are not same, the two trees are possible\\n                if(n != root/n) res+=cur*2;\\n                else res+=cur;\\n                usedNodes.add(n);\\n                usedNodes.add(root/n);\\n                res %= MOD;\\n            }\\n        }\\n        dp.put(root, res);\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402173,
                "title": "easy-intuition-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,long long int>m;\\n    unordered_set<int>s;\\n    \\n    long long int countTrees(int a,vector<int>&arr){\\n        \\n        if(m[a])return m[a];\\n        \\n        long long int ct=1;\\n        for(auto ele:arr){\\n            if(!(a%ele) && s.find(a/ele)!=s.end()){\\n                ct+=countTrees(ele,arr)*countTrees(a/ele,arr);\\n            }\\n        }\\n        \\n        return m[a]=ct;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        for(auto ele:arr){\\n            s.insert(ele);\\n        }\\n        \\n        long long int ans=0,n=1e9+7;\\n        \\n        for(auto ele:arr){\\n            ans+=countTrees(ele,arr);\\n            ans%=n;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,long long int>m;\\n    unordered_set<int>s;\\n    \\n    long long int countTrees(int a,vector<int>&arr){\\n        \\n        if(m[a])return m[a];\\n        \\n        long long int ct=1;\\n        for(auto ele:arr){\\n            if(!(a%ele) && s.find(a/ele)!=s.end()){\\n                ct+=countTrees(ele,arr)*countTrees(a/ele,arr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2402127,
                "title": "simple-straight-cut-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr){\\n            mpp.insert({it,1}); // initilizing all the values in the map as 1\\n        }\\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mpp.find(arr[i]/arr[j])!=mpp.end()){\\n                        count+=mpp[arr[j]]*mpp[arr[i]/arr[j]]; //incrementing count\\n                    }\\n                }\\n            }\\n            mpp[arr[i]]+=count; //updating the new value in the map\\n        }\\n        long long int res=0;\\n        for(auto it: mpp){\\n            res=res+it.second;\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr){\\n            mpp.insert({it,1}); // initilizing all the values in the map as 1\\n        }\\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mpp.find(arr[i]/arr[j])!=mpp.end()){\\n                        count+=mpp[arr[j]]*mpp[arr[i]/arr[j]]; //incrementing count\\n                    }\\n                }\\n            }\\n            mpp[arr[i]]+=count; //updating the new value in the map\\n        }\\n        long long int res=0;\\n        for(auto it: mpp){\\n            res=res+it.second;\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402024,
                "title": "top-down-dp-c",
                "content": "```\\nint MOD =  1e9 + 7;\\n\\n\\nclass Solution\\n{\\npublic:\\n\\n\\tlong long modMul(long long a, long long b){\\n\\t\\treturn ((a%MOD) * (b%MOD))%MOD;\\n\\t}\\n\\n\\tunordered_map<int, vector<int>> mp;\\n\\tlong long dp[20][1005];\\n\\tlong long numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tfor(int i = 0; i<arr.size();i++){\\n\\t\\t\\tif(mp.count(arr[i]) > 0){\\n\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tmp[arr[i]] = {i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong long tmp = 0;\\n\\t\\tfor (int j = 0; j < arr.size(); j++)\\n\\t\\t{\\n\\t\\t\\ttmp += makeTrees(arr, 0, j);\\n\\t\\t\\ttmp%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\tlong long makeTrees(vector<int> arr, int level, int parent)\\n\\t{\\n\\n\\t\\tif(dp[level][parent]!=-1)\\n\\t\\t\\treturn dp[level][parent];\\n\\t\\tlong long cnt = 1;\\n\\n\\n\\t\\tfor(int i = 0;i<arr.size();i++){\\n\\t\\t\\t\\n\\t\\t\\tif(arr[parent]%arr[i] !=0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\tint target = arr[parent]/arr[i];\\n\\t\\t\\tif(mp.count(target) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tvector<int>tt = mp[target];\\n\\n\\t\\t\\tfor(int j=0;j<tt.size();j++){\\n\\t\\t\\t\\tcnt+= (modMul((makeTrees(arr, level+1, i)),(makeTrees(arr, level+1, tt[j]))));\\n\\t\\t\\t\\tcnt%=MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[level][parent] = cnt;\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint MOD =  1e9 + 7;\\n\\n\\nclass Solution\\n{\\npublic:\\n\\n\\tlong long modMul(long long a, long long b){\\n\\t\\treturn ((a%MOD) * (b%MOD))%MOD;\\n\\t}\\n\\n\\tunordered_map<int, vector<int>> mp;\\n\\tlong long dp[20][1005];\\n\\tlong long numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tfor(int i = 0; i<arr.size();i++){\\n\\t\\t\\tif(mp.count(arr[i]) > 0){\\n\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tmp[arr[i]] = {i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong long tmp = 0;\\n\\t\\tfor (int j = 0; j < arr.size(); j++)\\n\\t\\t{\\n\\t\\t\\ttmp += makeTrees(arr, 0, j);\\n\\t\\t\\ttmp%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\tlong long makeTrees(vector<int> arr, int level, int parent)\\n\\t{\\n\\n\\t\\tif(dp[level][parent]!=-1)\\n\\t\\t\\treturn dp[level][parent];\\n\\t\\tlong long cnt = 1;\\n\\n\\n\\t\\tfor(int i = 0;i<arr.size();i++){\\n\\t\\t\\t\\n\\t\\t\\tif(arr[parent]%arr[i] !=0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\tint target = arr[parent]/arr[i];\\n\\t\\t\\tif(mp.count(target) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tvector<int>tt = mp[target];\\n\\n\\t\\t\\tfor(int j=0;j<tt.size();j++){\\n\\t\\t\\t\\tcnt+= (modMul((makeTrees(arr, level+1, i)),(makeTrees(arr, level+1, tt[j]))));\\n\\t\\t\\t\\tcnt%=MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[level][parent] = cnt;\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401791,
                "title": "c-accepted-best-approach-with-steps-explanation-easy-to-understand",
                "content": "**Read the below steps to understand the logic**\\n\\n***Upvote if you like it!!***\\n\\n**Steps**\\n1. Sort the given arr. ```sort(arr.begin(),arr.end());```\\n2. Declare map and set all element value by 1 ex: ```mp[auto num: arr]=1;```\\n3. Declare loop which will start from first index untill last index. ```for(int i=1;i<n;i++)```\\n\\t\\t* Declare nested loop inside previous loop which will start from 0\\'th untill i\\'th index for each i\\'th element.```for(int j=1;j<i;j++)``` and declare count as 0.\\n\\t\\t* Check whether arr[j] is factor of arr[i] of not, if yes then check divident value is present inside map or not, if yes than increment count by  multiply of arr[j] and divident second map value.\\n\\t\\t* after that increment map\\'s second value of arr[i] by count.\\n4.  return sum of second map\\'s values of each element of given array after taking modules. \\n\\n```\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        map<int,long long> mp;\\n        for(auto num: arr)\\n            mp[num]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            long long count=0;\\n            auto it=mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    auto it1 = mp.find(arr[i]/arr[j]);\\n                    auto it2=mp.find(arr[j]);\\n                    if(it1!=mp.end()){\\n                        count+=(it1->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it->second+=count;\\n        }\\n        long long  sum=0;\\n        for(auto it4=mp.begin();it4!=mp.end(); it4++){\\n            sum+= it4->second;\\n        }\\n        return sum%(1000000007);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```sort(arr.begin(),arr.end());```\n```mp[auto num: arr]=1;```\n```for(int i=1;i<n;i++)```\n```for(int j=1;j<i;j++)```\n```\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        map<int,long long> mp;\\n        for(auto num: arr)\\n            mp[num]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            long long count=0;\\n            auto it=mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    auto it1 = mp.find(arr[i]/arr[j]);\\n                    auto it2=mp.find(arr[j]);\\n                    if(it1!=mp.end()){\\n                        count+=(it1->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it->second+=count;\\n        }\\n        long long  sum=0;\\n        for(auto it4=mp.begin();it4!=mp.end(); it4++){\\n            sum+= it4->second;\\n        }\\n        return sum%(1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401736,
                "title": "python-two-dynamic-programming-solutions",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        arr.sort()\\n        arr_set = defaultdict(int)\\n        for i in range(N):\\n            arr_set[arr[i]] = i\\n        \\n        dp = [1] * N\\n        for i in range(1, N):\\n            for j in range(i):\\n                left = arr[j]\\n                right = arr[i] / left\\n                if right in arr_set:\\n                    l_comb = dp[j]-1\\n                    r_comb = dp[arr_set[right]]-1\\n                    dp[i] += 1 + l_comb + r_comb + (l_comb * r_comb)\\n        \\n        return sum(dp) % 1000000007\\n```\\n\\nor using memo\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:        \\n        arr.sort()\\n        arr_set = set(arr)\\n        \\n        @cache\\n        def dp(val):\\n            r = 1\\n            for i in range(len(arr)):\\n                left = arr[i]\\n                if left >= val:\\n                    break\\n                right = val / left\\n                if right in arr_set:\\n                    l_comb = dp(left)\\n                    r_comb = dp(right)\\n                    \\n                    r += 1\\n                    r += l_comb-1\\n                    r += r_comb-1\\n                    r += (l_comb-1) * (r_comb-1)\\n            return r\\n        \\n        answer = 0\\n        for n in arr:\\n            answer += dp(n)\\n        \\n        return answer % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        arr.sort()\\n        arr_set = defaultdict(int)\\n        for i in range(N):\\n            arr_set[arr[i]] = i\\n        \\n        dp = [1] * N\\n        for i in range(1, N):\\n            for j in range(i):\\n                left = arr[j]\\n                right = arr[i] / left\\n                if right in arr_set:\\n                    l_comb = dp[j]-1\\n                    r_comb = dp[arr_set[right]]-1\\n                    dp[i] += 1 + l_comb + r_comb + (l_comb * r_comb)\\n        \\n        return sum(dp) % 1000000007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:        \\n        arr.sort()\\n        arr_set = set(arr)\\n        \\n        @cache\\n        def dp(val):\\n            r = 1\\n            for i in range(len(arr)):\\n                left = arr[i]\\n                if left >= val:\\n                    break\\n                right = val / left\\n                if right in arr_set:\\n                    l_comb = dp(left)\\n                    r_comb = dp(right)\\n                    \\n                    r += 1\\n                    r += l_comb-1\\n                    r += r_comb-1\\n                    r += (l_comb-1) * (r_comb-1)\\n            return r\\n        \\n        answer = 0\\n        for n in arr:\\n            answer += dp(n)\\n        \\n        return answer % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401642,
                "title": "c-recursive-memomization-method",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long long int recur(int n,vector<int> nums,map<int,long long int>& dp){\\n        if(dp.find(n)!=dp.end()) return dp[n];\\n        long long int a=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(n%nums[i]==0){\\n            vector<int>::iterator it;\\n            it=find(nums.begin(),nums.end(),n/nums[i]);\\n                if(it!=nums.end())\\n             a=a%mod+(recur(n/nums[i],nums,dp)%mod)*(recur(nums[i],nums,dp)%mod);   \\n            }\\n        }\\n        return dp[n]=a%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n      sort(arr.begin(),arr.end());\\n        map<int,long long int> dp;\\n        int x=0;\\n        for(int i=0;i<arr.size();i++){\\n            x=x%mod+recur(arr[i],arr,dp)%mod;\\n        }\\n        return x%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long long int recur(int n,vector<int> nums,map<int,long long int>& dp){\\n        if(dp.find(n)!=dp.end()) return dp[n];\\n        long long int a=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(n%nums[i]==0){\\n            vector<int>::iterator it;\\n            it=find(nums.begin(),nums.end(),n/nums[i]);\\n                if(it!=nums.end())\\n             a=a%mod+(recur(n/nums[i],nums,dp)%mod)*(recur(nums[i],nums,dp)%mod);   \\n            }\\n        }\\n        return dp[n]=a%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n      sort(arr.begin(),arr.end());\\n        map<int,long long int> dp;\\n        int x=0;\\n        for(int i=0;i<arr.size();i++){\\n            x=x%mod+recur(arr[i],arr,dp)%mod;\\n        }\\n        return x%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401571,
                "title": "c-map-sort-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        map<int, long long int> m;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            m.insert({arr[i], 1});\\n        }\\n        for (int i = 1; i < arr.size(); i++)\\n        {\\n            auto it2 = m.find(arr[i]);\\n            long long int count = 0;\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (arr[i] % arr[j] == 0)\\n                {\\n                    auto it = m.find(arr[i] / arr[j]);\\n                    auto it1 = m.find(arr[j]);\\n                    if (it != m.end())\\n                        count += (it->second) * (it1->second);\\n                }\\n            }\\n            it2->second += count;\\n        }\\n        long long int ans = 0;\\n        for (auto x = m.begin(); x != m.end(); x++)\\n            ans += x->second;\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        map<int, long long int> m;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            m.insert({arr[i], 1});\\n        }\\n        for (int i = 1; i < arr.size(); i++)\\n        {\\n            auto it2 = m.find(arr[i]);\\n            long long int count = 0;\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (arr[i] % arr[j] == 0)\\n                {\\n                    auto it = m.find(arr[i] / arr[j]);\\n                    auto it1 = m.find(arr[j]);\\n                    if (it != m.end())\\n                        count += (it->second) * (it1->second);\\n                }\\n            }\\n            it2->second += count;\\n        }\\n        long long int ans = 0;\\n        for (auto x = m.begin(); x != m.end(); x++)\\n            ans += x->second;\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401525,
                "title": "binary-trees-with-factors-commented-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private static int MODULO = 1000000007;\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        \\n        // Map is used to check if any element is present which can be multiplied with the child to give the value at the parent node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        \\n        // It is possible to create 1 binary tree with each elements\\n        Arrays.fill(dp,1);\\n        \\n        // Add the elements along with their index in the map\\n        for(int index = 0 ; index < n ; index++) {\\n            int element = arr[index];\\n            map.put(element, index);\\n        }\\n        \\n        // It is not possible to create another binary tree \\n        // So start from i = 0;\\n        for(int i = 1 ; i < n ; i++) {\\n            // Check with the elements less than the current element \\n            for(int j = 0 ; j < i ; j++) {\\n                // arr[j] is the left child\\n                if(arr[i] % arr[j] == 0) {\\n                    // Element to be multiplied with the child to give the value at the parent node\\n                    int rightChild = arr[i] / arr[j]; \\n                    \\n                    // If map contains the element\\n                    if(map.containsKey(rightChild)) {\\n                        // No: of ways the product can be formed with the particular left and right child\\n                        int indexrightChild = map.get(rightChild);\\n                        long ways = (dp[j] * dp[indexrightChild]) % MODULO;\\n                        dp[i] = (dp[i] +  ways) % MODULO;\\n                    }\\n                }    \\n            }\\n        }\\n        \\n        long count = 0;\\n        for(long c : dp) {\\n            count += c;\\n        }\\n        \\n        int result = (int)(count % MODULO);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static int MODULO = 1000000007;\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        \\n        // Map is used to check if any element is present which can be multiplied with the child to give the value at the parent node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        \\n        // It is possible to create 1 binary tree with each elements\\n        Arrays.fill(dp,1);\\n        \\n        // Add the elements along with their index in the map\\n        for(int index = 0 ; index < n ; index++) {\\n            int element = arr[index];\\n            map.put(element, index);\\n        }\\n        \\n        // It is not possible to create another binary tree \\n        // So start from i = 0;\\n        for(int i = 1 ; i < n ; i++) {\\n            // Check with the elements less than the current element \\n            for(int j = 0 ; j < i ; j++) {\\n                // arr[j] is the left child\\n                if(arr[i] % arr[j] == 0) {\\n                    // Element to be multiplied with the child to give the value at the parent node\\n                    int rightChild = arr[i] / arr[j]; \\n                    \\n                    // If map contains the element\\n                    if(map.containsKey(rightChild)) {\\n                        // No: of ways the product can be formed with the particular left and right child\\n                        int indexrightChild = map.get(rightChild);\\n                        long ways = (dp[j] * dp[indexrightChild]) % MODULO;\\n                        dp[i] = (dp[i] +  ways) % MODULO;\\n                    }\\n                }    \\n            }\\n        }\\n        \\n        long count = 0;\\n        for(long c : dp) {\\n            count += c;\\n        }\\n        \\n        int result = (int)(count % MODULO);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401480,
                "title": "simple-using-map-and-sorting-very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define MOD 1000000007\\n    #define ll long long\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n        ll ans = 0;\\n        \\n        unordered_map<ll,ll> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // leaf node\\n            ll curr_ans  = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                ll num1 = arr[j];\\n                ll num2 = arr[i]/arr[j];\\n                \\n                curr_ans = (curr_ans+(mp[num1]*mp[num2])%MOD)%MOD;\\n            }\\n            \\n            mp[arr[i]] = curr_ans;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define MOD 1000000007\\n    #define ll long long\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n        ll ans = 0;\\n        \\n        unordered_map<ll,ll> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // leaf node\\n            ll curr_ans  = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                ll num1 = arr[j];\\n                ll num2 = arr[i]/arr[j];\\n                \\n                curr_ans = (curr_ans+(mp[num1]*mp[num2])%MOD)%MOD;\\n            }\\n            \\n            mp[arr[i]] = curr_ans;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401454,
                "title": "easy-dp-tabulation",
                "content": "Time Complexity: O(N2)\\nSpace Complexity: O(N)\\n```\\nclass Solution { // 29 ms -- 98.5% Faster\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n=arr.length,dp[] = new int[n],i,j,res=0; long val;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(i=0;i<n;i++){\\n            for(j=0,val=1;j<i;j++)\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    val=(val+(long)map.get(arr[j])*(long)map.get(arr[i]/arr[j]))%1000000007;\\n            res=(res+(dp[i]=(int)val))%1000000007;\\n            map.put(arr[i],dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution { // 29 ms -- 98.5% Faster\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n=arr.length,dp[] = new int[n],i,j,res=0; long val;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(i=0;i<n;i++){\\n            for(j=0,val=1;j<i;j++)\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    val=(val+(long)map.get(arr[j])*(long)map.get(arr[i]/arr[j]))%1000000007;\\n            res=(res+(dp[i]=(int)val))%1000000007;\\n            map.put(arr[i],dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401353,
                "title": "hashmap-c-dp-easy-solution",
                "content": "**Please upvote if u like the solution**\\n\\n\\n\\n\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n      sort(arr.begin(), arr.end());\\n        int mod=1e9+7;\\n        unordered_map<int , long>dp;\\n        \\n    long res=0;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            dp[arr[i]]=1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j]==0){\\n               dp[arr[i]]=dp[arr[i]]+dp[arr[j]]*dp[arr[i]/arr[j]];      \\n                }\\n             \\n            }\\n           res=(res+dp[arr[i]])%mod;  \\n        }\\n        \\n        return res;\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**Please upvote if u like the solution**\\n\\n\\n\\n\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n      sort(arr.begin(), arr.end());\\n        int mod=1e9+7;\\n        unordered_map<int , long>dp;\\n        \\n    long res=0;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            dp[arr[i]]=1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j]==0){\\n               dp[arr[i]]=dp[arr[i]]+dp[arr[j]]*dp[arr[i]/arr[j]];      \\n                }\\n             \\n            }\\n           res=(res+dp[arr[i]])%mod;  \\n        }\\n        \\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2401265,
                "title": "python-faster-than-91-memoization-easy-approach",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        s=set(arr)\\n        mp={}\\n        ans=0\\n        # To minimize the traversal time\\n        arr.sort()\\n        def f(el):\\n            a=1\\n            if el in mp:\\n                return mp[el]\\n            for x in arr:\\n                if x>math.sqrt(el):\\n                    break\\n                if el/x in s :\\n                    if el/x==x:\\n                        a+=f(int(el/x))*f(x)\\n                    else:\\n                        a+=f(int(el/x))*f(x)*2\\n            mp[el]=a\\n            return a\\n        for i in range(len(arr)):\\n            ans+=f(arr[i])\\n        return (ans)%(pow(10,9)+7)                 \\n```\\n# \\uD83E\\uDD7A\\uD83E\\uDD7A Please Upvote \\uD83D\\uDC4D if it helped you \\u2764\\uFE0F .",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        s=set(arr)\\n        mp={}\\n        ans=0\\n        # To minimize the traversal time\\n        arr.sort()\\n        def f(el):\\n            a=1\\n            if el in mp:\\n                return mp[el]\\n            for x in arr:\\n                if x>math.sqrt(el):\\n                    break\\n                if el/x in s :\\n                    if el/x==x:\\n                        a+=f(int(el/x))*f(x)\\n                    else:\\n                        a+=f(int(el/x))*f(x)*2\\n            mp[el]=a\\n            return a\\n        for i in range(len(arr)):\\n            ans+=f(arr[i])\\n        return (ans)%(pow(10,9)+7)                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401233,
                "title": "c-dp-approach-explained-with-comments-o-n2-time-o-n-space-solution",
                "content": "The first obvious hint at looking at his problem is that there is no TreeNode definition , so we don\\'t have to actually build a Tree.  Here are the observations that we should get on reading the problem\\n\\n\\t1.A tree **CAN NOT** have 1 child.\\n\\t2.No of trees possible for a Node with no children = 1\\n\\t3.No of trees possible for a Node(a) with valid children(b,c) such that(a=b*c) = no of trees(b)*no(of trees c ). \\n\\n3 gives the first condition for DP.i.e we can break into subproblems. Now we need to see if calculating in naive way , we repeat subproblems.Lets take eg of 40-\\n\\n\\t1. The factors are {2,20},{20,2},{4,10},{10,4},{5,8},{8,5}.\\n\\t2. Now for trees{20,2} = trees(20)*trees(2);\\n\\t3. notice that trees(20) is gonna calculate the subproblem trees(10) and so is the pair {4,10}. Thus we have the second condition for DP, repetition of sub problems.\\n\\nNow we need to populate 2 things for our algorithm.\\n\\t1. A hashmap for each element in the arr with a list of all pairs of factor.\\n\\t2. A dp array that stores the number of trees possible for an arr element.\\n\\nAlgorithm\\n1.  Create the Hashmap with the number as key and list of the pair of factos as the value. {a,b} and {b,a} are allowed as long as a!=b.\\n2.  For every element in arr- iterate over the possible pair of divisors(left and right child in the tree)\\n3.  if no such pair of divisors- trees[arr[i]] =1;\\n4.  otherwise for every pair - **trees[root] = trees[root]%MOD + trees[pair.first]%MOD * trees[pair.second]%MOD**. we know for sure that pair.first and pair.second have already been populated since we\\'re moving in ascending order.\\n5.  return ans%MOD.\\n\\nTime complexity = (O(nlogn +n^2 + n^2)) = O(n2)\\nSpace complexity = O(n + n) = O(n)\\n\\n![image](https://assets.leetcode.com/users/images/df9338c4-41cb-4cf4-bf16-b938392ac2df_1660031312.1613998.png)\\n\\n\\nThe code is as follows-\\n\\n```\\nclass Solution {\\npublic:\\n    // Global variables to help with MOD\\n    int MOD= pow(10,9)+7;\\n    \\n    //factor hashmap is gonna contain the pair of factors for that key\\n    unordered_map<int,vector<pair<int,int>>> factor;\\n    // DP hashmap, will contain the no of trees possible for the key\\n    unordered_map<int,long long> trees;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        // create a set of original array for O(1) checking of the second factor\\n        unordered_set<int> s(arr.begin(),arr.end());\\n        // sorting in O(nlogn), can be done without this, but since overall complexity is O(n*n) due to divisor loop, this will not affect it.\\n        sort(arr.begin(),arr.end());\\n        \\n        // create the Divisor hashmap,\\n        for (int i=n-1;i>=0;i--){\\n            // set the possible trees to 1 for every tree, this represents the tree without any child\\n            trees[arr[i]]=1;\\n            // considering arr[i] to be the root\\n            int root = arr[i];\\n            for(int j=i-1;j>=0;j--){\\n                // A break statement can be added here to break if arr[j]<sqrt(n),in my case i dont do it, since it leads to factors like (case i) (a,b ) and (b,a ) to be populated if a!=b otherwise (case ii) (a,a) is only populated once, this is in line as case i are two different possibilities of subtree, while case ii is only 1 subtree\\n                if(root%arr[j]==0){\\n                    if(s.find(root/arr[j])!=s.end()){\\n                        if(factor.find(root)!=factor.end()){\\n                            factor[root].push_back(make_pair(arr[j],root/arr[j]));\\n                        }\\n                        else{\\n                            factor[root]={make_pair(arr[j],root/arr[j])};\\n                        }\\n                    }\\n                }\\n            }\\n            // at the end of this j loop, arr[i] has its factor in the hash table\\n        }\\n        \\n        \\n        // now the preparation is done for the meat of the solution\\n        int ans =0;\\n        for (int i=0;i<n;i++){\\n            // consider arr[i] to be root\\n            int root= arr[i];\\n            // if root does not have any factors, this code just adds 1 to the answer\\n            if(factor.find(root)==factor.end()){\\n                ans+=trees[root];\\n                continue;\\n            }\\n            // else if  we have factors, get the factors from the hasmap.\\n            vector<pair<int,int>> divisors = factor[root];\\n            // for every pair of divisor(notice here we are going in increasing order, This is necessary for DP to work as the number of trees for factors will already be populated for the larger number)\\n            for( int j=0;j<divisors.size();j++){\\n                pair<int,int> p = divisors[j];\\n\\n                // add (no of possible trees for left subtree(divisor1) multiplied by no of possible trees for right subtree(divisor2) ) + MOD is distributive over multipplciation\\n                trees[root]= trees[root]%MOD + (trees[p.first]%MOD)*(trees[p.second]%MOD);\\n            }\\n\\n            // at end of j loop we have the no of trees possible for arr[i] so add to answer\\n            ans=ans%MOD + trees[root]%MOD;\\n            \\n        }\\n        // return the answer\\n        return ans%MOD;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Global variables to help with MOD\\n    int MOD= pow(10,9)+7;\\n    \\n    //factor hashmap is gonna contain the pair of factors for that key\\n    unordered_map<int,vector<pair<int,int>>> factor;\\n    // DP hashmap, will contain the no of trees possible for the key\\n    unordered_map<int,long long> trees;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        // create a set of original array for O(1) checking of the second factor\\n        unordered_set<int> s(arr.begin(),arr.end());\\n        // sorting in O(nlogn), can be done without this, but since overall complexity is O(n*n) due to divisor loop, this will not affect it.\\n        sort(arr.begin(),arr.end());\\n        \\n        // create the Divisor hashmap,\\n        for (int i=n-1;i>=0;i--){\\n            // set the possible trees to 1 for every tree, this represents the tree without any child\\n            trees[arr[i]]=1;\\n            // considering arr[i] to be the root\\n            int root = arr[i];\\n            for(int j=i-1;j>=0;j--){\\n                // A break statement can be added here to break if arr[j]<sqrt(n),in my case i dont do it, since it leads to factors like (case i) (a,b ) and (b,a ) to be populated if a!=b otherwise (case ii) (a,a) is only populated once, this is in line as case i are two different possibilities of subtree, while case ii is only 1 subtree\\n                if(root%arr[j]==0){\\n                    if(s.find(root/arr[j])!=s.end()){\\n                        if(factor.find(root)!=factor.end()){\\n                            factor[root].push_back(make_pair(arr[j],root/arr[j]));\\n                        }\\n                        else{\\n                            factor[root]={make_pair(arr[j],root/arr[j])};\\n                        }\\n                    }\\n                }\\n            }\\n            // at the end of this j loop, arr[i] has its factor in the hash table\\n        }\\n        \\n        \\n        // now the preparation is done for the meat of the solution\\n        int ans =0;\\n        for (int i=0;i<n;i++){\\n            // consider arr[i] to be root\\n            int root= arr[i];\\n            // if root does not have any factors, this code just adds 1 to the answer\\n            if(factor.find(root)==factor.end()){\\n                ans+=trees[root];\\n                continue;\\n            }\\n            // else if  we have factors, get the factors from the hasmap.\\n            vector<pair<int,int>> divisors = factor[root];\\n            // for every pair of divisor(notice here we are going in increasing order, This is necessary for DP to work as the number of trees for factors will already be populated for the larger number)\\n            for( int j=0;j<divisors.size();j++){\\n                pair<int,int> p = divisors[j];\\n\\n                // add (no of possible trees for left subtree(divisor1) multiplied by no of possible trees for right subtree(divisor2) ) + MOD is distributive over multipplciation\\n                trees[root]= trees[root]%MOD + (trees[p.first]%MOD)*(trees[p.second]%MOD);\\n            }\\n\\n            // at end of j loop we have the no of trees possible for arr[i] so add to answer\\n            ans=ans%MOD + trees[root]%MOD;\\n            \\n        }\\n        // return the answer\\n        return ans%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401220,
                "title": "cpp-dynamic-programming",
                "content": "```\\nint binaryTreeWithFactor(vector<int> arr) {\\n\\tmap<int, long long int> mp; // value of array --> count of binary tree with root as the value;\\n\\t//NOTE: this map will works as a storage for DP.\\n\\n\\tfor (int ele : arr) {\\n\\t\\tmp[ele] = 1;\\n\\t\\t//coz, har value ko as a root mante hue hm ek binary tree bna skte h.\\n\\t\\t//NOTE: all the values are unique in array, given in question.\\n\\t}\\n\\tsort(arr.begin(), arr.end());\\n\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\tlong long int count = 0; //no of ways\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0) { //arr[j] is a factor of arr[i]\\n\\t\\t\\t\\t//NOTE: arr[i]/arr[j] --> gives the another factor ie, if arr[j] * arr[i]/arr[j] = arr[i] (think, simple maths)\\n\\t\\t\\t\\tauto it = mp.find(arr[i] / arr[j]);\\n\\t\\t\\t\\tif (it != mp.end()) { //found, we found the other number using which we can get the product as arr[i]\\n\\t\\t\\t\\t\\tcount += (mp[arr[j]] * it->second); //crucial part, WV\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//update the DP(map) with the new value\\n\\t\\tmp[arr[i]] += count;\\n\\t}\\n\\n\\t//add all the values(ways of forming binary trees)\\n\\tlong long int ans = 0;\\n\\tfor (auto it : mp) {\\n\\t\\tans += it.second;\\n\\t}\\n\\treturn (ans % 1000000007);\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint binaryTreeWithFactor(vector<int> arr) {\\n\\tmap<int, long long int> mp; // value of array --> count of binary tree with root as the value;\\n\\t//NOTE: this map will works as a storage for DP.\\n\\n\\tfor (int ele : arr) {\\n\\t\\tmp[ele] = 1;\\n\\t\\t//coz, har value ko as a root mante hue hm ek binary tree bna skte h.\\n\\t\\t//NOTE: all the values are unique in array, given in question.\\n\\t}\\n\\tsort(arr.begin(), arr.end());\\n\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\tlong long int count = 0; //no of ways\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0) { //arr[j] is a factor of arr[i]\\n\\t\\t\\t\\t//NOTE: arr[i]/arr[j] --> gives the another factor ie, if arr[j] * arr[i]/arr[j] = arr[i] (think, simple maths)\\n\\t\\t\\t\\tauto it = mp.find(arr[i] / arr[j]);\\n\\t\\t\\t\\tif (it != mp.end()) { //found, we found the other number using which we can get the product as arr[i]\\n\\t\\t\\t\\t\\tcount += (mp[arr[j]] * it->second); //crucial part, WV\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//update the DP(map) with the new value\\n\\t\\tmp[arr[i]] += count;\\n\\t}\\n\\n\\t//add all the values(ways of forming binary trees)\\n\\tlong long int ans = 0;\\n\\tfor (auto it : mp) {\\n\\t\\tans += it.second;\\n\\t}\\n\\treturn (ans % 1000000007);\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2401196,
                "title": "c-simple-solution-hashmap",
                "content": "```\\n    int mod = 1e9 + 7;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int, long long int> mp;\\n        long long int ans = arr.size();\\n        \\n        for(auto num: arr) mp[num] = 1;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=1;i<arr.size();i++) {\\n            long long int count = 0;\\n            \\n            for(int j=0;j<i;j++) {\\n\\t\\t\\t\\n                //check arr[j] is a factor of arr[i] or not. if not then we can\\'t procced with this, \\n\\t\\t\\t\\t//because product of children will never be equal to parent.\\n                if(arr[i] % arr[j] != 0) continue;  \\n                \\n                int num = arr[i]/arr[j]; // if arr[j] is a factor of arr[i]. Then the other child value must be equal to arr[i]/ arr[j]. \\n\\t\\t\\t\\t\\n                if(mp.find(num) != mp.end()) // Check is num present or not.\\n                    count += mp[arr[j]] * mp[num];  // mutliple to find all the possible compination.\\n                \\n            }\\n            ans += count % mod;\\n            mp[arr[i]] += count;\\n        }\\n        \\n        return ans % mod;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int mod = 1e9 + 7;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int, long long int> mp;\\n        long long int ans = arr.size();\\n        \\n        for(auto num: arr) mp[num] = 1;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=1;i<arr.size();i++) {\\n            long long int count = 0;\\n            \\n            for(int j=0;j<i;j++) {\\n\\t\\t\\t\\n                //check arr[j] is a factor of arr[i] or not. if not then we can\\'t procced with this, \\n\\t\\t\\t\\t//because product of children will never be equal to parent.\\n                if(arr[i] % arr[j] != 0) continue;  \\n                \\n                int num = arr[i]/arr[j]; // if arr[j] is a factor of arr[i]. Then the other child value must be equal to arr[i]/ arr[j]. \\n\\t\\t\\t\\t\\n                if(mp.find(num) != mp.end()) // Check is num present or not.\\n                    count += mp[arr[j]] * mp[num];  // mutliple to find all the possible compination.\\n                \\n            }\\n            ans += count % mod;\\n            mp[arr[i]] += count;\\n        }\\n        \\n        return ans % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2401172,
                "title": "binary-trees-with-factors-java-solution",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] a) {\\n        long output = 0L , mod = (long)1e9+7;\\n        Arrays.sort(a);\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            map.put(a[i],1L);\\n            for(int j=0;j<i;j++)\\n                if(a[i]%a[j]==0)\\n                    map.put(a[i],map.get(a[i])+map.get(a[j])*map.getOrDefault(a[i]/a[j],0L)%mod);\\n            output = (output+map.get(a[i]))%mod;\\n        }\\n        return (int)output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] a) {\\n        long output = 0L , mod = (long)1e9+7;\\n        Arrays.sort(a);\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            map.put(a[i],1L);\\n            for(int j=0;j<i;j++)\\n                if(a[i]%a[j]==0)\\n                    map.put(a[i],map.get(a[i])+map.get(a[j])*map.getOrDefault(a[i]/a[j],0L)%mod);\\n            output = (output+map.get(a[i]))%mod;\\n        }\\n        return (int)output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401112,
                "title": "dynamic-programming-c",
                "content": "```\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        map<int,int>dp;\\n        int ans=1;  \\n        dp[arr[0]]=1;\\n        for(int i=1;i<n;i++){\\n            dp[arr[i]]=1;\\n                for(int j=0;j<i;j++){\\n                    if(arr[i]%arr[j]==0 && dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]]=\\n                        (\\n                            (long int)dp[arr[i]]+\\n                            (long int)dp[arr[j]]*\\n                            (long int)dp[arr[i]/arr[j]]\\n                        )%mod;\\n                }\\n            ans=((long int)ans+(long int)dp[arr[i]])%mod;\\n        }\\n        return ans;\\n\\t}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        map<int,int>dp;\\n        int ans=1;  \\n        dp[arr[0]]=1;\\n        for(int i=1;i<n;i++){\\n            dp[arr[i]]=1;\\n                for(int j=0;j<i;j++){\\n                    if(arr[i]%arr[j]==0 && dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]]=\\n                        (\\n                            (long int)dp[arr[i]]+\\n                            (long int)dp[arr[j]]*\\n                            (long int)dp[arr[i]/arr[j]]\\n                        )%mod;\\n                }\\n            ans=((long int)ans+(long int)dp[arr[i]])%mod;\\n        }\\n        return ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401008,
                "title": "c-solution-using-two-pointers-explained",
                "content": "Here, dp[i] signifies the number of trees with arr[i] as **root node**.\\nSort the array first.\\nInitialize the dp array with 1 since there can always be a tree with a single node.\\nFor each element in array, we just check which two elements from arr[0] till arr[i-1] multiply to give arr[i]. \\nIf the arr[start] and arr[end] are not the same, we multiply the product of the both by 2 since the two subtrees can be swapped.\\n\\n\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        int n=arr.size();\\n        vector<long long> dp(n, 1);\\n        long long ans=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int start=0;\\n            int end=i-1;\\n            while(start<end)\\n            {\\n                if((long long)arr[start]*(long long)arr[end] > arr[i])\\n                    end--;\\n                else if((long long)arr[start]*(long long)arr[end] < arr[i])\\n                    start++;\\n                else\\n                {\\n                    dp[i] += (2*dp[start]*dp[end])%mod;\\n                    start++;end--;\\n                }\\n                \\n            }\\n            if(start==end && (long long)arr[start]*(long long)arr[end]==arr[i])\\n                dp[i] = ((dp[start]*dp[start])%mod + dp[i])%mod;\\n            \\n            ans = (ans + dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        int n=arr.size();\\n        vector<long long> dp(n, 1);\\n        long long ans=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int start=0;\\n            int end=i-1;\\n            while(start<end)\\n            {\\n                if((long long)arr[start]*(long long)arr[end] > arr[i])\\n                    end--;\\n                else if((long long)arr[start]*(long long)arr[end] < arr[i])\\n                    start++;\\n                else\\n                {\\n                    dp[i] += (2*dp[start]*dp[end])%mod;\\n                    start++;end--;\\n                }\\n                \\n            }\\n            if(start==end && (long long)arr[start]*(long long)arr[end]==arr[i])\\n                dp[i] = ((dp[start]*dp[start])%mod + dp[i])%mod;\\n            \\n            ans = (ans + dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400975,
                "title": "c-dp-approach",
                "content": "* class Solution {\\n* public:\\n*      int numFactoredBinaryTrees(vector<int>& arr) {\\n*         long res = 0, mod = pow(10, 9) + 7;\\n*         sort(arr.begin(), arr.end());\\n*         unordered_map<int, long long int> dp;\\n*         for (int i = 0; i < arr.size(); ++i) {\\n*             dp[arr[i]] = 1;\\n*             for (int j = 0; j < i; ++j)\\n*                 if (arr[i] % arr[j] == 0)\\n*                     dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % mod;\\n*             res = (res + dp[arr[i]]) % mod;\\n*         }\\n*         return res;\\n*     }\\n* };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n* public:\\n*      int numFactoredBinaryTrees(vector<int>& arr) {\\n*         long res = 0, mod = pow(10, 9) + 7;\\n*         sort(arr.begin(), arr.end());\\n*         unordered_map<int, long long int> dp;\\n*         for (int i = 0; i < arr.size(); ++i) {\\n*             dp[arr[i]] = 1;\\n*             for (int j = 0; j < i; ++j)\\n*                 if (arr[i] % arr[j] == 0)\\n*                     dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % mod;\\n*             res = (res + dp[arr[i]]) % mod;\\n*         }",
                "codeTag": "Java"
            },
            {
                "id": 2400838,
                "title": "python-dict-bottom-up-dp",
                "content": "The existing solutions are too verbose to read. Here\\'s mine\\n  \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # time: O(n^2), space: O(n)\\n        arr.sort()\\n        dp = defaultdict(int)\\n        for num in arr:\\n            dp[num] = 1\\n            \\n        for i in range(len(arr)):\\n            for j in range(i+1): \\n                prd = arr[i]*arr[j]\\n            \\n                if prd > arr[-1]: # arr sorted. if multiple too large, break\\n                    break\\n                if dp[prd] <= 0: # prd not in arr\\n                    continue\\n                    \\n\\t\\t\\t\\t# multiply 2 to handle case when elems in a pair arent the same\\n\\t\\t\\t\\t# ie. (2,10) & (10,2)\\n                dp[prd] += dp[arr[i]]*dp[arr[j]]*(2 if arr[i] != arr[j] else 1)\\n        \\n        return sum(dp[num] for num in arr) % (10**9 + 7)\\n ```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # time: O(n^2), space: O(n)\\n        arr.sort()\\n        dp = defaultdict(int)\\n        for num in arr:\\n            dp[num] = 1\\n            \\n        for i in range(len(arr)):\\n            for j in range(i+1): \\n                prd = arr[i]*arr[j]\\n            \\n                if prd > arr[-1]: # arr sorted. if multiple too large, break\\n                    break\\n                if dp[prd] <= 0: # prd not in arr\\n                    continue\\n                    \\n\\t\\t\\t\\t# multiply 2 to handle case when elems in a pair arent the same\\n\\t\\t\\t\\t# ie. (2,10) & (10,2)\\n                dp[prd] += dp[arr[i]]*dp[arr[j]]*(2 if arr[i] != arr[j] else 1)\\n        \\n        return sum(dp[num] for num in arr) % (10**9 + 7)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2400793,
                "title": "easy-c-intution-explained-dp-hashmap",
                "content": "**Intution** : *sort the array and use **HashMap** to record each Integer, and the number of trees that can be formed with that Integer as root* \\n\\n*  we are initializing **dp** with **1** because each integer will always have one tree with only itself.\\n* Let\\'s suppose we want 18 as root and we have the nodes with value 3 and 6 So, `dp[18] = dp[18] + no ways of trees that can be obtained with 6 as root * 3 as root ` (here for better understanding we are taking dp[18] but actaully it is `dp[pos of 18]` )\\n* finally we sum all the number of trees that can be formed with that integer ie `for(auto x : dp)  res+=x ;`\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long res=0,n=arr.size();\\n        vector<long long> dp(n,1);\\n        unordered_map<long long,long long> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        for(long long i=0;i<n;i++) mp[arr[i]]=i;\\n        \\n        \\n        for(long long i=0;i<n;i++){\\n            for(long long j=i-1; j>=0; j--)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    long long div = arr[i]/arr[j];\\n                    if(mp.count(div)) dp[i]+=(dp[j]*dp[mp[div]])%mod;\\n                }\\n            }\\n        }\\n        \\n        for(auto x : dp)  res+=x ;\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long res=0,n=arr.size();\\n        vector<long long> dp(n,1);\\n        unordered_map<long long,long long> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        for(long long i=0;i<n;i++) mp[arr[i]]=i;\\n        \\n        \\n        for(long long i=0;i<n;i++){\\n            for(long long j=i-1; j>=0; j--)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    long long div = arr[i]/arr[j];\\n                    if(mp.count(div)) dp[i]+=(dp[j]*dp[mp[div]])%mod;\\n                }\\n            }\\n        }\\n        \\n        for(auto x : dp)  res+=x ;\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400720,
                "title": "java-hashmap",
                "content": "```\\npublic int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400638,
                "title": "c-easy-soluton-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint N = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int>& a) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tint n = a.size();\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) m[a[i]] = 1;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tlong long ct = 0;\\n\\t\\t\\tfor (int j = 0; j < i; ++j) {\\n\\t\\t\\t\\tif (a[i] % a[j] == 0) (ct += m[a[j]] * 1LL * m[a[i] / a[j]])%= N;\\n\\t\\t\\t}\\n\\t\\t\\tm[a[i]] += ct;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (auto &e : m) (ans += e.second) %= N;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint N = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int>& a) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tint n = a.size();\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) m[a[i]] = 1;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tlong long ct = 0;\\n\\t\\t\\tfor (int j = 0; j < i; ++j) {\\n\\t\\t\\t\\tif (a[i] % a[j] == 0) (ct += m[a[j]] * 1LL * m[a[i] / a[j]])%= N;\\n\\t\\t\\t}\\n\\t\\t\\tm[a[i]] += ct;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (auto &e : m) (ans += e.second) %= N;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400619,
                "title": "detailed-explanation-c-dp-simple-solution-accepted",
                "content": "Lets take an example [4,2,8]\\n1. As per the problem each item itself is a valid node. i.e [2],[4],[8]\\n2. And as root is always greater than its children. the smallest item cannot have anymore children node, so Binary trees with root 2 is only 1.\\nSo we need to sort the array so we can hardcode first element tree numbers and start the calculation from 2nd one.\\n![image](https://assets.leetcode.com/users/images/b3b3cb72-373f-4351-8194-dde7d57bf1df_1660022070.6698098.png)\\nand hardcoding 1 for first element, Here is the code for that\\n![image](https://assets.leetcode.com/users/images/da62428c-bb92-4d2b-a677-c162b6d93c68_1660022004.6806722.png)\\n\\n3. When 8 have 2 children nodes i.e 4 and 2. we need to see how many tree nodes can be formed with 4 so that can be computed for 8 as well.\\nso we use dictionary to keep track of computed nodes number and use them to compute different combinations for greater numbers i.e we use number of trees for root 2 and 4 to compute for root 8.\\n![image](https://assets.leetcode.com/users/images/b73f086b-cdc0-4842-9f33-239c02ecde9b_1660022395.4377546.png)\\n4. In the solution we first get one child node using **(arr[i]%key==0)** , it means one child is already in the dictioanry i.e **key** and then to find the second child we use **records[arr[i]/key]**. we got both the nodes.\\n5. Then we sum up all the values in dictionary to get the sum of binary trees.\\n ![image](https://assets.leetcode.com/users/images/f5ff006d-394c-489b-80ec-448e141ab282_1660022430.4626384.png)\\n\\nNOTE: Use long to avoid overflows\\n\\n**Please upvote if you like the explanation and solution, it means a lot**\\n\\n```\\npublic class Solution {\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        long counter = 1;\\n        long mod = 1000000007;\\n        Array.Sort(arr);\\n        Dictionary<int,long> records = new Dictionary<int,long>();\\n        records.Add(arr[0], counter);\\n        \\n        for(int i=1; i<arr.Length; i++){\\n            counter = 1;\\n            foreach(int key in records.Keys){\\n                if((arr[i]%key==0) && records.ContainsKey(arr[i]/key))\\n                    counter += (records[key] * records[arr[i]/key]);                \\n            }  \\n            records.Add(arr[i],counter);\\n        }\\n        long sum  = 0;\\n        foreach(long curvalue in records.Values)\\n            sum = (sum + curvalue)%mod;\\n        return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        long counter = 1;\\n        long mod = 1000000007;\\n        Array.Sort(arr);\\n        Dictionary<int,long> records = new Dictionary<int,long>();\\n        records.Add(arr[0], counter);\\n        \\n        for(int i=1; i<arr.Length; i++){\\n            counter = 1;\\n            foreach(int key in records.Keys){\\n                if((arr[i]%key==0) && records.ContainsKey(arr[i]/key))\\n                    counter += (records[key] * records[arr[i]/key]);                \\n            }  \\n            records.Add(arr[i],counter);\\n        }\\n        long sum  = 0;\\n        foreach(long curvalue in records.Values)\\n            sum = (sum + curvalue)%mod;\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400572,
                "title": "a-simple-c-solution",
                "content": "A Simple solution with time complexity O((n^2)*lg(n))\\n```\\nclass Solution {\\npublic:\\n    int MOD=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=1;\\n        for(int i=1;i<arr.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(binary_search(arr.begin(),arr.end(),arr[i]/arr[j])){\\n                        if(arr[i]/arr[j]>arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[i]/arr[j]]*2)%MOD;\\n                        else if(arr[i]/arr[j]==arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<arr.size();i++)\\n            answer=(answer+mp[arr[i]])%MOD;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=1;\\n        for(int i=1;i<arr.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(binary_search(arr.begin(),arr.end(),arr[i]/arr[j])){\\n                        if(arr[i]/arr[j]>arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[i]/arr[j]]*2)%MOD;\\n                        else if(arr[i]/arr[j]==arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<arr.size();i++)\\n            answer=(answer+mp[arr[i]])%MOD;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400534,
                "title": "c-soluting-using-unordered-map",
                "content": "\\n   \\n\\n     class Solution {\\n     public:\\n     int mod=1e9+7;\\n      int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long>mpp;\\n        int ans=0;\\n        sort(arr.begin(),arr.end());\\n\\t\\t// here we are running two loops  as the size of the array is 1e3\\n\\t\\t  // so it will be passed  in 1sec\\n        for(int i=0;i<n;i++){\\n            mpp[arr[i]]=1;\\n            for(int j=0;j<i;j++){\\n                if((arr[i]%arr[j])==0){\\n                    mpp[arr[i]]+=(mpp[arr[j]])*(mpp[arr[i]/arr[j]]);\\n                    mpp[arr[i]]%=mod;\\n                }\\n            }\\n            ans=(ans+mpp[arr[i]])%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n// T.C: O(N^2)( for two loops)\\n//S.C: O(N) ( for using the map)",
                "solutionTags": [
                    "Ordered Map"
                ],
                "code": "class Solution {\\n     public:\\n     int mod=1e9+7;\\n      int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long>mpp;\\n        int ans=0;\\n        sort(arr.begin(),arr.end());\\n\\t\\t// here we are running two loops  as the size of the array is 1e3\\n\\t\\t  // so it will be passed  in 1sec\\n        for(int i=0;i<n;i++){\\n            mpp[arr[i]]=1;\\n            for(int j=0;j<i;j++){\\n                if((arr[i]%arr[j])==0){\\n                    mpp[arr[i]]+=(mpp[arr[j]])*(mpp[arr[i]/arr[j]]);\\n                    mpp[arr[i]]%=mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2400508,
                "title": "bottom-up-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long long n = arr.size(), ans = 0, mod = 1e9+7;\\n        \\n        // sorting because we can check for smaller values as factor\\n        sort(arr.begin(), arr.end());\\n        \\n        // base case -> each node will have at least 1 tree, itself as root\\n        vector<long long> dp(n, 1);\\n        \\n        // to keep track of indices\\n        unordered_map<int, int> vis;\\n        for(int i = 0; i < n; i++) vis[arr[i]] = i;\\n        \\n        // counting for current node as parent\\n        for(int parent = 0; parent < n; ++parent) {\\n            // finding a potential left child \\n            for(int left = 0; left < parent; ++left) {\\n                if(arr[parent] % arr[left] == 0) {\\n                    // if there exists a right such that arr[parent] = arr[left] * arr[right]\\n                    if(vis.find(arr[parent] / arr[left]) != vis.end()) {\\n                        int right = arr[parent] / arr[left];\\n                        // trees[parent] = trees[left] * trees[right]\\n                        dp[parent] += (dp[left] % mod * dp[vis[right]] % mod) % mod;\\n                    }\\n                }\\n            }\\n            // total trees by using current node as parent\\n            ans += dp[parent] % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long long n = arr.size(), ans = 0, mod = 1e9+7;\\n        \\n        // sorting because we can check for smaller values as factor\\n        sort(arr.begin(), arr.end());\\n        \\n        // base case -> each node will have at least 1 tree, itself as root\\n        vector<long long> dp(n, 1);\\n        \\n        // to keep track of indices\\n        unordered_map<int, int> vis;\\n        for(int i = 0; i < n; i++) vis[arr[i]] = i;\\n        \\n        // counting for current node as parent\\n        for(int parent = 0; parent < n; ++parent) {\\n            // finding a potential left child \\n            for(int left = 0; left < parent; ++left) {\\n                if(arr[parent] % arr[left] == 0) {\\n                    // if there exists a right such that arr[parent] = arr[left] * arr[right]\\n                    if(vis.find(arr[parent] / arr[left]) != vis.end()) {\\n                        int right = arr[parent] / arr[left];\\n                        // trees[parent] = trees[left] * trees[right]\\n                        dp[parent] += (dp[left] % mod * dp[vis[right]] % mod) % mod;\\n                    }\\n                }\\n            }\\n            // total trees by using current node as parent\\n            ans += dp[parent] % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400486,
                "title": "c-code-dp-sorting-hash-table-with-intuition-and-time-complexity",
                "content": "Intution \\n1.As given one value is also a tree node root so base case will be one \\n2. If the product are present like for 12 6 and 2 or 3 or 4 is there means it is a tree \\n3. If they are the children have aslo childrens so we are multiplying them left child * right child//\\n4.And we are sorting it ro get left child and right child sub tree first then it will give us the correct value\\njust do one dry run we will understand the Intuition \\n\\nT.C. ->O(nlogn)+O(N*N) = O(N*N);\\nSC->O(N)+O(N)=O(N)\\n\\n```\\n int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        \\n      long ans=0;\\n        vector<long>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    if(arr[i]%arr[j]==0){\\n                        if(mp.find(arr[i]/arr[j])!=mp.end()){\\n                            int k=mp[arr[i]/arr[j]];\\n                            dp[i]+=(dp[j]*dp[k])%mod;//left child multiply right child \\n                        }\\n                    }\\n                }\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        \\n      long ans=0;\\n        vector<long>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    if(arr[i]%arr[j]==0){\\n                        if(mp.find(arr[i]/arr[j])!=mp.end()){\\n                            int k=mp[arr[i]/arr[j]];\\n                            dp[i]+=(dp[j]*dp[k])%mod;//left child multiply right child \\n                        }\\n                    }\\n                }\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400456,
                "title": "90-tc-and-83-sc-easy-python-solution",
                "content": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n\\tarr.sort()\\n\\tdp = {i:1 for i in arr}\\n\\tans = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tnum = arr[i]\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif(num % arr[j] == 0):\\n\\t\\t\\t\\tif(num//arr[j] in dp):\\n\\t\\t\\t\\t\\tdp[num] = (dp[num] + dp[arr[j]] * dp[num//arr[j]]) % 1000000007\\n\\t\\tans += dp[num]\\n\\treturn ans % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n\\tarr.sort()\\n\\tdp = {i:1 for i in arr}\\n\\tans = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tnum = arr[i]\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif(num % arr[j] == 0):\\n\\t\\t\\t\\tif(num//arr[j] in dp):\\n\\t\\t\\t\\t\\tdp[num] = (dp[num] + dp[arr[j]] * dp[num//arr[j]]) % 1000000007\\n\\t\\tans += dp[num]\\n\\treturn ans % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2400284,
                "title": "o-n-counting-using-cache-from-sub-trees-dp-hash-table-recursion",
                "content": "**Main Idea**:\\n+ The total binary of a specific number comprises it, and the number of sub-trees that are created from a splitting of left and right nodes.\\n+ A valid decomposition is splitting a node with the value product of left and right nodes equal to the parent node.\\n+ The number of sub-trees generated from splitting nodes is the product of the number of left and right sub-trees.\\n+ Using hash-table to cache all the number of sub-trees (preventing calculating again)\\n\\n**Examples**:\\n```\\na = {18, 6, 3, 2}\\n2 -> {2} = 1\\n3 -> {3} = 1\\n6 -> {6} = 1\\n     {6} {2} {3} = 1 x 1  = 1\\n     {6} {3} {2} = 1 x 1 = 1\\n  -> 3\\n18 -> 18 = 1\\n      18 {6} {3} = 3 x 1 = 3\\n\\t  18 6[0] 3\\n\\t  18 6[2,3] 3\\n\\t  18 6[3,2] 3\\n\\t  18 {3} {6} = 1 x 3 = 3\\n\\t  18 3 6[0]\\n\\t  18 3 6[2,3]\\n\\t  18 3 6[3,2]\\n   -> 1 + 3 + 3 = 7 \\ncache =  {18: 7, 6: 3, 3: 1, 2: 1}\\nans = sum(cache) = 12\\n```\\n\\n**Code**:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        def fsol(k, n, mod):\\n            if not h.get(k):\\n                print(k, h)\\n                ret = 1\\n                for i in range(n-1, -1, -1):\\n                    if k<=a[i]: \\n                        break\\n                    t = k // a[i]\\n                    if k%a[i]==0 and t in s:\\n                        ret = ret + fsol(a[i], n, mod) * fsol(t, n, mod)\\n                        print(\"??\", k, a[i], t, ret)\\n                        \\n                h[k] = ret%mod\\n                print(\"++\", k, h, h[k])\\n            return h[k]\\n            \\n        n, a = len(arr), sorted(arr)[::-1]\\n        s = set(a)\\n        mod = 10**9 + 7\\n        print(a)\\n        \\n        h = {}\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + fsol(a[i], n, mod))%mod\\n        \\n        print(h)\\n        print(\"=\"* 20)\\n        \\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\na = {18, 6, 3, 2}\\n2 -> {2} = 1\\n3 -> {3} = 1\\n6 -> {6} = 1\\n     {6} {2} {3} = 1 x 1  = 1\\n     {6} {3} {2} = 1 x 1 = 1\\n  -> 3\\n18 -> 18 = 1\\n      18 {6} {3} = 3 x 1 = 3\\n\\t  18 6[0] 3\\n\\t  18 6[2,3] 3\\n\\t  18 6[3,2] 3\\n\\t  18 {3} {6} = 1 x 3 = 3\\n\\t  18 3 6[0]\\n\\t  18 3 6[2,3]\\n\\t  18 3 6[3,2]\\n   -> 1 + 3 + 3 = 7 \\ncache =  {18: 7, 6: 3, 3: 1, 2: 1}\\nans = sum(cache) = 12\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        def fsol(k, n, mod):\\n            if not h.get(k):\\n                print(k, h)\\n                ret = 1\\n                for i in range(n-1, -1, -1):\\n                    if k<=a[i]: \\n                        break\\n                    t = k // a[i]\\n                    if k%a[i]==0 and t in s:\\n                        ret = ret + fsol(a[i], n, mod) * fsol(t, n, mod)\\n                        print(\"??\", k, a[i], t, ret)\\n                        \\n                h[k] = ret%mod\\n                print(\"++\", k, h, h[k])\\n            return h[k]\\n            \\n        n, a = len(arr), sorted(arr)[::-1]\\n        s = set(a)\\n        mod = 10**9 + 7\\n        print(a)\\n        \\n        h = {}\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + fsol(a[i], n, mod))%mod\\n        \\n        print(h)\\n        print(\"=\"* 20)\\n        \\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400279,
                "title": "dp-simple-tabulation-solution",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        final int n = arr.length;\\n        final long[] dp = new long[n];\\n        final int mod = 1000_000_007;\\n        final Map<Integer, Integer> numIndex = new HashMap<>();\\n        \\n        long res = 0;\\n                \\n        Arrays.sort(arr);\\n        \\n        for (int i=0; i<n; i++) {\\n            dp[i] = 1;\\n            numIndex.put(arr[i], i);\\n            for (int j=0; j<i; j++) {\\n                if (arr[i] % arr[j] == 0) {\\n                    Integer index = numIndex.get(arr[i]/arr[j]);\\n                    if (index != null) {\\n                        dp[i] = (dp[i] + (dp[index] * dp[j])%mod)%mod;\\n                    }\\n                }\\n            }\\n            res = (res + dp[i])%mod;\\n        }\\n        \\n        return (int) res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        final int n = arr.length;\\n        final long[] dp = new long[n];\\n        final int mod = 1000_000_007;\\n        final Map<Integer, Integer> numIndex = new HashMap<>();\\n        \\n        long res = 0;\\n                \\n        Arrays.sort(arr);\\n        \\n        for (int i=0; i<n; i++) {\\n            dp[i] = 1;\\n            numIndex.put(arr[i], i);\\n            for (int j=0; j<i; j++) {\\n                if (arr[i] % arr[j] == 0) {\\n                    Integer index = numIndex.get(arr[i]/arr[j]);\\n                    if (index != null) {\\n                        dp[i] = (dp[i] + (dp[index] * dp[j])%mod)%mod;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2400152,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Dp && Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // first of all sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        // declare a dp, dp[i] will store the possible binary tree till ith index\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // declare a map, {value -> index}\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the index to corresponding element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = i;\\n        }\\n        \\n        // fill the dp\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                // if we found one factor\\n                \\n                if(arr[i] % arr[j] == 0)\\n                {\\n                    // check if other corresponding factor is present in arr or not\\n                    \\n                    if(mp.count(arr[i] / arr[j]))\\n                    {\\n                        // find the index of other factor\\n                        \\n                        int idx = mp[arr[i] / arr[j]];\\n                        \\n                        // update the dp[i] \\n                        \\n                        dp[i] = (dp[i] % mod + (dp[j] % mod * dp[idx] % mod)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // at the end just sum up all the values of dp\\n        \\n        int total = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total = (total % mod + dp[i] % mod) % mod;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // first of all sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        // declare a dp, dp[i] will store the possible binary tree till ith index\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // declare a map, {value -> index}\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the index to corresponding element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = i;\\n        }\\n        \\n        // fill the dp\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                // if we found one factor\\n                \\n                if(arr[i] % arr[j] == 0)\\n                {\\n                    // check if other corresponding factor is present in arr or not\\n                    \\n                    if(mp.count(arr[i] / arr[j]))\\n                    {\\n                        // find the index of other factor\\n                        \\n                        int idx = mp[arr[i] / arr[j]];\\n                        \\n                        // update the dp[i] \\n                        \\n                        dp[i] = (dp[i] % mod + (dp[j] % mod * dp[idx] % mod)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // at the end just sum up all the values of dp\\n        \\n        int total = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total = (total % mod + dp[i] % mod) % mod;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400150,
                "title": "easy-dp-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        set<int>st;\\n        unordered_map<int,int>mp;\\n        for(int x:arr){\\n             st.insert(x);\\n            mp[x]=1;\\n        }\\n        for(auto it:st){\\n            int p=it;\\n            for(auto i:st){\\n                if(p%i==0 && st.find(p/i)!=st.end() && i!=p){\\n                    long long int prod=1;\\n                    prod=(((prod%M*mp[i]%M)%M)*mp[p/i]%M)%M;\\n                  //  if(prod!=1) prod*=2;\\n                    mp[p]=(mp[p]%M+prod%M)%M;\\n            }\\n                }\\n            \\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            ans=(ans%M+it.second%M)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if U like the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        set<int>st;\\n        unordered_map<int,int>mp;\\n        for(int x:arr){\\n             st.insert(x);\\n            mp[x]=1;\\n        }\\n        for(auto it:st){\\n            int p=it;\\n            for(auto i:st){\\n                if(p%i==0 && st.find(p/i)!=st.end() && i!=p){\\n                    long long int prod=1;\\n                    prod=(((prod%M*mp[i]%M)%M)*mp[p/i]%M)%M;\\n                  //  if(prod!=1) prod*=2;\\n                    mp[p]=(mp[p]%M+prod%M)%M;\\n            }\\n                }\\n            \\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            ans=(ans%M+it.second%M)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400134,
                "title": "c-recursive-dp-hashmap-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // dp[i] = number of binary trees with i as root\\n    const int mod = 1e9+7;\\n    \\n    // to store for each number, {a,b} such that axb = number\\n    map<int,vector<pair<int,int>>> mp;\\n    \\n    // to map values to index\\n    map<long long,int> idx;\\n    int n;\\n    \\n    int dp[1001];\\n    \\n    int rec(int val){\\n        // base case, if it cant be further extended\\n        if(mp[val].size() == 0){\\n            return 1;\\n        }\\n        if(dp[idx[val]] != -1){\\n            return dp[idx[val]];\\n        }\\n        // dont have any left or right child\\n        int ans = 1;\\n        for(auto pr:mp[val]){\\n            long long ans1 = rec(pr.first);\\n            long long ans2 = rec(pr.second);\\n            ans1*=ans2;\\n            ans1%=mod;\\n            \\n            // swap left and right\\n            if(pr.first!=pr.second)ans1*=2LL;\\n            ans1%=mod;\\n            ans+=ans1;\\n            ans%=mod;\\n        }\\n        return dp[idx[val]] = ans;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0;i<n;i++) idx[arr[i]] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                long long x = 1LL*arr[i]*arr[j];\\n                if(idx.find(x) != idx.end()){\\n                    mp[x].push_back({arr[i],arr[j]});\\n                }\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans+=rec(arr[i]);\\n            ans%=mod;\\n        }\\n      //  for(int i=0;i<n;i++) cout<<rec(arr[i])<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dp[i] = number of binary trees with i as root\\n    const int mod = 1e9+7;\\n    \\n    // to store for each number, {a,b} such that axb = number\\n    map<int,vector<pair<int,int>>> mp;\\n    \\n    // to map values to index\\n    map<long long,int> idx;\\n    int n;\\n    \\n    int dp[1001];\\n    \\n    int rec(int val){\\n        // base case, if it cant be further extended\\n        if(mp[val].size() == 0){\\n            return 1;\\n        }\\n        if(dp[idx[val]] != -1){\\n            return dp[idx[val]];\\n        }\\n        // dont have any left or right child\\n        int ans = 1;\\n        for(auto pr:mp[val]){\\n            long long ans1 = rec(pr.first);\\n            long long ans2 = rec(pr.second);\\n            ans1*=ans2;\\n            ans1%=mod;\\n            \\n            // swap left and right\\n            if(pr.first!=pr.second)ans1*=2LL;\\n            ans1%=mod;\\n            ans+=ans1;\\n            ans%=mod;\\n        }\\n        return dp[idx[val]] = ans;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0;i<n;i++) idx[arr[i]] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                long long x = 1LL*arr[i]*arr[j];\\n                if(idx.find(x) != idx.end()){\\n                    mp[x].push_back({arr[i],arr[j]});\\n                }\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans+=rec(arr[i]);\\n            ans%=mod;\\n        }\\n      //  for(int i=0;i<n;i++) cout<<rec(arr[i])<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2400127,
                "title": "c-unordered-map-o-n-2-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod = 1e9+7;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size(), ans=0;\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tunordered_map<int,long long>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[arr[i]] = 1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(arr[i]%arr[j] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] += (mp[arr[j]]*mp[arr[i]/arr[j]])%mod;\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] %= mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = (ans + mp[arr[i]])%mod;\\n\\t\\t\\t} \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mod = 1e9+7;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size(), ans=0;\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tunordered_map<int,long long>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[arr[i]] = 1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(arr[i]%arr[j] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] += (mp[arr[j]]*mp[arr[i]/arr[j]])%mod;\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] %= mod;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2400054,
                "title": "simple-c-solution",
                "content": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint numFactoredBinaryTrees(int* arr, int arrSize){\\n    int result = 0, mod = pow(10, 9) + 7;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    long dp[arrSize];\\n    for(int i = 0; i < arrSize; i++) \\n        dp[i] = 1;\\n    for(int i = 0; i < arrSize; i++) \\n    {\\n\\t\\tint left = 0, right = i - 1;\\n\\t\\twhile (left <= right) \\n        {\\n\\t\\t\\tif((long)arr[left] * arr[right] > arr[i])\\n\\t\\t\\t\\tright--;\\n\\t\\t\\telse if ((long)arr[left] * arr[right] < arr[i])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tdp[i] += (dp[left] * dp[right]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = ((result % mod) + dp[i]) % mod;   \\n\\t}\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint numFactoredBinaryTrees(int* arr, int arrSize){\\n    int result = 0, mod = pow(10, 9) + 7;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    long dp[arrSize];\\n    for(int i = 0; i < arrSize; i++) \\n        dp[i] = 1;\\n    for(int i = 0; i < arrSize; i++) \\n    {\\n\\t\\tint left = 0, right = i - 1;\\n\\t\\twhile (left <= right) \\n        {\\n\\t\\t\\tif((long)arr[left] * arr[right] > arr[i])\\n\\t\\t\\t\\tright--;\\n\\t\\t\\telse if ((long)arr[left] * arr[right] < arr[i])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tdp[i] += (dp[left] * dp[right]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = ((result % mod) + dp[i]) % mod;   \\n\\t}\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400023,
                "title": "java-hashmap-faster-than-98-27-less-than-23-70",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int result = 0;\\n        Arrays.sort(arr);\\n        int max = arr[arr.length-1];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : arr) map.put(num, 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            long count = map.get(arr[i]);\\n            result += count;\\n            if (result > 1000000007) result %= 1000000007;            \\n            \\n            for (int j = 0; j < i; j++) {\\n                long temp = (long) arr[i]*arr[j];\\n                if (temp > max) break;\\n                int product = (int) temp;\\n                if (map.containsKey(product)) {\\n                    long newVal = 2*map.get(arr[j]);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal *= count;\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal += map.get(product);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    map.put(product, (int) newVal);\\n                }\\n            }\\n            \\n            long temp = (long) arr[i]*arr[i];\\n            if (temp > max) continue;\\n            int product = (int) temp;\\n            if (map.containsKey(product)) {\\n                long newVal = count*count;\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                newVal += map.get(product);\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                map.put(product, (int) newVal);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int result = 0;\\n        Arrays.sort(arr);\\n        int max = arr[arr.length-1];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : arr) map.put(num, 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            long count = map.get(arr[i]);\\n            result += count;\\n            if (result > 1000000007) result %= 1000000007;            \\n            \\n            for (int j = 0; j < i; j++) {\\n                long temp = (long) arr[i]*arr[j];\\n                if (temp > max) break;\\n                int product = (int) temp;\\n                if (map.containsKey(product)) {\\n                    long newVal = 2*map.get(arr[j]);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal *= count;\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal += map.get(product);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    map.put(product, (int) newVal);\\n                }\\n            }\\n            \\n            long temp = (long) arr[i]*arr[i];\\n            if (temp > max) continue;\\n            int product = (int) temp;\\n            if (map.containsKey(product)) {\\n                long newVal = count*count;\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                newVal += map.get(product);\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                map.put(product, (int) newVal);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399932,
                "title": "python-100-faster-dp-solution-not-short",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        children = {num: [] for num in arr}\\n        trees = {num: 1 for num in arr}\\n        MOD = 10 ** 9 + 7\\n        \\n        for i in range(len(arr) - 1):\\n            for j in range(i, len(arr) - 1):\\n                product = arr[i] * arr[j]\\n                if product in children:\\n                    children[product].append((arr[i], arr[j]))\\n                elif product > arr[-1]:\\n                    break\\n        \\n        res = 0\\n        for num in arr:\\n            for pair in children[num]:\\n                trees[num] += (trees[pair[0]] * trees[pair[1]]\\n                               if pair[0] == pair[1]\\n                               else 2 * (trees[pair[0]] * trees[pair[1]]))\\n            trees[num] %= MOD\\n            res = (res + trees[num]) % MOD\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        children = {num: [] for num in arr}\\n        trees = {num: 1 for num in arr}\\n        MOD = 10 ** 9 + 7\\n        \\n        for i in range(len(arr) - 1):\\n            for j in range(i, len(arr) - 1):\\n                product = arr[i] * arr[j]\\n                if product in children:\\n                    children[product].append((arr[i], arr[j]))\\n                elif product > arr[-1]:\\n                    break\\n        \\n        res = 0\\n        for num in arr:\\n            for pair in children[num]:\\n                trees[num] += (trees[pair[0]] * trees[pair[1]]\\n                               if pair[0] == pair[1]\\n                               else 2 * (trees[pair[0]] * trees[pair[1]]))\\n            trees[num] %= MOD\\n            res = (res + trees[num]) % MOD\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373613,
                "title": "c-clean-solution",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        \\n        vector<int> dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            int l=0,r=i-1;\\n            while(l<=r){\\n                if(arr[l]*1LL*arr[r]==arr[i]*1LL){   \\n                    if(l!=r) dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod*2LL%mod))%mod;\\n                    else dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod))%mod;\\n                    l++,r--;\\n                } else if(arr[l]*1LL*arr[r]>arr[i]*1LL) r--;\\n                else l++;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(auto i:dp) ans=(ans+i)%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : **0(n^2)**\\nSpace Complexity : **0(n)**\\n\\nHope this helps :)\\nAny suggestions or updations are happily invited.",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        \\n        vector<int> dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            int l=0,r=i-1;\\n            while(l<=r){\\n                if(arr[l]*1LL*arr[r]==arr[i]*1LL){   \\n                    if(l!=r) dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod*2LL%mod))%mod;\\n                    else dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod))%mod;\\n                    l++,r--;\\n                } else if(arr[l]*1LL*arr[r]>arr[i]*1LL) r--;\\n                else l++;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(auto i:dp) ans=(ans+i)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180513,
                "title": "python-3-recursion-memoization-o-n-2-o-n",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def helper(num):\\n            trees = 1\\n            for factor in nums:\\n                if not num % factor and num // factor in nums:\\n                    trees += helper(factor) * helper(num // factor)\\n\\n            return trees\\n        \\n        return sum(helper(num) for num in nums) % (10 ** 9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def helper(num):\\n            trees = 1\\n            for factor in nums:\\n                if not num % factor and num // factor in nums:\\n                    trees += helper(factor) * helper(num // factor)\\n\\n            return trees\\n        \\n        return sum(helper(num) for num in nums) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2126369,
                "title": "c-easy-to-understand-commented-solution-hashmap-dp",
                "content": "Upvote if you find the code easy to understand :)\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        map<int,long long int>m;\\n        long long int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[arr[i]]=1;  //1 tree always being formed, also we don\\'t care about frequency of arr[i]\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            int root=it->first; //root of the tree\\n            for(auto it1=m.begin();it1!=it;it1++)  //iterating through all left child possibilities\\n            {\\n                if(m.find(root/it1->first)!=m.end()&&root%it1->first==0) //if and only if completely divisible\\n                {\\n                    long long int treesNumber=(it1->second*m[root/it1->first]); //left child trees*right child trees\\n                    it->second+=treesNumber;\\n                }\\n            }\\n            ans+=it->second;\\n        }\\n        return ans%1000000007;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Upvote if you find the code easy to understand :)\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        map<int,long long int>m;\\n        long long int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[arr[i]]=1;  //1 tree always being formed, also we don\\'t care about frequency of arr[i]\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            int root=it->first; //root of the tree\\n            for(auto it1=m.begin();it1!=it;it1++)  //iterating through all left child possibilities\\n            {\\n                if(m.find(root/it1->first)!=m.end()&&root%it1->first==0) //if and only if completely divisible\\n                {\\n                    long long int treesNumber=(it1->second*m[root/it1->first]); //left child trees*right child trees\\n                    it->second+=treesNumber;\\n                }\\n            }\\n            ans+=it->second;\\n        }\\n        return ans%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2121309,
                "title": "c-without-recursion-and-dp",
                "content": "# Using map to store factors\\n\\n\\n\\t\\t#define ll long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\tint mod = 1000000000+7;\\n\\t\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tunordered_map<ll,ll> m;\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\tll cnt = 1;\\n\\t\\t\\t\\t\\tfor(auto j: arr){\\n\\t\\t\\t\\t\\t\\tif(i%j==0 and m.find(j)!=m.end() and m.find(i/j)!=m.end()){\\n\\t\\t\\t\\t\\t\\t\\tcnt += m[j]%mod*m[i/j]%mod;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tm[i]=cnt%mod;\\n\\t\\t\\t\\t\\tres += cnt%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res%mod;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\tint mod = 1000000000+7;\\n\\t\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tunordered_map<ll,ll> m;\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\tll cnt = 1;\\n\\t\\t\\t\\t\\tfor(auto j: arr){\\n\\t\\t\\t\\t\\t\\tif(i%j==0 and m.find(j)!=m.end() and m.find(i/j)!=m.end()){\\n\\t\\t\\t\\t\\t\\t\\tcnt += m[j]%mod*m[i/j]%mod;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2121205,
                "title": "c-recursion-memoziation",
                "content": "\\t\\t#define ll long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tunordered_set<ll> s;\\n\\t\\t\\tunordered_map<ll,ll> t;\\n\\t\\t\\tll m = 1000000000+7;\\n\\t\\t\\tll f(int a,vector<int>& arr){\\n\\t\\t\\t\\tif(s.find(a)==s.end())return 0;\\n\\t\\t\\t\\tif(t.find(a)!=t.end())return t[a];\\n\\n\\t\\t\\t\\tll cnt=1;\\n\\t\\t\\t\\tfor(int i=0; i<arr.size(); i++){\\n\\t\\t\\t\\t\\t//cheak if arr[i] factors are present or not\\n\\t\\t\\t\\t\\tif(a%arr[i]==0 and s.find(a/arr[i])!=s.end()){\\n\\t\\t\\t\\t\\t\\t// then recursively call their factor also\\n\\t\\t\\t\\t\\t\\tcnt += (f(arr[i],arr)%m * f(a/arr[i],arr)%m)%m;\\n\\t\\t\\t\\t\\t\\t// cnt = (cnt+k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn t[a] = cnt;\\n\\t\\t\\t}\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\ts.clear();\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\ts.insert(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t//make it as root\\n\\t\\t\\t\\t\\tres += f(arr[i],arr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res%m;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tunordered_set<ll> s;\\n\\t\\t\\tunordered_map<ll,ll> t;\\n\\t\\t\\tll m = 1000000000+7;\\n\\t\\t\\tll f(int a,vector<int>& arr){\\n\\t\\t\\t\\tif(s.find(a)==s.end())return 0;\\n\\t\\t\\t\\tif(t.find(a)!=t.end())return t[a];\\n\\n\\t\\t\\t\\tll cnt=1;\\n\\t\\t\\t\\tfor(int i=0; i<arr.size(); i++){\\n\\t\\t\\t\\t\\t//cheak if arr[i] factors are present or not\\n\\t\\t\\t\\t\\tif(a%arr[i]==0 and s.find(a/arr[i])!=s.end()){\\n\\t\\t\\t\\t\\t\\t// then recursively call their factor also\\n\\t\\t\\t\\t\\t\\tcnt += (f(arr[i],arr)%m * f(a/arr[i],arr)%m)%m;\\n\\t\\t\\t\\t\\t\\t// cnt = (cnt+k);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1814561,
                "title": "wtf-is-with-the-description",
                "content": "You can have infinite trees.\\n\\nLeaves:\\n\\n2\\n2 2\\n2 2 2\\n2 2 2 2\\n2 2 2 2 2\\n...\\n\\nI hate this stupid description. How tf do people understand what this is asking?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1638396,
                "title": "using-maps-and-sqrt-break-48-ms-faster-than-86-27-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int total_count = 0;\\n        int mod = 1000000007;\\n        unordered_map<int,int> keyasroot;\\n        long long int var1, var2, temp_prod;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int factortill = pow(arr[i], 0.5);\\n            int curr_count = 1;\\n            for(int j=0;j<arr.size();j++){\\n                int num1;\\n                if(arr[j]<=factortill){\\n                    num1 = arr[j];\\n                }\\n                else{\\n                    break;\\n                }\\n                int num2 = arr[i]/num1;\\n                if(num1*num2==arr[i]){\\n                    if(num1==num2){\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                    else{\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        temp_prod = (temp_prod*2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                }\\n            }\\n            keyasroot[arr[i]] = curr_count;\\n            total_count = (total_count + curr_count)%mod;\\n        }\\n        return total_count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int total_count = 0;\\n        int mod = 1000000007;\\n        unordered_map<int,int> keyasroot;\\n        long long int var1, var2, temp_prod;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int factortill = pow(arr[i], 0.5);\\n            int curr_count = 1;\\n            for(int j=0;j<arr.size();j++){\\n                int num1;\\n                if(arr[j]<=factortill){\\n                    num1 = arr[j];\\n                }\\n                else{\\n                    break;\\n                }\\n                int num2 = arr[i]/num1;\\n                if(num1*num2==arr[i]){\\n                    if(num1==num2){\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                    else{\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        temp_prod = (temp_prod*2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                }\\n            }\\n            keyasroot[arr[i]] = curr_count;\\n            total_count = (total_count + curr_count)%mod;\\n        }\\n        return total_count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310584,
                "title": "python3-easy-dp-solution",
                "content": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        mod=10**9+7\\n        n=len(arr)\\n        dp=[1]*(n)\\n        arr_set=set(arr)\\n        for i in range(1,n):\\n            for j in range(i):\\n                if arr[i]%arr[j]==0:\\n                    temp=arr[i]//arr[j]\\n                    if temp in arr_set:\\n                        idx=arr.index(temp)\\n                        dp[i]+=dp[j]*dp[idx]\\n        return sum(dp)%mod",
                "solutionTags": [],
                "code": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        mod=10**9+7\\n        n=len(arr)\\n        dp=[1]*(n)\\n        arr_set=set(arr)\\n        for i in range(1,n):\\n            for j in range(i):\\n                if arr[i]%arr[j]==0:\\n                    temp=arr[i]//arr[j]\\n                    if temp in arr_set:\\n                        idx=arr.index(temp)\\n                        dp[i]+=dp[j]*dp[idx]\\n        return sum(dp)%mod",
                "codeTag": "Python3"
            },
            {
                "id": 1109389,
                "title": "c-12ms-100-how-about-it-new-time-record",
                "content": "I wrote that previous version can be improved and if I have free time I write it. I did it !!! and what I have : \\n![image](https://assets.leetcode.com/users/images/713b8cb1-7be2-4b54-96af-fd5721359022_1615835234.7344735.png)\\n\\n\\nRuntime: 12 ms, faster than 100.00% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 10.2 MB, less than 20.93% of C++ online submissions for Binary Trees With Factors.\\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<int> squar(n, -1);\\n    vector<vector<pair<int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)) squar[mp[squared]] = i;             \\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<pair<int,int>>;\\n          table[mp[num]]->push_back({i,j});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(squar[i] != -1) dp[i] += dp[squar[i]] * dp[squar[i]];\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[table[i]->operator[](w).first]*dp[table[i]->operator[](w).second])<<1;\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```\\n\\nOld version :\\n\\n\\n\\nRuntime: 16 ms, faster than 100.00% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 10.1 MB, less than 22.48% of C++ online submissions for Binary Trees With Factors.\\n![image](https://assets.leetcode.com/users/images/1f63d3ff-702e-43ea-a799-b0d8c51b4e08_1615735880.8892975.png)\\nOn second thought sake it can be improve !!! if I have free time - I will do it.\\nGeneral idea - just only forward !!!\\nP.s This idea is different from official .\\n\\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<vector<tuple<int,int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)){\\n        if(table[mp[squared]] == NULL)\\n          table[mp[squared]] = new vector<tuple<int,int,int>>;\\n        table[mp[squared]]->push_back({i,i,0});\\n      }\\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<tuple<int,int,int>>;\\n          table[mp[num]]->push_back({i,j,1});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[get<0>(table[i]->operator[](w))]*dp[get<1>(table[i]->operator[](w))]<<\\n                   get<2>(table[i]->operator[](w)));\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<int> squar(n, -1);\\n    vector<vector<pair<int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)) squar[mp[squared]] = i;             \\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<pair<int,int>>;\\n          table[mp[num]]->push_back({i,j});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(squar[i] != -1) dp[i] += dp[squar[i]] * dp[squar[i]];\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[table[i]->operator[](w).first]*dp[table[i]->operator[](w).second])<<1;\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<vector<tuple<int,int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)){\\n        if(table[mp[squared]] == NULL)\\n          table[mp[squared]] = new vector<tuple<int,int,int>>;\\n        table[mp[squared]]->push_back({i,i,0});\\n      }\\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<tuple<int,int,int>>;\\n          table[mp[num]]->push_back({i,j,1});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[get<0>(table[i]->operator[](w))]*dp[get<1>(table[i]->operator[](w))]<<\\n                   get<2>(table[i]->operator[](w)));\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108180,
                "title": "python-iteration-lookup-explanation-comments-diagram",
                "content": "Approach: O(N^2) runtime O(N) space - where N=len(arr)\\nIteration + Lookup\\nThe array needs to be sorted in increasing order for this method to work.\\nIterate through the array, for each array[i], we try modding with numbers to the left one by one\\nto find the factors of array[i]. For each factor, we can use valToCount map to lookup number of binary\\ntrees so we don\\'t recompute the recursion (note that there will be recursion if the factor can be broken up into more factors, so those will also be added to factors).\\n\\nDiagram example: https://drive.google.com/file/d/1vwcfst55yrYAheA8glYI-enJSCd4S3x5/view?usp=sharing\\n```py\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        #print(\"sorted input={}\".format(arr))\\n        valToCount = {} #maps arr value to number of binary trees we can make having that value as root\\n        MOD = 10**9+7\\n        result = 0\\n        #for each arr[i] we will get the count of all possible binary trees that have arr[i] as root, and then add it to valToCount map\\n        for index,val in enumerate(arr):\\n            valResult = 1 #start off with just [arr[i]], then add more for each binary tree we can make with factors\\n            #find all factors (by checking to the left of val) and multiply the count of each pair of factors to get the combination for this factor pair\\'s orientation\\n            for factorIdx in range(index-1,-1,-1):\\n                factorCandidate = arr[factorIdx]\\n                if val % factorCandidate == 0:\\n                    #this is a factor, so get the sum of the combinations for the [thisfactor,completementfactor] orientation \\n                    #(i.e. this factor will go first, and later on when we iterate to another arr[factorIdx], we will use the other factor to go first).\\n                    factor2 = val // factorCandidate\\n                    \\n                    #print(\"factorCandidate={},factor2={}\".format(factorCandidate,factor2))\\n                    #check if factor2 exists in arr\\n                    if factor2 in valToCount:\\n                        #note that we can do lookups because any value to the left is already computed in the previous iteration of our first for loop\\n                        valResult += valToCount[factorCandidate] * valToCount[factor2]\\n                        valResult %= MOD\\n            \\n            #append val to map so we can reuse without having to recursively compute the result for value again\\n            valToCount[val] = valResult\\n            result += valResult\\n            result %= MOD\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```py\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        #print(\"sorted input={}\".format(arr))\\n        valToCount = {} #maps arr value to number of binary trees we can make having that value as root\\n        MOD = 10**9+7\\n        result = 0\\n        #for each arr[i] we will get the count of all possible binary trees that have arr[i] as root, and then add it to valToCount map\\n        for index,val in enumerate(arr):\\n            valResult = 1 #start off with just [arr[i]], then add more for each binary tree we can make with factors\\n            #find all factors (by checking to the left of val) and multiply the count of each pair of factors to get the combination for this factor pair\\'s orientation\\n            for factorIdx in range(index-1,-1,-1):\\n                factorCandidate = arr[factorIdx]\\n                if val % factorCandidate == 0:\\n                    #this is a factor, so get the sum of the combinations for the [thisfactor,completementfactor] orientation \\n                    #(i.e. this factor will go first, and later on when we iterate to another arr[factorIdx], we will use the other factor to go first).\\n                    factor2 = val // factorCandidate\\n                    \\n                    #print(\"factorCandidate={},factor2={}\".format(factorCandidate,factor2))\\n                    #check if factor2 exists in arr\\n                    if factor2 in valToCount:\\n                        #note that we can do lookups because any value to the left is already computed in the previous iteration of our first for loop\\n                        valResult += valToCount[factorCandidate] * valToCount[factor2]\\n                        valResult %= MOD\\n            \\n            #append val to map so we can reuse without having to recursively compute the result for value again\\n            valToCount[val] = valResult\\n            result += valResult\\n            result %= MOD\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108099,
                "title": "javascript-dp-248ms-70",
                "content": "```\\nconst MOD = 1e9 + 7;\\nconst numFactoredBinaryTrees = (a) => {\\n    let n = a.length;\\n    let dp = new Map();\\n    a.sort((x, y) => x - y);\\n    for (let i = 0; i < n; i++) {\\n        dp.set(a[i], 1);\\n        for (let j = 0; j < i; j++) {\\n            let divide = a[i] / a[j] >> 0;\\n            let dd = dp.get(divide);\\n            let ii = dp.get(a[i]);\\n            let jj = dp.get(a[j]);\\n            if (a[i] % a[j] == 0 && dp.has(divide)) {\\n                dp.set(a[i], ii + jj * dd);\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (const [, v] of dp) res += v;\\n    return res % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst MOD = 1e9 + 7;\\nconst numFactoredBinaryTrees = (a) => {\\n    let n = a.length;\\n    let dp = new Map();\\n    a.sort((x, y) => x - y);\\n    for (let i = 0; i < n; i++) {\\n        dp.set(a[i], 1);\\n        for (let j = 0; j < i; j++) {\\n            let divide = a[i] / a[j] >> 0;\\n            let dd = dp.get(divide);\\n            let ii = dp.get(a[i]);\\n            let jj = dp.get(a[j]);\\n            if (a[i] % a[j] == 0 && dp.has(divide)) {\\n                dp.set(a[i], ii + jj * dd);\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (const [, v] of dp) res += v;\\n    return res % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1571922,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            },
            {
                "id": 1569207,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            },
            {
                "id": 1965541,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            }
        ]
    },
    {
        "title": "K-Concatenation Maximum Sum",
        "question_content": "<p>Given an integer array <code>arr</code> and an integer <code>k</code>, modify the array by repeating it <code>k</code> times.</p>\n\n<p>For example, if <code>arr = [1, 2]</code> and <code>k = 3 </code>then the modified array will be <code>[1, 2, 1, 2, 1, 2]</code>.</p>\n\n<p>Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be <code>0</code> and its sum in that case is <code>0</code>.</p>\n\n<p>As the answer can be very large, return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2], k = 3\n<strong>Output:</strong> 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,-2,1], k = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [-1,-2], k = 7\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 382350,
                "title": "java-solution-kadens-algo-with-explanation",
                "content": "Explanation:\\n The problem is to find the maximum sub array of *concatenatedarr*. \\n Maximum SubArray of an array A is a continuous SubArray within the array A that has the largest Sum. \\n The best method for finding Maximum SubArray is Kadanae\\'s algorithm.\\n \\n Here you have to find the Maximum SubArray for an array concatenated_arr which is a k-times repetitive array of A. For e.g.. if A is {3, 2, -1} and K is 3 then B will be {3, 2, -1, 3, 2, -1, 3, 2, -1}. Method:\\nThe maximum SubArray of concatenated_arr can be the sum of all its elements. \\nFor e.g.. if A is {3, 2, -1} and K is 3, then B will be {3, 2, -1, 3, 2, -1, 3, 2, -1}. \\nThe sum of all the elements in concatenated_arr will give us 12. To find this one we don\\'t need to create the array concatenated_arr. \\nWe can simply find the sum of all the elements in array A and we can mutilply it with K. \\n But wait, we can omit the last term in it so that the sum will become 13. \\nFor this one we can use prefix and suffix calculations. \\nEg:\\n A is repeated k times in *concatenatedarr*. \\nConsider the first repetition of A is A1, second is A2 and so on. So now our B array(if K=8) will be {A1, A2, A3, A4, A5, A6, A7, A8}. If you omit the first two elements in A1 and the last two elements in A8, you might also get the maxsub array.\\nSo here we can check whether it is possible to omit some initial elements in A1 and some Final elements in A8. We use prefix and suffix variables for that to calculate the sum of A1 and A10 specifically and he adds the remaining elements i.e answer = {prefix + sum_of_elements(A2) + sum_of_elements(A3) + sum_of_elements(A4) + sum_of_elements(A5) + sum_of_elements(A6) + sum_of_elements(A7) + suffix} , which in simplified form becomes {prefix + sum_of_elements(A)*(k-2) + suffix}. \\n\\n```\\n int mod  = (int) Math.pow(10,9)+7;\\n    public int kConcatenationMaxSum(int[] ar, int k) {\\n        long kadanes= kadanesAlgo(ar);\\n        if(k==1){\\n            return (int)kadanes;\\n        }\\n        long prefixSum= prefixSum(ar);\\n        long suffixSum=suffixSum(ar);\\n        long sum=0;\\n        for (int i1 : ar) {\\n            sum += i1;\\n        }\\n        if(sum>0){\\n            return (int)(Math.max(((sum*(k-2))%mod+suffixSum%mod+prefixSum%mod)%mod,kadanes%mod));\\n        }\\n        else{\\n            return (int)(Math.max((prefixSum%mod+suffixSum%mod)%mod,kadanes%mod));\\n        }\\n\\n    }\\n    public  long kadanesAlgo(int[] ar){\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=0;i<ar.length;i++){\\n            currentSum=currentSum>0?(currentSum+ar[i])%mod:ar[i];\\n            maxSum=Math.max(currentSum,maxSum);\\n        }\\n        return maxSum<0?0:maxSum%mod;\\n\\n    }\\n\\n\\n    public  long prefixSum(int[] ar){\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=0;i<ar.length;i++){\\n            currentSum= (currentSum+ar[i])%mod;\\n            maxSum=Math.max(maxSum,currentSum);\\n        }\\n        return maxSum;\\n\\n\\n    }\\n\\n    public  long suffixSum(int[] ar){\\n\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=ar.length-1;i>=0;i--){\\n            currentSum=(currentSum+ar[i])%mod;\\n            maxSum=Math.max(currentSum,maxSum);\\n        }\\n        return maxSum;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int mod  = (int) Math.pow(10,9)+7;\\n    public int kConcatenationMaxSum(int[] ar, int k) {\\n        long kadanes= kadanesAlgo(ar);\\n        if(k==1){\\n            return (int)kadanes;\\n        }\\n        long prefixSum= prefixSum(ar);\\n        long suffixSum=suffixSum(ar);\\n        long sum=0;\\n        for (int i1 : ar) {\\n            sum += i1;\\n        }\\n        if(sum>0){\\n            return (int)(Math.max(((sum*(k-2))%mod+suffixSum%mod+prefixSum%mod)%mod,kadanes%mod));\\n        }\\n        else{\\n            return (int)(Math.max((prefixSum%mod+suffixSum%mod)%mod,kadanes%mod));\\n        }\\n\\n    }\\n    public  long kadanesAlgo(int[] ar){\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=0;i<ar.length;i++){\\n            currentSum=currentSum>0?(currentSum+ar[i])%mod:ar[i];\\n            maxSum=Math.max(currentSum,maxSum);\\n        }\\n        return maxSum<0?0:maxSum%mod;\\n\\n    }\\n\\n\\n    public  long prefixSum(int[] ar){\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=0;i<ar.length;i++){\\n            currentSum= (currentSum+ar[i])%mod;\\n            maxSum=Math.max(maxSum,currentSum);\\n        }\\n        return maxSum;\\n\\n\\n    }\\n\\n    public  long suffixSum(int[] ar){\\n\\n\\n        long currentSum=0;\\n        long maxSum=Integer.MIN_VALUE;\\n        for(int i=ar.length-1;i>=0;i--){\\n            currentSum=(currentSum+ar[i])%mod;\\n            maxSum=Math.max(currentSum,maxSum);\\n        }\\n        return maxSum;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382885,
                "title": "short-and-concise-o-n-c-solution",
                "content": "We only need to consider  `k = 1` and `k = 2` then it becomes a classic DP problem - Maximum Subarray Sum.\\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n    int n = arr.size(), sum = arr[0], mx = arr[0];\\n    int64_t total = accumulate(arr.begin(), arr.end(), 0), mod = 1e9+7;\\n    for (int i = 1; i < n * min(k, 2); i++) {\\n        sum = max(arr[i % n], sum + arr[i % n]);\\n        mx = max(mx, sum);\\n    }\\n    return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n    int n = arr.size(), sum = arr[0], mx = arr[0];\\n    int64_t total = accumulate(arr.begin(), arr.end(), 0), mod = 1e9+7;\\n    for (int i = 1; i < n * min(k, 2); i++) {\\n        sum = max(arr[i % n], sum + arr[i % n]);\\n        mx = max(mx, sum);\\n    }\\n    return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382808,
                "title": "python3-6-liner-kadane",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int, mod = 10 ** 9 + 7) -> int:\\n        def Kadane(arr, res = 0, cur = 0):\\n            for num in arr:\\n                cur = max(num, num + cur)\\n                res = max(res, cur)\\n            return res\\n        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) % mod if k > 1 else Kadane(arr) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int, mod = 10 ** 9 + 7) -> int:\\n        def Kadane(arr, res = 0, cur = 0):\\n            for num in arr:\\n                cur = max(num, num + cur)\\n                res = max(res, cur)\\n            return res\\n        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) % mod if k > 1 else Kadane(arr) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404814,
                "title": "c-5-lines",
                "content": "- Find the maximum subbaray sum `m_sum` for 2-concatenated array (note the special case when `k == 1`).\\n- If the sum of the entire array is positive, add it `k - 2` times.\\n\\n> Note that If the sum of the entire array is positive, `m_sum` will always span across two arrays.\\n\\n```\\nint kConcatenationMaxSum(vector<int>& a, int k) {\\n    int m_sum = 0, sz = a.size();\\n    for (auto i = 0, sum = 0; i < min(2, k) * sz; ++i) {\\n        sum = max(sum + a[i % sz], a[i % sz]);\\n        m_sum = max(m_sum, sum);\\n    }\\n    return ((long long)m_sum + \\n        max(0ll, accumulate(begin(a), end(a), 0ll) * max(0, k - 2))) % 1000000007;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint kConcatenationMaxSum(vector<int>& a, int k) {\\n    int m_sum = 0, sz = a.size();\\n    for (auto i = 0, sum = 0; i < min(2, k) * sz; ++i) {\\n        sum = max(sum + a[i % sz], a[i % sz]);\\n        m_sum = max(m_sum, sum);\\n    }\\n    return ((long long)m_sum + \\n        max(0ll, accumulate(begin(a), end(a), 0ll) * max(0, k - 2))) % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383302,
                "title": "c-clean-code-beat-97-with-detailed-explanation",
                "content": "**introduce some pattern firstly,**\\n```\\n1. all positive : [1,2,3], k = 3, array_sum = 6\\n    return array_sum*3\\n```\\n```\\n2. all negative : [-1,-2], k = 2, array_sum = -3\\n    return 0\\n```\\n```\\n3. hybrid, with array_sum <= 0, [2,1,-3], k = 4, array_sum = 0\\n       [ 2,  1, -3, 2, 1, -3, 2, 1, -3, 2, 1, -3]\\nmax sum  2   3  0   2  3  0   2  3   0   2  3  0\\n\\treturn max_subarray_sum between [2,1,-3,2,1,-3] which is twice of original array\\n\\tso, return max_subarray_sum = 3\\n```\\n```\\n4. hybrid, with array_sum > 0, [2,-6,5], k =4, array_sum = 1\\n       [ 2, -6, 5, 2, -6, 5, 2, -6, 5, 2, -6, 5]\\nmax sum  2   0  5  7   1  6  8   2  7  9   3  8\\na. you can notice max subarray sum is getting bigger as k grows up.\\nb. with first 2 array, we can get max subarray sum is 8.\\nc. after that, with each new array, max_subarray_sum will increase by 1, which is array_sum\\n==>return (max_subarray_sum when k=2) + array_sum*(k-2)\\n```\\n\\n# formula : \\n`return ((max_subarray_sum when k = 2) + (array_sum>0?array_sum*(k-2):0))%1000000007`\\n\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\t    /* get array sum */\\n        long long array_sum = accumulate(arr.begin(),arr.end(),0);\\n\\t\\t\\n\\t\\t/* generate two times arr */\\n        vector<int> arr_cascade(arr.begin(),arr.end());\\n        arr_cascade.insert(arr_cascade.begin(),arr.begin(),arr.end());\\n        long long max_subarray_sum = 0, tmp_sum = 0;\\n\\t\\t\\n\\t\\t/* calculate max_subarray_sum */\\n        for(int i = 0 ; i < arr_cascade.size() ; i++){\\n            tmp_sum = max(tmp_sum+(long long)arr_cascade[i],(long long)arr_cascade[i]);\\n            max_subarray_sum = max(max_subarray_sum,tmp_sum);\\n        }\\n        return (max_subarray_sum+(array_sum>0?array_sum*(k-2):0))%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. all positive : [1,2,3], k = 3, array_sum = 6\\n    return array_sum*3\\n```\n```\\n2. all negative : [-1,-2], k = 2, array_sum = -3\\n    return 0\\n```\n```\\n3. hybrid, with array_sum <= 0, [2,1,-3], k = 4, array_sum = 0\\n       [ 2,  1, -3, 2, 1, -3, 2, 1, -3, 2, 1, -3]\\nmax sum  2   3  0   2  3  0   2  3   0   2  3  0\\n\\treturn max_subarray_sum between [2,1,-3,2,1,-3] which is twice of original array\\n\\tso, return max_subarray_sum = 3\\n```\n```\\n4. hybrid, with array_sum > 0, [2,-6,5], k =4, array_sum = 1\\n       [ 2, -6, 5, 2, -6, 5, 2, -6, 5, 2, -6, 5]\\nmax sum  2   0  5  7   1  6  8   2  7  9   3  8\\na. you can notice max subarray sum is getting bigger as k grows up.\\nb. with first 2 array, we can get max subarray sum is 8.\\nc. after that, with each new array, max_subarray_sum will increase by 1, which is array_sum\\n==>return (max_subarray_sum when k=2) + array_sum*(k-2)\\n```\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\t    /* get array sum */\\n        long long array_sum = accumulate(arr.begin(),arr.end(),0);\\n\\t\\t\\n\\t\\t/* generate two times arr */\\n        vector<int> arr_cascade(arr.begin(),arr.end());\\n        arr_cascade.insert(arr_cascade.begin(),arr.begin(),arr.end());\\n        long long max_subarray_sum = 0, tmp_sum = 0;\\n\\t\\t\\n\\t\\t/* calculate max_subarray_sum */\\n        for(int i = 0 ; i < arr_cascade.size() ; i++){\\n            tmp_sum = max(tmp_sum+(long long)arr_cascade[i],(long long)arr_cascade[i]);\\n            max_subarray_sum = max(max_subarray_sum,tmp_sum);\\n        }\\n        return (max_subarray_sum+(array_sum>0?array_sum*(k-2):0))%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573666,
                "title": "a-short-and-sweet-python-solution-with-a-not-so-short-and-not-so-sweet-explanation",
                "content": "```python\\nfrom math import inf as oo\\n\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        total = sum(arr)\\n        kadanes = self.maxSubArraySum(arr)\\n        if (k < 2): return kadanes%(10**9+7)\\n        if (total > 0): return (kadanes + (k-1)*total)%(10**9+7)\\n        stitchedKadanes = self.maxSubArraySum(arr*2)\\n        return stitchedKadanes%(10**9+7)\\n    \\n    \\n    def maxSubArraySum(self, a):\\n        size = len(a)\\n        max_so_far = -oo\\n        max_ending_here = 0\\n        \\n        for i in a:\\n            max_ending_here += i\\n            if max_ending_here < 0: max_ending_here=0\\n            max_so_far = max(max_so_far, max_ending_here)\\n\\n        return max_so_far\\n```\\n\\nOk here we go, the first thing to note is Kadane\\'s Algorithm. I literally yoinked it from ***.org. It\\'s a pretty easy to memorize algorithm that is useful here because it can find a maximum sum of a contiguous subarray. That\\'s the entire point of this problem. Now, if we didn\\'t have memory contraints, we could have done this: `return max(0, self.maxSubArraySum(arr*k)`, which would copy the array k times, and send it over to Kadane\\'s algorithm to find the largest subarray sum in `n*k` time. However `n <= 10**5` and `k <= 10**5`, so `n*k == 10**10` number of elements are way too many elements to store. Even if these were simply ints you would need at least 38GB of *free* RAM to store that many elements. The second option is to just modify kadane\\'s with a little bit of modular arithmetic:\\n```python\\ndef kConcatenationMaxSum(self, a: List[int], k: int) -> int:\\n    size = len(a)\\n    max_so_far = -oo\\n    max_ending_here = 0\\n\\n    for i in range(size*k): \\n        max_ending_here += a[i%size]\\n        if max_ending_here < 0: max_ending_here=0\\n        max_so_far = max(max_so_far, max_ending_here)\\n    return max_so_far\\n```\\n\\nBut now we get to discuss runtime complexity. Again, this algorithm runs in `n*k` time, so that can be as long as `10**10`. If you want, try running this on your own:\\n\\n```python\\nfrom time import time as t\\nfrom math import inf as oo\\n\\n\\ndef kConcatenationMaxSum(a, k):\\n    size = len(a)\\n    max_so_far = -oo\\n    max_ending_here = 0\\n\\n    for i in range(size*k): \\n        max_ending_here += a[i%size]\\n        if max_ending_here < 0: max_ending_here=0\\n        max_so_far = max(max_so_far, max_ending_here)\\n    return max_so_far\\n\\n\\nl = list(range(10**5))\\nfor i in range(6):\\n    num = 10**i\\n    start = t()\\n    kConcatenationMaxSum(l, num)\\n    print(t()-start)\\n```\\n\\nGiven a list of `10**5` elements, it\\'ll run `kConcatenationMaxSum` it\\'ll do a for looping testing k = 10\\\\*\\\\*0, 10\\\\*\\\\*1, 10\\\\*\\\\*2, 10\\\\*\\\\*3, 10\\\\*\\\\*4, and 10\\\\*\\\\*5, and print the time it took to run, if you\\'re patient enough to wait that is. Regardless though, I don\\'t think LeetCode will give you enough time and we can do better anyway.\\n\\nSo let\\'s start with the case where `k=1`\\nWhen k = 1, we don\\'t have to do any copying, so we know that the sum Kadane\\'s returns will be our maximum sum.\\n\\nLet\\'s move on to all the other cases where `k >= 2`.\\n\\nWe have two more cases, first: `total > 0`\\n`total` in this case is the sum of the entire input array. For this case, where `total > 0`, let\\'s look at this example:\\n```python\\narr = [-1,-2,8,12,3,9,-2,-1]\\nk = 2\\n```\\nThe sum of `arr` is 26. So `total = 26 > 0`.\\nLet\\'s find our kadane\\'s array: `kadanesArr = [8,12,3,9]`. Note that `kadanesSum = sum(kadanesArr) = 32\\nNow let\\'s extend copy our array so that it matches `k`:\\n```python\\narrK2 = [-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1]\\n```\\nNow let\\'s find our kadane\\'s array here: `[8,12,3,9,-2,-1,-1,-2,8,12,3,9]`\\nLet\\'s break that into two arrays: `subArr1 = [8,12,3,9]` and `subArr2 = [-2,-1,-1,-2,8,12,3,9]`\\nFinally, let\\'s rearrange `subArr2`: `[-1,-2,8,12,3,9,-2,-1]` Notice that now `arr == subArr2`! Which means `sum(subArr2) == sum(arr)`. Also, notice that `subArr1 == kadanesArr`.\\nSo if we put all that together, that means *every element between our first kadane\\'s array and our last kadane\\'s array on the kth array copy will increase our sum*. So in this case, every element from our **first** 8 to our **last** 9 is useful, let\\'s pretend k is 3 instead of 2 and extend our array one last time to drive home the point:\\n```python\\narrK3 = [-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1]\\n```\\nIf we use our logic we\\'ve uncovered, then every element from our first 8 at position 2, to our last 9 at position 22 is useful, and the sum of this subarray from position 2 through 22 then is 84. Let\\'s break out our subarray from position 8 to position 22 into 3 sub arrays:\\n```python\\nsubarrA = [8,12,3,9]\\nsubarrB = [-2,-1,-1,-2,8,12,3,9]\\nsubarrC = [-2,-1,-1,-2,8,12,3,9]\\n```\\nAgain, notice `sum(subarrA) == kadanesSum`, and `sum(subarrB) == sum(subarrC) == sum(arr) == total`. so in this case then, `sum(subarrA) + sum(subarrB) + sum(subarrC) == kadanesSum + total + total == kadanesSum + 2*total == kadanesSum + (k-1)*total == 84`. Perfect!\\n\\nFinally, the last case: `total <= 0`\\nThere\\'s an observation to be made here, Let\\'s look at an example which I will purposefully obfuscate numbers:\\n```python\\narrTotNotPositive = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\nnewK = 3\\n```\\nLet\\'s say our kadane\\'s array is: `greekKadanesArr = [\\u03B4,\\u03B5]`\\nand our `greekKadanesSum = \\u03A3`\\nLet\\'s say that `sum(arrTotNotPositive) == greekTotal == 0`\\nThen we know that if we tried: `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]` we\\'d simply get `\\u03A3`, because `greekKadanesSum + greekTotal == \\u03A3 + 0 == \\u03A3`. So what if we tried only a piece of the second array instead? `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3,\\u03B4]` Notice here that it\\'s still just `arrTotNotPositive + [\\u03B4]`, so the sum is `\\u03A3 + \\u03B4`.  However, I can guarantee that this is less than `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]`, why? Because `sum([\\u03B4,\\u03B5])` is guaranteed to be the largest subarray sum by kadanes, so therefore, `\\u03B4 + \\u03B5 > \\u03B4` or else kadanes would not have included `\\u03B5`. Therefore, `\\u03A3 + \\u03B4 + \\u03B5 > \\u03A3 + \\u03B4`. So moving on, let\\'s drop one more, `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3]`, this is just `arrTotNotPositive` so therefore this total is just `greekTotal == 0`. Again, let\\'s drop one more, `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2]`. Finally, we\\'re somewhere interesting. Because this is `greekKadanesSum + sum([\\u03B1,\\u03B2])`. We don\\'t know if `sum([\\u03B1,\\u03B2])` is positive or not. But we can find out real easily, by making a copy of k, and sending through kadane\\'s, by calling `stitchedKadanes = maxSubArraySum([\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5])`. If `stitchedKadanes != kadanes`, it obviously means that either `greekKadanesSum + sum([\\u03B1,\\u03B2]) > greekKadanesSum` or `greekKadanesSum + \\u03B1 > greekKadanesSum`, since we\\'ve covered all the other cases. Let\\'s just choose one to work with for this example, `stitchedKadanes = greekKadanesSum + sum([\\u03B1,\\u03B2])`. Here, let\\'s remember that `newK = 3`, however let\\'s remember that `greekTotal == 0` as well, so let\\'s look at our `arrTotNotPositive` after 3 copies:\\n```python\\narrTotNotPositiveK3 = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\n```\\nSo if we ran Kadane\\'s on `arrTotNotPositiveK3`, we\\'d get this:\\n```python\\ngreekK3 = [\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2]\\n```\\nLet\\'s break `greekK3` into subarrays again. \\n```python\\nsubGreekA = [\\u03B4,\\u03B5] => \\u03A3\\nsubGreekB = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5] => 0\\nsubGreekC = [\\u03B1,\\u03B2] => sum([\\u03B1,\\u03B2])\\n```\\nNotice the sum total, it\\'s `\\u03A3 + 0 + sum([\\u03B1,\\u03B2]) == \\u03A3 + sum([\\u03B1,\\u03B2]) == stitchedKadanes`. Therefore, no matter what `newK` is, for how many times we copy `arrTotNotPositive`, it will always just be `stitchedKadanes + 0*(newK-1)`.\\nLet\\'s keep using this example:\\n```python\\narrTotNotPositive = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\nnewK = 3\\n```\\nand these stay the same:\\nkadane\\'s array is: `greekKadanesArr = [\\u03B4,\\u03B5]`\\nand `greekKadanesSum = \\u03A3`\\nbut now,\\nLet\\'s say that `sum(arrTotNotPositive) == greekNegTotal < 0`\\nSo let\\'s first start by trying to add one whole copy to our greekKadanesArr again: `[\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]` Then we know this is `\\u03A3 + greekNegTotal < \\u03A3` because `greekNegTotal < 0`. Let\\'s try dropping one again resulting in : `sum([\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3,\\u03B4]) == sum([\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3] + [\\u03B4]) == sum([\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5] + [\\u03B4]) == greekNegTotal + \\u03B4`. Once again, `greekNegTotal + \\u03B4 < greekNegTotal + \\u03B4 + \\u03B5`, because we know that `\\u03B4 < \\u03B4 + \\u03B5`. Drop one more, `sum([\\u03B4,\\u03B5] + [\\u03B1,\\u03B2,\\u03B3])` and we just get `greekNegTotal` which is obviously less than `\\u03A3` because Kadane\\'s only returns subarray sums >= 0 (at least the way this one is written). One more time, `sum([\\u03B4,\\u03B5] + [\\u03B1,\\u03B2])`, and notice that we can determine if this is larger than `\\u03A3` with `stitchedKadanes = maxSubArraySum([\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5])`. We\\'ll pretend again that this returned `[\\u03B4,\\u03B5,\\u03B1,\\u03B2]`. Now let\\'s look at `newK = 3` again. Here\\'s a reminder of `arrTotNotPositiveK3`\\n```python\\narrTotNotPositiveK3 = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\n```\\nLet\\'s break down this array directly:\\n```python\\ngarbage = [\\u03B1,\\u03B2,\\u03B3]\\nsubK3A = [\\u03B4,\\u03B5,\\u03B1,\\u03B2] => stitchedKadanes\\nsubK3B = [\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2] => greekNegTotal\\nsubK3C = [\\u03B3,\\u03B4,\\u03B5] => The rest of the array\\n```\\nWe\\'re ignoring `garbage` because its part of our very first copy of our `arrTotNotPositive`, since we performed Kadane\\'s on the very first copy, we know that adding any more elements from `garbage` to kadane\\'s is only going to make lower the sum of our normal kadane\\'s. Following is `subK3A`, which is just the subarray that `stitchedKadanes` returned, so we know this is the subarray that creates the maximum subarray. Next, we have `subK3B`, Notice that it\\'s just a repeat of our entire array again, so it\\'s sum is `greekNegTotal`, and since that is less than zero, we don\\'t want to add it to our `stitchedKadanes` sum because it\\'s just going to drop the sum of our stitched kadane\\'s. Since we don\\'t add it, we can\\'t reach `subK3C` because we would no longer be contiguous. Meaning any copy of our input array past this point isn\\'t going to be touched either. Therefore, if `total <= 0`, the observation to be made is that *you will never need more than two copies of the input array*. With that knowledge, you can apply Kadane\\'s to the array because it\\'s bounded by `2n`.\\n\\nLet me know if this helps you. I\\'m trying to get better at my explanations, so feel free to leave a comment with your constructive criticism.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom math import inf as oo\\n\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        total = sum(arr)\\n        kadanes = self.maxSubArraySum(arr)\\n        if (k < 2): return kadanes%(10**9+7)\\n        if (total > 0): return (kadanes + (k-1)*total)%(10**9+7)\\n        stitchedKadanes = self.maxSubArraySum(arr*2)\\n        return stitchedKadanes%(10**9+7)\\n    \\n    \\n    def maxSubArraySum(self, a):\\n        size = len(a)\\n        max_so_far = -oo\\n        max_ending_here = 0\\n        \\n        for i in a:\\n            max_ending_here += i\\n            if max_ending_here < 0: max_ending_here=0\\n            max_so_far = max(max_so_far, max_ending_here)\\n\\n        return max_so_far\\n```\n```python\\ndef kConcatenationMaxSum(self, a: List[int], k: int) -> int:\\n    size = len(a)\\n    max_so_far = -oo\\n    max_ending_here = 0\\n\\n    for i in range(size*k): \\n        max_ending_here += a[i%size]\\n        if max_ending_here < 0: max_ending_here=0\\n        max_so_far = max(max_so_far, max_ending_here)\\n    return max_so_far\\n```\n```python\\nfrom time import time as t\\nfrom math import inf as oo\\n\\n\\ndef kConcatenationMaxSum(a, k):\\n    size = len(a)\\n    max_so_far = -oo\\n    max_ending_here = 0\\n\\n    for i in range(size*k): \\n        max_ending_here += a[i%size]\\n        if max_ending_here < 0: max_ending_here=0\\n        max_so_far = max(max_so_far, max_ending_here)\\n    return max_so_far\\n\\n\\nl = list(range(10**5))\\nfor i in range(6):\\n    num = 10**i\\n    start = t()\\n    kConcatenationMaxSum(l, num)\\n    print(t()-start)\\n```\n```python\\narr = [-1,-2,8,12,3,9,-2,-1]\\nk = 2\\n```\n```python\\narrK2 = [-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1]\\n```\n```python\\narrK3 = [-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1,-1,-2,8,12,3,9,-2,-1]\\n```\n```python\\nsubarrA = [8,12,3,9]\\nsubarrB = [-2,-1,-1,-2,8,12,3,9]\\nsubarrC = [-2,-1,-1,-2,8,12,3,9]\\n```\n```python\\narrTotNotPositive = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\nnewK = 3\\n```\n```python\\narrTotNotPositiveK3 = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\n```\n```python\\ngreekK3 = [\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2]\\n```\n```python\\nsubGreekA = [\\u03B4,\\u03B5] => \\u03A3\\nsubGreekB = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5] => 0\\nsubGreekC = [\\u03B1,\\u03B2] => sum([\\u03B1,\\u03B2])\\n```\n```python\\narrTotNotPositive = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\nnewK = 3\\n```\n```python\\narrTotNotPositiveK3 = [\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2,\\u03B3,\\u03B4,\\u03B5]\\n```\n```python\\ngarbage = [\\u03B1,\\u03B2,\\u03B3]\\nsubK3A = [\\u03B4,\\u03B5,\\u03B1,\\u03B2] => stitchedKadanes\\nsubK3B = [\\u03B3,\\u03B4,\\u03B5,\\u03B1,\\u03B2] => greekNegTotal\\nsubK3C = [\\u03B3,\\u03B4,\\u03B5] => The rest of the array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106043,
                "title": "c-solution-using-kadane-s-algo",
                "content": "```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tlong long ans=0,curr=0,last;\\n\\t// Apply kadane\\'s algo by traversing over the array two times to know the pattern\\n\\t// If at the end of second traversal, if sum (curr variable is storing the sum) is greater than what we get from 1st travresal then this means that (k-2) arrays when concatenated will always increase our sum\\n\\t// else our answer will be from first 2 arrays or traversal\\n\\tfor(int i=1;i<=k && i<=2;i++){\\n\\t\\tlast=curr;  // storing sum of 1st traversal\\n\\t\\tfor(auto ele:arr){\\n\\t\\t\\tcurr=curr+ele;\\n\\t\\t\\tif(curr<ele){\\n\\t\\t\\t\\tcurr=ele;\\n\\t\\t\\t}\\n\\t\\t\\tans=(max(ans,curr))%1000000007;\\n\\t\\t\\tcurr%=1000000007;\\n\\t\\t}\\n\\t}\\n\\t// let the sums we got after 1st and 2nd traversal are 5 and 10 respectively.\\n\\t// Here, there is increase of 5 in sum(10-5=5). So when the remaining k-2 arrays are concatenated, the increase in sum will (k-2)*5\\n\\tif(curr-last>0 && k>1){\\n\\t\\tans=(ans+((curr-last)*(k-2))%1000000007)%1000000007;\\n\\t}\\n\\treturn ans;\\n}\\n// Hit Upvote if you like... :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tlong long ans=0,curr=0,last;\\n\\t// Apply kadane\\'s algo by traversing over the array two times to know the pattern\\n\\t// If at the end of second traversal, if sum (curr variable is storing the sum) is greater than what we get from 1st travresal then this means that (k-2) arrays when concatenated will always increase our sum\\n\\t// else our answer will be from first 2 arrays or traversal\\n\\tfor(int i=1;i<=k && i<=2;i++){\\n\\t\\tlast=curr;  // storing sum of 1st traversal\\n\\t\\tfor(auto ele:arr){\\n\\t\\t\\tcurr=curr+ele;\\n\\t\\t\\tif(curr<ele){\\n\\t\\t\\t\\tcurr=ele;\\n\\t\\t\\t}\\n\\t\\t\\tans=(max(ans,curr))%1000000007;\\n\\t\\t\\tcurr%=1000000007;\\n\\t\\t}\\n\\t}\\n\\t// let the sums we got after 1st and 2nd traversal are 5 and 10 respectively.\\n\\t// Here, there is increase of 5 in sum(10-5=5). So when the remaining k-2 arrays are concatenated, the increase in sum will (k-2)*5\\n\\tif(curr-last>0 && k>1){\\n\\t\\tans=(ans+((curr-last)*(k-2))%1000000007)%1000000007;\\n\\t}\\n\\treturn ans;\\n}\\n// Hit Upvote if you like... :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466304,
                "title": "java-8-line-solution-kadane-s-with-explanation",
                "content": "Thanks @votrubac for inspiring me.\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1577780621.png)\\nFirst of all, you need to know what is [Kadane\\'s Algorithm](https://hackernoon.com/kadanes-algorithm-explained-50316f4fd8a6) to solve [\"the largest subarray sum\"](https://en.wikipedia.org/wiki/Maximum_subarray_problem). It\\'s a very elegant solution using dynamic programming. We can easily get `maxSoFar` by `maxOfEnd[i]` which represent the largest sum of subarray(s) ended by `arr[i]`. With the example above, the result is `55 + 66 = 121`.\\n```java\\nint largestSubarraySum(int[] arr) {\\n\\tint maxOfEnd, maxSoFar;\\n\\tmaxSoFar = maxOfEnd = arr[0] > 0 ? arr[0] : 0;\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tmaxOfEnd = Math.max(maxOfEnd + arr[i], arr[i]);\\n\\t\\tmaxSoFar = Math.max(maxOfEnd, maxSoFar);\\n\\t}\\n\\treturn maxSoFar;\\n}\\n```\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1577781579.png)\\nWhen it comes to concatenated arrays, the definition of general subarray has changed because of the subarray can go through the \"bound\". But if we bound subarray by `arr.length`, problem becomes another one with `arr`: number of the subarrays are doubled and all the subarrays consist of two types.\\n* **Type 1: Formal**, sum of `formal_subarray(i, j)` is:\\n`arr[i] + arr[i+1] + ... + arr[j]`, where `0 <= i <= j < arr.length`\\n* **Type 2: Non-formal**, sum of `nonformal_subarray(i, j)` is\\n`arr[0] + arr[1] + ... + arr[i] + arr[j] + arr[j+1] + ... + arr[arr.lengh-1]`, where `0 <= i <= j < arr.length`\\n\\nAfter calculate the \"largest subarray sum\" by concatenate two array, we have almost reached the goal.\\n```java\\nint largestSubarraySum(int[] arr) {\\n\\tint maxOfEnd, maxSoFar, len = arr.length;\\n\\tmaxSoFar = maxOfEnd = arr[0] > 0 ? arr[0] : 0;\\n\\tfor (int i = 1; i < len * 2; i++) {\\n\\t\\tmaxOfEnd = Math.max(maxOfEnd + arr[i % len], arr[i % len]);\\n\\t\\tmaxSoFar = Math.max(maxOfEnd, maxSoFar);\\n\\t}\\n\\treturn maxSoFar;\\n}\\n```\\nLet\\'s go to the final part. Above algorithm exactly gives `maxSoFar = 185` (Pic iii, the RED region). It\\'s neither **Formal** one nor **Non-formal** one. So what\\'s this?\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1577809682.png)\\nIf we divide it into two parts: BLUE and GREEN, then we can see more about it. It\\'s just a **Formal** subarray (BLUE region) plus a whole array sum (GREEN region). `[55, 66]` is the largest among **Formal** and **Non-formal** ones, but it can still be larger when extended by an array length if `sum(arr)` is **positive**. When `k` grows up, the maximum sequence grows up as well. So here is the answer. Take care if `k == 1`.\\n```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if (arr == null || arr.length == 0) return 0;\\n        long maxOfEnd = arr[0] > 0 ? arr[0] : 0L, maxSoFar = maxOfEnd, sum = arr[0];\\n        for (int i = 1; i < Math.min(k, 2) * arr.length; i++) {\\n            maxOfEnd = Math.max(maxOfEnd + arr[i % arr.length], arr[i % arr.length]);\\n            maxSoFar = Math.max(maxOfEnd, maxSoFar);\\n            if (i < arr.length) sum += arr[i];\\n        }\\n        while (sum > 0 && --k >= 2)\\n\\t\\t\\tmaxSoFar = (maxSoFar + sum) % 1000000007;\\n        return (int) maxSoFar;\\n    }\\n}\\n```\\n**UPDATE**:\\nWe declare the summary of `arr` as `sum(arr)` and concatenated array of repeating `arr` `k` times as `carr(k)` (`k >= 2`), then any subarray in  `carr(k)` can be written as the following formats.\\n* `formal(i, j) + carr(n)`, where `n = 0, 1, 2, ..., k - 1` and `0 <= i <= j <= len(arr) - 1`\\n* `nonformal(i, j) + carr(m)`, where `m = 0, 1, 2, ..., k - 2` and `0 <= i <= j <= len(arr) - 1`\\n\\nObviously, when `sum(arr) <= 0`, any subarray(s) whose length greater than `len(arr)` won\\'t produce a larger sum compare to **Formal**/**Non-formal** ones.\\nFurthermore, when `sum(arr) > 0`:\\n* sum of `formal(i, j) + carr(n)` is `sum(formal(i, j)) + sum(arr) + r * sum(arr)`\\n* sum of `nonformal(i, j) + carr(m)` is `sum(nonformal(i, j)) + r * sum(arr)`\\n\\nNow, `r` ranges from `0` to `k - 2`. That\\'s why two concatenated arrays is the key to the answer. The second example of (iv) shows two largest cases each result from a **Formal** one (plus an `arr`) and a **Non-formal** one.\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1577938646.png)\\n",
                "solutionTags": [],
                "code": "```java\\nint largestSubarraySum(int[] arr) {\\n\\tint maxOfEnd, maxSoFar;\\n\\tmaxSoFar = maxOfEnd = arr[0] > 0 ? arr[0] : 0;\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tmaxOfEnd = Math.max(maxOfEnd + arr[i], arr[i]);\\n\\t\\tmaxSoFar = Math.max(maxOfEnd, maxSoFar);\\n\\t}\\n\\treturn maxSoFar;\\n}\\n```\n```java\\nint largestSubarraySum(int[] arr) {\\n\\tint maxOfEnd, maxSoFar, len = arr.length;\\n\\tmaxSoFar = maxOfEnd = arr[0] > 0 ? arr[0] : 0;\\n\\tfor (int i = 1; i < len * 2; i++) {\\n\\t\\tmaxOfEnd = Math.max(maxOfEnd + arr[i % len], arr[i % len]);\\n\\t\\tmaxSoFar = Math.max(maxOfEnd, maxSoFar);\\n\\t}\\n\\treturn maxSoFar;\\n}\\n```\n```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if (arr == null || arr.length == 0) return 0;\\n        long maxOfEnd = arr[0] > 0 ? arr[0] : 0L, maxSoFar = maxOfEnd, sum = arr[0];\\n        for (int i = 1; i < Math.min(k, 2) * arr.length; i++) {\\n            maxOfEnd = Math.max(maxOfEnd + arr[i % arr.length], arr[i % arr.length]);\\n            maxSoFar = Math.max(maxOfEnd, maxSoFar);\\n            if (i < arr.length) sum += arr[i];\\n        }\\n        while (sum > 0 && --k >= 2)\\n\\t\\t\\tmaxSoFar = (maxSoFar + sum) % 1000000007;\\n        return (int) maxSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382365,
                "title": "simple-python-solution",
                "content": "```\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        def max_sum(lst):\\n            n = len(lst)\\n            max_ending_here, max_so_far = lst[0], lst[0]\\n            for x in lst[1:]:\\n                max_ending_here = max(max_ending_here + x, x)\\n                max_so_far = max(max_so_far, max_ending_here)\\n            return max_so_far\\n        \\n        if not arr:\\n            return 0\\n        s = sum(arr)\\n        if k == 1:\\n            return max(0, max_sum(arr)) % (10 ** 9 + 7)\\n        else:\\n            return max(0, (k - 2) * max(s, 0) + max_sum(arr + arr)) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        def max_sum(lst):\\n            n = len(lst)\\n            max_ending_here, max_so_far = lst[0], lst[0]\\n            for x in lst[1:]:\\n                max_ending_here = max(max_ending_here + x, x)\\n                max_so_far = max(max_so_far, max_ending_here)\\n            return max_so_far\\n        \\n        if not arr:\\n            return 0\\n        s = sum(arr)\\n        if k == 1:\\n            return max(0, max_sum(arr)) % (10 ** 9 + 7)\\n        else:\\n            return max(0, (k - 2) * max(s, 0) + max_sum(arr + arr)) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383442,
                "title": "c-short-and-easy-to-understand",
                "content": "**Thinking Process:**\\nFirst look at this question, makes me think of [Leetcode 53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/).\\n```\\nint maxSubArray(vector<int>& nums) {\\n\\tint cur = nums[0], result = cur;\\n\\tfor (int i = 1; i < nums.size(); i++) {\\n\\t\\tcur = max(nums[i], cur + nums[i]);\\n\\t\\tresult = max(result, cur);\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nA naive way is to loop input array k times and use the same idea mentioned above. And of course it\\'s a TLE.\\n\\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint result = 0, cur_max = 0;\\n\\tint M = 1e9 + 7;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tfor (int n : arr) {\\n\\t\\t\\tcur_max = max(cur_max + n, n) % M;\\n\\t\\t\\tresult = max(result, cur_max) % M;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nBut now I have the result for k == 1 at least, now let\\'s think about k == 2. We can easily find that there are 3 cases for k == 2:\\n\\n1. max subarray is somewhere in the middle and the second repeat does not help at all. ex. arr = [-1,  1,  -1], repeat twice, arr2 = [-1, 1, -1, -1, 1, -1], max subarray is still 1;\\n2. max subarray is somewhere in the middle and the second repeat can offer some help. ex. arr = [-1, 4, -1], repeat twice, arr2 = [-1, 4, -1, -1, 4 ,-1], max subarray increases from 4 to [4, -1, -1, 4] -> 6. Further, we can easily find that the extra offer is the sum of the arr = [-1, 4, -1] -> 2; **sum > 0 is the key difference from case 1**. And we can easily extend this case to any k > 2 as well, result = result + (k - 1) * sum; \\n3. max subarray is at the end of the array and the head of second repeat can offer some help. ex. arr = [1, -4, 1], repeat twice, arr2 = [1, -4, 1, 1, -4, 1], max subarray increases from 1 to 2; This is a special case which will not be affected by more repeated arrays. \\n\\nAs we think through k == 2, we already have the idea to extend to any k!\\n\\n**Code:**\\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tlong result = 0, cur_max = 0, sum = 0;\\n\\tint M = 1e9 + 7;\\n\\t// basic solution from Leetcode 53\\n\\tfor (int i = 0; i < arr.size(); i++) {\\n\\t\\tcur_max = max(cur_max + arr[i], (long)arr[i]);\\n\\t\\tresult = max(result, cur_max);\\n\\t\\tsum += arr[i];\\n\\t}\\n\\t// k < 2, return result from basic solution\\n\\tif (k < 2) return result % M;\\n\\t// sum > 0, case 2\\n\\tif (sum > 0) return (result + (k - 1) * sum) % M;\\n\\t// another round to catch case 3\\n\\tfor (int i = 0; i < arr.size(); i++) {\\n\\t\\tcur_max = max(cur_max + arr[i], (long)arr[i]);\\n\\t\\tresult = max(result, cur_max);\\n\\t}\\n\\treturn result % M;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxSubArray(vector<int>& nums) {\\n\\tint cur = nums[0], result = cur;\\n\\tfor (int i = 1; i < nums.size(); i++) {\\n\\t\\tcur = max(nums[i], cur + nums[i]);\\n\\t\\tresult = max(result, cur);\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint result = 0, cur_max = 0;\\n\\tint M = 1e9 + 7;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tfor (int n : arr) {\\n\\t\\t\\tcur_max = max(cur_max + n, n) % M;\\n\\t\\t\\tresult = max(result, cur_max) % M;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tlong result = 0, cur_max = 0, sum = 0;\\n\\tint M = 1e9 + 7;\\n\\t// basic solution from Leetcode 53\\n\\tfor (int i = 0; i < arr.size(); i++) {\\n\\t\\tcur_max = max(cur_max + arr[i], (long)arr[i]);\\n\\t\\tresult = max(result, cur_max);\\n\\t\\tsum += arr[i];\\n\\t}\\n\\t// k < 2, return result from basic solution\\n\\tif (k < 2) return result % M;\\n\\t// sum > 0, case 2\\n\\tif (sum > 0) return (result + (k - 1) * sum) % M;\\n\\t// another round to catch case 3\\n\\tfor (int i = 0; i < arr.size(); i++) {\\n\\t\\tcur_max = max(cur_max + arr[i], (long)arr[i]);\\n\\t\\tresult = max(result, cur_max);\\n\\t}\\n\\treturn result % M;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2726393,
                "title": "c-solution-kadens-algo-with-explanaion",
                "content": "![image](https://assets.leetcode.com/users/images/a1e9785f-03a5-4111-a665-e9c8b73ce7ad_1666284414.5443702.png)\\n\\nonly three cases can be there.\\n\\n**Case 1 :**\\n\\t\\t\\twhen the sum of entire array is positive.\\n* \\t\\t\\tans = maximumSuffixSum + arraySum*(k-2) + maximumPrefixSum\\n**Case 2 :**\\n\\t\\t\\twhen the maximum sum comes in only one array,irrespective of value of k.\\n* \\t\\t\\tans = KadensAlgoSum\\n**Case 3 :**\\n\\t\\t\\twhen the sum of entire array is neagitive,take the MaximumSuffixSum + MaximumPrefixSum\\n* \\t\\t\\tans = maximumSuffixSum + maximumPrefixSum\\n\\n\\nSo answer will be\\n\\n* \\t\\t\\tTake the maximum value of all the three cases.\\n\\n**Code :**\\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint n = arr.size(),gsum = 0,sum = 0,gMax = 0,cMaxSum = 0,mod = 1e9+7;\\n\\tgsum = accumulate(arr.begin(),arr.end(),gsum);\\n\\tint maxSuf = gsum,maxPre = 0;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tsum += arr[i];\\n\\t\\tmaxSuf = max(maxSuf,gsum-sum);\\n\\t\\tmaxPre = max(sum,maxPre);\\n\\t\\tcMaxSum = max(cMaxSum+arr[i],arr[i]);\\n\\t\\tgMax = max(gMax,cMaxSum);\\n\\t}\\n\\n\\tif(k == 1) return gMax;\\n\\treturn (max(max(0ll,(long long)(k-2)*sum)+maxSuf+maxPre,(long long)gMax))%mod;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint n = arr.size(),gsum = 0,sum = 0,gMax = 0,cMaxSum = 0,mod = 1e9+7;\\n\\tgsum = accumulate(arr.begin(),arr.end(),gsum);\\n\\tint maxSuf = gsum,maxPre = 0;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tsum += arr[i];\\n\\t\\tmaxSuf = max(maxSuf,gsum-sum);\\n\\t\\tmaxPre = max(sum,maxPre);\\n\\t\\tcMaxSum = max(cMaxSum+arr[i],arr[i]);\\n\\t\\tgMax = max(gMax,cMaxSum);\\n\\t}\\n\\n\\tif(k == 1) return gMax;\\n\\treturn (max(max(0ll,(long long)(k-2)*sum)+maxSuf+maxPre,(long long)gMax))%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650569,
                "title": "rust-kadane-algorithm-with-explanation",
                "content": "\\nThis is a variant of the [maximum subarray problem (wikipedia)](https://en.wikipedia.org/wiki/Maximum_subarray_problem), and a typical solution is `Kadane\\'s algorithm`:\\n\\n```python\\ndef kadane(numbers):\\n    \"\"\"Find the largest sum of any contiguous subarray.\"\"\"\\n    best_sum = 0  # or: float(\\'-inf\\')\\n    current_sum = 0\\n    for x in numbers:\\n        current_sum = max(0, current_sum + x)\\n        best_sum = max(best_sum, current_sum)\\n    return best_sum\\n```\\n\\nA naive solution to our question is to loop over `arr * k`, and return the `best_sum` in the end. However, with large `k` (e.g., 100_000), we will get `Limited Time Error` (try it).\\n\\nLuckily, we can find patterns. To illustrate, we take `arr = [-2, 5, -1]` as an example. Observe the following facts:\\n1. `sum(arr) = 2 > 0`\\n2. when `k = 2`, sub-array yields the best sum is `[5, -1, -2, 5]` and its sum is `7`, \\n3. when `k = 3`, sub-array yields the best sum is `[5, -1, -2, 5, -1, -2, 5]`, and its sum is `9`, \\n4. when `k = 4`, sub-array yields the best sum is `[5, -1, -2, 5, -1, -2, 5, -1, -2, 5]`, and its sum is `11`, \\n5. ... and so on\\n\\nThe only difference between cases when `k == m` and `k == m+1` is that: the best sub-array of the later contains one more `arr` and `bust_sum_[m+1] - best_sum[m]` is exactly `sum(arr)`.\\n\\nThus, it is safe to say, `res = kadane(arr * 2) + (k - 2) * sum(arr)` when `k >= 2` and `sum(arr) >= 0`. \\n\\nSo, what about the case when `sum(arr) < 0`, e.g., `arr = [1, -10, 3]` ? \\n\\nIn this case, the result is simply `res = kadane(arr * 2)` for any `k >= 2`, because `sum(arr) < 0` and any sub-array that contains `arr` will yield a smaller sum than one contains NO `arr`.\\n\\nCombine the above two possibilities, our result is therefore: `res = kadane(arr * 2) + (k - 2) * max(sum(arr), 0)` when `k >= 2` and `kadane(arr)` otherwise (do not forget to mod `10*9+7` before return the value).\\n\\n### Rust Solution\\n```rust\\nimpl Solution {\\n    pub fn k_concatenation_max_sum(arr: Vec<i32>, k: i32) -> i32 {\\n        let MOD = 1_000_000_007_i64;\\n        let copy = arr.iter().map(|c| *c as i64).collect::<Vec<i64>>();\\n        let mut best = 0_i64;\\n        let mut cur = 0_i64;\\n        let sum_i64: i64 = copy.iter().sum();\\n        let k = k as usize;\\n        \\n        for i in 0..min(k, 2) * copy.len() {\\n            let a = copy[i % arr.len()]; \\n            cur = max(a, cur+a) % MOD;\\n            best = max(best, cur) % MOD;\\n        }\\n        let res = if k > 1 { max(best, best + (k as i64 - 2) * max(sum_i64, 0)) % MOD } else {best % MOD};\\n        res as i32\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef kadane(numbers):\\n    \"\"\"Find the largest sum of any contiguous subarray.\"\"\"\\n    best_sum = 0  # or: float(\\'-inf\\')\\n    current_sum = 0\\n    for x in numbers:\\n        current_sum = max(0, current_sum + x)\\n        best_sum = max(best_sum, current_sum)\\n    return best_sum\\n```\n```rust\\nimpl Solution {\\n    pub fn k_concatenation_max_sum(arr: Vec<i32>, k: i32) -> i32 {\\n        let MOD = 1_000_000_007_i64;\\n        let copy = arr.iter().map(|c| *c as i64).collect::<Vec<i64>>();\\n        let mut best = 0_i64;\\n        let mut cur = 0_i64;\\n        let sum_i64: i64 = copy.iter().sum();\\n        let k = k as usize;\\n        \\n        for i in 0..min(k, 2) * copy.len() {\\n            let a = copy[i % arr.len()]; \\n            cur = max(a, cur+a) % MOD;\\n            best = max(best, cur) % MOD;\\n        }\\n        let res = if k > 1 { max(best, best + (k as i64 - 2) * max(sum_i64, 0)) % MOD } else {best % MOD};\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382889,
                "title": "java-java-solution-with-explanation",
                "content": "The key is to figure out couple of cases that the answer could be derived from.\\nCase 1: when k == 1, then the question is just asking max subarray sum since there\\'s only 1 array\\nCase 2: when k > 1:\\n- Case2(1): when sum >= 0: we can use ((k - 2) * sum of array) as \\'free\\' sum since they are positive and why not add them to our answer. Then, only add max prefix sum and max suffix sum from the rest two arrays to add to our final answer.\\n- Case2(2): when sum < 0: if sum < 0, there\\'s no need to add any of (k - 2) \\'free\\' sum, they are only going to make our final answer smaller. So we only pick the max prefix sum + max suffix sum as our answer.\\n- Note that for both cases in  case2, we need also compare final answer with kaden.\\n\\nHope it helpes.\\n```\\npublic static int mod = (int)(Math.pow(10, 9) + 7);\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\t// 3 cases to consider:\\n\\t// case1: max = max subarray (k == 1)\\n\\t// case2: max = max(kaden, maxPrefixSum + maxSuffixSum + (k - 2) * sum) (sum >=0 && k > 1)\\n\\t// case3: max = max(kaden, maxPrefixSum + maxSuffixSum) (sum < 0 && k > 1)\\n\\n\\tint n = arr.length;\\n\\tlong sum = 0;\\n\\t// calculate sum of whole array\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tsum += arr[i];\\n\\t}\\n\\tint kaden = kadenAlg(arr);\\n\\t// case1\\n\\t// if only 1 array, then answer is the max subarray sum\\n\\tif (k == 1) {\\n\\t\\treturn kaden;\\n\\t}  \\n\\t// calculate max value of prefix sum and max value of suffix sum\\n\\tlong prefixSum = 0;\\n\\tlong suffixSum = 0;\\n\\tlong maxPrefixSum = 0;\\n\\tlong maxSuffixSum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tprefixSum = (prefixSum+ arr[i]) % mod;\\n\\t\\tmaxPrefixSum = Math.max(maxPrefixSum, prefixSum);\\n\\t}\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tsuffixSum = (suffixSum + arr[i]) % mod;\\n\\t\\tmaxSuffixSum = Math.max(maxSuffixSum, suffixSum);\\n\\t}\\n\\n\\t// case 2:\\n\\tif (sum >= 0) {\\n\\t\\treturn Math.max(kaden, (int)((sum * (k - 2)  + maxSuffixSum + maxPrefixSum) % mod));\\n\\t}\\n\\t// case 3:\\n\\telse {\\n\\t\\treturn Math.max(kaden, (int)((maxSuffixSum + maxPrefixSum) % mod));\\n\\t}\\n}\\npublic int kadenAlg(int[] arr) {\\n\\tlong maxSoFar = 0, maxEndingHere = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tmaxEndingHere = (maxEndingHere + arr[i]) % mod;\\n\\t\\tif (maxEndingHere < 0) maxEndingHere = 0;\\n\\t\\telse {\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t}\\n\\treturn (int)maxSoFar;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int mod = (int)(Math.pow(10, 9) + 7);\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\t// 3 cases to consider:\\n\\t// case1: max = max subarray (k == 1)\\n\\t// case2: max = max(kaden, maxPrefixSum + maxSuffixSum + (k - 2) * sum) (sum >=0 && k > 1)\\n\\t// case3: max = max(kaden, maxPrefixSum + maxSuffixSum) (sum < 0 && k > 1)\\n\\n\\tint n = arr.length;\\n\\tlong sum = 0;\\n\\t// calculate sum of whole array\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tsum += arr[i];\\n\\t}\\n\\tint kaden = kadenAlg(arr);\\n\\t// case1\\n\\t// if only 1 array, then answer is the max subarray sum\\n\\tif (k == 1) {\\n\\t\\treturn kaden;\\n\\t}  \\n\\t// calculate max value of prefix sum and max value of suffix sum\\n\\tlong prefixSum = 0;\\n\\tlong suffixSum = 0;\\n\\tlong maxPrefixSum = 0;\\n\\tlong maxSuffixSum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tprefixSum = (prefixSum+ arr[i]) % mod;\\n\\t\\tmaxPrefixSum = Math.max(maxPrefixSum, prefixSum);\\n\\t}\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tsuffixSum = (suffixSum + arr[i]) % mod;\\n\\t\\tmaxSuffixSum = Math.max(maxSuffixSum, suffixSum);\\n\\t}\\n\\n\\t// case 2:\\n\\tif (sum >= 0) {\\n\\t\\treturn Math.max(kaden, (int)((sum * (k - 2)  + maxSuffixSum + maxPrefixSum) % mod));\\n\\t}\\n\\t// case 3:\\n\\telse {\\n\\t\\treturn Math.max(kaden, (int)((maxSuffixSum + maxPrefixSum) % mod));\\n\\t}\\n}\\npublic int kadenAlg(int[] arr) {\\n\\tlong maxSoFar = 0, maxEndingHere = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tmaxEndingHere = (maxEndingHere + arr[i]) % mod;\\n\\t\\tif (maxEndingHere < 0) maxEndingHere = 0;\\n\\t\\telse {\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t}\\n\\treturn (int)maxSoFar;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619200,
                "title": "heavily-commented-code-with-example-kadane-c",
                "content": "class Solution {\\npublic:\\n    \\n    /// when k=1, its kadane,\\n    \\n    // Explaination at end by comments.\\n    \\n    int kadane(vector<int>& arr, bool IsTwice) {\\n        long long M = 1000000007;\\n        int n = arr.size();\\n        int cSum = INT_MIN; // currentSum\\n        int mSum = INT_MIN; //maxSum\\n        \\n\\t\\t// loop will run twice, if isTwice is true\\n\\t\\t// basically we will be doing kadane for the array twice\\n        for(int j=0; j<(IsTwice?2:1); j++) {\\n            for(int i=0; i<n; i++) {\\n                if(cSum>=0) {\\n                    cSum += arr[i];\\n                } else {\\n                    cSum = arr[i];\\n                }\\n                if(cSum>mSum) {\\n                    mSum =  cSum;\\n                }\\n                cSum %= M;\\n                mSum %= M;\\n                // cout<<arr[i]<<\" \";\\n            }   \\n        }\\n        return mSum;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long M = 1000000007;\\n        if(k==1) return kadane(arr,false);\\n        long long sum = (accumulate(arr.begin(),arr.end(),0))%M;\\n        long long ans = 0;\\n        \\n        // SO basically there are only 2 cases. Either the sum>=0 || sum<0        \\n        if(sum>=0) {\\n            // Now when the sum is greater than zero, one appraoch that comes in that is to directly multiply the sum k number of times, but there is a catch.\\n            // What if there is a number is a array like: \\n            // [4, -6, 3] and k=3\\n            // The overall sum is +ve\\n            // [4, -6, 3, 4, -6, 3, 4, -6, 3] -> Net Array (sum(array)*3)\\n            // [0,  1, 2, 3,  4, 5, 6,  7, 8] -> Indicecs\\n                        \\n            // Here if we just add all the elements, sum*k format, \\n            // then we unnecessarily add last -6 and 3 to the sum, which contributes negatively\\n            // Now if we take Kadane with k=2 on the same array, the algorithm will surely avoid considering the -6 and 3.\\n            \\n            // Basically every array, like [4, -6, 3] will have a postive part and a negative part\\n            // like the part 4, -6 -> constributes -2 negatively\\n            // and the part -6, 3 -> contributes -3 negatively.\\n            // So we will try to avoid -6, 3 part.\\n            \\n            // Now we have merged k arrays and we apply Kadane to last 2 arrays of the merged array.\\n            // Why last 2?\\n            // Becasuse we want to avoid the last 2 elements of individual array, as they contribute negatively.\\n              // If the net negative effect was provided by the prefix elements, then we would have taken first 2 arrays for kadane\\n            //But anyhow that doesnt affect our answer.\\n            \\n            //Now if we applly kadane on \\n            // [4, -6, 3, 4, -6, 3, 4, -6, 3]\\n            // [0,  1, 2, 3,  4, 5, 6,  7, 8]\\n            \\n            // on last two arrays, i.e from the index 3 to 8, then the subarray it will choose for the maximum sum is\\n            // from index range [5,6] (inclusive)\\n            // Now merged array elements in the range [7,8] are unused, which we avoided.\\n            // merged Array elements in the range [3,4] is also unused as they did not contribute to maximum subarray when k=2.\\n            // But we can merge [3,4] ranges with index 2, and it forms a complete original individual array which contributes positively.\\n            // Now we can form k-2 such pairs, because we have untoched k-2 pairs and all nth array with form a pair with (n+1)th array.\\n            ans = ((kadane(arr,true)) + (((k-2)*sum)%M))%M;\\n        } else \\n        {   \\n            // we dont give a damn for negative arrays as we know they contribute negative as a whole.\\n            // But everyone deserves a second chance in life \\uD83D\\uDE42,\\n            // So we will try merging two negative sum arrays, to see if it results in a postive array.\\n            // For example: [1,-10,2] // ans = 3\\n            ans = kadane(arr,true);\\n        }\\n        if(ans<0) return 0;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    /// when k=1, its kadane,\\n    \\n    // Explaination at end by comments.\\n    \\n    int kadane(vector<int>& arr, bool IsTwice) {\\n        long long M = 1000000007;\\n        int n = arr.size();\\n        int cSum = INT_MIN; // currentSum\\n        int mSum = INT_MIN; //maxSum\\n        \\n\\t\\t// loop will run twice, if isTwice is true\\n\\t\\t// basically we will be doing kadane for the array twice\\n        for(int j=0; j<(IsTwice?2:1); j++) {\\n            for(int i=0; i<n; i++) {\\n                if(cSum>=0) {\\n                    cSum += arr[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1134335,
                "title": "java-easy-solution-kadanes-variation",
                "content": "```\\nclass Solution {\\n    public long kadane (int arr[]) {\\n    long curr = arr[0];\\n    long max = arr[0];\\n    for(int i = 1; i < arr.length; i++) {\\n        if (curr >= 0) curr+=arr[i];\\n        else curr = arr[i];\\n        if (curr > max) max = curr;\\n    }\\n    return max;\\n}\\npublic long kadaneTwo(int arr[]) {\\n    int narr[] = new int[arr.length * 2];\\n    for (int i = 0; i < arr.length; i++) \\n        narr[i] = arr[i];\\n    for (int i = 0; i < arr.length; i++)\\n        narr[i + arr.length] = arr[i];\\n    return kadane(narr);\\n}\\npublic long sum(int arr[]) {\\n    long s = 0;\\n    for (int i = 0; i < arr.length; i++)\\n        s += arr[i];\\n    return s;\\n}\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n    long sum = sum(arr);\\n    long res = 0;\\n    long x = 1000000007;\\n    if (k == 1) res = kadane(arr);\\n    else if (sum < 0) res = kadaneTwo(arr);\\n    else res = kadaneTwo(arr) + (k - 2)*sum;\\n    if (res < 0) return 0;\\n    return (int)(res % x);\\n}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long kadane (int arr[]) {\\n    long curr = arr[0];\\n    long max = arr[0];\\n    for(int i = 1; i < arr.length; i++) {\\n        if (curr >= 0) curr+=arr[i];\\n        else curr = arr[i];\\n        if (curr > max) max = curr;\\n    }\\n    return max;\\n}\\npublic long kadaneTwo(int arr[]) {\\n    int narr[] = new int[arr.length * 2];\\n    for (int i = 0; i < arr.length; i++) \\n        narr[i] = arr[i];\\n    for (int i = 0; i < arr.length; i++)\\n        narr[i + arr.length] = arr[i];\\n    return kadane(narr);\\n}\\npublic long sum(int arr[]) {\\n    long s = 0;\\n    for (int i = 0; i < arr.length; i++)\\n        s += arr[i];\\n    return s;\\n}\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n    long sum = sum(arr);\\n    long res = 0;\\n    long x = 1000000007;\\n    if (k == 1) res = kadane(arr);\\n    else if (sum < 0) res = kadaneTwo(arr);\\n    else res = kadaneTwo(arr) + (k - 2)*sum;\\n    if (res < 0) return 0;\\n    return (int)(res % x);\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264499,
                "title": "c-solved-in-3-cases",
                "content": "3 cases :\\n*  k=1 :  kadane for one\\n*  sum>0 : kadane for two  + (k-2)* kadane for one  \\n*  sum<0 : kadane for one\\n  Expanation:\\n  sum>0 : kadane for two  + (k-2)* kadane for one  :\\n  \\n  If sum>0, we need to add it to result because it increases our sum.\\n  But for first array  if we have have negative elements in beginning, remove those.\\n  :: kadane for two will remove those negative elements \\n  :: kadane for one will not work because it will not ensure that sum from 1 array includes last element or not, \\n  if not then we can cannot include sum>0 of all arrray, that would decrease overall sum.\\n```\\n class Solution {\\npublic:\\n    long long N=1000000007;\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int  ans=0;\\n        long long sum=0;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n        }\\n         if(k == 1){\\n            ans= (kadanesForOne(arr,n))%N;\\n        }\\n        else if(sum > 0){\\n            ans= (kadanesForTwo(arr,n) + ((k - 2) * (sum)))%N;\\n        }else{\\n            ans= (kadanesForTwo(arr,n))%N;\\n        }\\n        if(ans<0)return 0;\\n        return ans%N;\\n    }\\n     int kadanesForOne(vector<int> arr, int n) {\\n        int finalans = arr[0];\\n        int curr = arr[0];\\n        for(int i = 1 ; i < n; i++){\\n            curr = max(arr[i], arr[i] + curr);\\n            finalans = max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n    int kadanesForTwo(vector<int> arr, int n) {\\n        int finalans = arr[0];\\n        int curr = arr[0];\\n        for(int i = 1 ; i < 2 * n; i++){\\n            curr = max(arr[i % n], arr[i % n] + curr);\\n            finalans = max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n};\\n             \\n               \\n```\\nHope it helps.\\n  \\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    long long N=1000000007;\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int  ans=0;\\n        long long sum=0;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n        }\\n         if(k == 1){\\n            ans= (kadanesForOne(arr,n))%N;\\n        }\\n        else if(sum > 0){\\n            ans= (kadanesForTwo(arr,n) + ((k - 2) * (sum)))%N;\\n        }else{\\n            ans= (kadanesForTwo(arr,n))%N;\\n        }\\n        if(ans<0)return 0;\\n        return ans%N;\\n    }\\n     int kadanesForOne(vector<int> arr, int n) {\\n        int finalans = arr[0];\\n        int curr = arr[0];\\n        for(int i = 1 ; i < n; i++){\\n            curr = max(arr[i], arr[i] + curr);\\n            finalans = max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n    int kadanesForTwo(vector<int> arr, int n) {\\n        int finalans = arr[0];\\n        int curr = arr[0];\\n        for(int i = 1 ; i < 2 * n; i++){\\n            curr = max(arr[i % n], arr[i % n] + curr);\\n            finalans = max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n};\\n             \\n               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 382448,
                "title": "java-solution-with-easy-explanation-beat-100",
                "content": "3 cases:\\n1. maximum sum is located inside the array without any concatenation ( this is refer to 53. Maximum Subarray)\\n2. if sum of array is negative - maximum sum is over somewhere after two array concatenation\\n3. if sum of the array is positive - maximum sum is based on case 2 + (k - 2) * sum \\n\\n```\\nclass Solution {\\n    \\n    int modulo = 1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n        int maxSoFar = arr[0];\\n        int maxEndingHere = arr[0];\\n        for(int i = 1; i < n; i++){\\n            maxEndingHere = Math.max(maxEndingHere + arr[i], arr[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n        \\n        if(k < 2) return maxSoFar;\\n        \\n        int leftSum = arr[0];\\n        int rightSum = arr[n - 1];\\n        int lMax = Math.max(0, arr[0]);\\n        int rMax = Math.max(0, arr[n-1]);\\n        \\n        for(int i = 1; i < n; i++){\\n            leftSum += arr[i];\\n            lMax = Math.max(lMax, leftSum);\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            rightSum += arr[i];\\n            rMax = Math.max(rMax, rightSum);\\n        }\\n        \\n        int headTailMax = lMax + rMax;\\n\\n        if(leftSum < 0) return Math.max(maxSoFar, headTailMax);\\n        \\n        else return Math.max(maxSoFar, (int)(headTailMax + ((k - 2) * (long)leftSum) % modulo));\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int modulo = 1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n        int maxSoFar = arr[0];\\n        int maxEndingHere = arr[0];\\n        for(int i = 1; i < n; i++){\\n            maxEndingHere = Math.max(maxEndingHere + arr[i], arr[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n        \\n        if(k < 2) return maxSoFar;\\n        \\n        int leftSum = arr[0];\\n        int rightSum = arr[n - 1];\\n        int lMax = Math.max(0, arr[0]);\\n        int rMax = Math.max(0, arr[n-1]);\\n        \\n        for(int i = 1; i < n; i++){\\n            leftSum += arr[i];\\n            lMax = Math.max(lMax, leftSum);\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            rightSum += arr[i];\\n            rMax = Math.max(rMax, rightSum);\\n        }\\n        \\n        int headTailMax = lMax + rMax;\\n\\n        if(leftSum < 0) return Math.max(maxSoFar, headTailMax);\\n        \\n        else return Math.max(maxSoFar, (int)(headTailMax + ((k - 2) * (long)leftSum) % modulo));\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032432,
                "title": "python-3-2-7-lines-two-versions-w-example-t-m-99-12",
                "content": "\\nSame algorithm used by most of the other posted solutions.\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\n        if max(arr)<= 0 : return 0      #             arr = [-5,4,7,-2]\\n        sm, ct, mx,  = sum(arr), 0, 0   #              sm = 4\\n                                        # arr.extend(arr) = [-5,4,7,-2,-5,4,7,-2]\\n        if k > 1: arr.extend(arr)       #   \\n                                        #    n = [-5, 2, 4, 6,-5, 2, 4, 6]\\n        for n in arr:                   #   ct = [ 0, 4,11, 9, 4, 8,15,13]\\n            ct = max(ct + n, 0)         #   mx = [ 0, 4,11,11,11,11,15,15]\\n            mx = max(mx, ct)            #   \\n                                        #   15 + (3-2)*4*(3 > 1)*(4 > 0)\\n                                        #   15 + 1*4 * True*True = 19 <-- return\\n        return (mx + (k-2) * sm * (k > 1) * (sm > 0)) % 1000000007\\n```\\nHere\\'s the two-line version, using `accumulate`.\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n       \\n        acc = list(accumulate(chain(*[arr]*(2-(k==1))),\\n                   lambda x,y: max(0,x+y), initial = 0))\\n       \\n        return (max(acc) + (k-2)*sum(arr)*(sum(arr)>0)*(k>1))%1000000007\\n```\\n[https://leetcode.com/problems/k-concatenation-maximum-sum/submissions/875659809/](http://)\\n[https://leetcode.com/problems/k-concatenation-maximum-sum/submissions/875654833/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\n        if max(arr)<= 0 : return 0      #             arr = [-5,4,7,-2]\\n        sm, ct, mx,  = sum(arr), 0, 0   #              sm = 4\\n                                        # arr.extend(arr) = [-5,4,7,-2,-5,4,7,-2]\\n        if k > 1: arr.extend(arr)       #   \\n                                        #    n = [-5, 2, 4, 6,-5, 2, 4, 6]\\n        for n in arr:                   #   ct = [ 0, 4,11, 9, 4, 8,15,13]\\n            ct = max(ct + n, 0)         #   mx = [ 0, 4,11,11,11,11,15,15]\\n            mx = max(mx, ct)            #   \\n                                        #   15 + (3-2)*4*(3 > 1)*(4 > 0)\\n                                        #   15 + 1*4 * True*True = 19 <-- return\\n        return (mx + (k-2) * sm * (k > 1) * (sm > 0)) % 1000000007\\n```\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n       \\n        acc = list(accumulate(chain(*[arr]*(2-(k==1))),\\n                   lambda x,y: max(0,x+y), initial = 0))\\n       \\n        return (max(acc) + (k-2)*sum(arr)*(sum(arr)>0)*(k>1))%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522399,
                "title": "using-java-kadanes-algo",
                "content": "\\n    class Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        List<Integer> l=new ArrayList<>();\\n        long mod=(long)(1e9)+7;\\n       long sum=0;\\n        for(int x:arr){\\n            sum+=(long)x;\\n            l.add(x);\\n        }\\n        //condition for k==1\\n         if(k==1){\\n            long z=kadanes(l);\\n            return (int)(z%mod);\\n        }\\n        //if sum is neg applying two times kadanes\\n        else if(sum<0){\\n            for(int x:arr)l.add(x);\\n            long z=kadanes(l);\\n            return (int)(z%mod);\\n        }\\n        //if sum is pos applying two times kadanes and adding the k-2 times whole sum\\n        else{\\n            for(int x:arr)l.add(x);\\n            long z=kadanes(l);\\n            long p1=z+(k-2)*sum;\\n            return (int)(p1%mod);\\n        }\\n            \\n    }\\n    //kadanes algo\\n    public long kadanes(List<Integer> l){\\n        long prev=0;long max=0;\\n        for(int i=0;i<l.size();i++){\\n            prev=Math.max(prev+(long)l.get(i),(long)l.get(i));\\n            max=Math.max(max,prev);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        List<Integer> l=new ArrayList<>();\\n        long mod=(long)(1e9)+7;\\n       long sum=0;\\n        for(int x:arr){\\n            sum+=(long)x;\\n            l.add(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 383239,
                "title": "c-and-javascript-solutions",
                "content": "**Synopsis:**\\n\\n* There are 3 use-cases to consider:\\n\\t1. If ```k == 1``` or the maximum subarray sum from the first and second instance of ```A``` is the same, then return the value derived from [Kadane\\'s Algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem) mod ```1e9+7``` (ie. ```ans1```)\\n\\t2. The maximum subarray sum occurs between two instances of ```A``` appended together and that value is sustained regardless of how many additional ```k``` instances of ```A``` are \"processed\", then return the sustained maximum value mod ```1e9+7``` (ie. ```ans2```).  This use-case can be uniquely identified by \"processing\" 3 instances of ```A```, and checking if the ongoing sum changes between the \"processing\" of the first and second instance of ```A```, and remains the same between the \"processing\" of the second and third instance of ```A```.\\n\\t3. The maximum subarray sum occurs after all ```k``` instances of ```A``` are \"processed\", then return the  hypothetically calculated maximum subarray sum mod ```1e9+7``` by observing that each delta from the previous ```k```th instance of ```A``` and the current ```k```th instance of ```A``` is offset by the same amount.  We can use that consistent delta/offset to derive the maximum subarray sum for all ```k``` instances of ```A```, since there are ```k-1``` of these increased offsets of subarray sums.  This use-case can be uniquely identified by \"processing\" 3 instances of ```A```, and checking if the ongoing sum continually increases by the same delta from the first, second, and third \"processing\" of ```A``` (ie. ```delta1 > 0 && delta2 > 0 && delta1 == delta2```).\\n\\n**Note:** [Kadane\\'s Algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem) is used to calculate the maximum subarray sum for case 2 and case 3.  Also notice case 2 and case 3 can only occur if ```k > 1```.\\n\\n**Runtime:** O(N)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    static constexpr auto MOD = static_cast<int>(1e9 + 7);\\n    static constexpr auto INF = static_cast<int>(1e4 + 1);\\n    int kConcatenationMaxSum(vector<int>& A, int k, LL sum=0, LL ans1=0, LL ans2=0, LL ans3=0) {\\n        tie(sum, ans1) = kadane(A);\\n        tie(sum, ans2) = kadane(A, sum);\\n        tie(sum, ans3) = kadane(A, sum);\\n        LL delta1 = ans2 - ans1,\\n           delta2 = ans3 - ans2;\\n        return k == 1 || delta1 == 0 ? ans1 : delta2 == 0 ? ans2 : ans1 + (delta1 * (k-1) % MOD);\\n    }\\nprivate:\\n    pair<LL, LL> kadane(const vector<int>& A, LL sum=0, LL ans=-INF) { // https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n        for (auto i=0; i < A.size(); ++i) {\\n            sum = max(0LL, sum + A[i] % MOD);\\n            ans = max(ans, sum);\\n        }\\n        return {sum, ans};\\n    }\\n};\\n```\\n\\n**Javascript:**\\n```\\nvar kConcatenationMaxSum = (A, k) => {\\n  const MOD = 1e9 + 7,\\n        INF = 1e4 + 1;\\n  var kadane = (A, sum=0, ans=-INF) => { // https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n    for (let x of A) {\\n      sum = Math.max(0, sum + x);\\n      ans = Math.max(ans, sum);\\n    }\\n    return [sum, ans];\\n  };\\n  var [sum, ans1] = kadane(A);\\n  var [sum, ans2] = kadane(A, sum);\\n  var [sum, ans3] = kadane(A, sum);\\n  const delta1 = ans2 - ans1,\\n        delta2 = ans3 - ans2;\\n  return k == 1 || delta1 == 0 ? ans1 : delta2 == 0 ? ans2 : ans1 + (delta1 * (k-1) % MOD);\\n};\\n```",
                "solutionTags": [],
                "code": "```k == 1```\n```A```\n```1e9+7```\n```ans1```\n```A```\n```k```\n```A```\n```1e9+7```\n```ans2```\n```A```\n```A```\n```A```\n```k```\n```A```\n```1e9+7```\n```k```\n```A```\n```k```\n```A```\n```k```\n```A```\n```k-1```\n```A```\n```A```\n```delta1 > 0 && delta2 > 0 && delta1 == delta2```\n```k > 1```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    static constexpr auto MOD = static_cast<int>(1e9 + 7);\\n    static constexpr auto INF = static_cast<int>(1e4 + 1);\\n    int kConcatenationMaxSum(vector<int>& A, int k, LL sum=0, LL ans1=0, LL ans2=0, LL ans3=0) {\\n        tie(sum, ans1) = kadane(A);\\n        tie(sum, ans2) = kadane(A, sum);\\n        tie(sum, ans3) = kadane(A, sum);\\n        LL delta1 = ans2 - ans1,\\n           delta2 = ans3 - ans2;\\n        return k == 1 || delta1 == 0 ? ans1 : delta2 == 0 ? ans2 : ans1 + (delta1 * (k-1) % MOD);\\n    }\\nprivate:\\n    pair<LL, LL> kadane(const vector<int>& A, LL sum=0, LL ans=-INF) { // https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n        for (auto i=0; i < A.size(); ++i) {\\n            sum = max(0LL, sum + A[i] % MOD);\\n            ans = max(ans, sum);\\n        }\\n        return {sum, ans};\\n    }\\n};\\n```\n```\\nvar kConcatenationMaxSum = (A, k) => {\\n  const MOD = 1e9 + 7,\\n        INF = 1e4 + 1;\\n  var kadane = (A, sum=0, ans=-INF) => { // https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n    for (let x of A) {\\n      sum = Math.max(0, sum + x);\\n      ans = Math.max(ans, sum);\\n    }\\n    return [sum, ans];\\n  };\\n  var [sum, ans1] = kadane(A);\\n  var [sum, ans2] = kadane(A, sum);\\n  var [sum, ans3] = kadane(A, sum);\\n  const delta1 = ans2 - ans1,\\n        delta2 = ans3 - ans2;\\n  return k == 1 || delta1 == 0 ? ans1 : delta2 == 0 ? ans2 : ans1 + (delta1 * (k-1) % MOD);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902950,
                "title": "python3-kadane-algorithm",
                "content": "# Intuition\\nLongest continuos sum of sub-array containing negative number -> Kadane algorithm\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can iterate all over the arr `k` times and do kadane in it. It will work perfectly but not smart enough to pass all test cases. You will meet TLE in some cases. Even Kadane is smart but this way can be considerer brute-force with ones who\\'ve already knew about Kadane.\\n\\nKadane is a greedy algorithm but with this cases we can do it more greedily to avoid iterate the arr `k` times.\\nTo do it there are 2 cases that can return the max sum that we should consider:\\n- Taking the whole arr k-th times and sum it.\\n- Taking 1 semgment of sub-array that length is smaller than length arr * k\\n- Then we should find the maximum between 2 cases.\\n\\nWhy it should work:\\n- first of all we take all array if and only if sum of an array is positive (think it greedily). If it is negative we cannot take it we can only take segment of sub-array to get the max. With this we just need to calculate the sum of `arr` and sum it `k` times.\\n- Consider this example: `arr` = `[0,0,3,9,-2,-5,4]` and `k` = 5. You can see the `sum` of `arr` is `9` so the max sum is 9 * 5 = 45 (correct answer).\\n- What about this cases: `arr` = `[-5,-2,0,0,3,9,-2,-5,4]` and `k` = 5. `sum` of `arr` is `2` but the sum is not 2 * 5 like before. it is 9 + 2 * 4 = 17. How to find that we see that if we choose to take the whole array we always have to take the next `k-1` sub-array and max end part of the 1st array. The max end part of 1st sub-array can be find by kadane and you can find it `9` that why we have `9 + 2 * 4`\\n- You may say that the maximum sum get from kadane for the first array does not come from the ending sub-array of the first array to make it continuos with the left but it does since we apply this equation with non-negative sum of array.\\n- There are also a case the sum of whole sub-array is smaller than the sum of segment of sub-array. You can think about that if sum of array is positive but small and `k` is small too -> for example sum array is 1 and k is 2 -> if we apply the above equation the answer will be 2 It is failed in this case. `arr` = `[-1,1,2,3,-8,4]` and `k` = `2`. `sum` of `arr` is `1` which is positive so if we take all elements the `max_sum` is 1 * 2  = 2. However if we take only subarray the `max_sum` will be bigger. let see this array repeat 2 times will be `[-1,1,2,3,-8,4,-1,1,2,3,-8,4]` -> if we take sub-array from the 1st index (0-based index) to the 9th index the sum will be:\\n1 + 2 + 3 - 8 + 4 - 1 + 1 + 2 + 3 = 7. And yeah `7` is the correct answer in this case\\n- Thus we only need to care about 2 cases as I said which can minimize a lot of calulation.\\n- For the case getting sub-array. It can be from only one array or it can come from 2 consecutive array. With k=1 we can only check from only 1 array that is why I use `min(k, 2)`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        s, mod = sum(arr), 10 ** 9 + 7\\n        n = len(arr)\\n\\n        def kadane(l: int) -> int:\\n            cur_s = max_s = 0\\n            for i in range(l):\\n                num = arr[i % n]\\n                cur_s = max(0, cur_s + num)\\n                max_s = max(max_s, cur_s)\\n            return max_s\\n\\n        if s > 0: return max((kadane(n) + s * (k - 1)), kadane(n * min(k, 2))) % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        s, mod = sum(arr), 10 ** 9 + 7\\n        n = len(arr)\\n\\n        def kadane(l: int) -> int:\\n            cur_s = max_s = 0\\n            for i in range(l):\\n                num = arr[i % n]\\n                cur_s = max(0, cur_s + num)\\n                max_s = max(max_s, cur_s)\\n            return max_s\\n\\n        if s > 0: return max((kadane(n) + s * (k - 1)), kadane(n * min(k, 2))) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278545,
                "title": "o-n-easy-c-solution",
                "content": "# Intuition\\nWhen the arr\\'s sum is positive, consider k. When k > 2, use Kadane\\'s algorithm to calculate maximum subarray of 2 arrs(one in the front and one at the end) and add the sum of all the middle arrs.\\nWhen the arr\\'s sum is negative, we only need to use Kadane\\'s algorithm to calculate the maximum subarray of 2 arrs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    int M=1000000007;\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int sum=0;\\n        long long int res=0;\\n        vector<int> arr2(arr);\\n        arr2.insert(arr2.end(),arr.begin(),arr.end());\\n        if(k==1) return largest(arr)%M;\\n        if(k==2) return largest(arr2)%M;\\n        for(int i:arr) sum+=i;\\n        if(sum>0)\\n        {\\n            res=(long long int)(k-2)*sum%M;\\n            res=(res+largest(arr2))%M;\\n        }\\n        else\\n        {\\n            res=largest(arr2)%M;\\n        }\\n        return res;\\n    }\\n\\n    int largest(vector<int>& arr)\\n    {\\n        int best_sum = 0;\\n        int current_sum = 0;\\n        for (int x:arr)\\n        {\\n            current_sum = max(0, current_sum + x);\\n            best_sum = max(best_sum, current_sum);\\n        }\\n        return best_sum;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int M=1000000007;\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int sum=0;\\n        long long int res=0;\\n        vector<int> arr2(arr);\\n        arr2.insert(arr2.end(),arr.begin(),arr.end());\\n        if(k==1) return largest(arr)%M;\\n        if(k==2) return largest(arr2)%M;\\n        for(int i:arr) sum+=i;\\n        if(sum>0)\\n        {\\n            res=(long long int)(k-2)*sum%M;\\n            res=(res+largest(arr2))%M;\\n        }\\n        else\\n        {\\n            res=largest(arr2)%M;\\n        }\\n        return res;\\n    }\\n\\n    int largest(vector<int>& arr)\\n    {\\n        int best_sum = 0;\\n        int current_sum = 0;\\n        for (int x:arr)\\n        {\\n            current_sum = max(0, current_sum + x);\\n            best_sum = max(best_sum, current_sum);\\n        }\\n        return best_sum;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201976,
                "title": "python-easy-to-read-and-understand-kadane",
                "content": "```\\nclass Solution:\\n    def kadane(self, nums):\\n        for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(max(nums), 0)\\n    \\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        sums = sum(arr)\\n        mod = 10**9 + 7\\n        if k == 1:\\n            return self.kadane(arr) % (mod)\\n        if sums > 0:\\n            return (self.kadane(arr+arr) + (k-2)*sums) % (mod)\\n        else:\\n            return self.kadane(arr+arr) % (mod)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kadane(self, nums):\\n        for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(max(nums), 0)\\n    \\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        sums = sum(arr)\\n        mod = 10**9 + 7\\n        if k == 1:\\n            return self.kadane(arr) % (mod)\\n        if sums > 0:\\n            return (self.kadane(arr+arr) + (k-2)*sums) % (mod)\\n        else:\\n            return self.kadane(arr+arr) % (mod)",
                "codeTag": "Java"
            },
            {
                "id": 1755396,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> &arr)\\n    {\\n      int sum = 0, maxsum = 0;\\n      for(int it : arr)\\n      {\\n          sum = max(sum, 0) + it;\\n          maxsum = max(sum, maxsum);\\n      }\\n      return maxsum;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n     const int mod = 1e9 + 7;\\n     if( k == 1)\\n     return kadane(arr);\\n     int n = arr.size();\\n     int sum = 0;\\n     for(int it : arr)\\n     {\\n         sum = (sum + it)%mod;\\n     }\\n     arr.reserve(2 * n);\\n     for (int i = 0; i < n; ++i)\\n         arr.push_back(arr[i]);\\n     int ans = kadane(arr);\\n     if(sum <= 0)\\n     return ans;\\n     ans = (ans + long(k-2)*sum)%mod;\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> &arr)\\n    {\\n      int sum = 0, maxsum = 0;\\n      for(int it : arr)\\n      {\\n          sum = max(sum, 0) + it;\\n          maxsum = max(sum, maxsum);\\n      }\\n      return maxsum;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n     const int mod = 1e9 + 7;\\n     if( k == 1)\\n     return kadane(arr);\\n     int n = arr.size();\\n     int sum = 0;\\n     for(int it : arr)\\n     {\\n         sum = (sum + it)%mod;\\n     }\\n     arr.reserve(2 * n);\\n     for (int i = 0; i < n; ++i)\\n         arr.push_back(arr[i]);\\n     int ans = kadane(arr);\\n     if(sum <= 0)\\n     return ans;\\n     ans = (ans + long(k-2)*sum)%mod;\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478119,
                "title": "c-simple-and-well-explained-solution-with-comments-kadens-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long max(long long a,long long b)\\n    {\\n        if(a>b)return a;return b;\\n    }\\n    \\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        long long s=0;\\n        int md=1e9+7;\\n        long long n=arr.size();\\n        \\n        //finding the sum of all elements\\n        for(auto x:arr)s+=x;\\n        \\n        //if s>0 we can select all k arrays or we can select all k arrays and exclude the\\n        // first -ve and last -ve elements from total sum\\n        \\n        if(s>0)\\n        {\\n            long long t=0,mi1=INT_MAX,mi2=INT_MAX;\\n            \\n            //finding the min including first element\\n            for(int i=0;i<n;i++)\\n            {\\n                t+=arr[i];\\n                mi1=min(mi1,t);\\n            }\\n            \\n            //finding the min including last element\\n            t=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                t+=arr[i];\\n                mi2=min(mi2,t); \\n            }\\n            \\n            //if mi1 or mi2 >0 then we dont need them as they will subtract out our total sum\\n            if(mi1>0)mi1=0;\\n            if(mi2>0)mi2=0;\\n            \\n            mi1=abs(mi1);\\n            mi2=abs(mi2);\\n            long long e=s*k;\\n            return max(e,e+mi1+mi2)%md;\\n        }\\n        \\n        \\n        //if s<0 then we need only two arrays \\n        if(k!=1)for(int i=0;i<n;i++)arr.push_back(arr[i]);\\n        long long cm=0,maxsofar=0;\\n        for(auto x:arr)\\n        {\\n            cm=max(cm+x,x);\\n            maxsofar=max(maxsofar,cm);\\n        }\\n        return maxsofar%md;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long max(long long a,long long b)\\n    {\\n        if(a>b)return a;return b;\\n    }\\n    \\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        long long s=0;\\n        int md=1e9+7;\\n        long long n=arr.size();\\n        \\n        //finding the sum of all elements\\n        for(auto x:arr)s+=x;\\n        \\n        //if s>0 we can select all k arrays or we can select all k arrays and exclude the\\n        // first -ve and last -ve elements from total sum\\n        \\n        if(s>0)\\n        {\\n            long long t=0,mi1=INT_MAX,mi2=INT_MAX;\\n            \\n            //finding the min including first element\\n            for(int i=0;i<n;i++)\\n            {\\n                t+=arr[i];\\n                mi1=min(mi1,t);\\n            }\\n            \\n            //finding the min including last element\\n            t=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                t+=arr[i];\\n                mi2=min(mi2,t); \\n            }\\n            \\n            //if mi1 or mi2 >0 then we dont need them as they will subtract out our total sum\\n            if(mi1>0)mi1=0;\\n            if(mi2>0)mi2=0;\\n            \\n            mi1=abs(mi1);\\n            mi2=abs(mi2);\\n            long long e=s*k;\\n            return max(e,e+mi1+mi2)%md;\\n        }\\n        \\n        \\n        //if s<0 then we need only two arrays \\n        if(k!=1)for(int i=0;i<n;i++)arr.push_back(arr[i]);\\n        long long cm=0,maxsofar=0;\\n        for(auto x:arr)\\n        {\\n            cm=max(cm+x,x);\\n            maxsofar=max(maxsofar,cm);\\n        }\\n        return maxsofar%md;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245229,
                "title": "c-clean-solution-with-explanation",
                "content": "1. For K = 1, Answer will be same as Kadanes\\n2. For K >= 2, we calculate Kadanes for array + array, i.e, array concatinated once in array.\\n3. Imagine the answer on kadanes on array(1st array)+array(kth array) as two ends of the actual answer. Now if Sum of the array is greater than 0, we can add (k-2)*(sum) in the answer. Otherwise the answer will be same as Kadanes for array + array.\\n```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int> arr, int k){\\n        if(k==2){\\n            vector<int> v = arr;\\n            v.insert(v.end(), arr.begin(), arr.end());\\n            arr = v;\\n        }\\n        int curr_max = 0, ans = 0;\\n        for(auto i: arr){\\n            curr_max = max(curr_max + i, i);\\n            ans = max(ans, curr_max);\\n        }\\n        return ans;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int mod = 1e9 + 7;\\n        if(k==1){\\n            return kadanes(arr, 1);\\n        }\\n        int sum = 0;\\n        for(auto i: arr) sum += i;\\n        int kn2 = (1ll*(sum%mod)*((k-2)%mod))%mod;\\n        int k2 = kadanes(arr, 2)%mod;\\n        int ans = max(k2, (k2+kn2)%mod);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int> arr, int k){\\n        if(k==2){\\n            vector<int> v = arr;\\n            v.insert(v.end(), arr.begin(), arr.end());\\n            arr = v;\\n        }\\n        int curr_max = 0, ans = 0;\\n        for(auto i: arr){\\n            curr_max = max(curr_max + i, i);\\n            ans = max(ans, curr_max);\\n        }\\n        return ans;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int mod = 1e9 + 7;\\n        if(k==1){\\n            return kadanes(arr, 1);\\n        }\\n        int sum = 0;\\n        for(auto i: arr) sum += i;\\n        int kn2 = (1ll*(sum%mod)*((k-2)%mod))%mod;\\n        int k2 = kadanes(arr, 2)%mod;\\n        int ans = max(k2, (k2+kn2)%mod);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220422,
                "title": "java-k-kadanes-3ms-beats-92-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(arr.length) O(1)\\n\\tpublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\n\\t\\tif (k == 1)\\n\\t\\t\\treturn kadanes(arr);\\n\\n\\t\\tint sum = arr[0], mod = 1_000_000_007, len1 = arr.length, len2 = 2 * len1, cmax = arr[0], omax = arr[0];\\n\\t\\tfor (int i = 1; i < len2; i++) {\\n            int idx = i%len1;\\n\\t\\t\\tsum += arr[idx];\\n\\t\\t\\tcmax += arr[idx];\\n\\t\\t\\tif (arr[idx] > cmax)\\n\\t\\t\\t\\tcmax = arr[idx];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n        sum = sum/2;\\n\\n\\t\\tint ans = (sum <= 0) ? omax : (int) ((omax + ((long) k - 2) * sum) % mod);\\n\\t\\treturn (ans >= 0) ? ans : 0;\\n\\t}\\n\\n\\t// O(arr.length) O(1)\\n\\tpublic int kadanes(int[] arr) {\\n\\n\\t\\tint len = arr.length, omax = arr[0], cmax = arr[0];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += arr[i];\\n\\t\\t\\tif (arr[i] > cmax)\\n\\t\\t\\t\\tcmax = arr[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(arr.length) O(1)\\n\\tpublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\n\\t\\tif (k == 1)\\n\\t\\t\\treturn kadanes(arr);\\n\\n\\t\\tint sum = arr[0], mod = 1_000_000_007, len1 = arr.length, len2 = 2 * len1, cmax = arr[0], omax = arr[0];\\n\\t\\tfor (int i = 1; i < len2; i++) {\\n            int idx = i%len1;\\n\\t\\t\\tsum += arr[idx];\\n\\t\\t\\tcmax += arr[idx];\\n\\t\\t\\tif (arr[idx] > cmax)\\n\\t\\t\\t\\tcmax = arr[idx];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n        sum = sum/2;\\n\\n\\t\\tint ans = (sum <= 0) ? omax : (int) ((omax + ((long) k - 2) * sum) % mod);\\n\\t\\treturn (ans >= 0) ? ans : 0;\\n\\t}\\n\\n\\t// O(arr.length) O(1)\\n\\tpublic int kadanes(int[] arr) {\\n\\n\\t\\tint len = arr.length, omax = arr[0], cmax = arr[0];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += arr[i];\\n\\t\\t\\tif (arr[i] > cmax)\\n\\t\\t\\t\\tcmax = arr[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 939212,
                "title": "c-c-simple-solution-to-understand-in-o-n",
                "content": "```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\n    ll kadane(vector<int>& arr) {\\n        ll curr_sum = 0;\\n        ll sum_so_far = 0;\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            curr_sum += arr[i];\\n            if(curr_sum < 0)\\n                curr_sum = 0;\\n            else if(curr_sum > sum_so_far)\\n                sum_so_far = curr_sum;\\n            \\n        }\\n        return sum_so_far%mod;\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        //if (k==1) means simply do to Kadane\\'s Algo and done\\n        if(k==1)\\n            return kadane(arr);\\n        \\n        // if (k != 1) that means we have to modify our array\\n        ll sum=0;\\n        for(int i=0; i<arr.size() ; i++)\\n            sum+=arr[i];\\n        \\n        // Let\\'s have a 2 copy of original array.\\n        vector<int> newv;\\n            for(int i=0; i<2*arr.size(); i++)\\n                newv.push_back(arr[i%arr.size()]);\\n        \\n        if(sum<0)   // if sum if -ve then apply Kadane\\'s over new vector\\n            return kadane(newv);\\n        \\n        else        // if sum is +ve means we have to apply Kadane\\'s over n*k array\\n            return kadane(newv) + (k-2)*sum%mod;\\n            //taking Kadane\\'s of 2 copy and adding (k-2) times the sum of original array.\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\n    ll kadane(vector<int>& arr) {\\n        ll curr_sum = 0;\\n        ll sum_so_far = 0;\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            curr_sum += arr[i];\\n            if(curr_sum < 0)\\n                curr_sum = 0;\\n            else if(curr_sum > sum_so_far)\\n                sum_so_far = curr_sum;\\n            \\n        }\\n        return sum_so_far%mod;\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        //if (k==1) means simply do to Kadane\\'s Algo and done\\n        if(k==1)\\n            return kadane(arr);\\n        \\n        // if (k != 1) that means we have to modify our array\\n        ll sum=0;\\n        for(int i=0; i<arr.size() ; i++)\\n            sum+=arr[i];\\n        \\n        // Let\\'s have a 2 copy of original array.\\n        vector<int> newv;\\n            for(int i=0; i<2*arr.size(); i++)\\n                newv.push_back(arr[i%arr.size()]);\\n        \\n        if(sum<0)   // if sum if -ve then apply Kadane\\'s over new vector\\n            return kadane(newv);\\n        \\n        else        // if sum is +ve means we have to apply Kadane\\'s over n*k array\\n            return kadane(newv) + (k-2)*sum%mod;\\n            //taking Kadane\\'s of 2 copy and adding (k-2) times the sum of original array.\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871454,
                "title": "java-time-complexity-o-n",
                "content": "The six situations of the maximum-Sum are shown as follows:\\n![image](https://assets.leetcode.com/users/images/7edc66a7-7a6c-4043-9dbe-58b08c72e2b5_1601443455.1286414.png)\\nSo, in the single array (the array before K-Concatenating), we need to calcaluate these values are listed as follow:\\n1) sum: the sum of the array\\n2) max: the maximum sum of single sub-array\\n3) Lmin:  the minimum sum of consecutive sub-arrays starting from the left end\\n4) Rmin:  the minimum sum of consecutive sub-arrays starting from the right end\\n\\nAfter calculating the above four values, the sum of the largest sub-array after K concatenation can be calculated according to the above six situations\\n```\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        //======================\\n        long max = 0;\\n        int slow = 0;\\n        int fast = 0;\\n        long curSum = 0;\\n        while(fast<arr.length){\\n            curSum+=arr[fast];\\n            if(curSum>max){\\n                max = curSum;\\n            }\\n            while(curSum<0&&slow<=fast){\\n                curSum -= arr[slow];\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        if(curSum>max){\\n            max = curSum;\\n        }\\n        //=====================\\n        long min = 0;\\n        slow = 0;\\n        fast = 0;\\n        curSum = 0;\\n        while(fast<arr.length){\\n            curSum+=arr[fast];\\n            if(curSum<min){\\n                min = curSum;\\n            }\\n            while(curSum>0&&slow<=fast){\\n                curSum -= arr[slow];\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        if(curSum<min){\\n            min = curSum;\\n        }\\n        //===============================\\n        long leftMin = 0;\\n        long rightMax = 0;\\n        curSum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            curSum += arr[i];\\n            if(curSum< leftMin){\\n                leftMin = curSum;\\n            }\\n            if(curSum>rightMax){\\n                rightMax = curSum;\\n            }\\n        }\\n        //==============================\\n        long rightMin = 0;\\n        long leftMax = 0;\\n        curSum = 0;\\n        for(int i=arr.length-1;i>=0;i--){\\n            curSum+=arr[i];\\n            if(curSum<rightMin){\\n                rightMin = curSum;\\n            }\\n            if(curSum>leftMax){\\n                leftMax = curSum;\\n            }\\n        }\\n        //===============================\\n        leftMax = Math.max(leftMax, sum-leftMin);\\n        rightMax = Math.max(rightMax, sum-rightMin);\\n        max = Math.max(max, sum-min);\\n        max = Math.max(max, sum*k);\\n        max = Math.max(max, (sum*(k-2))+leftMax+rightMax);\\n        max = Math.max(max, (sum*(k-1))+leftMax);\\n        max = Math.max(max, (sum*(k-1))+rightMax);\\n        return (int)(max%(1000000007));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        //======================\\n        long max = 0;\\n        int slow = 0;\\n        int fast = 0;\\n        long curSum = 0;\\n        while(fast<arr.length){\\n            curSum+=arr[fast];\\n            if(curSum>max){\\n                max = curSum;\\n            }\\n            while(curSum<0&&slow<=fast){\\n                curSum -= arr[slow];\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        if(curSum>max){\\n            max = curSum;\\n        }\\n        //=====================\\n        long min = 0;\\n        slow = 0;\\n        fast = 0;\\n        curSum = 0;\\n        while(fast<arr.length){\\n            curSum+=arr[fast];\\n            if(curSum<min){\\n                min = curSum;\\n            }\\n            while(curSum>0&&slow<=fast){\\n                curSum -= arr[slow];\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        if(curSum<min){\\n            min = curSum;\\n        }\\n        //===============================\\n        long leftMin = 0;\\n        long rightMax = 0;\\n        curSum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            curSum += arr[i];\\n            if(curSum< leftMin){\\n                leftMin = curSum;\\n            }\\n            if(curSum>rightMax){\\n                rightMax = curSum;\\n            }\\n        }\\n        //==============================\\n        long rightMin = 0;\\n        long leftMax = 0;\\n        curSum = 0;\\n        for(int i=arr.length-1;i>=0;i--){\\n            curSum+=arr[i];\\n            if(curSum<rightMin){\\n                rightMin = curSum;\\n            }\\n            if(curSum>leftMax){\\n                leftMax = curSum;\\n            }\\n        }\\n        //===============================\\n        leftMax = Math.max(leftMax, sum-leftMin);\\n        rightMax = Math.max(rightMax, sum-rightMin);\\n        max = Math.max(max, sum-min);\\n        max = Math.max(max, sum*k);\\n        max = Math.max(max, (sum*(k-2))+leftMax+rightMax);\\n        max = Math.max(max, (sum*(k-1))+leftMax);\\n        max = Math.max(max, (sum*(k-1))+rightMax);\\n        return (int)(max%(1000000007));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429692,
                "title": "c-kadane-s-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int M = pow(10, 9) + 7;\\n    \\n    int Kadane(vector<int>& arr)\\n    {\\n        long csum = arr[0];\\n        long osum = arr[0];\\n        \\n        for(int i=1; i<arr.size(); i++)\\n        {\\n            csum = max(csum + arr[i], (long)arr[i]);\\n            osum = max(csum, osum);\\n        }\\n        \\n        return osum;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) \\n    {\\n        int osize = arr.size();\\n        \\n        if(arr.empty() || k==0)\\n            return 0;\\n        \\n        if(arr.size() == 1)\\n            return arr[1];\\n        \\n        long sum = 0; //sum of the array\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            sum+=arr[i];\\n        \\n        if(k == 1)\\n            return Kadane(arr);\\n        \\n        //for K==2\\n        \\n        arr.resize(2*arr.size());\\n      \\n        for(int i=0; i<osize; i++)\\n           arr[osize + i] = arr[i];\\n        \\n        int Kres = Kadane(arr);\\n        \\n        if(Kres < 0)\\n            return 0; //length of subarray is zero\\n        \\n        else\\n        {\\n            if(sum > 0)\\n                return (Kres + (k-2)*sum)%M;\\n            \\n            else\\n                return Kres%M;\\n        }\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int M = pow(10, 9) + 7;\\n    \\n    int Kadane(vector<int>& arr)\\n    {\\n        long csum = arr[0];\\n        long osum = arr[0];\\n        \\n        for(int i=1; i<arr.size(); i++)\\n        {\\n            csum = max(csum + arr[i], (long)arr[i]);\\n            osum = max(csum, osum);\\n        }\\n        \\n        return osum;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) \\n    {\\n        int osize = arr.size();\\n        \\n        if(arr.empty() || k==0)\\n            return 0;\\n        \\n        if(arr.size() == 1)\\n            return arr[1];\\n        \\n        long sum = 0; //sum of the array\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            sum+=arr[i];\\n        \\n        if(k == 1)\\n            return Kadane(arr);\\n        \\n        //for K==2\\n        \\n        arr.resize(2*arr.size());\\n      \\n        for(int i=0; i<osize; i++)\\n           arr[osize + i] = arr[i];\\n        \\n        int Kres = Kadane(arr);\\n        \\n        if(Kres < 0)\\n            return 0; //length of subarray is zero\\n        \\n        else\\n        {\\n            if(sum > 0)\\n                return (Kres + (k-2)*sum)%M;\\n            \\n            else\\n                return Kres%M;\\n        }\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382383,
                "title": "we-just-need-handle-k-2",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    static int mod;\\n\\n    int kConcatenationMaxSum(const vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int64_t sum = accumulate(arr.begin(), arr.end(), 0);\\n        vector<int> buf;\\n        buf.reserve(n * 2);\\n        copy(arr.begin(), arr.end(), back_inserter(buf));\\n        copy(arr.begin(), arr.end(), back_inserter(buf));\\n        if (k == 1) return h(arr);\\n        if (k == 2) return h(buf);\\n        if (sum <= 0) return h(buf);\\n        return ((k - 2) * (sum % mod) + h(buf)) % mod;\\n    }\\n\\n    int h(const vector<int>& arr) {\\n        int64_t res = 0, sofar = 0;\\n        for (int i : arr) {\\n            sofar = max((int64_t)0, sofar + i);\\n            res = max(res, sofar);\\n        }\\n        return res % mod;\\n    }\\n};\\n\\nint Solution::mod = 1e9 + 7;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    static int mod;\\n\\n    int kConcatenationMaxSum(const vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int64_t sum = accumulate(arr.begin(), arr.end(), 0);\\n        vector<int> buf;\\n        buf.reserve(n * 2);\\n        copy(arr.begin(), arr.end(), back_inserter(buf));\\n        copy(arr.begin(), arr.end(), back_inserter(buf));\\n        if (k == 1) return h(arr);\\n        if (k == 2) return h(buf);\\n        if (sum <= 0) return h(buf);\\n        return ((k - 2) * (sum % mod) + h(buf)) % mod;\\n    }\\n\\n    int h(const vector<int>& arr) {\\n        int64_t res = 0, sofar = 0;\\n        for (int i : arr) {\\n            sofar = max((int64_t)0, sofar + i);\\n            res = max(res, sofar);\\n        }\\n        return res % mod;\\n    }\\n};\\n\\nint Solution::mod = 1e9 + 7;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545582,
                "title": "using-one-kadane-s-algo-function-only-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int>& a){\\n        \\n        int ans = 0;\\n        \\n        int curr = 0;\\n        \\n        for(auto i:a){\\n            \\n            curr += i;\\n            \\n            if(curr<0)\\n                curr = 0;\\n            \\n            ans = max(ans,curr);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& a, int k) {\\n        \\n        long sum = accumulate(a.begin(),a.end(),0);\\n        \\n        long ans = 0;\\n        \\n        int n = a.size();\\n        \\n        if(k == 1){\\n            \\n            ans = kadane(a) % 1000000007;\\n        \\n        }else{\\n            \\n            vector<int> b(n*2);\\n            \\n            for(int i = 0 ; i < b.size() ; i++)\\n                b[i] = a[i%n];\\n            \\n            ans = kadane(b)%1000000007;\\n            \\n            if(sum >= 0)\\n                 ans=(ans + (k-2)*sum)%1000000007;\\n            \\n        }\\n        \\n        if(ans<0)return 0;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int>& a){\\n        \\n        int ans = 0;\\n        \\n        int curr = 0;\\n        \\n        for(auto i:a){\\n            \\n            curr += i;\\n            \\n            if(curr<0)\\n                curr = 0;\\n            \\n            ans = max(ans,curr);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& a, int k) {\\n        \\n        long sum = accumulate(a.begin(),a.end(),0);\\n        \\n        long ans = 0;\\n        \\n        int n = a.size();\\n        \\n        if(k == 1){\\n            \\n            ans = kadane(a) % 1000000007;\\n        \\n        }else{\\n            \\n            vector<int> b(n*2);\\n            \\n            for(int i = 0 ; i < b.size() ; i++)\\n                b[i] = a[i%n];\\n            \\n            ans = kadane(b)%1000000007;\\n            \\n            if(sum >= 0)\\n                 ans=(ans + (k-2)*sum)%1000000007;\\n            \\n        }\\n        \\n        if(ans<0)return 0;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392313,
                "title": "k-concatenation-maximum-sum",
                "content": "public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum +=arr[i];\\n        }\\n        int ans=0;\\n        if(k==1){\\n             ans=(int)(kadane(arr)%1000000007);\\n            return Math.max(ans,0);\\n        }\\n           \\n        int a[]=new int[2*arr.length];\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++){\\n            a[i]=a[i+n]=arr[i];\\n        }\\n        if(sum<0){\\n            \\n            ans=(int)(kadane(a)%1000000007);\\n            return Math.max(ans,0);\\n        }else{\\n            ans=(int)((kadane(a)+(k-2)*sum)%1000000007);\\n            return Math.max(ans,0);\\n        }\\n    }\\n    public long kadane(int a[]){\\n        long curBest=a[0], overallBest=a[0];\\n        for(int i=1;i<a.length;i++){\\n            if(curBest>=0){\\n                curBest =curBest+a[i];\\n            }\\n            else{\\n                curBest =a[i];\\n            }\\n            overallBest=Math.max(overallBest,curBest);\\n        }\\n        return overallBest;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum +=arr[i];\\n        }\\n        int ans=0;\\n        if(k==1){\\n             ans=(int)(kadane(arr)%1000000007);\\n            return Math.max(ans,0);\\n        }\\n           \\n        int a[]=new int[2*arr.length];\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++){\\n            a[i]=a[i+n]=arr[i];\\n        }\\n        if(sum<0){\\n            \\n            ans=(int)(kadane(a)%1000000007);\\n            return Math.max(ans,0);\\n        }else{\\n            ans=(int)((kadane(a)+(k-2)*sum)%1000000007);\\n            return Math.max(ans,0);\\n        }\\n    }\\n    public long kadane(int a[]){\\n        long curBest=a[0], overallBest=a[0];\\n        for(int i=1;i<a.length;i++){\\n            if(curBest>=0){\\n                curBest =curBest+a[i];\\n            }\\n            else{\\n                curBest =a[i];\\n            }\\n            overallBest=Math.max(overallBest,curBest);\\n        }\\n        return overallBest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1201609,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxSubarray(self, A):\\n        if not A:\\n            return 0\\n        curSum = maxSum = A[0]\\n        for i in range(1,len(A)):\\n            curSum = max(A[i], curSum + A[i])\\n            maxSum = max(curSum, maxSum)\\n        \\n        return max(maxSum,0)\\n        \\n    def kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        arrSum = sum(arr)\\n        MOD = (10**9 + 7)\\n        if k == 1:\\n            return self.maxSubarray(arr)%MOD\\n        if k == 2:\\n            return self.maxSubarray(2*arr)%MOD\\n        if k > 2 and arrSum > 0:\\n            return (self.maxSubarray(arr+arr) + (k-2)*arrSum)%MOD\\n        else:\\n            return self.maxSubarray(2*arr)%MOD\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubarray(self, A):\\n        if not A:\\n            return 0\\n        curSum = maxSum = A[0]\\n        for i in range(1,len(A)):\\n            curSum = max(A[i], curSum + A[i])\\n            maxSum = max(curSum, maxSum)\\n        \\n        return max(maxSum,0)\\n        \\n    def kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        arrSum = sum(arr)\\n        MOD = (10**9 + 7)\\n        if k == 1:\\n            return self.maxSubarray(arr)%MOD\\n        if k == 2:\\n            return self.maxSubarray(2*arr)%MOD\\n        if k > 2 and arrSum > 0:\\n            return (self.maxSubarray(arr+arr) + (k-2)*arrSum)%MOD\\n        else:\\n            return self.maxSubarray(2*arr)%MOD\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034314,
                "title": "java-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/48140766-b7ba-4b83-95d8-70ff24c9d228_1611565852.2842824.png)\\n\\n\\nclass Solution {\\n    \\n\\tpublic int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        // Method : Using Kedane\\'s Algorithm\\n        // Main task is to find this positive part ( this will be our max sum )\\n        \\n        /* \\n         * Case 1 : sum of array is positive\\n         * Ans = (k-2)*sum + Kedanes(2 arrays joined end to end)\\n         * Because (k-2)*sum will be a positive part so adding it will def increase our total sum\\n         * And Kedanes(2 arrays joined end to end) is used to find the sum when we discard the \\n         * negative part from left end of one array, and negative part from right end from another array\\n         */\\n        \\n        /*\\n         * Case 2 : sum of array is negative\\n         * Ans = Kedanes(2 arrays joined end to end)\\n         */\\n\\n        int MOD = 1_000_000_007;\\n\\n        if(k == 1) return kedanes(arr, 1);\\n        else{\\n            \\n            long sum = 0;\\n            for(int val:arr) sum += val;\\n            \\n            if(sum>=0) return (int)(((k-2)*sum)%MOD + kedanes(arr, 2)); \\n            else return kedanes(arr, 2);\\n            \\n        }\\n        \\n    }\\n    \\n    public int kedanes(int[] nums, int ch) {\\n        \\n        int MOD = 1_000_000_007;\\n        long cmax = 0, omax = 0;\\n        if(ch == 1){\\n            for(int i=0;i<nums.length;i++){\\n                if(cmax<0) cmax = nums[i]; \\n                else cmax += nums[i]; \\n                omax = Math.max(omax, cmax); \\n            }   \\n        }else{\\n            for(int i=0;i<2*nums.length;i++){\\n                int x = (i%nums.length);\\n                if(cmax<0) cmax = nums[x]; \\n                else cmax += nums[x]; \\n                omax = Math.max(omax, cmax); \\n            }  \\n        }      \\n        \\n        return (int)(omax%MOD);\\n    }\\n}\\n\\n\\nRefer [this ](https://leetcode.com/problems/maximum-subarray/discuss/1034276/2-Java-Solutions-With-explanation) for an explanation to kedane\\'s algorithm.",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        // Method : Using Kedane\\'s Algorithm\\n        // Main task is to find this positive part ( this will be our max sum )\\n        \\n        /* \\n         * Case 1 : sum of array is positive\\n         * Ans = (k-2)*sum + Kedanes(2 arrays joined end to end)\\n         * Because (k-2)*sum will be a positive part so adding it will def increase our total sum\\n         * And Kedanes(2 arrays joined end to end) is used to find the sum when we discard the \\n         * negative part from left end of one array, and negative part from right end from another array\\n         */\\n        \\n        /*\\n         * Case 2 : sum of array is negative\\n         * Ans = Kedanes(2 arrays joined end to end)\\n         */\\n\\n        int MOD = 1_000_000_007;\\n\\n        if(k == 1) return kedanes(arr, 1);\\n        else{\\n            \\n            long sum = 0;\\n            for(int val:arr) sum += val;\\n            \\n            if(sum>=0) return (int)(((k-2)*sum)%MOD + kedanes(arr, 2)); \\n            else return kedanes(arr, 2);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 890661,
                "title": "java-90-easy-kadane-with-comments",
                "content": "\\t\\t 3cases \\n\\t\\t 1) if k==1 return kadane of array\\n\\t\\t 2) if sum of array>0 return kadane of 2 array + sum*(k-2)\\n\\t\\t 3) if sum < 0 return kadane of 2 array\\n\\t\\t \\n\\t\\t \\n\\t\\t public int kConcatenationMaxSum(int[] arr, int k) {\\n\\t\\t //case 1 when k==1\\n\\t\\t\\tif(k==1)\\n\\t\\t\\t\\treturn kadanes(arr);\\n\\t\\t\\t\\t\\n\\t\\t\\tlong sum=0;\\n\\t\\t\\tfor(int ele:arr)\\n\\t\\t\\t\\tsum+=ele;\\n\\t\\t\\t\\t\\n\\t\\t\\tint[] kd=new int[2*arr.length];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<kd.length;i++)\\n\\t\\t\\t\\tkd[i]=arr[i%arr.length];\\n\\t\\t\\t\\t\\n\\t\\t\\tlong ans=0;\\n\\t\\t\\t\\n\\t\\t\\tif(sum<=0){            //case 2\\n\\t\\t\\t\\t ans= kadanes(kd);\\n\\t\\t\\t}else{                      //case 3\\n\\t\\t\\t\\tans= kadanes(kd)+(k-2)*sum;\\n\\t\\t\\t}\\n\\t\\t\\tif(ans<0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn (int)(ans%(1000000007));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// basic kadane code\\n\\t\\t\\n\\t\\tpublic int kadanes(int[] arr){\\n\\t\\t\\tint sum=0,ans=Integer.MIN_VALUE;\\n\\t\\t\\tfor(int ele:arr){\\n\\t\\t\\t\\tsum+=ele;\\n\\t\\t\\t\\tif(ans<sum)\\n\\t\\t\\t\\t\\tans=sum;\\n\\t\\t\\t\\tif(sum<0)\\n\\t\\t\\t\\t\\tsum=0;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\t 3cases \\n\\t\\t 1) if k==1 return kadane of array\\n\\t\\t 2) if sum of array>0 return kadane of 2 array + sum*(k-2)\\n\\t\\t 3) if sum < 0 return kadane of 2 array\\n\\t\\t \\n\\t\\t \\n\\t\\t public int kConcatenationMaxSum(int[] arr, int k) {\\n\\t\\t //case 1 when k==1\\n\\t\\t\\tif(k==1)\\n\\t\\t\\t\\treturn kadanes(arr);\\n\\t\\t\\t\\t\\n\\t\\t\\tlong sum=0;\\n\\t\\t\\tfor(int ele:arr)\\n\\t\\t\\t\\tsum+=ele;\\n\\t\\t\\t\\t\\n\\t\\t\\tint[] kd=new int[2*arr.length];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<kd.length;i++)\\n\\t\\t\\t\\tkd[i]=arr[i%arr.length];\\n\\t\\t\\t\\t\\n\\t\\t\\tlong ans=0;\\n\\t\\t\\t\\n\\t\\t\\tif(sum<=0){            //case 2\\n\\t\\t\\t\\t ans= kadanes(kd);\\n\\t\\t\\t}else{                      //case 3\\n\\t\\t\\t\\tans= kadanes(kd)+(k-2)*sum;\\n\\t\\t\\t}\\n\\t\\t\\tif(ans<0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn (int)(ans%(1000000007));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// basic kadane code\\n\\t\\t\\n\\t\\tpublic int kadanes(int[] arr){\\n\\t\\t\\tint sum=0,ans=Integer.MIN_VALUE;\\n\\t\\t\\tfor(int ele:arr){\\n\\t\\t\\t\\tsum+=ele;\\n\\t\\t\\t\\tif(ans<sum)\\n\\t\\t\\t\\t\\tans=sum;\\n\\t\\t\\t\\tif(sum<0)\\n\\t\\t\\t\\t\\tsum=0;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 864599,
                "title": "cpp-beats-98",
                "content": "\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        long long int n=arr.size(),i;\\n        long long int x=0;\\n        for(i=0;i<n;i++)\\n            x+=arr[i];\\n        //max sum from front;\\n        long long int mod=1e9+7;\\n        long long int maxifront=0;\\n        long long int maxisofar=0;\\n        int start=0,end=0;\\n        maxisofar=0;\\n        long long int maxi=0;\\n                for(i=0;i<n;i++){\\n            maxisofar+=arr[i];\\n            if(maxi<maxisofar)\\n                maxi=maxisofar;\\n            if(maxisofar<0)\\n                maxisofar=0;\\n        \\n        }\\n        \\n        if(k==1)\\n            return maxi%mod;\\n        maxisofar=0;\\n        for(i=0;i<n;i++){\\n            maxisofar+=arr[i];\\n            if(maxifront<maxisofar)\\n                maxifront=maxisofar,end=i;\\n        \\n        }\\n        long long int maxiback=0;\\n         maxisofar=0;\\n        \\n            for(i=n-1;i>=0;i--){\\n               \\n            maxisofar+=arr[i];\\n            if(maxiback<maxisofar)\\n                maxiback=maxisofar;\\n            }\\n        \\n        long long int ans=0;\\n        //cout<<start<<end<<endl;\\n      //cout<<x<<maxifront<<maxiback<<endl;\\n        if(x>0)\\n        {\\n            int val=k-2;\\n            while(val--){\\n                ans+=x;\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=maxiback;\\n        ans=ans%mod;\\n        ans+=maxifront;\\n        ans=ans%mod;\\n       // cout<<maxi;\\n        ans=max(ans,maxi);\\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        long long int n=arr.size(),i;\\n        long long int x=0;\\n        for(i=0;i<n;i++)\\n            x+=arr[i];\\n        //max sum from front;\\n        long long int mod=1e9+7;\\n        long long int maxifront=0;\\n        long long int maxisofar=0;\\n        int start=0,end=0;\\n        maxisofar=0;\\n        long long int maxi=0;\\n                for(i=0;i<n;i++){\\n            maxisofar+=arr[i];\\n            if(maxi<maxisofar)\\n                maxi=maxisofar;\\n            if(maxisofar<0)\\n                maxisofar=0;\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 660078,
                "title": "c-simple-kadane-algorithm-with-explanation",
                "content": "Kadane Algo - Complexity O(size of array) But maxm size array we can make is of order 10^7\\nSo according to constraints, we cannot duplicate the array k times and apply Kadane\\nSay arr = [1,-2,1], k = 5 \\nApproach-\\n1. Duplicate the given array. \\n-- So duplicated array will be [1 -2 1 1 -2 1]\\n\\n2. Apply Kadane on the duplicated array. Here it will give maxm subarray sum as 2(1 from first half+ 1 from sec half)\\n--The maximum subarray sum can be constituted with elements from two possible ways\\n---Way 1:From first two duplicates [1 -2 1][1 -2 1]..(k-2) duplicates\\n---Way 2: From all the duplicates. [1 -2 1]...(k-2) duplicates..[1 -2 -1]\\n\\n3. Find sum of all elements of given array. Here sum = 1-2+1=0\\n4. if sum>0 then result= Result of step 2 + (k-2) * sum          (Way 2 of step 2)\\n-- else result=sum                                                                   (Way 1 of step 2)\\n---So here result=2                            \\n\\nclass Solution {\\npublic:\\n\\n    long long int kadane(vector<int>& a)\\n    {\\n        long long int cs=0;long long int ms=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            cs+=a[i];\\n            ms=max(ms,cs);\\n            if(cs<0) cs=0;\\n        }\\n        return ms;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n     int mod=1000000007;\\n     if(k==1) return kadane(arr)%mod;\\n     int n=arr.size();\\n     vector<int>a(n*2);\\n     long long int sum=0;\\n     //Duplicating array and finding sum of array\\n     for(int i=0;i<n;i++) {a[i]=arr[i];sum+=arr[i];}\\n     for(int i=n;i<2*n;i++) a[i]=arr[i-n];\\n     \\n     long long int res=kadane(a)%mod;\\n     if(sum>0) return res+((k-2)*sum)%mod;\\n     return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long long int kadane(vector<int>& a)\\n    {\\n        long long int cs=0;long long int ms=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            cs+=a[i];\\n            ms=max(ms,cs);\\n            if(cs<0) cs=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 566690,
                "title": "java-discussion-of-cases",
                "content": "```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        /*\\n        If k = 1, the problem is not hard to solve in O(N) time O(1) space with Kadane Algorithm\\n       \\n        Considering the cases for k > 1:\\n        \\n        1) If the sum of arr < 0:\\n        1.1) If all the elements are negative, return 0;\\n        1.2) Kadane algorithm result for k=1\\n        1.3) max(max_prefix_sum, 0) + max(max_suffix_sum, 0)\\n        \\n        2) If the sum of arr >= 0:\\n        2.1) And the first and last elem > 0, the result is sum(arr) * k\\n        2.2) But eitehr the first or last elem is negative, \\n        thus we have to exclude those margin elements, e.g. [-1,4,-2] k=3, \\n        we should remove -1 from the begininng and -2 from the end of [-1,4,-2,-1,4,-2,-1,4,-2]. \\n        So it is (k-2) * sum(arr) + max_prefix_sum + max_suffix_sum\\n        */\\n        \\n        int mod = (int) 1e9 + 7;\\n        \\n        int n = arr.length;\\n\\t\\tlong maxsub = arr[0], cursub = arr[0]; // subarray sum\\n        long maxpre = arr[0], curpre = arr[0]; // prefix sum\\n        long maxsuf = arr[n-1], cursuf = arr[n-1]; // suffix sum\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (cursub > 0) cursub = arr[i] + cursub;\\n            else cursub = arr[i]; \\n            maxsub = Math.max(cursub, maxsub); // Kadane algorithm with O(1) space\\n\\t\\t\\tcurpre += arr[i];\\n            maxpre = Math.max(maxpre, curpre);\\n        }\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n            cursuf += arr[i];\\n            maxsuf = Math.max(maxsuf, cursuf);\\n        }\\n        \\n        if (k == 1) return (int) (maxsub % mod);\\n        else if (maxsub < 0) return 0;  // all elements are negative\\n        \\n        else {\\n            long sums = curpre;\\n            long res1 = sums * k;\\n            long res2 = Math.max(0, sums * (k-2)) + Math.max(0, maxpre) + Math.max(0, maxsuf); // combine case 1.3) and 2.2)\\n            long res3 = maxsub;\\n            \\n            return (int) (Math.max(res1, Math.max(res2, res3)) % mod);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        /*\\n        If k = 1, the problem is not hard to solve in O(N) time O(1) space with Kadane Algorithm\\n       \\n        Considering the cases for k > 1:\\n        \\n        1) If the sum of arr < 0:\\n        1.1) If all the elements are negative, return 0;\\n        1.2) Kadane algorithm result for k=1\\n        1.3) max(max_prefix_sum, 0) + max(max_suffix_sum, 0)\\n        \\n        2) If the sum of arr >= 0:\\n        2.1) And the first and last elem > 0, the result is sum(arr) * k\\n        2.2) But eitehr the first or last elem is negative, \\n        thus we have to exclude those margin elements, e.g. [-1,4,-2] k=3, \\n        we should remove -1 from the begininng and -2 from the end of [-1,4,-2,-1,4,-2,-1,4,-2]. \\n        So it is (k-2) * sum(arr) + max_prefix_sum + max_suffix_sum\\n        */\\n        \\n        int mod = (int) 1e9 + 7;\\n        \\n        int n = arr.length;\\n\\t\\tlong maxsub = arr[0], cursub = arr[0]; // subarray sum\\n        long maxpre = arr[0], curpre = arr[0]; // prefix sum\\n        long maxsuf = arr[n-1], cursuf = arr[n-1]; // suffix sum\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (cursub > 0) cursub = arr[i] + cursub;\\n            else cursub = arr[i]; \\n            maxsub = Math.max(cursub, maxsub); // Kadane algorithm with O(1) space\\n\\t\\t\\tcurpre += arr[i];\\n            maxpre = Math.max(maxpre, curpre);\\n        }\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n            cursuf += arr[i];\\n            maxsuf = Math.max(maxsuf, cursuf);\\n        }\\n        \\n        if (k == 1) return (int) (maxsub % mod);\\n        else if (maxsub < 0) return 0;  // all elements are negative\\n        \\n        else {\\n            long sums = curpre;\\n            long res1 = sums * k;\\n            long res2 = Math.max(0, sums * (k-2)) + Math.max(0, maxpre) + Math.max(0, maxsuf); // combine case 1.3) and 2.2)\\n            long res3 = maxsub;\\n            \\n            return (int) (Math.max(res1, Math.max(res2, res3)) % mod);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466307,
                "title": "simplest-1-pass-solution-o-1-space-very-easy-to-understand",
                "content": "```\\n// Runtime: O(N)\\n// Space: O(1) excluding inputs\\n// Very simple algo.\\n// The best subarray of the expanded arr must be one of the following patterns:\\n// 1) [...S2][...]...[...][S1...] for K >= 2\\n// 2) [...S2][...]...[...] for K >= 2\\n// 3) [...maxsum...] for K==1\\n// where :\\n//  each [] denotes arr and \\n//  maxsum is the max sum of a sequence within arr\\n//  S2 is the best sum of a sequence ending at the last index\\n//  S1 is the best sum of a sequence starting at 0\\n// So we just calculate the max sum of each pattern and viola!\\nclass Solution {\\npublic:\\n    inline static constexpr int mod = 1e9+7;\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int64_t sum1 = 0;\\n        int64_t sum2 = 0;\\n        int64_t sum1best = 0; // S1\\n        int64_t sum2best = 0; // S2\\n        int64_t cursum = 0;\\n        int64_t maxsum = 0;\\n        for (int i=0;i<arr.size();i++){\\n            sum1 += arr[i];\\n            sum2 += arr[arr.size()-1-i];\\n            sum1best = max(sum1best, sum1);\\n            sum2best = max(sum2best, sum2);\\n            cursum = max((int64_t)0, cursum + arr[i]);\\n            maxsum = max(maxsum, cursum);\\n        }\\n         \\n        int64_t ans = max(maxsum, sum2best  + (k-1)*sum1);\\n        if (k >= 2)\\n            ans = max(ans, sum1best + sum2best  + (k-2)*max((int64_t)0,sum1));\\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: O(N)\\n// Space: O(1) excluding inputs\\n// Very simple algo.\\n// The best subarray of the expanded arr must be one of the following patterns:\\n// 1) [...S2][...]...[...][S1...] for K >= 2\\n// 2) [...S2][...]...[...] for K >= 2\\n// 3) [...maxsum...] for K==1\\n// where :\\n//  each [] denotes arr and \\n//  maxsum is the max sum of a sequence within arr\\n//  S2 is the best sum of a sequence ending at the last index\\n//  S1 is the best sum of a sequence starting at 0\\n// So we just calculate the max sum of each pattern and viola!\\nclass Solution {\\npublic:\\n    inline static constexpr int mod = 1e9+7;\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int64_t sum1 = 0;\\n        int64_t sum2 = 0;\\n        int64_t sum1best = 0; // S1\\n        int64_t sum2best = 0; // S2\\n        int64_t cursum = 0;\\n        int64_t maxsum = 0;\\n        for (int i=0;i<arr.size();i++){\\n            sum1 += arr[i];\\n            sum2 += arr[arr.size()-1-i];\\n            sum1best = max(sum1best, sum1);\\n            sum2best = max(sum2best, sum2);\\n            cursum = max((int64_t)0, cursum + arr[i]);\\n            maxsum = max(maxsum, cursum);\\n        }\\n         \\n        int64_t ans = max(maxsum, sum2best  + (k-1)*sum1);\\n        if (k >= 2)\\n            ans = max(ans, sum1best + sum2best  + (k-2)*max((int64_t)0,sum1));\\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442894,
                "title": "key-observation-to-solve-this-problem",
                "content": "We need the solve a function:**F(A, K)**\\nwhat is its realtion with **F(A, K-1)**?\\na simple observation is that F(A, K) >= F(A, K-1).\\nSo when will F(A, K) > F(A, K-1)?\\n**key observation here**: THe necessary condition\\uFF08NOTE:not sufficient) is that all total K arrays must be utilized to make it greater than F(A, K-1).\\n\\npython code:\\n```\\ndef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\tdef mss(arr):\\n\\t\\tacc = res = 0\\n\\t\\tfor n in arr:\\n\\t\\t\\tacc += n\\n\\t\\t\\tif acc < 0:\\n\\t\\t\\t\\tacc = 0\\n\\t\\t\\tres = max(acc, res)\\n\\t\\treturn res\\n\\tr1, r2 = mss(arr), mss(arr * 2)\\n\\tif k == 1:\\n\\t\\treturn r1\\n\\telse:\\n\\t\\treturn max(r2, sum(arr) * k - (sum(arr) - r1)) %(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\tdef mss(arr):\\n\\t\\tacc = res = 0\\n\\t\\tfor n in arr:\\n\\t\\t\\tacc += n\\n\\t\\t\\tif acc < 0:\\n\\t\\t\\t\\tacc = 0\\n\\t\\t\\tres = max(acc, res)\\n\\t\\treturn res\\n\\tr1, r2 = mss(arr), mss(arr * 2)\\n\\tif k == 1:\\n\\t\\treturn r1\\n\\telse:\\n\\t\\treturn max(r2, sum(arr) * k - (sum(arr) - r1)) %(10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383062,
                "title": "javascript-o-n-59ms-solution-with-comments",
                "content": "At most, 2 passes of `arr` are required.\\n\\n> **With commentary:**\\n\\n```js\\nvar kConcatenationMaxSum = function(arr, k) {\\n  var MOD = 1000000007;\\n  var totalSum = 0;\\n  var localMax = 0;\\n  var globalMax = 0;\\n  \\n  /**\\n   * First loop: do Kadane\\'s algorithm for max subarray sum\\n   * with addition of calculating total sum for next steps.\\n   * \\n   * For Kadane\\'s, @see: leetcode.com/problems/maximum-subarray/\\n   */\\n  arr.forEach((num) => {\\n    totalSum += num;\\n    localMax = Math.max(num, localMax + num);\\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  /**\\n   * If k is 1, we don\\'t need to check for second concat.\\n   * Or if globalMax is still 0, all numbers were negative,\\n   * so max sum will be subarray of length 0 = 0.\\n   */\\n  if (k === 1 || globalMax === 0) {\\n    return globalMax % MOD;\\n  }\\n  \\n  /**\\n   * Calculate max sum of concatenating twice for case [1, -2, 1]\\n   * where max sum is formed from end of first with beginning of second.\\n   */\\n  arr.forEach((num) => {\\n    localMax = Math.max(num, localMax + num); \\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  /**\\n   * After 2x concatenations, the only increments we can gain\\n   * are from the total sum of the array, if total sum is positive.\\n   *\\n   * @example: [1,-2, 1, 1], k=4.\\n   * Total sum is 1 and concat 2x [1,-2,1,1,1,-2,1,1] max is 3.\\n   * From max 2x concat=3, each successive concat k after 2, we gain totalSum 1.\\n   * i.e max2x + (k-2)*totalSum = (3 + (4-2)*1) = (3+ ((2)*1) = 5)\\n   */\\n  if (totalSum > 0) {\\n    globalMax += (k - 2) * totalSum;\\n  }\\n  \\n  return globalMax % MOD;\\n};\\n```\\n\\n---\\n\\n> **Shorter commentary for code legibility:**\\n\\n```js\\nvar MOD = 1000000007;\\n\\nvar kConcatenationMaxSum = function(arr, k) {\\n  var totalSum = 0;\\n  var localMax = 0;\\n  var globalMax = 0;\\n  \\n  // Kadane\\'s with addition of calc total sum.\\n  arr.forEach((num) => {\\n    totalSum += num;\\n    localMax = Math.max(num, localMax + num);\\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  // Don\\'t need second concat if all negative\\n  if (k === 1 || globalMax === 0) {\\n    return globalMax % MOD;\\n  }\\n  \\n  // Calc max subarray sum with k=2\\n  arr.forEach((num) => {\\n    localMax = Math.max(num, localMax + num); \\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  // Answer is maxSubSumK2 + (totalSum + (k-2)) if totalSum > 0\\n  return globalMax + Math.max((k - 2) * totalSum, 0) % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar kConcatenationMaxSum = function(arr, k) {\\n  var MOD = 1000000007;\\n  var totalSum = 0;\\n  var localMax = 0;\\n  var globalMax = 0;\\n  \\n  /**\\n   * First loop: do Kadane\\'s algorithm for max subarray sum\\n   * with addition of calculating total sum for next steps.\\n   * \\n   * For Kadane\\'s, @see: leetcode.com/problems/maximum-subarray/\\n   */\\n  arr.forEach((num) => {\\n    totalSum += num;\\n    localMax = Math.max(num, localMax + num);\\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  /**\\n   * If k is 1, we don\\'t need to check for second concat.\\n   * Or if globalMax is still 0, all numbers were negative,\\n   * so max sum will be subarray of length 0 = 0.\\n   */\\n  if (k === 1 || globalMax === 0) {\\n    return globalMax % MOD;\\n  }\\n  \\n  /**\\n   * Calculate max sum of concatenating twice for case [1, -2, 1]\\n   * where max sum is formed from end of first with beginning of second.\\n   */\\n  arr.forEach((num) => {\\n    localMax = Math.max(num, localMax + num); \\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  /**\\n   * After 2x concatenations, the only increments we can gain\\n   * are from the total sum of the array, if total sum is positive.\\n   *\\n   * @example: [1,-2, 1, 1], k=4.\\n   * Total sum is 1 and concat 2x [1,-2,1,1,1,-2,1,1] max is 3.\\n   * From max 2x concat=3, each successive concat k after 2, we gain totalSum 1.\\n   * i.e max2x + (k-2)*totalSum = (3 + (4-2)*1) = (3+ ((2)*1) = 5)\\n   */\\n  if (totalSum > 0) {\\n    globalMax += (k - 2) * totalSum;\\n  }\\n  \\n  return globalMax % MOD;\\n};\\n```\n```js\\nvar MOD = 1000000007;\\n\\nvar kConcatenationMaxSum = function(arr, k) {\\n  var totalSum = 0;\\n  var localMax = 0;\\n  var globalMax = 0;\\n  \\n  // Kadane\\'s with addition of calc total sum.\\n  arr.forEach((num) => {\\n    totalSum += num;\\n    localMax = Math.max(num, localMax + num);\\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  // Don\\'t need second concat if all negative\\n  if (k === 1 || globalMax === 0) {\\n    return globalMax % MOD;\\n  }\\n  \\n  // Calc max subarray sum with k=2\\n  arr.forEach((num) => {\\n    localMax = Math.max(num, localMax + num); \\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  // Answer is maxSubSumK2 + (totalSum + (k-2)) if totalSum > 0\\n  return globalMax + Math.max((k - 2) * totalSum, 0) % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382897,
                "title": "clean-python-code-with-explaination",
                "content": "\\t\\t# left: max starting from index 0 (from left)\\n        # s: sum(arr)\\n        # m: max subarray (start anywhere)\\n        # right: max starting from the right\\n\\t\\t# result = left + max(0, s) * (k-2) + right\\n        # or     = m  \\n        #        e.g. [-3,-2, 5, -1] * 2\\n\\t\\t\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\n        left = cur = s = m = 0    \\n        for num in arr:\\n            s += num\\n            left = max(left, s)\\n            \\n            cur += num\\n            m = max(m, cur)    \\n            cur = 0 if cur < 0 else cur\\n                \\n        right = cur = 0\\n        for num in arr[::-1]:\\n            cur += num\\n            right = max(right, cur)\\n            \\n        middle = max(s, 0) * (k - 2)\\n        return max(m, (left + middle + right)) % (10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\n        left = cur = s = m = 0    \\n        for num in arr:\\n            s += num\\n            left = max(left, s)\\n            \\n            cur += num\\n            m = max(m, cur)    \\n            cur = 0 if cur < 0 else cur\\n                \\n        right = cur = 0\\n        for num in arr[::-1]:\\n            cur += num\\n            right = max(right, cur)\\n            \\n        middle = max(s, 0) * (k - 2)\\n        return max(m, (left + middle + right)) % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382533,
                "title": "simple-c-solution-with-explanation",
                "content": "The basic idea is:\\n1. If the sum of the array is negative or less than zero.\\n    Then attempt to find the maximum sum subset in the concatenation of min(2, k).\\n\\t\\n2. If the sum of the array is postive.\\n    Then attempt to find the best maximum sum subset in the concatenation of min(2, k). The best subset provides the right index to start and end with, and if you can imagine to insert the (k-2) arrays in the middle.\\n\\t\\n\\tSo, If k is greater than 2, add the (k-2)*(sum of array).\\t\\n\\n\\n```\\n\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {      \\n        Int64 maxSum = 0;\\n        int len = arr.Length;\\n        \\n        // Find the total sum of the array.\\n        Int64 arrSum = 0;    \\n        for(int i=0;i<len;i++)\\n        {\\n            arrSum += arr[i];\\n        }\\n        \\n        maxSum = Math.Max(arrSum, maxSum);\\n        \\n        // Get the minimum, to consider the case when there is only one array.\\n        int  loops = Math.Min(2, k);\\n        \\n        // Find the max sub array, when two arrays are concatenated.\\n        Int64 sum=0;\\n        for(int j=0;j<len*loops;j++)\\n        {            \\n                sum += arr[j%len];\\n                if (sum>maxSum)\\n                {\\n                    maxSum = sum;\\n                }\\n            \\n            // Reset the sum if it reaches negative.\\n            if(sum<0) sum=0;\\n        }\\n        \\n        // If the indiviaul array sum is greater than 0, add k>2, and the rest of the arrary sums.\\n        if (k>2 && arrSum>0)\\n        {\\n            maxSum += (k-2)*arrSum;\\n        }   \\n        \\n        return (int)(maxSum%(1000000007));\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {      \\n        Int64 maxSum = 0;\\n        int len = arr.Length;\\n        \\n        // Find the total sum of the array.\\n        Int64 arrSum = 0;    \\n        for(int i=0;i<len;i++)\\n        {\\n            arrSum += arr[i];\\n        }\\n        \\n        maxSum = Math.Max(arrSum, maxSum);\\n        \\n        // Get the minimum, to consider the case when there is only one array.\\n        int  loops = Math.Min(2, k);\\n        \\n        // Find the max sub array, when two arrays are concatenated.\\n        Int64 sum=0;\\n        for(int j=0;j<len*loops;j++)\\n        {            \\n                sum += arr[j%len];\\n                if (sum>maxSum)\\n                {\\n                    maxSum = sum;\\n                }\\n            \\n            // Reset the sum if it reaches negative.\\n            if(sum<0) sum=0;\\n        }\\n        \\n        // If the indiviaul array sum is greater than 0, add k>2, and the rest of the arrary sums.\\n        if (k>2 && arrSum>0)\\n        {\\n            maxSum += (k-2)*arrSum;\\n        }   \\n        \\n        return (int)(maxSum%(1000000007));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382409,
                "title": "determining-slope-approach-java",
                "content": "I thought of this as a line.  Store the max sum for each of the first three runs.  If then second and third run are equal, than we know that the line is flat and we return the max from third run.  If they are different, we know it is linear y = mx + b.  Each kth term has a slope (m) or difference (3rd term - 2nd term).  Determine b from the 2nd term (1st term may be off, example in code).  Final formula would be the difference (m) * (k-2) + 2nd term.\\n\\nExample Input:\\n[1,-2,3]\\nMaxArray = [3, 5, 7] \\nThe slope (m) is 2 and b = 3.\\n\\n```\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\tint mod = 1000000007;\\n\\tint max = 0, sum = 0, j = 3;\\n\\tint[] maxArray = new int[3];\\n\\twhile (j-- > 0) {\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum = (sum + arr[i]) % mod;\\n\\t\\t\\tif (sum > max) {\\n\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t\\tif (sum < 0) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmaxArray[2-j] = max;\\n\\t}\\n    if (k < 4) return maxArray[k-1];\\n\\tif (maxArray[2] == maxArray[1]) {\\n\\t\\treturn maxArray[2];\\n\\t} else {\\n\\t\\tint dif = maxArray[2] - maxArray[1];\\n\\t\\t// use 2nd term for b instead of 1st because in some cases 1st term may not produce true b value\\n\\t\\t// Example - [10, -12, 8] k = 15\\n\\t\\t// Max per K - 10, 14, 20, 26, 32, 38... \\n\\t\\t// m = 6 and b = 2\\n\\t\\treturn (int) (((long) dif * (k-2) % mod) + maxArray[1]) % mod;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int kConcatenationMaxSum(int[] arr, int k) {\\n\\tint mod = 1000000007;\\n\\tint max = 0, sum = 0, j = 3;\\n\\tint[] maxArray = new int[3];\\n\\twhile (j-- > 0) {\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum = (sum + arr[i]) % mod;\\n\\t\\t\\tif (sum > max) {\\n\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t\\tif (sum < 0) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmaxArray[2-j] = max;\\n\\t}\\n    if (k < 4) return maxArray[k-1];\\n\\tif (maxArray[2] == maxArray[1]) {\\n\\t\\treturn maxArray[2];\\n\\t} else {\\n\\t\\tint dif = maxArray[2] - maxArray[1];\\n\\t\\t// use 2nd term for b instead of 1st because in some cases 1st term may not produce true b value\\n\\t\\t// Example - [10, -12, 8] k = 15\\n\\t\\t// Max per K - 10, 14, 20, 26, 32, 38... \\n\\t\\t// m = 6 and b = 2\\n\\t\\treturn (int) (((long) dif * (k-2) % mod) + maxArray[1]) % mod;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462644,
                "title": "python-1-liner-solution",
                "content": "# Code\\n```\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        return (max(list(accumulate(chain(*[arr]*(2-(k==1))),\\n                   lambda x,y: max(0,x+y), initial = 0))) + (k-2)*sum(arr)*(sum(arr)>0)*(k>1))%1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        return (max(list(accumulate(chain(*[arr]*(2-(k==1))),\\n                   lambda x,y: max(0,x+y), initial = 0))) + (k-2)*sum(arr)*(sum(arr)>0)*(k>1))%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316068,
                "title": "java-simple-and-short-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=0l,min=0l,max=0l;\\n        int mod=(int)1e9+7;\\n        for(int i=0;i<k && i<2;i++){\\n            for(int ele:arr){\\n                sum+=ele;\\n                max=Math.max(max,sum-min);\\n                min=Math.min(min,sum);\\n            }\\n        }\\n        max+=((k<2)?0l:((k-2)*(sum>0?(sum>>1):0)));    \\n        return (int)(max%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=0l,min=0l,max=0l;\\n        int mod=(int)1e9+7;\\n        for(int i=0;i<k && i<2;i++){\\n            for(int ele:arr){\\n                sum+=ele;\\n                max=Math.max(max,sum-min);\\n                min=Math.min(min,sum);\\n            }\\n        }\\n        max+=((k<2)?0l:((k-2)*(sum>0?(sum>>1):0)));    \\n        return (int)(max%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123291,
                "title": "kadane-algorithm-golang",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc kConcatenationMaxSum(arr []int, k int) int {\\n    var mod int = 1e9 + 7\\n    var n int = len(arr)\\n\\n    if k == 1 {\\n        return MaxSubArr(arr, n, 1) % mod\\n    }\\n\\n    sum := Sum(arr, n)\\n\\n    if sum <= 0 {\\n        return MaxSubArr(arr, n, 2) % mod\\n    }\\n\\n    ans := MaxSubArr(arr, n, 2)\\n\\n    return (ans + (k - 2) * sum) % mod\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc MaxSubArr(arr []int, n int, k int) int {\\n    sum := 0\\n    ans := 0\\n\\n    for i := 0; i < n * k; i++ {\\n        sum = max(sum + arr[i % n], 0)\\n        ans = max(sum, ans)\\n    }\\n\\n    return ans\\n}\\n\\nfunc Sum(arr []int, n int) int {\\n    sum := 0\\n\\n    for i := 0; i < n; i++ {\\n        sum += arr[i]\\n    }\\n\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc kConcatenationMaxSum(arr []int, k int) int {\\n    var mod int = 1e9 + 7\\n    var n int = len(arr)\\n\\n    if k == 1 {\\n        return MaxSubArr(arr, n, 1) % mod\\n    }\\n\\n    sum := Sum(arr, n)\\n\\n    if sum <= 0 {\\n        return MaxSubArr(arr, n, 2) % mod\\n    }\\n\\n    ans := MaxSubArr(arr, n, 2)\\n\\n    return (ans + (k - 2) * sum) % mod\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc MaxSubArr(arr []int, n int, k int) int {\\n    sum := 0\\n    ans := 0\\n\\n    for i := 0; i < n * k; i++ {\\n        sum = max(sum + arr[i % n], 0)\\n        ans = max(sum, ans)\\n    }\\n\\n    return ans\\n}\\n\\nfunc Sum(arr []int, n int) int {\\n    sum := 0\\n\\n    for i := 0; i < n; i++ {\\n        sum += arr[i]\\n    }\\n\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922288,
                "title": "it-s-a-game-of-mod-maximum-subarray-problem",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616195,
                "title": "c-short-sol-easy",
                "content": "```\\n long total = 0;\\n        for(auto next : arr) total += next;\\n        \\n        long onepass = kadane(arr);\\n        long circular = circ(arr);\\n        long startmax = start(arr);\\n        long endmax = end(arr);\\n        if(k == 1) return onepass;\\n        return max<long int>(max(onepass, circular), startmax + endmax + (k-2) * total) % 1000000007;\\n    }\\n    \\n    \\nprivate:\\n    long circ(vector<int>  arr) {\\n        int total = 0;\\n        for(auto & next : arr)  {\\n            next = -1 * next;\\n            total += next;\\n        }\\n        int temp = kadane(arr);\\n        return -1 * (total - minarray(arr));\\n        \\n    }\\n    \\n    long minarray(vector<int> arr) {\\n        int temp = kadane(arr);\\n        return temp;\\n        \\n    }\\n    long kadane(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(int i = 0 ; i < arr.size() ;i++) {\\n            sumsf += arr[i];\\n            sumsf = max(sumsf, 0);\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n    }\\n    \\n    long start(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(auto next : arr) {\\n            sumsf += next;\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n            \\n    }\\n    \\n    long end(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(int i = arr.size() -1 ; i >= 0 ; i--) {\\n            sumsf += arr[i];\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n long total = 0;\\n        for(auto next : arr) total += next;\\n        \\n        long onepass = kadane(arr);\\n        long circular = circ(arr);\\n        long startmax = start(arr);\\n        long endmax = end(arr);\\n        if(k == 1) return onepass;\\n        return max<long int>(max(onepass, circular), startmax + endmax + (k-2) * total) % 1000000007;\\n    }\\n    \\n    \\nprivate:\\n    long circ(vector<int>  arr) {\\n        int total = 0;\\n        for(auto & next : arr)  {\\n            next = -1 * next;\\n            total += next;\\n        }\\n        int temp = kadane(arr);\\n        return -1 * (total - minarray(arr));\\n        \\n    }\\n    \\n    long minarray(vector<int> arr) {\\n        int temp = kadane(arr);\\n        return temp;\\n        \\n    }\\n    long kadane(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(int i = 0 ; i < arr.size() ;i++) {\\n            sumsf += arr[i];\\n            sumsf = max(sumsf, 0);\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n    }\\n    \\n    long start(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(auto next : arr) {\\n            sumsf += next;\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n            \\n    }\\n    \\n    long end(vector<int> & arr) {\\n        int sumsf = 0;\\n        int res = 0;\\n        for(int i = arr.size() -1 ; i >= 0 ; i--) {\\n            sumsf += arr[i];\\n            res = max(res, sumsf);\\n        }\\n        return res;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2583619,
                "title": "1191-python",
                "content": "\\tclass Solution:\\n\\t\\tdef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tmod = int(1e9+7)\\n\\n\\t\\t\\tdp[0] = arr[0]\\n\\t\\t\\ttotal = arr[0]\\n\\t\\t\\tidxzero = arr[0]\\n\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tdp[i] = max(dp[i-1]+arr[i],arr[i])\\n\\t\\t\\t\\ttotal += arr[i]\\n\\t\\t\\t\\tidxzero = max(idxzero,total)\\n\\n\\n\\t\\t\\tidxlast = dp[-1]\\n\\t\\t\\tisolated = max(dp+[0])\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\treturn isolated%mod\\n\\n\\t\\t\\treturn max(isolated,idxzero+idxlast+max(0,(k-2)*total))%mod",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tmod = int(1e9+7)\\n\\n\\t\\t\\tdp[0] = arr[0]\\n\\t\\t\\ttotal = arr[0]\\n\\t\\t\\tidxzero = arr[0]\\n\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tdp[i] = max(dp[i-1]+arr[i],arr[i])\\n\\t\\t\\t\\ttotal += arr[i]\\n\\t\\t\\t\\tidxzero = max(idxzero,total)\\n\\n\\n\\t\\t\\tidxlast = dp[-1]\\n\\t\\t\\tisolated = max(dp+[0])\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\treturn isolated%mod\\n\\n\\t\\t\\treturn max(isolated,idxzero+idxlast+max(0,(k-2)*total))%mod",
                "codeTag": "Java"
            },
            {
                "id": 2546534,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==1){\\n            long ans=0L, sum=0L;\\n            for(int i=0;i<n;i++){\\n                sum+=arr[i];\\n                ans=Math.max(ans,sum);\\n                if(sum<0) sum=0;\\n            }\\n            return (int)(ans%1000000007);\\n        }else{\\n            ArrayList<Integer> ar = new ArrayList<>();\\n            for(int i=0;i<n;i++) ar.add(arr[i]);\\n            long s=0L;\\n            for(int i=0;i<n;i++) s+=ar.get(i);\\n            if(s<=0){\\n                for(int i=0;i<n;i++) ar.add(ar.get(i));\\n                long ans=0L, sum=0L;\\n                for(int i=0;i<(n*2);i++){\\n                    sum+=ar.get(i);\\n                    ans=Math.max(ans,sum);\\n                    if(sum<0) sum=0;\\n                }\\n                return (int)(ans%1000000007);\\n            }else{\\n                for(int i=0;i<n;i++) ar.add(ar.get(i));\\n                long ans=0L, sum=0L;\\n                for(int i=0;i<(n*2);i++){\\n                    sum+=ar.get(i);\\n                    ans=Math.max(ans,sum);\\n                    if(sum<0) sum=0;\\n                }\\n                for(int i=0;i<k-2;i++) ans+=s;\\n                return (int)(ans%1000000007);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==1){\\n            long ans=0L, sum=0L;\\n            for(int i=0;i<n;i++){\\n                sum+=arr[i];\\n                ans=Math.max(ans,sum);\\n                if(sum<0) sum=0;\\n            }\\n            return (int)(ans%1000000007);\\n        }else{\\n            ArrayList<Integer> ar = new ArrayList<>();\\n            for(int i=0;i<n;i++) ar.add(arr[i]);\\n            long s=0L;\\n            for(int i=0;i<n;i++) s+=ar.get(i);\\n            if(s<=0){\\n                for(int i=0;i<n;i++) ar.add(ar.get(i));\\n                long ans=0L, sum=0L;\\n                for(int i=0;i<(n*2);i++){\\n                    sum+=ar.get(i);\\n                    ans=Math.max(ans,sum);\\n                    if(sum<0) sum=0;\\n                }\\n                return (int)(ans%1000000007);\\n            }else{\\n                for(int i=0;i<n;i++) ar.add(ar.get(i));\\n                long ans=0L, sum=0L;\\n                for(int i=0;i<(n*2);i++){\\n                    sum+=ar.get(i);\\n                    ans=Math.max(ans,sum);\\n                    if(sum<0) sum=0;\\n                }\\n                for(int i=0;i<k-2;i++) ans+=s;\\n                return (int)(ans%1000000007);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400297,
                "title": "simple-solution-kadane-s-and-easy-to-understand-java-3ms-99-70-faster",
                "content": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long maxSum = 0;\\n        long curSum = 0;\\n        long sum = 0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum = (sum+arr[i]);\\n            curSum =(curSum+arr[i]);\\n            if(maxSum<curSum)\\n            {\\n                maxSum = curSum;\\n            }\\n            if(curSum<0){\\n                curSum=0;\\n            }\\n        }\\n        if(k==1)\\n        return (int) maxSum%1000000007;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            curSum =(curSum+arr[i]);\\n            if(maxSum<curSum)\\n            {\\n                maxSum = curSum;\\n            }\\n            if(curSum<0){\\n                curSum=0;\\n            }\\n        }\\n        if(sum<0)\\n            return (int) maxSum%1000000007;\\n        \\n        return(int) (maxSum+(long)((k-2)*sum)%1000000007)%1000000007;\\n        \\n    }\\n}\\n```\\nFind the sum of the array and 1st Kadanes value - maxSum\\nIf k==1 return the maxSum\\nelse\\nFind the 2nd Kadanes value - maxSum by continuing the previoust arr1\\'s value\\nNow you have Maxsub array vales for 1st two arrays Arr1,ArrK\\n\\nIf sum <0 negative : Simply return the maxArray(Arr1,ArrK) value because it the value will not increase by adding untill Kth array in negative side.\\n\\nif sum>0 positive :\\nreturn the maxSum(value for Arr1,arrK) + (k-2)(remaining array sums) i.e maxSum+(k-2)*sum\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long maxSum = 0;\\n        long curSum = 0;\\n        long sum = 0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum = (sum+arr[i]);\\n            curSum =(curSum+arr[i]);\\n            if(maxSum<curSum)\\n            {\\n                maxSum = curSum;\\n            }\\n            if(curSum<0){\\n                curSum=0;\\n            }\\n        }\\n        if(k==1)\\n        return (int) maxSum%1000000007;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            curSum =(curSum+arr[i]);\\n            if(maxSum<curSum)\\n            {\\n                maxSum = curSum;\\n            }\\n            if(curSum<0){\\n                curSum=0;\\n            }\\n        }\\n        if(sum<0)\\n            return (int) maxSum%1000000007;\\n        \\n        return(int) (maxSum+(long)((k-2)*sum)%1000000007)%1000000007;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381257,
                "title": "simple-solution-using-kadane-s",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        def kadanes(nums):\\n            curr_sum = nums[0]\\n            best_sum = nums[0]\\n\\n            for i in range(1, len(nums)):\\n                curr_sum = max(curr_sum+nums[i], nums[i])\\n                best_sum = max(curr_sum ,best_sum)\\n\\n            return best_sum\\n\\n\\n        if k == 1:\\n            return kadanes(arr) % (10**9 + 7)\\n\\n        else:\\n            sm = sum(arr)\\n\\n            if sm < 0:\\n                return kadanes(arr+arr) % (10**9 + 7) if result >= 0 else 0\\n            else:\\n                return (kadanes(arr+arr)+(k-2)*sm) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        def kadanes(nums):\\n            curr_sum = nums[0]\\n            best_sum = nums[0]\\n\\n            for i in range(1, len(nums)):\\n                curr_sum = max(curr_sum+nums[i], nums[i])\\n                best_sum = max(curr_sum ,best_sum)\\n\\n            return best_sum\\n\\n\\n        if k == 1:\\n            return kadanes(arr) % (10**9 + 7)\\n\\n        else:\\n            sm = sum(arr)\\n\\n            if sm < 0:\\n                return kadanes(arr+arr) % (10**9 + 7) if result >= 0 else 0\\n            else:\\n                return (kadanes(arr+arr)+(k-2)*sm) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264522,
                "title": "how-to-come-up-with-this-in-interview",
                "content": "this is where I fail in leetcode, I can not think of these type of solutions.. there is no pattern...this needs deep thinking .. plz help",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2248286,
                "title": "k-concatenation-maximum-sum-java-easy-kadane-s-algorithm",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(k==1){\\n            return kadane(arr);\\n        }else{\\n            long sum=0;\\n            for(int i=0;i<arr.length;i++){\\n                sum+=arr[i];\\n            }\\n            \\n            if(sum<0){\\n                int val= merge(arr);\\n                if(val<0){\\n                    return 0;\\n                }else{\\n                    return val;\\n                }\\n            }else{\\n                int val=merge(arr);\\n                return (int)(val+((k-2)*sum)%mod)%mod;\\n            }\\n        }\\n    }\\n    \\n    public int kadane(int []arr){\\n        long localMax=arr[0];\\n        long globalMax=arr[0];\\n        \\n        for(int i=1;i<arr.length;i++){\\n            localMax+=arr[i]%mod;\\n            localMax=Math.max(localMax,arr[i]);\\n            globalMax=Math.max(globalMax,localMax);\\n        }\\n        \\n        return (int)globalMax;\\n    }\\n    \\n    public int merge(int []arr){\\n        int n=arr.length;\\n        int []nums=new int[n+n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            nums[i]=arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            nums[n+i]=arr[i];\\n        }\\n        \\n       \\n        return kadane(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(k==1){\\n            return kadane(arr);\\n        }else{\\n            long sum=0;\\n            for(int i=0;i<arr.length;i++){\\n                sum+=arr[i];\\n            }\\n            \\n            if(sum<0){\\n                int val= merge(arr);\\n                if(val<0){\\n                    return 0;\\n                }else{\\n                    return val;\\n                }\\n            }else{\\n                int val=merge(arr);\\n                return (int)(val+((k-2)*sum)%mod)%mod;\\n            }\\n        }\\n    }\\n    \\n    public int kadane(int []arr){\\n        long localMax=arr[0];\\n        long globalMax=arr[0];\\n        \\n        for(int i=1;i<arr.length;i++){\\n            localMax+=arr[i]%mod;\\n            localMax=Math.max(localMax,arr[i]);\\n            globalMax=Math.max(globalMax,localMax);\\n        }\\n        \\n        return (int)globalMax;\\n    }\\n    \\n    public int merge(int []arr){\\n        int n=arr.length;\\n        int []nums=new int[n+n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            nums[i]=arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            nums[n+i]=arr[i];\\n        }\\n        \\n       \\n        return kadane(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235033,
                "title": "c-kadanes-prefix",
                "content": "```\\n/*\\n\\n there will be only 3 cases possible to get max sum if we concatenate k arrays\\nCase1: [......(max sum subarray= total1)......] , Its a case when our answer comes from 1st array only after concatenation of k such arrays\\nCase2: [.....................(max suffix sum=mx2)] [ (max prefix sum=mx1).................] , total2= mx2+mx1 , Its a case when our answer comes from starting two arrays only,\\nCase3: [..........(max suffix sum=mx2)] [........][........][..........][........][............][.........][..........]..........(k-2)times [(max prefix sum = mx2)................] , \\ntotal3= mx2+ (k-2)*sum + mx1 , \\nIts a case when our answer comes from all k arrays \\nOR total3= [ max suffix sum from 1st array + sum of all (k-2) middle arrays+ max prefixsum from last array ]\\nAns= max(all three cases)\\n\\n*/\\n\\nint mod=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        \\n        vector<int>pref(n),suff(n);\\n    \\n        pref[0]=arr[0];\\n        int mx1=pref[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+arr[i];\\n            mx1=max(mx1,pref[i]);\\n        }\\n        \\n        suff[n-1]=arr[n-1];\\n        \\n        int mx2=suff[n-1];\\n        \\n        for(int i=n-2;i>=0;i--){\\n            suff[i]=suff[i+1]+arr[i];\\n            mx2=max(mx2,suff[i]);\\n        }\\n        \\n        int sum=pref[n-1];\\n        \\n        int total1=kadans(arr);  // considering only one array\\n        \\n        if(k==1)\\n            return total1;\\n        \\n        int total2=mx1+mx2; // considering only 2 array\\n        \\n       \\n        int total3=mx1+mx2+1ll*sum*(k-2)%mod; // taking all arrays\\n\\n        \\n        return max({total1,total2,total3})%mod;\\n        \\n    }\\n    \\n    int kadans(vector<int>&arr){\\n        \\n        int temp=0;\\n        \\n        int mxsum=INT_MIN;\\n        \\n        for(int x:arr){\\n            temp=max(x,temp+x);\\n            mxsum=max(mxsum,temp);\\n            if(mxsum<0)\\n                mxsum=0;\\n        }\\n        \\n        return mxsum;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        \\n        vector<int>pref(n),suff(n);\\n    \\n        pref[0]=arr[0];\\n        int mx1=pref[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+arr[i];\\n            mx1=max(mx1,pref[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2201337,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int sum = arr[0], mx = arr[0];\\n        int n = arr.size();\\n        int64_t total = accumulate(arr.begin(), arr.end(), 0), mod = 1e9+7;\\n        for(int i=1; i<n* min(k, 2); i++){\\n            sum = max(arr[i%n], sum+arr[i%n]);\\n            mx = max(mx, sum);\\n        }\\n        \\n        return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int sum = arr[0], mx = arr[0];\\n        int n = arr.size();\\n        int64_t total = accumulate(arr.begin(), arr.end(), 0), mod = 1e9+7;\\n        for(int i=1; i<n* min(k, 2); i++){\\n            sum = max(arr[i%n], sum+arr[i%n]);\\n            mx = max(mx, sum);\\n        }\\n        \\n        return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132268,
                "title": "c-dynamic-programming-o-n-time",
                "content": "Dynamic Programming, Greedy \\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(k==1){\\n            return calMaxSum(arr, 1)%1000000007;\\n        }else{\\n            int max_sum=calMaxSum( arr, 2)%1000000007, \\n                tot=calSum( arr );\\n            if(0<tot)\\n                return max_sum+(long long)tot*(k-2)%1000000007;\\n            else\\n                return max_sum;\\n        }\\n    }\\n    \\nprotected:\\n    int calMaxSum( vector<int> & arr, int repeat){\\n        long long max_sum=0, pre_sum=0;// max of sum of subarray ending at i\\n        for( int j=0; j<repeat; j++){\\n            for( int i=0; i<arr.size(); i++){\\n                pre_sum+=arr[i];\\n                if(0<arr[i]){\\n                    if(max_sum<pre_sum)\\n                        max_sum=pre_sum;\\n                }else{\\n                    if(pre_sum<0)\\n                        pre_sum=0;\\n                }\\n            }\\n        }\\n        return max_sum%1000000007;\\n    }\\n    \\n    int calSum(vector<int> & arr){\\n        long sum=0;\\n        for( int i=0; i<arr.size(); i++)\\n            sum=(sum+arr[i])%1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(k==1){\\n            return calMaxSum(arr, 1)%1000000007;\\n        }else{\\n            int max_sum=calMaxSum( arr, 2)%1000000007, \\n                tot=calSum( arr );\\n            if(0<tot)\\n                return max_sum+(long long)tot*(k-2)%1000000007;\\n            else\\n                return max_sum;\\n        }\\n    }\\n    \\nprotected:\\n    int calMaxSum( vector<int> & arr, int repeat){\\n        long long max_sum=0, pre_sum=0;// max of sum of subarray ending at i\\n        for( int j=0; j<repeat; j++){\\n            for( int i=0; i<arr.size(); i++){\\n                pre_sum+=arr[i];\\n                if(0<arr[i]){\\n                    if(max_sum<pre_sum)\\n                        max_sum=pre_sum;\\n                }else{\\n                    if(pre_sum<0)\\n                        pre_sum=0;\\n                }\\n            }\\n        }\\n        return max_sum%1000000007;\\n    }\\n    \\n    int calSum(vector<int> & arr){\\n        long sum=0;\\n        for( int i=0; i<arr.size(); i++)\\n            sum=(sum+arr[i])%1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084994,
                "title": "c-dp-kadane-algo-easy-with-explanation",
                "content": "In this question, we can solve it by using Kadane Algorithm : \\n\\n1.for the idea of kadane algorithm, it helps us to find the longest continuous number in an array.\\n2.for the question, we can divide it as two cases. For the case one, if k = 1, just call the kadane function to find the max value.\\n3. for other cases, use accumulate function to count the sum of the the orignal array.\\n4.  and then we need to insert the copy of the original array into the array. \\n5.  if the sum is large than zero, we can just count result by adding (k-2)*sum % mod.\\n6.  Finally, return the function call of kadane(doubled array) + result(if sum < 0, whatever the k of value is(except 2), it wont affect the answer).\\n\\nThat is my sharing about this question.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    // use kadane algorithm to find the longest continuous number in an array.    \\n    long kadane (vector<int>& arr){\\n        int maxEndingHere = 0;\\n        int maxAll = 0;\\n        int size = arr.size();\\n        for(int i=0; i<size; i++){\\n            maxEndingHere += arr[i]%mod;\\n            // if the maxEndingHere is smaller than 0, we just reset it.\\n            if(maxEndingHere < 0) maxEndingHere = 0;\\n            maxAll = max(maxEndingHere, maxAll);\\n        }\\n        return maxAll;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(arr.size() == 0) return 0;\\n        int size = arr.size();\\n        // case one, k == 1, just input the result.\\n        if(k==1) return kadane(arr)%mod;\\n        \\n\\t\\t// since we want to check whether the actual sum of the array is larger than 0\\n        long long sum = accumulate(arr.begin(), arr.end(), 0) % mod; \\n\\t\\t\\n        // for other cases, we insert the copy of the array into the array.\\n        for(int i=0; i<size; i++){\\n            arr.push_back(arr[i]);\\n        }\\n\\n        \\n        int result = 0;\\n        // sum of original array is larger than 0, we dont need to call the kadane function\\n        // k - 2 is because we haved doubled the size of the original array by its copy\\n        if(sum > 0){\\n            result += (k-2)*sum % mod;\\n        }\\n\\n        return (kadane(arr) + result) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    // use kadane algorithm to find the longest continuous number in an array.    \\n    long kadane (vector<int>& arr){\\n        int maxEndingHere = 0;\\n        int maxAll = 0;\\n        int size = arr.size();\\n        for(int i=0; i<size; i++){\\n            maxEndingHere += arr[i]%mod;\\n            // if the maxEndingHere is smaller than 0, we just reset it.\\n            if(maxEndingHere < 0) maxEndingHere = 0;\\n            maxAll = max(maxEndingHere, maxAll);\\n        }\\n        return maxAll;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(arr.size() == 0) return 0;\\n        int size = arr.size();\\n        // case one, k == 1, just input the result.\\n        if(k==1) return kadane(arr)%mod;\\n        \\n\\t\\t// since we want to check whether the actual sum of the array is larger than 0\\n        long long sum = accumulate(arr.begin(), arr.end(), 0) % mod; \\n\\t\\t\\n        // for other cases, we insert the copy of the array into the array.\\n        for(int i=0; i<size; i++){\\n            arr.push_back(arr[i]);\\n        }\\n\\n        \\n        int result = 0;\\n        // sum of original array is larger than 0, we dont need to call the kadane function\\n        // k - 2 is because we haved doubled the size of the original array by its copy\\n        if(sum > 0){\\n            result += (k-2)*sum % mod;\\n        }\\n\\n        return (kadane(arr) + result) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070102,
                "title": "easy-faster-efficient-kadane-application-java-soln",
                "content": "```\\nclass Solution {\\n    private int kadane(int [] arr){\\n        int csum = arr[0];\\n        int msum = arr[0];\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            int val = arr[i];\\n            if(csum > 0){\\n                csum += val;\\n            } else {\\n                csum = val;\\n            }\\n            msum = Math.max(csum, msum);\\n        }\\n        return msum;\\n    }\\n    private int kadaneOfTwo(int [] arr){\\n        int [] narr = new int[2 * arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            narr[i] = arr[i];\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            narr[i + arr.length] = arr[i];\\n        }\\n        return kadane(narr);\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for(int val : arr){\\n            sum += val;\\n        }\\n        if(k == 1){\\n            return kadane(arr);\\n        } else if(sum < 0){\\n            int res = kadaneOfTwo(arr);\\n            return res < 0 ? 0 : res;\\n        } else{\\n            return (int)((kadaneOfTwo(arr) + (k - 2) * sum) % (1e9 + 7));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int kadane(int [] arr){\\n        int csum = arr[0];\\n        int msum = arr[0];\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            int val = arr[i];\\n            if(csum > 0){\\n                csum += val;\\n            } else {\\n                csum = val;\\n            }\\n            msum = Math.max(csum, msum);\\n        }\\n        return msum;\\n    }\\n    private int kadaneOfTwo(int [] arr){\\n        int [] narr = new int[2 * arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            narr[i] = arr[i];\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            narr[i + arr.length] = arr[i];\\n        }\\n        return kadane(narr);\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for(int val : arr){\\n            sum += val;\\n        }\\n        if(k == 1){\\n            return kadane(arr);\\n        } else if(sum < 0){\\n            int res = kadaneOfTwo(arr);\\n            return res < 0 ? 0 : res;\\n        } else{\\n            return (int)((kadaneOfTwo(arr) + (k - 2) * sum) % (1e9 + 7));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949865,
                "title": "javascript-k-1-2-and-3-reveals-the-logic",
                "content": "**Step 1**\\nSolve how to get maximum sub array sum:\\n```\\nExample:\\n[4, -3, 1, -2, -1, 5]\\nWe keep 2 variables MAX and CUR\\n\\nIterations\\ni = 4: MAX = 4 and CUR = 4\\ni = -3: MAX = 4 and CUR = 1\\ni = 1: MAX = 4 and CUR = 2\\ni = -2: MAX = 4 and CUR = 0\\ni = -1: MAX = 4 and CUR = 0 (if CUR<0 make it 0 again)\\ni = 5: MAX = 5 and CUR = 5\\n```\\nIf at any point our CUR variable becomes negative we reset it back to 0 as we don\\'t need our answer to be less than 0. Else we add it to cur variable because we might spot a greater sum than current one.\\n\\nThis is classic algorithm known as kadane, look it up on wikipedia\\n\\n```\\nlet maxSum = function(ar){\\n    let max = 0;\\n    let cur = 0;\\n    \\n    for(let i of ar){\\n        if(i+cur > 0)\\n            cur+=i;\\n        else\\n            cur = 0;\\n        max = Math.max(cur,max);\\n    }\\n    \\n    return max;\\n}\\n```\\n**Step 2**\\nModulus operations. If you don\\'t know why we apply mod for big valued answers, read about it.\\nThe basic idea behind taking Mod is to prevent integer overflows\\n```\\nlet mod = 10**9+7;\\n\\nlet addMod = (a,b) => (a%mod + b%mod)%mod;\\nlet mulMod = (a,b) => (a%mod * b%mod)%mod;\\nlet subMod = (a,b) => (a%mod - b%mod)%mod;\\n```\\n**Step 3**\\nSolving the problem:\\nFor any problem which deals with a variable like k which is applied on a data structure try to iterate it manually for some values like (k=1, k=2, k=3)\\n```\\nObservation 1:\\n[-1,-2] if all elements are -ve whatever the value of k is, the answer will be 0 always\\n```\\n```\\nObservation 2:\\n[1,3,1] if all elemets are +ve, the answer would be k*sum(ar)\\n```\\n\\nIterate over some examples:\\n```\\nk = 1\\n[3, -2, -2, 1]\\nThe answer would be simply \\'maximum sub array sum\\' which would be 3 in this case\\n```\\n```\\nk = 2\\n[3, -2, -2, 1, 3, -2, -2, 1]\\nHere, the answer would be 4 as array is doubled so the two positive integers at each end would come together.\\n```\\n```\\nFor k = 3 the same would happen\\n```\\n\\nThis was one example where the sum of negative elements was large enough to cancel out positives so we couldn\\'t increase the window of our solution for k=2, 3 and so on.\\n\\n**Example 2:**\\n```\\nk = 1\\n[4, -1, -1, 5, -1]\\nanswer = 6\\n```\\n```\\nk = 2\\n[4, -1, -1, 5, -1, 4, -1, -1, 5, -1]\\nanswer = 13\\n```\\n```\\nk = 3\\n[4, -1, -1, 5, -1, 4, -1, -1, 5, -1, 4, -1, -1, 5, -1]\\nanswer = 19\\n```\\nIf you look closely, you will find that the answer is all about \"till what extent we can increase our window of elements\". This would form an arithmetic progression as we increase value of \\'k\\'.\\nFor kth iteration value would be: a + (k-1)*diff\\nwhere a is answer for k =1 and diff is the difference in progression\\n\\nTry iterating for array [-5, -2, 0, 0, 3, 9, -2, -5, 4]\\n\\nFrom above explanation we found out that there can be 2 cases overall:\\n1. Max-subarray sum over different k follows arithemetic progression\\n2. Max-subarray sum remains constant after k=2 as the window cannot be increased more.\\n\\nJust find out answes for k=1,2 and 3 and formulate the final answer accordingly.\\n\\nCode:\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nlet mod = 10**9+7;\\n\\nlet addMod = (a,b) => (a%mod + b%mod)%mod;\\nlet mulMod = (a,b) => (a%mod * b%mod)%mod;\\nlet subMod = (a,b) => (a%mod - b%mod)%mod;\\n\\nlet maxSum = function(ar){\\n    let max = 0;\\n    let cur = 0;\\n    \\n    for(let i of ar){\\n        if(i+cur > 0)\\n            cur+=i;\\n        else\\n            cur = 0;\\n        max = Math.max(cur,max);\\n    }\\n    \\n    return max;\\n}\\n\\n\\nvar kConcatenationMaxSum = function(ar, k) {\\n    let ans1 = maxSum(ar)%mod\\n    \\n    if(k==1)\\n        return ans1;\\n    \\n    let ar2 = [...ar, ...ar]\\n    let ans2 = maxSum(ar2)%mod\\n    \\n    if(k==2)\\n        return ans2;\\n    \\n    if(k>=3){\\n        let ar3 = [...ar2, ...ar]\\n        let ans3 = maxSum(ar3)%mod\\n        let diff = subMod(ans3,ans2)\\n        \\n        if(diff === 0) // window cannot be increased\\n            return ans3;\\n        else\\n            return addMod(ans1,mulMod(subMod(k,1), diff)); // window is increased with each k (a+(n-1)*d)\\n    }\\n};\\n```\\nThe code and explanation is large but this might help in case when you are not able to come with a short solution in one go.\\n\\nTime Complexity:\\nO(3*n) (k=3) = O(n) \\n\\nSpace Complexity:\\nO(3*n) (k=3) = O(n)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nExample:\\n[4, -3, 1, -2, -1, 5]\\nWe keep 2 variables MAX and CUR\\n\\nIterations\\ni = 4: MAX = 4 and CUR = 4\\ni = -3: MAX = 4 and CUR = 1\\ni = 1: MAX = 4 and CUR = 2\\ni = -2: MAX = 4 and CUR = 0\\ni = -1: MAX = 4 and CUR = 0 (if CUR<0 make it 0 again)\\ni = 5: MAX = 5 and CUR = 5\\n```\n```\\nlet maxSum = function(ar){\\n    let max = 0;\\n    let cur = 0;\\n    \\n    for(let i of ar){\\n        if(i+cur > 0)\\n            cur+=i;\\n        else\\n            cur = 0;\\n        max = Math.max(cur,max);\\n    }\\n    \\n    return max;\\n}\\n```\n```\\nlet mod = 10**9+7;\\n\\nlet addMod = (a,b) => (a%mod + b%mod)%mod;\\nlet mulMod = (a,b) => (a%mod * b%mod)%mod;\\nlet subMod = (a,b) => (a%mod - b%mod)%mod;\\n```\n```\\nObservation 1:\\n[-1,-2] if all elements are -ve whatever the value of k is, the answer will be 0 always\\n```\n```\\nObservation 2:\\n[1,3,1] if all elemets are +ve, the answer would be k*sum(ar)\\n```\n```\\nk = 1\\n[3, -2, -2, 1]\\nThe answer would be simply \\'maximum sub array sum\\' which would be 3 in this case\\n```\n```\\nk = 2\\n[3, -2, -2, 1, 3, -2, -2, 1]\\nHere, the answer would be 4 as array is doubled so the two positive integers at each end would come together.\\n```\n```\\nFor k = 3 the same would happen\\n```\n```\\nk = 1\\n[4, -1, -1, 5, -1]\\nanswer = 6\\n```\n```\\nk = 2\\n[4, -1, -1, 5, -1, 4, -1, -1, 5, -1]\\nanswer = 13\\n```\n```\\nk = 3\\n[4, -1, -1, 5, -1, 4, -1, -1, 5, -1, 4, -1, -1, 5, -1]\\nanswer = 19\\n```\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nlet mod = 10**9+7;\\n\\nlet addMod = (a,b) => (a%mod + b%mod)%mod;\\nlet mulMod = (a,b) => (a%mod * b%mod)%mod;\\nlet subMod = (a,b) => (a%mod - b%mod)%mod;\\n\\nlet maxSum = function(ar){\\n    let max = 0;\\n    let cur = 0;\\n    \\n    for(let i of ar){\\n        if(i+cur > 0)\\n            cur+=i;\\n        else\\n            cur = 0;\\n        max = Math.max(cur,max);\\n    }\\n    \\n    return max;\\n}\\n\\n\\nvar kConcatenationMaxSum = function(ar, k) {\\n    let ans1 = maxSum(ar)%mod\\n    \\n    if(k==1)\\n        return ans1;\\n    \\n    let ar2 = [...ar, ...ar]\\n    let ans2 = maxSum(ar2)%mod\\n    \\n    if(k==2)\\n        return ans2;\\n    \\n    if(k>=3){\\n        let ar3 = [...ar2, ...ar]\\n        let ans3 = maxSum(ar3)%mod\\n        let diff = subMod(ans3,ans2)\\n        \\n        if(diff === 0) // window cannot be increased\\n            return ans3;\\n        else\\n            return addMod(ans1,mulMod(subMod(k,1), diff)); // window is increased with each k (a+(n-1)*d)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926988,
                "title": "java-kadane-explained-w-diagrams",
                "content": "Two cases: \\n1. Array sum is negative\\n2. Array sum is positive\\n\\nIf we are dealing with case 1, then we wouldn\\'t want to include a whole array because we could have a better result by cutting out any whole array in the maximum k-concatenated subarray.\\n\\nLet\\'s then look at case 2:\\nWithout the loss of generality, when array sum is positive, we can draw a diagram like this where our largest sum subarray is covered by white marker.\\n\\n![image](https://assets.leetcode.com/users/images/89a76d09-1457-4c56-8ace-bca1c9575eed_1649443304.003091.png)\\n\\nWhen each green segement (array) sum is positive, we can disregard the middle segemnt and simplify this into head & tail (`k = 2`) case like the below shows. When we run kadane through it, we can possibly find two cases: \\n1. The largest subarray is marked blue where it crosses the array\\n\\n2. The largest subarray is marked red where it stays in the same array. \\n\\n\\n![image](https://assets.leetcode.com/users/images/b876f882-c0ad-4e3c-9c07-7f3e3816896a_1649443356.6162713.png)\\nIt is important to recognize that case 2 can only happen when the yellow segment is more negative than how positive red segment is; otherwise, the red segment would have included the yellow segment to combine the next red segment to yield a better outcome. Note that Yellow segment is the start and end segment of an array, so this actually means is that the whole subarray sum will be negative, which means case 2 does not fall under the case where array sum is positive.\\n\\nWith that out of the way, we can write the following solution:\\n\\n```Java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int kadane = 0, cur = 0, n = arr.length, m = (int)(1e9 + 7), sum = Arrays.stream(arr).sum();\\n        for (int i = 0; i < Math.min(2, k) * n; i++){\\n            int j = i % n;\\n            cur = Math.max(cur + arr[j], arr[j]);\\n            kadane = Math.max(kadane, cur);\\n        }\\n\\n        return k <= 2 || kadane > kadane + 1L * (k - 2) * sum? \\n            kadane % m : (int)((kadane + 1L * (k - 2) * sum) % m);\\n    }\\n}\\n\\n// OR, we can find the max suffix and max prefix sum like the below solution shows.\\n// I wasn\\'t sure if the kadane across 2-concatenated arrays guarantees they are connected, \\n// so I wrote the below first, then refined it into the solution above.\\n//\\n// class Solution {\\n//     public int kConcatenationMaxSum(int[] arr, int k) {\\n//         int kadane = 0, cur = 0, n = arr.length, m = (int)(1e9 + 7);\\n//         for (int i = 0; i < Math.min(2, k) * n; i++){\\n//             int j = i % n;\\n//             cur = Math.max(cur + arr[j], arr[j]);\\n//             kadane = Math.max(kadane, cur);\\n//         }\\n//         if (k <= 2)\\n//             return kadane % m;\\n\\n//         int min = 0, max = 0, sum = 0;\\n//         for (int i = 0 ; i < n; i++){\\n//             sum += arr[i];\\n//             min = Math.min(sum, min);\\n//             max = Math.max(sum, max);\\n//         }\\n\\n//         long other = (sum - min) + 1L * sum * (k - 2) + max;\\n//         return other > kadane? (int)(other % m) : kadane % m;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int kadane = 0, cur = 0, n = arr.length, m = (int)(1e9 + 7), sum = Arrays.stream(arr).sum();\\n        for (int i = 0; i < Math.min(2, k) * n; i++){\\n            int j = i % n;\\n            cur = Math.max(cur + arr[j], arr[j]);\\n            kadane = Math.max(kadane, cur);\\n        }\\n\\n        return k <= 2 || kadane > kadane + 1L * (k - 2) * sum? \\n            kadane % m : (int)((kadane + 1L * (k - 2) * sum) % m);\\n    }\\n}\\n\\n// OR, we can find the max suffix and max prefix sum like the below solution shows.\\n// I wasn\\'t sure if the kadane across 2-concatenated arrays guarantees they are connected, \\n// so I wrote the below first, then refined it into the solution above.\\n//\\n// class Solution {\\n//     public int kConcatenationMaxSum(int[] arr, int k) {\\n//         int kadane = 0, cur = 0, n = arr.length, m = (int)(1e9 + 7);\\n//         for (int i = 0; i < Math.min(2, k) * n; i++){\\n//             int j = i % n;\\n//             cur = Math.max(cur + arr[j], arr[j]);\\n//             kadane = Math.max(kadane, cur);\\n//         }\\n//         if (k <= 2)\\n//             return kadane % m;\\n\\n//         int min = 0, max = 0, sum = 0;\\n//         for (int i = 0 ; i < n; i++){\\n//             sum += arr[i];\\n//             min = Math.min(sum, min);\\n//             max = Math.max(sum, max);\\n//         }\\n\\n//         long other = (sum - min) + 1L * sum * (k - 2) + max;\\n//         return other > kadane? (int)(other % m) : kadane % m;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750149,
                "title": "c-solution",
                "content": "// 3 cases :\\n// k=1 : kadane for one\\n// sum>0 : kadane for two + (k-2)* sum\\n// sum<=0 : kadane for two\\n//N=1000000007 preventing data Overflow\\n```\\nint kadane(int* arr, int arrSize,int degree){\\n    int i,max=arr[0],tmp=0;\\n    for(i=0;i<arrSize*degree;i++){\\n        tmp += arr[i%arrSize];\\n        if(tmp<0){\\n            tmp=0;\\n        }\\n        if(max<tmp){\\n            max=tmp;\\n        }\\n    }\\n    return max;\\n}\\nint kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    if(k==1){\\n        return kadane(arr,arrSize,1);\\n    }\\n    long long i,sum=0;\\n    long long N=1000000007;\\n    for(i=0;i<arrSize;i++){\\n        sum+=arr[i];\\n    }\\n    if(sum>0){\\n        return (kadane(arr,arrSize,2)+((k-2)*sum)%N)%N;\\n    }else{\\n        return (kadane(arr,arrSize,2))%N;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kadane(int* arr, int arrSize,int degree){\\n    int i,max=arr[0],tmp=0;\\n    for(i=0;i<arrSize*degree;i++){\\n        tmp += arr[i%arrSize];\\n        if(tmp<0){\\n            tmp=0;\\n        }\\n        if(max<tmp){\\n            max=tmp;\\n        }\\n    }\\n    return max;\\n}\\nint kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    if(k==1){\\n        return kadane(arr,arrSize,1);\\n    }\\n    long long i,sum=0;\\n    long long N=1000000007;\\n    for(i=0;i<arrSize;i++){\\n        sum+=arr[i];\\n    }\\n    if(sum>0){\\n        return (kadane(arr,arrSize,2)+((k-2)*sum)%N)%N;\\n    }else{\\n        return (kadane(arr,arrSize,2))%N;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743897,
                "title": "java-complete-detailed-solution-without-copying-array",
                "content": "```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        // int kadane = Kadane(arr);\\n        if(k == 1){//#1 when k 1 simply calculate kadanes\\n            return (int)(Kadane(arr)%mod);\\n        }\\n        //#2 else calculate the total sum and then check if sum is -Ve or +Ve\\n        long totalSum = 0;\\n        for(int i : arr) \\n            totalSum += i;\\n        \\n        //#3 when negative then calculate of arr 2 times only the answer is in there only\\n        if(totalSum < 0){\\n            return (int)(Math.max(KadaneTwo(arr)%mod,0));//when -ve sum put a extra check here of max from 0\\n        }else{\\n        //#4 when sum is positve then the ans is kadane of 2 + sum * (k-2);//these two are used sUm*(k-2) ensures that all other are also included\\n            return (int)((KadaneTwo(arr) + ((k-2) * totalSum)  + mod) % mod );\\n        } \\n    }\\n    \\n    private long Kadane(int[] arr){\\n        long max = arr[0] , cur = 0;\\n        for(int n : arr){\\n            cur += n;\\n            max = Math.max(max, cur);\\n            if(cur < 0) cur = 0;\\n        }\\n        return max;\\n    }\\n    \\n    private long KadaneTwo(int[] arr){\\n      // WITHOUT CREATING THE COPY OF THE ORIGINAL ARRAY SO SPACE COMPLEXITY BECOMES O(1) AND USING Circular Indexing\\n        long max = arr[0] , cur = 0;\\n        for(int i = 0;i < arr.length*2;i++){\\n            cur += arr[i%arr.length];\\n            max = Math.max(max, cur);\\n            if(cur < 0) cur = 0;\\n        }\\n        return max;\\n\\t\\t\\n\\t\\t /* CREATING A COPY APPROACH NOT RECOMMENDED\\n        int ar[] = new int[arr.length*2];\\n        for(int i = 0;i<arr.length*2;i++){doubling the length can be reduced to below FOR\\n            ar[i] = arr[i%arr.length];\\n        } */\\n\\t\\t/*\\n        int n = arr.length;\\n        for(int i = 0;i<arr.length;i++){\\n            ar[i] = ar[i+n] = arr[i];\\n        }\\n        return Kadane(ar);\\n        */\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        // int kadane = Kadane(arr);\\n        if(k == 1){//#1 when k 1 simply calculate kadanes\\n            return (int)(Kadane(arr)%mod);\\n        }\\n        //#2 else calculate the total sum and then check if sum is -Ve or +Ve\\n        long totalSum = 0;\\n        for(int i : arr) \\n            totalSum += i;\\n        \\n        //#3 when negative then calculate of arr 2 times only the answer is in there only\\n        if(totalSum < 0){\\n            return (int)(Math.max(KadaneTwo(arr)%mod,0));//when -ve sum put a extra check here of max from 0\\n        }else{\\n        //#4 when sum is positve then the ans is kadane of 2 + sum * (k-2);//these two are used sUm*(k-2) ensures that all other are also included\\n            return (int)((KadaneTwo(arr) + ((k-2) * totalSum)  + mod) % mod );\\n        } \\n    }\\n    \\n    private long Kadane(int[] arr){\\n        long max = arr[0] , cur = 0;\\n        for(int n : arr){\\n            cur += n;\\n            max = Math.max(max, cur);\\n            if(cur < 0) cur = 0;\\n        }\\n        return max;\\n    }\\n    \\n    private long KadaneTwo(int[] arr){\\n      // WITHOUT CREATING THE COPY OF THE ORIGINAL ARRAY SO SPACE COMPLEXITY BECOMES O(1) AND USING Circular Indexing\\n        long max = arr[0] , cur = 0;\\n        for(int i = 0;i < arr.length*2;i++){\\n            cur += arr[i%arr.length];\\n            max = Math.max(max, cur);\\n            if(cur < 0) cur = 0;\\n        }\\n        return max;\\n\\t\\t\\n\\t\\t /* CREATING A COPY APPROACH NOT RECOMMENDED\\n        int ar[] = new int[arr.length*2];\\n        for(int i = 0;i<arr.length*2;i++){doubling the length can be reduced to below FOR\\n            ar[i] = arr[i%arr.length];\\n        } */\\n\\t\\t/*\\n        int n = arr.length;\\n        for(int i = 0;i<arr.length;i++){\\n            ar[i] = ar[i+n] = arr[i];\\n        }\\n        return Kadane(ar);\\n        */\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658501,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int>&arr){\\n        int maxsum=arr[0];\\n        int currsum=arr[0];\\n        for(int i=1;i<arr.size();i++){\\n            currsum=max(currsum+arr[i],arr[i]);\\n            maxsum=max(maxsum,currsum);\\n        }\\n        return maxsum%1000000007;\\n    }\\n    int kadaneoftwo(vector<int>&arr){\\n        vector<int>arrx(arr.size()*2,0);\\n        for(int i=0;i<arr.size();i++){\\n            arrx.push_back(arr[i]);\\n        }        \\n        for(int i=0;i<arr.size();i++){\\n            arrx.push_back(arr[i]);\\n        }   \\n        int maxsum=kadane(arrx);\\n        return maxsum%1000000007;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(arr.size()==0)\\n            return 0;\\n        long long sum=accumulate(arr.begin(),arr.end(),0)%1000000007;\\n        if(k==1)\\n            return kadane(arr);\\n        if(sum%1000000007<0)\\n            return kadaneoftwo(arr);\\n        if(sum%1000000007>=0)\\n            return kadaneoftwo(arr)+(((k-2)*sum)%1000000007)%1000000007;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int>&arr){\\n        int maxsum=arr[0];\\n        int currsum=arr[0];\\n        for(int i=1;i<arr.size();i++){\\n            currsum=max(currsum+arr[i],arr[i]);\\n            maxsum=max(maxsum,currsum);\\n        }\\n        return maxsum%1000000007;\\n    }\\n    int kadaneoftwo(vector<int>&arr){\\n        vector<int>arrx(arr.size()*2,0);\\n        for(int i=0;i<arr.size();i++){\\n            arrx.push_back(arr[i]);\\n        }        \\n        for(int i=0;i<arr.size();i++){\\n            arrx.push_back(arr[i]);\\n        }   \\n        int maxsum=kadane(arrx);\\n        return maxsum%1000000007;\\n    }\\n    \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(arr.size()==0)\\n            return 0;\\n        long long sum=accumulate(arr.begin(),arr.end(),0)%1000000007;\\n        if(k==1)\\n            return kadane(arr);\\n        if(sum%1000000007<0)\\n            return kadaneoftwo(arr);\\n        if(sum%1000000007>=0)\\n            return kadaneoftwo(arr)+(((k-2)*sum)%1000000007)%1000000007;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617882,
                "title": "good-solution-with-kadane-s-algorithm-c",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n    \\n    Observation is key for this problem\\n    \\n    if you clearly observer we get some pattern after k>2\\n    \\n    k=3 sol= maximum subarray sum of array when its repeated twice + total sum *(1)\\n    k=4 sol= subarraysum + totalsum*(2)\\n    \\n    recurrance relation is kadanesum(k=2) + totalsum*(k-2)    \\n    */\\n    int mod=1e9+7;\\n    int kadane(vector<int>&arr)\\n    {\\n        int sum=0;\\n        int ans=0;\\n        int incl=0;\\n        \\n        for(auto i:arr)\\n        {\\n            sum+=i;\\n            if(sum>incl)\\n            {\\n                incl=sum;\\n            }\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n            ans=max(ans,incl);\\n        }\\n        return ans;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n      \\n        long long  int ans=kadane(arr);\\n     \\n        long long   int totalsum=accumulate(arr.begin(),arr.end(),0);\\n       \\n        if(k==1)\\n        {\\n            return ans;\\n        }\\n       \\n        \\n        \\n        vector<int>b(arr.size()*2);\\n        for(int i=0;i<arr.size()*2;i++)\\n        {\\n            b[i]=arr[i%arr.size()];\\n        }\\n        \\n         ans=kadane(b)%mod;\\n        if(totalsum>=0)\\n        {\\n           \\n        \\n        ans=(ans+(k-2)*totalsum)%mod;\\n        }\\n        b.clear();\\n        \\n        if(ans<0) return 0;\\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n    \\n    Observation is key for this problem\\n    \\n    if you clearly observer we get some pattern after k>2\\n    \\n    k=3 sol= maximum subarray sum of array when its repeated twice + total sum *(1)\\n    k=4 sol= subarraysum + totalsum*(2)\\n    \\n    recurrance relation is kadanesum(k=2) + totalsum*(k-2)    \\n    */\\n    int mod=1e9+7;\\n    int kadane(vector<int>&arr)\\n    {\\n        int sum=0;\\n        int ans=0;\\n        int incl=0;\\n        \\n        for(auto i:arr)\\n        {\\n            sum+=i;\\n            if(sum>incl)\\n            {\\n                incl=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1602739,
                "title": "c-dp-kadane-s-algorithm",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int sum=0;\\n        int mod=(int)(1e9+7);\\n        int globemax=0,n=arr.size();\\n        for(int i=0;i<arr.size();++i)\\n            sum=(sum+arr[i])%mod;\\n        if(k==1){\\n            int cmax=arr[0];\\n            int gmax=arr[0];\\n            for(int i=1;i<arr.size();++i){\\n                cmax=max(arr[i],arr[i]+cmax);\\n                gmax=max(gmax,cmax);\\n            }\\n            return gmax;\\n        }else{\\n            int finalans = arr[0];\\n        int curr = arr[0];\\n        for(int i = 1 ; i < 2 * n; i++){\\n            curr = max(arr[i % n], arr[i % n] + curr);\\n            finalans = max(finalans, curr);\\n        }\\n            globemax=finalans;\\n        }\\n        if(sum < 0) return max(0,globemax%mod);\\n         int ans=(globemax+((k-2)*sum))%mod;\\n            \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int sum=0;\\n        int mod=(int)(1e9+7);\\n        int globemax=0,n=arr.size();\\n        for(int i=0;i<arr.size();++i)\\n            sum=(sum+arr[i])%mod;\\n        if(k==1){\\n            int cmax=arr[0];\\n            int gmax=arr[0];\\n            for(int i=1;i<arr.size();++i){\\n                cmax=max(arr[i],arr[i]+cmax);\\n                gmax=max(gmax,cmax);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1591841,
                "title": "fastest-o-n-c-solution-with-explanation-converting-o-k-n-in-o-n-solution",
                "content": "```\\nSo we use kadanes algorithm to find for when k = 1, and k = 2, and store answer \\nk =2 in a variable called array_for_two.\\nNow after a dry run, we observe a pattern that,\\nfor k = 3, ans = array_for_two + totalsum.\\nfor k = 4, ans  = array_for_two + 2totalsum.\\nfor k = 5 ans = array_for_two + 3totalsum.\\n..\\n..\\nfor k = r, ans = array_for_two + (r-2)totalsum.\\nand this was the basic intuition for converting the code from O(K* N)  to O(N).\\nJust if you want to understand, i have posted O(k*N) solution too in the comments.\\nAnd if you want the solution to be the fastest submission copy the line \\n\" static const auto x=[](){ std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr; }(); \"\\nand paste it before the class solution. It increases the speed of input and output of the code and result in 38ms submission, 99 point something fastest.\\n```\\n\\n\\n\\n```\\nint kadanes(vector<int>& arr, int k){\\n        int mod=(int)(1e9+7);\\n\\n        long csum=0, msum=0;\\n        int i=0;\\n\\n        while(k>0){\\n            while(i<arr.size()){\\n                csum += arr[i];\\n\\n                if(csum<0) csum=0;\\n                msum= max(csum, msum);\\n                i++;\\n            }\\n            i=0;\\n            k--;\\n        }\\n\\n        return (int)(msum % mod);\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int ans_for_2=0;\\n        long mod = (int)(1e9+7);\\n\\n        long arr_sum = 0;\\n        for(int& e:arr)  arr_sum+=e;\\n        \\n        for(int i=1; i<=2; i++){\\n            int sum = kadanes(arr,i);\\n\\n            if(k==i){\\n                return sum;\\n            }\\n\\n            if(i==2){\\n                ans_for_2=sum;\\n            }\\n        }\\n\\n        if(arr_sum < 0){\\n            return (int)(ans_for_2 % mod);\\n        }\\n\\n        int ans = (int)(ans_for_2 + ((k-2) * (arr_sum) % mod));\\n\\n        return max(ans,0);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nSo we use kadanes algorithm to find for when k = 1, and k = 2, and store answer \\nk =2 in a variable called array_for_two.\\nNow after a dry run, we observe a pattern that,\\nfor k = 3, ans = array_for_two + totalsum.\\nfor k = 4, ans  = array_for_two + 2totalsum.\\nfor k = 5 ans = array_for_two + 3totalsum.\\n..\\n..\\nfor k = r, ans = array_for_two + (r-2)totalsum.\\nand this was the basic intuition for converting the code from O(K* N)  to O(N).\\nJust if you want to understand, i have posted O(k*N) solution too in the comments.\\nAnd if you want the solution to be the fastest submission copy the line \\n\" static const auto x=[](){ std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr; }(); \"\\nand paste it before the class solution. It increases the speed of input and output of the code and result in 38ms submission, 99 point something fastest.\\n```\n```\\nint kadanes(vector<int>& arr, int k){\\n        int mod=(int)(1e9+7);\\n\\n        long csum=0, msum=0;\\n        int i=0;\\n\\n        while(k>0){\\n            while(i<arr.size()){\\n                csum += arr[i];\\n\\n                if(csum<0) csum=0;\\n                msum= max(csum, msum);\\n                i++;\\n            }\\n            i=0;\\n            k--;\\n        }\\n\\n        return (int)(msum % mod);\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int ans_for_2=0;\\n        long mod = (int)(1e9+7);\\n\\n        long arr_sum = 0;\\n        for(int& e:arr)  arr_sum+=e;\\n        \\n        for(int i=1; i<=2; i++){\\n            int sum = kadanes(arr,i);\\n\\n            if(k==i){\\n                return sum;\\n            }\\n\\n            if(i==2){\\n                ans_for_2=sum;\\n            }\\n        }\\n\\n        if(arr_sum < 0){\\n            return (int)(ans_for_2 % mod);\\n        }\\n\\n        int ans = (int)(ans_for_2 + ((k-2) * (arr_sum) % mod));\\n\\n        return max(ans,0);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530951,
                "title": "python-different-possibilities",
                "content": "First determine if both positive and negative numbers exists. \\nIf only positive exists, results is simpley sum(arr) * k.\\nIf only negative number exists, result is zero\\nIf both exists,\\nThe result is either\\n\\t1. max(bestSum) in the arr \\n\\t2. sumArr * k\\n\\t3. sumArr * (k - 1 ) - max(bestSum) of arr when tails are not considered\\n\\n\\n\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        sumArr = sum(arr)\\n        \\n        neg = False\\n        pos = False\\n        both = False\\n        \\n        for i in range(n):\\n            if neg == False and arr[i] < 0:\\n                neg = True\\n            if pos == False and arr[i] >= 0:\\n                pos = True\\n            if neg and pos:\\n                both = True\\n                break\\n                \\n        if not both:\\n            return 0 if neg else sumArr * k  %(10**9 + 7)\\n        \\n        maxSum = 0\\n        curSum = 0\\n        for i in range(min(k,2)*n):\\n            if curSum + arr[i%n] < 0:\\n                curSum = 0\\n            else:\\n                curSum += arr[i%n]\\n            maxSum = max(maxSum, curSum)\\n        bestSum = 0\\n        bestMax = 0\\n        for i in range(n):\\n            if bestSum +arr[i] < 0:\\n                bestSum = 0\\n            else:\\n                bestSum += arr[i]\\n            bestMax = max(bestSum, bestMax)\\n        return max(max(k*sumArr, maxSum), (k-1)*sumArr +bestMax ) %(10**9 + 7)\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        sumArr = sum(arr)\\n        \\n        neg = False\\n        pos = False\\n        both = False\\n        \\n        for i in range(n):\\n            if neg == False and arr[i] < 0:\\n                neg = True\\n            if pos == False and arr[i] >= 0:\\n                pos = True\\n            if neg and pos:\\n                both = True\\n                break\\n                \\n        if not both:\\n            return 0 if neg else sumArr * k  %(10**9 + 7)\\n        \\n        maxSum = 0\\n        curSum = 0\\n        for i in range(min(k,2)*n):\\n            if curSum + arr[i%n] < 0:\\n                curSum = 0\\n            else:\\n                curSum += arr[i%n]\\n            maxSum = max(maxSum, curSum)\\n        bestSum = 0\\n        bestMax = 0\\n        for i in range(n):\\n            if bestSum +arr[i] < 0:\\n                bestSum = 0\\n            else:\\n                bestSum += arr[i]\\n            bestMax = max(bestSum, bestMax)\\n        return max(max(k*sumArr, maxSum), (k-1)*sumArr +bestMax ) %(10**9 + 7)\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364520,
                "title": "java-solution-faster-than-99-21-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        // Prefix Sum\\n        int n=arr.length;\\n        long prefix_sum=arr[0];\\n        long max_prefix_sum=arr[0];\\n        for(int x=1;x<n;x++)\\n        {\\n            prefix_sum+=arr[x];\\n            max_prefix_sum=Math.max(max_prefix_sum, prefix_sum);\\n        }\\n       \\n        if(max_prefix_sum <0)\\n        {\\n            prefix_sum=0;\\n        }\\n        //Kadens Algorithm\\n        long curr_sum=arr[0];\\n        long best_sum=arr[0];\\n        for(int x=1;x<n;x++)\\n        {\\n            curr_sum=Math.max(curr_sum+arr[x], arr[x]);\\n            best_sum=Math.max(curr_sum, best_sum);\\n        }\\n        \\n        \\n        \\n      //Suffix_sum\\n         long suffix_sum=arr[n-1];\\n        long  max_suffix_sum=arr[n-1];\\n        for(int x=n-2;x>=0;x--)\\n        {\\n            suffix_sum+=arr[x];\\n            max_suffix_sum=Math.max( max_suffix_sum, suffix_sum);\\n        }\\n        \\n        \\n       \\n        long kk=(long)prefix_sum*k;\\n        long maxs= Math.max(kk, Math.max(best_sum,Math.max( max_suffix_sum+max_prefix_sum*(k==1?0:1),\\n                                                               max_suffix_sum+(long)prefix_sum*(k-1))));\\n        \\n        \\n        \\n        maxs=Math.max(maxs,prefix_sum*(k-1)+max_prefix_sum);\\n              \\n\\n        maxs=Math.max(maxs, max_suffix_sum+ prefix_sum*(k<=1?0:k-2)+max_prefix_sum*(k==1?0:1));\\n               \\n\\n        return (int)(maxs%1000000007);\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        \\n        // Prefix Sum\\n        int n=arr.length;\\n        long prefix_sum=arr[0];\\n        long max_prefix_sum=arr[0];\\n        for(int x=1;x<n;x++)\\n        {\\n            prefix_sum+=arr[x];\\n            max_prefix_sum=Math.max(max_prefix_sum, prefix_sum);\\n        }\\n       \\n        if(max_prefix_sum <0)\\n        {\\n            prefix_sum=0;\\n        }\\n        //Kadens Algorithm\\n        long curr_sum=arr[0];\\n        long best_sum=arr[0];\\n        for(int x=1;x<n;x++)\\n        {\\n            curr_sum=Math.max(curr_sum+arr[x], arr[x]);\\n            best_sum=Math.max(curr_sum, best_sum);\\n        }\\n        \\n        \\n        \\n      //Suffix_sum\\n         long suffix_sum=arr[n-1];\\n        long  max_suffix_sum=arr[n-1];\\n        for(int x=n-2;x>=0;x--)\\n        {\\n            suffix_sum+=arr[x];\\n            max_suffix_sum=Math.max( max_suffix_sum, suffix_sum);\\n        }\\n        \\n        \\n       \\n        long kk=(long)prefix_sum*k;\\n        long maxs= Math.max(kk, Math.max(best_sum,Math.max( max_suffix_sum+max_prefix_sum*(k==1?0:1),\\n                                                               max_suffix_sum+(long)prefix_sum*(k-1))));\\n        \\n        \\n        \\n        maxs=Math.max(maxs,prefix_sum*(k-1)+max_prefix_sum);\\n              \\n\\n        maxs=Math.max(maxs, max_suffix_sum+ prefix_sum*(k<=1?0:k-2)+max_prefix_sum*(k==1?0:1));\\n               \\n\\n        return (int)(maxs%1000000007);\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280389,
                "title": "java-easy-solution-o-n",
                "content": "```\\nclass Solution {\\n     public int mod = (int)1e9+7;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(arr.length==1) return arr[0]<0 ? 0: arr[0];\\n        if(k==1) return (int)(kadane1(arr));\\n        \\n        long sum = 0;\\n        for(int v: arr)sum =sum+v;\\n        \\n        long ans;\\n        if(sum<0){\\n           long res = kadane2(arr);\\n           ans = res<0 ? 0 : res;\\n        }else{\\n            ans = (kadane2(arr)+ sum*(k-2)%mod)%mod;\\n        }\\n        return (int)(ans%mod);\\n    }\\n    public long kadane1(int[] arr){\\n      long max = -(long)1e9;\\n      long res = -(long)1e9;\\n        \\n      for(int i=0; i<arr.length; i++){\\n        max = Math.max(max+arr[i], arr[i]);\\n        res = Math.max(res, max);\\n      }\\n      \\n      return res;\\n  }\\n    \\n    public long kadane2(int[] arr){\\n      long max = -(long)1e9;\\n      long res = -(long)1e9;\\n        \\n      for(int i=0; i<2*arr.length; i++){\\n        max = Math.max(max+arr[i%arr.length], arr[i%arr.length]);\\n        res = Math.max(res, max);\\n      }\\n      \\n      return res;  \\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int mod = (int)1e9+7;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(arr.length==1) return arr[0]<0 ? 0: arr[0];\\n        if(k==1) return (int)(kadane1(arr));\\n        \\n        long sum = 0;\\n        for(int v: arr)sum =sum+v;\\n        \\n        long ans;\\n        if(sum<0){\\n           long res = kadane2(arr);\\n           ans = res<0 ? 0 : res;\\n        }else{\\n            ans = (kadane2(arr)+ sum*(k-2)%mod)%mod;\\n        }\\n        return (int)(ans%mod);\\n    }\\n    public long kadane1(int[] arr){\\n      long max = -(long)1e9;\\n      long res = -(long)1e9;\\n        \\n      for(int i=0; i<arr.length; i++){\\n        max = Math.max(max+arr[i], arr[i]);\\n        res = Math.max(res, max);\\n      }\\n      \\n      return res;\\n  }\\n    \\n    public long kadane2(int[] arr){\\n      long max = -(long)1e9;\\n      long res = -(long)1e9;\\n        \\n      for(int i=0; i<2*arr.length; i++){\\n        max = Math.max(max+arr[i%arr.length], arr[i%arr.length]);\\n        res = Math.max(res, max);\\n      }\\n      \\n      return res;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203750,
                "title": "6ms-java-dp-solutipn",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    long findMax(int arr[]){\\n        int n=arr.length;\\n        long last=0;\\n        long max=last=Math.max(0,arr[0]);\\n        for(int i=1;i<n;i++)\\n            max=Math.max(max,last=Math.max(last+arr[i],arr[i]));\\n        return Math.max(0,max);\\n    }\\n    long findMaxTail(int arr[]){\\n        int n=arr.length;\\n        long last=Math.max(arr[0],0);\\n        for(int i=1;i<n;i++)\\n            last=Math.max(last+arr[i],arr[i]);\\n        return Math.max(last,0);\\n    }\\n    long findMaxHead(int arr[]){\\n        int n=arr.length;\\n        long last=Math.max(0,arr[n-1]);\\n        for(int i=n-2;i>=0;i--) last=Math.max(last+arr[i],arr[i]);\\n        return Math.max(last,0);\\n    }\\n    long findSum(int arr[],int i){\\n        if(i>=arr.length)return 0;\\n        return arr[i]+findSum(arr,i+1);\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n         long max=findMax(arr);\\n        if(k==1)return (int)(max%mod);\\n      long sum=findSum(arr,0);\\n      long head=findMaxHead(arr);\\n      long tail=findMaxTail(arr);\\n        long tempAns=Math.max(max,(head+tail)); \\n        return (int)(Math.max(tempAns,(tail+(k-2)*sum+head))%1000000007);\\n        \\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    long findMax(int arr[]){\\n        int n=arr.length;\\n        long last=0;\\n        long max=last=Math.max(0,arr[0]);\\n        for(int i=1;i<n;i++)\\n            max=Math.max(max,last=Math.max(last+arr[i],arr[i]));\\n        return Math.max(0,max);\\n    }\\n    long findMaxTail(int arr[]){\\n        int n=arr.length;\\n        long last=Math.max(arr[0],0);\\n        for(int i=1;i<n;i++)\\n            last=Math.max(last+arr[i],arr[i]);\\n        return Math.max(last,0);\\n    }\\n    long findMaxHead(int arr[]){\\n        int n=arr.length;\\n        long last=Math.max(0,arr[n-1]);\\n        for(int i=n-2;i>=0;i--) last=Math.max(last+arr[i],arr[i]);\\n        return Math.max(last,0);\\n    }\\n    long findSum(int arr[],int i){\\n        if(i>=arr.length)return 0;\\n        return arr[i]+findSum(arr,i+1);\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n         long max=findMax(arr);\\n        if(k==1)return (int)(max%mod);\\n      long sum=findSum(arr,0);\\n      long head=findMaxHead(arr);\\n      long tail=findMaxTail(arr);\\n        long tempAns=Math.max(max,(head+tail)); \\n        return (int)(Math.max(tempAns,(tail+(k-2)*sum+head))%1000000007);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185523,
                "title": "python-kadane-s-simple-code",
                "content": "There is a math logic to solve this question\\n**if k==1 --> **simple kadane\\'s algo.\\n\\n \\n** if sum(arr)>=0-->** that means if we multiply this arr more then 2  time that is arr=arr*3  then just forget the first and the last concatenated arr and the no. of arr that are in between will make our maximum sum  increase as we increase the count of array in between because if sum (arr)>0 then if we concatenate 2 arrays  in between then also we can take whole 2 array as a part of our required subarray and our sum will increased by  2 times sum(arr)  so now we have to check the no. of element to take from the first array and the last array and the remaining k-2 array in between will contributed fully so just apply kadanes on the first and last array and add the remaining k-2 array sum .**\\n \\n** if sum(arr)<0-->** then we can find our maximum sum by concatinating just 2 arrays if we concatenate more then 2 then we know sum(arr)<0 so there is no advantage of concatinating more then 2 as they will sum up to negative only \\n\\njust do some pen paper math by taking some example if you dont understand\\n \\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        if k==1:\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n        elif sum(arr)<0:\\n          arr=arr*2\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n            \\n        elif sum(arr)>=0:\\n          s=sum(arr)   \\n          arr=arr*2\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n          maxsum=(maxsum+(k-2)*s)\\n        \\n        \\n        \\n        \\n        return maxsum%1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        if k==1:\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n        elif sum(arr)<0:\\n          arr=arr*2\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n            \\n        elif sum(arr)>=0:\\n          s=sum(arr)   \\n          arr=arr*2\\n          maxsum=0\\n          currentsum=0\\n          for i,val in enumerate(arr):\\n            currentsum+=val\\n            if currentsum<0:\\n                currentsum=0\\n            maxsum=(max(currentsum,maxsum))\\n          maxsum=(maxsum+(k-2)*s)\\n        \\n        \\n        \\n        \\n        return maxsum%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155407,
                "title": "python3-kadane-s-algo",
                "content": "This is based on @mzchen\\'s solution [here](https://leetcode.com/problems/k-concatenation-maximum-sum/discuss/382885/Short-and-concise-O(N)-C%2B%2B-solution). \\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        rsm = val = 0 \\n        sm = sum(arr)\\n        if k > 1: arr *= 2\\n        for x in arr: \\n            val = max(0, val + x)\\n            rsm = max(rsm, val)\\n        return max(rsm, rsm + max(0, k-2)*sm) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        rsm = val = 0 \\n        sm = sum(arr)\\n        if k > 1: arr *= 2\\n        for x in arr: \\n            val = max(0, val + x)\\n            rsm = max(rsm, val)\\n        return max(rsm, rsm + max(0, k-2)*sm) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136845,
                "title": "python3-clear-code-explanation-to-hint-4-explanation-with-figures",
                "content": "The hardest part of this problem is to understand why **hint 4**: \"*The answer is the maximum between, the answer for k=1, the sum of the whole array multiplied by k, or the maximum suffix sum plus the maximum prefix sum plus (k-2) multiplied by the whole array sum for k > 1.*\" is correct.\\n\\nLet\\'s analyze 3 cases:\\n1. When ```k=1```, the problem is reduced to implementing the Kadane Algorithm, as mentioned in many other posts.\\n2. When ```k=2```, there are two subcases:\\n2.1. some suffix and prefix form the maximum, as illustrated below:\\n![image](https://assets.leetcode.com/users/images/7c26b9ca-0b36-4fdb-b13d-c7641ab5aa5a_1617256542.4299235.png)\\n2.2. the second array has no contribution (i.e. same as when k=1). For example, ```[-1, -1, 1, -1, -1, 1]```, the maximum subarray is ```[1]```, adding the second half won\\'t make it better.\\n3. When ```k>=3```, besides the two subcases aforementioned in 2.1 and 2.2, there\\'s a third possibility, where the middle ```(k-2)``` arrays have positive contributions:\\n![image](https://assets.leetcode.com/users/images/93d7b8f1-63c3-4dcf-ad6b-8947d2de9a7c_1617257041.715272.png)\\nYou may ask why ```k-2```? Can\\'t it be ```k-3, k-4,...``` ? This is because under the assumption that each array has positive contribution to the sum, adding ```k-2``` positive sums is obviously better than other choices.\\n\\nCode:\\n```\\ndef kConcatenationMaxSum(arr: List[int], k: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\n\\tdef kadane(arr):\\n\\t\\tmax_local = 0\\n\\t\\tmax_global = float(\"-inf\")\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\tmax_local = max(max_local+arr[i], arr[i])\\n\\t\\t\\tmax_global = max(max_global, max_local)\\n\\t\\treturn max(0, max_global)\\n\\n\\tdef prefixSum(arr):\\n\\t\\tmax_global = float(\"-inf\")\\n\\t\\ts = 0\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\ts += arr[i]\\n\\t\\t\\tmax_global = max(max_global, s)\\n\\t\\treturn max_global\\n\\n\\tm1 = kadane(arr)\\n\\tm2, m3 = prefixSum(arr), prefixSum(arr[::-1])  # prefix sum and suffix sum\\n\\ts = sum(arr)\\n\\n\\tif k == 1:\\n\\t\\tans = m1\\n\\telif k == 2:\\n\\t\\tans = max(m2+m3, m1)\\n\\telse:\\n\\t\\tans = max(max(m2+m3, m1), m2+m3+(k-2)*s)\\n\\n\\treturn ans % MOD\\n```",
                "solutionTags": [],
                "code": "```k=1```\n```k=2```\n```[-1, -1, 1, -1, -1, 1]```\n```[1]```\n```k>=3```\n```(k-2)```\n```k-2```\n```k-3, k-4,...```\n```k-2```\n```\\ndef kConcatenationMaxSum(arr: List[int], k: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\n\\tdef kadane(arr):\\n\\t\\tmax_local = 0\\n\\t\\tmax_global = float(\"-inf\")\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\tmax_local = max(max_local+arr[i], arr[i])\\n\\t\\t\\tmax_global = max(max_global, max_local)\\n\\t\\treturn max(0, max_global)\\n\\n\\tdef prefixSum(arr):\\n\\t\\tmax_global = float(\"-inf\")\\n\\t\\ts = 0\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\ts += arr[i]\\n\\t\\t\\tmax_global = max(max_global, s)\\n\\t\\treturn max_global\\n\\n\\tm1 = kadane(arr)\\n\\tm2, m3 = prefixSum(arr), prefixSum(arr[::-1])  # prefix sum and suffix sum\\n\\ts = sum(arr)\\n\\n\\tif k == 1:\\n\\t\\tans = m1\\n\\telif k == 2:\\n\\t\\tans = max(m2+m3, m1)\\n\\telse:\\n\\t\\tans = max(max(m2+m3, m1), m2+m3+(k-2)*s)\\n\\n\\treturn ans % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112803,
                "title": "java-t-o-n-s-o-1",
                "content": "```\\nclass Solution {\\n\\n  private static final int MOD = (int) 1e9 + 7;\\n\\n  // T = O(N), S = O(1)\\n  public int kConcatenationMaxSum(int[] arr, int k) {\\n    int n = arr.length;\\n    long max = getMaxSubSum(arr, n);\\n    if (k == 1) return asIntMod(max);\\n    max = Math.max(max, getMaxSubSum(arr, n * 2));\\n    return asIntMod(Math.max(max, getKConcatMaxSum(arr, k)));\\n  }\\n\\n  private long getMaxSubSum(int[] arr, int n) {\\n    long sum = 0, max = 0;\\n    for (int i = 0; i < n; i++) {\\n      sum += arr[i % arr.length];\\n      max = Math.max(max, sum);\\n      if (sum < 0) sum = 0;\\n    }\\n    return max;\\n  }\\n  \\n  private int asIntMod(long num) {\\n    return (int) (num % MOD);\\n  }\\n\\n  private long getKConcatMaxSum(int[] arr, int k) {\\n    int n = arr.length;\\n    long left = 0, right = 0, minLeft = 0, minRight = 0;\\n    for (int i = 0; i < n; i++) {\\n      left += arr[i];\\n      right += arr[n - 1 - i];\\n      minLeft = Math.min(minLeft, left);\\n      minRight = Math.min(minRight, right);\\n    }\\n    return (left * k) + -minLeft + -minRight;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n  private static final int MOD = (int) 1e9 + 7;\\n\\n  // T = O(N), S = O(1)\\n  public int kConcatenationMaxSum(int[] arr, int k) {\\n    int n = arr.length;\\n    long max = getMaxSubSum(arr, n);\\n    if (k == 1) return asIntMod(max);\\n    max = Math.max(max, getMaxSubSum(arr, n * 2));\\n    return asIntMod(Math.max(max, getKConcatMaxSum(arr, k)));\\n  }\\n\\n  private long getMaxSubSum(int[] arr, int n) {\\n    long sum = 0, max = 0;\\n    for (int i = 0; i < n; i++) {\\n      sum += arr[i % arr.length];\\n      max = Math.max(max, sum);\\n      if (sum < 0) sum = 0;\\n    }\\n    return max;\\n  }\\n  \\n  private int asIntMod(long num) {\\n    return (int) (num % MOD);\\n  }\\n\\n  private long getKConcatMaxSum(int[] arr, int k) {\\n    int n = arr.length;\\n    long left = 0, right = 0, minLeft = 0, minRight = 0;\\n    for (int i = 0; i < n; i++) {\\n      left += arr[i];\\n      right += arr[n - 1 - i];\\n      minLeft = Math.min(minLeft, left);\\n      minRight = Math.min(minRight, right);\\n    }\\n    return (left * k) + -minLeft + -minRight;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040005,
                "title": "simple-python-solution",
                "content": "```\\ndef kdane(lst):\\n    n=len(lst)\\n    maxx=cur=lst[0]\\n    for i in range(1,n):\\n        cur=max(cur+lst[i],lst[i])\\n        maxx=max(maxx,cur)\\n    return max(0,maxx)\\n    \\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        mod=7+(10**9)\\n        n=len(arr)\\n        if k==1:\\n            return kdane(arr)%mod\\n        summ=sum(arr)\\n        \\n        if summ>0:\\n            return ((kdane(arr+arr)%mod)+((k-2)*summ)%mod)%mod\\n        else:\\n            return (kdane(arr+arr))%mod\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef kdane(lst):\\n    n=len(lst)\\n    maxx=cur=lst[0]\\n    for i in range(1,n):\\n        cur=max(cur+lst[i],lst[i])\\n        maxx=max(maxx,cur)\\n    return max(0,maxx)\\n    \\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        mod=7+(10**9)\\n        n=len(arr)\\n        if k==1:\\n            return kdane(arr)%mod\\n        summ=sum(arr)\\n        \\n        if summ>0:\\n            return ((kdane(arr+arr)%mod)+((k-2)*summ)%mod)%mod\\n        else:\\n            return (kdane(arr+arr))%mod\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 932992,
                "title": "java-clean-code-kadane-s-algorithm",
                "content": "class Solution {\\n\\n    public long kadane (int arr[]) {\\n        long curr = arr[0];\\n        long max = arr[0];\\n        for(int i = 1; i < arr.length; i++) {\\n            if (curr >= 0) curr+=arr[i];\\n            else curr = arr[i];\\n            if (curr > max) max = curr;\\n        }\\n        return max;\\n    }\\n    public long kadaneTwo(int arr[]) {\\n        int narr[] = new int[arr.length * 2];\\n        for (int i = 0; i < arr.length; i++) \\n            narr[i] = arr[i];\\n        for (int i = 0; i < arr.length; i++)\\n            narr[i + arr.length] = arr[i];\\n        return kadane(narr);\\n    }\\n    public long sum(int arr[]) {\\n        long s = 0;\\n        for (int i = 0; i < arr.length; i++)\\n            s += arr[i];\\n        return s;\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = sum(arr);\\n        long res = 0;\\n        long x = 1000000007;\\n        if (k == 1) res = kadane(arr);\\n        else if (sum < 0) res = kadaneTwo(arr);\\n        else res = kadaneTwo(arr) + (k - 2)*sum;\\n        if (res < 0) return 0;\\n        return (int)(res % x);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public long kadane (int arr[]) {\\n        long curr = arr[0];\\n        long max = arr[0];\\n        for(int i = 1; i < arr.length; i++) {\\n            if (curr >= 0) curr+=arr[i];\\n            else curr = arr[i];\\n            if (curr > max) max = curr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 864692,
                "title": "c-faster-than-97-56-15-lines",
                "content": "The idea is that after 2 iterations, the max sum will only increase by the same amount. i.e. it will increase by X from iteration 2 to 3, and by the same X from iteration 3 to 4, and so on. Hence we find what this difference is and multiply accordingly.\\n\\n```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n        static int MOD = 1000000007;\\n        int firstMaxSum = 0;\\n        int secondMaxSum = 0;\\n        int maxSum = 0;\\n        int sum = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int num : arr) {\\n                sum = max(0, sum + num % MOD);\\n                maxSum = max(maxSum, sum);\\n            }\\n            if (i == 0) firstMaxSum = maxSum;\\n            else if (i == 1) secondMaxSum = maxSum;\\n        }\\n        long long diff = maxSum - secondMaxSum;\\n        return secondMaxSum + ((diff * (k - 2)) % MOD);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint kConcatenationMaxSum(vector<int>& arr, int k) {\\n        static int MOD = 1000000007;\\n        int firstMaxSum = 0;\\n        int secondMaxSum = 0;\\n        int maxSum = 0;\\n        int sum = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int num : arr) {\\n                sum = max(0, sum + num % MOD);\\n                maxSum = max(maxSum, sum);\\n            }\\n            if (i == 0) firstMaxSum = maxSum;\\n            else if (i == 1) secondMaxSum = maxSum;\\n        }\\n        long long diff = maxSum - secondMaxSum;\\n        return secondMaxSum + ((diff * (k - 2)) % MOD);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854449,
                "title": "c-video-solution-o-n-in-depth-explanation-and-code-walkthrough",
                "content": "https://www.youtube.com/watch?v=eYsUFBucwCM",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=eYsUFBucwCM",
                "codeTag": "Unknown"
            },
            {
                "id": 801127,
                "title": "javascript-solution-using-kadane-s-algorithm",
                "content": "The solution seems long and complicated, but if you walk through it step by step, it is actually pretty straightforward. The most difficult part about the problem is understanding the different scenarios you will have when you have k that is greater than 1. I did not really try to explain it here, since I feel like there are some good explanations in other people\\'s post.\\nHowever, if you have any question that I can possible answer and help, please let met know. Thank you.\\n\\n```\\nvar kConcatenationMaxSum = function(arr, k) {\\n    const MOD = 1e9 + 7;\\n    const n = arr.length;\\n    \\n    let max = arr[0]; // represent the max subarray sum of a single iteration of the original array\\n    let curr = arr[0];\\n    \\n    // Kadane\\'s Algorithm\\n    for (let i = 1; i < n; i++) {\\n        curr = Math.max(arr[i], curr + arr[i]);\\n        max = Math.max(curr, max);\\n    }\\n    \\n    // If we can\\'t get a subarray with a sum that is greater than 0, then it is better to not get anything\\n    if (max < 0) max = 0;\\n    \\n    let prefixSum = arr[n - 1];\\n    let maxPrefix = arr[n - 1];\\n    \\n    // the prefix is from the back since we are going to use the back portion of the original array for the front of the subarray\\n    for (let i = n - 2; i >= 0; i--) {\\n        prefixSum += arr[i];\\n        maxPrefix = Math.max(prefixSum, maxPrefix);\\n    }\\n    \\n    let suffixSum = arr[0];\\n    let maxSuffix = arr[0];\\n    \\n    // the suffix is the reverse of prefix where we are going to use the front portion of the original array for the back of the subarray\\n    for (let i = 1; i < n; i++) {\\n        suffixSum += arr[i];\\n        maxSuffix = Math.max(suffixSum, maxSuffix);\\n    }\\n\\n    let sum = 0;\\n    \\n    // calculate the entire sum of the array\\n    for (let i = 0; i < n; i++) {\\n        sum += arr[i];\\n    }\\n    \\n    // For k == 1, we just need to return the result from Kadane\\'s Algorithm\\n    if (k == 1) return max % MOD;\\n    \\n    \\n    // The different scenarios of the max subarray sum that can form are:\\n\\t//\\n    //  (1) max (max subarray sum from Kadane\\'s Algorithm or 0 if the max sum < 0)\\n\\t//\\n\\t//  (2) maxPrefix + the sum of the original array * (k - 2) + maxSuffix. It is k - 2 since\\n    //      we used an array for the maxPrefix and array for the maxSuffix.\\n\\t//\\n    //  (3) maxPrefix + maxSuffix (this represent the max subarray from 2 concatenation of the original array)\\n    \\n\\t\\n    // If we have a sum greater than 0, then the maximum is between (1), (2), and (3) from the three scenarioes above\\n    if (sum > 0) {\\n        return Math.max(\\n            max, // (1)\\n\\t\\t\\tmaxPrefix + (k - 2) * sum + maxSuffix, // (2)\\n\\t\\t\\tmaxPrefix + maxSuffix // (3)\\n\\t\\t) % MOD;\\n\\t}\\n   \\n    // If the sum is less than 0, then the maximum is between (1) and (3) from the three scenarioes above\\n    return Math.max(\\n        max, // (1)\\n        maxPrefix + maxSuffix // (3)\\n    ) % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar kConcatenationMaxSum = function(arr, k) {\\n    const MOD = 1e9 + 7;\\n    const n = arr.length;\\n    \\n    let max = arr[0]; // represent the max subarray sum of a single iteration of the original array\\n    let curr = arr[0];\\n    \\n    // Kadane\\'s Algorithm\\n    for (let i = 1; i < n; i++) {\\n        curr = Math.max(arr[i], curr + arr[i]);\\n        max = Math.max(curr, max);\\n    }\\n    \\n    // If we can\\'t get a subarray with a sum that is greater than 0, then it is better to not get anything\\n    if (max < 0) max = 0;\\n    \\n    let prefixSum = arr[n - 1];\\n    let maxPrefix = arr[n - 1];\\n    \\n    // the prefix is from the back since we are going to use the back portion of the original array for the front of the subarray\\n    for (let i = n - 2; i >= 0; i--) {\\n        prefixSum += arr[i];\\n        maxPrefix = Math.max(prefixSum, maxPrefix);\\n    }\\n    \\n    let suffixSum = arr[0];\\n    let maxSuffix = arr[0];\\n    \\n    // the suffix is the reverse of prefix where we are going to use the front portion of the original array for the back of the subarray\\n    for (let i = 1; i < n; i++) {\\n        suffixSum += arr[i];\\n        maxSuffix = Math.max(suffixSum, maxSuffix);\\n    }\\n\\n    let sum = 0;\\n    \\n    // calculate the entire sum of the array\\n    for (let i = 0; i < n; i++) {\\n        sum += arr[i];\\n    }\\n    \\n    // For k == 1, we just need to return the result from Kadane\\'s Algorithm\\n    if (k == 1) return max % MOD;\\n    \\n    \\n    // The different scenarios of the max subarray sum that can form are:\\n\\t//\\n    //  (1) max (max subarray sum from Kadane\\'s Algorithm or 0 if the max sum < 0)\\n\\t//\\n\\t//  (2) maxPrefix + the sum of the original array * (k - 2) + maxSuffix. It is k - 2 since\\n    //      we used an array for the maxPrefix and array for the maxSuffix.\\n\\t//\\n    //  (3) maxPrefix + maxSuffix (this represent the max subarray from 2 concatenation of the original array)\\n    \\n\\t\\n    // If we have a sum greater than 0, then the maximum is between (1), (2), and (3) from the three scenarioes above\\n    if (sum > 0) {\\n        return Math.max(\\n            max, // (1)\\n\\t\\t\\tmaxPrefix + (k - 2) * sum + maxSuffix, // (2)\\n\\t\\t\\tmaxPrefix + maxSuffix // (3)\\n\\t\\t) % MOD;\\n\\t}\\n   \\n    // If the sum is less than 0, then the maximum is between (1) and (3) from the three scenarioes above\\n    return Math.max(\\n        max, // (1)\\n        maxPrefix + maxSuffix // (3)\\n    ) % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788517,
                "title": "python-solution-with-explanation",
                "content": "There are three cases:\\n1. if k==1, which is the same as find the maximum subarray;\\n2. if k>1: \\n\\t1. if the sum of the array is less than or equal to 0, we can each find max subarray in the first array or concatenation of two arraies, for example\\n \\t\\t1. [1,2,-4]+[1,2,-4] the subarray max is 1+2 = 3, which is in the first array; \\n\\t\\t2. [1,-4,1]+[1,-4,1] the subarray max is 1+1 = 2, which is in the first two array;\\n\\t2. if the sum of the array is greater than 0, we have to add the(k-1)*sum(array) and maximum subarray of array,\\n\\t\\t\\t\\t1.prefix+[maximum subarry] + suffix +(k-2)*sum(array)+ prefix+[maximum subarry] + suffix =(prefix+[maximum subarry] + suffix + prefix+[maximum subarry] + suffix) +(k-2)*sum(array), so we only need to consider the first part, the maximum subarray sum of the first part is [maximum subarry] + suffix + prefix+[maximum subarry] = sum(array)+maximum subarray, since the sum of the array is greater than 0, so it must be the sum(array)+subarrrysum. hope it helpes.\\n```\\ndef kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        m = 10**9+7\\n        def kadane(arr):\\n            cur =0\\n            res = 0\\n            for a in arr:\\n                cur = max(a, cur+a)\\n                res = max(res, cur)\\n\\n            return res\\n        if k==1:\\n            return kadane(arr)\\n        else:\\n            if sum(arr)<=0:\\n                return kadane(arr*2)\\n            else:\\n                return (kadane(arr) + (k-1)*sum(arr))%m\\n```",
                "solutionTags": [],
                "code": "```\\ndef kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        m = 10**9+7\\n        def kadane(arr):\\n            cur =0\\n            res = 0\\n            for a in arr:\\n                cur = max(a, cur+a)\\n                res = max(res, cur)\\n\\n            return res\\n        if k==1:\\n            return kadane(arr)\\n        else:\\n            if sum(arr)<=0:\\n                return kadane(arr*2)\\n            else:\\n                return (kadane(arr) + (k-1)*sum(arr))%m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 742883,
                "title": "java-only-2-cases",
                "content": "1, when k == 0 or k ==1, just find subarray with max sum, see getSubArrayMax;\\n2, when k >= 2, calculate head for max surfix sum l, tail for max prefix sum r;\\nif array sum < 0, we treat all (k - 2) mid repeat as 0, else sum * (k - 2);\\nthat is , if array sum < 0, just find find the sum of first 2 repeated array, to add max surfix sum + max prefix sum;\\nthen compare with getSubArrayMax;\\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if (k == 0) return 0;\\n        if (k == 1) return getSubArrayMax(arr);\\n        long l = Integer.MIN_VALUE, r = l, lsum = 0, rsum = 0, res = 0;\\n        int n = arr.length;\\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\\n            lsum = (lsum + arr[i]) % mod;\\n            rsum = (rsum + arr[j]) % mod;\\n            l = Math.max(l, lsum);\\n            r = Math.max(r, rsum);\\n        }\\n        long mid = Math.max(0, lsum) * (k - 2) % mod;\\n        return (int) Math.max((l + r + mid) % mod, getSubArrayMax(arr));\\n    }\\n    \\n    private int getSubArrayMax(int[] arr) {\\n        int sum = 0, res = 0;\\n        for (int num : arr) {\\n            if (sum < 0) sum = 0;\\n            sum = (sum + num) % mod;\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if (k == 0) return 0;\\n        if (k == 1) return getSubArrayMax(arr);\\n        long l = Integer.MIN_VALUE, r = l, lsum = 0, rsum = 0, res = 0;\\n        int n = arr.length;\\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\\n            lsum = (lsum + arr[i]) % mod;\\n            rsum = (rsum + arr[j]) % mod;\\n            l = Math.max(l, lsum);\\n            r = Math.max(r, rsum);\\n        }\\n        long mid = Math.max(0, lsum) * (k - 2) % mod;\\n        return (int) Math.max((l + r + mid) % mod, getSubArrayMax(arr));\\n    }\\n    \\n    private int getSubArrayMax(int[] arr) {\\n        int sum = 0, res = 0;\\n        for (int num : arr) {\\n            if (sum < 0) sum = 0;\\n            sum = (sum + num) % mod;\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581359,
                "title": "c-28-ms-o-n-check-all-combination-solution",
                "content": "The idea is to just check all possible combinations of subarrays that could lead to better result. These are all the combinations:\\n\\n1. Maximum subarray sum of a single array. Requires `k >= 1`. \\n2. Maximum sum starting from right + maximum sum starting from left (needs `k >= 2`). Essentially this is a subarray that lies in between two of the repeated `arrs`.\\n3. Maximum sum starting from right + maximum sum starting from left + sum of entire array in the middle. Requires `k >= 2` and total sum of array is greater than 0. Essentially this means the subarray starts in first `arr` and ends in last `arr`. \\n\\nSo if `k = 1`, we only need to check case 1, and that can be done in `O(N)`. \\nFor `k >= 2`, we need to check all 3 cases, and it takes `O(N)` to get result for all of these cases so the run-time is still `O(N)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int size = arr.size();\\n        if(!size) return 0;\\n        if(k == 1) return maxSum(arr) % MOD;\\n        int64_t sum1 = maxSum(arr), sum2 = sumLeft(arr) + sumRight(arr), sum3 = totalSum(arr), z = 0;\\n        return max(z, max(sum1, max(z, sum3*(k-2)) + sum2)) % MOD;\\n    }\\n    int64_t maxSum(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0, z = 0;\\n        for(const int n: arr) {\\n            sum = max(z, sum+n);\\n            max_ = max(sum, max_);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t sumLeft(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0;\\n        for(const int n: arr) {\\n            sum += n;\\n            max_  = max(max_, sum);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t sumRight(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0;\\n        for(auto it = arr.rbegin(); it != arr.rend(); ++it) {\\n            sum += *it;\\n            max_ = max(max_, sum);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t totalSum(vector<int>& arr) {\\n        return accumulate(arr.begin(), arr.end(), 0, [](int64_t a, int b) -> int64_t {return a + b;});\\n    }\\n    \\n    static const int MOD = 1e9+7;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int size = arr.size();\\n        if(!size) return 0;\\n        if(k == 1) return maxSum(arr) % MOD;\\n        int64_t sum1 = maxSum(arr), sum2 = sumLeft(arr) + sumRight(arr), sum3 = totalSum(arr), z = 0;\\n        return max(z, max(sum1, max(z, sum3*(k-2)) + sum2)) % MOD;\\n    }\\n    int64_t maxSum(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0, z = 0;\\n        for(const int n: arr) {\\n            sum = max(z, sum+n);\\n            max_ = max(sum, max_);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t sumLeft(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0;\\n        for(const int n: arr) {\\n            sum += n;\\n            max_  = max(max_, sum);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t sumRight(vector<int>& arr) {\\n        int64_t sum = 0, max_ = 0;\\n        for(auto it = arr.rbegin(); it != arr.rend(); ++it) {\\n            sum += *it;\\n            max_ = max(max_, sum);\\n        }\\n        return max_;\\n    }\\n    \\n    int64_t totalSum(vector<int>& arr) {\\n        return accumulate(arr.begin(), arr.end(), 0, [](int64_t a, int b) -> int64_t {return a + b;});\\n    }\\n    \\n    static const int MOD = 1e9+7;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 555984,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        long res=0;long total=0;\\n        long memo[]=new long[nums.length];\\n        long max=0;\\n        long sum=0;\\n        for(int n:nums)total+=n;\\n        for(int i=0;i<nums.length;i++){\\n            if(sum<0)sum=0;\\n            sum+=nums[i];\\n            max=Math.max(max,sum);\\n            memo[i]=sum;\\n        }\\n        if(k==1)return (int)(max%mod);\\n        long last=memo[memo.length-1];\\n        sum=0;\\n        for(int i=2;i<=k-1;i++){\\n            last=Math.max(last,total+last);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            sum+=(nums[i]);\\n            max=Math.max(max,sum+last);\\n        }\\n        return (int)(max%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        long res=0;long total=0;\\n        long memo[]=new long[nums.length];\\n        long max=0;\\n        long sum=0;\\n        for(int n:nums)total+=n;\\n        for(int i=0;i<nums.length;i++){\\n            if(sum<0)sum=0;\\n            sum+=nums[i];\\n            max=Math.max(max,sum);\\n            memo[i]=sum;\\n        }\\n        if(k==1)return (int)(max%mod);\\n        long last=memo[memo.length-1];\\n        sum=0;\\n        for(int i=2;i<=k-1;i++){\\n            last=Math.max(last,total+last);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            sum+=(nums[i]);\\n            max=Math.max(max,sum+last);\\n        }\\n        return (int)(max%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479353,
                "title": "c-100-runtime-and-100-memory-using-kadane-s-algorightm",
                "content": "```\\n//Fast IO\\nstatic auto magic = []() {ios_base::sync_with_stdio(false); cin.tie(nullptr); return false;}();\\n\\nclass Solution {\\npublic:\\n\\tint p = 1000000007;\\n\\t\\n\\tint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long maxsofar = 0;\\n\\t\\tlong long sum = 0;\\n\\t\\t\\n\\t\\t//for k == 1 kadane\\'s algo\\n\\t\\tfor (int i = 0; i<arr.size(); i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tif(sum >= p)\\n\\t\\t\\t\\tsum %= p;\\n\\t\\t\\tmaxsofar += arr[i];\\n\\t\\t\\tif(maxsofar >= p)\\n\\t\\t\\t\\tmaxsofar %= p;\\n\\t\\t\\tif(maxsofar < 0)\\n\\t\\t\\t\\tmaxsofar = 0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tans = max(ans, maxsofar);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(k == 1)\\n\\t\\t\\treturn ans;\\n\\t\\t\\n\\t\\tlong long ans1 = ans;\\n\\t\\t\\n\\t\\t//try for two arrays concatenated\\n\\t\\tfor (int i = 0; i<arr.size(); i++) {\\n\\t\\t\\tmaxsofar += arr[i];\\n\\t\\t\\tif(maxsofar >= p)\\n\\t\\t\\t\\tmaxsofar %= p;\\n\\t\\t\\tif(maxsofar < 0)\\n\\t\\t\\t\\tmaxsofar = 0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tans = max(ans, maxsofar);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//compute three values that can possibly be the answers\\n\\t\\tlong long res = max(ans1, ans);\\n\\t\\tif(sum > 0)\\n\\t\\t\\tres = max(res, ((ans + ((sum * (k-2))%p))%p));\\n\\t\\t\\t\\n\\t\\t//return the answer\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Fast IO\\nstatic auto magic = []() {ios_base::sync_with_stdio(false); cin.tie(nullptr); return false;}();\\n\\nclass Solution {\\npublic:\\n\\tint p = 1000000007;\\n\\t\\n\\tint kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long maxsofar = 0;\\n\\t\\tlong long sum = 0;\\n\\t\\t\\n\\t\\t//for k == 1 kadane\\'s algo\\n\\t\\tfor (int i = 0; i<arr.size(); i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tif(sum >= p)\\n\\t\\t\\t\\tsum %= p;\\n\\t\\t\\tmaxsofar += arr[i];\\n\\t\\t\\tif(maxsofar >= p)\\n\\t\\t\\t\\tmaxsofar %= p;\\n\\t\\t\\tif(maxsofar < 0)\\n\\t\\t\\t\\tmaxsofar = 0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tans = max(ans, maxsofar);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(k == 1)\\n\\t\\t\\treturn ans;\\n\\t\\t\\n\\t\\tlong long ans1 = ans;\\n\\t\\t\\n\\t\\t//try for two arrays concatenated\\n\\t\\tfor (int i = 0; i<arr.size(); i++) {\\n\\t\\t\\tmaxsofar += arr[i];\\n\\t\\t\\tif(maxsofar >= p)\\n\\t\\t\\t\\tmaxsofar %= p;\\n\\t\\t\\tif(maxsofar < 0)\\n\\t\\t\\t\\tmaxsofar = 0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tans = max(ans, maxsofar);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//compute three values that can possibly be the answers\\n\\t\\tlong long res = max(ans1, ans);\\n\\t\\tif(sum > 0)\\n\\t\\t\\tres = max(res, ((ans + ((sum * (k-2))%p))%p));\\n\\t\\t\\t\\n\\t\\t//return the answer\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437170,
                "title": "python-solution-with-explanation",
                "content": "Solution:\\nIn order to find the maximum subarray, there are several situations:\\n1. The original array has a negative sum.\\n2. The original array has a positive sum, but the sum is smaller than the maximum subarray when link two same arrays.\\n3. The original array has a positive sum, and the sum is bigger than the maximum subarray when link two same arrays.\\n\\nWhy can we find the maximum subarray when we link only two of the same arrays? In situation 1, we should not include one whole original array in our maximum subarray\\nin concatenated array, since the sum is negative, if we go through the whole array, there is no point. In situation 2, since the sum is smaller than the maximum subarray,\\nthat means there are some middle elements in the original array are missed in the maximum subarray when we linked two of the same arrays. That means the maximum subarray\\nwould include some part of the tail of first array and some part of the head of the second array.\\n\\nSo we can only use two array to find out the maximum subarray.\\nAfter this, we can now see the fun part.\\n\\nThe maximum subarray cross two subarray can only be selected once, but the whole original array can be selected k times.\\nEach maximum subarray would use 2 original arrays to form, so we can choose k-2 times the original array if the sum of it is positive.\\n\\nSomehow we can guarantee that the maximum subarray is bigger than the sum of 2 linked arrays, since it is the maximum subarray we can find in the linked array.\\n\\nThus, in the end of the function, if the sum of original array is positive, return k-2 * sum + maximum array, if negative, return the maximum array.\\n```python\\nclass Solution(object):\\n\\tdef kConcatenationMaxSum(self, arr, k):\\n\\t\\t\"\"\"\\n\\t\\t:type arr: List[int]\\n\\t\\t:type k: int\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef maxSubArray(nums):\\n\\t\\t\\tarr = [0] * len(nums)\\n\\t\\t\\tarr[0] = nums[0]\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif arr[i-1] < 0:\\n\\t\\t\\t\\t\\tarr[i] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tarr[i] = arr[i-1] + nums[i]\\n\\t\\t\\treturn max(arr)\\n\\t\\tif k == 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tsums = sum(arr)\\n\\t\\tnewArr = arr * 2\\n\\t\\trst = maxSubArray(newArr)\\n\\n\\t\\tif rst < 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tif sums > 0:\\n\\t\\t\\treturn (sums * (k-2) + rst) % (pow(10, 9) + 7)\\n\\t\\telse:\\n\\t\\t\\treturn rst % (pow(10, 9) + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n\\tdef kConcatenationMaxSum(self, arr, k):\\n\\t\\t\"\"\"\\n\\t\\t:type arr: List[int]\\n\\t\\t:type k: int\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef maxSubArray(nums):\\n\\t\\t\\tarr = [0] * len(nums)\\n\\t\\t\\tarr[0] = nums[0]\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif arr[i-1] < 0:\\n\\t\\t\\t\\t\\tarr[i] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tarr[i] = arr[i-1] + nums[i]\\n\\t\\t\\treturn max(arr)\\n\\t\\tif k == 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tsums = sum(arr)\\n\\t\\tnewArr = arr * 2\\n\\t\\trst = maxSubArray(newArr)\\n\\n\\t\\tif rst < 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tif sums > 0:\\n\\t\\t\\treturn (sums * (k-2) + rst) % (pow(10, 9) + 7)\\n\\t\\telse:\\n\\t\\t\\treturn rst % (pow(10, 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432107,
                "title": "java-clean-code-with-explanation",
                "content": "Thanks for others\\' posts to help me understand this question. Here is my understand and java code. \\nThere are three cases:\\n1. if current array\\'s sum is equal to sub-array\\'s max sum, this means we don\\'t need to consider k. speical case is k is equal to 1, also belong to this case.\\n2. if current array\\'s sum is positive, this means it is deserved to concate more array by k repeatedly. This causes final result is combined by two parts, one is the sub-array\\'s sum, another is (k-2) times array. \\n3. if current array\\'s sum is negative, it is not deserved to concate more. The final result is determined by sub-array\\'s sum. \\n\\nHere sub-array means under k=2 condition, there is a sub-array which has max sum. In fact, it must be combined by tail of original array(from j to end) and head of original array(from 0 to i). \\n\\nHere is the tip to module 10^9+7 to output result. Here is other\\'s [explaination](https://www.geeksforgeeks.org/modulo-1097-1000000007/) All in all, it is to avoid integer overflows. \\n\\nHere is the code.\\n```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for (int item: arr) sum += item;\\n        long subMax = 0;\\n        long curSum = 0;\\n        for (int i=0; i<arr.length*2; i++) {\\n            int index = i%arr.length;\\n            if (curSum+arr[index]<=0) {\\n                curSum = 0;\\n            } else {\\n                curSum = Math.max(curSum+arr[index], arr[index]);\\n                subMax = Math.max(subMax, curSum);\\n            }\\n        }\\n        if (k==1&&sum==subMax) return (int)(sum%(long)(Math.pow(10,9)+7));\\n        if (sum>0) {\\n            return (int)(((k-2)*sum+subMax)%(long)(Math.pow(10,9)+7));\\n        }\\n        return (int)(subMax%(long)(Math.pow(10,9)+7));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for (int item: arr) sum += item;\\n        long subMax = 0;\\n        long curSum = 0;\\n        for (int i=0; i<arr.length*2; i++) {\\n            int index = i%arr.length;\\n            if (curSum+arr[index]<=0) {\\n                curSum = 0;\\n            } else {\\n                curSum = Math.max(curSum+arr[index], arr[index]);\\n                subMax = Math.max(subMax, curSum);\\n            }\\n        }\\n        if (k==1&&sum==subMax) return (int)(sum%(long)(Math.pow(10,9)+7));\\n        if (sum>0) {\\n            return (int)(((k-2)*sum+subMax)%(long)(Math.pow(10,9)+7));\\n        }\\n        return (int)(subMax%(long)(Math.pow(10,9)+7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402399,
                "title": "no-need-to-search-more-this-one-is-okay",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n    int kConcatenationMaxSum(vector<int>& A, int k) {\\n        int n = A.size();\\n        /*\\n        \\n        There are 4 cases to consider\\n        1. when sum of all element is answer => k*total\\n        2. when sum of all element is negative => 0\\n        3. when sum of array is positive and some contigous part is \\n            responsible for solution => kadane +(k-2)*total\\n        4. when sum of array is negative and some contiguous part is\\n            responsible for solution => return kadane\\n        */\\n        const int mod = (int)(1e9 + 7);\\n        long total = 0;\\n        for(int i=0;i<n;i++){\\n            total += A[i];\\n            total %= mod;\\n        }\\n        long curr_sum = 0, g_sum = 0;\\n        for(int i=0;i<(k>1 ? 2 : 1)*n;i++){\\n            curr_sum += A[i%n];\\n            curr_sum %= mod;\\n            if(curr_sum < A[i%n])\\n                curr_sum = A[i%n];\\n            if(curr_sum > g_sum)\\n                g_sum = curr_sum;\\n        }\\n        int a = g_sum, b = (a + (k>1 ? ((k-2)*1ll*total)%mod : 0))%mod;\\n        return max({0, a, b});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    int kConcatenationMaxSum(vector<int>& A, int k) {\\n        int n = A.size();\\n        /*\\n        \\n        There are 4 cases to consider\\n        1. when sum of all element is answer => k*total\\n        2. when sum of all element is negative => 0\\n        3. when sum of array is positive and some contigous part is \\n            responsible for solution => kadane +(k-2)*total\\n        4. when sum of array is negative and some contiguous part is\\n            responsible for solution => return kadane\\n        */\\n        const int mod = (int)(1e9 + 7);\\n        long total = 0;\\n        for(int i=0;i<n;i++){\\n            total += A[i];\\n            total %= mod;\\n        }\\n        long curr_sum = 0, g_sum = 0;\\n        for(int i=0;i<(k>1 ? 2 : 1)*n;i++){\\n            curr_sum += A[i%n];\\n            curr_sum %= mod;\\n            if(curr_sum < A[i%n])\\n                curr_sum = A[i%n];\\n            if(curr_sum > g_sum)\\n                g_sum = curr_sum;\\n        }\\n        int a = g_sum, b = (a + (k>1 ? ((k-2)*1ll*total)%mod : 0))%mod;\\n        return max({0, a, b});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400434,
                "title": "100-memory-efficient-python-easy-to-understand-no-dp",
                "content": "\\tclass Solution(object):\\n\\t\\tdef kConcatenationMaxSum(self, arr, k):\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tif min(arr) >= 0: return sum(arr)*k % M\\n\\t\\t\\tif max(arr) <= 0: return 0\\n\\t\\t\\ta=arr\\n\\t\\t\\tarr = arr*2\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i-1]>0:\\n\\t\\t\\t\\t\\tarr[i]+=arr[i-1]\\n\\t\\t\\tif max(arr)>0:\\n\\t\\t\\t\\treturn max(max(arr),sum(a)*(k-2)+max(arr))%M",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef kConcatenationMaxSum(self, arr, k):\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tif min(arr) >= 0: return sum(arr)*k % M\\n\\t\\t\\tif max(arr) <= 0: return 0\\n\\t\\t\\ta=arr\\n\\t\\t\\tarr = arr*2\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i-1]>0:\\n\\t\\t\\t\\t\\tarr[i]+=arr[i-1]\\n\\t\\t\\tif max(arr)>0:\\n\\t\\t\\t\\treturn max(max(arr),sum(a)*(k-2)+max(arr))%M",
                "codeTag": "Java"
            },
            {
                "id": 396880,
                "title": "python-o-n-clean-code",
                "content": "```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n    \\ttotal=sum(arr)\\n    \\tleft= self.getMaxLeft(arr)\\n    \\tright=self.getMaxRight(arr)\\n    \\tmid=self.getMaxSubArr(arr)\\n    \\tans = int((max(mid,left+(k-2)*max(0,total)+right))%(1e9+7))\\n    \\treturn ans\\n    def getMaxSubArr(self, arr):\\n    \\tcurr,ans=0,0\\n    \\tfor i in arr:\\n    \\t\\tcurr+=i\\n    \\t\\tcurr=0 if curr<0 else curr\\n    \\t\\tans=max(ans,curr)\\n    \\treturn ans\\n    def getMaxLeft(self,arr):\\n    \\tleft,ans=0,0\\n    \\tfor i in arr:\\n    \\t\\tleft+=i\\n    \\t\\tans=max(ans,left)\\n    \\treturn ans\\n    def getMaxRight(self,arr):\\n    \\tright,ans=0,0\\n    \\tfor i in arr[::-1]:\\n    \\t\\tright+=i\\n    \\t\\tans=max(ans,right)\\n    \\treturn ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n    \\ttotal=sum(arr)\\n    \\tleft= self.getMaxLeft(arr)\\n    \\tright=self.getMaxRight(arr)\\n    \\tmid=self.getMaxSubArr(arr)\\n    \\tans = int((max(mid,left+(k-2)*max(0,total)+right))%(1e9+7))\\n    \\treturn ans\\n    def getMaxSubArr(self, arr):\\n    \\tcurr,ans=0,0\\n    \\tfor i in arr:\\n    \\t\\tcurr+=i\\n    \\t\\tcurr=0 if curr<0 else curr\\n    \\t\\tans=max(ans,curr)\\n    \\treturn ans\\n    def getMaxLeft(self,arr):\\n    \\tleft,ans=0,0\\n    \\tfor i in arr:\\n    \\t\\tleft+=i\\n    \\t\\tans=max(ans,left)\\n    \\treturn ans\\n    def getMaxRight(self,arr):\\n    \\tright,ans=0,0\\n    \\tfor i in arr[::-1]:\\n    \\t\\tright+=i\\n    \\t\\tans=max(ans,right)\\n    \\treturn ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 385933,
                "title": "8-lines-concise-java-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] in, int k) {\\n        int n = in.length, mod = 1000000007;\\n        long sum = 0, pre = 0, max = 0;\\n        for (int i = 0; i < 2*n; i++) {\\n            sum += in[i%n];\\n            pre = pre < 0 ? in[i%n] : pre + in[i%n];\\n            max = Math.max(max, pre);\\n        }\\n        return (int)((sum > 0 && k > 2) ? (max + sum/2*(k-2)) % mod : max%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] in, int k) {\\n        int n = in.length, mod = 1000000007;\\n        long sum = 0, pre = 0, max = 0;\\n        for (int i = 0; i < 2*n; i++) {\\n            sum += in[i%n];\\n            pre = pre < 0 ? in[i%n] : pre + in[i%n];\\n            max = Math.max(max, pre);\\n        }\\n        return (int)((sum > 0 && k > 2) ? (max + sum/2*(k-2)) % mod : max%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383505,
                "title": "python-short-version",
                "content": "```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n        \\n        def kadane(arr):\\n            # init res to 0 so that it will be bigger than 0\\n            cur_res, res = 0, 0\\n            for e in arr:\\n                cur_res = max(cur_res + e, e)\\n                res = max(res, cur_res)\\n            return res\\n        \\n        if k == 1:\\n            return kadane(arr)\\n        \\n        s = sum(arr)\\n        \\n        if s <= 0:\\n            return kadane(arr*2) % (10**9+7)\\n        else:\\n            return (s * (k-2) + kadane(arr*2)) % (10**9+7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n        \\n        def kadane(arr):\\n            # init res to 0 so that it will be bigger than 0\\n            cur_res, res = 0, 0\\n            for e in arr:\\n                cur_res = max(cur_res + e, e)\\n                res = max(res, cur_res)\\n            return res\\n        \\n        if k == 1:\\n            return kadane(arr)\\n        \\n        s = sum(arr)\\n        \\n        if s <= 0:\\n            return kadane(arr*2) % (10**9+7)\\n        else:\\n            return (s * (k-2) + kadane(arr*2)) % (10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 382661,
                "title": "o-n-python-solution-with-explanation",
                "content": "- In case `k=0`, just return 0\\n- In case `k=1`, just find the maximum subarray within the given `arr`\\n- In case `k>=2`, we need to consider several cases:\\n1. Max subarray can just be some subarray of `arr` itself. When `k=1`, this is definitely the case.\\n2. When we combine right part of one array (`largest_right`) and left part of the array right next to it (`largest_left`), it also could be the answer. It will look like :\\n `arr[0] arr[1] ... {arr[x] ... arr[-2] arr[-1] arr[0] arr[1] ... arr[y] } arr[y+1] ... arr[-2] arr[-1] arr[0] ... etc` \\n where the resulting array is between curly braces.\\n3. This case is similar to `2` except that you can take right part of the first `arr`, fully paste k-2 `arr`s in between,  and take largest left part of `k-th` `arr`.\\n\\n- Since I use for-loop 3 times, iterating over all elements, the time complexity is O(n).\\n\\n- Please, comment on it and let me know your opinion.\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        if k == 0: return 0\\n        \\n        length, res = len(arr), 0\\n        \\n        # use sliding window to find res in case\\n        # the resulting subarray is subarray of given \"arr\"\\n        summ = 0\\n        start = 0\\n        for end in range(len(arr)):\\n            summ += arr[end]\\n            while summ < 0:\\n                summ -= arr[start]\\n                start += 1\\n            res = max(res, summ)\\n            \\n        if k == 1: return res % 1000000007\\n        \\n        largest_left = 0 # [arr[0] arr[1] ... arr[x]] ... arr[-1]\\n        summ = 0\\n        for i in range(length):\\n            summ += arr[i]\\n            largest_left = max(largest_left, summ)\\n                \\n        largest_right = 0 # arr[0] ... [arr[x] arr[x+1] arr[-1]]\\n        summ = 0\\n        for i in range(length - 1, -1, -1):\\n            summ += arr[i]\\n            largest_right = max(largest_right, summ)\\n        \\n        res = max(res, largest_left+largest_right,\\\\\\n                  largest_left + largest_right + sum(arr) * (k-2))\\n        return res % 1000000007",
                "solutionTags": [],
                "code": "- In case `k=0`, just return 0\\n- In case `k=1`, just find the maximum subarray within the given `arr`\\n- In case `k>=2`, we need to consider several cases:\\n1. Max subarray can just be some subarray of `arr` itself. When `k=1`, this is definitely the case.\\n2. When we combine right part of one array (`largest_right`) and left part of the array right next to it (`largest_left`), it also could be the answer. It will look like :\\n `arr[0] arr[1] ... {arr[x] ... arr[-2] arr[-1] arr[0] arr[1] ... arr[y] } arr[y+1] ... arr[-2] arr[-1] arr[0] ... etc` \\n where the resulting array is between curly braces.\\n3. This case is similar to `2` except that you can take right part of the first `arr`, fully paste k-2 `arr`s in between,  and take largest left part of `k-th` `arr`.\\n\\n- Since I use for-loop 3 times, iterating over all elements, the time complexity is O(n).\\n\\n- Please, comment on it and let me know your opinion.\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        if k == 0: return 0\\n        \\n        length, res = len(arr), 0\\n        \\n        # use sliding window to find res in case\\n        # the resulting subarray is subarray of given \"arr\"\\n        summ = 0\\n        start = 0\\n        for end in range(len(arr)):\\n            summ += arr[end]\\n            while summ < 0:\\n                summ -= arr[start]\\n                start += 1\\n            res = max(res, summ)\\n            \\n        if k == 1: return res % 1000000007\\n        \\n        largest_left = 0 # [arr[0] arr[1] ... arr[x]] ... arr[-1]\\n        summ = 0\\n        for i in range(length):\\n            summ += arr[i]\\n            largest_left = max(largest_left, summ)\\n                \\n        largest_right = 0 # arr[0] ... [arr[x] arr[x+1] arr[-1]]\\n        summ = 0\\n        for i in range(length - 1, -1, -1):\\n            summ += arr[i]\\n            largest_right = max(largest_right, summ)\\n        \\n        res = max(res, largest_left+largest_right,\\\\\\n                  largest_left + largest_right + sum(arr) * (k-2))\\n        return res % 1000000007",
                "codeTag": "Java"
            },
            {
                "id": 382492,
                "title": "a-python-method-easy-to-understand-but-stupid",
                "content": "```\\ndef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        summing = [0]*(2*n)\\n        left_summing = [0]*n\\n        right_summing = [0]*n\\n        summing[0] = max(0,arr[0])\\n        arr2 = arr*2\\n        left_summing[0] = arr[0]\\n        right_summing[0] = arr[n-1]\\n        for i in range(1,n):\\n            left_summing[i] = left_summing[i-1]+arr[i]\\n            right_summing[i] = right_summing[i-1]+arr[n-1-i]\\n        for i in range(1,2*n):\\n            summing[i] = max(arr2[i],summing[i-1]+arr2[i],0)\\n        sep_sum = max(summing)\\n        ind_sum = sum(arr)\\n        print(sep_sum)\\n        print(ind_sum)\\n        print(left_summing)\\n        print(right_summing)\\n        if sep_sum == ind_sum:\\n            return ind_sum*k % (10**9+7)\\n        else:\\n            return max(sep_sum,(k-2)*ind_sum+max(0,max(left_summing))+max(0,max(right_summing))) % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        summing = [0]*(2*n)\\n        left_summing = [0]*n\\n        right_summing = [0]*n\\n        summing[0] = max(0,arr[0])\\n        arr2 = arr*2\\n        left_summing[0] = arr[0]\\n        right_summing[0] = arr[n-1]\\n        for i in range(1,n):\\n            left_summing[i] = left_summing[i-1]+arr[i]\\n            right_summing[i] = right_summing[i-1]+arr[n-1-i]\\n        for i in range(1,2*n):\\n            summing[i] = max(arr2[i],summing[i-1]+arr2[i],0)\\n        sep_sum = max(summing)\\n        ind_sum = sum(arr)\\n        print(sep_sum)\\n        print(ind_sum)\\n        print(left_summing)\\n        print(right_summing)\\n        if sep_sum == ind_sum:\\n            return ind_sum*k % (10**9+7)\\n        else:\\n            return max(sep_sum,(k-2)*ind_sum+max(0,max(left_summing))+max(0,max(right_summing))) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382457,
                "title": "short-java-dp-solution",
                "content": "```\\nclass Solution {\\n    /*                 **YOU MUST AT LEST TRY TO UNDERSTAND OTHER\\'S CODE (bcz of various reason)... real_LIFE IS NOT TAHT SIMPLE **\\n\\t                                                      hope u can nail it...give it a try  it\\'s easy        :)     \\n    at the end of max_sum call...s1 holds max_sum and s2 holds sum of element other than max_sum_subarray\\n    */\\n    int s1=0,s2=0;\\n    public int max_sum(int[] arr){\\n        int n=arr.length;\\n         int[] dp=new int[n]; dp[0]=arr[0];     // dp[i]=max_sum_subarray ended with arr[i] from 0..upto i\\n        for(int i=1;i<n;i++){    \\n               dp[i]=Math.max(arr[i],arr[i]+dp[i-1]);\\n            s1=Math.max(s1,dp[i]);\\n        }\\n        return s1;\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n=arr.length;\\n        if(arr.length==0){return 0;}\\n        boolean b=true; int xx=0;\\n        for(int i=0;i<arr.length;i++){if(arr[i]>=0){b=false;}xx+=arr[i];} // if all are -ve\\n        if(b){return 0;}\\n        if(xx<=0){\\n            int[] arr1=new int[2*n];\\n            for(int i=0;i<2*n;i++){\\n                arr1[i]=arr[i%n];\\n            }\\n            return max_sum(arr1);\\n        }\\n        else{\\n            max_sum(arr);s2=xx-s1;\\n            int res=0; int mod=(int)1e9+7;\\n            for(int j=1;j<=k;j++){\\n                res=(res+s1+s2)%mod;\\n            }\\n            res-=s2;\\n            return res;\\n        }\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /*                 **YOU MUST AT LEST TRY TO UNDERSTAND OTHER\\'S CODE (bcz of various reason)... real_LIFE IS NOT TAHT SIMPLE **\\n\\t                                                      hope u can nail it...give it a try  it\\'s easy        :)     \\n    at the end of max_sum call...s1 holds max_sum and s2 holds sum of element other than max_sum_subarray\\n    */\\n    int s1=0,s2=0;\\n    public int max_sum(int[] arr){\\n        int n=arr.length;\\n         int[] dp=new int[n]; dp[0]=arr[0];     // dp[i]=max_sum_subarray ended with arr[i] from 0..upto i\\n        for(int i=1;i<n;i++){    \\n               dp[i]=Math.max(arr[i],arr[i]+dp[i-1]);\\n            s1=Math.max(s1,dp[i]);\\n        }\\n        return s1;\\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n=arr.length;\\n        if(arr.length==0){return 0;}\\n        boolean b=true; int xx=0;\\n        for(int i=0;i<arr.length;i++){if(arr[i]>=0){b=false;}xx+=arr[i];} // if all are -ve\\n        if(b){return 0;}\\n        if(xx<=0){\\n            int[] arr1=new int[2*n];\\n            for(int i=0;i<2*n;i++){\\n                arr1[i]=arr[i%n];\\n            }\\n            return max_sum(arr1);\\n        }\\n        else{\\n            max_sum(arr);s2=xx-s1;\\n            int res=0; int mod=(int)1e9+7;\\n            for(int j=1;j<=k;j++){\\n                res=(res+s1+s2)%mod;\\n            }\\n            res-=s2;\\n            return res;\\n        }\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382417,
                "title": "python-3-solution-with-explantion",
                "content": "1. Find out the sum of one arr, if it is <= 0, then repeat it multiple times won\\'t give us a positive sum. In this case, the value of k isnt that meaningful since we dont need to repeat the arr.\\n2. Find out the max subarray arr*2, this is because the maximum sum may come from the end of the first arr and start of the second arr (eg: 2,-4,2 => 2,-4,{2,2},-4,2   max is 4)\\n3. Then the question becomes easy. We have the result from of step 2, and add it to (k-2) times result of step 1. (k-2 because what we did in step 2 consumes two times)\\n4. pay attention to corner cases like k = 1\\n\\n```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        # 1. sum of 1 arr\\n        # 2. largest subarray of two arr\\n        \\n        oneArrSum = sum(arr)\\n        twoArr = arr + arr\\n        \\n        def findMaxSub(array):\\n            if len(array) == 1:\\n                return array[0]\\n            \\n            cur = 0\\n            small = 0\\n            ret = -999999\\n            for i in array:\\n                cur += i\\n                small = cur if cur < small else small\\n                ret = cur - small if cur - small > ret else ret\\n           \\n            return 0 if ret < 0 else ret\\n        \\n        if not arr:\\n            return 0\\n        if k == 1:\\n            return findMaxSub(arr)\\n        \\n        ret = findMaxSub(twoArr)\\n        if oneArrSum > 0 and k > 2:\\n            ret += (k-2)*oneArrSum\\n        return ret % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        # 1. sum of 1 arr\\n        # 2. largest subarray of two arr\\n        \\n        oneArrSum = sum(arr)\\n        twoArr = arr + arr\\n        \\n        def findMaxSub(array):\\n            if len(array) == 1:\\n                return array[0]\\n            \\n            cur = 0\\n            small = 0\\n            ret = -999999\\n            for i in array:\\n                cur += i\\n                small = cur if cur < small else small\\n                ret = cur - small if cur - small > ret else ret\\n           \\n            return 0 if ret < 0 else ret\\n        \\n        if not arr:\\n            return 0\\n        if k == 1:\\n            return findMaxSub(arr)\\n        \\n        ret = findMaxSub(twoArr)\\n        if oneArrSum > 0 and k > 2:\\n            ret += (k-2)*oneArrSum\\n        return ret % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382349,
                "title": "simple-python-solution",
                "content": "If k == 1, we just need to find the maximum continous subarray. If k > 1, the array can forms a1+a2+a3+..+ak as a big array. If sum of the orginal array is greater than 0, that means a2...ak-1 is useful, otherwise we just need to find the maximum continous subarray as the case when k == 1\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        total = sum(arr)\\n        \\n        def solve(a):\\n            ans = cur = 0\\n            for i in a:\\n                cur += i\\n                ans = max(ans, cur)\\n            return ans\\n        \\n        def helper(arr):\\n            ans = cur = 0\\n            for i in arr:\\n                cur += i\\n                ans = max(ans, cur)\\n                if cur < 0:\\n                    cur = 0\\n            return ans\\n        \\n        ans = helper(arr)\\n        if k == 1:\\n            return ans % (10 ** 9 + 7)\\n        return max(max(0,total) * (k - 2) + solve(arr) + solve(arr[::-1]),ans) % (10**9 + 7)",
                "solutionTags": [],
                "code": "If k == 1, we just need to find the maximum continous subarray. If k > 1, the array can forms a1+a2+a3+..+ak as a big array. If sum of the orginal array is greater than 0, that means a2...ak-1 is useful, otherwise we just need to find the maximum continous subarray as the case when k == 1\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        total = sum(arr)\\n        \\n        def solve(a):\\n            ans = cur = 0\\n            for i in a:\\n                cur += i\\n                ans = max(ans, cur)\\n            return ans\\n        \\n        def helper(arr):\\n            ans = cur = 0\\n            for i in arr:\\n                cur += i\\n                ans = max(ans, cur)\\n                if cur < 0:\\n                    cur = 0\\n            return ans\\n        \\n        ans = helper(arr)\\n        if k == 1:\\n            return ans % (10 ** 9 + 7)\\n        return max(max(0,total) * (k - 2) + solve(arr) + solve(arr[::-1]),ans) % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 4101147,
                "title": "c-running-sum-and-prefix-sum",
                "content": "# Intuition\\nWe need to check running Sum and max Prefix sum in first round.\\nif k>1 and last ps >0 then we have to go for one more round to find maxPrefix sum for last element in the arr. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> N= number of elements in arr\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long rs=0,ps=0,maxPrefixSum=0;\\n        int MOD = 1000000007;\\n        for (const auto a:arr){\\n            rs+=a;\\n            if (ps+a<=0) ps=0;\\n            else ps+=a;\\n            maxPrefixSum=max(maxPrefixSum,ps);\\n        }\\n        long long maxPrefixSum1=maxPrefixSum;\\n        if (k>1 && ps>0){\\n            for (const auto a:arr){\\n                if (ps+a<=0) ps=0;\\n                else ps+=a;\\n                maxPrefixSum=max(maxPrefixSum,ps);\\n            }\\n        }\\n        //cout << rs << \"-\" << maxPrefixSum;\\n        return max(max(0LL,max(maxPrefixSum,rs*k)),maxPrefixSum1*k-(maxPrefixSum1-rs)*(k-1))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long rs=0,ps=0,maxPrefixSum=0;\\n        int MOD = 1000000007;\\n        for (const auto a:arr){\\n            rs+=a;\\n            if (ps+a<=0) ps=0;\\n            else ps+=a;\\n            maxPrefixSum=max(maxPrefixSum,ps);\\n        }\\n        long long maxPrefixSum1=maxPrefixSum;\\n        if (k>1 && ps>0){\\n            for (const auto a:arr){\\n                if (ps+a<=0) ps=0;\\n                else ps+=a;\\n                maxPrefixSum=max(maxPrefixSum,ps);\\n            }\\n        }\\n        //cout << rs << \"-\" << maxPrefixSum;\\n        return max(max(0LL,max(maxPrefixSum,rs*k)),maxPrefixSum1*k-(maxPrefixSum1-rs)*(k-1))%MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3986685,
                "title": "c-kadane-s-algorithm-extra-logic-o-n",
                "content": "# Code\\n```\\nlong long int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    long long int findMax(vector<int>&arr){\\n        int n = arr.size();\\n        long long int result = 0 , answer = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            answer = max(answer + (long long int)arr[i] , (long long int)arr[i]);\\n            result = max(result , answer);\\n        }\\n        return result;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(k == 1) return (int)(findMax(arr)%mod);\\n        int n = arr.size();\\n        long long int sum = 0 , firstSum = 0 , lastSum = 0 , temp = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum+=arr[i];\\n            temp+=arr[n - i - 1];\\n            lastSum = max(lastSum , temp);\\n            firstSum = max(sum , firstSum);\\n        }\\n        if(sum<=0){\\n            long long int answer = findMax(arr);\\n            answer = max(answer , firstSum + lastSum);\\n            return (int)(answer)%mod;\\n        }\\n        else{\\n            long long int answer = findMax(arr);\\n            answer = max(answer , firstSum + lastSum);\\n            long long int newSum = sum * (long long int)(k-2);\\n            newSum += (firstSum + lastSum);\\n            answer = max(answer , newSum);\\n            return (int)(answer%mod);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    long long int findMax(vector<int>&arr){\\n        int n = arr.size();\\n        long long int result = 0 , answer = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            answer = max(answer + (long long int)arr[i] , (long long int)arr[i]);\\n            result = max(result , answer);\\n        }\\n        return result;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(k == 1) return (int)(findMax(arr)%mod);\\n        int n = arr.size();\\n        long long int sum = 0 , firstSum = 0 , lastSum = 0 , temp = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum+=arr[i];\\n            temp+=arr[n - i - 1];\\n            lastSum = max(lastSum , temp);\\n            firstSum = max(sum , firstSum);\\n        }\\n        if(sum<=0){\\n            long long int answer = findMax(arr);\\n            answer = max(answer , firstSum + lastSum);\\n            return (int)(answer)%mod;\\n        }\\n        else{\\n            long long int answer = findMax(arr);\\n            answer = max(answer , firstSum + lastSum);\\n            long long int newSum = sum * (long long int)(k-2);\\n            newSum += (firstSum + lastSum);\\n            answer = max(answer , newSum);\\n            return (int)(answer%mod);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976516,
                "title": "deque-solution-o-n-time-o-n-3-space",
                "content": "# Intuition And  Approach\\nCalculate the maximum subarray sum for 2*n sized self concatenated array.\\nApprooach same as problem https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/submissions/1034980678/\\n\\nNow we jsut check if k<=2 we return the maxSum\\n\\nelse we calculate what we can get from middle concatenated arrays\\nif total sum is negative its 0 obviously\\n\\nIf our maximum sum subarray contains some part of both the concatenated and original array we return fromMiddle + maxSum\\n\\nelse we return the maximum of these two values  max( ((long long)fromMiddle + max(0,maxpre) + max(0,sum - minpre))%mod , (long long)maxSum); \\nWe are done.\\n\\n# Complexity\\n- Time complexity O(N):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    const int mod = 1e9+7;\\n\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        auto & nums = arr;\\n        int n = arr.size();\\n\\n        if(k >= 2){\\n            arr.resize(2*n);\\n\\n            for(int i=0;i<n;i++){\\n                arr[n+i] = arr[i];\\n            }\\n            n = 2*n;\\n        }\\n\\n        //question reduced to finding the maximum sum subarray \\n\\n\\n        deque<pair<int,int>> dq; // value then index\\n        int sum = 0;\\n        int maxSum = 0;\\n        int start = -1;\\n        int end = -1;\\n        int head = 0;\\n        int maxpre = 0;\\n        int minpre = 0;\\n\\n        while(head < n){\\n            sum += nums[head];\\n\\n            if(k<2 || (k>=2 && head < n/2)){\\n                maxpre = max(sum , maxpre);\\n                minpre = min(sum , minpre);\\n            }\\n            \\n            if(maxSum < sum){\\n                maxSum = sum;\\n                start  = 0;\\n                end = head;\\n            }\\n\\n            if(dq.empty()){\\n                dq.push_back({sum , head});\\n                head++;\\n                continue;\\n            }\\n\\n            while(!dq.empty() && dq.back().first >= sum){\\n                dq.pop_back();\\n            }\\n\\n            int subSum = sum - dq.front().first;\\n\\n            if(maxSum < subSum){\\n                    maxSum = subSum;\\n                    start = dq.front().second+1;\\n                    end = head;\\n            }\\n\\n            dq.push_back({sum,head});\\n\\n            head++;\\n        }\\n        \\n\\n        if(k<=2)\\n            return maxSum%mod;\\n\\n        sum /= 2;\\n        int fromMiddle = max(0, (int)((k - 2) * (long long)sum % mod));\\n\\n\\n        if ( end-start+1 > n/2 ||  (end-start+1 == n/2 && start != 0)){\\n            return (fromMiddle + maxSum)%mod;\\n        }\\n\\n        return max( ((long long)fromMiddle + max(0,maxpre) + max(0,sum - minpre))%mod , (long long)maxSum); \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    const int mod = 1e9+7;\\n\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        auto & nums = arr;\\n        int n = arr.size();\\n\\n        if(k >= 2){\\n            arr.resize(2*n);\\n\\n            for(int i=0;i<n;i++){\\n                arr[n+i] = arr[i];\\n            }\\n            n = 2*n;\\n        }\\n\\n        //question reduced to finding the maximum sum subarray \\n\\n\\n        deque<pair<int,int>> dq; // value then index\\n        int sum = 0;\\n        int maxSum = 0;\\n        int start = -1;\\n        int end = -1;\\n        int head = 0;\\n        int maxpre = 0;\\n        int minpre = 0;\\n\\n        while(head < n){\\n            sum += nums[head];\\n\\n            if(k<2 || (k>=2 && head < n/2)){\\n                maxpre = max(sum , maxpre);\\n                minpre = min(sum , minpre);\\n            }\\n            \\n            if(maxSum < sum){\\n                maxSum = sum;\\n                start  = 0;\\n                end = head;\\n            }\\n\\n            if(dq.empty()){\\n                dq.push_back({sum , head});\\n                head++;\\n                continue;\\n            }\\n\\n            while(!dq.empty() && dq.back().first >= sum){\\n                dq.pop_back();\\n            }\\n\\n            int subSum = sum - dq.front().first;\\n\\n            if(maxSum < subSum){\\n                    maxSum = subSum;\\n                    start = dq.front().second+1;\\n                    end = head;\\n            }\\n\\n            dq.push_back({sum,head});\\n\\n            head++;\\n        }\\n        \\n\\n        if(k<=2)\\n            return maxSum%mod;\\n\\n        sum /= 2;\\n        int fromMiddle = max(0, (int)((k - 2) * (long long)sum % mod));\\n\\n\\n        if ( end-start+1 > n/2 ||  (end-start+1 == n/2 && start != 0)){\\n            return (fromMiddle + maxSum)%mod;\\n        }\\n\\n        return max( ((long long)fromMiddle + max(0,maxpre) + max(0,sum - minpre))%mod , (long long)maxSum); \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973443,
                "title": "easy-solution",
                "content": "# Intuition\\nrelated to max sum subarry. need to build an array saving \"till current index, what\\'s the max sum of subarray, basically judging by including past is bigger than not? and including this or not?\\n\\nhigh[i] = Math.Max(0, high[i-1]+arr[i]);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif K = 1, then same as sum of max sum subarray. not going to discuss this..\\n\\nsince this is a repeating pattern. this could be different, coz when k >=2, this could be a cyclic, then a thought is to duplicate it to 2 repeats, then we know the cyclic peak.\\n\\nthen it\\'s easy. peak2 + (k-2)*sum is the answer, if sum>=0\\nif sum < 0; just peak2\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.Length, factor = 1000000007;\\n        int[] high = new int[n]; high[0] = arr[0] > 0 ? arr[0] : 0;\\n        int[] twoarr = new int[2*n]; twoarr[0] = arr[0];\\n        int[] twohigh = new int[2*n]; twohigh[0] = high[0];\\n\\n        // peak, peak2 can be 1E10, just over int, but can be hold by long.\\n        long sum = arr[0], peak = high[0], peak2 = twohigh[0];\\n        for(int i = 1; i < 2 * n; i++)\\n        {\\n            twoarr[i] = arr[i % n];\\n            if(i < n)\\n            {\\n                high[i] = Math.Max(0, high[i-1]+arr[i]);\\n                sum += arr[i];\\n                peak = Math.Max((long)high[i], peak);\\n            }\\n            twohigh[i] = Math.Max(0, twohigh[i-1] + twoarr[i]);\\n            peak2 = Math.Max((long)twohigh[i], peak2);\\n        }\\n        \\n        if(k == 1)\\n            return (int)(peak % factor);\\n        else if(sum <= 0)\\n            return (int)(peak2 % factor);\\n        else\\n            return (int)((peak2 + (k - 2) * sum) % factor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.Length, factor = 1000000007;\\n        int[] high = new int[n]; high[0] = arr[0] > 0 ? arr[0] : 0;\\n        int[] twoarr = new int[2*n]; twoarr[0] = arr[0];\\n        int[] twohigh = new int[2*n]; twohigh[0] = high[0];\\n\\n        // peak, peak2 can be 1E10, just over int, but can be hold by long.\\n        long sum = arr[0], peak = high[0], peak2 = twohigh[0];\\n        for(int i = 1; i < 2 * n; i++)\\n        {\\n            twoarr[i] = arr[i % n];\\n            if(i < n)\\n            {\\n                high[i] = Math.Max(0, high[i-1]+arr[i]);\\n                sum += arr[i];\\n                peak = Math.Max((long)high[i], peak);\\n            }\\n            twohigh[i] = Math.Max(0, twohigh[i-1] + twoarr[i]);\\n            peak2 = Math.Max((long)twohigh[i], peak2);\\n        }\\n        \\n        if(k == 1)\\n            return (int)(peak % factor);\\n        else if(sum <= 0)\\n            return (int)(peak2 % factor);\\n        else\\n            return (int)((peak2 + (k - 2) * sum) % factor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935102,
                "title": "swift-solution-highly-efficient-with-easy-to-follow-explanation",
                "content": "# Intuition\\nInitially, my goal is to find the maximum sum of a subarray formed by repeating the original array \\n\\nk times. If k=1, the problem reduces to finding the maximum subarray sum. For k>1, it may involve using parts of the array more than once.\\n# Approach\\nCreate a result() function that computes the maximum subarray sum for a given array. We use dynamic programming (dp) to find the maximum subarray sum, taking O(n) time and O(n) space.\\n\\nFor k=1, the answer is simply arr.result().\\n\\nFor k=2, we concatenate the array with itself and find the maximum subarray sum.\\n\\nFor k>2, we also consider whether the sum of the entire array (sum) is positive or negative. If positive, it contributes to the maximum sum for the k\\u22122 remaining repetitions.\\n# Complexity\\n- Time complexity:\\nHere n is the length of the array. result() takes O(n) time and other operations like sum also take O(n) time.\\n\\n- Space complexity:\\nThe dynamic programming array (dp) takes O(n) space.\\n\\n### (I wrote this code but explanation is from ChatGPT.)\\n\\n# Code\\n```\\nimport Foundation\\n\\nextension Array where Element == Int {\\n    func result() -> Int {\\n        guard !isEmpty else { return 0 }\\n        guard count > 1 else { return Swift.max(0, self[0])}\\n        var dp = [Int](repeating: 0, count: count)\\n        dp[0] = Swift.max(0,  self[0])\\n        for i in 1...count - 1 {\\n            dp[i] = Swift.max(self[i], dp[i-1] + self[i], 0)\\n        }\\n\\n        return dp.max()!\\n    }\\n}\\n\\nclass Solution {\\n    func kConcatenationMaxSum(_ arr: [Int], _ k: Int) -> Int {\\n        let n = 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 + 7\\n\\n        if k == 1 { return arr.result() % n}\\n        let res =  (arr + arr).result() \\n\\n        if k == 2 { return res % n}\\n        let sum = arr.reduce(0) { $0 + $1 }\\n\\n        return (sum <= 0 ? res : res + (k - 2) * sum) % n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport Foundation\\n\\nextension Array where Element == Int {\\n    func result() -> Int {\\n        guard !isEmpty else { return 0 }\\n        guard count > 1 else { return Swift.max(0, self[0])}\\n        var dp = [Int](repeating: 0, count: count)\\n        dp[0] = Swift.max(0,  self[0])\\n        for i in 1...count - 1 {\\n            dp[i] = Swift.max(self[i], dp[i-1] + self[i], 0)\\n        }\\n\\n        return dp.max()!\\n    }\\n}\\n\\nclass Solution {\\n    func kConcatenationMaxSum(_ arr: [Int], _ k: Int) -> Int {\\n        let n = 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 + 7\\n\\n        if k == 1 { return arr.result() % n}\\n        let res =  (arr + arr).result() \\n\\n        if k == 2 { return res % n}\\n        let sum = arr.reduce(0) { $0 + $1 }\\n\\n        return (sum <= 0 ? res : res + (k - 2) * sum) % n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928324,
                "title": "c-using-kadane-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long kadane(vector<int> &arr,int n,int k)\\n{\\n\\tlong long sum=0,maxi=INT_MIN;\\n\\tfor(int i=0;i<n*k;i++)\\n\\t{\\n\\t\\tsum+=arr[i%n];\\n\\t\\tmaxi=max(maxi,sum);\\n\\t\\tif(sum<0)\\n\\t\\t{\\n\\t\\t\\tsum=0;\\n\\t\\t}\\n\\t}\\n\\treturn maxi;\\n\\n}\\n    long long kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        long long maxSubsum;\\n\\t if (k == 1) {\\n                        maxSubsum=kadane(arr, n, k);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                                    return maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n                }\\n\\tint arrSum = 0;\\n\\t\\tfor (int i=0;i<n;i++) {\\n\\t\\t\\tarrSum += arr[i];\\n\\t\\t}\\n\\n               \\n                if (arrSum <= 0) {\\n                        maxSubsum=kadane(arr, n, 2);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                                          return maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n                } \\n\\t\\t\\t\\telse {\\n                        maxSubsum=kadane(arr,n,2);\\n\\t\\t\\t\\t\\t\\tmaxSubsum+=(long long)(k-2)*(long long)arrSum;\\n\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t}\\n                }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long kadane(vector<int> &arr,int n,int k)\\n{\\n\\tlong long sum=0,maxi=INT_MIN;\\n\\tfor(int i=0;i<n*k;i++)\\n\\t{\\n\\t\\tsum+=arr[i%n];\\n\\t\\tmaxi=max(maxi,sum);\\n\\t\\tif(sum<0)\\n\\t\\t{\\n\\t\\t\\tsum=0;\\n\\t\\t}\\n\\t}\\n\\treturn maxi;\\n\\n}\\n    long long kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        long long maxSubsum;\\n\\t if (k == 1) {\\n                        maxSubsum=kadane(arr, n, k);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                                    return maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n                }\\n\\tint arrSum = 0;\\n\\t\\tfor (int i=0;i<n;i++) {\\n\\t\\t\\tarrSum += arr[i];\\n\\t\\t}\\n\\n               \\n                if (arrSum <= 0) {\\n                        maxSubsum=kadane(arr, n, 2);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                                          return maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n                } \\n\\t\\t\\t\\telse {\\n                        maxSubsum=kadane(arr,n,2);\\n\\t\\t\\t\\t\\t\\tmaxSubsum+=(long long)(k-2)*(long long)arrSum;\\n\\t\\t\\t\\t\\t\\tif(maxSubsum<0)\\n\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn maxSubsum%1000000007;\\n\\t\\t\\t\\t\\t\\t}\\n                }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909647,
                "title": "easy-to-understand-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        long sum = 0, max = 0;\\n        int cou = 0;\\n        long a[] = new long[2];\\n        long b[] = new long[2];\\n        int mod = (int)Math.pow(10,9) + 7;\\n        \\n        for(int i = 0; i < 2*n; i++){\\n            if(arr[i % n] < 0) cou++;\\n            sum += arr[i % n] % mod;\\n            if(sum < 0) sum = 0;\\n            max = Math.max(max, sum) % mod;\\n            if(i == n - 1){\\n                a[0] = sum % mod;\\n                a[1] = max % mod;\\n                if(k == 1) return (int) max % mod;\\n            }\\n            if(i == 2 *n - 1) {\\n                b[0] = sum % mod;\\n                b[1] = max % mod;\\n            }\\n        }\\n        if(cou == 2 * n) return 0;\\n\\n        if(cou == 0){\\n            long ans = (max * k) / 2 % mod;\\n            return (int) ans;\\n        }\\n\\n        if(cou < 2 * n){\\n            if(a[0] == b[0])\\n                return (int)max;\\n            else{\\n                long ans = (b[1] - a[1]) * (k - 2) % mod + b[1];\\n                return (int) ans % mod;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        long sum = 0, max = 0;\\n        int cou = 0;\\n        long a[] = new long[2];\\n        long b[] = new long[2];\\n        int mod = (int)Math.pow(10,9) + 7;\\n        \\n        for(int i = 0; i < 2*n; i++){\\n            if(arr[i % n] < 0) cou++;\\n            sum += arr[i % n] % mod;\\n            if(sum < 0) sum = 0;\\n            max = Math.max(max, sum) % mod;\\n            if(i == n - 1){\\n                a[0] = sum % mod;\\n                a[1] = max % mod;\\n                if(k == 1) return (int) max % mod;\\n            }\\n            if(i == 2 *n - 1) {\\n                b[0] = sum % mod;\\n                b[1] = max % mod;\\n            }\\n        }\\n        if(cou == 2 * n) return 0;\\n\\n        if(cou == 0){\\n            long ans = (max * k) / 2 % mod;\\n            return (int) ans;\\n        }\\n\\n        if(cou < 2 * n){\\n            if(a[0] == b[0])\\n                return (int)max;\\n            else{\\n                long ans = (b[1] - a[1]) * (k - 2) % mod + b[1];\\n                return (int) ans % mod;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898676,
                "title": "c-intuitive",
                "content": "# Intuition\\n- Concatenate two times. \\n- Find maximum sum sub array\\n- If normal sum of array > 0, add it to $$k - 2 $$ times.\\n- Handle other case gracefully.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v(n * 2);\\n        long long neg = 0, s = 0;\\n        for(int & i : arr) {\\n            if(i < 0) neg = true;\\n            s += i;\\n        }\\n        if(!neg) {\\n            return (1LL * s * k) % mod;\\n        }\\n        int m = k;\\n        k = min(2, k);\\n        for(int j = 0; j < (n * k); ++j) {\\n            v[j] = arr[j % n];\\n        }\\n        long long p = 0, q = 0;\\n        for(int i = 0; i < k * n; ++i) {\\n            q = max(q + v[i] % mod, 1LL * v[i]) % mod;\\n            p = max(p, q) % mod;\\n        }\\n        \\n        if(s < 0) return p;\\n        m = m - 2;\\n        long long ans = p;\\n        while(m-- > 0) ans = (ans + s) % mod;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v(n * 2);\\n        long long neg = 0, s = 0;\\n        for(int & i : arr) {\\n            if(i < 0) neg = true;\\n            s += i;\\n        }\\n        if(!neg) {\\n            return (1LL * s * k) % mod;\\n        }\\n        int m = k;\\n        k = min(2, k);\\n        for(int j = 0; j < (n * k); ++j) {\\n            v[j] = arr[j % n];\\n        }\\n        long long p = 0, q = 0;\\n        for(int i = 0; i < k * n; ++i) {\\n            q = max(q + v[i] % mod, 1LL * v[i]) % mod;\\n            p = max(p, q) % mod;\\n        }\\n        \\n        if(s < 0) return p;\\n        m = m - 2;\\n        long long ans = p;\\n        while(m-- > 0) ans = (ans + s) % mod;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888622,
                "title": "max-sum-using-c-beats-100",
                "content": "# Intuition\\nEither the max sum includes all arrays if total sum is positive else it includes 2 adjoining arrays since we need to cross hte negative elements of hte array before hitting the positive ones again so we check 2 concatenated arrays VS array sum * num of arrays + (max sum starting from 0 - array sum) + (max sum ending at last index - array sum)\\n\\nWe need to check max sum starting from 0 and max sum ending at last index since we can skip the elements causing the sum to be less than max in first and last concatenated arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is length of array passed. \\n\\n- Space complexity:\\nO(n) where n is length of array passed. Space complexity is just the length of array passed\\n\\n# Code\\n```\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {\\n       long maxSum = 0;\\n       long currSum = 0;\\n       int startIndex = 0;\\n       int endIndex = 0;\\n       long mod = 1000000007;\\n       int maxIterations = k;\\n       k = Math.Min(2, k);\\n\\n       long arraySum = 0;\\n       int i = 0;\\n       while(k > 0) {\\n           if(i < arr.Length){\\n               arraySum += arr[i++];\\n           }\\n\\n           currSum = (currSum + (long)arr[endIndex]);\\n           // mod doesn\\'t work if we do it during sum\\n           // since the curr sum may be less than max sum.\\n           if(currSum > maxSum){\\n               maxSum = currSum;\\n           }\\n\\n           endIndex = (endIndex + 1)%arr.Length;\\n           if(endIndex == 0){\\n               k--;\\n           }\\n\\n            if(currSum <= 0) {\\n                startIndex = endIndex;\\n                currSum = 0;\\n            }\\n       }\\n\\n    \\n       if(arraySum > 0){\\n           long selectAll = arraySum * maxIterations;\\n            // deal with starting negatives\\n            int j = arr.Length - 1;\\n            long localMaxSum = 0;\\n            long localCurrSum = 0;\\n            while(j >= 0){\\n                localCurrSum += arr[j--];\\n                if(localCurrSum > localMaxSum){\\n                    localMaxSum = localCurrSum;\\n                }\\n            }\\n\\n            selectAll += (localMaxSum - arraySum);\\n\\n            // deal with trailing negatives\\n            j = 0;\\n            localMaxSum = 0;\\n            localCurrSum = 0;\\n            while(j < arr.Length){\\n                localCurrSum += arr[j++];\\n                if(localCurrSum > localMaxSum){\\n                    localMaxSum = localCurrSum;\\n                }\\n            }\\n\\n            selectAll += localMaxSum - arraySum;\\n\\n           if(selectAll > maxSum){\\n               maxSum = selectAll;\\n           }\\n       }\\n\\n       return (int)(maxSum%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KConcatenationMaxSum(int[] arr, int k) {\\n       long maxSum = 0;\\n       long currSum = 0;\\n       int startIndex = 0;\\n       int endIndex = 0;\\n       long mod = 1000000007;\\n       int maxIterations = k;\\n       k = Math.Min(2, k);\\n\\n       long arraySum = 0;\\n       int i = 0;\\n       while(k > 0) {\\n           if(i < arr.Length){\\n               arraySum += arr[i++];\\n           }\\n\\n           currSum = (currSum + (long)arr[endIndex]);\\n           // mod doesn\\'t work if we do it during sum\\n           // since the curr sum may be less than max sum.\\n           if(currSum > maxSum){\\n               maxSum = currSum;\\n           }\\n\\n           endIndex = (endIndex + 1)%arr.Length;\\n           if(endIndex == 0){\\n               k--;\\n           }\\n\\n            if(currSum <= 0) {\\n                startIndex = endIndex;\\n                currSum = 0;\\n            }\\n       }\\n\\n    \\n       if(arraySum > 0){\\n           long selectAll = arraySum * maxIterations;\\n            // deal with starting negatives\\n            int j = arr.Length - 1;\\n            long localMaxSum = 0;\\n            long localCurrSum = 0;\\n            while(j >= 0){\\n                localCurrSum += arr[j--];\\n                if(localCurrSum > localMaxSum){\\n                    localMaxSum = localCurrSum;\\n                }\\n            }\\n\\n            selectAll += (localMaxSum - arraySum);\\n\\n            // deal with trailing negatives\\n            j = 0;\\n            localMaxSum = 0;\\n            localCurrSum = 0;\\n            while(j < arr.Length){\\n                localCurrSum += arr[j++];\\n                if(localCurrSum > localMaxSum){\\n                    localMaxSum = localCurrSum;\\n                }\\n            }\\n\\n            selectAll += localMaxSum - arraySum;\\n\\n           if(selectAll > maxSum){\\n               maxSum = selectAll;\\n           }\\n       }\\n\\n       return (int)(maxSum%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881720,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long solve(vector<int>& arr) {\\nint sum=0,mx=-1e5;\\nint n=arr.size();\\nfor(int i=0;i<n;i++){\\nsum+=arr[i];\\nif(sum<0) sum=0;\\nmx=max(sum,mx);\\n}\\nreturn mx;\\n}\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\n        long long ans=0;\\n        int n=arr.size();\\n        long long sum1=solve(arr)%mod;\\n        if(k==1) return solve(arr);\\n        if(k>=2) {\\n       vector<int> num=arr;\\n        num.insert(num.end(),arr.begin(),arr.end());\\n        long long sum2=solve(num);\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=arr[i];\\n       ans=max({(sum2+(k-2)*sum%mod)%mod,((k%mod)*sum%mod)%mod,sum1,sum2});\\n        }\\n        return ans%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long solve(vector<int>& arr) {\\nint sum=0,mx=-1e5;\\nint n=arr.size();\\nfor(int i=0;i<n;i++){\\nsum+=arr[i];\\nif(sum<0) sum=0;\\nmx=max(sum,mx);\\n}\\nreturn mx;\\n}\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\n        long long ans=0;\\n        int n=arr.size();\\n        long long sum1=solve(arr)%mod;\\n        if(k==1) return solve(arr);\\n        if(k>=2) {\\n       vector<int> num=arr;\\n        num.insert(num.end(),arr.begin(),arr.end());\\n        long long sum2=solve(num);\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=arr[i];\\n       ans=max({(sum2+(k-2)*sum%mod)%mod,((k%mod)*sum%mod)%mod,sum1,sum2});\\n        }\\n        return ans%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858023,
                "title": "easy-kadane-s-algorithm",
                "content": "# Intuition\\nOne case is Our answer array that has max subarray sum can have t array in middle and part/full of an array on the left on it and part/full of an array on right of it. So, we can have 1 array, 2 array, 3 .... k-2 at max arrays in middle. This means the number of arrays included in the answer subarray are (3, 4, 5 ..... k).\\nNow if the array has +ve sum, then the more arrays in the middle more it is better. And if -ve sum, then do nothing.\\nNow, a case is left when our answer subarray extends only to 1 or 2 subarrays. That we can handle seperately using Kadane algorithm\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) \\n    {\\n        long long int n = arr.size(), sms = 0, ans = 0, mpre=0, msuf=0, mod = (1e9)+7;\\n        vector<long long int> pre(n+2, 0);\\n        vector<long long int> suf(n+2, 0);\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            pre[i+1] = pre[i] + arr[i];\\n            mpre = max(mpre, pre[i+1]);\\n        }\\n\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            suf[i+1] = arr[i] + suf[i+2];\\n            msuf = max(msuf, suf[i+1]);\\n        }\\n\\n        if(k > 2 && pre[n] > 0)\\n        {\\n            ans = (pre[n]*(k-2)) + mpre + msuf;\\n        }\\n\\n        ans = max(ans, kadane(arr, k));\\n        return (ans % mod);\\n    }\\n\\n    long long int kadane(vector<int> &nums, int k)\\n    {\\n        vector<long long int> vr;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            vr.push_back(nums[i]);\\n        }\\n\\n        if(k > 1)\\n        {\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                vr.push_back(nums[i]);\\n            }\\n        }\\n\\n        long long int maxm=0, max_end_here=0;\\n        for(int i = 0; i < vr.size(); i++)\\n        {\\n            max_end_here += vr[i];\\n            maxm = max(maxm, max_end_here);\\n\\n            if(max_end_here < 0)\\n            {\\n                max_end_here = 0;\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) \\n    {\\n        long long int n = arr.size(), sms = 0, ans = 0, mpre=0, msuf=0, mod = (1e9)+7;\\n        vector<long long int> pre(n+2, 0);\\n        vector<long long int> suf(n+2, 0);\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            pre[i+1] = pre[i] + arr[i];\\n            mpre = max(mpre, pre[i+1]);\\n        }\\n\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            suf[i+1] = arr[i] + suf[i+2];\\n            msuf = max(msuf, suf[i+1]);\\n        }\\n\\n        if(k > 2 && pre[n] > 0)\\n        {\\n            ans = (pre[n]*(k-2)) + mpre + msuf;\\n        }\\n\\n        ans = max(ans, kadane(arr, k));\\n        return (ans % mod);\\n    }\\n\\n    long long int kadane(vector<int> &nums, int k)\\n    {\\n        vector<long long int> vr;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            vr.push_back(nums[i]);\\n        }\\n\\n        if(k > 1)\\n        {\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                vr.push_back(nums[i]);\\n            }\\n        }\\n\\n        long long int maxm=0, max_end_here=0;\\n        for(int i = 0; i < vr.size(); i++)\\n        {\\n            max_end_here += vr[i];\\n            maxm = max(maxm, max_end_here);\\n\\n            if(max_end_here < 0)\\n            {\\n                max_end_here = 0;\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833563,
                "title": "c-easy-just-do-it",
                "content": "# Intution\\n1 2 3 1 2 3 1 2 3 1 2 3\\nwhen sum is positive then cal max sum only in this part\\n1 2 3 1 2 3 as this will give max sum and then add\\ntotal sum of remaining parts or (k-2) * arr_sum \\nif arr sum is not positive so e cannot add other parts\\nas it will lead to negative value only\\nto just find max sum subaaray in temp array;\\nsuppose -1 3 -4 \\ntotal sum is -2 negative so if we add\\n-2 *(k-2) it will result in negative but we dont want\\nso we will find max sum subaray in -1 3 -4 -1 3 -4\\nwhich is i think 3 only so return \\nWhy are we finding max subarray in twicing the array because after that array will repeat so ans will be either maxsum in twiced array + sum of remaining emelents if array_sum is positive \\nor it will be max subarray sum in twiced array only(temp)\\n```\\nclass Solution {\\n    int M = 1000000007;\\npublic:\\n    int kadane(vector<int>&nums)\\n    {\\n        int max_sum = 0;\\n        int cur_sum = 0;\\n        for(int i:nums)\\n        {\\n            cur_sum +=i;\\n            if(cur_sum<0) cur_sum = 0;\\n            max_sum = max(cur_sum,max_sum);\\n        }\\n        return max_sum;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int res = 0;\\n        vector<int> temp(arr);\\n        temp.insert(temp.end(),temp.begin(),temp.end());\\n        // where to insert , start , end\\n        if(k==1) return kadane(arr) % M;\\n        if(k==2) return kadane(temp) % M;\\n        int arr_sum = 0;\\n        for(auto i:arr) arr_sum+=i;\\n        if(arr_sum>0)\\n        {\\n            res = (long long) (k-2) * arr_sum % M;\\n            res = (res + kadane(temp)) % M;\\n        }\\n        else res = kadane(temp) % M;\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int M = 1000000007;\\npublic:\\n    int kadane(vector<int>&nums)\\n    {\\n        int max_sum = 0;\\n        int cur_sum = 0;\\n        for(int i:nums)\\n        {\\n            cur_sum +=i;\\n            if(cur_sum<0) cur_sum = 0;\\n            max_sum = max(cur_sum,max_sum);\\n        }\\n        return max_sum;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int res = 0;\\n        vector<int> temp(arr);\\n        temp.insert(temp.end(),temp.begin(),temp.end());\\n        // where to insert , start , end\\n        if(k==1) return kadane(arr) % M;\\n        if(k==2) return kadane(temp) % M;\\n        int arr_sum = 0;\\n        for(auto i:arr) arr_sum+=i;\\n        if(arr_sum>0)\\n        {\\n            res = (long long) (k-2) * arr_sum % M;\\n            res = (res + kadane(temp)) % M;\\n        }\\n        else res = kadane(temp) % M;\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821256,
                "title": "o-n-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Whole array is only negative numbers :  0\\n2. Whole array is only positive numbers :  k*totalarraysum\\n3. if k==1 : answer can be the maximum subarray sum\\n4. if k>2 : answer can be postmaxsubarray + (k-2)*totalarraysum + leftsubarraysum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wholeNeg(vector<int>& arr){\\n        for(int x : arr) if(x>0) return false;\\n        return true;\\n    }\\n    bool wholePos(vector<int>& arr){\\n        for(int x : arr) if(x<0) return false;\\n        return true;\\n    }\\n    int subarrayMax(vector<int>& arr){\\n        int n=arr.size();\\n        int presum=0;\\n        int minpresum=0;\\n        int res=arr[0];\\n        for(int i=0; i<n; i++){\\n            presum+=arr[i];\\n            res=max(res,presum-minpresum);\\n            minpresum=min(minpresum,presum);\\n        }\\n        return res;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(wholeNeg(arr)) return 0;\\n        int n=arr.size();\\n        long long int totalsum=0, mod=1e9+7;\\n        for(int i=0; i<n; i++) totalsum+=arr[i];\\n        if(wholePos(arr)) return (totalsum*k)%mod;\\n        long long int maxsumfromleft=0, maxsumfromright=0, currsum=0;\\n        for(int i=0; i<n; i++){\\n            currsum+=arr[i];\\n            maxsumfromleft=max(maxsumfromleft,currsum);\\n        }\\n        currsum=0;\\n        for(int i=n-1; i>=0; i--){\\n            currsum+=arr[i];\\n            maxsumfromright=max(maxsumfromright,currsum);\\n        }\\n        long long int  res=(long long int)subarrayMax(arr);\\n        if(k>2) res=max(res,maxsumfromleft+maxsumfromright+totalsum*(k-2));\\n        if(k>1) res=max(res,maxsumfromleft+maxsumfromright);\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wholeNeg(vector<int>& arr){\\n        for(int x : arr) if(x>0) return false;\\n        return true;\\n    }\\n    bool wholePos(vector<int>& arr){\\n        for(int x : arr) if(x<0) return false;\\n        return true;\\n    }\\n    int subarrayMax(vector<int>& arr){\\n        int n=arr.size();\\n        int presum=0;\\n        int minpresum=0;\\n        int res=arr[0];\\n        for(int i=0; i<n; i++){\\n            presum+=arr[i];\\n            res=max(res,presum-minpresum);\\n            minpresum=min(minpresum,presum);\\n        }\\n        return res;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if(wholeNeg(arr)) return 0;\\n        int n=arr.size();\\n        long long int totalsum=0, mod=1e9+7;\\n        for(int i=0; i<n; i++) totalsum+=arr[i];\\n        if(wholePos(arr)) return (totalsum*k)%mod;\\n        long long int maxsumfromleft=0, maxsumfromright=0, currsum=0;\\n        for(int i=0; i<n; i++){\\n            currsum+=arr[i];\\n            maxsumfromleft=max(maxsumfromleft,currsum);\\n        }\\n        currsum=0;\\n        for(int i=n-1; i>=0; i--){\\n            currsum+=arr[i];\\n            maxsumfromright=max(maxsumfromright,currsum);\\n        }\\n        long long int  res=(long long int)subarrayMax(arr);\\n        if(k>2) res=max(res,maxsumfromleft+maxsumfromright+totalsum*(k-2));\\n        if(k>1) res=max(res,maxsumfromleft+maxsumfromright);\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772485,
                "title": "cpp-kadane-s-by-concatenating-two-times-only",
                "content": "# Intuition\\nthink for edge cases only not for all occurence coz you are human not robot. try to find saturation point after which things are starts behaving similar.\\n\\n# Approach\\nlike work on only array when k<=2;\\nthen see the cases;\\nfor example : find kadane for 1 2 1 2(first testcase);\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2*n)\\n\\n# Code\\n```\\nclass Solution {\\nint mod=1e9+7;\\n//code for kadane\\'s algorithm\\n int solve(vector<int>& nums) {\\n        int sum=0;\\n        int maxsum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           if(sum+nums[i]<nums[i]){\\n               sum=nums[i];\\n           }\\n          else{\\n              sum+=nums[i];\\n          }\\n         maxsum=(max(maxsum,sum))%mod;\\n        }\\n        if(maxsum<0){\\n            return 0;\\n        }\\n        return maxsum;\\n\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n       int n=arr.size();\\n       long long sum=accumulate(arr.begin(),arr.end(),0)%mod;\\n       //two times array\\n        vector<int>vec=arr;\\n          for(auto it:arr){\\n              vec.push_back(it);\\n          }\\n        //kadane for two times array\\n       int ans=solve(vec);\\n       if(k==1){\\n           //if k is 1 then normal kadane\\'s algo\\n        return solve(arr)%mod;\\n       }\\n       else if(sum<0){\\n          return ans%mod;\\n       }\\n       else{\\n            return ans%mod+sum*(k-2)%mod;\\n       }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint mod=1e9+7;\\n//code for kadane\\'s algorithm\\n int solve(vector<int>& nums) {\\n        int sum=0;\\n        int maxsum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           if(sum+nums[i]<nums[i]){\\n               sum=nums[i];\\n           }\\n          else{\\n              sum+=nums[i];\\n          }\\n         maxsum=(max(maxsum,sum))%mod;\\n        }\\n        if(maxsum<0){\\n            return 0;\\n        }\\n        return maxsum;\\n\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n       int n=arr.size();\\n       long long sum=accumulate(arr.begin(),arr.end(),0)%mod;\\n       //two times array\\n        vector<int>vec=arr;\\n          for(auto it:arr){\\n              vec.push_back(it);\\n          }\\n        //kadane for two times array\\n       int ans=solve(vec);\\n       if(k==1){\\n           //if k is 1 then normal kadane\\'s algo\\n        return solve(arr)%mod;\\n       }\\n       else if(sum<0){\\n          return ans%mod;\\n       }\\n       else{\\n            return ans%mod+sum*(k-2)%mod;\\n       }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740053,
                "title": "c-solution-kadens-algo-100-faster-code-easy-to-understand-image-explaination",
                "content": "# Check out the image :\\n![image](https://assets.leetcode.com/users/images/763c8f93-13e5-44d0-8cf6-f358605f8957_1688890254.255391.jpeg)\\n\\n# CODE :\\n```\\nclass Solution {\\npublic:\\n        \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n                \\n                int mod = 1e9 + 7;\\n                int n = arr.size();\\n                long long  Kadnes_ans = 0;\\n                long long arr_sum = 0;\\n            \\n            // Using Kadnes Algo \\n              long long temp = 0;\\n              for(int i =0  ;i < n ;i++){\\n                    temp += arr[i];\\n                    if(temp < 0) temp =0;\\n                    Kadnes_ans = max(Kadnes_ans,temp);\\n                        }\\n            // Edge Case\\n            if(k == 1) return Kadnes_ans%mod;\\n            \\n        \\n              long long bestpreffix = 0;\\n              long long bestsuffix = 0;\\n                temp = 0;\\n            for(int i = 0 ; i < n ; i++){\\n                    temp += arr[i];\\n                    bestpreffix= max(bestpreffix , temp);\\n                \\n            }\\n            \\n            sum = temp; // Array Sum \\n            temp = 0;\\n            for(int i = n-1 ; i>= 0;i--){\\n                    temp += arr[i];\\n                    bestsuffix = max(bestsuffix,temp);\\n                                       \\n            }\\n           long long ans;  \\n        if(sum >= 0) { // For positive Array Sum\\n        \\n       ans = max(bestpreffix + bestsuffix +  (long long)(k-2)*(long long)(sum)  ,Kadnes_ans );\\n                \\n            }\\n        else{    \\n                // For Negative Array Sum\\n             ans =  max((bestpreffix + bestsuffix), Kadnes_ans);\\n         }\\n               return ans%mod;\\n                    \\n            \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n                \\n                int mod = 1e9 + 7;\\n                int n = arr.size();\\n                long long  Kadnes_ans = 0;\\n                long long arr_sum = 0;\\n            \\n            // Using Kadnes Algo \\n              long long temp = 0;\\n              for(int i =0  ;i < n ;i++){\\n                    temp += arr[i];\\n                    if(temp < 0) temp =0;\\n                    Kadnes_ans = max(Kadnes_ans,temp);\\n                        }\\n            // Edge Case\\n            if(k == 1) return Kadnes_ans%mod;\\n            \\n        \\n              long long bestpreffix = 0;\\n              long long bestsuffix = 0;\\n                temp = 0;\\n            for(int i = 0 ; i < n ; i++){\\n                    temp += arr[i];\\n                    bestpreffix= max(bestpreffix , temp);\\n                \\n            }\\n            \\n            sum = temp; // Array Sum \\n            temp = 0;\\n            for(int i = n-1 ; i>= 0;i--){\\n                    temp += arr[i];\\n                    bestsuffix = max(bestsuffix,temp);\\n                                       \\n            }\\n           long long ans;  \\n        if(sum >= 0) { // For positive Array Sum\\n        \\n       ans = max(bestpreffix + bestsuffix +  (long long)(k-2)*(long long)(sum)  ,Kadnes_ans );\\n                \\n            }\\n        else{    \\n                // For Negative Array Sum\\n             ans =  max((bestpreffix + bestsuffix), Kadnes_ans);\\n         }\\n               return ans%mod;\\n                    \\n            \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734031,
                "title": "complete-explaination-of-short-and-precise-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first though that come\\'s to mind while solving this problem is to: \\n1. Find naximum sum using Kadane\\'s algorithm.\\n2. Find the maximum prefix and suffix sum and then add them to $$(k - 2) * total$$ where $$total$$ is the total sum of the array. \\n3. Return the maximum from both the above answers.\\n\\nBut here\\'s the catch, we don\\'t need to solve for both the sums separately. We will directly take the given array twicw when $$k >= 2$$ and apply Kadane\\'s to it, add $$(k - 2) * total$$ to the answer returned from Kadane\\'s algorithm. Note the sum returned can be of the subarray which contains intersection(made from prefix and suffix sum) and also which doesn\\'t. But we are adding $$(k - 2) * total$$ irrespective of whether it contains the intersection or not.\\n\\nLet\\'s prove why this work\\'s:\\nTake an array $$A = [a, b, c]$$. $$a$$ represents the prefix of the array, $$b$$ represents the subarray from which we got the maximum sum using Kadane\\'s algorithm and $$c$$ represents the suffix of the array. If $$(k >= 2)$$, the array would look like $$A1 = [a, b, c, a, b, c]$$ if we take the array twice. Few things to note here:\\n1. $$a + c$$ should be negative, if not, then we had added it to $$b$$ to make maximum subarray.\\n2. $$b$$ should be positive, in the case where $$b$$ is negative, answer would be 0, because then the whole array is negative.\\n\\nNow we have 2 cases:\\n1. $$b > |a + c|$$, sum of whole array is positive.\\n2. $$b < |a + c|$$, sum of whole array is negative\\n\\nIn the first case, we have $$b + a + c > 0$$, since $$b$$ is greater than $$|a + c|$$. If we will add $$b$$ to both the sides of the equation, we will get $$b + a + c + b > b$$. Hence this proves that $$prefix + suffix$$ will always have a sum greater then that we got using Kadane\\'s algorithm on the $$A$$ array i.e. $$b$$(note that $$b + a + c + b$$ contains intersection). This proves theat if we combine the array twice and then use Kadane\\'s algorithm, the subarray will always lie of the intersection of the two arrays. Hence we can use Kadane\\'s on the $$A1$$ array, it will give $$b + a + c + b$$ as the maximum subarray and then we will just add this to $$(k - 2) * total$$ which will only increase that answer since the sum of whole array is positive.\\n\\nIn the second case, since the sum of whole array is negative and hence we don\\'t need to take care of $$prefix-suffix$$ sum to multiply it by $$(k - 2) * total$$ because $$total$$ is negative and it will only make the sum less. Hence, whatever Kadane\\'s return will be the answer.\\n\\nHence we have proved that we do not need to calculate the two sum\\'s separately.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int curr_max = 0, ans = 0;\\n        int n = arr.size();\\n        int total_sum = 0;\\n        for (int i = 0; i < n * min(k, 2); i++) {\\n            curr_max = max(curr_max + arr[i % n], arr[i % n]);\\n            ans = max(ans, curr_max);\\n            total_sum += arr[i % n];\\n        }\\n        total_sum /= 2;\\n        int MOD = 1e9 + 7;\\n        int sumk = (k > 1 ? ((long)(k - 2) * total_sum) % MOD : 0);\\n        return max(ans % MOD, (ans + sumk) % MOD);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int curr_max = 0, ans = 0;\\n        int n = arr.size();\\n        int total_sum = 0;\\n        for (int i = 0; i < n * min(k, 2); i++) {\\n            curr_max = max(curr_max + arr[i % n], arr[i % n]);\\n            ans = max(ans, curr_max);\\n            total_sum += arr[i % n];\\n        }\\n        total_sum /= 2;\\n        int MOD = 1e9 + 7;\\n        int sumk = (k > 1 ? ((long)(k - 2) * total_sum) % MOD : 0);\\n        return max(ans % MOD, (ans + sumk) % MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682664,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int maxForK1 = SolveFor1(arr), max = maxForK1 , pref = 0 , bestPref = 0 , suff =0, bestSuff = 0, totalSum =0;\\n        \\n        if (k==1) return maxForK1;\\n        \\n        for (int num:arr) {\\n            totalSum += num;\\n            pref += num;\\n            bestPref = Math.max(pref,bestPref);\\n        }\\n\\n        for (int i=arr.length-1; i>=0; i--){\\n            suff += arr[i];\\n            bestSuff = Math.max(suff,bestSuff);\\n        }\\n\\n        if (k>2) {\\n            //totalSum *= k-2;  mod 1000000007 version \\n            int x = totalSum;\\n            for (int i=0;i<k-3; i++){\\n                totalSum = (totalSum + x) % 1000000007;\\n            }\\n            totalSum= Math.max (0,totalSum);\\n        }\\n        else totalSum = 0;\\n\\n        if ((bestSuff + totalSum) > 1000000007 || (bestSuff + totalSum + bestPref ) > 1000000007) {\\n            return ((bestSuff + totalSum) % 1000000007 + bestPref ) % 1000000007 ;\\n        }\\n        \\n        return Math.max(maxForK1, ((bestSuff + totalSum) % 1000000007 + bestPref ) % 1000000007);\\n    }\\n\\n    private int SolveFor1(int[] arr){\\n        int sum=0,max=0;\\n        for (int num:arr){\\n            sum = Math.max(0, sum + num);\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int maxForK1 = SolveFor1(arr), max = maxForK1 , pref = 0 , bestPref = 0 , suff =0, bestSuff = 0, totalSum =0;\\n        \\n        if (k==1) return maxForK1;\\n        \\n        for (int num:arr) {\\n            totalSum += num;\\n            pref += num;\\n            bestPref = Math.max(pref,bestPref);\\n        }\\n\\n        for (int i=arr.length-1; i>=0; i--){\\n            suff += arr[i];\\n            bestSuff = Math.max(suff,bestSuff);\\n        }\\n\\n        if (k>2) {\\n            //totalSum *= k-2;  mod 1000000007 version \\n            int x = totalSum;\\n            for (int i=0;i<k-3; i++){\\n                totalSum = (totalSum + x) % 1000000007;\\n            }\\n            totalSum= Math.max (0,totalSum);\\n        }\\n        else totalSum = 0;\\n\\n        if ((bestSuff + totalSum) > 1000000007 || (bestSuff + totalSum + bestPref ) > 1000000007) {\\n            return ((bestSuff + totalSum) % 1000000007 + bestPref ) % 1000000007 ;\\n        }\\n        \\n        return Math.max(maxForK1, ((bestSuff + totalSum) % 1000000007 + bestPref ) % 1000000007);\\n    }\\n\\n    private int SolveFor1(int[] arr){\\n        int sum=0,max=0;\\n        for (int num:arr){\\n            sum = Math.max(0, sum + num);\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682309,
                "title": "96-beat-c-simple-solution-using-kadane-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint n = arr.size(),sum = 0, mod = 1000000007;\\n\\tint gsum = accumulate(arr.begin(),arr.end(),0);\\n\\tint maxSuf = gsum, maxPre = 0;\\n\\n    int S = 0;\\n    int res = INT_MIN;\\n    for(auto& i:arr){\\n        S = (S+i)%mod;\\n        res = max(res,S);\\n        if(S<0){\\n            S = 0;\\n        }\\n    }\\n    \\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tsum += arr[i];\\n\\t\\tmaxSuf = max(maxSuf,gsum-sum);\\n\\t\\tmaxPre = max(sum,maxPre);\\n\\t}\\n\\n\\tif(k == 1){\\n        if(res>0){\\n            return res;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n\\treturn (max(max(0ll,(long long)(k-2)*sum)+maxSuf+maxPre,(long long)res))%mod;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n\\tint n = arr.size(),sum = 0, mod = 1000000007;\\n\\tint gsum = accumulate(arr.begin(),arr.end(),0);\\n\\tint maxSuf = gsum, maxPre = 0;\\n\\n    int S = 0;\\n    int res = INT_MIN;\\n    for(auto& i:arr){\\n        S = (S+i)%mod;\\n        res = max(res,S);\\n        if(S<0){\\n            S = 0;\\n        }\\n    }\\n    \\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tsum += arr[i];\\n\\t\\tmaxSuf = max(maxSuf,gsum-sum);\\n\\t\\tmaxPre = max(sum,maxPre);\\n\\t}\\n\\n\\tif(k == 1){\\n        if(res>0){\\n            return res;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n\\treturn (max(max(0ll,(long long)(k-2)*sum)+maxSuf+maxPre,(long long)res))%mod;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589115,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        \\n        def dp(arr):\\n            cum_sum = 0\\n            max_sum = 0\\n            for i in arr:\\n                cum_sum = max(i, cum_sum + i)\\n                max_sum = max(max_sum, cum_sum)\\n            return max_sum\\n        \\n        res = dp(arr)\\n        return (max(res + (dp(3*arr)-dp(2*arr))*(k-1), dp(2*arr if k > 1 else arr))%1000000007)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        \\n        def dp(arr):\\n            cum_sum = 0\\n            max_sum = 0\\n            for i in arr:\\n                cum_sum = max(i, cum_sum + i)\\n                max_sum = max(max_sum, cum_sum)\\n            return max_sum\\n        \\n        res = dp(arr)\\n        return (max(res + (dp(3*arr)-dp(2*arr))*(k-1), dp(2*arr if k > 1 else arr))%1000000007)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551659,
                "title": "solution-k-concatenation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n My first thought process to this problem was try to find the maximum sub array - in case if the total sum is greater then zero and the given k = 1 then in that situation the answer will be the total sum. \\nand if k is greater than 1 then I will multiply the total sum with k and that will be my answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Try to find the maximum sum of sub-array.\\n2)if (k == 1) return the maximum sum sub-array.\\n3)if k >= 2 in that case we have to find the maximum-suffix-sum and maximum prefix-sum and total-sum.\\n4)if total-sum >= 0 then in that case I will return maximum of \\nmax_prefix_sum+max_suffix_sum+total_sum*(k-2)[we are multiplying by k-2 because the first and last array is used for calculating the maximum prefix sum and maximum suffix sum respectively.] and kadaneSum,the maximum will be our answer.\\n5)if total_sum < 0 int that case we have to find maximum of max_prefix_sum+max_suffix_sum and kadanesum because if we take total-sum*(k-1) in this case the answer we will get is negative so there is no need to consider that part.\\n6)Finally we will return the ans .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n Time complexity = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n Space complexity = O(1)\\n# Code\\n```\\nconst int M = 1000000007;\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int kadaneSum(vector<int>& arr)\\n    {\\n        ll mx = INT_MIN;\\n        ll sum = 0;\\n        for(int i = 0;i < arr.size();i++){\\n            sum = (sum + arr[i]) % M;\\n            if (sum < 0){\\n                sum = 0;\\n            }\\n            if (sum >= mx){\\n                mx = sum;\\n            }\\n        }\\n        return mx;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if (k == 1){\\n            return kadaneSum(arr);\\n        }\\n        ll prefix_sum = 0,suffix_sum = 0;\\n        ll max_prefix_sum = INT_MIN, max_suffix_sum = INT_MIN,total_sum=0;\\n          ll ans = kadaneSum(arr);\\n        if (k >= 2){\\n            for(int i = 0;i < arr.size();i++){\\n                prefix_sum += arr[i];\\n                if (prefix_sum > max_prefix_sum){\\n                    max_prefix_sum = prefix_sum;\\n                }\\n            }\\n              total_sum = prefix_sum%M;\\n             for(int i = arr.size()-1;i >= 0;i--){\\n                suffix_sum += arr[i];\\n                if (suffix_sum > max_suffix_sum){\\n                    max_suffix_sum = suffix_sum;\\n                }\\n            }\\n          \\n            if (total_sum >= 0){\\n                ans = max(ans,(max_prefix_sum+max_suffix_sum+total_sum*(k-2)));         \\n            }\\n            else{\\n                ans = max(ans,(max_prefix_sum+max_suffix_sum));    \\n            }\\n\\n        \\n        }\\n     return ans%M;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int M = 1000000007;\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int kadaneSum(vector<int>& arr)\\n    {\\n        ll mx = INT_MIN;\\n        ll sum = 0;\\n        for(int i = 0;i < arr.size();i++){\\n            sum = (sum + arr[i]) % M;\\n            if (sum < 0){\\n                sum = 0;\\n            }\\n            if (sum >= mx){\\n                mx = sum;\\n            }\\n        }\\n        return mx;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        if (k == 1){\\n            return kadaneSum(arr);\\n        }\\n        ll prefix_sum = 0,suffix_sum = 0;\\n        ll max_prefix_sum = INT_MIN, max_suffix_sum = INT_MIN,total_sum=0;\\n          ll ans = kadaneSum(arr);\\n        if (k >= 2){\\n            for(int i = 0;i < arr.size();i++){\\n                prefix_sum += arr[i];\\n                if (prefix_sum > max_prefix_sum){\\n                    max_prefix_sum = prefix_sum;\\n                }\\n            }\\n              total_sum = prefix_sum%M;\\n             for(int i = arr.size()-1;i >= 0;i--){\\n                suffix_sum += arr[i];\\n                if (suffix_sum > max_suffix_sum){\\n                    max_suffix_sum = suffix_sum;\\n                }\\n            }\\n          \\n            if (total_sum >= 0){\\n                ans = max(ans,(max_prefix_sum+max_suffix_sum+total_sum*(k-2)));         \\n            }\\n            else{\\n                ans = max(ans,(max_prefix_sum+max_suffix_sum));    \\n            }\\n\\n        \\n        }\\n     return ans%M;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3538371,
                "title": "k-concatenation-maximum-sum",
                "content": "------------------- Easy Java Solution -------------------\\n\\n# Code\\n```\\nclass Solution {\\n      public static long solution(int[] arr, int k, long sum){\\n        if(k == 1){\\n            return kadanesForOne(arr);\\n        }\\n        if(sum > 0){\\n            return  kadanesForTwo(arr) + ((k - 2) * (sum));\\n        }else{\\n            return kadanesForTwo(arr);\\n        }\\n    }\\n\\n    public static long kadanesForOne(int[] arr) {\\n        long finalans = arr[0];\\n        long curr = arr[0];\\n        for(int i = 1 ; i < arr.length; i++){\\n            curr = Math.max(arr[i], arr[i] + curr);\\n            finalans = Math.max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n\\n    public static long kadanesForTwo(int[] arr) {\\n        long finalans = arr[0];\\n        long curr = arr[0];\\n        for(int i = 1 ; i < 2 * arr.length; i++){\\n            curr = Math.max(arr[i % arr.length], arr[i % arr.length] + curr);\\n            finalans = Math.max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n        }\\n        sum=sum%1000000007;\\n        int sol=(int)(solution(arr, k, sum)%1000000007);\\n       return sol==-1?0:sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public static long solution(int[] arr, int k, long sum){\\n        if(k == 1){\\n            return kadanesForOne(arr);\\n        }\\n        if(sum > 0){\\n            return  kadanesForTwo(arr) + ((k - 2) * (sum));\\n        }else{\\n            return kadanesForTwo(arr);\\n        }\\n    }\\n\\n    public static long kadanesForOne(int[] arr) {\\n        long finalans = arr[0];\\n        long curr = arr[0];\\n        for(int i = 1 ; i < arr.length; i++){\\n            curr = Math.max(arr[i], arr[i] + curr);\\n            finalans = Math.max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n\\n    public static long kadanesForTwo(int[] arr) {\\n        long finalans = arr[0];\\n        long curr = arr[0];\\n        for(int i = 1 ; i < 2 * arr.length; i++){\\n            curr = Math.max(arr[i % arr.length], arr[i % arr.length] + curr);\\n            finalans = Math.max(finalans, curr);\\n        }\\n        return finalans; \\n    }\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n        }\\n        sum=sum%1000000007;\\n        int sol=(int)(solution(arr, k, sum)%1000000007);\\n       return sol==-1?0:sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529946,
                "title": "simple-kadanes-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) // O(N) if we consider doubling the given nums array \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int>&nums,int k)\\n    {\\n        int sum=0,n=nums.size();\\n        if(k>1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=nums[i];\\n                nums.push_back(nums[i]);\\n            }\\n        }\\n        int curr=0,ans=INT_MIN,m=1e9+7;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr+=nums[i];\\n            if(curr<0)\\n               curr=0;\\n            ans=max(ans,curr);\\n            \\n        }\\n        if(k==1 || sum<0)\\n            return ans;\\n        return (ans+1LL*(k-2)*sum)%m;\\n        \\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        return kadanes(arr,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int>&nums,int k)\\n    {\\n        int sum=0,n=nums.size();\\n        if(k>1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=nums[i];\\n                nums.push_back(nums[i]);\\n            }\\n        }\\n        int curr=0,ans=INT_MIN,m=1e9+7;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr+=nums[i];\\n            if(curr<0)\\n               curr=0;\\n            ans=max(ans,curr);\\n            \\n        }\\n        if(k==1 || sum<0)\\n            return ans;\\n        return (ans+1LL*(k-2)*sum)%m;\\n        \\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        return kadanes(arr,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516904,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define e 1000000007\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    // 3 - condition  \\n    // 1. all value < 0 => No matter k => return 0;\\n\\n    // Ex [1,2,3,-4,-5,-6,1,2,4] => totalsum < 0, k = 3,4,5,6,7....\\n    // 2. Max SubSum = [1,2,4,1,2,3] ,just do k=2 is ok\\n\\n    // Ex [1,-4,5,6,-5] => totalsum > 0, k = 3,4,5,6,7....\\n    // 3. Max SubSum = [5,6,-5,[1,-4,5,6,-5].....,1,-4,5,6] = [5,6,-5 + 1,-4,5,6](repeat 2th) + totalsum*(k-2)\\n    int res=INT_MIN;\\n    int currsum=0;\\n    int totalsum=0;\\n    for(int i=0;i<arrSize*fmin(k,2);i++){\\n        currsum=fmax(arr[i%arrSize]+currsum,arr[i%arrSize]);\\n        res=fmax(res,currsum);\\n        if(i<arrSize) totalsum+=arr[i];\\n    }\\n    \\n    if(k<=2) return max(0,res%e);\\n    return max(0,max(res%e,(int)((((long)totalsum*((long)(k-2)))+res)%e)));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define e 1000000007\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    // 3 - condition  \\n    // 1. all value < 0 => No matter k => return 0;\\n\\n    // Ex [1,2,3,-4,-5,-6,1,2,4] => totalsum < 0, k = 3,4,5,6,7....\\n    // 2. Max SubSum = [1,2,4,1,2,3] ,just do k=2 is ok\\n\\n    // Ex [1,-4,5,6,-5] => totalsum > 0, k = 3,4,5,6,7....\\n    // 3. Max SubSum = [5,6,-5,[1,-4,5,6,-5].....,1,-4,5,6] = [5,6,-5 + 1,-4,5,6](repeat 2th) + totalsum*(k-2)\\n    int res=INT_MIN;\\n    int currsum=0;\\n    int totalsum=0;\\n    for(int i=0;i<arrSize*fmin(k,2);i++){\\n        currsum=fmax(arr[i%arrSize]+currsum,arr[i%arrSize]);\\n        res=fmax(res,currsum);\\n        if(i<arrSize) totalsum+=arr[i];\\n    }\\n    \\n    if(k<=2) return max(0,res%e);\\n    return max(0,max(res%e,(int)((((long)totalsum*((long)(k-2)))+res)%e)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503135,
                "title": "swift-100-fastest-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\nIt looks like a subarray max sum problem.\\n\\n# Approach\\nIf the sum of all elements in arr > 0 we will have to add up all sums of arr by repeating it k-2 times. -2 is because we are going to exclude the most left and the most right arrays where we can maximize the sums by finding the maximum sums of the subarray which have starting point from the 0 index (this is the last array in the sequence) and the subarray with the ending point at the latest index (this is the first array in the sequence).\\nThe edge cases:\\n1) When k == 1 we need to find a subarray max sum. \\n2) When the sum of all elements in arr is less or equal to 0, then either we need to find a subarray max sum or the sum of the maximum sums of the subarray which have starting point from the 0 index and the subarray with the ending point at the latest index. This is because those subarrays will concatanate sitting next to each other. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func kConcatenationMaxSum(_ arr: [Int], _ k: Int) -> Int {\\n        if k == 1 {\\n            return max(maxSubarraySum(arr), 0)\\n        }\\n        \\n        let sum = arr.reduce(0, +)\\n        \\n        let count = arr.count\\n        var leftSum = sum\\n        var rightSum = sum\\n        var maxRightSum = sum\\n        var maxLeftSum = sum\\n        for i in 0..<count-1 {\\n            leftSum -= arr[count-1-i]\\n            maxLeftSum = max(maxLeftSum, leftSum)\\n            rightSum -= arr[i]\\n            maxRightSum = max(maxRightSum, rightSum)\\n        }\\n        \\n        if sum <= 0 {\\n            return max(maxLeftSum + maxRightSum, maxSubarraySum(arr), 0)\\n        }\\n        \\n        let produce: Int64 = (Int64(sum) * Int64(k-2) + Int64(maxLeftSum) + Int64(maxRightSum)) % 1000000007\\n        return Int(produce)\\n    }\\n    \\n    private func maxSubarraySum(_ arr: [Int]) -> Int {\\n        var sum = 0\\n        var maxResult = Int.min\\n        for num in arr {\\n            sum += num\\n            if sum > maxResult {\\n                maxResult = sum\\n            }\\n            if sum < 0 {\\n                sum = 0\\n            }\\n        }\\n        return maxResult\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kConcatenationMaxSum(_ arr: [Int], _ k: Int) -> Int {\\n        if k == 1 {\\n            return max(maxSubarraySum(arr), 0)\\n        }\\n        \\n        let sum = arr.reduce(0, +)\\n        \\n        let count = arr.count\\n        var leftSum = sum\\n        var rightSum = sum\\n        var maxRightSum = sum\\n        var maxLeftSum = sum\\n        for i in 0..<count-1 {\\n            leftSum -= arr[count-1-i]\\n            maxLeftSum = max(maxLeftSum, leftSum)\\n            rightSum -= arr[i]\\n            maxRightSum = max(maxRightSum, rightSum)\\n        }\\n        \\n        if sum <= 0 {\\n            return max(maxLeftSum + maxRightSum, maxSubarraySum(arr), 0)\\n        }\\n        \\n        let produce: Int64 = (Int64(sum) * Int64(k-2) + Int64(maxLeftSum) + Int64(maxRightSum)) % 1000000007\\n        return Int(produce)\\n    }\\n    \\n    private func maxSubarraySum(_ arr: [Int]) -> Int {\\n        var sum = 0\\n        var maxResult = Int.min\\n        for num in arr {\\n            sum += num\\n            if sum > maxResult {\\n                maxResult = sum\\n            }\\n            if sum < 0 {\\n                sum = 0\\n            }\\n        }\\n        return maxResult\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449929,
                "title": "kadane-s-algorithm-easy",
                "content": "Step 1: if k==1 then simple kadane\\nStep 2: if sum(arr) is postive then (k-2) X sum(arr) + kadanesofTwoArray(arr)\\nStep 3: if sum(arr) is negative or zero then kadanesofTwoArray(arr)\\n\\n```\\nclass Solution {\\n    int mod  = (int) Math.pow(10,9)+7;\\n    public long kadane(int []arr)\\n    {\\n        long max=arr[0];\\n        long ans=arr[0];\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            max=Math.max(max+arr[i],arr[i]);\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=Arrays.stream(arr).sum();\\n        int sol=0;\\n        if(k==1)\\n            sol=(int)(kadane(arr)%mod);\\n        else if(sum>0)\\n            sol=(int)((((k-2)*sum)%mod + kadane2s(arr)%mod)%mod);\\n        else\\n            sol=(int)(kadane2s(arr)%mod);\\n        return Math.max(sol,0);          \\n    }\\n    //kadane of 2 same array if arr=[1,2,3] then [1,2,3,1,2,3] on this array kadane is used\\n    public long kadane2s(int []arr)\\n    {\\n        long max=arr[0];\\n        long ans=arr[0];\\n        for(int i=1;i<2*arr.length;i++)\\n        {\\n            max=Math.max(max+arr[i%arr.length],arr[i%arr.length]);\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int mod  = (int) Math.pow(10,9)+7;\\n    public long kadane(int []arr)\\n    {\\n        long max=arr[0];\\n        long ans=arr[0];\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            max=Math.max(max+arr[i],arr[i]);\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long sum=Arrays.stream(arr).sum();\\n        int sol=0;\\n        if(k==1)\\n            sol=(int)(kadane(arr)%mod);\\n        else if(sum>0)\\n            sol=(int)((((k-2)*sum)%mod + kadane2s(arr)%mod)%mod);\\n        else\\n            sol=(int)(kadane2s(arr)%mod);\\n        return Math.max(sol,0);          \\n    }\\n    //kadane of 2 same array if arr=[1,2,3] then [1,2,3,1,2,3] on this array kadane is used\\n    public long kadane2s(int []arr)\\n    {\\n        long max=arr[0];\\n        long ans=arr[0];\\n        for(int i=1;i<2*arr.length;i++)\\n        {\\n            max=Math.max(max+arr[i%arr.length],arr[i%arr.length]);\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422717,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar kConcatenationMaxSum = function(arr, k) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = arr.length;\\n    const minK = Math.min(2, k);\\n    const sum = arr.reduce((total, num) => total + num);\\n    let currnetSum = result = 0;\\n\\n    for (let index = 0; index < size * minK; index++) {\\n        const num = arr[index % size];\\n\\n        currnetSum = Math.max(currnetSum + num, num);\\n        result = Math.max(result, currnetSum);\\n    }\\n    return Math.max(result, sum * Math.max(0, k - 2) + result) % MODULO;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kConcatenationMaxSum = function(arr, k) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = arr.length;\\n    const minK = Math.min(2, k);\\n    const sum = arr.reduce((total, num) => total + num);\\n    let currnetSum = result = 0;\\n\\n    for (let index = 0; index < size * minK; index++) {\\n        const num = arr[index % size];\\n\\n        currnetSum = Math.max(currnetSum + num, num);\\n        result = Math.max(result, currnetSum);\\n    }\\n    return Math.max(result, sum * Math.max(0, k - 2) + result) % MODULO;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3365556,
                "title": "easy-c-k-concatenation-maximum-subarray-sum",
                "content": "# Intuition\\nI thought it like the kadane\\'s algorithim but with a twist of k\\nso at first when i did it normally not all of my test cases were passed so tried a different method.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n#define MOD (1\\'000\\'000\\'000 + 7)\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int> &arr, int k) {\\n        long total_sum, min_sum, max_sum;\\n        total_sum = min_sum = max_sum = 0;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            total_sum += arr[i];\\n            min_sum = min(total_sum, min_sum);\\n            max_sum = max(total_sum - min_sum, max_sum);\\n        }\\n        if (k == 1 || max_sum == 0)\\n            return max_sum;\\n        long onepass_sum = total_sum;\\n        //using kaden\\'s algo twice\\n        for (int i = 0; i < arr.size(); ++i) {\\n            total_sum += arr[i];\\n            min_sum = min(total_sum, min_sum);\\n            max_sum = max(total_sum - min_sum, max_sum);\\n        }\\n        if (k == 2 || onepass_sum < 0)\\n            return max_sum % MOD;\\n        return (max_sum + (k - 2) * onepass_sum) % MOD;\\n    }\\n};\\n\\n\\n\\n//39 test cases passed \\n//#define MOD (1\\'000\\'000\\'000 + 7)\\n// class Solution {\\n// public:\\n//     long long kConcatenationMaxSum(vector<int>& arr, int k) {\\n//         vector<int> nums;\\n//         while(k>0){\\n//             for(int i=0;i<arr.size();i++){\\n//                 nums.push_back(arr[i]);\\n//                  }\\n//             k--;\\n//         }\\n//            long cmax=0,sum=0,max1=INT_MIN;\\n//             for(int i=0;i<nums.size();i++){\\n//                 if(nums[i]>max1){\\n//                     max1=nums[i];\\n//                 }\\n//                 cmax+=nums[i];\\n//                 if(cmax>sum){\\n//                     sum=cmax;\\n//                 }\\n//                 if(cmax<0){\\n//                     cmax=0;\\n//                     continue;\\n//                 }\\n//             }\\n//             if(sum==0){\\n//                 return 0;\\n//             }\\n//             return sum%MOD;}\\n// };\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD (1\\'000\\'000\\'000 + 7)\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int> &arr, int k) {\\n        long total_sum, min_sum, max_sum;\\n        total_sum = min_sum = max_sum = 0;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            total_sum += arr[i];\\n            min_sum = min(total_sum, min_sum);\\n            max_sum = max(total_sum - min_sum, max_sum);\\n        }\\n        if (k == 1 || max_sum == 0)\\n            return max_sum;\\n        long onepass_sum = total_sum;\\n        //using kaden\\'s algo twice\\n        for (int i = 0; i < arr.size(); ++i) {\\n            total_sum += arr[i];\\n            min_sum = min(total_sum, min_sum);\\n            max_sum = max(total_sum - min_sum, max_sum);\\n        }\\n        if (k == 2 || onepass_sum < 0)\\n            return max_sum % MOD;\\n        return (max_sum + (k - 2) * onepass_sum) % MOD;\\n    }\\n};\\n\\n\\n\\n//39 test cases passed \\n//#define MOD (1\\'000\\'000\\'000 + 7)\\n// class Solution {\\n// public:\\n//     long long kConcatenationMaxSum(vector<int>& arr, int k) {\\n//         vector<int> nums;\\n//         while(k>0){\\n//             for(int i=0;i<arr.size();i++){\\n//                 nums.push_back(arr[i]);\\n//                  }\\n//             k--;\\n//         }\\n//            long cmax=0,sum=0,max1=INT_MIN;\\n//             for(int i=0;i<nums.size();i++){\\n//                 if(nums[i]>max1){\\n//                     max1=nums[i];\\n//                 }\\n//                 cmax+=nums[i];\\n//                 if(cmax>sum){\\n//                     sum=cmax;\\n//                 }\\n//                 if(cmax<0){\\n//                     cmax=0;\\n//                     continue;\\n//                 }\\n//             }\\n//             if(sum==0){\\n//                 return 0;\\n//             }\\n//             return sum%MOD;}\\n// };\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365377,
                "title": "python-o-n-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nthere have three situations:\\n1. k == 1,  find max sum of subarray\\n2. k == 2, find max sum of subarray across two arrays\\n3. k > 2, if sum of arr > 0, answer is (max sum for k == 2) + (sum of arr * (k-2))\\n\\n\\nmax is positive array, pref, suff are negative array, sum of arr > 0, [pref][max][suff].\\nk == 2: (eliminate x)\\na. no pref, positive array is at the beginning: [max][suff] [max]    x[suff]\\nb. both have, positive array is at the middle: [pref]x    [max][suff] [pref][max]    x[suff]\\nc. no suff, positive array is at the end: [pref]x    [max] [pref][max]\\n\\nk == 3: (eliminate x)\\na. no pref, positive array is at the beginning: \\n\\t[max][suff] [max][suff] [max]    x[suff] = ([max][suff] [max]) + [suff] [max]\\nb. both have, positive array is at the middle: \\n\\t[pref]x    [max][suff] [pref][max][suff] [pref][max]    x[suff]= ([max][suff] [pref][max]) + [suff] [pref][max]\\nc. no suff, positive array is at the end: \\n\\t[pref]x    [max] [pref][max] [pref][max] = ([max] [pref][max]) + [pref][max]\\n\\nso answer is (max sum for k == 2) + (sum of arr * (k-2))\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        curSum = maxSum = 0\\n        s = sum(arr)\\n        leng = len(arr)\\n        for i in range(min(2, k) * leng):\\n            i %= leng\\n            curSum = curSum + arr[i] if curSum + arr[i] >= arr[i] else arr[i]\\n            if curSum > maxSum: maxSum = curSum\\n\\n        return (maxSum + max(0, s * max(0, k-2))) % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n\\'\\'\\'\\nthere have three situations:\\n1. k == 1,  find max sum of subarray\\n2. k == 2, find max sum of subarray across two arrays\\n3. k > 2, if sum of arr > 0, answer is (max sum for k == 2) + (sum of arr * (k-2))\\n\\n\\nmax is positive array, pref, suff are negative array, sum of arr > 0, [pref][max][suff].\\nk == 2: (eliminate x)\\na. no pref, positive array is at the beginning: [max][suff] [max]    x[suff]\\nb. both have, positive array is at the middle: [pref]x    [max][suff] [pref][max]    x[suff]\\nc. no suff, positive array is at the end: [pref]x    [max] [pref][max]\\n\\nk == 3: (eliminate x)\\na. no pref, positive array is at the beginning: \\n\\t[max][suff] [max][suff] [max]    x[suff] = ([max][suff] [max]) + [suff] [max]\\nb. both have, positive array is at the middle: \\n\\t[pref]x    [max][suff] [pref][max][suff] [pref][max]    x[suff]= ([max][suff] [pref][max]) + [suff] [pref][max]\\nc. no suff, positive array is at the end: \\n\\t[pref]x    [max] [pref][max] [pref][max] = ([max] [pref][max]) + [pref][max]\\n\\nso answer is (max sum for k == 2) + (sum of arr * (k-2))\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        curSum = maxSum = 0\\n        s = sum(arr)\\n        leng = len(arr)\\n        for i in range(min(2, k) * leng):\\n            i %= leng\\n            curSum = curSum + arr[i] if curSum + arr[i] >= arr[i] else arr[i]\\n            if curSum > maxSum: maxSum = curSum\\n\\n        return (maxSum + max(0, s * max(0, k-2))) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351791,
                "title": "k-concantenation-problem-solution-with-kadene-algorithm-in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll kadaneSum(vector<int>&arr)\\n{\\n    ll curr_sum=0;\\n    ll max_sum_so_far=INT_MIN;\\n    for(int i=0; i<arr.size(); i++)\\n    {\\n        curr_sum+=arr[i];\\n        if(curr_sum>max_sum_so_far)\\n        {\\n            max_sum_so_far=curr_sum%mod;\\n        }\\n        if(curr_sum<0)\\n        {\\n            curr_sum=0;\\n        }\\n    }\\n    return max_sum_so_far%mod;\\n}\\n\\n    int kConcatenationMaxSum(vector<int>& arr, int k)\\n     {\\n         ll n=arr.size();\\n         ll kadness_sum=kadaneSum(arr);\\n   // cout<<kadness_sum<<endl;\\n    if(k==1)\\n    {\\n        if(kadness_sum>0)\\n       return kadness_sum;\\n       else\\n       return 0;\\n\\n    }\\n    ll current_prefix_sum=0,current_suffix_sum=0;\\n    ll max_prefix_sum=INT_MIN,max_suffix_sum=INT_MIN;\\n    for (int i = 0; i <n; i++)\\n    {\\n        current_prefix_sum+=arr[i];\\n        max_prefix_sum=max(current_prefix_sum%mod,max_prefix_sum%mod);\\n    }\\n    ll total_sum=current_prefix_sum%mod;\\n    //cout<<total_sum<<endl;\\n    for(int i=n-1; i>=0; i--)\\n    {\\n        current_suffix_sum+=arr[i];\\n        max_suffix_sum=max(max_suffix_sum%mod,current_suffix_sum%mod);\\n    }\\n    ll ans;\\n    if(total_sum<0)\\n    {\\n        ans=max(max_suffix_sum%mod+max_prefix_sum%mod,kadness_sum%mod);\\n\\n    }\\n    else\\n    {\\n        ans=max(max_suffix_sum%mod+max_prefix_sum%mod+total_sum*(k-2),kadness_sum%mod);\\n\\n    }\\n   // cout<<ans<<endl;\\n   if(ans>0)\\n   {\\n       return ans%mod;\\n   }\\n   else\\n{ \\n    return 0;\\n     }\\n    }\\n         \\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll kadaneSum(vector<int>&arr)\\n{\\n    ll curr_sum=0;\\n    ll max_sum_so_far=INT_MIN;\\n    for(int i=0; i<arr.size(); i++)\\n    {\\n        curr_sum+=arr[i];\\n        if(curr_sum>max_sum_so_far)\\n        {\\n            max_sum_so_far=curr_sum%mod;\\n        }\\n        if(curr_sum<0)\\n        {\\n            curr_sum=0;\\n        }\\n    }\\n    return max_sum_so_far%mod;\\n}\\n\\n    int kConcatenationMaxSum(vector<int>& arr, int k)\\n     {\\n         ll n=arr.size();\\n         ll kadness_sum=kadaneSum(arr);\\n   // cout<<kadness_sum<<endl;\\n    if(k==1)\\n    {\\n        if(kadness_sum>0)\\n       return kadness_sum;\\n       else\\n       return 0;\\n\\n    }\\n    ll current_prefix_sum=0,current_suffix_sum=0;\\n    ll max_prefix_sum=INT_MIN,max_suffix_sum=INT_MIN;\\n    for (int i = 0; i <n; i++)\\n    {\\n        current_prefix_sum+=arr[i];\\n        max_prefix_sum=max(current_prefix_sum%mod,max_prefix_sum%mod);\\n    }\\n    ll total_sum=current_prefix_sum%mod;\\n    //cout<<total_sum<<endl;\\n    for(int i=n-1; i>=0; i--)\\n    {\\n        current_suffix_sum+=arr[i];\\n        max_suffix_sum=max(max_suffix_sum%mod,current_suffix_sum%mod);\\n    }\\n    ll ans;\\n    if(total_sum<0)\\n    {\\n        ans=max(max_suffix_sum%mod+max_prefix_sum%mod,kadness_sum%mod);\\n\\n    }\\n    else\\n    {\\n        ans=max(max_suffix_sum%mod+max_prefix_sum%mod+total_sum*(k-2),kadness_sum%mod);\\n\\n    }\\n   // cout<<ans<<endl;\\n   if(ans>0)\\n   {\\n       return ans%mod;\\n   }\\n   else\\n{ \\n    return 0;\\n     }\\n    }\\n         \\n        \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3332736,
                "title": "easiest-o-n-code-beats-99-75-in-tc-95-42-in-sc",
                "content": "\\n\\n# Approach\\nUse Kadane\\'s Algorithm to find ans(MaximumSubarraySum).\\nThere can be 2 cases when K==1 and K>1.\\nreturn 0 , when all elements are negative.\\nreturn ans, when totalsum is negative but ans is positive and k>1\\nreturn ttsum*max(0,k-2)+ans, when ttsum is positive and ans is also positive.\\n\\n# Complexity\\n- Time complexity:\\nO(n*min(0,k-2));\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n = arr.size();\\n    int ans = 0;\\n    int sum =0;\\n    long long ttsum =0;\\n    for(int i =0;i<n*min(2,k);i++)\\n    {\\n         if(i<n)ttsum+=arr[i];\\n        sum+=arr[i%n];\\n        if(sum<arr[i%n])\\n        {\\n            sum = arr[i%n];\\n        }\\n        ans = max(ans,sum);\\n\\n    }\\n    arr.clear();\\n    return (max(0ll,max((long long)ans,ttsum* max(0,k-2)+ans)))%1000000007;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n = arr.size();\\n    int ans = 0;\\n    int sum =0;\\n    long long ttsum =0;\\n    for(int i =0;i<n*min(2,k);i++)\\n    {\\n         if(i<n)ttsum+=arr[i];\\n        sum+=arr[i%n];\\n        if(sum<arr[i%n])\\n        {\\n            sum = arr[i%n];\\n        }\\n        ans = max(ans,sum);\\n\\n    }\\n    arr.clear();\\n    return (max(0ll,max((long long)ans,ttsum* max(0,k-2)+ans)))%1000000007;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3318056,
                "title": "java-kadanes-algo-with-comments-and-illustration",
                "content": "![image.png](https://assets.leetcode.com/users/images/fdd65e64-968c-4319-95c2-8afc8637c660_1679278167.5680363.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/df285434-f516-4051-9f07-4f66ccf96c5a_1679278176.643682.png)\\n\\n\\n // b <=============== K-Concatenation Maximum Sum ==============>\\n    // https://leetcode.com/problems/k-concatenation-maximum-sum/\\n\\n    // Kadanes algo chalaya k=3 tak ek liye. Ab agar uske baad koi 3 se bada k hoga,\\n    // to uske liye jo formula derive kiya hai wo laga diya.\\n\\n    // Yahan pe teen cases ho sakte hain :\\n\\n    // 1. Jab k=1 ke liye thoda arraya contribute kare s1, k=2 ke liye s1 + s2\\n    // contribute kare, k=3 ke liye s1 + s2 + x contribute kare.\\n    // 2. Pura Array contribute kare\\n    // 3. Ki thoda array contribute kare. Aur kitne bhi array concat ho jayein, utna he contribution aayega.\\n\\n    static int mod = (int) 1e9 + 7;\\n\\n    public int kadanesSum(int[] arr, int k) {\\n        int n = arr.length;\\n        long gsum = 0, csum = 0;\\n        int mod = (int) 1e9 + 7;\\n\\n        for (int i = 0; i < k * n; i++) {\\n            int ele = arr[i % n];\\n            csum += ele;\\n\\n            if (csum > gsum)\\n                gsum = csum;\\n            if (csum <= 0)\\n                csum = 0;\\n        }\\n\\n        return (int) gsum % mod;\\n    }\\n\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long prevSum = 0, sum = 0;\\n        for (int i = 1; i <= 3; i++) {\\n            prevSum = sum;\\n            sum = kadanesSum(arr, i);\\n\\n            if (i == k)\\n                return (int) sum;\\n        }\\n\\n        return (int) ((prevSum + (k - 2) * (sum - prevSum)) % mod);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "![image.png](https://assets.leetcode.com/users/images/fdd65e64-968c-4319-95c2-8afc8637c660_1679278167.5680363.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/df285434-f516-4051-9f07-4f66ccf96c5a_1679278176.643682.png)\\n\\n\\n // b <=============== K-Concatenation Maximum Sum ==============>\\n    // https://leetcode.com/problems/k-concatenation-maximum-sum/\\n\\n    // Kadanes algo chalaya k=3 tak ek liye. Ab agar uske baad koi 3 se bada k hoga,\\n    // to uske liye jo formula derive kiya hai wo laga diya.\\n\\n    // Yahan pe teen cases ho sakte hain :\\n\\n    // 1. Jab k=1 ke liye thoda arraya contribute kare s1, k=2 ke liye s1 + s2\\n    // contribute kare, k=3 ke liye s1 + s2 + x contribute kare.\\n    // 2. Pura Array contribute kare\\n    // 3. Ki thoda array contribute kare. Aur kitne bhi array concat ho jayein, utna he contribution aayega.\\n\\n    static int mod = (int) 1e9 + 7;\\n\\n    public int kadanesSum(int[] arr, int k) {\\n        int n = arr.length;\\n        long gsum = 0, csum = 0;\\n        int mod = (int) 1e9 + 7;\\n\\n        for (int i = 0; i < k * n; i++) {\\n            int ele = arr[i % n];\\n            csum += ele;\\n\\n            if (csum > gsum)\\n                gsum = csum;\\n            if (csum <= 0)\\n                csum = 0;\\n        }\\n\\n        return (int) gsum % mod;\\n    }\\n\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        long prevSum = 0, sum = 0;\\n        for (int i = 1; i <= 3; i++) {\\n            prevSum = sum;\\n            sum = kadanesSum(arr, i);\\n\\n            if (i == k)\\n                return (int) sum;\\n        }\\n\\n        return (int) ((prevSum + (k - 2) * (sum - prevSum)) % mod);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290009,
                "title": "python-3-very-fast-beats-100",
                "content": "![Capture d\\u2019\\xE9cran 2023-03-12 234222.png](https://assets.leetcode.com/users/images/8091f693-4cc6-4efb-a1af-226fc31dad3c_1678660976.0052133.png)\\n\\nWorking only on array $$arr$$, to find its maximum sub-array sum, its maximum sub-array sum on one side, the same on the other side and its sum.\\nWe use these four sums to calculate the answer in the different cases of $$k$$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        left_sum = 0\\n        right_sum = 0\\n        max_sum = 0\\n        arr_sum = 0\\n        for i, v in enumerate(arr, 1):\\n            arr_sum += v\\n            left_sum += v\\n            if left_sum > max_sum:\\n                max_sum = left_sum\\n            if left_sum < 0:\\n                left_sum = 0\\n            right_sum += arr[-i]\\n            if right_sum < 0:\\n                right_sum = 0\\n        \\n        output = max_sum        \\n        if k > 1:\\n            arr_sum = max(arr_sum, 0)\\n            output = max(output, left_sum + (k - 2) * arr_sum + right_sum)\\n        MOD = 1_000_000_007\\n        return output % MOD\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        left_sum = 0\\n        right_sum = 0\\n        max_sum = 0\\n        arr_sum = 0\\n        for i, v in enumerate(arr, 1):\\n            arr_sum += v\\n            left_sum += v\\n            if left_sum > max_sum:\\n                max_sum = left_sum\\n            if left_sum < 0:\\n                left_sum = 0\\n            right_sum += arr[-i]\\n            if right_sum < 0:\\n                right_sum = 0\\n        \\n        output = max_sum        \\n        if k > 1:\\n            arr_sum = max(arr_sum, 0)\\n            output = max(output, left_sum + (k - 2) * arr_sum + right_sum)\\n        MOD = 1_000_000_007\\n        return output % MOD\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283966,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long M = 1e9 + 7 ;\\n    int maxSum(vector<int>& arr, int round){\\n        long long sum = 0 ;\\n        long long ret = 0 ; \\n        for(int i = 0; i < round; i++){\\n            for(int j = 0; j < arr.size(); j++){\\n                sum = max(0LL , sum + arr[j]) ;\\n                ret = max(ret, sum) ;\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long total = 0 ;\\n        for(int i = 0; i < arr.size() ; i++)\\n        {\\n            total += arr[i] ;\\n        }\\n\\n        if(k == 1)\\n            return maxSum(arr, 1) ;\\n        if(k == 2 || total < 0){\\n            return max( maxSum(arr, 1), maxSum(arr, 2) ) % M ;\\n        }        \\n        return (maxSum(arr, 2) + total * (k-2)) % M ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long M = 1e9 + 7 ;\\n    int maxSum(vector<int>& arr, int round){\\n        long long sum = 0 ;\\n        long long ret = 0 ; \\n        for(int i = 0; i < round; i++){\\n            for(int j = 0; j < arr.size(); j++){\\n                sum = max(0LL , sum + arr[j]) ;\\n                ret = max(ret, sum) ;\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long total = 0 ;\\n        for(int i = 0; i < arr.size() ; i++)\\n        {\\n            total += arr[i] ;\\n        }\\n\\n        if(k == 1)\\n            return maxSum(arr, 1) ;\\n        if(k == 2 || total < 0){\\n            return max( maxSum(arr, 1), maxSum(arr, 2) ) % M ;\\n        }        \\n        return (maxSum(arr, 2) + total * (k-2)) % M ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280119,
                "title": "kadane-s-algorithm-easiest-code-using-java",
                "content": "# Intuition\\nUse Kadane\\'s Algorithm To Find MAX_SUM_SUBARRAY\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust Handle 3 cases:\\nCase 1: when k == 1, Just Return Kadane\\'s Algorithm i.e kadaneOfFirstArr\\n\\nCase 2: when k > 1 & SUM_OF_ARR < 0 , Return Kadane\\'s of first two arr\\ni.e kadaneOfTwoArr\\n\\nCase 3: when k > 1 & SUM_OF_ARR > 0 , Return Kadane\\'s of first two arr + (k-2)*sum\\n\\nJust Dry Run for all above cases, you will understand lot better\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(k==1){\\n            return kadaneOfFirstArr(arr);\\n        }else{\\n            long sum=0;\\n            for(int i=0;i<arr.length;i++){\\n                sum+=arr[i];\\n            }\\n            \\n            if(sum<0){\\n                int val= kadaneOfTwoArr(arr);\\n                \\n                if(val<0){\\n                    return 0;\\n                }else{\\n                    return val;\\n                }\\n            }else{\\n                int val=kadaneOfTwoArr(arr);\\n                return (int)(val+((k-2)*sum)%mod)%mod;\\n            }\\n        }\\n    }\\n    \\n    public int kadaneOfFirstArr(int []arr){\\n       long MAX_END_HERE=arr[0];\\n        long MAX_SO_FAR=arr[0];\\n\\n        \\n        \\n        for(int i=1;i<arr.length;i++){\\n            MAX_END_HERE+=arr[i]%mod;\\n            MAX_END_HERE=Math.max(MAX_END_HERE,arr[i]);\\n            MAX_SO_FAR=Math.max(MAX_SO_FAR,MAX_END_HERE);\\n        }\\n        if(MAX_SO_FAR < 0)\\n        {\\n            MAX_SO_FAR = 0;\\n        }\\n        return (int)MAX_SO_FAR;\\n    }\\n    \\n    public int kadaneOfTwoArr(int []arr){\\n        int n=arr.length;\\n        int []newArr=new int[n+n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            newArr[i]=arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            newArr[n+i]=arr[i];\\n        }\\n\\n        long MAX_END_HERE=newArr[0];\\n        long MAX_SO_FAR=newArr[0];\\n        \\n        for(int i=1;i<newArr.length;i++){\\n            MAX_END_HERE+=newArr[i]%mod;\\n            MAX_END_HERE=Math.max(MAX_END_HERE,newArr[i]);\\n            MAX_SO_FAR=Math.max(MAX_SO_FAR,MAX_END_HERE);\\n        }\\n        \\n        return (int)MAX_SO_FAR;\\n        \\n       \\n        // return kadaneOfFirstArr(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    \\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        if(k==1){\\n            return kadaneOfFirstArr(arr);\\n        }else{\\n            long sum=0;\\n            for(int i=0;i<arr.length;i++){\\n                sum+=arr[i];\\n            }\\n            \\n            if(sum<0){\\n                int val= kadaneOfTwoArr(arr);\\n                \\n                if(val<0){\\n                    return 0;\\n                }else{\\n                    return val;\\n                }\\n            }else{\\n                int val=kadaneOfTwoArr(arr);\\n                return (int)(val+((k-2)*sum)%mod)%mod;\\n            }\\n        }\\n    }\\n    \\n    public int kadaneOfFirstArr(int []arr){\\n       long MAX_END_HERE=arr[0];\\n        long MAX_SO_FAR=arr[0];\\n\\n        \\n        \\n        for(int i=1;i<arr.length;i++){\\n            MAX_END_HERE+=arr[i]%mod;\\n            MAX_END_HERE=Math.max(MAX_END_HERE,arr[i]);\\n            MAX_SO_FAR=Math.max(MAX_SO_FAR,MAX_END_HERE);\\n        }\\n        if(MAX_SO_FAR < 0)\\n        {\\n            MAX_SO_FAR = 0;\\n        }\\n        return (int)MAX_SO_FAR;\\n    }\\n    \\n    public int kadaneOfTwoArr(int []arr){\\n        int n=arr.length;\\n        int []newArr=new int[n+n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            newArr[i]=arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            newArr[n+i]=arr[i];\\n        }\\n\\n        long MAX_END_HERE=newArr[0];\\n        long MAX_SO_FAR=newArr[0];\\n        \\n        for(int i=1;i<newArr.length;i++){\\n            MAX_END_HERE+=newArr[i]%mod;\\n            MAX_END_HERE=Math.max(MAX_END_HERE,newArr[i]);\\n            MAX_SO_FAR=Math.max(MAX_SO_FAR,MAX_END_HERE);\\n        }\\n        \\n        return (int)MAX_SO_FAR;\\n        \\n       \\n        // return kadaneOfFirstArr(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253702,
                "title": "easy-to-unserstand-c-kadanes-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        long long int currBest = -1e9, overallBest = -1e9;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(currBest + nums[i] >= nums[i]){\\n                currBest = (currBest + nums[i]%mod);\\n                if(currBest > overallBest){\\n                    overallBest = currBest;\\n                }\\n            }\\n            else{\\n                currBest = nums[i]%mod;\\n                if(currBest > overallBest){\\n                    overallBest = currBest;\\n                }   \\n            }\\n        }\\n        return overallBest%mod;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int ans = 0;\\n        int mod = 1e9 + 7;\\n        vector<int> nums=arr;\\n        long long int sum = 0;\\n        if(k == 1 ){\\n            ans = maxSubArray(arr);\\n            if(ans < 0)return 0;\\n            return ans%mod;\\n        }\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            sum += arr[i];    \\n        }\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            nums.push_back(arr[i]);\\n        }\\n        \\n        \\n        ans = maxSubArray(nums);\\n        if(k==2){\\n            if(ans > 0)return ans%mod;\\n            return 0;\\n        }\\n        \\n        if(sum > 0){\\n            // ans += (((k-2)%mod)*(sum)%mod)%mod;\\n            long long int a = (k-2);\\n            long long int b = sum;\\n            ans = (ans) + long(a*b);\\n        } \\n        if(ans < 0)return 0;\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        long long int currBest = -1e9, overallBest = -1e9;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(currBest + nums[i] >= nums[i]){\\n                currBest = (currBest + nums[i]%mod);\\n                if(currBest > overallBest){\\n                    overallBest = currBest;\\n                }\\n            }\\n            else{\\n                currBest = nums[i]%mod;\\n                if(currBest > overallBest){\\n                    overallBest = currBest;\\n                }   \\n            }\\n        }\\n        return overallBest%mod;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long int ans = 0;\\n        int mod = 1e9 + 7;\\n        vector<int> nums=arr;\\n        long long int sum = 0;\\n        if(k == 1 ){\\n            ans = maxSubArray(arr);\\n            if(ans < 0)return 0;\\n            return ans%mod;\\n        }\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            sum += arr[i];    \\n        }\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            nums.push_back(arr[i]);\\n        }\\n        \\n        \\n        ans = maxSubArray(nums);\\n        if(k==2){\\n            if(ans > 0)return ans%mod;\\n            return 0;\\n        }\\n        \\n        if(sum > 0){\\n            // ans += (((k-2)%mod)*(sum)%mod)%mod;\\n            long long int a = (k-2);\\n            long long int b = sum;\\n            ans = (ans) + long(a*b);\\n        } \\n        if(ans < 0)return 0;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236220,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint kadane(vector<int>&arr)\\n{\\n    int sum=0;\\n    int ans=INT_MIN;\\n    int n=arr.size();\\n    for (int i=0;i<n;i++)\\n    {\\n        sum+=arr[i];\\n        if (sum>ans)\\n        {\\n            ans=sum;\\n        }\\n        if (sum<0)\\n        {\\n            sum=0;\\n        }\\n    }\\n    return ans;\\n}\\n    int kConcatenationMaxSum(vector<int>& arr, int k1) {\\n        long long k=k1;\\n        long long mod=1e9+7;\\n        long long preMax=INT_MIN;\\n        long long sufMax=INT_MIN;\\n        long long pre=0;\\n        long long suf=0;\\n        long long total=0;\\n        int n=arr.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            pre+=arr[i];\\n            if(pre>preMax)\\n            preMax=pre;\\n            total+=arr[i];\\n        }\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            suf+=arr[i];\\n            if (suf>sufMax)\\n            sufMax=suf;\\n        }\\n        long long ans=0;\\n       if (total*k>ans) ans=total*k;\\n       long long kad=kadane(arr);\\n       if (kad>ans)\\n       ans=kad;\\n       if (k>1)\\n       {\\n           if (preMax+sufMax>ans)\\n           ans=preMax+sufMax;\\n           if (preMax+sufMax+((k-2)*total)>ans)\\n           ans=preMax+sufMax+((k-2)*total);\\n         }\\n       return ans%mod;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint kadane(vector<int>&arr)\\n{\\n    int sum=0;\\n    int ans=INT_MIN;\\n    int n=arr.size();\\n    for (int i=0;i<n;i++)\\n    {\\n        sum+=arr[i];\\n        if (sum>ans)\\n        {\\n            ans=sum;\\n        }\\n        if (sum<0)\\n        {\\n            sum=0;\\n        }\\n    }\\n    return ans;\\n}\\n    int kConcatenationMaxSum(vector<int>& arr, int k1) {\\n        long long k=k1;\\n        long long mod=1e9+7;\\n        long long preMax=INT_MIN;\\n        long long sufMax=INT_MIN;\\n        long long pre=0;\\n        long long suf=0;\\n        long long total=0;\\n        int n=arr.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            pre+=arr[i];\\n            if(pre>preMax)\\n            preMax=pre;\\n            total+=arr[i];\\n        }\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            suf+=arr[i];\\n            if (suf>sufMax)\\n            sufMax=suf;\\n        }\\n        long long ans=0;\\n       if (total*k>ans) ans=total*k;\\n       long long kad=kadane(arr);\\n       if (kad>ans)\\n       ans=kad;\\n       if (k>1)\\n       {\\n           if (preMax+sufMax>ans)\\n           ans=preMax+sufMax;\\n           if (preMax+sufMax+((k-2)*total)>ans)\\n           ans=preMax+sufMax+((k-2)*total);\\n         }\\n       return ans%mod;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204384,
                "title": "golang-100-time-easy-to-understand",
                "content": "# Code\\n```\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc sumArr(arr []int) int {\\n    ret := 0\\n    for i:=0; i<len(arr); i++ {\\n        ret += arr[i]\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSumFromStart(arr []int) int {\\n    ret := 0\\n    sum := 0\\n    for i:=0; i<len(arr); i++ {\\n        sum += arr[i]\\n        ret = max(ret, sum)\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSumFromEnd(arr []int) int {\\n    ret := 0\\n    sum := 0\\n    for i:=len(arr)-1; i>=0; i-- {\\n        sum += arr[i]\\n        ret = max(ret, sum)\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSum(arr []int) int {\\n    if len(arr) == 0 {\\n        return 0\\n    }\\n    retVal := arr[0]\\n    lastDpVal := arr[0]\\n    for i:=1; i<len(arr); i++ {\\n        lastDpVal = max(lastDpVal+arr[i], arr[i])\\n        retVal = max(retVal, lastDpVal)\\n    }\\n    return max(0, retVal)\\n}\\n\\nfunc kConcatenationMaxSum(arr []int, k int) int {\\n    mod := int(1e9+7)\\n\\n    if k == 1 {\\n        return maxSubSum(arr) % mod\\n    }\\n\\n    sum := sumArr(arr)\\n    if sum > 0 {\\n        return ((sum * (k-2)) + maxSubSumFromStart(arr) + maxSubSumFromEnd(arr)) % mod\\n    }\\n\\n    twoArr := append(arr, arr...)\\n    return maxSubSum(twoArr) % mod\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc sumArr(arr []int) int {\\n    ret := 0\\n    for i:=0; i<len(arr); i++ {\\n        ret += arr[i]\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSumFromStart(arr []int) int {\\n    ret := 0\\n    sum := 0\\n    for i:=0; i<len(arr); i++ {\\n        sum += arr[i]\\n        ret = max(ret, sum)\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSumFromEnd(arr []int) int {\\n    ret := 0\\n    sum := 0\\n    for i:=len(arr)-1; i>=0; i-- {\\n        sum += arr[i]\\n        ret = max(ret, sum)\\n    }\\n    return ret\\n}\\n\\nfunc maxSubSum(arr []int) int {\\n    if len(arr) == 0 {\\n        return 0\\n    }\\n    retVal := arr[0]\\n    lastDpVal := arr[0]\\n    for i:=1; i<len(arr); i++ {\\n        lastDpVal = max(lastDpVal+arr[i], arr[i])\\n        retVal = max(retVal, lastDpVal)\\n    }\\n    return max(0, retVal)\\n}\\n\\nfunc kConcatenationMaxSum(arr []int, k int) int {\\n    mod := int(1e9+7)\\n\\n    if k == 1 {\\n        return maxSubSum(arr) % mod\\n    }\\n\\n    sum := sumArr(arr)\\n    if sum > 0 {\\n        return ((sum * (k-2)) + maxSubSumFromStart(arr) + maxSubSumFromEnd(arr)) % mod\\n    }\\n\\n    twoArr := append(arr, arr...)\\n    return maxSubSum(twoArr) % mod\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3185672,
                "title": "kadane-s-algorithm-linear-time-easy-python-python3",
                "content": "## Please Upvote if you find this useful \\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### Solution: 1\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        minEle, sumEle = 10**9+7, 0\\n\\n        for num in arr:\\n            sumEle += num\\n            minEle = min(minEle, num)\\n\\n        mod = 10**9+7\\n\\n        if minEle > 0:\\n            return int(((sumEle % mod) * (k %  mod)) % mod)\\n        else:\\n            lenA = len(arr)\\n            sol = 0\\n            \\n            if k > 1:\\n                maxLeft, curSum = 0, 0\\n                for i in range(lenA):\\n                    curSum += arr[i]\\n                    maxLeft = max(maxLeft, curSum)\\n\\n                maxRight, curSum = 0, 0\\n                for i in range(lenA - 1, -1, -1):\\n                    curSum += arr[i]\\n                    maxRight = max(maxRight, curSum)\\n\\n                sol = maxRight + maxLeft\\n            \\n            curSol = 0\\n            for i in range(lenA):\\n                curSol = max(0, curSol + arr[i])\\n                sol = max(sol, curSol)\\n\\n        if sumEle > 0:\\n            sumEle = ((sumEle % mod) * ((k - 2) % mod)) % mod\\n            sol = max(sol + sumEle, sol)\\n\\n        return int(sol % mod)\\n\\n\\n\\n\\n```\\n\\n### Solution: 2\\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        minEle, sumEle = 10**5+1, 0\\n        mod = int(10**9+7)\\n        lenA = len(arr)\\n        sol, curSol = 0, 0\\n        maxLeft, leftCurSum = 0, 0\\n        maxRight, rightCurSum = 0, 0\\n\\n        for num in arr:\\n            sumEle += num\\n            minEle = min(minEle, num)\\n            leftCurSum += num\\n            maxLeft = max(maxLeft, leftCurSum)\\n            curSol = max(0, curSol + num)\\n            sol = max(sol, curSol)\\n\\n        if minEle > 0:\\n            return ((sumEle % mod) * k) % mod\\n        \\n        if k > 1:\\n            for i in range(lenA - 1, -1, -1):\\n                rightCurSum += arr[i]\\n                maxRight = max(maxRight, rightCurSum)\\n    \\n            sol = max(sol, maxRight + maxLeft)\\n\\n        if sumEle > 0:\\n            sumEle = ((sumEle % mod) * (k - 2)) % mod\\n            sol = max(sol + sumEle, sol)\\n\\n        return sol % mod\\n\\n```\\n\\n## Please Upvote if you find this useful \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        minEle, sumEle = 10**9+7, 0\\n\\n        for num in arr:\\n            sumEle += num\\n            minEle = min(minEle, num)\\n\\n        mod = 10**9+7\\n\\n        if minEle > 0:\\n            return int(((sumEle % mod) * (k %  mod)) % mod)\\n        else:\\n            lenA = len(arr)\\n            sol = 0\\n            \\n            if k > 1:\\n                maxLeft, curSum = 0, 0\\n                for i in range(lenA):\\n                    curSum += arr[i]\\n                    maxLeft = max(maxLeft, curSum)\\n\\n                maxRight, curSum = 0, 0\\n                for i in range(lenA - 1, -1, -1):\\n                    curSum += arr[i]\\n                    maxRight = max(maxRight, curSum)\\n\\n                sol = maxRight + maxLeft\\n            \\n            curSol = 0\\n            for i in range(lenA):\\n                curSol = max(0, curSol + arr[i])\\n                sol = max(sol, curSol)\\n\\n        if sumEle > 0:\\n            sumEle = ((sumEle % mod) * ((k - 2) % mod)) % mod\\n            sol = max(sol + sumEle, sol)\\n\\n        return int(sol % mod)\\n\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        minEle, sumEle = 10**5+1, 0\\n        mod = int(10**9+7)\\n        lenA = len(arr)\\n        sol, curSol = 0, 0\\n        maxLeft, leftCurSum = 0, 0\\n        maxRight, rightCurSum = 0, 0\\n\\n        for num in arr:\\n            sumEle += num\\n            minEle = min(minEle, num)\\n            leftCurSum += num\\n            maxLeft = max(maxLeft, leftCurSum)\\n            curSol = max(0, curSol + num)\\n            sol = max(sol, curSol)\\n\\n        if minEle > 0:\\n            return ((sumEle % mod) * k) % mod\\n        \\n        if k > 1:\\n            for i in range(lenA - 1, -1, -1):\\n                rightCurSum += arr[i]\\n                maxRight = max(maxRight, rightCurSum)\\n    \\n            sol = max(sol, maxRight + maxLeft)\\n\\n        if sumEle > 0:\\n            sumEle = ((sumEle % mod) * (k - 2)) % mod\\n            sol = max(sol + sumEle, sol)\\n\\n        return sol % mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139298,
                "title": "c-kadane-algorithm-method-simple-and-easy",
                "content": "```\\nclass Solution {\\nint m=1e9+7;\\npublic:\\n    long long ka(vector<int> &arr){\\n        long long ans=INT_MIN;\\n        long long cs=0;\\n        long long n=arr.size();\\n        for(int i=0;i<n;i++){\\n            cs+=arr[i];\\n            if(cs>ans) ans=cs;\\n            if(cs<0) cs=0;\\n        }\\n        return ans;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long n=arr.size();\\n        long long s=accumulate(begin(arr),end(arr),0);\\n        long long ans=0;\\n        long long r=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n                r=1;\\n\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        if(!r){\\n            return 0;\\n        }\\n        if(k==1) {\\n            ans=ka(arr);\\n            return ans%m;\\t\\n        }\\n        for(int i=0;i<n;i++){\\n            arr.push_back(arr[i]);\\n        } \\n        if(s<0){\\n            ans=ka(arr);\\n        }\\n        else {\\n            ans=((ka(arr)%m) +(((k-2)*s)%m))%m;\\n        }\\n        return (int)ans%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint m=1e9+7;\\npublic:\\n    long long ka(vector<int> &arr){\\n        long long ans=INT_MIN;\\n        long long cs=0;\\n        long long n=arr.size();\\n        for(int i=0;i<n;i++){\\n            cs+=arr[i];\\n            if(cs>ans) ans=cs;\\n            if(cs<0) cs=0;\\n        }\\n        return ans;\\n    }\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        long long n=arr.size();\\n        long long s=accumulate(begin(arr),end(arr),0);\\n        long long ans=0;\\n        long long r=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n                r=1;\\n\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        if(!r){\\n            return 0;\\n        }\\n        if(k==1) {\\n            ans=ka(arr);\\n            return ans%m;\\t\\n        }\\n        for(int i=0;i<n;i++){\\n            arr.push_back(arr[i]);\\n        } \\n        if(s<0){\\n            ans=ka(arr);\\n        }\\n        else {\\n            ans=((ka(arr)%m) +(((k-2)*s)%m))%m;\\n        }\\n        return (int)ans%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133031,
                "title": "solution",
                "content": "```C++ []\\nstatic const int iofast = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& a, int k) {\\n        ll n = a.size();\\n        ll min_sum = 0;\\n        ll ans = a[0];\\n        ll sum = 0;\\n        for (int i = 0; i < n * min(k, 2); i++) {\\n            sum += a[i % n];\\n            ans = max(ans, sum - min_sum);\\n            min_sum = min(min_sum, sum);\\n        }\\n        sum = accumulate(a.begin(), a.end(), 0);\\n        return max({0ll, ans, ans + sum * max(0, k - 2)}) % 1000000007ll;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        l1 = len(arr)\\n        max_front = 0\\n        min_front = 0\\n        curr_front = 0  \\n        max_seg = 0\\n        for v in arr:\\n            curr_front += v\\n            if curr_front > max_front:\\n                max_front = curr_front\\n            if curr_front < min_front:\\n                min_front = curr_front\\n            if curr_front - min_front > max_seg:\\n                max_seg = curr_front - min_front\\n\\n        max_back = curr_front - min_front\\n\\n        res = max(max_front + max_back, max_seg)\\n        if k == 1:\\n            res = max_seg\\n\\n        if curr_front > 0:\\n            res = max(curr_front * (k - 2) + max_front + max_back, max_seg)\\n\\n        return res % (10 ** 9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int max=0,sum=0,sm=0,sm1=0,sm2=0,sum2=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            sm+=arr[i];\\n            sm1=Math.max(sm1,sm);\\n            if(sum<0){\\n                sum=0;\\n            }\\n            sum2+=arr[arr.length-1-i];\\n            sm2=Math.max(sm2,sum2);\\n            max=Math.max(max,sum);\\n        }\\n        if(k==1){\\n            return max;\\n        }\\n        if(sm<0){\\n            return Math.max(max,sm1+sm2);\\n        }\\n        int mod=1000000000+7;\\n        int ans=0,s=0;\\n        for(int i=0;i<k-2;i++){\\n            s=(s+sm)%mod;\\n        }\\n        int tmp=(s+sm1)%mod;\\n        tmp=(tmp+sm2)%mod;\\n        ans=Math.max(ans,tmp);\\n        s=(s+sm)%mod;\\n        ans=Math.max(ans,(s+sm1)%mod);\\n        ans=Math.max(ans,(s+sm2)%mod);\\n        ans=Math.max(ans,(s+sm)%mod);\\n        return ans;\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const int iofast = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& a, int k) {\\n        ll n = a.size();\\n        ll min_sum = 0;\\n        ll ans = a[0];\\n        ll sum = 0;\\n        for (int i = 0; i < n * min(k, 2); i++) {\\n            sum += a[i % n];\\n            ans = max(ans, sum - min_sum);\\n            min_sum = min(min_sum, sum);\\n        }\\n        sum = accumulate(a.begin(), a.end(), 0);\\n        return max({0ll, ans, ans + sum * max(0, k - 2)}) % 1000000007ll;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        l1 = len(arr)\\n        max_front = 0\\n        min_front = 0\\n        curr_front = 0  \\n        max_seg = 0\\n        for v in arr:\\n            curr_front += v\\n            if curr_front > max_front:\\n                max_front = curr_front\\n            if curr_front < min_front:\\n                min_front = curr_front\\n            if curr_front - min_front > max_seg:\\n                max_seg = curr_front - min_front\\n\\n        max_back = curr_front - min_front\\n\\n        res = max(max_front + max_back, max_seg)\\n        if k == 1:\\n            res = max_seg\\n\\n        if curr_front > 0:\\n            res = max(curr_front * (k - 2) + max_front + max_back, max_seg)\\n\\n        return res % (10 ** 9 + 7)\\n```\n```Java []\\nclass Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int max=0,sum=0,sm=0,sm1=0,sm2=0,sum2=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            sm+=arr[i];\\n            sm1=Math.max(sm1,sm);\\n            if(sum<0){\\n                sum=0;\\n            }\\n            sum2+=arr[arr.length-1-i];\\n            sm2=Math.max(sm2,sum2);\\n            max=Math.max(max,sum);\\n        }\\n        if(k==1){\\n            return max;\\n        }\\n        if(sm<0){\\n            return Math.max(max,sm1+sm2);\\n        }\\n        int mod=1000000000+7;\\n        int ans=0,s=0;\\n        for(int i=0;i<k-2;i++){\\n            s=(s+sm)%mod;\\n        }\\n        int tmp=(s+sm1)%mod;\\n        tmp=(tmp+sm2)%mod;\\n        ans=Math.max(ans,tmp);\\n        s=(s+sm)%mod;\\n        ans=Math.max(ans,(s+sm1)%mod);\\n        ans=Math.max(ans,(s+sm2)%mod);\\n        ans=Math.max(ans,(s+sm)%mod);\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3066701,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEssesntially there are only three cases, if (k==1), if (sum <0) && if sum>0 \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062743,
                "title": "python-greedy-solution-98-faster",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        cur = 0\\n        start = 0\\n        best = 0\\n        end = 0\\n\\n        for i in range(len(arr)):\\n            start += arr[i]\\n            best = max(best,start)\\n            if start < 0:\\n                start = 0\\n\\n        for i in range(len(arr)-1,-1,-1):\\n            end += arr[i]\\n            if end < 0:\\n                end = 0\\n\\n        if k == 1: return best\\n        res = max(best,\\n                start+end,\\n                start+sum(arr)*max(k-2,0)+end\\n                )\\n        \\n        return res % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        cur = 0\\n        start = 0\\n        best = 0\\n        end = 0\\n\\n        for i in range(len(arr)):\\n            start += arr[i]\\n            best = max(best,start)\\n            if start < 0:\\n                start = 0\\n\\n        for i in range(len(arr)-1,-1,-1):\\n            end += arr[i]\\n            if end < 0:\\n                end = 0\\n\\n        if k == 1: return best\\n        res = max(best,\\n                start+end,\\n                start+sum(arr)*max(k-2,0)+end\\n                )\\n        \\n        return res % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058061,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn k_concatenation_max_sum(arr: Vec<i32>, k: i32) -> i32 {\\n        use std::cmp::{max, min};\\n        let k = k as i64;\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let mut m_sum = 0;\\n        let sz = arr.len() as i64;\\n        let mut sum = 0;\\n        for i in 0..min(2, k) * sz {\\n            sum = max(sum + arr[(i % sz) as usize], arr[(i % sz) as usize]);\\n            m_sum = max(m_sum, sum);\\n        }\\n        ((m_sum + max(0, arr.iter().sum::<i64>()) * max(0, k - 2)) % 1000000007) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn k_concatenation_max_sum(arr: Vec<i32>, k: i32) -> i32 {\\n        use std::cmp::{max, min};\\n        let k = k as i64;\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let mut m_sum = 0;\\n        let sz = arr.len() as i64;\\n        let mut sum = 0;\\n        for i in 0..min(2, k) * sz {\\n            sum = max(sum + arr[(i % sz) as usize], arr[(i % sz) as usize]);\\n            m_sum = max(m_sum, sum);\\n        }\\n        ((m_sum + max(0, arr.iter().sum::<i64>()) * max(0, k - 2)) % 1000000007) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991163,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long int ans =0;\\n        for(int i =0;i<n;i++){\\n            ans+=arr[i];\\n        }\\n\\n            long long int maxi = INT_MIN;\\n    long long int sum =0;\\n     if(k==1) {\\n      for(int i =0;i<n;i++){\\n        sum = sum + arr[i];\\n         if(sum<0)\\n        sum =0;\\n        if(sum>maxi)\\n        maxi = sum;\\n    }\\n    \\n    }\\n   else if(k>=2){\\n              if(ans<0){\\n                          for(int i =1;i<=2;i++){\\n                              for(int j =0;j<n;j++){\\n                                  sum+=arr[j];\\n                                  if(sum<0)\\n                                  sum =0;\\n                                  if(sum>maxi)\\n                                  maxi = sum;\\n                              }\\n\\n                          }\\n\\n              }\\n              else if(ans>=0){\\n                      for(int i =1;i<=2;i++){\\n                          for(int j =0;j<n;j++){\\n                              sum+=arr[j];\\n                              if(sum<0)\\n                              sum =0;\\n                              if(sum>maxi)\\n                              maxi =sum;\\n                          }\\n                      }\\n                   //   long long int temp = ;\\n                      maxi = maxi+ (k-2)*ans ;            \\n\\n              }\\n\\n\\n   }\\n\\n\\n\\n    \\n    int result = maxi%1000000007;\\n    return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long int ans =0;\\n        for(int i =0;i<n;i++){\\n            ans+=arr[i];\\n        }\\n\\n            long long int maxi = INT_MIN;\\n    long long int sum =0;\\n     if(k==1) {\\n      for(int i =0;i<n;i++){\\n        sum = sum + arr[i];\\n         if(sum<0)\\n        sum =0;\\n        if(sum>maxi)\\n        maxi = sum;\\n    }\\n    \\n    }\\n   else if(k>=2){\\n              if(ans<0){\\n                          for(int i =1;i<=2;i++){\\n                              for(int j =0;j<n;j++){\\n                                  sum+=arr[j];\\n                                  if(sum<0)\\n                                  sum =0;\\n                                  if(sum>maxi)\\n                                  maxi = sum;\\n                              }\\n\\n                          }\\n\\n              }\\n              else if(ans>=0){\\n                      for(int i =1;i<=2;i++){\\n                          for(int j =0;j<n;j++){\\n                              sum+=arr[j];\\n                              if(sum<0)\\n                              sum =0;\\n                              if(sum>maxi)\\n                              maxi =sum;\\n                          }\\n                      }\\n                   //   long long int temp = ;\\n                      maxi = maxi+ (k-2)*ans ;            \\n\\n              }\\n\\n\\n   }\\n\\n\\n\\n    \\n    int result = maxi%1000000007;\\n    return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984944,
                "title": "easy-solution-commented",
                "content": "```\\nclass Solution {\\n    //the question is fairly easy if you have kdane algo in mind...\\n    \\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n        //no need of concatenations...\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n        //here we will check both normal sum and kdane sum\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         //we will here add \\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    //this function right here can be same as other but for shorter lenght therefore we don\\'t use mod\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```\\nPlease Upvote if helpful...",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //the question is fairly easy if you have kdane algo in mind...\\n    \\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n        //no need of concatenations...\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }\\n        //here we will check both normal sum and kdane sum\\n     long sum=0;\\n     for(int i:arr){\\n         sum+=i;\\n     }\\n     if(sum<0){\\n        int result=kadane(arr)%mod;\\n        return result>0?result:0;\\n     }\\n     else{\\n         //we will here add \\n         int result= (int)(kadane(arr)+((k-2)*sum)%mod)%mod;\\n         return result>0?result:0;\\n     }\\n    }\\n    //this function right here can be same as other but for shorter lenght therefore we don\\'t use mod\\n    public int maxsum(int []arr){\\n         int sum=arr[0];\\n         int result=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            sum=Math.max(sum+arr[i],arr[i]);\\n            result=Math.max(result,sum);\\n        }\\n        return result;\\n    }\\n    public int kadane(int[]arr){\\n         long sum=arr[0];\\n         long result=arr[0];\\n        for(int i=1;i<arr.length*2;i++){\\n            sum=Math.max(sum+(arr[i%arr.length]%mod),arr[i%arr.length]);\\n            result=Math.max(result,sum);\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924281,
                "title": "greatest-of-one-array-or-maximum-prefix-and-suffix-sum-for-extremes",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        p = sum(arr)\\n        msum = 0\\n        mending = 0\\n        for el in arr:\\n            mending = max(el, el + mending)\\n            msum = max(msum, mending)\\n        if k > 1:\\n            mpref = 0\\n            msuff = 0\\n            pf = sf = 0\\n            for i in range(n):\\n                pf += arr[i]\\n                sf += arr[n - i - 1]\\n                mpref = max(mpref, pf)\\n                msuff = max(msuff, sf)\\n            msum = max(msum, max(p, 0) * (k - 2) + mpref + msuff)\\n        return msum % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        p = sum(arr)\\n        msum = 0\\n        mending = 0\\n        for el in arr:\\n            mending = max(el, el + mending)\\n            msum = max(msum, mending)\\n        if k > 1:\\n            mpref = 0\\n            msuff = 0\\n            pf = sf = 0\\n            for i in range(n):\\n                pf += arr[i]\\n                sf += arr[n - i - 1]\\n                mpref = max(mpref, pf)\\n                msuff = max(msuff, sf)\\n            msum = max(msum, max(p, 0) * (k - 2) + mpref + msuff)\\n        return msum % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879438,
                "title": "c-simple-and-fast-with-explanation",
                "content": "# Intuition\\n3 cases need to handle\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n3 cases need to handle\\n1. When all the elements of array are +ve. --> sum_array*k\\n2. When all elements of array are -ve. --> 0\\n3. When both +ve and -ve elements are present. --> Just repeat array 3 times and see the pattern that in every n elements block `max_so_far` forms an AP so we need nth element of that sequence and i.e `max_so_far` (we got from first two sequence) and add `(k-2)*arr_sum` (which is nothing but `T_nth = a + (n-1)*d` in AP series).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        int max_so_far=0, cur_sum=0;\\n        int arr_sum=0;\\n        //min b/c when k<2 it will not go beyond n terms\\n        for(int i=0; i<min(k, 2)*n; i++){\\n            if(i<n) arr_sum+=arr[i];\\n            cur_sum=max(arr[i%n], cur_sum+arr[i%n]);\\n            max_so_far=max(max_so_far, cur_sum);\\n            if(cur_sum<0) cur_sum=0;\\n        }\\n        if(k<2) return (long long)max_so_far%mod;\\n        return ((long long)max_so_far + (long long)(arr_sum>0?(long long)(k-2)*arr_sum:0))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        int max_so_far=0, cur_sum=0;\\n        int arr_sum=0;\\n        //min b/c when k<2 it will not go beyond n terms\\n        for(int i=0; i<min(k, 2)*n; i++){\\n            if(i<n) arr_sum+=arr[i];\\n            cur_sum=max(arr[i%n], cur_sum+arr[i%n]);\\n            max_so_far=max(max_so_far, cur_sum);\\n            if(cur_sum<0) cur_sum=0;\\n        }\\n        if(k<2) return (long long)max_so_far%mod;\\n        return ((long long)max_so_far + (long long)(arr_sum>0?(long long)(k-2)*arr_sum:0))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846764,
                "title": "python-kadane-algo",
                "content": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        s=sum(arr)\\n        if s>0:\\n            sx=k*s\\n            cx=sx\\n            for i in range(len(arr)):\\n                cx-=arr[i]\\n                sx=max(sx,cx)\\n            rcx=sx\\n            for i in range(len(arr)-1,-1,-1):\\n                cx-=arr[i]\\n                rcx-=arr[i]\\n                sx=max(sx,cx,rcx)\\n            return (sx)%((10**9)+7)\\n        ms=0\\n        cs=0\\n        for i in range(len(arr)):\\n            cs+=arr[i]\\n            cs=max(cs,0)\\n            ms=max(ms,cs)\\n        if ms<=0 or k==1:return ms\\n        arr+=arr\\n        ms=0\\n        cs=0\\n        for i in range(len(arr)):\\n            cs+=arr[i]\\n            cs=max(cs,0)\\n            ms=max(ms,cs)\\n        return ms%((10**9)+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        s=sum(arr)\\n        if s>0:\\n            sx=k*s\\n            cx=sx\\n            for i in range(len(arr)):\\n                cx-=arr[i]\\n                sx=max(sx,cx)\\n            rcx=sx\\n            for i in range(len(arr)-1,-1,-1):\\n                cx-=arr[i]\\n                rcx-=arr[i]\\n                sx=max(sx,cx,rcx)\\n            return (sx)%((10**9)+7)\\n        ms=0\\n        cs=0\\n        for i in range(len(arr)):\\n            cs+=arr[i]\\n            cs=max(cs,0)\\n            ms=max(ms,cs)\\n        if ms<=0 or k==1:return ms\\n        arr+=arr\\n        ms=0\\n        cs=0\\n        for i in range(len(arr)):\\n            cs+=arr[i]\\n            cs=max(cs,0)\\n            ms=max(ms,cs)\\n        return ms%((10**9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810564,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kadane(self,ans):\\n        max_sum_so_far, max_ending_here = ans[0], ans[0]\\n\\n        for i in ans[1:]:\\n            max_ending_here = max(max_ending_here+i,i)\\n            max_sum_so_far = max(max_sum_so_far,max_ending_here)\\n\\n        return max_sum_so_far\\n\\n    def kConcatenationMaxSum(self, arr, k):\\n        if k == 1:\\n            return self.kadane(arr)%(10**9+7)\\n        else:\\n            return ((k-2)*max(sum(arr),0) + max(self.kadane(arr*2),0))%(10**9+7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kadane(self,ans):\\n        max_sum_so_far, max_ending_here = ans[0], ans[0]\\n\\n        for i in ans[1:]:\\n            max_ending_here = max(max_ending_here+i,i)\\n            max_sum_so_far = max(max_sum_so_far,max_ending_here)\\n\\n        return max_sum_so_far\\n\\n    def kConcatenationMaxSum(self, arr, k):\\n        if k == 1:\\n            return self.kadane(arr)%(10**9+7)\\n        else:\\n            return ((k-2)*max(sum(arr),0) + max(self.kadane(arr*2),0))%(10**9+7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768043,
                "title": "using-kadanes-algorithm-c-faster-than-97-62",
                "content": "class Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n         long long csum=0,maxm=0,n=arr.size(),temp=1,tsum=0;\\n        if(k>1)\\n            temp=2;\\n        \\n    for(int i=0;i<n*temp;i++)\\n    {\\n        tsum+=arr[i%n];\\n        csum+=arr[i%n];\\n        if(csum<0)\\n            csum=0;\\n        maxm = max(maxm,csum);\\n        \\n    }\\n        tsum/=2;\\n    if(tsum>=0 && k-2>0)\\n    return (maxm+tsum*(k-2))%(1000000007);\\n        return maxm%(1000000007);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\\n         long long csum=0,maxm=0,n=arr.size(),temp=1,tsum=0;\\n        if(k>1)\\n            temp=2;\\n        \\n    for(int i=0;i<n*temp;i++)\\n    {\\n        tsum+=arr[i%n];\\n        csum+=arr[i%n];\\n        if(csum<0)\\n            csum=0;\\n        maxm = max(maxm,csum);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2639571,
                "title": "without-kadane-o-n-solution-explained-python",
                "content": "```\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        MOD = 1000000007\\n        if max(arr) < 0: return 0 #obvious case\\n        \\n        if min(arr) >= 0: return sum(arr)*k % MOD #obvious case\\n        \\n        n = len(arr)\\n        j = -1\\n        max_subarray = subarray = 0\\n        for i in range(n):\\n            subarray += arr[i]\\n            \\n            while subarray < 0:\\n                j += 1\\n                subarray -= arr[j]\\n            \\n            max_subarray = max(subarray, max_subarray)\\n        if k == 1: return max_subarray%MOD #obvious case\\n        \\n        #for not obvious cases you only have 3 options for ans\\n        # 1. ans = max_subarray in unmodified array\\n        # 2. ans = arr[:i] + arr[j:] for i such that arr[i:] is max and for j such that arr[j:] is max\\n        # 3. ans = sum(arr)*k - max_leading_neg_in_arr - max_trailing_neg_in_arr\\n        left_max = left_neg_max = c_sum = 0\\n        for i in range(n):\\n            c_sum += arr[i]\\n            left_max = max(left_max, c_sum)            \\n            if c_sum < 0: left_neg_max = min(c_sum, left_neg_max)\\n                \\n                \\n        right_max = right_neg_max = c_sum = 0\\n        for i in range(n-1, -1, -1):\\n            c_sum += arr[i]\\n            right_max = max(right_max, c_sum)\\n            if c_sum < 0: right_neg_max = min(c_sum, right_neg_max)\\n        \\n        \\n        return max(max_subarray, left_max + right_max, sum(arr)*k - left_neg_max - right_neg_max)%MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n        MOD = 1000000007\\n        if max(arr) < 0: return 0 #obvious case\\n        \\n        if min(arr) >= 0: return sum(arr)*k % MOD #obvious case\\n        \\n        n = len(arr)\\n        j = -1\\n        max_subarray = subarray = 0\\n        for i in range(n):\\n            subarray += arr[i]\\n            \\n            while subarray < 0:\\n                j += 1\\n                subarray -= arr[j]\\n            \\n            max_subarray = max(subarray, max_subarray)\\n        if k == 1: return max_subarray%MOD #obvious case\\n        \\n        #for not obvious cases you only have 3 options for ans\\n        # 1. ans = max_subarray in unmodified array\\n        # 2. ans = arr[:i] + arr[j:] for i such that arr[i:] is max and for j such that arr[j:] is max\\n        # 3. ans = sum(arr)*k - max_leading_neg_in_arr - max_trailing_neg_in_arr\\n        left_max = left_neg_max = c_sum = 0\\n        for i in range(n):\\n            c_sum += arr[i]\\n            left_max = max(left_max, c_sum)            \\n            if c_sum < 0: left_neg_max = min(c_sum, left_neg_max)\\n                \\n                \\n        right_max = right_neg_max = c_sum = 0\\n        for i in range(n-1, -1, -1):\\n            c_sum += arr[i]\\n            right_max = max(right_max, c_sum)\\n            if c_sum < 0: right_neg_max = min(c_sum, right_neg_max)\\n        \\n        \\n        return max(max_subarray, left_max + right_max, sum(arr)*k - left_neg_max - right_neg_max)%MOD\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566959,
                "content": [
                    {
                        "username": "Vishesh2308",
                        "content": "Found this awesome explanation on YouTube.\\nhttps://youtu.be/WElk6NK83QY (clickable)"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": " **Input** : \narr = [10000,10000,10000,10000,10000,10000,10000,\n10000,10000,10000]\nk = 1000000\nThis test case is like OooAmmmGiiiii."
                    },
                    {
                        "username": "Bit-code0180",
                        "content": "how to solve this test case \\n"
                    },
                    {
                        "username": "SergiConstance",
                        "content": "for arr = [-1,-2],  and k = 7\\nhow can answer be 0.?\\nAnswer should be -1......right??"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Note that the length of the sub-array can be 0 and its sum in that case is 0"
                    },
                    {
                        "username": "Pankaj_Kumar_Das",
                        "content": "it has said na, in case all elements are negative we can have a option where we need not to choose any element and will be maximum output then a negative output.\\n"
                    },
                    {
                        "username": "singharyan242000",
                        "content": "Can anyone tell what does the modulo operator do here ?"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is a classical trick to avoid integer overflow. For example the range of 32 bit INT is -2^31 to 2^31 - 1. Now for example you try to add two numbers 2^31 - 1 and 2. This will cause an overflow and you will get -2^31 as the result which is unexpected. To avoid this we can MOD the answer with a really large prime number most commonly used one is 1e9 + 7. Which ensures that the results fit in the given range while ensuring uniqueness, since the number is prime itself and the result likely wont be a multiple of it."
                    },
                    {
                        "username": "dipto_reza",
                        "content": "as the result can be very large when you sum up all the elements, mod actually shrinks the sum ."
                    },
                    {
                        "username": "johnnyho415",
                        "content": "i think it just does nothing more than making the returned value smaller "
                    },
                    {
                        "username": "sam2611",
                        "content": "This is hard problem."
                    }
                ]
            },
            {
                "id": 1927741,
                "content": [
                    {
                        "username": "Vishesh2308",
                        "content": "Found this awesome explanation on YouTube.\\nhttps://youtu.be/WElk6NK83QY (clickable)"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": " **Input** : \narr = [10000,10000,10000,10000,10000,10000,10000,\n10000,10000,10000]\nk = 1000000\nThis test case is like OooAmmmGiiiii."
                    },
                    {
                        "username": "Bit-code0180",
                        "content": "how to solve this test case \\n"
                    },
                    {
                        "username": "SergiConstance",
                        "content": "for arr = [-1,-2],  and k = 7\\nhow can answer be 0.?\\nAnswer should be -1......right??"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Note that the length of the sub-array can be 0 and its sum in that case is 0"
                    },
                    {
                        "username": "Pankaj_Kumar_Das",
                        "content": "it has said na, in case all elements are negative we can have a option where we need not to choose any element and will be maximum output then a negative output.\\n"
                    },
                    {
                        "username": "singharyan242000",
                        "content": "Can anyone tell what does the modulo operator do here ?"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is a classical trick to avoid integer overflow. For example the range of 32 bit INT is -2^31 to 2^31 - 1. Now for example you try to add two numbers 2^31 - 1 and 2. This will cause an overflow and you will get -2^31 as the result which is unexpected. To avoid this we can MOD the answer with a really large prime number most commonly used one is 1e9 + 7. Which ensures that the results fit in the given range while ensuring uniqueness, since the number is prime itself and the result likely wont be a multiple of it."
                    },
                    {
                        "username": "dipto_reza",
                        "content": "as the result can be very large when you sum up all the elements, mod actually shrinks the sum ."
                    },
                    {
                        "username": "johnnyho415",
                        "content": "i think it just does nothing more than making the returned value smaller "
                    },
                    {
                        "username": "sam2611",
                        "content": "This is hard problem."
                    }
                ]
            },
            {
                "id": 1574642,
                "content": [
                    {
                        "username": "Vishesh2308",
                        "content": "Found this awesome explanation on YouTube.\\nhttps://youtu.be/WElk6NK83QY (clickable)"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": " **Input** : \narr = [10000,10000,10000,10000,10000,10000,10000,\n10000,10000,10000]\nk = 1000000\nThis test case is like OooAmmmGiiiii."
                    },
                    {
                        "username": "Bit-code0180",
                        "content": "how to solve this test case \\n"
                    },
                    {
                        "username": "SergiConstance",
                        "content": "for arr = [-1,-2],  and k = 7\\nhow can answer be 0.?\\nAnswer should be -1......right??"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Note that the length of the sub-array can be 0 and its sum in that case is 0"
                    },
                    {
                        "username": "Pankaj_Kumar_Das",
                        "content": "it has said na, in case all elements are negative we can have a option where we need not to choose any element and will be maximum output then a negative output.\\n"
                    },
                    {
                        "username": "singharyan242000",
                        "content": "Can anyone tell what does the modulo operator do here ?"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is a classical trick to avoid integer overflow. For example the range of 32 bit INT is -2^31 to 2^31 - 1. Now for example you try to add two numbers 2^31 - 1 and 2. This will cause an overflow and you will get -2^31 as the result which is unexpected. To avoid this we can MOD the answer with a really large prime number most commonly used one is 1e9 + 7. Which ensures that the results fit in the given range while ensuring uniqueness, since the number is prime itself and the result likely wont be a multiple of it."
                    },
                    {
                        "username": "dipto_reza",
                        "content": "as the result can be very large when you sum up all the elements, mod actually shrinks the sum ."
                    },
                    {
                        "username": "johnnyho415",
                        "content": "i think it just does nothing more than making the returned value smaller "
                    },
                    {
                        "username": "sam2611",
                        "content": "This is hard problem."
                    }
                ]
            },
            {
                "id": 1799552,
                "content": [
                    {
                        "username": "Vishesh2308",
                        "content": "Found this awesome explanation on YouTube.\\nhttps://youtu.be/WElk6NK83QY (clickable)"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": " **Input** : \narr = [10000,10000,10000,10000,10000,10000,10000,\n10000,10000,10000]\nk = 1000000\nThis test case is like OooAmmmGiiiii."
                    },
                    {
                        "username": "Bit-code0180",
                        "content": "how to solve this test case \\n"
                    },
                    {
                        "username": "SergiConstance",
                        "content": "for arr = [-1,-2],  and k = 7\\nhow can answer be 0.?\\nAnswer should be -1......right??"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Note that the length of the sub-array can be 0 and its sum in that case is 0"
                    },
                    {
                        "username": "Pankaj_Kumar_Das",
                        "content": "it has said na, in case all elements are negative we can have a option where we need not to choose any element and will be maximum output then a negative output.\\n"
                    },
                    {
                        "username": "singharyan242000",
                        "content": "Can anyone tell what does the modulo operator do here ?"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is a classical trick to avoid integer overflow. For example the range of 32 bit INT is -2^31 to 2^31 - 1. Now for example you try to add two numbers 2^31 - 1 and 2. This will cause an overflow and you will get -2^31 as the result which is unexpected. To avoid this we can MOD the answer with a really large prime number most commonly used one is 1e9 + 7. Which ensures that the results fit in the given range while ensuring uniqueness, since the number is prime itself and the result likely wont be a multiple of it."
                    },
                    {
                        "username": "dipto_reza",
                        "content": "as the result can be very large when you sum up all the elements, mod actually shrinks the sum ."
                    },
                    {
                        "username": "johnnyho415",
                        "content": "i think it just does nothing more than making the returned value smaller "
                    },
                    {
                        "username": "sam2611",
                        "content": "This is hard problem."
                    }
                ]
            },
            {
                "id": 2014095,
                "content": [
                    {
                        "username": "Vishesh2308",
                        "content": "Found this awesome explanation on YouTube.\\nhttps://youtu.be/WElk6NK83QY (clickable)"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": " **Input** : \narr = [10000,10000,10000,10000,10000,10000,10000,\n10000,10000,10000]\nk = 1000000\nThis test case is like OooAmmmGiiiii."
                    },
                    {
                        "username": "Bit-code0180",
                        "content": "how to solve this test case \\n"
                    },
                    {
                        "username": "SergiConstance",
                        "content": "for arr = [-1,-2],  and k = 7\\nhow can answer be 0.?\\nAnswer should be -1......right??"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Note that the length of the sub-array can be 0 and its sum in that case is 0"
                    },
                    {
                        "username": "Pankaj_Kumar_Das",
                        "content": "it has said na, in case all elements are negative we can have a option where we need not to choose any element and will be maximum output then a negative output.\\n"
                    },
                    {
                        "username": "singharyan242000",
                        "content": "Can anyone tell what does the modulo operator do here ?"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is a classical trick to avoid integer overflow. For example the range of 32 bit INT is -2^31 to 2^31 - 1. Now for example you try to add two numbers 2^31 - 1 and 2. This will cause an overflow and you will get -2^31 as the result which is unexpected. To avoid this we can MOD the answer with a really large prime number most commonly used one is 1e9 + 7. Which ensures that the results fit in the given range while ensuring uniqueness, since the number is prime itself and the result likely wont be a multiple of it."
                    },
                    {
                        "username": "dipto_reza",
                        "content": "as the result can be very large when you sum up all the elements, mod actually shrinks the sum ."
                    },
                    {
                        "username": "johnnyho415",
                        "content": "i think it just does nothing more than making the returned value smaller "
                    },
                    {
                        "username": "sam2611",
                        "content": "This is hard problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sell Diminishing-Valued Colored Balls",
        "question_content": "<p>You have an <code>inventory</code> of different colored balls, and there is a customer that wants <code>orders</code> balls of <strong>any</strong> color.</p>\n\n<p>The customer weirdly values the colored balls. Each colored ball&#39;s value is the number of balls <strong>of that color&nbsp;</strong>you currently have in your <code>inventory</code>. For example, if you own <code>6</code> yellow balls, the customer would pay <code>6</code> for the first yellow ball. After the transaction, there are only <code>5</code> yellow balls left, so the next yellow ball is then valued at <code>5</code> (i.e., the value of the balls decreases as you sell more to the customer).</p>\n\n<p>You are given an integer array, <code>inventory</code>, where <code>inventory[i]</code> represents the number of balls of the <code>i<sup>th</sup></code> color that you initially own. You are also given an integer <code>orders</code>, which represents the total number of balls that the customer wants. You can sell the balls <strong>in any order</strong>.</p>\n\n<p>Return <em>the <strong>maximum</strong> total value that you can attain after selling </em><code>orders</code><em> colored balls</em>. As the answer may be too large, return it <strong>modulo </strong><code>10<sup>9 </sup>+ 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/jj.gif\" style=\"width: 480px; height: 270px;\" />\n<pre>\n<strong>Input:</strong> inventory = [2,5], orders = 4\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inventory = [3,5], orders = 6\n<strong>Output:</strong> 19\n<strong>Explanation: </strong>Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inventory.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= inventory[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= orders &lt;= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 927560,
                "title": "c-binary-answer-or-sort-greedy",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\nI updated with more graphics/explanations at the end of this post. Make sure you check them out if there is anything unclear to you. Good luck.\\n\\n## Solution 1. Binary Answer\\n\\n**Intuition**:\\n\\nWe should greedily pick the greatest number `A[i]` from `A`, add `A[i]` to answer and then `A[i]--`.\\n\\nThe simple solution would be using max heap to simulate the above process. But it will get TLE.\\n\\nTo solve it more efficiently, we can break this problem into two steps:\\n\\n1. Find the smallest number `k` such that we make all `A[i] > k` to be `k`, and `sum(A[i] - k)` (i.e. the number of balls we take) is smaller than `T`. We can do this using binary search.\\n2. Based on `k`, we can calculate the maximum total value.\\n\\n![image](https://assets.leetcode.com/users/images/a96cffb3-3a28-4b68-8f99-dc3f2f339858_1604809682.3360424.png)\\n\\n\\n**Algorithm**:\\n\\nFor **Step 1**, I first store the frequencies of `A[i]` in a map. The range of `k` is `[0, max(A)]`, so we do binary search within this range.\\n\\nLet `L = 0, R = max(A)`.\\n\\nWe define a `valid(M, T)` function which returns true if `sum(A[i] - M | A[i] > M) >= T`.\\n\\nThe smaller the `M` is, the more likely `valid(M, T)` returns true.\\n\\nIf `valid(M, T)`, we should increase `M`, so `L = M + 1`. Otherwise, we do `R = M - 1`.\\n\\nIn the end, `L` is the `k` we are looking for.\\n\\nFor **Step 2**, we traverse the `m` in descending order. For each pair `n, cnt` that `n > L`, we will take `cnt * (n - L)` balls from it which has total value `(n + L + 1) * (n - L) / 2 * cnt`.\\n![image](https://assets.leetcode.com/users/images/d26a21f3-e46a-49fb-b7d6-e521d8de0b10_1604810021.257941.png)\\n\\n\\nIf after traversing the `m`, `T` is still not exhausted, we should add `L * T` to the answer.\\n\\n![image](https://assets.leetcode.com/users/images/08f78dfe-32cb-487a-a8f9-919cad68b75a_1604810861.4671383.png)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-214/problems/sell-diminishing-valued-colored-balls/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(max(A)))\\n// Space: O(N)\\nclass Solution {\\n    map<int, int, greater<>> m;\\n    bool valid(int M, int T) {\\n        for (auto &[n , cnt] : m) {\\n            if (n <= M) break;\\n            T -= (long)cnt * (n - M);\\n            if (T <= 0) return true;\\n        }\\n        return T <= 0;\\n    }\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        long ans = 0, mod = 1e9+7, L = 0, R = *max_element(begin(A), end(A));\\n        for (int n : A) m[n]++;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(M, T)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        for (auto &[n , cnt] : m) {\\n            if (n <= L) break;\\n            T -= cnt * (n - L);\\n            ans = (ans + (n + L + 1) * (n - L) / 2 % mod * cnt % mod) % mod;\\n        }\\n        if (T) ans = (ans + L * T % mod) % mod;\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate 11/9/2020:\\n\\n> We define a `valid(M, T)` function which returns true if `sum(A[i] - M | A[i] > M) >= T`.\\n\\nThe meaning of this `valid(M, T)` function is that if we pick all the balls with value greater than `M`, the number of balls we will get is greater than or equal to our target amount of balls `T`. So a better function name could be `haveEnoughBalls`.\\n\\nThe binary search is looking for the smallest `M` which is invalid, or can\\'t get us enough balls. And for the remainder, we are sure those balls are of value `M`.\\n\\n![image](https://assets.leetcode.com/users/images/fd5bb50c-97ec-47e3-b5fe-a13ddd17346c_1604954189.8344336.png)\\n\\n![image](https://assets.leetcode.com/users/images/3d5b1fba-6e23-444e-b33b-c74a618dec36_1604954132.6884036.png)\\n\\n# Summary of my thinking process\\n\\n1. If I directly use min heap to simulate the process, the time complexity is `O(sum(A) * logN)` which is too slow (the max heap solution can be improved as well if we don\\'t decrement the numbers by one). Is there a way to improve it?\\n2. We are always taking high value balls from top to bottom, like stripping the balls row by row from the top. What if I somehow know that I should strip all the balls above the `k`-th row? Can I efficiently calculate the values?\\n3. Yes I can. I can use the formula of the sum of arithmetic sequence to get the values of each column. And for the remainders, they must be at the `k`-th row so their values are `k`.\\n4. Now the problem is how to find this `k` efficiently? The meaning of it is the smallest row number which doesn\\'t give me enough ball. Does it have monotonicity?\\n5. Yes! At the beginning we strip no balls so we don\\'t have enough balls, let\\'s regard this as invalid. As we strip downwards, we will get more and more balls until a breakpoint where we get enough or more balls than we need. If we continue stripping, we will keep being valid. So it has perfect monotonicity, which means that I can use binary search!\\n6. To use binary search in range `[L, R] = [0, max(A)]`, I need to define a function `valid(M)` meaning having enough balls. It should return `true` if `sum( A[i] - M | A[i] > M ) >= T`. We can do this `valid(M)` in `O(N)` time.\\n7. Since the binary search takes `O(log(max(A)))` time, the overal time complexity is `O(Nlog(max(A)))`. Good to go.\\n\\n# More Binary Answer Problems\\n* [410. Split Array Largest Sum \\\\(Hard\\\\)](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1482. Minimum Number of Days to Make m Bouquets \\\\(Medium\\\\)](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [1300. Sum of Mutated Array Closest to Target \\\\(Medium\\\\)](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/)\\n* [1044. Longest Duplicate Substring \\\\(Hard\\\\)](https://leetcode.com/problems/longest-duplicate-substring/)\\n* [668. Kth Smallest Number in Multiplication Table (Hard)](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [719. Find K-th Smallest Pair Distance (Hard)](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [1283. Find the Smallest Divisor Given a Threshold (Medium)](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\n## Solution 2. Sort + Greedy\\n![image](https://assets.leetcode.com/users/images/28928ac0-7d63-41ee-9ba6-b2a8617d3138_1605093139.7600973.png)\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-214/problems/sell-diminishing-valued-colored-balls/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\n// Ref: www.youtube.com/watch?v=kBxqAnWo9Wo\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        sort(rbegin(A), rend(A)); // sort in descending order\\n        long mod = 1e9+7, N = A.size(), cur = A[0], ans = 0, i = 0;\\n        while (T) {\\n            while (i < N && A[i] == cur) ++i; // handle those same numbers together\\n            long next = i == N ? 0 : A[i], h = cur - next, r = 0, cnt = min((long)T, i * h);\\n            if (T < i * h) { // the i * h balls are more than what we need.\\n                h = T / i; // we just reduce the height by `T / i` instead\\n                r = T % i; \\n            }\\n            long val = cur - h; // each of the remainder `r` balls has value `cur - h`.\\n            ans = (ans + (cur + val + 1) * h / 2 * i + val * r) % mod;\\n            T -= cnt;\\n            cur = next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-214/problems/sell-diminishing-valued-colored-balls/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(max(A)))\\n// Space: O(N)\\nclass Solution {\\n    map<int, int, greater<>> m;\\n    bool valid(int M, int T) {\\n        for (auto &[n , cnt] : m) {\\n            if (n <= M) break;\\n            T -= (long)cnt * (n - M);\\n            if (T <= 0) return true;\\n        }\\n        return T <= 0;\\n    }\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        long ans = 0, mod = 1e9+7, L = 0, R = *max_element(begin(A), end(A));\\n        for (int n : A) m[n]++;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(M, T)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        for (auto &[n , cnt] : m) {\\n            if (n <= L) break;\\n            T -= cnt * (n - L);\\n            ans = (ans + (n + L + 1) * (n - L) / 2 % mod * cnt % mod) % mod;\\n        }\\n        if (T) ans = (ans + L * T % mod) % mod;\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-214/problems/sell-diminishing-valued-colored-balls/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\n// Ref: www.youtube.com/watch?v=kBxqAnWo9Wo\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        sort(rbegin(A), rend(A)); // sort in descending order\\n        long mod = 1e9+7, N = A.size(), cur = A[0], ans = 0, i = 0;\\n        while (T) {\\n            while (i < N && A[i] == cur) ++i; // handle those same numbers together\\n            long next = i == N ? 0 : A[i], h = cur - next, r = 0, cnt = min((long)T, i * h);\\n            if (T < i * h) { // the i * h balls are more than what we need.\\n                h = T / i; // we just reduce the height by `T / i` instead\\n                r = T % i; \\n            }\\n            long val = cur - h; // each of the remainder `r` balls has value `cur - h`.\\n            ans = (ans + (cur + val + 1) * h / 2 * i + val * r) % mod;\\n            T -= cnt;\\n            cur = next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927509,
                "title": "java-o-nlogn-detailed-explanation-runtime-beats-100",
                "content": "It is a greedy algorithm with some improvements for better complexity.\\n\\n**Maths Formula** - (x+1) + (x+2) + ... + (n-1) + n **=>** (1 + 2 + 3 + ...+ (n-1) + n) - (1 + 2 + 3 + ... + (x-1) + x) **=>** (n * (n+1)/2) - (x * (x+1)/2)\\n\\nGiven a below inventory (taking an already sorted) and number of orders as 23.\\n\\n![image](https://assets.leetcode.com/users/images/79155677-b3c3-4350-b8c9-943f58479873_1604809747.1179063.png)\\n\\n\\nIf you go by greedy, you would end up with something like this -\\n```\\nYou will get the profit in this sequence -\\n10, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3 \\n```\\n\\nUsing count, I am trying to improve the greedy by creating groups and calculating sum of the groups instead.\\n```\\ngroup 1 - 10 => 10\\ngroup 2 - 9, 9, 8, 8, 7, 7 => 2 * (9 + 8 + 7)\\ngroup 3 - 6, 6, 6, 6, 5, 5, 5, 5 => 4 * (6 + 5)\\ngroup 4 - 4, 4, 4, 4, 4 => 1 * (5)\\ngroup 5 - 3, 3, 3 => 1 * (3)\\n```\\n**n** denotes **index** , **count** denotes **number of elements traversed**, **orders** denotes **number of orders**.\\n*  n = 5, orders = 23, count = 1 \\n\\t* inventory[5]-inventory[4] > 0 => (10 - 9 > 0)\\n\\t* orders >= count * (inventory[5]-inventory[4]) => (23 >=  1 * (10-9))\\n\\t* for 1 * (10-9) orders, we can sell at (1 * 10) => 10\\n* n = 4, orders = 22, count = 2\\n\\t* inventory[4]-inventory[3] > 0 => (9 - 6 > 0)\\n\\t* orders >= count * (inventory[4]-inventory[3]) => (22 >=  2 * (9-6))\\n\\t* for 2 * (9-6) orders, we can sell at (2 * (9 + 8 + 7)) => 2 * (9* 10/2 - 6* 7/2) => 2 * 24 => 48\\n* n = 3, orders = 16, count = 3\\n\\t* inventory[3]-inventory[2] = 0\\n* n = 2, orders = 16, count = 4\\n\\t*  inventory[2]-inventory[1] > 0 => (6 - 4 > 0)\\n\\t*  orders >= count * (inventory[2]-inventory[1]) => (16 >=  4 * (6-4))\\n\\t*  for 4 * (6-4) orders, we can sell at (4 * (6 + 5)) => 4 * (6* 7/2 - 4* 5/2) => 4 * 11 => 44\\n*  n = 1, orders = 8, count = 5\\n\\t*   inventory[1]-inventory[0] > 0 => (4 - 2 > 0)\\n\\t*   orders >= count * (inventory[1]-inventory[0]) => (8 >=  5 * (4-2)) => false\\n\\t*   a = orders/count => 8/5 => 1, we can sell (5 * (4 - 3)) orders at (5 * (4)) => 20\\n\\t*   remaining orders => b = orders%count => 8%5 => 3 , we can sell (3) orders at 3 * (4 -1) => 9\\n*   total = 10 + 48 + 44 + 20 + 9 => 131\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long ans = 0;\\n        int n = inventory.length-1;\\n        long count = 1;\\n        while(orders > 0){\\n            if(n > 0 && inventory[n] - inventory[n-1] > 0 && orders >= count * (inventory[n] - inventory[n-1])){\\n                ans += count * sumFromNtoX(inventory[n], inventory[n-1]);\\n                orders -= count * (inventory[n] - inventory[n-1]);\\n            }else if(n == 0 || inventory[n] - inventory[n-1] > 0){\\n                long a = orders / count;\\n                ans += count * sumFromNtoX(inventory[n], inventory[n]-a);\\n                long b = orders % count;\\n                ans += b * (inventory[n]-a);\\n                orders = 0;\\n            }\\n            ans %= 1000000007;\\n            n --;\\n            count ++;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private long sumFromNtoX(long n, long x){\\n        return (n * (n+1))/2 - (x * (x+1))/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nYou will get the profit in this sequence -\\n10, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3 \\n```\n```\\ngroup 1 - 10 => 10\\ngroup 2 - 9, 9, 8, 8, 7, 7 => 2 * (9 + 8 + 7)\\ngroup 3 - 6, 6, 6, 6, 5, 5, 5, 5 => 4 * (6 + 5)\\ngroup 4 - 4, 4, 4, 4, 4 => 1 * (5)\\ngroup 5 - 3, 3, 3 => 1 * (3)\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long ans = 0;\\n        int n = inventory.length-1;\\n        long count = 1;\\n        while(orders > 0){\\n            if(n > 0 && inventory[n] - inventory[n-1] > 0 && orders >= count * (inventory[n] - inventory[n-1])){\\n                ans += count * sumFromNtoX(inventory[n], inventory[n-1]);\\n                orders -= count * (inventory[n] - inventory[n-1]);\\n            }else if(n == 0 || inventory[n] - inventory[n-1] > 0){\\n                long a = orders / count;\\n                ans += count * sumFromNtoX(inventory[n], inventory[n]-a);\\n                long b = orders % count;\\n                ans += b * (inventory[n]-a);\\n                orders = 0;\\n            }\\n            ans %= 1000000007;\\n            n --;\\n            count ++;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private long sumFromNtoX(long n, long x){\\n        return (n * (n+1))/2 - (x * (x+1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927522,
                "title": "python-n-log-n-690-ms",
                "content": "First, we sort the inventory large to small. This is the most complex (n * log n) operation. Then, we start collecting/valuing the balls for sale.\\n\\n**The algorithm**\\n\\nWe need to sell the balls with the most frequent color. Once the most frequent ball color reaches  the frequency of the next ball color, we sell the two most frequent colors one after another. Once we reach the frequency of the third most frequent color, we start selling  the three colors one after another, and so on. The value-maximizing order of selling (row by row) is shown on the picture.\\n\\n![image](https://assets.leetcode.com/users/images/f57d26a4-fa52-4d66-a591-cb95402c4ba8_1604840291.874188.png)\\n\\n**Value calculation while moving from more frequent to less frequent color**\\n\\nWhen we move to the next color, we calculate *width* - the number of colors with the same frequency. We  determine how many balls we can *sell* before reaching the frequency of the next color, limited by the remaining *order* . The frequency of the next color is *inventory[ind+1]* ; thus, we can *sell* at max *width * (inventory[ind]-inventory[ind+1])* . Once we know *sell* , we calculate the value of the balls we are selling - simple arithmetic progression. We sell all most frequent colors in the amount *whole* (quotient of *sell* and *width* ), and then *remainder*  .\\n\\nThe picture shows calculation for order = 12.\\n\\n![image](https://assets.leetcode.com/users/images/9078e2de-a8a9-49ca-ac94-a7bcdf534c89_1604842047.8952916.png)\\n\\n1. Blue color, frequency = 6, next color frequency = 5, width=1. We can sell only one blue ball.\\n2. Red color, frequency = 5, next color frequency = 5, width=2. We do not sell any balls, because next frequency matches current frequency.\\n3. Green color, frequency = 5, next color frequency = 1, width=3. We will be selling colors Blue, Red, Green row by row, untill the order is fulfilled. As the remaining order is 11, we will sell 3 whole rows, and remainder is 2 balls from the next row.\\n\\n**The arithmetic progression part**\\n\\nAt Green color, the order is 11. *Width* = 3 (number of colors of the same highest frequency). *Whole* = 3 - we will sell three rows of Blue, Red, and Green (BRG-BRG-BRG). *Remainder* = 2 - we will also sell 2 balls of the remaining most frequent colors, e.g., Blue and Red (BR).\\n\\nThe value of the residual balls is simple - *inventory[ind] - whole =  5-3=2* ; we just need to multiply them by *remainder* .\\n\\nThe value of *whole* balls is *width* by the value of the balls of one color. The value of the balls of one color is arithmetic progression between the value when we start selling - *inventory[ind] = 5* , and when we end - *inventory[ind] - whole + 1 = 3*.  The value of each color is 5 + 4 + 3 = 12. \\n\\n**The program (1,400ms)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, inv: List[int], orders: int) -> int:\\n        inv.sort(reverse=True)\\n        inv.append(0)\\n        ans, ind, width=0,0,0\\n        \\n        while orders>0:\\n            width += 1\\n            sell=min(orders, width * (inv[ind] - inv[ind+1]))\\n            whole, remainder= divmod(sell, width)\\n            ans += width*(whole*(inv[ind]+inv[ind]-(whole-1)))//2 + remainder*(inv[ind]-whole)\\n            orders -= sell\\n            ind += 1\\n        return ans % 1_000_000_007      \\n```\\n\\n**Improvement (690 ms)**\\n\\nIf many colors have the same frequency, collecting this information (through *collections.Counter()*) will eliminate the need for repeated operations, line *width += 1* needs to account for how many colors have the same frequency at the onset.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, inv: List[int], orders: int) -> int:\\n        arr=sorted(Counter(inv).items(), reverse=True)+[(0,0)]\\n        ans, ind, width=0,0,0\\n        \\n        while orders>0:\\n            width += arr[ind][1]\\n            sell=min(orders, width * (arr[ind][0] - arr[ind+1][0]))\\n            whole, remainder= divmod(sell, width)\\n            ans += width*(whole*(arr[ind][0]+arr[ind][0]-(whole-1)))//2 + remainder*(arr[ind][0]-whole)\\n            orders -= sell\\n            ind += 1\\n        return ans % 1_000_000_007  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inv: List[int], orders: int) -> int:\\n        inv.sort(reverse=True)\\n        inv.append(0)\\n        ans, ind, width=0,0,0\\n        \\n        while orders>0:\\n            width += 1\\n            sell=min(orders, width * (inv[ind] - inv[ind+1]))\\n            whole, remainder= divmod(sell, width)\\n            ans += width*(whole*(inv[ind]+inv[ind]-(whole-1)))//2 + remainder*(inv[ind]-whole)\\n            orders -= sell\\n            ind += 1\\n        return ans % 1_000_000_007      \\n```\n```\\nclass Solution:\\n    def maxProfit(self, inv: List[int], orders: int) -> int:\\n        arr=sorted(Counter(inv).items(), reverse=True)+[(0,0)]\\n        ans, ind, width=0,0,0\\n        \\n        while orders>0:\\n            width += arr[ind][1]\\n            sell=min(orders, width * (arr[ind][0] - arr[ind+1][0]))\\n            whole, remainder= divmod(sell, width)\\n            ans += width*(whole*(arr[ind][0]+arr[ind][0]-(whole-1)))//2 + remainder*(arr[ind][0]-whole)\\n            orders -= sell\\n            ind += 1\\n        return ans % 1_000_000_007  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116418,
                "title": "java-sorting-solution-easy-to-understand-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        /*                       \\n          1  3  5  5  9  9  9    original sorted inventory\\n          1  3  5  5  5  5  5    profit gain after selling all 9-value balls: (9 + 8 + 7 + 6) * 3 -> (9 + 6) * (9 - 6 + 1) / 2 * 3\\n          1  3  3  3  3  3  3    (5 + 4) * (5 - 4 + 1) / 2 * 5  -> (curValue + nextValue + 1) * (curValue - nextValue) / 2 * numSameColor\\n          1  1  1  1  1  1  1\\n          0  0  0  0  0  0  0\\n          \\n          need to handle the edge case that orders left is less than the number of items to buy\\n        */\\n        int mod = 1000000007;\\n        Arrays.sort(inventory);\\n        int curIndex = inventory.length - 1;\\n        int curValue = inventory[curIndex];\\n        long profit = 0;\\n        while (orders > 0) {\\n            while (curIndex >= 0 && inventory[curIndex] == curValue) {\\n                curIndex--;\\n            }\\n            // if all colors of balls are the same value, nextValue is 0\\n            int nextValue = curIndex < 0 ? 0 : inventory[curIndex];\\n            // number of colors of balls with same value \\n            int numSameColor = inventory.length - 1 - curIndex;\\n            // number of items to buy\\n            int nums = (curValue - nextValue) * numSameColor;\\n            if (orders >= nums) {\\n                // buy all items\\n                profit += (long)(curValue + nextValue + 1) * (curValue - nextValue) / 2 * numSameColor;\\n            } else {\\n\\t\\t\\t    // orders left is less than the number of items to buy\\n                int numFullRow = orders / numSameColor;\\n                int remainder = orders % numSameColor;\\n                profit += (long)(curValue + curValue - numFullRow + 1) * numFullRow / 2 * numSameColor;\\n                profit += (long)(curValue - numFullRow) * remainder;\\n            }\\n            orders -= nums;\\n            profit = profit % mod;\\n            curValue = nextValue;\\n        }\\n        return (int)profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        /*                       \\n          1  3  5  5  9  9  9    original sorted inventory\\n          1  3  5  5  5  5  5    profit gain after selling all 9-value balls: (9 + 8 + 7 + 6) * 3 -> (9 + 6) * (9 - 6 + 1) / 2 * 3\\n          1  3  3  3  3  3  3    (5 + 4) * (5 - 4 + 1) / 2 * 5  -> (curValue + nextValue + 1) * (curValue - nextValue) / 2 * numSameColor\\n          1  1  1  1  1  1  1\\n          0  0  0  0  0  0  0\\n          \\n          need to handle the edge case that orders left is less than the number of items to buy\\n        */\\n        int mod = 1000000007;\\n        Arrays.sort(inventory);\\n        int curIndex = inventory.length - 1;\\n        int curValue = inventory[curIndex];\\n        long profit = 0;\\n        while (orders > 0) {\\n            while (curIndex >= 0 && inventory[curIndex] == curValue) {\\n                curIndex--;\\n            }\\n            // if all colors of balls are the same value, nextValue is 0\\n            int nextValue = curIndex < 0 ? 0 : inventory[curIndex];\\n            // number of colors of balls with same value \\n            int numSameColor = inventory.length - 1 - curIndex;\\n            // number of items to buy\\n            int nums = (curValue - nextValue) * numSameColor;\\n            if (orders >= nums) {\\n                // buy all items\\n                profit += (long)(curValue + nextValue + 1) * (curValue - nextValue) / 2 * numSameColor;\\n            } else {\\n\\t\\t\\t    // orders left is less than the number of items to buy\\n                int numFullRow = orders / numSameColor;\\n                int remainder = orders % numSameColor;\\n                profit += (long)(curValue + curValue - numFullRow + 1) * numFullRow / 2 * numSameColor;\\n                profit += (long)(curValue - numFullRow) * remainder;\\n            }\\n            orders -= nums;\\n            profit = profit % mod;\\n            curValue = nextValue;\\n        }\\n        return (int)profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927716,
                "title": "c-o-n-log-n",
                "content": "We should sell most expensive balls first. The trick here is to how to do it efficiently. If our inventory is 10 and 5, we can sell 5 balls of the first color for `10 * 11 / 2 - 5 * 6 / 2 = 40` profit. \\n\\nThen, we sell 2 balls for 5 (we now have two colors with the same count), 2 balls for 4, and so on. So the profit would be 2 * (5 * (5 + 1)) / 2 = 30.\\n\\nEasy enough, but the number of orders could fall short. Thus, we check how many full rounds can we take (`orders / colors`), and take no more than this number of rounds of the most expensive balls. Note that we may need to do one more - partial - round.\\n\\n**C++**\\n```cpp\\nint maxProfit(vector<int>& inv, int orders) {\\n    long res = 0, colors = 1;\\n    sort(begin(inv), end(inv));\\n    for (int i = inv.size() - 1; i >= 0 && orders > 0; --i, ++colors) {\\n        long cur = inv[i], prev = i > 0 ? inv[i - 1] : 0;\\n        long rounds = min(orders / colors, cur - prev);\\n        orders -= rounds * colors;\\n        res = (res + (cur * (cur + 1) - (cur - rounds) * (cur - rounds + 1)) / 2 * colors) % 1000000007;\\n        if (cur - prev > rounds) {\\n            res = (res + orders * (cur - rounds)) % 1000000007;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxProfit(vector<int>& inv, int orders) {\\n    long res = 0, colors = 1;\\n    sort(begin(inv), end(inv));\\n    for (int i = inv.size() - 1; i >= 0 && orders > 0; --i, ++colors) {\\n        long cur = inv[i], prev = i > 0 ? inv[i - 1] : 0;\\n        long rounds = min(orders / colors, cur - prev);\\n        orders -= rounds * colors;\\n        res = (res + (cur * (cur + 1) - (cur - rounds) * (cur - rounds + 1)) / 2 * colors) % 1000000007;\\n        if (cur - prev > rounds) {\\n            res = (res + orders * (cur - rounds)) % 1000000007;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927674,
                "title": "python3-greedy",
                "content": "Algo \\nFirst, it should be clear that we want to sell from the most abundant balls as much as possible as it is valued more than less abundant balls. In the spirit of this, we propose the below algo \\n1) sort inventory in reverse order and append 0 at the end (for termination); \\n2) scan through the inventory, and add the difference between adjacent categories to answer. \\n\\nAssume `inventory = [2,8,4,10,6]`. Then, we traverse inventory following 10->8->6->4->2->0. The evolution of inventory becomes \\n```\\n10 | 8 | 6 | 4 | 2\\n 8 | 8 | 6 | 4 | 2\\n 6 | 6 | 6 | 4 | 2\\n 4 | 4 | 4 | 4 | 2\\n 2 | 2 | 2 | 2 | 2 \\n 0 | 0 | 0 | 0 | 0 \\n```\\nOf course, if in any step, we have enough order, return the answer. \\n\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True) # inventory high to low \\n        inventory += [0]\\n        ans = 0\\n        k = 1\\n        for i in range(len(inventory)-1): \\n            if inventory[i] > inventory[i+1]: \\n                if k*(inventory[i] - inventory[i+1]) < orders: \\n                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum \\n                    orders -= k*(inventory[i] - inventory[i+1])\\n                else: \\n                    q, r = divmod(orders, k)\\n                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)\\n                    return ans % 1_000_000_007\\n            k += 1\\n```\\n\\nEdited on 10/08/2020\\nAdding binary serach solution \\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        fn = lambda x: sum(max(0, xx - x) for xx in inventory) # balls sold \\n    \\n        # last true binary search \\n        lo, hi = 0, 10**9\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid) >= orders: lo = mid\\n            else: hi = mid - 1\\n        \\n        ans = sum((x + lo + 1)*(x - lo)//2 for x in inventory if x > lo)\\n        return (ans - (fn(lo) - orders) * (lo + 1)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n10 | 8 | 6 | 4 | 2\\n 8 | 8 | 6 | 4 | 2\\n 6 | 6 | 6 | 4 | 2\\n 4 | 4 | 4 | 4 | 2\\n 2 | 2 | 2 | 2 | 2 \\n 0 | 0 | 0 | 0 | 0 \\n```\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True) # inventory high to low \\n        inventory += [0]\\n        ans = 0\\n        k = 1\\n        for i in range(len(inventory)-1): \\n            if inventory[i] > inventory[i+1]: \\n                if k*(inventory[i] - inventory[i+1]) < orders: \\n                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum \\n                    orders -= k*(inventory[i] - inventory[i+1])\\n                else: \\n                    q, r = divmod(orders, k)\\n                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)\\n                    return ans % 1_000_000_007\\n            k += 1\\n```\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        fn = lambda x: sum(max(0, xx - x) for xx in inventory) # balls sold \\n    \\n        # last true binary search \\n        lo, hi = 0, 10**9\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid) >= orders: lo = mid\\n            else: hi = mid - 1\\n        \\n        ans = sum((x + lo + 1)*(x - lo)//2 for x in inventory if x > lo)\\n        return (ans - (fn(lo) - orders) * (lo + 1)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929004,
                "title": "python-o-nlogn-without-confusing-arithmetic",
                "content": "To preface, this answer was heavily inspired by this post https://leetcode.com/problems/sell-diminishing-valued-colored-balls/discuss/927674/Python3-Greedy  \\nCheck out that post if you want an explanation for what\\'s going on.\\n\\n\\nI thought it was more intuitive to create a sumRange helper function to compute the profit.\\nThis function is essentially a modification of the gaussian sum equation. \\nEx. sumRange(3, 6) -> 3 + 4 + 5 + 6 = 18\\n\\n```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        profit = 0\\n        width = 1\\n        for i in range(len(inventory)-1):\\n            if inventory[i] > inventory[i+1]:\\n                if width * (inventory[i] - inventory[i+1]) < orders:\\n                    profit += width * self.sumRange(inventory[i+1]+1, inventory[i])\\n                    orders -= width * (inventory[i] - inventory[i+1])\\n                else:\\n                    whole, remaining = divmod(orders, width)\\n                    profit += width * self.sumRange(inventory[i]-whole+1, inventory[i])\\n                    profit += remaining * (inventory[i]-whole)\\n                    break\\n            width += 1\\n        return profit % (10**9 + 7)\\n                    \\n        \\ndef sumRange(self, lo, hi):\\n\\t# inclusive lo and hi\\n\\treturn (hi * (hi+1)) // 2 - (lo * (lo-1)) // 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        profit = 0\\n        width = 1\\n        for i in range(len(inventory)-1):\\n            if inventory[i] > inventory[i+1]:\\n                if width * (inventory[i] - inventory[i+1]) < orders:\\n                    profit += width * self.sumRange(inventory[i+1]+1, inventory[i])\\n                    orders -= width * (inventory[i] - inventory[i+1])\\n                else:\\n                    whole, remaining = divmod(orders, width)\\n                    profit += width * self.sumRange(inventory[i]-whole+1, inventory[i])\\n                    profit += remaining * (inventory[i]-whole)\\n                    break\\n            width += 1\\n        return profit % (10**9 + 7)\\n                    \\n        \\ndef sumRange(self, lo, hi):\\n\\t# inclusive lo and hi\\n\\treturn (hi * (hi+1)) // 2 - (lo * (lo-1)) // 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927720,
                "title": "java-priorityqueue-math",
                "content": "Unpleasant question, it\\'s easy to come up with Greedy solution, but the math is hard part as all test cases are big number.\\n```\\nclass Solution {\\n    // Hard point 1: Must calculate the sum like n *(n + 1) / 2, rather than i++, given number is big\\n    // Hard ponit 2: Big number and always use long and cast!!\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = 1000000007;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int num : inventory) {\\n            pq.offer(num);\\n        }\\n        \\n        int cur = pq.poll();\\n        int count = 1; // When pq poll the next element, +1 to count.\\n        long res = 0;\\n        while (orders > 0) {\\n            int next = pq.isEmpty() ? 0 : pq.peek();\\n            // If the number for [next + 1, cur] less than orders, add them ALL.\\n            if ((cur - next) * count <= orders) {\\n                // Add all the sum, and don\\'t forget cast!\\n                long num =  (1L * (next + 1 + cur) * (cur - next) * count / 2) % mod;\\n                res = (res + num) % mod;\\n                orders -= (cur - next) * count;\\n                \\n            } else {\\n                // If the number for [next + 1, cur] greater than orders, only add partially.\\n                // Calculate the new next where the add stops.\\n                next = cur - orders / count;\\n                long num =  (1L * (next + 1 + cur) * (cur - next) * count / 2) % mod;\\n                res = (res + num) % mod;\\n                // For the last number to add (new next), and don\\'t forget cast! I forget here in contest!\\n                res = (res + 1L * next * (orders % count)) % mod;\\n                orders = 0;\\n            }\\n            \\n            if (!pq.isEmpty()) cur = pq.poll();\\n            count++;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Hard point 1: Must calculate the sum like n *(n + 1) / 2, rather than i++, given number is big\\n    // Hard ponit 2: Big number and always use long and cast!!\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = 1000000007;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int num : inventory) {\\n            pq.offer(num);\\n        }\\n        \\n        int cur = pq.poll();\\n        int count = 1; // When pq poll the next element, +1 to count.\\n        long res = 0;\\n        while (orders > 0) {\\n            int next = pq.isEmpty() ? 0 : pq.peek();\\n            // If the number for [next + 1, cur] less than orders, add them ALL.\\n            if ((cur - next) * count <= orders) {\\n                // Add all the sum, and don\\'t forget cast!\\n                long num =  (1L * (next + 1 + cur) * (cur - next) * count / 2) % mod;\\n                res = (res + num) % mod;\\n                orders -= (cur - next) * count;\\n                \\n            } else {\\n                // If the number for [next + 1, cur] greater than orders, only add partially.\\n                // Calculate the new next where the add stops.\\n                next = cur - orders / count;\\n                long num =  (1L * (next + 1 + cur) * (cur - next) * count / 2) % mod;\\n                res = (res + num) % mod;\\n                // For the last number to add (new next), and don\\'t forget cast! I forget here in contest!\\n                res = (res + 1L * next * (orders % count)) % mod;\\n                orders = 0;\\n            }\\n            \\n            if (!pq.isEmpty()) cur = pq.poll();\\n            count++;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928851,
                "title": "javascript-drawing-detailed-explanation-examples",
                "content": "Ok boyos we re going to build this as we go. It\\'s easy so **don\\'t panic**\\nFirst, let\\'s do some Maths tho to get that out of the way. Consider we want to calculate the sum of elements of a given interval (a,b]. Let\\'s denote it with **rangeSum(a,b)** . \\nIt\\'s trivial to notice that **rangeSum(a,b)=rangeSum(0,b)-rangeSum(0,a)**. Thankfully, there is a known mathematical formula for any  rangeSum(0,k) though.\\n\\t![image](https://assets.leetcode.com/users/images/89d568e8-d8ad-4ef9-8342-a725f55e0450_1604881920.1339781.png)   =**rangeSum(0,n)**\\n\\tSo we can now calculate any given rangeSum(a,b) through 2 of those formulas.\\n\\nOk, the maths part is gone, it\\'s all logic from now on. Now let\\'s look at the problem through an example\\n\\t\\t\\t\\t\\tBalls=[  4, 2, 6 ,12, 6, 8]  Orders=K=20\\nIt\\'s easy to realise that the first choices are always going to be the best ones, as I want to maximize my value. So let\\'s just sort the array to begin with. \\n\\t\\tBalls=[ 2, 4, 6, 6, 8, 12]  Orders=K=20\\nNow I know, that on every iteration of my algorithm, I want to pick the BEST choices, which are (for now) in the end of my array.\\nIF K was 4 instead here are the best picks and the array after each of those picks.\\n\\t\\t**Balls**=[ 2, 4, 6, 6, 8, 12]  K=**4**\\n\\t\\t**Balls**=[ 2, 4, 6, 6, 8, 11]  K=**3** result=12\\n\\t\\t**Balls**=[ 2, 4, 6, 6, 8, 10]  K=**2** result=12+11\\n\\t\\t**Balls**=[ 2, 4, 6, 6, 8, 9]   K=**1**  result=12+11+10\\n\\t\\t**Balls**=[ 2, 4, 6, 6, 8, 8]   K=**0**  result=12+11+10+9\\nThis approach is OK, and would theoretically work if it wasnt for the next 2 issues: \\n1.  If K was 5, I would also have to pick the last 8, so my array would become [ 2, 4, 6, 6, 8, 7] which doesnt have the best choice in the end anymore. \\n2.  It\\'s slow given a large K/ large numbers of Balloons ant will TLE even through the use of a heap to keep the items sorted.\\n\\nThe most important observation that one can make here is that the previous example **can be calculated in O(1)**  through our aforementioned formula. Notice how the result=9+10+11+12= **rangeSum(8,12)**=** rangeSum(Balls[n-1],Balls[n-1]-k)** . However 2 cases arise \\n1.  What if k> 12-8? **(aka the best and the second best item\\'s difference)**\\n2.  What if k< 12-8?\\n\\nRegarding the first case, I would have to use more orders to cover the remaining K. In our previous example, if K=6, the last 2 choices will have to be the remaining 2 8s, making my array\\n\\tBalls=[ 2, 4, 6, 6, **7, 7**] , result=**rangeSum(8,12)**+8+8\\nIf K=8, I would have to use the 7s too!\\n\\tBalls=[ 2, 4, **6, 6, 6, 6**] , result=**rangeSum(8,12)**+**8+7+ 8+7** =**rangeSum(8,12)**+**2\\\\*rangeSum(6,8)**\\nif (K=16) I would have to use all 6s, and all 5\\'s\\n\\tBalls=[ 2, **4, 4, 4, 4, 4**] , result=**rangeSum(8,12)**+**2\\\\*rangeSum(6,8)** +**4\\\\*rangeSum(4,6)**\\n\\n**Original Balls**=[ 2, 4, 6, 6, 8, 12]  \\nSo let\\'s just look at the bigger picture now.  Starting from the last item, we re making some orders, relatively to its previous element. From 8-12 we made  a total of 4 orders, but from 6-12 we made  4+**2\\\\*2**=8 orders. Finally from 4 to 12 we made a total of 4+4+**4\\\\*2**=16 orders. It\\'s easy to notice that from an index i one has in total \\n\\t**(n-i)*(A[i+1]-A[i])** **available orders** .if A[i]==A[i+1]==...==A[n-1]\\n* If we consider all the A[i]\\'s (for example all 6\\'s) a **level** then A[i+1]-A[i] gives us the **NUMBER OF LEVELS**\\n*  **(n-i) is the total number of different colored balloons that we use (aka the columns)**\\n\\nso if my array was [3,5,5,5,5]\\nthen at index 1 my total available choices would be (5-1)\\\\*(5-3)\\nThat would be 2 levels of 4 orders each, so 8 orders in total\\nThe first level would trivially be **5,5,5,5**\\n\\t\\tand the second would be **4,4,4,4**\\nNotice that after I used all of my available orders for that item, the array becomes [3,3,3,3,3], so If i still have some orders to go I can go to the left of my index and consider the next \"best available choices\" ,so my new i=0.\\n**But wait!, there\\'s more**\\nSo If my array was [3,3,3,3,3], what\\'s  the total number of my available orders now? Well as we ve said it\\'s **(A[i]-A[i-1]) \\\\* (n-1)**, but i=0. \\nSo that\\'s a problem cos there\\'s no A[-1]. **Well  doesn\\'t it make total sense to prepend a 0 for that reason?**. I mean I do have 3 available layers of 5 items, which is trivially (3-0)\\\\*(5-0)=**(A[i]-A[i-1]) \\\\* (n-1)** if my array was [**0**, 3,3,3,3,3] instead. So that\\'s why from now on we ll always have a 0 as a sentinel element at the beginning. \\n\\nLet\\'s answer our last question now, which is what happens when I\\'m at an index, and I dont have enough orders left for all of the available orders. Demonstrating,\\n\\t\\t\\tBalls=[0,3,3,3] K=7\\nIn this case I ll have to take some of the levels instead. **But how many of those full levels can I take?**\\nA level consists of 3 elements now doesnt it? So I can take 2 full levels, namely \\n3,3,3 and 2,2,2 . Then I would have 1 order left to make. \\n**Math.floor(K/(n-i))**=Math.floor(7/3)=2 is the formula to calculate the number of **FULL LEVELS** that I can take.\\nOhh, and knowing how many levels to take can also help me to calculate the total value added to the result\\nresult+= levels\\\\*rangeSum(0,3)\\nK=K-6=1\\nThe remaining order is to be taken from  [0,1,1,1] and is trivially going to be one of those ones\\nso result+= K*(A[i])\\nHere follows an example for\\n Balls=[ 0, 2, 4, 6, 6, 8, 12 ], K=20\\n\\n![image](https://assets.leetcode.com/users/images/730df4db-0a3e-45f9-95bc-c019e3453149_1604886630.6030862.png)\\n\\n\\t\\t\\n```\\nvar maxProfit = function(A, k) {\\n    //rangeSum Formula\\n    let rangesum=(i,j)=>{\\n        i=BigInt(i),j=BigInt(j)\\n        return ((j*((j+1n))/2n)-(i*(i+1n)/2n))\\n    }\\n    A.unshift(0) //prepend the sentinel 0 \\n    A.sort((a,b)=>a-b)\\n    let n=A.length,result=0n,mod=BigInt(1e9+7),i=n-1\\n    // can use all current levels\\n    while((k>=(n-i)*(A[i]-A[i-1]))&&i>0){\\n        if(A[i]!=A[i-1])\\n            result=(result+(rangesum(A[i-1],A[i])*BigInt(n-i)))%mod,\\n            k-=(n-i)*(A[i]-A[i-1])\\n        i--\\n    }\\n    //can use some of the current levels\\n    if(k>0&&k>=n-i){\\n        let levels=Math.floor(k/(n-i)) //the levels i can use \\n        result=(result+(BigInt(n-i)*rangesum(A[i]-levels,A[i])))%mod\\n        k-=levels*(n-i)\\n        A[i]-=levels\\n    }\\n    // can use some of the items OF the first level\\n    if(k>0&&k<n-i)\\n        result=(result+BigInt(k)*BigInt(A[i]))%mod\\n    return Number(result)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar maxProfit = function(A, k) {\\n    //rangeSum Formula\\n    let rangesum=(i,j)=>{\\n        i=BigInt(i),j=BigInt(j)\\n        return ((j*((j+1n))/2n)-(i*(i+1n)/2n))\\n    }\\n    A.unshift(0) //prepend the sentinel 0 \\n    A.sort((a,b)=>a-b)\\n    let n=A.length,result=0n,mod=BigInt(1e9+7),i=n-1\\n    // can use all current levels\\n    while((k>=(n-i)*(A[i]-A[i-1]))&&i>0){\\n        if(A[i]!=A[i-1])\\n            result=(result+(rangesum(A[i-1],A[i])*BigInt(n-i)))%mod,\\n            k-=(n-i)*(A[i]-A[i-1])\\n        i--\\n    }\\n    //can use some of the current levels\\n    if(k>0&&k>=n-i){\\n        let levels=Math.floor(k/(n-i)) //the levels i can use \\n        result=(result+(BigInt(n-i)*rangesum(A[i]-levels,A[i])))%mod\\n        k-=levels*(n-i)\\n        A[i]-=levels\\n    }\\n    // can use some of the items OF the first level\\n    if(k>0&&k<n-i)\\n        result=(result+BigInt(k)*BigInt(A[i]))%mod\\n    return Number(result)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434560,
                "title": "c-o-nlogn-greedy-solution-with-explanation",
                "content": "The main idea is that we should always pick the largest number for each order. We could simulate the entire process using a maxheap but that would take O(k\\\\*logn) time, and will thus give a TLE. \\n\\nWhenever we have to pick a ball, it should be taken from the inventory with highest value. So we try to take as many orders as we can from the inventory(s) having the current highest number until the value becomes equal to the next second largest inventory, and thus a new inventory is added to our set from which we pick balls.\\n\\nFormulas:\\n\\n`1 + 2 + ... + n = n * (n+1) / 2`\\n`k + (k+1) + ... + n = [n * (n+1) / 2] - [(k-1) * k / 2]`\\n\\n\\n```\\n#define ll long long\\nconst int MOD = 1e9+7; \\n\\nclass Solution {\\npublic:\\n    \\n    ll summation(ll n) {\\n        return (n*(n+1)/2);\\n    }\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        ll n = inventory.size(), i = 0, ans = 0;\\n        inventory.push_back(0);\\n        sort(inventory.rbegin(), inventory.rend());\\n        while(orders and i < n) {\\n            if(inventory[i] != inventory[i+1]) {\\n                ll width = i+1, h = inventory[i] - inventory[i+1];\\n                ll available = width * h, gain = 0;\\n                if(available <= orders) {\\n                    orders -= available;\\n\\t\\t\\t\\t\\t// from each of the first i+1 inventories, we gain (inventory[i+1] + 1) + ... + inventory[i] value\\n                    gain = (width * (summation(inventory[i]) - summation(inventory[i+1]))) % MOD; \\n                } else {\\n                    ll q = orders / width, r = orders % width;\\n\\t\\t\\t\\t\\t// q balls picked from each of the first i+1 inventories\\n                    gain = (width * (summation(inventory[i]) - summation(inventory[i]-q))) % MOD;\\n\\t\\t\\t\\t\\t// 1 ball picked from r inventories providing value (inventory[i]-q)\\n                    gain = (gain + r*(inventory[i]-q)) % MOD;\\n                    orders = 0;\\n                }\\n                \\n                ans = (ans + gain) % MOD; \\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\nconst int MOD = 1e9+7; \\n\\nclass Solution {\\npublic:\\n    \\n    ll summation(ll n) {\\n        return (n*(n+1)/2);\\n    }\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        ll n = inventory.size(), i = 0, ans = 0;\\n        inventory.push_back(0);\\n        sort(inventory.rbegin(), inventory.rend());\\n        while(orders and i < n) {\\n            if(inventory[i] != inventory[i+1]) {\\n                ll width = i+1, h = inventory[i] - inventory[i+1];\\n                ll available = width * h, gain = 0;\\n                if(available <= orders) {\\n                    orders -= available;\\n\\t\\t\\t\\t\\t// from each of the first i+1 inventories, we gain (inventory[i+1] + 1) + ... + inventory[i] value\\n                    gain = (width * (summation(inventory[i]) - summation(inventory[i+1]))) % MOD; \\n                } else {\\n                    ll q = orders / width, r = orders % width;\\n\\t\\t\\t\\t\\t// q balls picked from each of the first i+1 inventories\\n                    gain = (width * (summation(inventory[i]) - summation(inventory[i]-q))) % MOD;\\n\\t\\t\\t\\t\\t// 1 ball picked from r inventories providing value (inventory[i]-q)\\n                    gain = (gain + r*(inventory[i]-q)) % MOD;\\n                    orders = 0;\\n                }\\n                \\n                ans = (ans + gain) % MOD; \\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927517,
                "title": "clean-python-3-binary-search-o-nlogm",
                "content": "Find the boundary of orders by using binary search.\\nThen calculate values for each inventory and the outbounded values.\\n\\nFor example, for `inventory = [4, 2, 7, 5]` and `orders = 8`, after the binary search we will found the boundary of orders is on 4.\\n\\n1, 2, [3, 4\\n1, 2\\n1, 2, 3, [4, 5, 6, 7\\n1, 2, 3, [4, 5\\n\\nthen just calculate values for each inventory and add one more `3` which is out ouf bound.\\n\\nTime: `O(NlogM)`, where `N` is the length of `inventory` and `M` is the largest number in `inventory`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        left, right, mod = 0, max(inventory), 10 ** 9 + 7\\n        counts = lambda i: sum(count - i + 1 for count in inventory if count >= i)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if counts(mid) > orders:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        result = sum((count + left) * (count - left + 1) // 2 for count in inventory if count >= left) % mod\\n        return (result + outbound * (left - 1) if (outbound := orders - counts(left)) > 0 else result) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        left, right, mod = 0, max(inventory), 10 ** 9 + 7\\n        counts = lambda i: sum(count - i + 1 for count in inventory if count >= i)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if counts(mid) > orders:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        result = sum((count + left) * (count - left + 1) // 2 for count in inventory if count >= left) % mod\\n        return (result + outbound * (left - 1) if (outbound := orders - counts(left)) > 0 else result) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201722,
                "title": "binary-search",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory, orders: int) -> int:\\n        left = 0\\n        right = max(inventory)\\n        while right - left > 1:\\n            middle = (left + right) // 2\\n            sold_balls = sum(i - middle for i in inventory if i > middle)\\n            if sold_balls > orders:\\n                left = middle\\n            else:\\n                right = middle\\n        sold_balls = 0\\n        total_value = 0\\n        for i in inventory:\\n            if i > right:\\n                sold_balls += i - right\\n                total_value += (i + right + 1) * (i - right) // 2\\n        if sold_balls < orders:\\n            total_value += (orders - sold_balls) * right\\n        return total_value % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory, orders: int) -> int:\\n        left = 0\\n        right = max(inventory)\\n        while right - left > 1:\\n            middle = (left + right) // 2\\n            sold_balls = sum(i - middle for i in inventory if i > middle)\\n            if sold_balls > orders:\\n                left = middle\\n            else:\\n                right = middle\\n        sold_balls = 0\\n        total_value = 0\\n        for i in inventory:\\n            if i > right:\\n                sold_balls += i - right\\n                total_value += (i + right + 1) * (i - right) // 2\\n        if sold_balls < orders:\\n            total_value += (orders - sold_balls) * right\\n        return total_value % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927506,
                "title": "c-binary-search",
                "content": "\\tThe idea is we first want to find a target value T which is the smallest value we will add to our score within a transaction. \\n\\tSince the trend is monotonic, we can use Binary Search to find the value T. \\n\\tWe simply guess a value to see \\n\\thow many orders we can make with the value. If the result is less the \\n\\tvalue orders we are given, then we know the value we guessed is too high that cannot be the target value (that\\'s why set hi=mid-1). \\n\\tWhen we know the target value T, we need to notice that \\n\\twe are not necessarily buying all those balls with target value,\\n\\tbut it is guaranteed that we need to buy all the balls with value greater than \\n\\ttarget value T(that\\'s why we set low = low+1). \\n\\tAfter that, we ran out of the balls with value greater than target value, \\n\\tnow, we can only add balls with target value for (orders we left) times.\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong check(vector<int>& inventory, int target) {// count how many orders with buying balls with value at least target\\n\\t\\t\\tlong sum = 0;\\n\\t\\t\\tfor(auto& x:inventory) {\\n\\t\\t\\t\\tif(x >= target) {\\n\\t\\t\\t\\t\\tsum += x - target + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\tint maxProfit(vector<int>& inventory, int orders) {\\n\\t\\t\\tlong low = 1;\\n\\t\\t\\tlong hi = INT_MAX;\\n\\t\\t\\tint kMod = 1e9 + 7;\\n\\t\\t\\twhile(low < hi) {\\n\\t\\t\\t\\tlong mid = low + (hi - low+1) /2;\\n\\t\\t\\t\\tlong res = check(inventory, mid);\\n\\t\\t\\t\\tif(res < orders) {\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlow = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tlow = low + 1; // buy all balls with this value and above\\n\\t\\t\\tfor(auto& x:inventory) {\\n\\t\\t\\t\\tif(x >= low ) {\\n\\t\\t\\t\\t\\tans += (low + x)*(x-low + 1)/2;\\n\\t\\t\\t\\t\\tans = ans%kMod;\\n\\t\\t\\t\\t\\torders -= x-low+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlow = low - 1;\\n\\t\\t\\tfor(int i=0;i<orders;i++) {\\n\\t\\t\\t\\tans += low;\\n\\t\\t\\t\\tans = ans%kMod;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong check(vector<int>& inventory, int target) {// count how many orders with buying balls with value at least target\\n\\t\\t\\tlong sum = 0;\\n\\t\\t\\tfor(auto& x:inventory) {\\n\\t\\t\\t\\tif(x >= target) {\\n\\t\\t\\t\\t\\tsum += x - target + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 928877,
                "title": "python-clear-greedy-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/7_QGT_LcbIQ\\n\\n\\nIntuition: Greedy/Math\\nKey equation: Arithmetic series sum:\\nn+(n-1)+\\u2026+(n-d)=(n+(n-d))x(d+1)/2\\n\\n**Code**\\nInspired by https://leetcode.com/problems/sell-diminishing-valued-colored-balls/discuss/927674/Python3-Greedy\\n\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True) \\n        inventory += [0]\\n        res = 0\\n        k = 1\\n        \\n        for i in range(len(inventory)-1): \\n            if inventory[i] > inventory[i+1]: \\n                if k*(inventory[i]-inventory[i+1]) < orders:\\n                    diff = inventory[i]-inventory[i+1]\\n                    res += k*(inventory[i]+inventory[i+1]+1)*(diff)//2\\n                    orders -= k*diff\\n                else: \\n                    q, r = divmod(orders, k)\\n                    res += k*(inventory[i]+(inventory[i]-q+1))*q//2\\n                    res += r*(inventory[i]-q)\\n                    return res%(10**9+7)\\n            k += 1\\n```\\n\\n\\nTime: O(nlogn)\\nSpace: O(1)\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True) \\n        inventory += [0]\\n        res = 0\\n        k = 1\\n        \\n        for i in range(len(inventory)-1): \\n            if inventory[i] > inventory[i+1]: \\n                if k*(inventory[i]-inventory[i+1]) < orders:\\n                    diff = inventory[i]-inventory[i+1]\\n                    res += k*(inventory[i]+inventory[i+1]+1)*(diff)//2\\n                    orders -= k*diff\\n                else: \\n                    q, r = divmod(orders, k)\\n                    res += k*(inventory[i]+(inventory[i]-q+1))*q//2\\n                    res += r*(inventory[i]-q)\\n                    return res%(10**9+7)\\n            k += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625711,
                "title": "lessons-learned",
                "content": "I would prefer the TLE Heap approach for interview as working solution. Then would discuss the binary search approach, but might not implement it.\\n\\n**Code**:\\n```\\n// HARD: Binary search on threshold ball count above which the orders balls are picked and profitted. \\n// There are 3 aspects: threshold ball count, fulfilling all orders, max profit\\n// Requires a Maths formula: sum of numbers from a to b\\nclass Solution {\\n     public int maxProfit(int[] inventory, int orders) {\\n        int max = 0;\\n        for (int in : inventory) {\\n            max = Math.max(max, in);\\n        }\\n        int lo = 0, hi = max;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (getBallCnt(inventory, mid, orders) > orders) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        int remainMax = lo;\\n        long res = 0L;\\n        for (int cnt : inventory) {\\n            if (cnt <= remainMax) continue;\\n            res += (long) (cnt + remainMax + 1) * (long) (cnt - remainMax) / 2;\\n            orders -= cnt - remainMax;\\n        }\\n        res += (long) remainMax * (long) orders;\\n\\n        return (int) (res % 1000000007);\\n    }\\n\\n    private int getBallCnt(int[] inventory, int remainMax, int total) {\\n        int res = 0;\\n        for (int cnt : inventory) {\\n            if (cnt <= remainMax) continue;\\n            res += (cnt - remainMax);\\n            if (res > total) break;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Code**:\\n```\\n// TLE: Heap\\n// Time: O(orders * log(inventoryLength)) | Given the constraint \\'orders <= min(sum(inventory[i]), 10^9)\\', this time is bad since it is dependent on huge \\'orders\\'\\n// Space: O(log(inventoryLength))\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> inventory[b] - inventory[a]);\\n        for (int i = 0; i < inventory.length; ++i) {\\n            pq.add(i);\\n        }\\n        \\n        int profit = 0;\\n        while (orders-- > 0) {\\n            int removedIndex = pq.remove();\\n            profit += inventory[removedIndex];\\n            --inventory[removedIndex];\\n            pq.add(removedIndex);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// HARD: Binary search on threshold ball count above which the orders balls are picked and profitted. \\n// There are 3 aspects: threshold ball count, fulfilling all orders, max profit\\n// Requires a Maths formula: sum of numbers from a to b\\nclass Solution {\\n     public int maxProfit(int[] inventory, int orders) {\\n        int max = 0;\\n        for (int in : inventory) {\\n            max = Math.max(max, in);\\n        }\\n        int lo = 0, hi = max;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (getBallCnt(inventory, mid, orders) > orders) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        int remainMax = lo;\\n        long res = 0L;\\n        for (int cnt : inventory) {\\n            if (cnt <= remainMax) continue;\\n            res += (long) (cnt + remainMax + 1) * (long) (cnt - remainMax) / 2;\\n            orders -= cnt - remainMax;\\n        }\\n        res += (long) remainMax * (long) orders;\\n\\n        return (int) (res % 1000000007);\\n    }\\n\\n    private int getBallCnt(int[] inventory, int remainMax, int total) {\\n        int res = 0;\\n        for (int cnt : inventory) {\\n            if (cnt <= remainMax) continue;\\n            res += (cnt - remainMax);\\n            if (res > total) break;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n// TLE: Heap\\n// Time: O(orders * log(inventoryLength)) | Given the constraint \\'orders <= min(sum(inventory[i]), 10^9)\\', this time is bad since it is dependent on huge \\'orders\\'\\n// Space: O(log(inventoryLength))\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> inventory[b] - inventory[a]);\\n        for (int i = 0; i < inventory.length; ++i) {\\n            pq.add(i);\\n        }\\n        \\n        int profit = 0;\\n        while (orders-- > 0) {\\n            int removedIndex = pq.remove();\\n            profit += inventory[removedIndex];\\n            --inventory[removedIndex];\\n            pq.add(removedIndex);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557501,
                "title": "python-explained-with-diagram",
                "content": "We solve this problem using a heap and a Counter (or a hashmap, if you like). The max heap picks the maximum element available and helps us calculate the differences between the maximum and the next possible maximum element. The counter just neatly keeps a track of the frequency of balls at its respective ball count. \\n\\n![image](https://assets.leetcode.com/users/images/ba73dd70-a141-4814-bae9-572101f18ced_1635950271.4066608.png)\\n\\nHere: \\n* `Height h` = Difference between current highest frequency and the next highest frequency. \\n* `Width w` = Count of balls having the given frequency (or above).\\n* `order` = Amount of balls ordered.\\n\\nConsidering pass #1:\\nThe `order` amount exceeds the `h * w` product, so we just deduct it from the order amount. Since `w` amount of balls are also present in the next highest frequency, we add `w` to the next highest frequency in the counter. \\n\\nConsidering pass#2 in both the cases:\\n* **Balls in currently considered group>order amount** - Case 1: Balls remaining in order = 5\\n\\t* `Width w` (count of balls at frequency) = 3; `Height h` (difference between current frequency and the next highest frequency) = 2. Does this exceed the remaining order amount? Yes. \\n\\t* Hence, we take `(h - k) * w` amount of balls, followed by a remainder amount `r`. Since the initial `h * w` exceeded the `order` amount, we can safely say that the `(h - k) * w + remainder` would cover the order amount, and we can break out of the loop. \\n\\t* What height of balls would we take? `h = order//w`, and the remainder `r = order%w`\\n\\t* We wouldn\\'t have to make any modifications to the heap or the counter after this condition.  \\n\\t\\n* **Balls in currently considered group<=order amount**Case 2: Balls remaining in order = 6:\\n\\t* This matches pass #1. We deduct `h * w` from the `order` amount.\\n\\n**Getting the amount**\\n* In a certain pass, we see that <code>(\\u03A3 (w * h<sub>i</sub>)) + (r * (h - k))</code> is added to the amount. \\n* <code>h<sub>i</sub></code> = <code>curV - i</code>, where <code>i</code> lies in the range <code>0 to h (h excluded)</code>and an amount `r * (curV - h)` is also added (the cost for the remaining balls).\\n\\nAdditionally, we\\'re considering a `[0]` in the heap, because it would help if ~all the items are considered. \\n\\nRuntime: 664ms (90.40%); \\nMemory: 32.8mb (16.73%)\\n\\n```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\n    ctr = collections.Counter(inventory)\\n    ls = sorted([-k for k in ctr.keys()] + [0])\\n\\n    maxEarn = 0\\n    ordersRemaining = True\\n    while orders and ls and ordersRemaining:\\n        curV = -heapq.heappop(ls)\\n        nxV = -ls[0]\\n        height = curV - nxV\\n        divM = 0\\n        width = ctr[curV]\\n        if (width * height) > orders:\\n            ordersRemaining = False\\n            height, divM = map(int, divmod(orders, width))\\n        maxEarn = (\\n            maxEarn\\n            + (width * ((height * curV) - ((height * (height - 1)) // 2)))\\n            + (divM * (curV - height))\\n        )\\n        maxEarn = int(maxEarn % ((10 ** 9) + 7))\\n        orders = orders - (height * width) - divM\\n        if ordersRemaining:\\n            del ctr[curV]\\n            ctr[nxV] = ctr[nxV] + width\\n            orders = orders - (width * height)\\n    return int(maxEarn % (1e9 + 7))\\n```\\n\\n(Typecasting, since there was an unknown conversion to float.)\\n\\nInitially, we were going down by 1 from the maxValue and not considering the previous max, which gave a TLE. \\n\\nAny additions or improvements are welcome. Happy coding. :)",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\n    ctr = collections.Counter(inventory)\\n    ls = sorted([-k for k in ctr.keys()] + [0])\\n\\n    maxEarn = 0\\n    ordersRemaining = True\\n    while orders and ls and ordersRemaining:\\n        curV = -heapq.heappop(ls)\\n        nxV = -ls[0]\\n        height = curV - nxV\\n        divM = 0\\n        width = ctr[curV]\\n        if (width * height) > orders:\\n            ordersRemaining = False\\n            height, divM = map(int, divmod(orders, width))\\n        maxEarn = (\\n            maxEarn\\n            + (width * ((height * curV) - ((height * (height - 1)) // 2)))\\n            + (divM * (curV - height))\\n        )\\n        maxEarn = int(maxEarn % ((10 ** 9) + 7))\\n        orders = orders - (height * width) - divM\\n        if ordersRemaining:\\n            del ctr[curV]\\n            ctr[nxV] = ctr[nxV] + width\\n            orders = orders - (width * height)\\n    return int(maxEarn % (1e9 + 7))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1227121,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/54d5cff6-e286-4718-842c-b68e89e987cd_1621833973.393343.png)\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] inventory, int orders) {\\n        \\n        // sort the colored balles by inventory in descending order\\n        Array.Sort(inventory, (a,b) => b-a);\\n        int idx = 0; \\n        long currPrice = inventory[0], nextPrice = 0, sell = 0, res = 0;\\n        \\n        while(orders > 0)\\n        {\\n            // count the number of colors that can be sold together\\n            while(idx < inventory.Length && inventory[idx] == currPrice)\\n                idx++;\\n            \\n            // next price when new colors can be sold together with current colors\\n            nextPrice = idx == inventory.Length? 0 : inventory[idx];\\n            \\n            // actual number of balls will be sold in this round\\n            sell = Math.Min(orders, idx * (currPrice - nextPrice));\\n            \\n            // profit when all the balls of a specific color can be sold in this round\\n            long priceDiff = currPrice - nextPrice;            \\n            int remainder = 0;\\n            \\n            // don\\'t need to sell all the saleable balls to satisfy orders\\n            if(orders < idx * (currPrice - nextPrice))\\n            {\\n                priceDiff = orders / idx;\\n                remainder = orders % idx;\\n                nextPrice = currPrice - priceDiff;\\n            }              \\n            \\n            res = (res + (currPrice + nextPrice + 1) * priceDiff / 2 * idx + nextPrice * remainder) % 1000000007;\\n            orders -= (int)sell;\\n            currPrice = nextPrice;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] inventory, int orders) {\\n        \\n        // sort the colored balles by inventory in descending order\\n        Array.Sort(inventory, (a,b) => b-a);\\n        int idx = 0; \\n        long currPrice = inventory[0], nextPrice = 0, sell = 0, res = 0;\\n        \\n        while(orders > 0)\\n        {\\n            // count the number of colors that can be sold together\\n            while(idx < inventory.Length && inventory[idx] == currPrice)\\n                idx++;\\n            \\n            // next price when new colors can be sold together with current colors\\n            nextPrice = idx == inventory.Length? 0 : inventory[idx];\\n            \\n            // actual number of balls will be sold in this round\\n            sell = Math.Min(orders, idx * (currPrice - nextPrice));\\n            \\n            // profit when all the balls of a specific color can be sold in this round\\n            long priceDiff = currPrice - nextPrice;            \\n            int remainder = 0;\\n            \\n            // don\\'t need to sell all the saleable balls to satisfy orders\\n            if(orders < idx * (currPrice - nextPrice))\\n            {\\n                priceDiff = orders / idx;\\n                remainder = orders % idx;\\n                nextPrice = currPrice - priceDiff;\\n            }              \\n            \\n            res = (res + (currPrice + nextPrice + 1) * priceDiff / 2 * idx + nextPrice * remainder) % 1000000007;\\n            orders -= (int)sell;\\n            currPrice = nextPrice;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927650,
                "title": "c-binarysearch",
                "content": "```\\n    public class Solution\\n    {\\n        public int MaxProfit(int[] inventory, int orders)\\n        {\\n            long low = 0;\\n            long high = inventory.Max();\\n            while (low < high)\\n            {\\n                long mid = low + (high - low) / 2;\\n                long sum = inventory.Sum(x => Math.Max(0, x - mid));\\n                if (sum <= orders)\\n                    high = mid;\\n                else\\n                    low = mid + 1;\\n            }\\n\\n            long mod = (long)Math.Pow(10, 9) + 7;\\n            long res = 0;\\n            foreach (int n in inventory)\\n            {\\n                if (n > low)\\n                {\\n                    res = (res + (low + 1 + n) * (n - low) / 2) % mod;\\n                    orders -= (int)(n - low);\\n                }\\n            }\\n\\n            res = (res + orders * low) % mod;\\n\\n            return (int)res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int MaxProfit(int[] inventory, int orders)\\n        {\\n            long low = 0;\\n            long high = inventory.Max();\\n            while (low < high)\\n            {\\n                long mid = low + (high - low) / 2;\\n                long sum = inventory.Sum(x => Math.Max(0, x - mid));\\n                if (sum <= orders)\\n                    high = mid;\\n                else\\n                    low = mid + 1;\\n            }\\n\\n            long mod = (long)Math.Pow(10, 9) + 7;\\n            long res = 0;\\n            foreach (int n in inventory)\\n            {\\n                if (n > low)\\n                {\\n                    res = (res + (low + 1 + n) * (n - low) / 2) % mod;\\n                    orders -= (int)(n - low);\\n                }\\n            }\\n\\n            res = (res + orders * low) % mod;\\n\\n            return (int)res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276934,
                "title": "c-binary-search-well-explained",
                "content": "**Time Complexity-- O(N*logK)**\\n**N--size of inventory**\\n**K--max quantity of a ball in inventory**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //determiing the maximum quantity a coloured ball can have in the inventory\\n    bool canBeSold(int maxQty,vector<int> &inv,int orders)\\n    {\\n        int n = inv.size();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            //determining balls to be sold to achieve maxQty balls\\n            int ballsToBeSold = max(0,inv[i]-maxQty);\\n            //updating orders\\n            orders-=ballsToBeSold;\\n            //if we need to sell more balls than orders,,then we can\\'t have a max of maxQty balls of a type in inventory\\n            if(orders<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    //calculating the profit we achieve\\n    /*\\n    formula:\\n    sum of n numbers = n*(n+1)/2\\n    sum of k numbers = k*(k+1)/2\\n    sum of n-k numbers = n*(n+1)/2 - k*(k+1)/2\\n    */\\n    int calcProfit(int low,vector<int> &inv,int orders)\\n    {\\n        int mod = 1e9+7;\\n        long long maxBallinInv = low;\\n        int ans=0;\\n        //future cost--cost for removing \\'low\\' no. of balls\\n        long long futureCost = (maxBallinInv*(maxBallinInv+1))/2;\\n        \\n        for(int i=0;i<inv.size();i++)\\n        {\\n            if(inv[i]<=maxBallinInv)\\n                continue;\\n            long long balls = inv[i];\\n            //present cost-- cost for rmeoving \\'inv[i]\\' no. of balls\\n            long long presentCost = (balls* (balls+1))/2;\\n            \\n            ans = (ans%mod + (int)((presentCost - futureCost)%mod))%mod;\\n            //updating orders\\n            orders -= (inv[i]-maxBallinInv);\\n        }\\n        //after achieving a maximum of \\'low\\' balls in the inventory we process the remaining orders\\n        ans = (ans%mod + (orders*maxBallinInv)%mod)%mod;\\n        return ans%mod;        \\n    }\\n    \\n    int maxProfit(vector<int>& inv, int orders) \\n    {\\n        sort(inv.begin(),inv.end());\\n        int low = 0,high = inv.back();\\n        \\n        //determing the max qty a coloured ball can have in the inventory\\n        while(low<high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(canBeSold(mid,inv,orders))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return calcProfit(low,inv,orders);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //determiing the maximum quantity a coloured ball can have in the inventory\\n    bool canBeSold(int maxQty,vector<int> &inv,int orders)\\n    {\\n        int n = inv.size();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            //determining balls to be sold to achieve maxQty balls\\n            int ballsToBeSold = max(0,inv[i]-maxQty);\\n            //updating orders\\n            orders-=ballsToBeSold;\\n            //if we need to sell more balls than orders,,then we can\\'t have a max of maxQty balls of a type in inventory\\n            if(orders<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    //calculating the profit we achieve\\n    /*\\n    formula:\\n    sum of n numbers = n*(n+1)/2\\n    sum of k numbers = k*(k+1)/2\\n    sum of n-k numbers = n*(n+1)/2 - k*(k+1)/2\\n    */\\n    int calcProfit(int low,vector<int> &inv,int orders)\\n    {\\n        int mod = 1e9+7;\\n        long long maxBallinInv = low;\\n        int ans=0;\\n        //future cost--cost for removing \\'low\\' no. of balls\\n        long long futureCost = (maxBallinInv*(maxBallinInv+1))/2;\\n        \\n        for(int i=0;i<inv.size();i++)\\n        {\\n            if(inv[i]<=maxBallinInv)\\n                continue;\\n            long long balls = inv[i];\\n            //present cost-- cost for rmeoving \\'inv[i]\\' no. of balls\\n            long long presentCost = (balls* (balls+1))/2;\\n            \\n            ans = (ans%mod + (int)((presentCost - futureCost)%mod))%mod;\\n            //updating orders\\n            orders -= (inv[i]-maxBallinInv);\\n        }\\n        //after achieving a maximum of \\'low\\' balls in the inventory we process the remaining orders\\n        ans = (ans%mod + (orders*maxBallinInv)%mod)%mod;\\n        return ans%mod;        \\n    }\\n    \\n    int maxProfit(vector<int>& inv, int orders) \\n    {\\n        sort(inv.begin(),inv.end());\\n        int low = 0,high = inv.back();\\n        \\n        //determing the max qty a coloured ball can have in the inventory\\n        while(low<high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(canBeSold(mid,inv,orders))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return calcProfit(low,inv,orders);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015875,
                "title": "java-3-approaches-with-time-complexity-analysis",
                "content": "There are 3 approaches for me to resolve this problem:\\n1. Priority Queue with `O(m log(n))` --> TLE\\n2. Sorting with `O(n log(n))` --> Accepted\\n3. Binary Search with `O(n log(max(A)))` --> Accepted\\n\\n##### 1. Priority Queue\\n\\nUse priority queue or max heap to pick the largest inventory every time.\\nAfter each pick, update the profit and count of inventory\\n\\nGiven `n` is length of inventory array, `m` is orders\\n**Time complexity**: `O(m log(n))` which causes TLE\\n\\n```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    int n = inventory.length;\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> {\\n        return inventory[b] - inventory[a];\\n    });\\n\\n    for (int i = 0; i < n; i++) {\\n        maxHeap.add(i);\\n    }\\n\\n    long profit = 0;\\n    while (orders-- > 0) {\\n        int idx = maxHeap.remove();\\n        profit = (profit + inventory[idx]) % mod;\\n        inventory[idx]--;\\n        maxHeap.add(idx);\\n    }\\n    return (int) profit;\\n}\\n```\\n\\n##### 2. Sorting\\n\\nInstead of use priority queue, sort the inventory and then calculate those with the same inventory at once.\\n\\n```\\n->[1,1,2,4,5], order=10, profit 0\\n->[1,1,2,4,4], order=9, profit += 5 * 1\\n->[1,1,2,2,2], order=5, profit += 4 * 2 * 2\\n->[1,1,1,1,0], order=0, profit += 2 * 3 + 1 * 1\\n```\\n\\nGiven `n` is length of inventory array\\n**Time complexity**: `O(n log(n))` \\n```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    int n = inventory.length, i = n - 1;\\n    long profit = 0;\\n\\n    Arrays.sort(inventory);\\n    int cur = inventory[n - 1];\\n\\n    while (orders > 0) {\\n        while (i >= 0 && cur == inventory[i]) i--;\\n        int count = n - i - 1;\\n        int next = i < 0 ? 0 : inventory[i];\\n        int total = (cur - next) * count;\\n        if (orders > total) {\\n            profit += area(cur, next + 1, count);\\n        } else {\\n            int h = orders / count, r = orders % count;\\n            profit += area(cur, cur - h + 1, count) + 1L * r * (cur - h);\\n        }\\n        orders -= total;\\n        profit %= mod;\\n        cur = next;\\n    }\\n    return (int) profit;\\n}\\n\\nlong area(int max, int min, int count) {\\n    return 1L * (max + min) * (max - min + 1) / 2 * count;\\n}\\n```\\n\\n##### 3. Binary Search\\n**Step 1**\\nFind the smallest `k` such that `sum(A[i] - k) < order` for all A[i] > k \\nUse binary search from the range `[0, max(A)]`\\n\\n**Step 2**\\nCalculate the sum of profit and update the order\\n\\nGiven `inventory[i] = x`, the profit sum is `(x + x - 1 + x - 2 + ... + k + 1)` \\n= `(x + k + 1) * (x - k) / 2`\\nDecrease the order by `x - k`\\n\\n**Step 3**\\n\\nIf the there are remain orders, add the remain profit with `orders * k`\\n\\nGiven `n` is length of inventory array, `m` is orders\\n**Time complexity**: `O(n log(max(A)))`\\n```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    long profit = 0;\\n    int k = smallestK(inventory, orders);\\n\\n    for (int inv : inventory) {\\n        if (inv > k) {\\n            profit = (profit + 1L * (inv + k + 1) * (inv - k) / 2) % mod;\\n            orders -= inv - k;\\n        }\\n    }\\n    return (int) ((profit + 1L * orders * k) % mod);\\n}\\n\\nint smallestK(int[] inventory, int target) {\\n    int max = Integer.MIN_VALUE;\\n    for (int inv : inventory) max = Math.max(max, inv);\\n\\n    int left = 0, right = max;\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (sum(inventory, mid) > target) left = mid + 1;\\n        else right = mid;\\n    }\\n    return left;\\n}\\n\\nlong sum(int[] inventory, int k) {\\n    long sum = 0;\\n    for (int i : inventory) {\\n        if (i > k) sum += i - k;\\n    }\\n    return sum;\\n}\\n```\\n\\nPlease let me know if that\\'s helpful, thanks!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    int n = inventory.length;\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> {\\n        return inventory[b] - inventory[a];\\n    });\\n\\n    for (int i = 0; i < n; i++) {\\n        maxHeap.add(i);\\n    }\\n\\n    long profit = 0;\\n    while (orders-- > 0) {\\n        int idx = maxHeap.remove();\\n        profit = (profit + inventory[idx]) % mod;\\n        inventory[idx]--;\\n        maxHeap.add(idx);\\n    }\\n    return (int) profit;\\n}\\n```\n```\\n->[1,1,2,4,5], order=10, profit 0\\n->[1,1,2,4,4], order=9, profit += 5 * 1\\n->[1,1,2,2,2], order=5, profit += 4 * 2 * 2\\n->[1,1,1,1,0], order=0, profit += 2 * 3 + 1 * 1\\n```\n```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    int n = inventory.length, i = n - 1;\\n    long profit = 0;\\n\\n    Arrays.sort(inventory);\\n    int cur = inventory[n - 1];\\n\\n    while (orders > 0) {\\n        while (i >= 0 && cur == inventory[i]) i--;\\n        int count = n - i - 1;\\n        int next = i < 0 ? 0 : inventory[i];\\n        int total = (cur - next) * count;\\n        if (orders > total) {\\n            profit += area(cur, next + 1, count);\\n        } else {\\n            int h = orders / count, r = orders % count;\\n            profit += area(cur, cur - h + 1, count) + 1L * r * (cur - h);\\n        }\\n        orders -= total;\\n        profit %= mod;\\n        cur = next;\\n    }\\n    return (int) profit;\\n}\\n\\nlong area(int max, int min, int count) {\\n    return 1L * (max + min) * (max - min + 1) / 2 * count;\\n}\\n```\n```java\\nint mod = (int) 1e9 + 7;\\npublic int maxProfit(int[] inventory, int orders) {\\n    long profit = 0;\\n    int k = smallestK(inventory, orders);\\n\\n    for (int inv : inventory) {\\n        if (inv > k) {\\n            profit = (profit + 1L * (inv + k + 1) * (inv - k) / 2) % mod;\\n            orders -= inv - k;\\n        }\\n    }\\n    return (int) ((profit + 1L * orders * k) % mod);\\n}\\n\\nint smallestK(int[] inventory, int target) {\\n    int max = Integer.MIN_VALUE;\\n    for (int inv : inventory) max = Math.max(max, inv);\\n\\n    int left = 0, right = max;\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (sum(inventory, mid) > target) left = mid + 1;\\n        else right = mid;\\n    }\\n    return left;\\n}\\n\\nlong sum(int[] inventory, int k) {\\n    long sum = 0;\\n    for (int i : inventory) {\\n        if (i > k) sum += i - k;\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928615,
                "title": "python3-binary-search-with-explanation-in-comment",
                "content": "1. Get the highest price that satisfies the number of orders\\n2. Calculate the total cost by:\\n\\t2.1 Selling all the balls above the price limit\\n\\t2.2 Selling all the balls at the price limit, and notice that here the number of balls is the number of remaining orders\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def counts(m):\\n            result = 0\\n            for x in inventory:\\n                if x >= m:\\n                    result += x - m + 1\\n            return result\\n                                \\n        l = 1\\n        r = max(inventory) \\n        # Get the limit that satisfies the orders: eg orders = 10, sell until 2 can have 12 \\n        # balls in total, then this is a satisfaction,\\n        while l < r:\\n            m = l + (r - l) // 2\\n            if counts(m) < orders:\\n                r = m \\n            else:\\n                l = m + 1\\n                \\n        if counts(l) < orders:\\n            l = l - 1\\n        inventory.sort(reverse=True)\\n        ans = 0\\n        # sell all the balls above the limit\\n\\t\\t# Increase the limit by 1 \\n        l = l + 1\\n        for x in inventory:\\n            if orders >= x - l + 1 >= 0:\\n                ans += (x - l + 1) * (x + l) // 2 # x + (x-1) + (x-2) + ... +(x-n) = (x + x-n) * n / 2\\n                orders -= (x - l + 1)\\n                \\n        # Then sell all the balls that are sold at the limit price\\n        ans += orders * (l - 1)\\n        return ans % (1000000000 + 7)\\n        \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def counts(m):\\n            result = 0\\n            for x in inventory:\\n                if x >= m:\\n                    result += x - m + 1\\n            return result\\n                                \\n        l = 1\\n        r = max(inventory) \\n        # Get the limit that satisfies the orders: eg orders = 10, sell until 2 can have 12 \\n        # balls in total, then this is a satisfaction,\\n        while l < r:\\n            m = l + (r - l) // 2\\n            if counts(m) < orders:\\n                r = m \\n            else:\\n                l = m + 1\\n                \\n        if counts(l) < orders:\\n            l = l - 1\\n        inventory.sort(reverse=True)\\n        ans = 0\\n        # sell all the balls above the limit\\n\\t\\t# Increase the limit by 1 \\n        l = l + 1\\n        for x in inventory:\\n            if orders >= x - l + 1 >= 0:\\n                ans += (x - l + 1) * (x + l) // 2 # x + (x-1) + (x-2) + ... +(x-n) = (x + x-n) * n / 2\\n                orders -= (x - l + 1)\\n                \\n        # Then sell all the balls that are sold at the limit price\\n        ans += orders * (l - 1)\\n        return ans % (1000000000 + 7)\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 927855,
                "title": "java-solution-with-map-and-priorityqueue",
                "content": "```java\\nclass Solution {\\n    private long mod = 1000000007L;\\n    public int maxProfit(int[] inventory, int orders) {\\n\\t\\t// we use pq to find the most balls\\n        PriorityQueue<Long> pq = new PriorityQueue<>((x, y) -> Long.compare(y, x));\\n        pq.offer(0L);\\n\\t\\t\\n        // we use map to count the balls\\n        Map<Long, Long> map = new HashMap<>();\\n        map.put(0L, 0L);\\n        \\n        for (int j : inventory) {\\n            long i = (long)j;\\n            if (map.containsKey(i)) {\\n                map.put(i, map.get(i) + 1);\\n            }\\n            else {\\n                pq.offer(i);\\n                map.put(i, 1L);\\n            }\\n        }\\n        \\n        long res = 0;\\n        while (orders > 0) {\\n            long ball = pq.poll(), nextBall = pq.peek();\\n            long times = map.get(ball);\\n            long diff = Math.min(ball - nextBall, orders / times);\\n            if (diff == 0) {\\n                res = (res + orders * ball) % mod;\\n                break;\\n            }\\n            long sum = (ball * 2 + 1 - diff) * diff / 2 * times;\\n            res = (res + sum) % mod;\\n            orders -= diff * times;\\n            if (!map.containsKey(ball - diff)) {\\n                map.put(ball - diff, map.get(ball));\\n                pq.offer(ball - diff);\\n            }\\n            else {\\n                map.put(ball - diff, map.get(ball - diff) + map.get(ball));\\n            }\\n            map.remove(ball);\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private long mod = 1000000007L;\\n    public int maxProfit(int[] inventory, int orders) {\\n\\t\\t// we use pq to find the most balls\\n        PriorityQueue<Long> pq = new PriorityQueue<>((x, y) -> Long.compare(y, x));\\n        pq.offer(0L);\\n\\t\\t\\n        // we use map to count the balls\\n        Map<Long, Long> map = new HashMap<>();\\n        map.put(0L, 0L);\\n        \\n        for (int j : inventory) {\\n            long i = (long)j;\\n            if (map.containsKey(i)) {\\n                map.put(i, map.get(i) + 1);\\n            }\\n            else {\\n                pq.offer(i);\\n                map.put(i, 1L);\\n            }\\n        }\\n        \\n        long res = 0;\\n        while (orders > 0) {\\n            long ball = pq.poll(), nextBall = pq.peek();\\n            long times = map.get(ball);\\n            long diff = Math.min(ball - nextBall, orders / times);\\n            if (diff == 0) {\\n                res = (res + orders * ball) % mod;\\n                break;\\n            }\\n            long sum = (ball * 2 + 1 - diff) * diff / 2 * times;\\n            res = (res + sum) % mod;\\n            orders -= diff * times;\\n            if (!map.containsKey(ball - diff)) {\\n                map.put(ball - diff, map.get(ball));\\n                pq.offer(ball - diff);\\n            }\\n            else {\\n                map.put(ball - diff, map.get(ball - diff) + map.get(ball));\\n            }\\n            map.remove(ball);\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927679,
                "title": "python-greedy-solution",
                "content": "```python\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        ans, mod = 0, 10**9+7\\n        total = sum(inventory) \\n        inventory.sort()\\n        remain = total - orders\\n        N = len(inventory)\\n        for i, d in enumerate(inventory):\\n            each = remain // (N-i)\\n            if d > each:\\n                ans += (each+1+d) * (d-each) // 2\\n            remain -= min(each, d)\\n        return ans % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        ans, mod = 0, 10**9+7\\n        total = sum(inventory) \\n        inventory.sort()\\n        remain = total - orders\\n        N = len(inventory)\\n        for i, d in enumerate(inventory):\\n            each = remain // (N-i)\\n            if d > each:\\n                ans += (each+1+d) * (d-each) // 2\\n            remain -= min(each, d)\\n        return ans % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927551,
                "title": "c-o-n-log-n-greedy-using-max-heap-priority-queue",
                "content": "Greedily using the group of balls with maximum number.\\n\\nComplexity: O(n\\\\*log(n))\\nIn each loop I will remove one item from the heap by merging top with sub top.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int mod = 1000000007;\\n        unordered_map<int, int> counts;\\n        for (int num : inventory) {\\n            counts[num]++;\\n        }\\n        priority_queue<pair<int, int>> maxHeap;    //<number of balls, count of different balls with same number>\\n        for (auto &it : counts) {\\n            maxHeap.push(it);\\n        }\\n        int result = 0;\\n        while (orders > 0) {\\n            pair<int, int> top = maxHeap.top();\\n            maxHeap.pop();\\n            pair<int, int> sub = make_pair(0, 0);\\n            if (!maxHeap.empty()) {\\n                sub = maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            if ((long long)(top.first - sub.first) * top.second <= orders) {\\n                // merge top and sub top\\n                result = (result + ((long long)top.first + sub.first + 1) * (top.first - sub.first) / 2 * top.second) % mod;\\n                orders -= (top.first - sub.first) * top.second;\\n                sub.second += top.second;\\n                maxHeap.push(sub);\\n            } else {\\n                long long num = top.first;\\n                int count = top.second;\\n                int a = orders / count;\\n                int b = orders % count;\\n                result = (result + (num + num - a + 1) * a / 2 * count + (num - a) * b) % mod;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nExplanation of `((long long)top.first + sub.first + 1) * (top.first - sub.first) / 2 * top.second`:\\n`top.first` is the largest number group.\\n`sub.first` is the sub largest number group.\\n`((long long)top.first + sub.first + 1) * (top.first - sub.first) / 2` is the sum of arithmetic sequence from `sub.first + 1` to `top.first`.\\nSo the total formula is the total value we can get to merge largest number group with sub largest number group.\\n\\nExplanation of `(num + num - a + 1) * a / 2 * count + (num - a) * b`:\\n`num` is the largest number group.\\n`count` is the kinds of balls in the largest number group.\\n`a` is how many balls we take from each kind of balls in the group\\n`b` is the leftover balls we take from the group\\n`(num + num - a + 1) * a / 2` is the sum of arithmetic sequence from `num - a + 1` to `num`.\\nSo the total formula is the total value we can get from the largest number group.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int mod = 1000000007;\\n        unordered_map<int, int> counts;\\n        for (int num : inventory) {\\n            counts[num]++;\\n        }\\n        priority_queue<pair<int, int>> maxHeap;    //<number of balls, count of different balls with same number>\\n        for (auto &it : counts) {\\n            maxHeap.push(it);\\n        }\\n        int result = 0;\\n        while (orders > 0) {\\n            pair<int, int> top = maxHeap.top();\\n            maxHeap.pop();\\n            pair<int, int> sub = make_pair(0, 0);\\n            if (!maxHeap.empty()) {\\n                sub = maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            if ((long long)(top.first - sub.first) * top.second <= orders) {\\n                // merge top and sub top\\n                result = (result + ((long long)top.first + sub.first + 1) * (top.first - sub.first) / 2 * top.second) % mod;\\n                orders -= (top.first - sub.first) * top.second;\\n                sub.second += top.second;\\n                maxHeap.push(sub);\\n            } else {\\n                long long num = top.first;\\n                int count = top.second;\\n                int a = orders / count;\\n                int b = orders % count;\\n                result = (result + (num + num - a + 1) * a / 2 * count + (num - a) * b) % mod;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927526,
                "title": "python-greedy-binary-search",
                "content": "We do a greedy binary search to find the max possible threshold `T-1`. From each color we first fill the orders above with `T` and above. For the remainder we use `T-1`.\\n\\n``` python\\nclass Solution(object):\\n    def maxProfit(self, inventory, orders):\\n\\t\\t#count how many balls can be sold with this threshold\\n        def count_balls(x):\\n            ans = 0\\n            for e in inventory:\\n                if e<x:\\n                    continue\\n                else:\\n                    ans += e-x+1\\n            return ans\\n        \\n\\t\\t#modulo series sum\\n        def csum(x):\\n            return ((x*(x+1)//2) % (10**9 + 7))\\n        \\n        #T-1 will be the max possible threshold\\n        left = 0\\n        right = max(inventory)\\n        while left<right-1:\\n            mid = (left+right)>>1\\n            n = count_balls(mid)\\n            if n<orders:\\n                right = mid-1\\n            else:\\n                left = mid\\n        if count_balls(right)>=orders:\\n            T = right+1\\n        else:\\n            T = left+1\\n        \\n        #return value\\n        ret = 0\\n        \\n\\t\\t#first use T and above, these are highest value balls\\n        upper_count = 0\\n        for e in inventory:\\n            if e>=T:\\n                upper_count += (e-T+1) \\n                ret += csum(e)-csum(T-1)\\n                ret = ret % (10**9+7)\\n        \\n\\t\\t#complete the remainder with value T-1\\n        lower_count = orders-upper_count\\n        if lower_count > 0:\\n            ret += lower_count*(T-1)\\n            ret = ret % (10**9+7)\\n                \\n        return ret\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution(object):\\n    def maxProfit(self, inventory, orders):\\n\\t\\t#count how many balls can be sold with this threshold\\n        def count_balls(x):\\n            ans = 0\\n            for e in inventory:\\n                if e<x:\\n                    continue\\n                else:\\n                    ans += e-x+1\\n            return ans\\n        \\n\\t\\t#modulo series sum\\n        def csum(x):\\n            return ((x*(x+1)//2) % (10**9 + 7))\\n        \\n        #T-1 will be the max possible threshold\\n        left = 0\\n        right = max(inventory)\\n        while left<right-1:\\n            mid = (left+right)>>1\\n            n = count_balls(mid)\\n            if n<orders:\\n                right = mid-1\\n            else:\\n                left = mid\\n        if count_balls(right)>=orders:\\n            T = right+1\\n        else:\\n            T = left+1\\n        \\n        #return value\\n        ret = 0\\n        \\n\\t\\t#first use T and above, these are highest value balls\\n        upper_count = 0\\n        for e in inventory:\\n            if e>=T:\\n                upper_count += (e-T+1) \\n                ret += csum(e)-csum(T-1)\\n                ret = ret % (10**9+7)\\n        \\n\\t\\t#complete the remainder with value T-1\\n        lower_count = orders-upper_count\\n        if lower_count > 0:\\n            ret += lower_count*(T-1)\\n            ret = ret % (10**9+7)\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927505,
                "title": "c-greedy-using-map",
                "content": "first of all, I think this question is much harder than usual medium ones\\n```\\nclass Solution {\\npublic:\\n\\nint maxProfit(vector<int>& inventory, int orders)\\n{\\n\\tlong long int res = 0;\\n\\tint mod = 1e9 + 7;\\n\\n\\tmap<int, int> freq;\\n\\tfor (int i = 0; i < inventory.size(); i++)\\n\\t\\tfreq[inventory[i]]++;\\n\\t\\n\\tauto iter = freq.rbegin();\\n\\t\\n\\twhile(orders && iter != freq.rend()) \\n\\t{\\n\\t\\tint cnt = iter->second;\\n\\t\\tlong long int curr = iter->first;\\n\\t\\titer++;\\n\\n\\t\\tint top = iter == freq.rend() ? 0 : iter->first;\\n\\n\\t\\tif (orders >= (curr - top) * cnt)\\n\\t\\t{\\n\\t\\t\\tres = (res + cnt * (curr + top + 1) * (curr - top) / 2) % mod;\\n\\t\\t\\torders -= (curr - top) * cnt;\\n\\t\\t\\titer->second += cnt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint trancs = orders / cnt;\\n\\t\\t\\tint remain = orders % cnt;\\n\\t\\t\\tres = (res + cnt * (curr + curr - trancs + 1) * trancs / 2) % mod;\\n\\t\\t\\tres = (res + remain * (curr - trancs)) % mod;\\n\\t\\t\\torders = 0;\\n\\t\\t}\\n \\t}\\n\\n\\treturn res;\\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint maxProfit(vector<int>& inventory, int orders)\\n{\\n\\tlong long int res = 0;\\n\\tint mod = 1e9 + 7;\\n\\n\\tmap<int, int> freq;\\n\\tfor (int i = 0; i < inventory.size(); i++)\\n\\t\\tfreq[inventory[i]]++;\\n\\t\\n\\tauto iter = freq.rbegin();\\n\\t\\n\\twhile(orders && iter != freq.rend()) \\n\\t{\\n\\t\\tint cnt = iter->second;\\n\\t\\tlong long int curr = iter->first;\\n\\t\\titer++;\\n\\n\\t\\tint top = iter == freq.rend() ? 0 : iter->first;\\n\\n\\t\\tif (orders >= (curr - top) * cnt)\\n\\t\\t{\\n\\t\\t\\tres = (res + cnt * (curr + top + 1) * (curr - top) / 2) % mod;\\n\\t\\t\\torders -= (curr - top) * cnt;\\n\\t\\t\\titer->second += cnt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint trancs = orders / cnt;\\n\\t\\t\\tint remain = orders % cnt;\\n\\t\\t\\tres = (res + cnt * (curr + curr - trancs + 1) * trancs / 2) % mod;\\n\\t\\t\\tres = (res + remain * (curr - trancs)) % mod;\\n\\t\\t\\torders = 0;\\n\\t\\t}\\n \\t}\\n\\n\\treturn res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816673,
                "title": "either-the-problem-is-too-difficult-or-i-thought-too-much-applied-all-my-maths-knowledge-here",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxProfit(vector<int> &inv, int ord)\\n        {\\n            map<long, long> m;\\n            for (int i = 0; i < inv.size(); i++) m[inv[i]] += 1;\\n            m[0] = 0;\\n            priority_queue<pair<long, long>, vector< pair<long, long>>> heap;\\n            for (auto i: m) heap.push(i);\\n            long long cost = 0;\\n            while (ord)\\n            {\\n                auto x = heap.top();\\n                heap.pop();\\n                auto y = heap.top();\\n                heap.pop();\\n                long balls = (x.first - y.first) *x.second;\\n                if (balls <= ord)\\n                {\\n                    long long n1 = (x.first *(x.first + 1)) / 2;\\n                    long long n2 = (y.first *(y.first + 1)) / 2;\\n                    ord -= balls;\\n                    cost += (n1 - n2) *x.second;\\n                }\\n                else\\n                {\\n                    long req = ord / x.second;\\n                    long long n1 = (x.first *(x.first + 1)) / 2;\\n                    long long n2 = ((x.first - req) *((x.first - req) + 1)) / 2;\\n                    cost += (n1 - n2) *x.second;\\n                    x.first -= req;\\n                    req = ord % x.second;\\n                    cost += x.first * req;\\n                    return cost % 1000000007;\\n                }\\n                y.second += x.second;\\n                heap.push(y);\\n            }\\n            return cost % 1000000007;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxProfit(vector<int> &inv, int ord)\\n        {\\n            map<long, long> m;\\n            for (int i = 0; i < inv.size(); i++) m[inv[i]] += 1;\\n            m[0] = 0;\\n            priority_queue<pair<long, long>, vector< pair<long, long>>> heap;\\n            for (auto i: m) heap.push(i);\\n            long long cost = 0;\\n            while (ord)\\n            {\\n                auto x = heap.top();\\n                heap.pop();\\n                auto y = heap.top();\\n                heap.pop();\\n                long balls = (x.first - y.first) *x.second;\\n                if (balls <= ord)\\n                {\\n                    long long n1 = (x.first *(x.first + 1)) / 2;\\n                    long long n2 = (y.first *(y.first + 1)) / 2;\\n                    ord -= balls;\\n                    cost += (n1 - n2) *x.second;\\n                }\\n                else\\n                {\\n                    long req = ord / x.second;\\n                    long long n1 = (x.first *(x.first + 1)) / 2;\\n                    long long n2 = ((x.first - req) *((x.first - req) + 1)) / 2;\\n                    cost += (n1 - n2) *x.second;\\n                    x.first -= req;\\n                    req = ord % x.second;\\n                    cost += x.first * req;\\n                    return cost % 1000000007;\\n                }\\n                y.second += x.second;\\n                heap.push(y);\\n            }\\n            return cost % 1000000007;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884482,
                "title": "java-binary-search-solution",
                "content": "- Binary search for the minimum number we can make all the numbers be without making `orders` go to 0.\\n- Once we have that number, the rest is just range sum + reminders of orders multiplies that number. \\n- i.e. `((lo + 1) + (lo + 2) + ... + n)` + `orders * lo`\\n<br>\\n```Java\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int lo = 1, hi = (int)1e9, m = hi + 7;\\n        while(lo < hi){\\n            int mid = (lo + hi) >> 1;\\n            long need = 0;\\n            for (int n : inventory){\\n                need += Math.max(0, n - mid);\\n            }\\n            if (need < orders){\\n                hi = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int n : inventory){\\n            ans = (ans + Math.max(0L, 1L*(lo + 1 + n)*(n - lo)/2)) % m;\\n            orders -= Math.max(0, n - lo);\\n        }\\n\\n        return (int)((ans + 1L*orders * lo) % m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int lo = 1, hi = (int)1e9, m = hi + 7;\\n        while(lo < hi){\\n            int mid = (lo + hi) >> 1;\\n            long need = 0;\\n            for (int n : inventory){\\n                need += Math.max(0, n - mid);\\n            }\\n            if (need < orders){\\n                hi = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int n : inventory){\\n            ans = (ans + Math.max(0L, 1L*(lo + 1 + n)*(n - lo)/2)) % m;\\n            orders -= Math.max(0, n - lo);\\n        }\\n\\n        return (int)((ans + 1L*orders * lo) % m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927626,
                "title": "python-o-nlogn-think-backwards-1-color-at-a-time-easy-to-understand",
                "content": "Think about when all sales are completed, what do we have as remainnig inventory? \\n\\nHow do we maximize our profit?  we sell the color that has the highest count.  When there are several colors with equal count, we sell 1 from each color.  So when all sales are final,  we would have a remaining inventory list of \\n[ x1, x2, ... A, A, A, A, ... A+1, A+1, A+1, ... ] \\nx1, x2 ...:  These are colors that are less than A, we did not sale any\\nA:  These are colors >= A, and we sold # of them to reach A \\nA+1:  These are colors >= A + 1, and we sold # of them to reach A + 1\\n\\nThe sum of our remaining Inventory list = orignal invetory - orders, let\\'s sort our inventory list and work 1 color at a time\\n\\n```\\n\\t\\tinventory.sort()   \\n        profit = 0\\n        m = len(inventory)\\n        remaining = sum(inventory) - orders  #total remaining quantity expected \\n        \\n        for i, start in enumerate(inventory):   \\n\\t\\t\\t# if we sold this color, we expect ending count = end\\n            end = remaining // (m-i)   \\n            # we sold some quantity\\n\\t\\t\\tif end < start:  \\n                profit += (end + 1 + start) * (start - end) // 2\\n                remaining -= end\\n            # no sale made for this color \\n\\t\\t\\telse: \\n                remaining -= start\\n                \\n        return profit % (10**9+7)\\n```\\n        \\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tinventory.sort()   \\n        profit = 0\\n        m = len(inventory)\\n        remaining = sum(inventory) - orders  #total remaining quantity expected \\n        \\n        for i, start in enumerate(inventory):   \\n\\t\\t\\t# if we sold this color, we expect ending count = end\\n            end = remaining // (m-i)   \\n            # we sold some quantity\\n\\t\\t\\tif end < start:  \\n                profit += (end + 1 + start) * (start - end) // 2\\n                remaining -= end\\n            # no sale made for this color \\n\\t\\t\\telse: \\n                remaining -= start\\n                \\n        return profit % (10**9+7)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927620,
                "title": "java-greedy-priorityqueue-68-ms-faster-than-16-67-50-mb-less-than-16-67",
                "content": "```\\nclass Solution {\\n    private class Pair {\\n        long p;\\n        int cnt;\\n\\n        Pair(long p, int cnt) {\\n            this.p = p;\\n            this.cnt = cnt;\\n        }\\n    }\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(b.p, a.p));\\n        for (int cnt : inventory) {\\n            pq.offer(new Pair(cnt, 1));\\n        }\\n        long profit = 0;\\n        while (orders > 0 && !pq.isEmpty()) {\\n            Pair p = pq.poll();\\n            while (!pq.isEmpty() && pq.peek().p == p.p) {\\n                p.cnt += pq.poll().cnt;\\n            }\\n            long diff = pq.isEmpty() ? p.p : p.p - pq.peek().p;\\n            if (p.cnt * diff <= orders) {\\n                orders -= p.cnt * diff;\\n                profit += p.cnt * (p.p - diff + 1 + p.p) * diff / 2;\\n                if (p.p - diff > 0) {\\n                    pq.offer(new Pair(p.p - diff, p.cnt));\\n                }\\n            } else {\\n                int len = orders / p.cnt;\\n                profit += len * (p.p - len + 1 + p.p) * p.cnt / 2;\\n                profit += (orders % p.cnt) * (p.p - len);\\n                orders = 0;\\n            }\\n        }\\n        return (int) (profit % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Pair {\\n        long p;\\n        int cnt;\\n\\n        Pair(long p, int cnt) {\\n            this.p = p;\\n            this.cnt = cnt;\\n        }\\n    }\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(b.p, a.p));\\n        for (int cnt : inventory) {\\n            pq.offer(new Pair(cnt, 1));\\n        }\\n        long profit = 0;\\n        while (orders > 0 && !pq.isEmpty()) {\\n            Pair p = pq.poll();\\n            while (!pq.isEmpty() && pq.peek().p == p.p) {\\n                p.cnt += pq.poll().cnt;\\n            }\\n            long diff = pq.isEmpty() ? p.p : p.p - pq.peek().p;\\n            if (p.cnt * diff <= orders) {\\n                orders -= p.cnt * diff;\\n                profit += p.cnt * (p.p - diff + 1 + p.p) * diff / 2;\\n                if (p.p - diff > 0) {\\n                    pq.offer(new Pair(p.p - diff, p.cnt));\\n                }\\n            } else {\\n                int len = orders / p.cnt;\\n                profit += len * (p.p - len + 1 + p.p) * p.cnt / 2;\\n                profit += (orders % p.cnt) * (p.p - len);\\n                orders = 0;\\n            }\\n        }\\n        return (int) (profit % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998097,
                "title": "c-using-binarysearch-maths-o-n-log-1e9",
                "content": "```\\n#define ll long long int\\n#define MODADD(a, b, m) ((((a) % m) + ((b) % m)) % m)\\nconst ll M = 1e9 + 7;\\nclass Solution {\\npublic:\\n    \\n    ll sum(ll n)\\n    {\\n        return (n * (n + 1)) / 2;\\n    }\\n    \\n    bool isPossible(vector<int> &a, int k, ll orders)\\n    {\\n        ll cnt = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] <= k) continue;\\n            cnt += (a[i] - k); // a[i] - (k + 1) + 1\\n        }\\n        \\n        return cnt <= orders;\\n    }\\n    \\n    int maxProfit(vector<int>& a, int orders) \\n    {\\n        int n = a.size();\\n        \\n        sort(a.begin(), a.end());\\n        \\n        ll k = 1e9;\\n        \\n        ll beg = 0, end  = 1e9;\\n    \\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            \\n            if(isPossible(a, mid, orders))\\n            {\\n                k = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n        \\n        ll ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(a[i] <= k) continue;\\n            ans = MODADD(ans, sum(a[i]) - sum(k), M);\\n            orders -= (a[i] - k);\\n        }\\n        \\n        ll freq_of_k = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(a[i] < k) continue;\\n            freq_of_k++;\\n        }\\n        \\n        ans = MODADD(ans, min(freq_of_k, (ll)orders) * k, M);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long int\\n#define MODADD(a, b, m) ((((a) % m) + ((b) % m)) % m)\\nconst ll M = 1e9 + 7;\\nclass Solution {\\npublic:\\n    \\n    ll sum(ll n)\\n    {\\n        return (n * (n + 1)) / 2;\\n    }\\n    \\n    bool isPossible(vector<int> &a, int k, ll orders)\\n    {\\n        ll cnt = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] <= k) continue;\\n            cnt += (a[i] - k); // a[i] - (k + 1) + 1\\n        }\\n        \\n        return cnt <= orders;\\n    }\\n    \\n    int maxProfit(vector<int>& a, int orders) \\n    {\\n        int n = a.size();\\n        \\n        sort(a.begin(), a.end());\\n        \\n        ll k = 1e9;\\n        \\n        ll beg = 0, end  = 1e9;\\n    \\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            \\n            if(isPossible(a, mid, orders))\\n            {\\n                k = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n        \\n        ll ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(a[i] <= k) continue;\\n            ans = MODADD(ans, sum(a[i]) - sum(k), M);\\n            orders -= (a[i] - k);\\n        }\\n        \\n        ll freq_of_k = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(a[i] < k) continue;\\n            freq_of_k++;\\n        }\\n        \\n        ans = MODADD(ans, min(freq_of_k, (ll)orders) * k, M);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492498,
                "title": "java-easy-to-understand",
                "content": "using priority queue and map.\\npriority queue holds unique values of # of balls initially.\\nmap contains number of groups of those unique values.\\n\\nsome code are duplicated, so we could reduce the code, too.\\nbut it is very easier to understand.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        HashMap<Long, Long> map = new HashMap<>();\\n        PriorityQueue<Long> pq = new PriorityQueue<>((a,b) -> (int)(b - a));\\n        for (int i : inventory) {\\n            map.put((long)i, map.getOrDefault((long)i, 0L) + 1L);\\n        }\\n        for (long l : map.keySet()) {\\n            pq.offer(l);\\n        }\\n        \\n        long ret = 0;\\n        while (orders > 0) {\\n            long n = pq.poll();\\n            long count = map.get(n);\\n            if (pq.isEmpty()) {\\n                if (orders >= n * count) {\\n                    ret += count * n * (n+1) / 2;\\n                } else {\\n                    while (orders >= count) {\\n                        ret += n * count;\\n                        orders -= count;\\n                        n--;\\n                    }\\n                    ret += n * orders;\\n                }\\n                break;\\n            } else {\\n                long nn = pq.peek();\\n                if (orders >= (n - nn) * count) {\\n                    ret += count * getFromTo(n, nn);\\n                    orders -= (n - nn) * count;\\n                    map.put(nn, map.get(nn) + count);\\n                } else {\\n                   while (orders >= count) {\\n                       ret += n * count;\\n                       orders -= count;\\n                       n--;\\n                   } \\n                   ret += n * orders;\\n                   break;\\n                }\\n            }\\n        }\\n        ret %= 1000000007;            \\n        return (int)ret;\\n    }\\n    \\n    public long getFromTo(long l, long ll) {\\n        return l * (l+1) / 2 - ll * (ll + 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        HashMap<Long, Long> map = new HashMap<>();\\n        PriorityQueue<Long> pq = new PriorityQueue<>((a,b) -> (int)(b - a));\\n        for (int i : inventory) {\\n            map.put((long)i, map.getOrDefault((long)i, 0L) + 1L);\\n        }\\n        for (long l : map.keySet()) {\\n            pq.offer(l);\\n        }\\n        \\n        long ret = 0;\\n        while (orders > 0) {\\n            long n = pq.poll();\\n            long count = map.get(n);\\n            if (pq.isEmpty()) {\\n                if (orders >= n * count) {\\n                    ret += count * n * (n+1) / 2;\\n                } else {\\n                    while (orders >= count) {\\n                        ret += n * count;\\n                        orders -= count;\\n                        n--;\\n                    }\\n                    ret += n * orders;\\n                }\\n                break;\\n            } else {\\n                long nn = pq.peek();\\n                if (orders >= (n - nn) * count) {\\n                    ret += count * getFromTo(n, nn);\\n                    orders -= (n - nn) * count;\\n                    map.put(nn, map.get(nn) + count);\\n                } else {\\n                   while (orders >= count) {\\n                       ret += n * count;\\n                       orders -= count;\\n                       n--;\\n                   } \\n                   ret += n * orders;\\n                   break;\\n                }\\n            }\\n        }\\n        ret %= 1000000007;            \\n        return (int)ret;\\n    }\\n    \\n    public long getFromTo(long l, long ll) {\\n        return l * (l+1) / 2 - ll * (ll + 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429311,
                "title": "java-o-nlogn-sort-maths",
                "content": "1. Sort inventory array\\n2. Consider [10,8,6,4,2] as inventory array and no of orders as infinite and now convert it to 8,8,6,4,2 in the first step so we will have profit as (9+10) and in second step convert it to 6,6,6,4,2 and now we will have profit as (9+10+(8+7)*2)\\n3. If we take prev as 8 and curr as 6 in the second step, we are adding summation of curr+1, curr+2, curr+3 ....,prev to ans for 2(cnt) no of times which is actually count of 8. So in this manner we are actually making all prev elements same and simultaneously decreasing their value.\\n4. Based on this, we can add ((getSum(prev) - getSum(curr) ) * cnt ) to ans where getSum(prev) is prev*(prev+1)/2\\n5. Now to put limitation on no of orders we need to check for how many times we are adding balls. If we observe in second step we are adding balls 4 no of times (8,8,7,7) which is (prev - curr)*cnt.\\n6. Now lets say we had to add only 3(remaining orders) balls instead of 4 in second step. So we can add 8 for 2 times and 7 for 1 time. If we observe, we are adding cnt no of times for all elements from prev, prev-1, prev-2,..prev-cal(orders/cnt) until no more remaining orders are left and last element(prev-cal) will take remainder(orders%cnt) of orders.\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        int n=inventory.length;\\n        int prev = inventory[n-1];\\n        long ans = 0;\\n        long mod = 1000000007;\\n        for (int i=n-2;i>=0;i--) {\\n            int curr = inventory[i];\\n            int cnt = n-i-1;\\n            if (prev!=curr) {\\n                if (((long)prev-curr)*cnt<=orders) {\\n                    ans += ((getSum(prev) - getSum(curr) +mod)%mod * cnt )%mod;\\n                    ans %= mod;\\n                    orders -= ((long)prev-curr)*cnt;\\n                } else {\\n                    int cal = orders/cnt;\\n                    int rem = orders%cnt;\\n                    ans += ((getSum(prev) - getSum(prev-cal) + mod)%mod * cnt )%mod;\\n                    ans %= mod;\\n                    ans += ((prev-cal+mod) * rem )%mod;\\n                    ans %= mod;\\n                    orders = 0;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        int curr = 0;\\n        int cnt = n;\\n        if (prev!=curr) {\\n            if (((long)prev-curr)*cnt<=orders) {\\n                ans += ((getSum(prev) - getSum(curr) )%mod * cnt )%mod;\\n                ans %= mod;\\n                orders -= ((long)prev-curr)*cnt;\\n            } else {\\n                int cal = orders/cnt;\\n                int rem = orders%cnt;\\n                ans += ((getSum(prev) - getSum(prev-cal) )%mod * cnt )%mod;\\n                ans %= mod;\\n                ans += ((prev-cal+mod) * rem )%mod;\\n                ans %= mod;\\n                orders = 0;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n    long getSum(int k) {\\n        return (((long)k*(k+1))/2)%1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        int n=inventory.length;\\n        int prev = inventory[n-1];\\n        long ans = 0;\\n        long mod = 1000000007;\\n        for (int i=n-2;i>=0;i--) {\\n            int curr = inventory[i];\\n            int cnt = n-i-1;\\n            if (prev!=curr) {\\n                if (((long)prev-curr)*cnt<=orders) {\\n                    ans += ((getSum(prev) - getSum(curr) +mod)%mod * cnt )%mod;\\n                    ans %= mod;\\n                    orders -= ((long)prev-curr)*cnt;\\n                } else {\\n                    int cal = orders/cnt;\\n                    int rem = orders%cnt;\\n                    ans += ((getSum(prev) - getSum(prev-cal) + mod)%mod * cnt )%mod;\\n                    ans %= mod;\\n                    ans += ((prev-cal+mod) * rem )%mod;\\n                    ans %= mod;\\n                    orders = 0;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        int curr = 0;\\n        int cnt = n;\\n        if (prev!=curr) {\\n            if (((long)prev-curr)*cnt<=orders) {\\n                ans += ((getSum(prev) - getSum(curr) )%mod * cnt )%mod;\\n                ans %= mod;\\n                orders -= ((long)prev-curr)*cnt;\\n            } else {\\n                int cal = orders/cnt;\\n                int rem = orders%cnt;\\n                ans += ((getSum(prev) - getSum(prev-cal) )%mod * cnt )%mod;\\n                ans %= mod;\\n                ans += ((prev-cal+mod) * rem )%mod;\\n                ans %= mod;\\n                orders = 0;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n    long getSum(int k) {\\n        return (((long)k*(k+1))/2)%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995753,
                "title": "javascript-binary-search-o-nlgn",
                "content": "```\\nvar maxProfit = function (A, t) {\\n  const m = BigInt(1e9 + 7),\\n    N = A.length;\\n  let l = 1,\\n    r = Math.max(...A);\\n\\n  // Find a price l that all other prices p whre p >= l, count up to t\\n  while (l < r) {\\n    const mid = (l + r) >> 1;\\n    let s = 0;\\n    for (let i = 0; i < N; i++) if (A[i] >= mid) s += A[i] - mid + 1;\\n    // Not enough, decrease mid\\n    if (s <= t) r = mid;\\n    // Too much, increase mid\\n    else l = mid + 1;\\n  }\\n\\n  // Convert to BigInt\\n  t = BigInt(t);\\n  let res = 0n;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] >= l) {\\n      const small = BigInt(l),\\n        large = BigInt(A[i]),\\n        count = BigInt(A[i] - l + 1);\\n      res += (((small + large) * count) / 2n) % m;\\n      res %= m;\\n      t -= count;\\n    }\\n  }\\n  res += (t * BigInt(l - 1)) % m;\\n  return res % m;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar maxProfit = function (A, t) {\\n  const m = BigInt(1e9 + 7),\\n    N = A.length;\\n  let l = 1,\\n    r = Math.max(...A);\\n\\n  // Find a price l that all other prices p whre p >= l, count up to t\\n  while (l < r) {\\n    const mid = (l + r) >> 1;\\n    let s = 0;\\n    for (let i = 0; i < N; i++) if (A[i] >= mid) s += A[i] - mid + 1;\\n    // Not enough, decrease mid\\n    if (s <= t) r = mid;\\n    // Too much, increase mid\\n    else l = mid + 1;\\n  }\\n\\n  // Convert to BigInt\\n  t = BigInt(t);\\n  let res = 0n;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] >= l) {\\n      const small = BigInt(l),\\n        large = BigInt(A[i]),\\n        count = BigInt(A[i] - l + 1);\\n      res += (((small + large) * count) / 2n) % m;\\n      res %= m;\\n      t -= count;\\n    }\\n  }\\n  res += (t * BigInt(l - 1)) % m;\\n  return res % m;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249075,
                "title": "java-easy-solution",
                "content": "# Java Easy Solution\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long ans = 0, range = 1, current, next;\\n\\n        for (int i = inventory.length - 1; i >= 0; i--) {\\n            if (i != 0 && inventory[i] == inventory[i - 1]) {\\n                range++;\\n                continue;\\n            }\\n\\n            current = inventory[i];\\n            next = (i == 0) ? 0 : inventory[i - 1];\\n\\n            if ((current - next) * range <= orders) {\\n                ans += (findSum(current, next) * range) % 1000000007;\\n                orders -= (current - next) * range;\\n            } else {\\n                long multiple = orders / range;\\n                ans += (findSum(current, current - multiple) * range) % 1000000007;\\n                long remainder = orders % range;\\n                ans += ((current - multiple) * remainder) % 1000000007;\\n                orders = 0;\\n            }\\n\\n            range++;\\n\\n            if (orders <= 0)\\n                break;\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n\\n    public long findSum(long start, long end) {\\n        long res = ((start * (start + 1)) - (end * (end + 1))) / 2;\\n        return res % 1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long ans = 0, range = 1, current, next;\\n\\n        for (int i = inventory.length - 1; i >= 0; i--) {\\n            if (i != 0 && inventory[i] == inventory[i - 1]) {\\n                range++;\\n                continue;\\n            }\\n\\n            current = inventory[i];\\n            next = (i == 0) ? 0 : inventory[i - 1];\\n\\n            if ((current - next) * range <= orders) {\\n                ans += (findSum(current, next) * range) % 1000000007;\\n                orders -= (current - next) * range;\\n            } else {\\n                long multiple = orders / range;\\n                ans += (findSum(current, current - multiple) * range) % 1000000007;\\n                long remainder = orders % range;\\n                ans += ((current - multiple) * remainder) % 1000000007;\\n                orders = 0;\\n            }\\n\\n            range++;\\n\\n            if (orders <= 0)\\n                break;\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n\\n    public long findSum(long start, long end) {\\n        long res = ((start * (start + 1)) - (end * (end + 1))) / 2;\\n        return res % 1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102300,
                "title": "c-o-nlog-n-simple-array-bs",
                "content": "```\\nusing ll = long long;\\nconst long long MOD = 1e9 + 7;\\nll mod_a(ll a,ll b){a %= MOD;b %= MOD;return (((a + b) % MOD) + MOD) % MOD;}\\nll mod_m(ll a,ll b){a %= MOD;b %= MOD;return (((a * b) % MOD) + MOD) % MOD;}\\nll mod_s(ll a,ll b){a %= MOD;b %= MOD;return (((a - b) % MOD) + MOD) % MOD;}\\nlong long f(long long N){return N * (N + 1) / 2;}\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& I,long long orders) {\\n        sort(I.begin(),I.end());\\n        int N = I.size();\\n        int R = N,Val = I[N-1];\\n        long long C = 0;\\n        while(orders){\\n            int l = 0,r = R-1,idx = -1;\\n            while(l<=r){\\n                int m = l + (r-l)/2;\\n                if(I[m]>=Val){\\n                    idx = m;\\n                    r = m - 1;\\n                }else l = m + 1;\\n            }\\n            long long D = 1ll * (N - idx);\\n            long long Last = 1ll * (idx ? I[idx-1] : 0);\\n            if((D * (Val - Last))<=orders){\\n                C = mod_a(C,mod_m(D,mod_s(f(Val),f(Last))));\\n                orders -= (D * 1ll * (Val - Last));\\n                Val = (idx ? I[idx-1] : 0);\\n                R = idx;\\n            }else{\\n                long long S = orders / D;\\n                C = mod_a(C,mod_m(D,mod_s(f(Val),f(Val-S))));\\n                C = mod_a(C,mod_m((orders % D),mod_s(Val,S)));\\n                orders = 0;\\n            }\\n        }\\n        return C % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nusing ll = long long;\\nconst long long MOD = 1e9 + 7;\\nll mod_a(ll a,ll b){a %= MOD;b %= MOD;return (((a + b) % MOD) + MOD) % MOD;}\\nll mod_m(ll a,ll b){a %= MOD;b %= MOD;return (((a * b) % MOD) + MOD) % MOD;}\\nll mod_s(ll a,ll b){a %= MOD;b %= MOD;return (((a - b) % MOD) + MOD) % MOD;}\\nlong long f(long long N){return N * (N + 1) / 2;}\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& I,long long orders) {\\n        sort(I.begin(),I.end());\\n        int N = I.size();\\n        int R = N,Val = I[N-1];\\n        long long C = 0;\\n        while(orders){\\n            int l = 0,r = R-1,idx = -1;\\n            while(l<=r){\\n                int m = l + (r-l)/2;\\n                if(I[m]>=Val){\\n                    idx = m;\\n                    r = m - 1;\\n                }else l = m + 1;\\n            }\\n            long long D = 1ll * (N - idx);\\n            long long Last = 1ll * (idx ? I[idx-1] : 0);\\n            if((D * (Val - Last))<=orders){\\n                C = mod_a(C,mod_m(D,mod_s(f(Val),f(Last))));\\n                orders -= (D * 1ll * (Val - Last));\\n                Val = (idx ? I[idx-1] : 0);\\n                R = idx;\\n            }else{\\n                long long S = orders / D;\\n                C = mod_a(C,mod_m(D,mod_s(f(Val),f(Val-S))));\\n                C = mod_a(C,mod_m((orders % D),mod_s(Val,S)));\\n                orders = 0;\\n            }\\n        }\\n        return C % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416409,
                "title": "java-using-sorting",
                "content": "```\\nclass Solution {\\n   int mod=1000000007;\\n    public int maxProfit(int[] inventory, int orders) {\\n        long ans=0;\\n        Arrays.sort(inventory);\\n\\t\\t//it is used to count the window\\n        long factor=1;\\n        int i=inventory.length-1;\\n        while(orders>0)\\n        {\\n\\t\\t\\t//cases like [5,6,7,9,9,9] and order is 35\\n            if(i>0 && inventory[i]>inventory[i-1] && orders>=factor*(inventory[i]-inventory[i-1]))\\n            {\\n                ans+=factor*(getSum(inventory[i],inventory[i-1]));\\n                ans=ans%mod;\\n                orders-=factor*(inventory[i]-inventory[i-1]);\\n            } // cases like [8,8,8] but orders is 10 \\n\\t\\t\\telse if(i==0 || inventory[i]>inventory[i-1])\\n            {\\n\\t\\t\\t   //use long to avoid overflow\\n                long sellItems=(orders/factor);\\n                ans+=factor*getSum(inventory[i],inventory[i]-sellItems);\\n                ans=ans%mod;\\n                long remain=(orders%factor);\\n                ans+=(inventory[i]-sellItems)*remain;\\n                ans=ans%mod;\\n                break;\\n            }\\n            factor++;\\n            i--;\\n        }\\n        return  (int)ans;\\n    }\\n    // to get the sum of numbers in the window\\n    public long getSum(long left, long right)\\n    {\\n        left=left%mod;\\n        right=right%mod;\\n        return ((left*(left+1))/2)-(right*(right+1)/2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int mod=1000000007;\\n    public int maxProfit(int[] inventory, int orders) {\\n        long ans=0;\\n        Arrays.sort(inventory);\\n\\t\\t//it is used to count the window\\n        long factor=1;\\n        int i=inventory.length-1;\\n        while(orders>0)\\n        {\\n\\t\\t\\t//cases like [5,6,7,9,9,9] and order is 35\\n            if(i>0 && inventory[i]>inventory[i-1] && orders>=factor*(inventory[i]-inventory[i-1]))\\n            {\\n                ans+=factor*(getSum(inventory[i],inventory[i-1]));\\n                ans=ans%mod;\\n                orders-=factor*(inventory[i]-inventory[i-1]);\\n            } // cases like [8,8,8] but orders is 10 \\n\\t\\t\\telse if(i==0 || inventory[i]>inventory[i-1])\\n            {\\n\\t\\t\\t   //use long to avoid overflow\\n                long sellItems=(orders/factor);\\n                ans+=factor*getSum(inventory[i],inventory[i]-sellItems);\\n                ans=ans%mod;\\n                long remain=(orders%factor);\\n                ans+=(inventory[i]-sellItems)*remain;\\n                ans=ans%mod;\\n                break;\\n            }\\n            factor++;\\n            i--;\\n        }\\n        return  (int)ans;\\n    }\\n    // to get the sum of numbers in the window\\n    public long getSum(long left, long right)\\n    {\\n        left=left%mod;\\n        right=right%mod;\\n        return ((left*(left+1))/2)-(right*(right+1)/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365851,
                "title": "java-o-nlogn-solution-with-detailed-comment",
                "content": "```java\\npublic class Solution {\\n    public static int maxProfit(int[] inventory, int orders) {\\n        // sort all items\\n        Arrays.sort(inventory);\\n\\n        // insert 0 to the head of array;\\n        int len = inventory.length+1;\\n        int[] item = new int[len];\\n        item[0] = 0;\\n        System.arraycopy(inventory, 0, item, 1, len - 1);\\n\\n        /**\\n         * start from the biggest e.g. [2,4,6,8,10], 26\\n         * num=1 loop=offset=2, remain=0, ans += (10+9) + 0 = 19, order = 22-2 = 20, items = [0,2,4,6,8,8]\\n         * num=2 loop=offset=2, remain=0, ans += 2*(8+7) + 0 = 49, order = 20-2*2 = 16, items = [0,2,4,6,6,6]\\n         * num=3 loop=offset=2, remain=0, ans += 3*(6+5) + 0 = 82, order = 16-3*2 = 10, items = [0,2,4,4,4,4]\\n         * num=4 loop=offset=2, remain=0, ans += 4*(4+3) + 0 = 110, order = 10-4*2 = 2, items = [0,2,2,2,2,2]\\n         * num=5 loop=6/5=1 < offset=2, remain=6%5=1 ans += 5*2 + 1*1 = 121, order = 2-1*1-1 = 0, items = [0,1,1,1,1,0]\\n         */\\n        long ans = 0;\\n        int count = len-1; // start from the biggest value\\n        while(orders > 0) {\\n            // number of elements with same value\\n            int num = len - count;\\n            // number of loops current value needed\\n            long loop = orders/num;\\n            // remain orders after loop\\n            long remain = orders%num;\\n\\n            // the offset between current value and next value\\n            long offset = item[count] - item[count - 1];\\n\\n            // If the current value is reduced to the same as the next value, end the loop\\n            if(loop >= offset) {\\n                loop = offset;\\n                remain = 0;\\n            }\\n\\n            // add loop value and remain value\\n            ans += num*(item[count]+item[count]-loop+1)*loop/2 + remain*(item[count]-loop);\\n            orders -= loop*num+remain;\\n\\n            count--;\\n        }\\n\\n        return (int)(ans%1000000007);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public static int maxProfit(int[] inventory, int orders) {\\n        // sort all items\\n        Arrays.sort(inventory);\\n\\n        // insert 0 to the head of array;\\n        int len = inventory.length+1;\\n        int[] item = new int[len];\\n        item[0] = 0;\\n        System.arraycopy(inventory, 0, item, 1, len - 1);\\n\\n        /**\\n         * start from the biggest e.g. [2,4,6,8,10], 26\\n         * num=1 loop=offset=2, remain=0, ans += (10+9) + 0 = 19, order = 22-2 = 20, items = [0,2,4,6,8,8]\\n         * num=2 loop=offset=2, remain=0, ans += 2*(8+7) + 0 = 49, order = 20-2*2 = 16, items = [0,2,4,6,6,6]\\n         * num=3 loop=offset=2, remain=0, ans += 3*(6+5) + 0 = 82, order = 16-3*2 = 10, items = [0,2,4,4,4,4]\\n         * num=4 loop=offset=2, remain=0, ans += 4*(4+3) + 0 = 110, order = 10-4*2 = 2, items = [0,2,2,2,2,2]\\n         * num=5 loop=6/5=1 < offset=2, remain=6%5=1 ans += 5*2 + 1*1 = 121, order = 2-1*1-1 = 0, items = [0,1,1,1,1,0]\\n         */\\n        long ans = 0;\\n        int count = len-1; // start from the biggest value\\n        while(orders > 0) {\\n            // number of elements with same value\\n            int num = len - count;\\n            // number of loops current value needed\\n            long loop = orders/num;\\n            // remain orders after loop\\n            long remain = orders%num;\\n\\n            // the offset between current value and next value\\n            long offset = item[count] - item[count - 1];\\n\\n            // If the current value is reduced to the same as the next value, end the loop\\n            if(loop >= offset) {\\n                loop = offset;\\n                remain = 0;\\n            }\\n\\n            // add loop value and remain value\\n            ans += num*(item[count]+item[count]-loop+1)*loop/2 + remain*(item[count]-loop);\\n            orders -= loop*num+remain;\\n\\n            count--;\\n        }\\n\\n        return (int)(ans%1000000007);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160163,
                "title": "c-easy-map",
                "content": "```\\nclass Solution {\\n  \\n    const int mod_val = 1000000007;\\npublic:\\n    long long getASum(int n){\\n\\treturn (((long long)n * ( 1 + n)) / 2);\\n }\\n int maxProfit(vector<int>& inventory, int orders) {\\n    \\tmap<int,int> map;\\n\\t\\tint order_count = 0, res = 0;\\n\\t\\t\\n        for (auto it = rbegin(inventory); it != rend(inventory); ++it){\\n\\t\\t\\tmap[*it]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (auto it = map.rbegin(); it != map.rend() && orders > 0; ++it){\\n            auto prev = it;\\n            ++prev;\\n            int count = it->second;\\n            int curr_orders = count * (it->first - prev->first);\\n            if (prev != map.rend() && orders > curr_orders){\\n                res = (res + min(count,orders)  * (getASum(it->first) - getASum(prev->first))) % mod_val;\\n                orders -= curr_orders;\\n                prev->second += count;\\n            }\\n            else{\\n                int remainder  = orders % count;\\n                int seed =  it->first - (orders )/ count; \\n                res = (res + ((long)remainder * seed + count *(getASum(it->first) - getASum(seed))) % mod_val) % mod_val;\\n                orders = 0; \\n            }\\n        }\\n        \\n       \\treturn res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n    const int mod_val = 1000000007;\\npublic:\\n    long long getASum(int n){\\n\\treturn (((long long)n * ( 1 + n)) / 2);\\n }",
                "codeTag": "Java"
            },
            {
                "id": 1158741,
                "title": "simple-cpp-solution-using-value-count-map-with-detailed-explanation-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    long long getSum(long long num)\\n    {return num * (num+1) / 2;}\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        map<int, int> mp;\\n        //get count of each element\\n        for(int i : inventory)\\n            mp[i]++;\\n        \\n        //Iterate count from behind\\n        auto itr = mp.rbegin();\\n        const int MOD = 1e9+7;\\n        long long res = 0;\\n        \\n        //Iterate as long as we have orders remaining.\\n        while(orders > 0)\\n        {\\n            //Get the current element and its count.\\n            long long curr = itr->first, count = itr->second;\\n            \\n            //Move iterator by 1 and get next element\\'s value\\n            itr = next(itr, 1);\\n            long long next = itr != mp.rend() ? itr->first : 0;\\n            \\n            //Calculate total number of balls that you can fill.\\n            long long totalBallsAvailable = count * (curr - next);\\n            \\n            //Order can consume all the available balls\\n            if(orders >= totalBallsAvailable)\\n            {\\n                res = (res + count * (getSum(curr) - getSum(next))) % MOD;\\n                \\n                //Add the current count to next element and deduct the number of balls filled from order.\\n                itr->second += count;\\n                orders -= totalBallsAvailable;\\n            }\\n            //Else we have more balls than we need.\\n            else\\n            {\\n                //Calculate number of orders current count can fill and remaining orders after we fill with current count.\\n                long long numOfOrdersCurrCanFulfill = orders/count, remainingOrders = orders % count;\\n\\n                //Fill the orders with current count\\n                res = (res + (count * ( getSum(curr) - getSum(curr - numOfOrdersCurrCanFulfill) ) ) ) % MOD;\\n                //Fill the orders with remaining balls.\\n                res = (res + (remainingOrders * (curr - numOfOrdersCurrCanFulfill) ) ) % MOD;\\n                \\n                orders = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long getSum(long long num)\\n    {return num * (num+1) / 2;}\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        map<int, int> mp;\\n        //get count of each element\\n        for(int i : inventory)\\n            mp[i]++;\\n        \\n        //Iterate count from behind\\n        auto itr = mp.rbegin();\\n        const int MOD = 1e9+7;\\n        long long res = 0;\\n        \\n        //Iterate as long as we have orders remaining.\\n        while(orders > 0)\\n        {\\n            //Get the current element and its count.\\n            long long curr = itr->first, count = itr->second;\\n            \\n            //Move iterator by 1 and get next element\\'s value\\n            itr = next(itr, 1);\\n            long long next = itr != mp.rend() ? itr->first : 0;\\n            \\n            //Calculate total number of balls that you can fill.\\n            long long totalBallsAvailable = count * (curr - next);\\n            \\n            //Order can consume all the available balls\\n            if(orders >= totalBallsAvailable)\\n            {\\n                res = (res + count * (getSum(curr) - getSum(next))) % MOD;\\n                \\n                //Add the current count to next element and deduct the number of balls filled from order.\\n                itr->second += count;\\n                orders -= totalBallsAvailable;\\n            }\\n            //Else we have more balls than we need.\\n            else\\n            {\\n                //Calculate number of orders current count can fill and remaining orders after we fill with current count.\\n                long long numOfOrdersCurrCanFulfill = orders/count, remainingOrders = orders % count;\\n\\n                //Fill the orders with current count\\n                res = (res + (count * ( getSum(curr) - getSum(curr - numOfOrdersCurrCanFulfill) ) ) ) % MOD;\\n                //Fill the orders with remaining balls.\\n                res = (res + (remainingOrders * (curr - numOfOrdersCurrCanFulfill) ) ) % MOD;\\n                \\n                orders = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136773,
                "title": "c-nlogn-greedy-with-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    const long M=1e9+7;\\n    long long  getrangesum(long long first,long long  second)\\n    {   \\n        return ((first+1)*first-(second+1)*second)/2;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(),inventory.end(),greater<int>());\\n        int n=inventory.size();\\n        inventory.push_back(0);\\n        \\n        long long  prev=0;\\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int first=inventory[i];\\n            int second=inventory[i+1];\\n            long long winsum=getrangesum(first,second);\\n            prev++;\\n          \\n            if(prev*(first-second)<=orders)\\n            {\\n                ans=(ans+(prev*winsum))%M;\\n                orders-=prev*(first-second);\\n                \\n            }\\n            else\\n            {   \\n                long long  dividen,rem=0;\\n                dividen=orders/prev,rem=orders%prev;\\n                ans=(ans+(prev*getrangesum(first,first-dividen)))%M;\\n                ans=(ans+((first-dividen)*rem))%M;\\n                break;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long M=1e9+7;\\n    long long  getrangesum(long long first,long long  second)\\n    {   \\n        return ((first+1)*first-(second+1)*second)/2;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(),inventory.end(),greater<int>());\\n        int n=inventory.size();\\n        inventory.push_back(0);\\n        \\n        long long  prev=0;\\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int first=inventory[i];\\n            int second=inventory[i+1];\\n            long long winsum=getrangesum(first,second);\\n            prev++;\\n          \\n            if(prev*(first-second)<=orders)\\n            {\\n                ans=(ans+(prev*winsum))%M;\\n                orders-=prev*(first-second);\\n                \\n            }\\n            else\\n            {   \\n                long long  dividen,rem=0;\\n                dividen=orders/prev,rem=orders%prev;\\n                ans=(ans+(prev*getrangesum(first,first-dividen)))%M;\\n                ans=(ans+((first-dividen)*rem))%M;\\n                break;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060970,
                "title": "python-binary-search",
                "content": "Python binary search based on https://www.krammerliu.com/blog/leetcode-1648-sell-diminishing-valued-colored-balls/\\n\\n        \\'\\'\\'\\n        low = 0\\n        high = int(1e9)\\n        \\n        while low < high:\\n            mid = (low+high)//2\\n            \\n            # find total number of balls > mid\\n            s = 0\\n            for i in inventory:\\n                if i > mid:\\n                    s += i-mid\\n            \\n            if s > orders:\\n                low = mid+1\\n            else:\\n                high = mid\\n            \\n            \\n        mid = (low+high)//2    \\n           \\n        # count all the balls above mid\\n        ans = 0 \\n        for i in inventory:\\n            if i > mid:\\n                ans += i*(i+1)//2 - mid*(mid+1)//2\\n                orders -= i-mid\\n        \\n        # remaining balls equal to mid\\n        ans += orders*mid\\n        return int(ans)%(10**9 + 7)\\n        \\'\\'\\'",
                "solutionTags": [],
                "code": "Python binary search based on https://www.krammerliu.com/blog/leetcode-1648-sell-diminishing-valued-colored-balls/\\n\\n        \\'\\'\\'\\n        low = 0\\n        high = int(1e9)\\n        \\n        while low < high:\\n            mid = (low+high)//2\\n            \\n            # find total number of balls > mid\\n            s = 0\\n            for i in inventory:\\n                if i > mid:\\n                    s += i-mid\\n            \\n            if s > orders:\\n                low = mid+1\\n            else:\\n                high = mid\\n            \\n            \\n        mid = (low+high)//2    \\n           \\n        # count all the balls above mid\\n        ans = 0 \\n        for i in inventory:\\n            if i > mid:\\n                ans += i*(i+1)//2 - mid*(mid+1)//2\\n                orders -= i-mid\\n        \\n        # remaining balls equal to mid\\n        ans += orders*mid\\n        return int(ans)%(10**9 + 7)\\n        \\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1011297,
                "title": "o-n-c-156ms-beats-100",
                "content": "Similar to the median selection algorithm, we only need to recurse in one half of the array. The running time is O(n).\\n![image](https://assets.leetcode.com/users/images/a3d87dfa-937b-4b46-93f8-27ee4e1f7691_1613430584.6369374.png)\\n```\\ntypedef long long ll;\\nconst int P=1000000007;\\nint tot,val; ll num,ans;\\ntemplate<class T>\\nvoid Q(T a[],int s,int t){\\n\\tif (s>t){\\n\\t\\tint x=tot/num;\\n\\t\\tans+=num*(val*2-x+1)*x/2;\\n\\t\\tans+=tot%num*(val-x);\\n\\t\\treturn;\\n\\t}\\n\\tint i=s,j=t,tmp,m=a[s+rand()%(t-s+1)];\\n\\tdo {\\n\\t\\twhile (a[i]<m)++i;\\n\\t\\twhile (a[j]>m)--j;\\n\\t\\tif (i<=j){\\n\\t\\t\\ttmp=a[i]; a[i]=a[j]; a[j]=tmp;\\n\\t\\t\\t++i; --j;\\n\\t\\t}\\n\\t}while (i<=j);\\n\\tll c=num*(val-m)-(ll)m*(t-j);\\n\\tfor (int k=j+1;k<=t;++k)c+=a[k];\\n\\tif (c<=tot){\\n\\t\\ttot-=c; ans+=num*(val+m+1)*(val-m)/2;\\n\\t\\tfor (int k=j+1;k<=t;++k)ans+=(ll)(a[k]+m+1)*(a[k]-m)/2;\\n\\t\\tval=m; num+=t-j;\\n\\t\\tQ(a,s,j);\\n\\t}\\n\\telse {\\n\\t\\tif (a[j+1]==m)++j;\\n\\t\\tQ(a,j+1,t);\\n\\t}\\n}\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& a, int orders) {\\n\\t\\tint n=a.size(); tot=orders; ans=0; num=0;\\n\\t\\tQ(&a[0],0,n-1);\\n\\t\\treturn ans%P;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nconst int P=1000000007;\\nint tot,val; ll num,ans;\\ntemplate<class T>\\nvoid Q(T a[],int s,int t){\\n\\tif (s>t){\\n\\t\\tint x=tot/num;\\n\\t\\tans+=num*(val*2-x+1)*x/2;\\n\\t\\tans+=tot%num*(val-x);\\n\\t\\treturn;\\n\\t}\\n\\tint i=s,j=t,tmp,m=a[s+rand()%(t-s+1)];\\n\\tdo {\\n\\t\\twhile (a[i]<m)++i;\\n\\t\\twhile (a[j]>m)--j;\\n\\t\\tif (i<=j){\\n\\t\\t\\ttmp=a[i]; a[i]=a[j]; a[j]=tmp;\\n\\t\\t\\t++i; --j;\\n\\t\\t}\\n\\t}while (i<=j);\\n\\tll c=num*(val-m)-(ll)m*(t-j);\\n\\tfor (int k=j+1;k<=t;++k)c+=a[k];\\n\\tif (c<=tot){\\n\\t\\ttot-=c; ans+=num*(val+m+1)*(val-m)/2;\\n\\t\\tfor (int k=j+1;k<=t;++k)ans+=(ll)(a[k]+m+1)*(a[k]-m)/2;\\n\\t\\tval=m; num+=t-j;\\n\\t\\tQ(a,s,j);\\n\\t}\\n\\telse {\\n\\t\\tif (a[j+1]==m)++j;\\n\\t\\tQ(a,j+1,t);\\n\\t}\\n}\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& a, int orders) {\\n\\t\\tint n=a.size(); tot=orders; ans=0; num=0;\\n\\t\\tQ(&a[0],0,n-1);\\n\\t\\treturn ans%P;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936587,
                "title": "java-treemap-intuitive",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int maxProfit(int[] inventory, int orders) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < inventory.length; i++) {\\n            if(map.containsKey(inventory[i])) {\\n                map.put(inventory[i], map.get(inventory[i]) + 1);\\n            }else {\\n                map.put(inventory[i], 1);\\n            }\\n        }\\n        long profit = 0;\\n        while(orders > 0) {\\n            int FN = (int) map.lastKey();\\n            int FC = map.get(FN);\\n            map.remove(FN);\\n            int SN = map.size() > 0 ? (int) map.lastKey() : 0;\\n            int SC = map.size() > 0 ? map.get(SN) : 0;\\n            int rows = FN - SN;\\n            if(rows * FC >= orders) {\\n                int complete = orders / FC;\\n                int remainder = orders - complete * FC;\\n                profit += FC * (long)((complete * (long)(FN - complete + 1 + FN)) / 2);\\n                profit += (FN - complete) * (long)remainder;\\n                return (int)(profit % mod);\\n            }else {\\n                profit += FC * (long)((rows * (long)(FN - rows + 1 + FN)) / 2);\\n                orders -= rows * FC;\\n                map.put(SN, FC + SC);\\n            }\\n        }\\n        return (int)(profit % mod);\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/b2a41d08-02f8-4b47-8e8e-e091ad31e752_1612254581.652731.png)\\n\\nPick up the balls from block (Between level n and level n-1), it will have same cost. We will just need to multiply number of colors with number of balls to get our profit.\\n\\nKeep slicing the bars on levels until our orders get fulfilled. \\n\\nSpecial case will be when the block size (which we will be slicing) is exceeding the number of orders, in this case we will only take the balls as per our requirement and won\\'t slice the entire block.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int maxProfit(int[] inventory, int orders) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < inventory.length; i++) {\\n            if(map.containsKey(inventory[i])) {\\n                map.put(inventory[i], map.get(inventory[i]) + 1);\\n            }else {\\n                map.put(inventory[i], 1);\\n            }\\n        }\\n        long profit = 0;\\n        while(orders > 0) {\\n            int FN = (int) map.lastKey();\\n            int FC = map.get(FN);\\n            map.remove(FN);\\n            int SN = map.size() > 0 ? (int) map.lastKey() : 0;\\n            int SC = map.size() > 0 ? map.get(SN) : 0;\\n            int rows = FN - SN;\\n            if(rows * FC >= orders) {\\n                int complete = orders / FC;\\n                int remainder = orders - complete * FC;\\n                profit += FC * (long)((complete * (long)(FN - complete + 1 + FN)) / 2);\\n                profit += (FN - complete) * (long)remainder;\\n                return (int)(profit % mod);\\n            }else {\\n                profit += FC * (long)((rows * (long)(FN - rows + 1 + FN)) / 2);\\n                orders -= rows * FC;\\n                map.put(SN, FC + SC);\\n            }\\n        }\\n        return (int)(profit % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928534,
                "title": "c-using-map",
                "content": "\\n\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n = inventory.size();\\n        std::map<int, int> star; // key: ball counts of each color, value: count of color\\n        for(int i = 0; i < n; ++i) {\\n            ++star[inventory[i]];\\n        }\\n        \\n        long long res = 0;\\n        int mod = 1e9 + 7;\\n        int bought = 0;\\n        \\n        while(bought < orders) {\\n            \\n\\t\\t\\t// for each fetch round, we only fetch the most count color balls, the last element in map\\n            std::map<int,int>::reverse_iterator rit = star.rbegin();\\n            long long upper = rit->first; // the current most ball count (could be more than one color)\\n            if (upper <= 0) break;\\n            ++rit;\\n            long long low = (rit == star.rend() ? 0 : rit->first); // the current second most ball count\\n            \\n            int cnt = star[upper];\\n            int collect = upper - low; // for each color ball, we can only fetch this number, then the most will become second most. we can\\'t fetch more, need wait next iteration\\n            int total = collect * cnt;\\n            if (total + bought >= orders) { // if we can finish in this iteration\\n                int equallyfetch = (orders - bought) / cnt; // fetch this from all buffer\\n                int leftover = (orders - bought) % cnt;\\n\\n                res += cnt * ((upper + upper - equallyfetch + 1) * equallyfetch / 2);\\n                res += leftover * (upper - equallyfetch);\\n\\n                bought = orders;\\n                break;\\n\\n            } else {\\n                res += cnt * ((upper + low + 1) * collect / 2);\\n                bought += collect * cnt;\\n\\n                star[low] += cnt;\\n                star[upper] = 0;\\n                star.erase(upper);\\n            }\\n            \\n            res %= mod;\\n          \\n        }\\n        return res % mod;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n = inventory.size();\\n        std::map<int, int> star; // key: ball counts of each color, value: count of color\\n        for(int i = 0; i < n; ++i) {\\n            ++star[inventory[i]];\\n        }\\n        \\n        long long res = 0;\\n        int mod = 1e9 + 7;\\n        int bought = 0;\\n        \\n        while(bought < orders) {\\n            \\n\\t\\t\\t// for each fetch round, we only fetch the most count color balls, the last element in map\\n            std::map<int,int>::reverse_iterator rit = star.rbegin();\\n            long long upper = rit->first; // the current most ball count (could be more than one color)\\n            if (upper <= 0) break;\\n            ++rit;\\n            long long low = (rit == star.rend() ? 0 : rit->first); // the current second most ball count\\n            \\n            int cnt = star[upper];\\n            int collect = upper - low; // for each color ball, we can only fetch this number, then the most will become second most. we can\\'t fetch more, need wait next iteration\\n            int total = collect * cnt;\\n            if (total + bought >= orders) { // if we can finish in this iteration\\n                int equallyfetch = (orders - bought) / cnt; // fetch this from all buffer\\n                int leftover = (orders - bought) % cnt;\\n\\n                res += cnt * ((upper + upper - equallyfetch + 1) * equallyfetch / 2);\\n                res += leftover * (upper - equallyfetch);\\n\\n                bought = orders;\\n                break;\\n\\n            } else {\\n                res += cnt * ((upper + low + 1) * collect / 2);\\n                bought += collect * cnt;\\n\\n                star[low] += cnt;\\n                star[upper] = 0;\\n                star.erase(upper);\\n            }\\n            \\n            res %= mod;\\n          \\n        }\\n        return res % mod;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 927766,
                "title": "java-treemap",
                "content": "```\\n  public int maxProfit(int[] nums, int order) {\\n        if(nums == null || nums.length == 0 || order == 0) return 0;\\n        long sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>((a, b) -> (b - a));\\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int mod = 1000000007;\\n        \\n        while(order > 0){\\n           int curMax = map.firstKey();\\n           int freq = map.get(curMax);\\n           Integer second = map.ceilingKey(curMax - 1);\\n           if(second == null) second = 0;\\n            \\n           int diff = curMax - second;\\n            \\n           if(diff * freq <= order){\\n               order -= diff * freq;\\n               sum += ((sumFromStartToEnd(second + 1, curMax) % mod)  * freq) % mod;\\n               sum = sum % mod;\\n               if(second == 0) return (int)sum;\\n               map.put(second, map.get(second) + freq);\\n               map.remove(curMax);\\n           }else{              \\n               diff = order / freq;\\n               long res = order % freq;\\n               sum += ((sumFromStartToEnd(curMax - diff + 1, curMax) % mod) * freq) % mod;\\n               sum += (res * (curMax - diff)) % mod;\\n               return (int)sum;\\n           }\\n        }\\n        return (int)sum;\\n    }\\n    \\n    public long sumFromStartToEnd(long start, long end){\\n        return (end + start) * (end - start + 1)/2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int maxProfit(int[] nums, int order) {\\n        if(nums == null || nums.length == 0 || order == 0) return 0;\\n        long sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>((a, b) -> (b - a));\\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int mod = 1000000007;\\n        \\n        while(order > 0){\\n           int curMax = map.firstKey();\\n           int freq = map.get(curMax);\\n           Integer second = map.ceilingKey(curMax - 1);\\n           if(second == null) second = 0;\\n            \\n           int diff = curMax - second;\\n            \\n           if(diff * freq <= order){\\n               order -= diff * freq;\\n               sum += ((sumFromStartToEnd(second + 1, curMax) % mod)  * freq) % mod;\\n               sum = sum % mod;\\n               if(second == 0) return (int)sum;\\n               map.put(second, map.get(second) + freq);\\n               map.remove(curMax);\\n           }else{              \\n               diff = order / freq;\\n               long res = order % freq;\\n               sum += ((sumFromStartToEnd(curMax - diff + 1, curMax) % mod) * freq) % mod;\\n               sum += (res * (curMax - diff)) % mod;\\n               return (int)sum;\\n           }\\n        }\\n        return (int)sum;\\n    }\\n    \\n    public long sumFromStartToEnd(long start, long end){\\n        return (end + start) * (end - start + 1)/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927673,
                "title": "java-binary-search",
                "content": "Intuition:\\n1. Binary searach for the lowest inventory count that gives closest answer.\\n2. Add extra cost.\\n```\\npublic int maxProfit(int[] inventory, int orders) {\\n\\tlong lo = 0;\\n\\tlong hi = 0;\\n\\tfor (int i = 0; i < inventory.length; i++) {\\n\\t\\thi = Math.max(hi, inventory[i]);\\n\\t}\\n\\n\\t// 1. Binary search\\n\\twhile (lo < hi) {\\n\\t\\tlong mid = lo + (hi - lo) / 2;\\n\\t\\tlong count = getCount(inventory, mid);\\n\\t\\tif (count == orders) {\\n\\t\\t\\tlo = hi = mid;\\n\\t\\t} else if (count > orders) {\\n\\t\\t\\tlo = mid + 1;\\n\\t\\t} else {\\n\\t\\t\\thi = mid;\\n\\t\\t}\\n\\t}\\n\\n\\tlong res = 0;\\n\\tlong count = getCount(inventory, lo);\\n\\t// 2. Add extra cost.\\n\\tif (count < orders) {\\n\\t\\tres += (orders - count) * lo;\\n\\t}\\n\\n\\tfor (int i = 0; i < inventory.length; i++) {\\n\\t\\tif (inventory[i] > lo) {\\n//                long u = ((long) inventory[i] + 1) * (long) inventory[i] / 2;\\n//                long v = (lo + 1) * lo / 2;\\n//                long w = u - v;\\n//                res = (res + w) % 1_000_000_007;\\n\\t\\t\\tlong num = inventory[i] - lo;\\n\\t\\t\\tres = (res + num * (inventory[i] + lo + 1) / 2) % 1_000_000_007;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int) (res % 1_000_000_007);\\n}\\n\\nprivate long getCount(int[] inventory, long lo) {\\n\\tlong count = 0;\\n\\tfor (int i : inventory) {\\n\\t\\tif (i > lo) {\\n\\t\\t\\tcount += i - lo;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] inventory, int orders) {\\n\\tlong lo = 0;\\n\\tlong hi = 0;\\n\\tfor (int i = 0; i < inventory.length; i++) {\\n\\t\\thi = Math.max(hi, inventory[i]);\\n\\t}\\n\\n\\t// 1. Binary search\\n\\twhile (lo < hi) {\\n\\t\\tlong mid = lo + (hi - lo) / 2;\\n\\t\\tlong count = getCount(inventory, mid);\\n\\t\\tif (count == orders) {\\n\\t\\t\\tlo = hi = mid;\\n\\t\\t} else if (count > orders) {\\n\\t\\t\\tlo = mid + 1;\\n\\t\\t} else {\\n\\t\\t\\thi = mid;\\n\\t\\t}\\n\\t}\\n\\n\\tlong res = 0;\\n\\tlong count = getCount(inventory, lo);\\n\\t// 2. Add extra cost.\\n\\tif (count < orders) {\\n\\t\\tres += (orders - count) * lo;\\n\\t}\\n\\n\\tfor (int i = 0; i < inventory.length; i++) {\\n\\t\\tif (inventory[i] > lo) {\\n//                long u = ((long) inventory[i] + 1) * (long) inventory[i] / 2;\\n//                long v = (lo + 1) * lo / 2;\\n//                long w = u - v;\\n//                res = (res + w) % 1_000_000_007;\\n\\t\\t\\tlong num = inventory[i] - lo;\\n\\t\\t\\tres = (res + num * (inventory[i] + lo + 1) / 2) % 1_000_000_007;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int) (res % 1_000_000_007);\\n}\\n\\nprivate long getCount(int[] inventory, long lo) {\\n\\tlong count = 0;\\n\\tfor (int i : inventory) {\\n\\t\\tif (i > lo) {\\n\\t\\t\\tcount += i - lo;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359428,
                "title": "easiest-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }\\n\\n        int l = 0, r = max;\\n\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n\\n            if (isValid(inventory, orders, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        long res = 0;\\n\\n        for (int x : inventory) {\\n            if (x > l) {\\n                res += (long) (x + l + 1) * (x - l) / 2;\\n                res %= MOD;\\n                orders -= x - l;\\n            }\\n        }\\n\\n        res += (long) l * orders;\\n\\n        return (int) (res % MOD);\\n    }\\n\\n    private boolean isValid(int[] inventory, int orders, int mid) {\\n        long sum = 0;\\n\\n        for (int x : inventory) {\\n            sum += Math.max(x - mid, 0);\\n        }\\n\\n        return sum <= orders;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }\\n\\n        int l = 0, r = max;\\n\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n\\n            if (isValid(inventory, orders, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        long res = 0;\\n\\n        for (int x : inventory) {\\n            if (x > l) {\\n                res += (long) (x + l + 1) * (x - l) / 2;\\n                res %= MOD;\\n                orders -= x - l;\\n            }\\n        }\\n\\n        res += (long) l * orders;\\n\\n        return (int) (res % MOD);\\n    }\\n\\n    private boolean isValid(int[] inventory, int orders, int mid) {\\n        long sum = 0;\\n\\n        for (int x : inventory) {\\n            sum += Math.max(x - mid, 0);\\n        }\\n\\n        return sum <= orders;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174249,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }\\n\\n        int l = 0, r = max;\\n\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n\\n            if (isValid(inventory, orders, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        long res = 0;\\n\\n        for (int x : inventory) {\\n            if (x > l) {\\n                res += (long) (x + l + 1) * (x - l) / 2;\\n                res %= MOD;\\n                orders -= x - l;\\n            }\\n        }\\n\\n        res += (long) l * orders;\\n\\n        return (int) (res % MOD);\\n    }\\n\\n    private boolean isValid(int[] inventory, int orders, int mid) {\\n        long sum = 0;\\n\\n        for (int x : inventory) {\\n            sum += Math.max(x - mid, 0);\\n        }\\n\\n        return sum <= orders;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }\\n\\n        int l = 0, r = max;\\n\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n\\n            if (isValid(inventory, orders, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        long res = 0;\\n\\n        for (int x : inventory) {\\n            if (x > l) {\\n                res += (long) (x + l + 1) * (x - l) / 2;\\n                res %= MOD;\\n                orders -= x - l;\\n            }\\n        }\\n\\n        res += (long) l * orders;\\n\\n        return (int) (res % MOD);\\n    }\\n\\n    private boolean isValid(int[] inventory, int orders, int mid) {\\n        long sum = 0;\\n\\n        for (int x : inventory) {\\n            sum += Math.max(x - mid, 0);\\n        }\\n\\n        return sum <= orders;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807111,
                "title": "python3-solution-sorting-o-nlogn",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, A, O):\\n        nsum = lambda n : (n * (n + 1)) // 2\\n        A.sort(reverse = True)\\n        A.append(0)\\n        ans, mod = 0, 10 ** 9 + 7\\n        for i in range(len(A) - 1):\\n            if (i + 1) * (A[i] - A[i + 1]) > O:\\n                k, l = O // (i + 1), O % (i + 1)\\n                return (ans + (i + 1) * (nsum(A[i]) - nsum(A[i] - k)) + l * (A[i] - k)) % mod\\n            ans = (ans + (i + 1) * (nsum(A[i]) - nsum(A[i + 1]))) % mod\\n            O -= (i + 1) * (A[i] - A[i + 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, A, O):\\n        nsum = lambda n : (n * (n + 1)) // 2\\n        A.sort(reverse = True)\\n        A.append(0)\\n        ans, mod = 0, 10 ** 9 + 7\\n        for i in range(len(A) - 1):\\n            if (i + 1) * (A[i] - A[i + 1]) > O:\\n                k, l = O // (i + 1), O % (i + 1)\\n                return (ans + (i + 1) * (nsum(A[i]) - nsum(A[i] - k)) + l * (A[i] - k)) % mod\\n            ans = (ans + (i + 1) * (nsum(A[i]) - nsum(A[i + 1]))) % mod\\n            O -= (i + 1) * (A[i] - A[i + 1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482726,
                "title": "85-tc-and-84-sc-easy-python-solution",
                "content": "```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\tinventory.sort()\\n\\ti, j = 1, inventory[-1]\\n\\tans = -1\\n\\tdef isValid(v):\\n\\t\\tt = orders\\n\\t\\tm = bisect_left(inventory, v)\\n\\t\\tfor i in range(m, len(inventory)):\\n\\t\\t\\tt -= inventory[i] - v\\n\\t\\t\\tif(t <= 0):\\n\\t\\t\\t\\treturn 1\\n\\t\\tif(t <= len(inventory)-m):\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\twhile(i <= j):\\n\\t\\tmid = i + (j-i) // 2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tans = mid\\n\\t\\t\\ti = mid+1\\n\\t\\telse:\\n\\t\\t\\tj = mid-1\\n\\tif(ans == -1):\\n\\t\\treturn -1\\n\\tans, v = 0, ans\\n\\tfor i in range(len(inventory)):\\n\\t\\tif(inventory[i] > v):\\n\\t\\t\\tans = (ans + ((inventory[i]+1)*inventory[i])//2 - ((v+1)*v)//2) % 1000000007\\n\\t\\t\\torders -= inventory[i] - v\\n\\tif(orders):\\n\\t\\tans = (ans + v * orders) % 1000000007\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\tinventory.sort()\\n\\ti, j = 1, inventory[-1]\\n\\tans = -1\\n\\tdef isValid(v):\\n\\t\\tt = orders\\n\\t\\tm = bisect_left(inventory, v)\\n\\t\\tfor i in range(m, len(inventory)):\\n\\t\\t\\tt -= inventory[i] - v\\n\\t\\t\\tif(t <= 0):\\n\\t\\t\\t\\treturn 1\\n\\t\\tif(t <= len(inventory)-m):\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\twhile(i <= j):\\n\\t\\tmid = i + (j-i) // 2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tans = mid\\n\\t\\t\\ti = mid+1\\n\\t\\telse:\\n\\t\\t\\tj = mid-1\\n\\tif(ans == -1):\\n\\t\\treturn -1\\n\\tans, v = 0, ans\\n\\tfor i in range(len(inventory)):\\n\\t\\tif(inventory[i] > v):\\n\\t\\t\\tans = (ans + ((inventory[i]+1)*inventory[i])//2 - ((v+1)*v)//2) % 1000000007\\n\\t\\t\\torders -= inventory[i] - v\\n\\tif(orders):\\n\\t\\tans = (ans + v * orders) % 1000000007\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2401158,
                "title": "c-unordered-map-priority-queue-max-heap",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n    int maxProfit(vector<int>& inventory, int orders){\\n        unordered_map<int, int> mp;\\n        \\n        priority_queue<int> pq;\\n        for(int i = 0; i < inventory.size(); ++i){\\n            if(mp.find(inventory[i]) == mp.end())\\n                pq.push(inventory[i]);\\n            ++mp[inventory[i]];\\n        }\\n        \\n        int64_t cost = 0;\\n        while(orders > 0){\\n            int max_cost = pq.top();        pq.pop();\\n            int counter = mp[max_cost];\\n            \\n            mp[max_cost] = 0;   \\n            if(!pq.empty()){\\n                mp[pq.top()] += counter;\\n            }\\n            \\n            int64_t balls = (!pq.empty())?max_cost - pq.top(): max_cost;\\n            int64_t total_ball = counter * balls;\\n\\n            if(total_ball >= orders){\\n                int64_t complete = (orders / counter);\\n                int64_t start = max_cost - complete + 1;\\n\\n\\n                int64_t a = complete;\\n                int64_t b = (max_cost + start);\\n                int64_t current_cost = ((a * b)/2)% MOD;\\n                \\n                current_cost = (current_cost * counter)% MOD;\\n                \\n                orders = orders - (complete * counter);\\n                --start;\\n                for(int i = 0; i < orders; ++i){\\n                    current_cost = (current_cost + start) % MOD;\\n                }\\n\\n                cost = (cost + current_cost) % MOD;\\n                orders = 0;\\n            } else{\\n                int64_t s = (!pq.empty())? pq.top(): 0;\\n\\n                int64_t a = balls;\\n                int64_t b = (max_cost + s + 1);\\n\\n                int64_t current_cost = ((a * b)/2) % MOD;\\n                current_cost = (current_cost * counter) % MOD;\\n\\n                cost = (cost + current_cost) % MOD;\\n                orders -= total_ball;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```\\n\\n**Output**\\n```\\nRuntime: 338 ms, faster than 24.70% of C++ online submissions for Sell Diminishing-Valued Colored Balls.\\nMemory Usage: 88.7 MB, less than 11.24% of C++ online submissions for Sell Diminishing-Valued Colored Balls.\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n    int maxProfit(vector<int>& inventory, int orders){\\n        unordered_map<int, int> mp;\\n        \\n        priority_queue<int> pq;\\n        for(int i = 0; i < inventory.size(); ++i){\\n            if(mp.find(inventory[i]) == mp.end())\\n                pq.push(inventory[i]);\\n            ++mp[inventory[i]];\\n        }\\n        \\n        int64_t cost = 0;\\n        while(orders > 0){\\n            int max_cost = pq.top();        pq.pop();\\n            int counter = mp[max_cost];\\n            \\n            mp[max_cost] = 0;   \\n            if(!pq.empty()){\\n                mp[pq.top()] += counter;\\n            }\\n            \\n            int64_t balls = (!pq.empty())?max_cost - pq.top(): max_cost;\\n            int64_t total_ball = counter * balls;\\n\\n            if(total_ball >= orders){\\n                int64_t complete = (orders / counter);\\n                int64_t start = max_cost - complete + 1;\\n\\n\\n                int64_t a = complete;\\n                int64_t b = (max_cost + start);\\n                int64_t current_cost = ((a * b)/2)% MOD;\\n                \\n                current_cost = (current_cost * counter)% MOD;\\n                \\n                orders = orders - (complete * counter);\\n                --start;\\n                for(int i = 0; i < orders; ++i){\\n                    current_cost = (current_cost + start) % MOD;\\n                }\\n\\n                cost = (cost + current_cost) % MOD;\\n                orders = 0;\\n            } else{\\n                int64_t s = (!pq.empty())? pq.top(): 0;\\n\\n                int64_t a = balls;\\n                int64_t b = (max_cost + s + 1);\\n\\n                int64_t current_cost = ((a * b)/2) % MOD;\\n                current_cost = (current_cost * counter) % MOD;\\n\\n                cost = (cost + current_cost) % MOD;\\n                orders -= total_ball;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```\n```\\nRuntime: 338 ms, faster than 24.70% of C++ online submissions for Sell Diminishing-Valued Colored Balls.\\nMemory Usage: 88.7 MB, less than 11.24% of C++ online submissions for Sell Diminishing-Valued Colored Balls.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119754,
                "title": "c-greedy-sorting-priority-queue-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(long long n, long long m, int cnt){\\n        int mod=1e9+7;\\n        long long x=(n*(n+1)/2);\\n        long long y=(m*(m+1)/2);\\n        //cout<<n<<\" \"<<m<<\" \"<<cnt<<\" \"<<x-y<<endl;\\n        return ((x-y)*cnt)%mod;\\n    }\\n    \\n    int maxProfit(vector<int>& nums, int orders) {\\n        int n=nums.size();\\n        long long cost=0;\\n        priority_queue<pair<long long,long long>> pq;\\n        sort(nums.begin(),nums.end());\\n        int mod=1e9+7;\\n        long long prev=nums[0],cnt=1;\\n        for(int i=1;i<n;i++){\\n            if(prev==nums[i]){\\n                cnt++;\\n            }else{\\n                pq.push({prev,cnt});\\n                prev=nums[i];\\n                cnt=1;\\n            }\\n        }\\n        \\n        pq.push({prev,cnt});\\n        pq.push({0,0});\\n        \\n        while(pq.size()>1){\\n            pair<long,long> top=pq.top();\\n            pq.pop();\\n            pair<long,long> second_top=pq.top();\\n            pq.pop();\\n            long long cnt=(long long)(top.first-second_top.first)*top.second;\\n            if(cnt>=orders){\\n                long long x=orders/top.second,y=orders%top.second;\\n                if(x!=0){\\n                    //cout<<cost<<endl;\\n                    cost+=func(top.first,top.first-x,top.second)%mod;\\n                    //cout<<cost<<endl;\\n                    if(y!=0)\\n                        cost+=((top.first-x)*y)%mod;\\n                }else{\\n                    cost+=(top.first*y)%mod;\\n                }\\n                return cost%mod;\\n            }else{\\n                cost+=func(top.first,second_top.first,top.second)%mod;\\n                orders-=cnt;\\n                pq.push({second_top.first,top.second+second_top.second});\\n            }\\n        }\\n        \\n        return cost%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(long long n, long long m, int cnt){\\n        int mod=1e9+7;\\n        long long x=(n*(n+1)/2);\\n        long long y=(m*(m+1)/2);\\n        //cout<<n<<\" \"<<m<<\" \"<<cnt<<\" \"<<x-y<<endl;\\n        return ((x-y)*cnt)%mod;\\n    }\\n    \\n    int maxProfit(vector<int>& nums, int orders) {\\n        int n=nums.size();\\n        long long cost=0;\\n        priority_queue<pair<long long,long long>> pq;\\n        sort(nums.begin(),nums.end());\\n        int mod=1e9+7;\\n        long long prev=nums[0],cnt=1;\\n        for(int i=1;i<n;i++){\\n            if(prev==nums[i]){\\n                cnt++;\\n            }else{\\n                pq.push({prev,cnt});\\n                prev=nums[i];\\n                cnt=1;\\n            }\\n        }\\n        \\n        pq.push({prev,cnt});\\n        pq.push({0,0});\\n        \\n        while(pq.size()>1){\\n            pair<long,long> top=pq.top();\\n            pq.pop();\\n            pair<long,long> second_top=pq.top();\\n            pq.pop();\\n            long long cnt=(long long)(top.first-second_top.first)*top.second;\\n            if(cnt>=orders){\\n                long long x=orders/top.second,y=orders%top.second;\\n                if(x!=0){\\n                    //cout<<cost<<endl;\\n                    cost+=func(top.first,top.first-x,top.second)%mod;\\n                    //cout<<cost<<endl;\\n                    if(y!=0)\\n                        cost+=((top.first-x)*y)%mod;\\n                }else{\\n                    cost+=(top.first*y)%mod;\\n                }\\n                return cost%mod;\\n            }else{\\n                cost+=func(top.first,second_top.first,top.second)%mod;\\n                orders-=cnt;\\n                pq.push({second_top.first,top.second+second_top.second});\\n            }\\n        }\\n        \\n        return cost%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1960721,
                "title": "c-o-n-logn-with-verbose-comments-and-variable-names",
                "content": "Maybe it\\'ll be more easy for someone to grasp what\\'s happening\\n\\n```\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int modulo = 1000000007;\\n        \\n        int total = 0;\\n        \\n\\t\\t// descending order\\n        sort(inventory.begin(), inventory.end(), std::greater<int>());\\n        for (int i = 0; i < inventory.size();) {\\n            \\n            int columns = i + 1;\\n            // find next column w less elements so we can consume whole rows\\n            while (columns < inventory.size() && inventory[columns] == inventory[i]) {\\n                ++columns;\\n            }\\n            \\n            uint64_t current = inventory[i];\\n            uint64_t next = (columns < inventory.size()) ? inventory[columns] : 0;\\n            \\n            // number of available elements\\n            int available = (current - next) * columns;\\n            // actual required count which could be less than available\\n            int count = std::min(available, orders);\\n            \\n            // number of fully consumed rows\\n            int rows = count / columns;\\n            // number of elements not equal to row cnt, it means we will be full\\n            int leftover  = count % columns;\\n            \\n            // sum of element in each column: (Am + An) * (m - n + 1) / 2\\n            // total sum =  sum of column * colunbs\\n            uint64_t sum = (current + (current - rows + 1)) * rows / 2 * columns;\\n            if (leftover){\\n                // if there unequal number of elements left\\n                // then simply number of columns left * value of the row\\n                sum += (current - rows) * leftover;\\n            }\\n            \\n            total = (total + sum) % modulo;\\n            orders -= count;\\n            if (!orders) {\\n                break;\\n            }\\n            \\n            i = columns;\\n        }\\n\\n        return total;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int modulo = 1000000007;\\n        \\n        int total = 0;\\n        \\n\\t\\t// descending order\\n        sort(inventory.begin(), inventory.end(), std::greater<int>());\\n        for (int i = 0; i < inventory.size();) {\\n            \\n            int columns = i + 1;\\n            // find next column w less elements so we can consume whole rows\\n            while (columns < inventory.size() && inventory[columns] == inventory[i]) {\\n                ++columns;\\n            }\\n            \\n            uint64_t current = inventory[i];\\n            uint64_t next = (columns < inventory.size()) ? inventory[columns] : 0;\\n            \\n            // number of available elements\\n            int available = (current - next) * columns;\\n            // actual required count which could be less than available\\n            int count = std::min(available, orders);\\n            \\n            // number of fully consumed rows\\n            int rows = count / columns;\\n            // number of elements not equal to row cnt, it means we will be full\\n            int leftover  = count % columns;\\n            \\n            // sum of element in each column: (Am + An) * (m - n + 1) / 2\\n            // total sum =  sum of column * colunbs\\n            uint64_t sum = (current + (current - rows + 1)) * rows / 2 * columns;\\n            if (leftover){\\n                // if there unequal number of elements left\\n                // then simply number of columns left * value of the row\\n                sum += (current - rows) * leftover;\\n            }\\n            \\n            total = (total + sum) % modulo;\\n            orders -= count;\\n            if (!orders) {\\n                break;\\n            }\\n            \\n            i = columns;\\n        }\\n\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894536,
                "title": "python3-o-nlogn-with-explanation",
                "content": "One naive approach is to repeat for orders times, and each time, take the largest one, decrease it and place back to the array. This will take O(orders * logN) time complexity if using heap.\\nLet\\'s sort the array first, from max to min.\\n\\nOne important observation is that: if max of array is max1, second max is max2, then one can safely take the \"max\" for (max1 - max2) times, then the original max1 becomes max2.\\n[max1, max2, max3, max4, ...] --> [max2, max2, max3, max4, ...]\\nThen, we can safely take the first two elements for (max2 - max3) times, and the array becomes:\\n[max3, max3, max3, max4, ...]\\n\\nI hope you already found the rule. Let\\'s do the coding.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        n = len(inventory)\\n        inventory = sorted(inventory, reverse=True)\\n        inventory.append(0)\\n        \\n        score = 0\\n        for i in range(n):\\n            max1, max2 = inventory[i], inventory[i + 1]\\n            num = (i + 1) * (max1 - max2)\\n            if num < orders:\\n                score += (max1 + max2 + 1) * (max1 - max2) // 2 * (i + 1)\\n            else:\\n                num = orders\\n                lap = num // (i + 1)\\n                rem = num % (i + 1)\\n                score += (max1 + max1 - lap + 1) * lap // 2 * (i + 1)\\n                score += (max1 - lap) * rem\\n                break\\n                \\n            orders -= num\\n                \\n        return score % MOD\\n```\\n        \\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        n = len(inventory)\\n        inventory = sorted(inventory, reverse=True)\\n        inventory.append(0)\\n        \\n        score = 0\\n        for i in range(n):\\n            max1, max2 = inventory[i], inventory[i + 1]\\n            num = (i + 1) * (max1 - max2)\\n            if num < orders:\\n                score += (max1 + max2 + 1) * (max1 - max2) // 2 * (i + 1)\\n            else:\\n                num = orders\\n                lap = num // (i + 1)\\n                rem = num % (i + 1)\\n                score += (max1 + max1 - lap + 1) * lap // 2 * (i + 1)\\n                score += (max1 - lap) * rem\\n                break\\n                \\n            orders -= num\\n                \\n        return score % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842466,
                "title": "simple-c-without-binary-search-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int sum(int i) {\\n        //return sum of first i natural numbers;\\n        return ((long long) i * (i + 1)) / 2;\\n    }\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n = (int) inventory.size();\\n        sort(inventory.rbegin(), inventory.rend());\\n        inventory.push_back(0); n++;\\n        long long cnt = 1, ans = 0, MOD = 1e9 + 7;\\n        for (int i = 1; i < n; i++) {\\n            if (inventory[i] == inventory[i - 1]) {\\n                cnt++;\\n            } else {\\n                long long total = (inventory[i - 1] - inventory[i]) * cnt;\\n                if (orders >= total) {\\n                    ans += (((sum(inventory[i - 1]) -  sum(inventory[i])) % MOD) * cnt);\\n                    ans %= MOD;\\n                    orders -= total;\\n                } else {\\n                    int take = orders / cnt;\\n                    ans += (((sum(inventory[i - 1]) - sum(inventory[i - 1] - take)) % MOD) * cnt);\\n                    long long rem = orders % cnt;\\n                    ans += (rem * (inventory[i - 1] - take));\\n                    ans %= MOD;\\n                    break;\\n                }\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int sum(int i) {\\n        //return sum of first i natural numbers;\\n        return ((long long) i * (i + 1)) / 2;\\n    }\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n = (int) inventory.size();\\n        sort(inventory.rbegin(), inventory.rend());\\n        inventory.push_back(0); n++;\\n        long long cnt = 1, ans = 0, MOD = 1e9 + 7;\\n        for (int i = 1; i < n; i++) {\\n            if (inventory[i] == inventory[i - 1]) {\\n                cnt++;\\n            } else {\\n                long long total = (inventory[i - 1] - inventory[i]) * cnt;\\n                if (orders >= total) {\\n                    ans += (((sum(inventory[i - 1]) -  sum(inventory[i])) % MOD) * cnt);\\n                    ans %= MOD;\\n                    orders -= total;\\n                } else {\\n                    int take = orders / cnt;\\n                    ans += (((sum(inventory[i - 1]) - sum(inventory[i - 1] - take)) % MOD) * cnt);\\n                    long long rem = orders % cnt;\\n                    ans += (rem * (inventory[i - 1] - take));\\n                    ans %= MOD;\\n                    break;\\n                }\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836416,
                "title": "cpp-sort-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        long res=0,prev=0,curr,color=1;\\n        sort(inventory.begin(),inventory.end());\\n        for(int i=inventory.size()-1;i>=0&&orders>0;i--,color++){\\n            \\n            curr=inventory[i],prev = i>0?inventory[i-1]:0;\\n            long rounds=min(orders/color,curr-prev);\\n            orders-=(rounds*color);\\n               res = (res + (curr * (curr + 1) - (curr - rounds) * (curr - rounds + 1)) / 2 * color) % 1000000007;\\n            \\n            if(curr-prev>rounds){\\n                res=(res+(curr-rounds)*orders)%mod;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        long res=0,prev=0,curr,color=1;\\n        sort(inventory.begin(),inventory.end());\\n        for(int i=inventory.size()-1;i>=0&&orders>0;i--,color++){\\n            \\n            curr=inventory[i],prev = i>0?inventory[i-1]:0;\\n            long rounds=min(orders/color,curr-prev);\\n            orders-=(rounds*color);\\n               res = (res + (curr * (curr + 1) - (curr - rounds) * (curr - rounds + 1)) / 2 * color) % 1000000007;\\n            \\n            if(curr-prev>rounds){\\n                res=(res+(curr-rounds)*orders)%mod;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788319,
                "title": "c-o-nlongn",
                "content": "To obtain maximum profit you have to sort the array strting from n-1.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr, int order) {\\n\\t\\n\\t //Sorting of array to find maximum no of ball at last to start counting.\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n\\t\\t//Res  will store the final answer \\n        long res=0;\\n\\t\\t//color represent the type of color ball we take simultaneously \\n        long color=1;\\n        int i=n-1;\\n        while(i>=0 and order>0 )\\n        {\\n\\t\\t  //current point\\n            long curr=arr[i];\\n          \\n            long prev=i>0?arr[i-1]:0;\\n          //You have two choices weather you have full round or half round\\n\\t\\t  //Full round occur when the curr-prev> order/color.\\n\\t\\t  //It means you have to remove all the current balls\\n            long check_full_round1=order/color;\\n            long check_full_round2=curr-prev;\\n            \\n        //Taking minimum which help to decide weather you go for full or half round\\n            long full_round=min(check_full_round1,check_full_round2);\\n            \\n            \\n            //Decrese the number of balls=>round*order\\n            order-=full_round*color;\\n         \\n            //Count all  points\\n            res=(res+((curr*(curr+1)-(curr-full_round)*(curr-full_round+1))/2)*color)%1000000007;\\n            \\n            //if curr-prev> full_round means its time to fnd half round.\\n\\t\\t\\t//Its last time when we traverse b/c we have left with some value which less than curr-prev\\n            if(curr-prev>full_round){\\n                res=(res+order*(curr-full_round))%1000000007;\\n                break;\\n            }\\n            color++;\\n            i--;\\n            \\n            \\n        }\\n        return res;\\n        \\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr, int order) {\\n\\t\\n\\t //Sorting of array to find maximum no of ball at last to start counting.\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n\\t\\t//Res  will store the final answer \\n        long res=0;\\n\\t\\t//color represent the type of color ball we take simultaneously \\n        long color=1;\\n        int i=n-1;\\n        while(i>=0 and order>0 )\\n        {\\n\\t\\t  //current point\\n            long curr=arr[i];\\n          \\n            long prev=i>0?arr[i-1]:0;\\n          //You have two choices weather you have full round or half round\\n\\t\\t  //Full round occur when the curr-prev> order/color.\\n\\t\\t  //It means you have to remove all the current balls\\n            long check_full_round1=order/color;\\n            long check_full_round2=curr-prev;\\n            \\n        //Taking minimum which help to decide weather you go for full or half round\\n            long full_round=min(check_full_round1,check_full_round2);\\n            \\n            \\n            //Decrese the number of balls=>round*order\\n            order-=full_round*color;\\n         \\n            //Count all  points\\n            res=(res+((curr*(curr+1)-(curr-full_round)*(curr-full_round+1))/2)*color)%1000000007;\\n            \\n            //if curr-prev> full_round means its time to fnd half round.\\n\\t\\t\\t//Its last time when we traverse b/c we have left with some value which less than curr-prev\\n            if(curr-prev>full_round){\\n                res=(res+order*(curr-full_round))%1000000007;\\n                break;\\n            }\\n            color++;\\n            i--;\\n            \\n            \\n        }\\n        return res;\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663686,
                "title": "ruby-arithmatic-sum",
                "content": "```\\n# @param {Integer[]} inventory\\n# @param {Integer} orders\\n# @return {Integer}\\ndef max_profit(inventory, orders)\\n  res = 0\\n  inventory.sort!.reverse!\\n  inventory << 0\\n  k = 1 \\n  \\n  # First iteration array: [10, 7, 3, 0], k = 1\\n  # Second iteration: [7, 7, 3, 0], k = 2 because you can decrease both 7s at the same time\\n  # Third iteration: [3, 3, 3, 0], k = 3 because you can decrease three 3s at the same time\\n  inventory.each_with_index do |num, i|\\n    next_num = inventory[i + 1]\\n    \\n    if next_num && num > next_num\\n      diff = num - next_num\\n      \\n      if k * diff < orders\\n        res += k * arithematic_sum(num, next_num)\\n        orders -= k * diff\\n      else\\n        q, r = orders.divmod(k)\\n\\n        res += k * arithematic_sum(num, num - q)\\n        res += r * (num - q)\\n\\n        return res % (10**9 + 7)\\n      end\\n    end\\n    \\n    k += 1\\n  end\\nend\\n\\ndef arithematic_sum(num1, num2)\\n  diff = num1 - num2\\n  \\n  (num1 + num2 + 1) * diff / 2\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} inventory\\n# @param {Integer} orders\\n# @return {Integer}\\ndef max_profit(inventory, orders)\\n  res = 0\\n  inventory.sort!.reverse!\\n  inventory << 0\\n  k = 1 \\n  \\n  # First iteration array: [10, 7, 3, 0], k = 1\\n  # Second iteration: [7, 7, 3, 0], k = 2 because you can decrease both 7s at the same time\\n  # Third iteration: [3, 3, 3, 0], k = 3 because you can decrease three 3s at the same time\\n  inventory.each_with_index do |num, i|\\n    next_num = inventory[i + 1]\\n    \\n    if next_num && num > next_num\\n      diff = num - next_num\\n      \\n      if k * diff < orders\\n        res += k * arithematic_sum(num, next_num)\\n        orders -= k * diff\\n      else\\n        q, r = orders.divmod(k)\\n\\n        res += k * arithematic_sum(num, num - q)\\n        res += r * (num - q)\\n\\n        return res % (10**9 + 7)\\n      end\\n    end\\n    \\n    k += 1\\n  end\\nend\\n\\ndef arithematic_sum(num1, num2)\\n  diff = num1 - num2\\n  \\n  (num1 + num2 + 1) * diff / 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1613287,
                "title": "java-sort-greedy",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        long MOD = (long)1e9 + 7;\\n        long totalValue = 0;\\n        \\n        Arrays.sort(inventory);\\n        \\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            count++;\\n            if (i == 0 || inventory[i] > inventory[i - 1]){\\n                long diff = i == 0 ? inventory[i] : inventory[i] - inventory[i - 1];\\n                if (count * diff < orders) {\\n                    totalValue += \\n                        (2 * inventory[i] - diff + 1)\\n                        * diff * count / 2 % MOD;\\n                    orders -= count * diff;\\n                } else {\\n                    diff = orders / count;\\n                    long remainder = orders % count;\\n                                    \\n                    totalValue += \\n                        (2 * inventory[i] - diff + 1)\\n                        * diff * count / 2 % MOD;\\n                    totalValue += (inventory[i] - diff) * remainder % MOD;\\n                    totalValue %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        return (int)totalValue;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        long MOD = (long)1e9 + 7;\\n        long totalValue = 0;\\n        \\n        Arrays.sort(inventory);\\n        \\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            count++;\\n            if (i == 0 || inventory[i] > inventory[i - 1]){\\n                long diff = i == 0 ? inventory[i] : inventory[i] - inventory[i - 1];\\n                if (count * diff < orders) {\\n                    totalValue += \\n                        (2 * inventory[i] - diff + 1)\\n                        * diff * count / 2 % MOD;\\n                    orders -= count * diff;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1610777,
                "title": "python-o-nlogn-readable-code",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        inventory = Counter(inventory)\\n        inventory = list(inventory.items())\\n        inventory = sorted(inventory, reverse=True, key= lambda x: x[0])\\n        queue = deque(inventory)\\n        ans = 0\\n               \\n        while orders > 0 and queue:\\n            \\n            maxVal, maxValFreq = queue.popleft()\\n            secondMax, secondMaxFreq = queue[0] if len(queue) else (0,0)\\n            diff = maxVal - secondMax\\n            consumable = diff * maxValFreq\\n\\n            if orders > consumable:\\n\\n                # add all items from first ~ second + 1\\n                ans += maxValFreq * (maxVal + secondMax + 1) * diff // 2\\n                queue[0] = (secondMax, maxValFreq + secondMaxFreq)\\n                orders -= consumable\\n\\n            else: # orders <= consumable\\n                \\n                quotient = orders // maxValFreq\\n                remainder = orders % maxValFreq\\n                ans += maxValFreq * (maxVal + maxVal - quotient + 1) * quotient // 2\\n                ans += remainder * ( maxVal - quotient )\\n                orders = 0\\n                break\\n        \\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        inventory = Counter(inventory)\\n        inventory = list(inventory.items())\\n        inventory = sorted(inventory, reverse=True, key= lambda x: x[0])\\n        queue = deque(inventory)\\n        ans = 0\\n               \\n        while orders > 0 and queue:\\n            \\n            maxVal, maxValFreq = queue.popleft()\\n            secondMax, secondMaxFreq = queue[0] if len(queue) else (0,0)\\n            diff = maxVal - secondMax\\n            consumable = diff * maxValFreq\\n\\n            if orders > consumable:\\n\\n                # add all items from first ~ second + 1\\n                ans += maxValFreq * (maxVal + secondMax + 1) * diff // 2\\n                queue[0] = (secondMax, maxValFreq + secondMaxFreq)\\n                orders -= consumable\\n\\n            else: # orders <= consumable\\n                \\n                quotient = orders // maxValFreq\\n                remainder = orders % maxValFreq\\n                ans += maxValFreq * (maxVal + maxVal - quotient + 1) * quotient // 2\\n                ans += remainder * ( maxVal - quotient )\\n                orders = 0\\n                break\\n        \\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596375,
                "title": "c-binary-serach-with-comments-o-n-log-m-beats-100",
                "content": "```\\n#define MODULO (int)(pow(10, 9) + 7)\\n\\nint maxProfit(int* inventory, int inventorySize, int orders){\\n    // Get the maxium number of inventory\\n    int max = 0;\\n    int i;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > max) {\\n            max = inventory[i];\\n        }\\n    }\\n    int min = 0;\\n    int value; // value of balls\\n    long num; // the number of balls that the price is larger than value\\n    \\n    // Binary search the value between min and max\\n    // Count num to find the value that makes num and orders are closest\\n    // s.t. num(value) <= orders < num(value+1)\\n    while (min <= max) {\\n        num = 0;\\n        value = (min + max) / 2;\\n        // Count the num that price is larger than value\\n        for (i=0; i<inventorySize; i++) {\\n            if (inventory[i] > value) {\\n                num += inventory[i] - value;\\n            }\\n        }\\n        if (num == orders) {        // value found\\n            break;\\n        } else if (num < orders) {  // value is larger than excepted\\n            max = value - 1;\\n        } else {                    // value is smaller thanexcepted\\n            min = value + 1;\\n        }\\n    }\\n    \\n    long profit = 0;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > value) {\\n            // Calculate the profit by summing the arithmetic series\\n            profit += (long)(inventory[i] + (value + 1)) * (long)(inventory[i]-value) / 2;\\n        }\\n    }\\n    \\n    // Amend the profit when the num != orders\\n    if (num > orders) {\\n        profit = (profit - (num-orders) * (value + 1)) % MODULO;\\n    } else if (num < orders) {\\n        profit = (profit + (orders-num) * (value)) % MODULO;\\n    } else {\\n        profit %= MODULO;\\n    }\\n\\n    return (int)profit;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\n#define MODULO (int)(pow(10, 9) + 7)\\n\\nint maxProfit(int* inventory, int inventorySize, int orders){\\n    // Get the maxium number of inventory\\n    int max = 0;\\n    int i;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > max) {\\n            max = inventory[i];\\n        }\\n    }\\n    int min = 0;\\n    int value; // value of balls\\n    long num; // the number of balls that the price is larger than value\\n    \\n    // Binary search the value between min and max\\n    // Count num to find the value that makes num and orders are closest\\n    // s.t. num(value) <= orders < num(value+1)\\n    while (min <= max) {\\n        num = 0;\\n        value = (min + max) / 2;\\n        // Count the num that price is larger than value\\n        for (i=0; i<inventorySize; i++) {\\n            if (inventory[i] > value) {\\n                num += inventory[i] - value;\\n            }\\n        }\\n        if (num == orders) {        // value found\\n            break;\\n        } else if (num < orders) {  // value is larger than excepted\\n            max = value - 1;\\n        } else {                    // value is smaller thanexcepted\\n            min = value + 1;\\n        }\\n    }\\n    \\n    long profit = 0;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > value) {\\n            // Calculate the profit by summing the arithmetic series\\n            profit += (long)(inventory[i] + (value + 1)) * (long)(inventory[i]-value) / 2;\\n        }\\n    }\\n    \\n    // Amend the profit when the num != orders\\n    if (num > orders) {\\n        profit = (profit - (num-orders) * (value + 1)) % MODULO;\\n    } else if (num < orders) {\\n        profit = (profit + (orders-num) * (value)) % MODULO;\\n    } else {\\n        profit %= MODULO;\\n    }\\n\\n    return (int)profit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568384,
                "title": "c-priority-queue-tle-can-we-improve-this",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int modu = pow(10,9)+7;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        priority_queue<long> pq;\\n        for( int i = 0 ; i< inventory.size() ; i++ ){\\n            pq.push( inventory[i] );\\n        }\\n        long rem = orders;\\n        long amount = 0;\\n        while( !pq.empty() || rem > 0 ){\\n            long a = pq.top(); pq.pop();\\n            if( pq.empty() ){\\n                amount += ( a*(a+1)/2 - (a-rem)*(a-rem+1)/2 );\\n                amount = amount%modu;\\n                break;\\n            }\\n            long b = pq.top();\\n            if( a-b+1 < rem ){\\n                amount += ( a*(a+1)/2 - (b-1)*b/2 );\\n                amount = amount%modu;\\n                rem -= (a-b+1);\\n                a = b-1;\\n                if( a ){\\n                    pq.push(a);\\n                }\\n                \\n            }else{\\n                amount += ( a*(a+1)/2 - (a-rem)*(a-rem+1)/2 );\\n                amount = amount%modu;\\n                break;\\n            }\\n        }\\n        \\n        return amount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int modu = pow(10,9)+7;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        priority_queue<long> pq;\\n        for( int i = 0 ; i< inventory.size() ; i++ ){\\n            pq.push( inventory[i] );\\n        }\\n        long rem = orders;\\n        long amount = 0;\\n        while( !pq.empty() || rem > 0 ){\\n            long a = pq.top(); pq.pop();\\n            if( pq.empty() ){\\n                amount += ( a*(a+1)/2 - (a-rem)*(a-rem+1)/2 );\\n                amount = amount%modu;\\n                break;\\n            }\\n            long b = pq.top();\\n            if( a-b+1 < rem ){\\n                amount += ( a*(a+1)/2 - (b-1)*b/2 );\\n                amount = amount%modu;\\n                rem -= (a-b+1);\\n                a = b-1;\\n                if( a ){\\n                    pq.push(a);\\n                }\\n                \\n            }else{\\n                amount += ( a*(a+1)/2 - (a-rem)*(a-rem+1)/2 );\\n                amount = amount%modu;\\n                break;\\n            }\\n        }\\n        \\n        return amount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544374,
                "title": "python-sorting-greedy-beats-95-detailed-comments",
                "content": "```\\n# N: # of balls in the inventory\\n# Time complexity: O(N log N); sorting + O(N); worst case iteration\\n# Space complexity: O(1); a few int variables\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort()\\n        # The number of colors of the balls per iteration\\n        groupsize = 1\\n        res = 0\\n        mod = 10**9 + 7\\n        while orders > 0:\\n            # number of balls in the beginning for this iteration\\n            curval = inventory[-groupsize]\\n            # count and increment groupsize by the number of duplicates\\n            while groupsize < len(inventory) and inventory[-groupsize-1] == curval:\\n                groupsize += 1\\n\\t\\t\\t\\t\\n            # if # of orders don\\'t exceed the total # of balls subtracting, minval would be the next largest number of balls,\\n            # and height would be the difference between the current # of balls and minval, and remainder would be 0\\n            minval = inventory[-groupsize-1] if groupsize < len(inventory) else 0\\n            height = curval - minval\\n            remainder = 0\\n            # if not, height should decrease to the # of orders divided by groupsize and the remainder will be stored\\n            # Also, minval should be updated correspondingly\\n            if orders < groupsize * height:\\n                height = orders // groupsize\\n                remainder = orders % groupsize\\n                minval = curval - height\\n\\t\\t\\t\\t\\n            # Use the formula sum 1 to n = n * (n+1) / 2 with curval and minval to find the adding values for the iteration\\n            res += ((((curval * (curval+1) - minval * (minval+1)) * groupsize) >> 1) + minval * remainder) % mod\\n            # Decrement by the # of subtracted orders\\n            orders -= height * groupsize + remainder\\n            # Decrement the next curval to the next minval\\n            # No need to decrement the entire range of the list since only curval will be used for comparisons\\n            inventory[-groupsize] = minval\\n        return res % mod\\n```",
                "solutionTags": [],
                "code": "```\\n# N: # of balls in the inventory\\n# Time complexity: O(N log N); sorting + O(N); worst case iteration\\n# Space complexity: O(1); a few int variables\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort()\\n        # The number of colors of the balls per iteration\\n        groupsize = 1\\n        res = 0\\n        mod = 10**9 + 7\\n        while orders > 0:\\n            # number of balls in the beginning for this iteration\\n            curval = inventory[-groupsize]\\n            # count and increment groupsize by the number of duplicates\\n            while groupsize < len(inventory) and inventory[-groupsize-1] == curval:\\n                groupsize += 1\\n\\t\\t\\t\\t\\n            # if # of orders don\\'t exceed the total # of balls subtracting, minval would be the next largest number of balls,\\n            # and height would be the difference between the current # of balls and minval, and remainder would be 0\\n            minval = inventory[-groupsize-1] if groupsize < len(inventory) else 0\\n            height = curval - minval\\n            remainder = 0\\n            # if not, height should decrease to the # of orders divided by groupsize and the remainder will be stored\\n            # Also, minval should be updated correspondingly\\n            if orders < groupsize * height:\\n                height = orders // groupsize\\n                remainder = orders % groupsize\\n                minval = curval - height\\n\\t\\t\\t\\t\\n            # Use the formula sum 1 to n = n * (n+1) / 2 with curval and minval to find the adding values for the iteration\\n            res += ((((curval * (curval+1) - minval * (minval+1)) * groupsize) >> 1) + minval * remainder) % mod\\n            # Decrement by the # of subtracted orders\\n            orders -= height * groupsize + remainder\\n            # Decrement the next curval to the next minval\\n            # No need to decrement the entire range of the list since only curval will be used for comparisons\\n            inventory[-groupsize] = minval\\n        return res % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478237,
                "title": "python-sorting-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        \\n        res = 0\\n        for i in range(len(inventory)-1):\\n            curr_inv, next_inv = inventory[i], inventory[i+1]\\n            num_balls_of_same_color = i + 1\\n            available_orders = (curr_inv - next_inv) * num_balls_of_same_color\\n            orders_taken_from_everyone, rem_orders = divmod(\\n                min(orders, available_orders), num_balls_of_same_color\\n            )\\n            # take orders from every ball of the same color\\n            res += (\\n                (2 * curr_inv - (orders_taken_from_everyone-1)) * orders_taken_from_everyone // 2 * \\\\\\n                    num_balls_of_same_color\\n            )\\n            res %= 1000000007\\n            \\n            # take the remaining orders\\n            if rem_orders:\\n                curr_inv -= orders_taken_from_everyone\\n                res += curr_inv * rem_orders\\n                res %= 1000000007\\n            \\n            orders -= min(orders, available_orders)\\n\\n            if orders == 0:\\n                break\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        \\n        res = 0\\n        for i in range(len(inventory)-1):\\n            curr_inv, next_inv = inventory[i], inventory[i+1]\\n            num_balls_of_same_color = i + 1\\n            available_orders = (curr_inv - next_inv) * num_balls_of_same_color\\n            orders_taken_from_everyone, rem_orders = divmod(\\n                min(orders, available_orders), num_balls_of_same_color\\n            )\\n            # take orders from every ball of the same color\\n            res += (\\n                (2 * curr_inv - (orders_taken_from_everyone-1)) * orders_taken_from_everyone // 2 * \\\\\\n                    num_balls_of_same_color\\n            )\\n            res %= 1000000007\\n            \\n            # take the remaining orders\\n            if rem_orders:\\n                curr_inv -= orders_taken_from_everyone\\n                res += curr_inv * rem_orders\\n                res %= 1000000007\\n            \\n            orders -= min(orders, available_orders)\\n\\n            if orders == 0:\\n                break\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379333,
                "title": "c-solution-using-binary-search",
                "content": "```\\nlong long int MOD=1e9 + 7;\\n    bool check(vector<int> &inventory,int assumecutength,int orders){\\n      \\n        int weget=0;\\n        \\n        \\n        for(auto x: inventory){\\n            if(x>=assumecutength){\\n                weget+=(x - assumecutength + 1);\\n                if(weget>=orders) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n         \\n        int l=1,r=1e9;\\n        \\n        while(r>l){\\n            \\n            int mid=l+ (r - l + 1)/2;\\n            \\n            if(check(inventory,mid,orders)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid - 1;\\n            }\\n        }\\n        \\n        \\n        long low=l;\\n        long ans = 0;\\n\\t\\tlow = low + 1; // buy all balls with this value and above\\n\\t\\tfor(auto& x:inventory) {\\n\\t\\t\\tif(x >= low ) {\\n\\t\\t\\t\\tans += (low + x)*(x-low + 1)/2;\\n\\t\\t\\t\\tans = ans%MOD;\\n\\t\\t\\t\\torders -= x-low+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlow = low - 1;\\n\\t\\tfor(int i=0;i<orders;i++) {\\n\\t\\t\\tans += low;\\n\\t\\t\\tans = ans%MOD;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong long int MOD=1e9 + 7;\\n    bool check(vector<int> &inventory,int assumecutength,int orders){\\n      \\n        int weget=0;\\n        \\n        \\n        for(auto x: inventory){\\n            if(x>=assumecutength){\\n                weget+=(x - assumecutength + 1);\\n                if(weget>=orders) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n         \\n        int l=1,r=1e9;\\n        \\n        while(r>l){\\n            \\n            int mid=l+ (r - l + 1)/2;\\n            \\n            if(check(inventory,mid,orders)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid - 1;\\n            }\\n        }\\n        \\n        \\n        long low=l;\\n        long ans = 0;\\n\\t\\tlow = low + 1; // buy all balls with this value and above\\n\\t\\tfor(auto& x:inventory) {\\n\\t\\t\\tif(x >= low ) {\\n\\t\\t\\t\\tans += (low + x)*(x-low + 1)/2;\\n\\t\\t\\t\\tans = ans%MOD;\\n\\t\\t\\t\\torders -= x-low+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlow = low - 1;\\n\\t\\tfor(int i=0;i<orders;i++) {\\n\\t\\t\\tans += low;\\n\\t\\t\\tans = ans%MOD;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311935,
                "title": "python-sort-greedy-binary-search-o-nlogn-time-o-1-space-beats-99-77",
                "content": "### Intuition\\nSort `I` beforehand because we want to do binary search.\\nSuppose we have `I = [1,3,7]`. \\nNo matter what `orders` is, we want to sell the ball in the last index first, until its quantity is equal to that of the previously less abundant ball.\\nIn this case, our first 4 sales must be 7,6,5,4, and `I` will become `[1,3,3]`.\\n(After each batch sale, we will have more member in `I` equal to the last element of `I`)\\n\\nThen, how many balls we can sell for more than 1? \\nThe answer is (3-1)*(3-1)=4 \\n`(len(I)-firstIdxOfLargestElement) * (I[-1]-nextSmallerElement)`\\n\\nIf we can consume all 4 sale `(if orders>=4)`, it is just a simple arithmatic sum `((3+2)*2)`\\nIf we cannot consume all 4 sale `(if orders<4, letsay it is 3)`, it is just another arithmatic sum () + residue `(3*2) + 2*(3-2)`\\n\\nThe key point is finding `firstIdxOfLargestElement` using binary search (O(logn)),\\n`nextSmallerElement` is just the one at index `firstIdxOfLargestElement - 1` for simple reason.\\nIn the worst case when `I = [i for i in range(10**9)]`, we will have to search again everytime we sell 1 ball, which is eventually O(nlogn)\\n\\n\\n### Code\\n```\\nclass Solution:\\n    def maxProfit(self, I: List[int], orders: int) -> int:\\n        I.sort()\\n        I = [0] + I\\n        idx = bisect.bisect_left(I, I[-1])\\n        res = 0\\n        \\n        while orders > 0 and idx > 0:\\n            length = len(I) - idx\\n            available = length * (I[idx] - I[idx-1])\\n            if orders >= available:\\n                res += length * (((I[idx-1]+I[idx]+1) * (I[idx]-I[idx-1])) // 2)\\n                orders -= available\\n            else:\\n                full_cnt = orders // length\\n                residue = orders % length\\n                res += length * (((I[idx]+I[idx]-full_cnt+1) * full_cnt) // 2)\\n                res += residue * (I[idx]-full_cnt)\\n                orders = 0\\n            idx = bisect.bisect_left(I, I[idx-1])\\n            \\n        return res % (10**9 + 7)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, I: List[int], orders: int) -> int:\\n        I.sort()\\n        I = [0] + I\\n        idx = bisect.bisect_left(I, I[-1])\\n        res = 0\\n        \\n        while orders > 0 and idx > 0:\\n            length = len(I) - idx\\n            available = length * (I[idx] - I[idx-1])\\n            if orders >= available:\\n                res += length * (((I[idx-1]+I[idx]+1) * (I[idx]-I[idx-1])) // 2)\\n                orders -= available\\n            else:\\n                full_cnt = orders // length\\n                residue = orders % length\\n                res += length * (((I[idx]+I[idx]-full_cnt+1) * full_cnt) // 2)\\n                res += residue * (I[idx]-full_cnt)\\n                orders = 0\\n            idx = bisect.bisect_left(I, I[idx-1])\\n            \\n        return res % (10**9 + 7)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1306530,
                "title": "python-binary-search-arithmetic-series-formula-680ms",
                "content": "Firstly, I ignore the overflow problem since this is python. However, I do not think this is great. Then, we can use Arithmetic series formula e.g. 5+4+3 = (5+3)x3x0.5 = 12 to get the summation.  \"if inventory[i]>inventory[i+1]:\" can lower the execution time in terms of case [10, 10, 10, 10, 10,...10, 1, 0] and 100000. But, I do not like my solution because I do not deal with overflow porblem though it is python. \\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        p = 0\\n        for i in range(10**5):\\n            if inventory[i]>inventory[i+1]:\\n                if (i+1)*(inventory[i]-inventory[i+1])>=orders:\\n                    left, right = inventory[i+1]+1, inventory[i]\\n                    while left<=right:\\n                        mid = (left+right)//2\\n                        numBalls = (inventory[i]-mid+1)*(i+1)\\n                        if 0<=numBalls-orders<i+1:\\n                            k = numBalls-orders\\n                            p += ((inventory[i]+mid)*(inventory[i]-mid+1)//2)*(i+1)-(k*mid)\\n                            return p%1000000007\\n                        elif numBalls<orders:\\n                            right = mid-1\\n                        else:\\n                            left = mid+1\\n                else:\\n                    orders -= (i+1)*(inventory[i]-inventory[i+1])\\n                    p += ((inventory[i]+inventory[i+1]+1)*(inventory[i]-inventory[i+1])//2)*(i+1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        p = 0\\n        for i in range(10**5):\\n            if inventory[i]>inventory[i+1]:\\n                if (i+1)*(inventory[i]-inventory[i+1])>=orders:\\n                    left, right = inventory[i+1]+1, inventory[i]\\n                    while left<=right:\\n                        mid = (left+right)//2\\n                        numBalls = (inventory[i]-mid+1)*(i+1)\\n                        if 0<=numBalls-orders<i+1:\\n                            k = numBalls-orders\\n                            p += ((inventory[i]+mid)*(inventory[i]-mid+1)//2)*(i+1)-(k*mid)\\n                            return p%1000000007\\n                        elif numBalls<orders:\\n                            right = mid-1\\n                        else:\\n                            left = mid+1\\n                else:\\n                    orders -= (i+1)*(inventory[i]-inventory[i+1])\\n                    p += ((inventory[i]+inventory[i+1]+1)*(inventory[i]-inventory[i+1])//2)*(i+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297122,
                "title": "with-explanation",
                "content": "```\\n //Assuming a list 123,123,134,134,134 you don\\'t have to take one at a time\\n    //from each of 134. You know you have 33 availability(134-123)*3 till you \\n    //get 5 sets of 123 balls. So if your order is greater than \\n    //33 balls you can get to 5 sets of 123 balls each in one step and repeat \\n    //the process with 5 sets of 123 balls each. But if your orderRemaining is \\n    //less than 33,  or you have sets of same number of balls remaining, i.e. \\n    //5 sets of 123 each for example, then you can just get to final answer in \\n    //one step. You just have to split the order carefully. For example, if \\n    //you need only 23 then you can get 7(23/3) from each set and 1 each from \\n    //two sets. So the final count will be 123,123,126,126,127. There is a \\n    //special case here if you only needed 21 or 2. For 21, you just take 7 \\n    //from each set so the second step of taking 2 should not be done but for \\n    //2 you only take 1 from 2 sets each so the first step of taking 7 from \\n    //each should not be done. \\n    //The other solutions of using priority queue doe not working because\\n    //you go one ball at a time.\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        map<int,int> mp;\\n        for( auto inv: inventory)\\n            mp[inv]+= 1;\\n\\n        int orderFilled = 0;\\n        long int sum = 0;\\n        int mod = 1000000007;\\n        while(orderFilled<orders)\\n        {\\n            int availability;\\n            auto start = mp.rbegin();\\n            auto end = start;\\n            \\n            while((end != mp.rend() ) && (end->first == start->first))\\n                end++;\\n            \\n            long int topValue = start->first;\\n            long int topValue2;\\n            //take what you need from start \\n            if( end == mp.rend())\\n            {\\n                int orderRemaining = orders-orderFilled;\\n                return takewhatever(mp,start,orderRemaining,\\n                                    topValue, sum,mod);\\n            }\\n            else\\n            {\\n                topValue2 = end->first;\\n                int availability = (topValue-topValue2)*start->second;\\n                int orderRemaining = orders-orderFilled;\\n                if( orderRemaining > availability)\\n                {\\n                    orderFilled += availability;\\n                    mp[topValue2] += mp[start->first];\\n                    mp.erase(start->first);\\n                    sum = (sum+((topValue+topValue2+1)*\\n                                availability/2)%mod)%mod;\\n                }\\n                else\\n                {\\n                    return takewhatever(mp,start,orderRemaining,\\n                                        topValue, sum,mod);\\n                }   \\n            }\\n\\n        }\\n        return sum;\\n    }\\n    \\n    double takewhatever(map<int,int>& mp, \\n                        map<int,int>::reverse_iterator start, \\n                        int orderRemaining, long int topValue, \\n                        long int sum,int mod )\\n    {\\n        int howmanyduplicates = start->second;\\n        int howmanytotakefromeach = \\n                orderRemaining/howmanyduplicates;\\n        int howmanyleft = orderRemaining-            \\n            (howmanytotakefromeach*howmanyduplicates);\\n        mp.erase(start->first);\\n        if(howmanyleft)\\n        {\\n            int splitAmount1 = topValue-howmanytotakefromeach;\\n            int count1 = howmanyduplicates-howmanyleft;\\n            int splitAmount2 = splitAmount1-1;\\n            int count2 = howmanyleft;\\n            if(howmanytotakefromeach)\\n                sum = (sum+((topValue+splitAmount1+1)*\\n                    (topValue-splitAmount1)*count1/2)%mod)%mod;\\n            sum = (sum+((topValue+splitAmount2+1)*\\n                (topValue-splitAmount2)*count2/2)%mod)%mod;\\n        }\\n        else\\n        {    \\n            int splitAmount1 = topValue-howmanytotakefromeach;\\n            int count1 = howmanyduplicates;\\n            sum = (sum+((topValue+splitAmount1+1)*\\n                    (topValue-splitAmount1)*count1/2)%mod)%mod;\\n        }\\n                    \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n //Assuming a list 123,123,134,134,134 you don\\'t have to take one at a time\\n    //from each of 134. You know you have 33 availability(134-123)*3 till you \\n    //get 5 sets of 123 balls. So if your order is greater than \\n    //33 balls you can get to 5 sets of 123 balls each in one step and repeat \\n    //the process with 5 sets of 123 balls each. But if your orderRemaining is \\n    //less than 33,  or you have sets of same number of balls remaining, i.e. \\n    //5 sets of 123 each for example, then you can just get to final answer in \\n    //one step. You just have to split the order carefully. For example, if \\n    //you need only 23 then you can get 7(23/3) from each set and 1 each from \\n    //two sets. So the final count will be 123,123,126,126,127. There is a \\n    //special case here if you only needed 21 or 2. For 21, you just take 7 \\n    //from each set so the second step of taking 2 should not be done but for \\n    //2 you only take 1 from 2 sets each so the first step of taking 7 from \\n    //each should not be done. \\n    //The other solutions of using priority queue doe not working because\\n    //you go one ball at a time.\\n    \\n    int maxProfit(vector<int>& inventory, int orders) {\\n        map<int,int> mp;\\n        for( auto inv: inventory)\\n            mp[inv]+= 1;\\n\\n        int orderFilled = 0;\\n        long int sum = 0;\\n        int mod = 1000000007;\\n        while(orderFilled<orders)\\n        {\\n            int availability;\\n            auto start = mp.rbegin();\\n            auto end = start;\\n            \\n            while((end != mp.rend() ) && (end->first == start->first))\\n                end++;\\n            \\n            long int topValue = start->first;\\n            long int topValue2;\\n            //take what you need from start \\n            if( end == mp.rend())\\n            {\\n                int orderRemaining = orders-orderFilled;\\n                return takewhatever(mp,start,orderRemaining,\\n                                    topValue, sum,mod);\\n            }\\n            else\\n            {\\n                topValue2 = end->first;\\n                int availability = (topValue-topValue2)*start->second;\\n                int orderRemaining = orders-orderFilled;\\n                if( orderRemaining > availability)\\n                {\\n                    orderFilled += availability;\\n                    mp[topValue2] += mp[start->first];\\n                    mp.erase(start->first);\\n                    sum = (sum+((topValue+topValue2+1)*\\n                                availability/2)%mod)%mod;\\n                }\\n                else\\n                {\\n                    return takewhatever(mp,start,orderRemaining,\\n                                        topValue, sum,mod);\\n                }   \\n            }\\n\\n        }\\n        return sum;\\n    }\\n    \\n    double takewhatever(map<int,int>& mp, \\n                        map<int,int>::reverse_iterator start, \\n                        int orderRemaining, long int topValue, \\n                        long int sum,int mod )\\n    {\\n        int howmanyduplicates = start->second;\\n        int howmanytotakefromeach = \\n                orderRemaining/howmanyduplicates;\\n        int howmanyleft = orderRemaining-            \\n            (howmanytotakefromeach*howmanyduplicates);\\n        mp.erase(start->first);\\n        if(howmanyleft)\\n        {\\n            int splitAmount1 = topValue-howmanytotakefromeach;\\n            int count1 = howmanyduplicates-howmanyleft;\\n            int splitAmount2 = splitAmount1-1;\\n            int count2 = howmanyleft;\\n            if(howmanytotakefromeach)\\n                sum = (sum+((topValue+splitAmount1+1)*\\n                    (topValue-splitAmount1)*count1/2)%mod)%mod;\\n            sum = (sum+((topValue+splitAmount2+1)*\\n                (topValue-splitAmount2)*count2/2)%mod)%mod;\\n        }\\n        else\\n        {    \\n            int splitAmount1 = topValue-howmanytotakefromeach;\\n            int count1 = howmanyduplicates;\\n            sum = (sum+((topValue+splitAmount1+1)*\\n                    (topValue-splitAmount1)*count1/2)%mod)%mod;\\n        }\\n                    \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275226,
                "title": "c-one-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int mod = 1e9 + 7;\\n        sort(inventory.begin(), inventory.end(), greater());\\n        inventory.push_back(0);\\n        int64_t res = 0;\\n        for(int i = 1; i < inventory.size(); ++i){\\n            if(orders == 0) break;\\n            if(orders >= i * (inventory[i-1] - inventory[i])){\\n                orders -= i * (inventory[i-1] - inventory[i]);\\n                res += (int64_t)i * (inventory[i-1] + inventory[i] + 1) * (inventory[i-1] - inventory[i]) / 2;\\n                res %= mod;\\n            }\\n            else{\\n                int64_t reminder = orders % i;\\n                orders /= i;\\n                res += (int64_t)i * (inventory[i-1] + inventory[i-1] - orders + 1) * orders / 2;\\n                res %= mod;\\n                res += reminder * (inventory[i-1] - orders);\\n                res %= mod;\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int mod = 1e9 + 7;\\n        sort(inventory.begin(), inventory.end(), greater());\\n        inventory.push_back(0);\\n        int64_t res = 0;\\n        for(int i = 1; i < inventory.size(); ++i){\\n            if(orders == 0) break;\\n            if(orders >= i * (inventory[i-1] - inventory[i])){\\n                orders -= i * (inventory[i-1] - inventory[i]);\\n                res += (int64_t)i * (inventory[i-1] + inventory[i] + 1) * (inventory[i-1] - inventory[i]) / 2;\\n                res %= mod;\\n            }\\n            else{\\n                int64_t reminder = orders % i;\\n                orders /= i;\\n                res += (int64_t)i * (inventory[i-1] + inventory[i-1] - orders + 1) * orders / 2;\\n                res %= mod;\\n                res += reminder * (inventory[i-1] - orders);\\n                res %= mod;\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270407,
                "title": "python-o-nlog-n-sol-sort-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def _get_profit(self, sp_inv, ep_inv, sp, profit, orders):\\n        if (sp_inv - ep_inv)*(sp+1) > orders:\\n                diff = orders\\n                div = diff/(sp+1)\\n                mod = diff%(sp+1)\\n                profit += (self._get_sum(sp_inv) - self._get_sum(sp_inv-div))*(sp+1) + (sp_inv-div)*mod\\n                orders = 0\\n        else:\\n            profit += (self._get_sum(sp_inv) - self._get_sum(ep_inv))*(sp+1)\\n            orders -= (sp_inv - ep_inv)*(sp+1)\\n        \\n        return profit, orders\\n                \\n    def _get_sum(self, num):\\n        return (num*(num+1))/2\\n    \\n    def maxProfit(self, inventory, orders):\\n        inventory = sorted(inventory, reverse=True)\\n        n = len(inventory)\\n        sp = 0\\n        ep = 1\\n        profit = 0\\n        l_mod = pow(10,9) + 7\\n        \\n        while ep < n:\\n            profit, orders = self._get_profit(inventory[sp], inventory[ep], sp, profit, orders)\\n            sp += 1\\n            ep += 1\\n        \\n        if orders > 0:\\n            profit, orders = self._get_profit(inventory[sp], 1, sp, profit, orders)\\n        \\n        return (profit + orders) % l_mod\\n            \\n        \\n        \"\"\"\\n        :type inventory: List[int]\\n        :type orders: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def _get_profit(self, sp_inv, ep_inv, sp, profit, orders):\\n        if (sp_inv - ep_inv)*(sp+1) > orders:\\n                diff = orders\\n                div = diff/(sp+1)\\n                mod = diff%(sp+1)\\n                profit += (self._get_sum(sp_inv) - self._get_sum(sp_inv-div))*(sp+1) + (sp_inv-div)*mod\\n                orders = 0\\n        else:\\n            profit += (self._get_sum(sp_inv) - self._get_sum(ep_inv))*(sp+1)\\n            orders -= (sp_inv - ep_inv)*(sp+1)\\n        \\n        return profit, orders\\n                \\n    def _get_sum(self, num):\\n        return (num*(num+1))/2\\n    \\n    def maxProfit(self, inventory, orders):\\n        inventory = sorted(inventory, reverse=True)\\n        n = len(inventory)\\n        sp = 0\\n        ep = 1\\n        profit = 0\\n        l_mod = pow(10,9) + 7\\n        \\n        while ep < n:\\n            profit, orders = self._get_profit(inventory[sp], inventory[ep], sp, profit, orders)\\n            sp += 1\\n            ep += 1\\n        \\n        if orders > 0:\\n            profit, orders = self._get_profit(inventory[sp], 1, sp, profit, orders)\\n        \\n        return (profit + orders) % l_mod\\n            \\n        \\n        \"\"\"\\n        :type inventory: List[int]\\n        :type orders: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258976,
                "title": "c-implementation",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        /** data copy; don\\'t modify inventory */\\n        vector<int> inven_cpy(inventory);\\n        sort(inven_cpy.begin(), inven_cpy.end());\\n        \\n        size_t size = inven_cpy.size();\\n        size_t i = size - 1;\\n        int num_max_elements = 1;\\n        \\n        /** it may have multiple max numer in initial array */\\n        while(i > 0 && inven_cpy[i] == inven_cpy[i-1])\\n        {\\n            i--;\\n            num_max_elements++;\\n        }\\n        \\n        long int value = 0;\\n        while(orders > 0)\\n        {\\n            long top = inven_cpy[size - 1];\\n            long bottom = size - num_max_elements > 0 ? inven_cpy[size - num_max_elements - 1] : 0;\\n            \\n            /** if true, take all the colored balls with max number\\n              * until its number reduce to the second largest one */\\n            if(num_max_elements * (top - bottom) <= orders)\\n            {\\n                value = (value + num_max_elements * ((top - bottom) * (top + bottom + 1)/2)) % 1000000007;\\n                orders -= num_max_elements * (top - bottom);\\n                \\n                for(i = 0; i < num_max_elements; i++)\\n                    inven_cpy[size - 1 - i] = bottom;\\n                \\n                i = size - num_max_elements;\\n                while(i > 0 && inven_cpy[i] == inven_cpy[i-1])\\n                {\\n                    i--;\\n                    num_max_elements++;\\n                }\\n            }\\n            else\\n            {\\n                long a = orders/num_max_elements;\\n                long b = orders % num_max_elements;\\n                bottom = top - a;\\n                value = (value + (num_max_elements * (a * (top + bottom + 1)/2))) % 1000000007;\\n                value = (value + (b * bottom)) % 1000000007;\\n                orders = 0;\\n            }\\n        }\\n        \\n        return value;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        /** data copy; don\\'t modify inventory */\\n        vector<int> inven_cpy(inventory);\\n        sort(inven_cpy.begin(), inven_cpy.end());\\n        \\n        size_t size = inven_cpy.size();\\n        size_t i = size - 1;\\n        int num_max_elements = 1;\\n        \\n        /** it may have multiple max numer in initial array */\\n        while(i > 0 && inven_cpy[i] == inven_cpy[i-1])\\n        {\\n            i--;\\n            num_max_elements++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1256527,
                "title": "java-what-is-wrong-with-time-complexity",
                "content": "I thought it was fine with time O(N log N).\\n\\nHowever, could not execute with time limit with input:\\n>[1000000000]\\n1000000000\\n\\ncodes are:\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Integer> db = new PriorityQueue<>((a,b)->b-a);\\n        for(int i: inventory)\\n            db.offer(i);\\n        \\n        double maxVal = 0;\\n        \\n        while(orders>0){\\n            orders--;\\n            \\n            int currmax = db.poll();\\n            maxVal = (maxVal + currmax)%(1e9+7);\\n            db.offer(currmax-1);\\n        }\\n        \\n        return (int)(maxVal%(1e9+7));\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Integer> db = new PriorityQueue<>((a,b)->b-a);\\n        for(int i: inventory)\\n            db.offer(i);\\n        \\n        double maxVal = 0;\\n        \\n        while(orders>0){\\n            orders--;\\n            \\n            int currmax = db.poll();\\n            maxVal = (maxVal + currmax)%(1e9+7);\\n            db.offer(currmax-1);\\n        }\\n        \\n        return (int)(maxVal%(1e9+7));\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1228346,
                "title": "concise-java-solution-greedy-using-treemap-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        \\n        TreeMap<Long, Long> treeMap = new TreeMap<>(); // <The number of balls of specific color, Count>\\n        \\n        for (int number : inventory)\\n            treeMap.put((long)number, treeMap.getOrDefault((long)number, 0L) + 1);\\n        \\n        long result = 0, mod = (long)Math.pow(10, 9) + 7;\\n        \\n        while (orders > 0)\\n        {\\n            Map.Entry<Long, Long> maxEntry = treeMap.pollLastEntry();\\n            long maxNumber = maxEntry.getKey(), maxCount = maxEntry.getValue(), subMaxNumber = 0;\\n            \\n            if (!treeMap.isEmpty())\\n                subMaxNumber = treeMap.lastKey();\\n            \\n            long totalCount = (maxNumber - subMaxNumber) * maxCount;\\n            \\n            if (orders >= totalCount)\\n            {\\n                long n = maxNumber - subMaxNumber, a1 = maxNumber, an = subMaxNumber + 1; \\n            \\n                result = (result + n * (a1 + an) / 2 * maxCount) % mod; // Note: Sum of arithmetic sequence n * (a1 + an) / 2\\n                orders -= n * maxCount;\\n                \\n                treeMap.put(subMaxNumber, treeMap.getOrDefault(subMaxNumber, 0L) + maxCount); // Get the orders until maxNumber equals subMaxNumber\\n            }\\n            else\\n            {\\n                long n = orders / maxCount, a1 = maxNumber, an = a1 - n + 1;\\n                \\n                result = (result + n * (a1 + an) / 2 * maxCount) % mod;\\n                orders -= n * maxCount;\\n                \\n                result = (result + orders * (an - 1)) % mod;\\n                break; // orders = 0\\n            }\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        \\n        TreeMap<Long, Long> treeMap = new TreeMap<>(); // <The number of balls of specific color, Count>\\n        \\n        for (int number : inventory)\\n            treeMap.put((long)number, treeMap.getOrDefault((long)number, 0L) + 1);\\n        \\n        long result = 0, mod = (long)Math.pow(10, 9) + 7;\\n        \\n        while (orders > 0)\\n        {\\n            Map.Entry<Long, Long> maxEntry = treeMap.pollLastEntry();\\n            long maxNumber = maxEntry.getKey(), maxCount = maxEntry.getValue(), subMaxNumber = 0;\\n            \\n            if (!treeMap.isEmpty())\\n                subMaxNumber = treeMap.lastKey();\\n            \\n            long totalCount = (maxNumber - subMaxNumber) * maxCount;\\n            \\n            if (orders >= totalCount)\\n            {\\n                long n = maxNumber - subMaxNumber, a1 = maxNumber, an = subMaxNumber + 1; \\n            \\n                result = (result + n * (a1 + an) / 2 * maxCount) % mod; // Note: Sum of arithmetic sequence n * (a1 + an) / 2\\n                orders -= n * maxCount;\\n                \\n                treeMap.put(subMaxNumber, treeMap.getOrDefault(subMaxNumber, 0L) + maxCount); // Get the orders until maxNumber equals subMaxNumber\\n            }\\n            else\\n            {\\n                long n = orders / maxCount, a1 = maxNumber, an = a1 - n + 1;\\n                \\n                result = (result + n * (a1 + an) / 2 * maxCount) % mod;\\n                orders -= n * maxCount;\\n                \\n                result = (result + orders * (an - 1)) % mod;\\n                break; // orders = 0\\n            }\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220441,
                "title": "easy-to-understand-python-fast",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def sf(a, b):\\n            return (a*(a+1) - b*(b+1)) // 2\\n        \\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        total, i, w = 0,0,0\\n        \\n        while orders > 0:\\n            w += 1\\n            n = (inventory[i] - inventory[i+1]) * w\\n            if orders >= n: # Simple case\\n                s = sf(inventory[i],inventory[i+1])\\n                total += w * s\\n                orders -= n\\n            else:\\n                r = orders % w # Last remainder row\\n                c = (orders - r) // w # Fully filled columns\\n                s = sf(inventory[i], inventory[i] - c)\\n                total += w * s + (inventory[i] - c) * r\\n                return total % 1_000_000_007 \\n            i += 1\\n            \\n        return total % 1_000_000_007  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def sf(a, b):\\n            return (a*(a+1) - b*(b+1)) // 2\\n        \\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        total, i, w = 0,0,0\\n        \\n        while orders > 0:\\n            w += 1\\n            n = (inventory[i] - inventory[i+1]) * w\\n            if orders >= n: # Simple case\\n                s = sf(inventory[i],inventory[i+1])\\n                total += w * s\\n                orders -= n\\n            else:\\n                r = orders % w # Last remainder row\\n                c = (orders - r) // w # Fully filled columns\\n                s = sf(inventory[i], inventory[i] - c)\\n                total += w * s + (inventory[i] - c) * r\\n                return total % 1_000_000_007 \\n            i += 1\\n            \\n        return total % 1_000_000_007  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171573,
                "title": "fails-497978859-167261111-483575207-591815159-836556809",
                "content": "Hm, yeah this is weird but I cannot seem to get my head around what\\'s wrong with my code here? There\\'s an off by 1 for that case and I can\\'t see where I\\'m modding incorrectly. Struggled for really long, would be grateful if someone could help.\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long max_profit = 0;\\n        int left = 0, right = Integer.MAX_VALUE, mod = (int)1e9+7;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            long[] arr = isPossible(mid, inventory, orders);\\n            if(arr[0] == 1){\\n                max_profit = arr[1];\\n                left = mid+1;\\n            }\\n            else right = mid - 1;\\n        }\\n        return (int)(max_profit % mod);\\n    }\\n    \\n    \\n    private long[] isPossible(int threshold, int[] inv, int orders){\\n        long[] arr = new long[2];\\n        int mod = (int)1e9+7;\\n        long profit = 0;\\n        int[] inventory = Arrays.copyOf(inv, inv.length);\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < threshold) break;\\n            profit = (profit%mod + (getSum(inventory[j], orders, threshold)%mod)) % mod;\\n            orders -= Math.min(orders, inventory[j] - threshold);\\n            if(orders == 0) break;\\n        }\\n        if(orders != 0) return arr;\\n        arr[0] = 1; arr[1] = profit;\\n        return arr;\\n    }\\n    \\n    private long getSum(int available, int orders, int threshold){\\n        int mod = (int)1e9+7;\\n        long x = (long)available;\\n        long b = x * (x+1)/2;\\n        long reduceTo = Math.max(available - orders, threshold);\\n        long a = reduceTo * (reduceTo+1)/2;\\n        return (b%mod-a%mod) % mod;\\n    }\\n}\\n```\\n\\nEDIT: \\nWorking code below, simplified the logic(will explain the changes soon)\\n\\n```java\\nclass Solution {\\n    static int mod = (int)1e9+7;\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long profit = 0;\\n        int left = 0, right = Integer.MAX_VALUE;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(isPossible(inventory, orders, mid)) left = mid+1;\\n            else right = mid - 1;\\n        }\\n        return (int)(getSum(inventory, left, orders) % mod);\\n    }\\n    \\n    \\n    private boolean isPossible(int[] inventory, int orders, int threshold){\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < threshold) break;\\n            orders -= inventory[j] - threshold + 1;\\n            if(orders <= 0) break;\\n        }\\n        return orders <= 0;\\n    }\\n    \\n    private long getSum(int[] inventory, int left, int orders){\\n        long profit = 0;\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < left || orders <= 0) break;\\n            profit = (profit + getSum(inventory[j], left)) % mod;\\n            orders -= inventory[j] - left + 1;\\n        }\\n        left--;\\n        for(int i = 0; i < orders; i++) profit = (profit + left) % mod;\\n        return profit;\\n    }\\n    \\n    private long getSum(long total, long limit){\\n        return (total - limit + 1) * (total + limit)/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long max_profit = 0;\\n        int left = 0, right = Integer.MAX_VALUE, mod = (int)1e9+7;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            long[] arr = isPossible(mid, inventory, orders);\\n            if(arr[0] == 1){\\n                max_profit = arr[1];\\n                left = mid+1;\\n            }\\n            else right = mid - 1;\\n        }\\n        return (int)(max_profit % mod);\\n    }\\n    \\n    \\n    private long[] isPossible(int threshold, int[] inv, int orders){\\n        long[] arr = new long[2];\\n        int mod = (int)1e9+7;\\n        long profit = 0;\\n        int[] inventory = Arrays.copyOf(inv, inv.length);\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < threshold) break;\\n            profit = (profit%mod + (getSum(inventory[j], orders, threshold)%mod)) % mod;\\n            orders -= Math.min(orders, inventory[j] - threshold);\\n            if(orders == 0) break;\\n        }\\n        if(orders != 0) return arr;\\n        arr[0] = 1; arr[1] = profit;\\n        return arr;\\n    }\\n    \\n    private long getSum(int available, int orders, int threshold){\\n        int mod = (int)1e9+7;\\n        long x = (long)available;\\n        long b = x * (x+1)/2;\\n        long reduceTo = Math.max(available - orders, threshold);\\n        long a = reduceTo * (reduceTo+1)/2;\\n        return (b%mod-a%mod) % mod;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    static int mod = (int)1e9+7;\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        long profit = 0;\\n        int left = 0, right = Integer.MAX_VALUE;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(isPossible(inventory, orders, mid)) left = mid+1;\\n            else right = mid - 1;\\n        }\\n        return (int)(getSum(inventory, left, orders) % mod);\\n    }\\n    \\n    \\n    private boolean isPossible(int[] inventory, int orders, int threshold){\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < threshold) break;\\n            orders -= inventory[j] - threshold + 1;\\n            if(orders <= 0) break;\\n        }\\n        return orders <= 0;\\n    }\\n    \\n    private long getSum(int[] inventory, int left, int orders){\\n        long profit = 0;\\n        for(int j = inventory.length - 1; j >= 0; j--){\\n            if(inventory[j] < left || orders <= 0) break;\\n            profit = (profit + getSum(inventory[j], left)) % mod;\\n            orders -= inventory[j] - left + 1;\\n        }\\n        left--;\\n        for(int i = 0; i < orders; i++) profit = (profit + left) % mod;\\n        return profit;\\n    }\\n    \\n    private long getSum(long total, long limit){\\n        return (total - limit + 1) * (total + limit)/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105678,
                "title": "python-greedy-approach",
                "content": "```\\n    def maxProfit(self,arr: List[int], orders: int) -> int:\\n        arr.append(0)\\n        arr.sort()\\n        n=len(arr)\\n        ans=0\\n        for i in range(n-1,0,-1):\\n            maxi=(arr[i]-arr[i-1])*(n-i)\\n            if maxi<=orders:\\n                j,k=arr[i],arr[i-1]\\n                ans+=(j*(j+1)//2-k*(k+1)//2)*(n-i)\\n                orders-=maxi\\n                if orders==0:\\n                    return ans%(10**9+7)\\n            elif maxi>orders:\\n                div=orders//(n-i)\\n                rem=orders%(n-i)\\n                ans+=(n-i)*(arr[i]*(arr[i]+1)//2-(arr[i]-div)*(arr[i]-div+1)//2)\\n                ans+=rem*(arr[i]-div)\\n                            \\n                return ans%(10**9+7)\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n    def maxProfit(self,arr: List[int], orders: int) -> int:\\n        arr.append(0)\\n        arr.sort()\\n        n=len(arr)\\n        ans=0\\n        for i in range(n-1,0,-1):\\n            maxi=(arr[i]-arr[i-1])*(n-i)\\n            if maxi<=orders:\\n                j,k=arr[i],arr[i-1]\\n                ans+=(j*(j+1)//2-k*(k+1)//2)*(n-i)\\n                orders-=maxi\\n                if orders==0:\\n                    return ans%(10**9+7)\\n            elif maxi>orders:\\n                div=orders//(n-i)\\n                rem=orders%(n-i)\\n                ans+=(n-i)*(arr[i]*(arr[i]+1)//2-(arr[i]-div)*(arr[i]-div+1)//2)\\n                ans+=rem*(arr[i]-div)\\n                            \\n                return ans%(10**9+7)\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 930090,
                "title": "java-o-n-log-n-using-intervals-and-sorting",
                "content": "The primary thinking is to break down [2,5] into something like [1,1,2,2,3,4,5] which in interval form is **[1,2]=2 [3,5]=1**\\n\\nThis requires the input array sorted in an **ascending** order. Whats really neat about sorted input is that when we loop from an array like [2,5,7,8] we will there will be 4 ranges of [1,2]\\n\\nThe optimal solution is to loop the above range entries from right to left in an decresing fashion. To achieve the best space usage our range entry will look like `[left, right, times]`. Where times is the number of times each entry reappears. \\n\\n\\nDepending on the order we will run into two scenarios as we look through the ranges \\nex: [[1,2,2], [3,5,1]], orders = 4\\n\\n1) When orders > the size of the range, \\n\\tThis is simple because we know how many numbers are between [left,right] and the number of times this range has appeared in our list. We can do (`right - left + 1) * size` to find out how many orders we can satisfy. \\n\\tFinding the score of satisifying this order is also trivial, we can take advantage of the arithmetic sequence to find the sum in constant time. \\n```\\n\\tval = sum(range[0], range[1]) % mod;\\n\\tval = (val * size) % mod; \\n```\\n\\n2) When orders >= the size of the range,\\n\\tThis is a bit tricky to implement but the idea is pretty straightforward. Say your range is `[1,5,2]` or `1 1 2 2 3 3 4 4 5 5 `  if your orders is `7`. You will want the sum from `2 3 3 4 4 5 5`. You can do this by find the last integer that you want to include in your range, and find an extra values outside your this range. (2 + (range(3,5) * 2)) or `extra + ((range(left, right) * size)`. \\n\\tThe leftMost integer to be included into your rangeSum can be found with `int newLeft = range[1] - (orders/size) + 1;`\\n\\tThe extra value to be added into the sum can be found with `long extra = (orders%size) * (newLeft-1);` \\n\\n\\nWrapping everything up\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = (int) 1e9+7;\\n        Arrays.sort(inventory);\\n        List<int[]> ranges = new ArrayList<>();\\n        int left = 1;\\n        int index = 0;\\n        while (index < inventory.length) { // create range entry [left, right, size]\\n            ranges.add(new int[] {left, inventory[index], inventory.length - index});\\n            left = inventory[index] + 1;\\n            index++;\\n        }\\n        index--; // move last index pointer to last index in array\\n        long res = 0;\\n        while (orders > 0 && index >= 0) {\\n            int[] range = ranges.get(index);\\n            int size = range[2];\\n            int num = (size * (range[1] - range[0] + 1));\\n            long val = 0l;\\n            if (num >= orders) { // if we can find the finish the order in this iteration\\n                int newLeft = range[1] - (orders/size) + 1; // finding the left bound of this new range [newLeft, right] where newLeft > left\\n                long extra = (((long) (orders%size) * (newLeft-1)) % mod); // sum of the values not include in the above range\\n                long s = (sum(newLeft, range[1]) % mod);\\n                s = ((s * size) % mod);\\n                s = ((s + extra) % mod);\\n                val = s;\\n            } else { // satisfy as much order as we can\\n                val = sum(range[0], range[1]) % mod; \\n                val = (val * size) % mod;\\n            }\\n\\n            \\n            res = (res + val) % mod;\\n            orders -= num;\\n            index--;\\n        }\\n        return (int) res % mod;\\n    }\\n    \\n    \\n    private long sum(int left, int right) {\\n        long sum = left + right;\\n        int size = right - left + 1;\\n        long res = sum * (size/2);\\n        if (size % 2 == 1) {\\n            res += (sum/2);\\n        }\\n        return res;\\n    }\\n    \\n    // 2 , 5\\n    // [0-2]: 2 [3:5] : 1\\n    \\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tval = sum(range[0], range[1]) % mod;\\n\\tval = (val * size) % mod; \\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = (int) 1e9+7;\\n        Arrays.sort(inventory);\\n        List<int[]> ranges = new ArrayList<>();\\n        int left = 1;\\n        int index = 0;\\n        while (index < inventory.length) { // create range entry [left, right, size]\\n            ranges.add(new int[] {left, inventory[index], inventory.length - index});\\n            left = inventory[index] + 1;\\n            index++;\\n        }\\n        index--; // move last index pointer to last index in array\\n        long res = 0;\\n        while (orders > 0 && index >= 0) {\\n            int[] range = ranges.get(index);\\n            int size = range[2];\\n            int num = (size * (range[1] - range[0] + 1));\\n            long val = 0l;\\n            if (num >= orders) { // if we can find the finish the order in this iteration\\n                int newLeft = range[1] - (orders/size) + 1; // finding the left bound of this new range [newLeft, right] where newLeft > left\\n                long extra = (((long) (orders%size) * (newLeft-1)) % mod); // sum of the values not include in the above range\\n                long s = (sum(newLeft, range[1]) % mod);\\n                s = ((s * size) % mod);\\n                s = ((s + extra) % mod);\\n                val = s;\\n            } else { // satisfy as much order as we can\\n                val = sum(range[0], range[1]) % mod; \\n                val = (val * size) % mod;\\n            }\\n\\n            \\n            res = (res + val) % mod;\\n            orders -= num;\\n            index--;\\n        }\\n        return (int) res % mod;\\n    }\\n    \\n    \\n    private long sum(int left, int right) {\\n        long sum = left + right;\\n        int size = right - left + 1;\\n        long res = sum * (size/2);\\n        if (size % 2 == 1) {\\n            res += (sum/2);\\n        }\\n        return res;\\n    }\\n    \\n    // 2 , 5\\n    // [0-2]: 2 [3:5] : 1\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929539,
                "title": "thinking-process-binary-search",
                "content": "The problem is similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152506/Binary-Search-Java-Python-with-Explanations/). Given a linear searching space [lo, hi], [mi, hi] (lo <= mi) satisfy a property, we can use Binary Searc to get mi.\\n\\nHere, we play with the searching space of `remaining`:\\n```\\ninventory = [1, 2, 3] as below\\n        x\\n      x x\\n    x x x\\ni = 0 1 2\\n\\nLet\\'s define remaining = 2 as below:\\n      x x\\n    x x x\\ni = 0 1 2\\n\\n      x  \\n    x x x\\ni = 0 1 2\\n\\n        x  \\n    x x x\\ni = 0 1 2\\n\\nthey can cover orders = 1 an orders = 2.\\n\\nOur problem becomes with the given `orders`, what is `remaining`?\\n\\nWith `remaining` decreasing, `orders` gets larger.\\n```\\n\\nHere, searching space for `remaining` is monotone regarding whether they can satisfy `orders`. \\n\\nIf searching space of `remaining` is `[lo, hi]`, the subrange `[lo, K]` can make orders >= `orders`, our aim is to find such `K` in order to get maximum profit.\\n\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    \\n    public int maxProfit(int[] inventory, int orders) {\\n        int maxFreq = 0;\\n        for (int freq : inventory) {\\n            maxFreq = Math.max(freq, maxFreq);\\n        }\\n        \\n        long lo = 0, hi = maxFreq; // Search space of remaining balls of each inventory[i]\\n        while (lo <= hi) {\\n            long mi = lo + (hi - lo) / 2;\\n            long cntOrders = countOrders(mi, inventory);\\n            if (cntOrders == orders) {\\n                lo = mi;\\n                break;\\n            } else if (cntOrders < orders) {\\n                hi = mi - 1;\\n            } else {\\n                lo = mi + 1;\\n            }\\n        }\\n    \\n        return getProfitFromOrders(lo, orders, inventory);\\n    }\\n    \\n    private int getProfitFromOrders(long remaining, int orders, int[] inventory) {\\n        long ordersSoFar = 0, profit = 0;\\n        for (int freq : inventory) {\\n            if (freq <= remaining)\\n                continue;\\n            profit = (profit + (freq + remaining + 1) * (freq - remaining) / 2 % MOD) % MOD;\\n            ordersSoFar += freq - remaining;\\n        }\\n        profit = (profit + (orders - ordersSoFar) * remaining % MOD) % MOD;\\n        \\n        return (int)profit;\\n    }\\n\\n    // For each inventory[i], we sell (inventory[i] - target) orders, count the total orders\\n    private long countOrders(long remaining, int[] inventory) {\\n        long sum = 0;\\n        for (int freq : inventory) {\\n            if (freq < remaining)\\n                continue;\\n            sum += freq - remaining;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ninventory = [1, 2, 3] as below\\n        x\\n      x x\\n    x x x\\ni = 0 1 2\\n\\nLet\\'s define remaining = 2 as below:\\n      x x\\n    x x x\\ni = 0 1 2\\n\\n      x  \\n    x x x\\ni = 0 1 2\\n\\n        x  \\n    x x x\\ni = 0 1 2\\n\\nthey can cover orders = 1 an orders = 2.\\n\\nOur problem becomes with the given `orders`, what is `remaining`?\\n\\nWith `remaining` decreasing, `orders` gets larger.\\n```\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    \\n    public int maxProfit(int[] inventory, int orders) {\\n        int maxFreq = 0;\\n        for (int freq : inventory) {\\n            maxFreq = Math.max(freq, maxFreq);\\n        }\\n        \\n        long lo = 0, hi = maxFreq; // Search space of remaining balls of each inventory[i]\\n        while (lo <= hi) {\\n            long mi = lo + (hi - lo) / 2;\\n            long cntOrders = countOrders(mi, inventory);\\n            if (cntOrders == orders) {\\n                lo = mi;\\n                break;\\n            } else if (cntOrders < orders) {\\n                hi = mi - 1;\\n            } else {\\n                lo = mi + 1;\\n            }\\n        }\\n    \\n        return getProfitFromOrders(lo, orders, inventory);\\n    }\\n    \\n    private int getProfitFromOrders(long remaining, int orders, int[] inventory) {\\n        long ordersSoFar = 0, profit = 0;\\n        for (int freq : inventory) {\\n            if (freq <= remaining)\\n                continue;\\n            profit = (profit + (freq + remaining + 1) * (freq - remaining) / 2 % MOD) % MOD;\\n            ordersSoFar += freq - remaining;\\n        }\\n        profit = (profit + (orders - ordersSoFar) * remaining % MOD) % MOD;\\n        \\n        return (int)profit;\\n    }\\n\\n    // For each inventory[i], we sell (inventory[i] - target) orders, count the total orders\\n    private long countOrders(long remaining, int[] inventory) {\\n        long sum = 0;\\n        for (int freq : inventory) {\\n            if (freq < remaining)\\n                continue;\\n            sum += freq - remaining;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929283,
                "title": "javascript-solution",
                "content": "##### Amortized Analysis\\n---\\nTime Complexity: O(n log n)\\nSpace Complexity: O(1)\\n\\nRuntime: 256 ms\\nMemory Usage: 55.5 MB\\n\\n---\\n##### Code\\n---\\n```\\nconst min = (a, b) => a < b? a:b;\\n\\nconst summationN = n => n * (n + BigInt(1)) / BigInt(2);\\n\\nconst MOD = BigInt(1e9 + 7);\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\n\\nvar maxProfit = function(inventory, orders) {\\n  inventory.sort((a, b) => b - a);\\n  inventory.push(0);\\n  inventory = inventory.map( e => BigInt(e));\\n  let top = inventory[0];\\n  let answer = BigInt(0);\\n  let i = 1;\\n  orders = BigInt(orders);\\n  const len = inventory.length;\\n  while(i < len && orders > 0) {\\n    while(i < len && inventory[i] == top) {\\n      i++;\\n    }\\n    let col = BigInt(i);\\n    let row = BigInt(top - inventory[i]);\\n    let cells = row * col;\\n    let take = min(orders, cells);\\n    let res = take / col;\\n    let rem = take % col;\\n    \\n    answer = (answer + ((summationN(top) - summationN(top - res)) * col) % MOD) % MOD;\\n    answer = (answer + ((top - res) * rem) % MOD) % MOD;\\n    orders -= take;\\n    top = inventory[i];\\n    i++;\\n  }\\n  return answer;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst min = (a, b) => a < b? a:b;\\n\\nconst summationN = n => n * (n + BigInt(1)) / BigInt(2);\\n\\nconst MOD = BigInt(1e9 + 7);\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\n\\nvar maxProfit = function(inventory, orders) {\\n  inventory.sort((a, b) => b - a);\\n  inventory.push(0);\\n  inventory = inventory.map( e => BigInt(e));\\n  let top = inventory[0];\\n  let answer = BigInt(0);\\n  let i = 1;\\n  orders = BigInt(orders);\\n  const len = inventory.length;\\n  while(i < len && orders > 0) {\\n    while(i < len && inventory[i] == top) {\\n      i++;\\n    }\\n    let col = BigInt(i);\\n    let row = BigInt(top - inventory[i]);\\n    let cells = row * col;\\n    let take = min(orders, cells);\\n    let res = take / col;\\n    let rem = take % col;\\n    \\n    answer = (answer + ((summationN(top) - summationN(top - res)) * col) % MOD) % MOD;\\n    answer = (answer + ((top - res) * rem) % MOD) % MOD;\\n    orders -= take;\\n    top = inventory[i];\\n    i++;\\n  }\\n  return answer;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929003,
                "title": "java-greedy-priorityqueue",
                "content": "```\\nclass Solution\\n{\\n    private final int mod = 1_000_000_007;\\n    \\n    public int maxProfit(int[] stock, int orders)\\n    {\\n        long profit = 0;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> (b - a));\\n        Arrays.stream(stock).forEach(maxHeap::add);\\n        long prevMaxCount = 0L;\\n        while (orders > 0)\\n        {\\n            long top = maxHeap.poll();\\n            long maxCount = 1 + prevMaxCount;\\n            while (!maxHeap.isEmpty() && maxHeap.peek() == top)\\n            {\\n                maxHeap.poll();\\n                maxCount++;\\n            }\\n            long second = maxHeap.isEmpty() ? 0L : maxHeap.peek();\\n            long diff = top - second;\\n            if (diff * maxCount >= orders)\\n            {\\n                long toTake = orders / maxCount;\\n                long left = orders - toTake * maxCount;\\n                profit += ((((top + top - (toTake - 1)) * toTake) / 2) * maxCount) % mod;\\n                profit %= mod;\\n                profit += left * (top - toTake) % mod;\\n                profit %= mod;\\n                break;\\n            }\\n            else\\n            {\\n                profit += ((((top + top - (diff - 1)) * diff) / 2) * maxCount) % mod;\\n                profit %= mod;\\n                prevMaxCount = maxCount;\\n                orders -= diff * maxCount;\\n            }\\n        }\\n        return (int)profit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    private final int mod = 1_000_000_007;\\n    \\n    public int maxProfit(int[] stock, int orders)\\n    {\\n        long profit = 0;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> (b - a));\\n        Arrays.stream(stock).forEach(maxHeap::add);\\n        long prevMaxCount = 0L;\\n        while (orders > 0)\\n        {\\n            long top = maxHeap.poll();\\n            long maxCount = 1 + prevMaxCount;\\n            while (!maxHeap.isEmpty() && maxHeap.peek() == top)\\n            {\\n                maxHeap.poll();\\n                maxCount++;\\n            }\\n            long second = maxHeap.isEmpty() ? 0L : maxHeap.peek();\\n            long diff = top - second;\\n            if (diff * maxCount >= orders)\\n            {\\n                long toTake = orders / maxCount;\\n                long left = orders - toTake * maxCount;\\n                profit += ((((top + top - (toTake - 1)) * toTake) / 2) * maxCount) % mod;\\n                profit %= mod;\\n                profit += left * (top - toTake) % mod;\\n                profit %= mod;\\n                break;\\n            }\\n            else\\n            {\\n                profit += ((((top + top - (diff - 1)) * diff) / 2) * maxCount) % mod;\\n                profit %= mod;\\n                prevMaxCount = maxCount;\\n                orders -= diff * maxCount;\\n            }\\n        }\\n        return (int)profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928862,
                "title": "go-2-solutions-with-o-n-log-n",
                "content": "To get maximum profit from selling inventories, each inventory price should be as high as possible, which means selling start from largest number.\\n\\nBasic idea is to pick largest number from max heap (priority queue), this guarantees maximum profit.\\n\\n- Solution 1 - priority queue\\n\\n  Although idea is correct, submission gets TLE, needs further optimation. Time complexity is O(n log(m)), m: size of inventory, n: orders\\n\\n  ```golang\\n\\ttype MaxHeap []int\\n\\n\\tfunc (h MaxHeap) Len() int           { return len(h) }\\n\\tfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\n\\tfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\tfunc (h MaxHeap) Peek() int          { return h[0] }\\n\\n\\tfunc (h *MaxHeap) Push(x interface{}) {\\n\\t\\t*h = append(*h, x.(int))\\n\\t}\\n\\n\\tfunc (h *MaxHeap) Pop() interface{} {\\n\\t    old := *h\\n\\t    n := len(old)\\n\\t    x := old[n-1]\\n\\t    *h = old[0 : n-1]\\n\\t    return x\\n    }\\n\\n    func maxProfit1(inventory []int, orders int) int {\\n\\t    // sell balls with maximum length\\n\\t    h := &MaxHeap{}\\n\\t    heap.Init(h)\\n\\n\\t    var profit int64\\n\\t    mod := int64(1e9 + 7)\\n\\t    heap.Push(h, 0) // always exist one number 0\\n\\n\\t    for _, i := range inventory {\\n\\t\\t    heap.Push(h, i)\\n        }\\n\\n        for i := 0; i < orders; i++ {\\n\\t\\t    tmp := heap.Pop(h).(int)\\n\\t\\t    diff := tmp - h.Peek()\\n\\n            for j := 0; j <= diff && tmp > 0 && i < orders; i, j = i+1, j+1 {\\n\\t\\t\\t    profit += int64(tmp)\\n\\t\\t\\t    if profit > mod {\\n\\t\\t\\t\\t    profit -= mod\\n                }\\n\\t\\t\\t    tmp--\\n\\t\\t    }\\n            i--\\n\\n            heap.Push(h, tmp)\\n\\t    }\\n\\n\\t    return int(profit)\\n    }\\n  ```\\n\\n- Solution 2 - improve from previous\\n\\n  Since first solution is not fast enough, some improvements can be made. One way to observe the problem is from sold sequence.\\n\\n  If inventory array is [2, 4, 6, 8, 10] and all inventories are sold, sold sequence is as follows:\\n\\n  ```\\n  1, 1, 1, 1, 1,\\n  2, 2, 2, 2, 2,\\n  3, 3, 3, 3,\\n  4, 4, 4, 4,\\n  5, 5, 5,\\n  6, 6, 6,\\n  7, 7,\\n  8, 8,\\n  9,\\n  10\\n  ```\\n\\n  orders = k means to select largest k number from a non-decreasing sequence. e.g. same inventory and want to sold 10 inventories:\\n\\n  ```\\n  x - not sold\\n  number - sold price\\n\\n  x, x, x, x, x,\\n  x, x, x, x, x,\\n  x, x, x, x,\\n  x, x, x, x,\\n  x, x, 5,        - sold 1\\n  6, 6, 6,        - sold 3\\n  7, 7,           - sold 2\\n  8, 8,           - sold 2\\n  9,              - sold 1\\n  10              - sold 1\\n\\n  total sold = 1 + 1 + 2 + 2 + 3 + 1 = 10\\n  maximum prices = 10 + 9 + 8 * 2 + 7 * 2 + 6 * 3 + 5\\n  ```\\n\\n  In this calculation, it\\'s crucial to find price `5`, it\\'s the cut-off number that can sold wanted orders. Becase whole sequence is in descending order with some repeated pattern, once cut-off number if found, total profit can also be calculated.\\n\\n  To find cut-off point, one way is to compute from largest number down to 0.\\n  e.g.\\n  sold price at 10 has 1 inventory not enough\\n  sold price at 9 has 1 + 1 = 2 inventories not enough\\n  sold price at 8 has 2 + 2 = 4 inventories not enough\\n  ...\\n\\n   One technique to find cut-off number is using binary search. Because for each inventory, number can be sold for cut-off number can be calculated.\\n\\n   e.g. inventory = [2, 4, 6, 8, 10], orders = 21\\n\\n   possible range 0 ~ 10 (max in inventory), guess cut-off number 5 (not sold when remaining is 5):\\n\\n   For inventory with 10 remaining, it can sold up to 5 inventories (10, 9, 8, 7, 6) = 10 - 5\\n\\n   ```\\n   x - not sold\\n\\n   x, x, x, x, x,\\n   x, x, x, x, x,\\n   x, x, x, x,\\n   x, x, x, x,\\n   x, x, x,\\n   6, x, x,\\n   7, x,\\n   8, x,\\n   9,\\n   10\\n   ```\\n\\n   For inventory with 8 remaing, it can sold up to 3 inventories (8, 7, 6) = 8 - 5\\n\\n   ```\\n   x, x, x, x, x,\\n   x, x, x, x, x,\\n   x, x, x, x,\\n   x, x, x, x,\\n   x, x, x,\\n   6, 6, x,\\n   7, 7,\\n   8, 8,\\n   9,\\n   10\\n   ```\\n\\n   So,  for each inventory to sold at some price, number to sold is `inventory count - guess number`.\\n\\n   When cut-off number is found, need to be careful calculating remaining sold, because there might need additional sold.\\n\\n   e.g. inventory = [2, 4, 6, 8, 10], orders = 10\\n\\n    ```\\n    x - not sold\\n    number- sold price\\n\\n    x, x, x, x, x,\\n    x, x, x, x, x,\\n    x, x, x, x,\\n    x, x, x, x,\\n    x, x, 5,        - sold 1\\n    6, 6, 6,        - sold 3\\n    7, 7,           - sold 2\\n    8, 8,           - sold 2\\n    9,              - sold 1\\n    10              - sold 1\\n    ```\\n\\n    cut-off number is 6, means all invetory will be sold for prices >= 6. But there still need to sold additional 1 inventory with price 5. The reason is because for prices >= 6, there can sold 1 + 1 + 2 + 2 + + 3 = 9, which is not enough for 10.\\n\\n    Knowing this, maximum profit can be calculated. Time complexity is O(n log(m)), n: inventory size, m: maximum value in invetory list\\n\\n    ```golang\\n    func maxProfit(inventory []int, orders int) int {\\n\\t    sort.Slice(inventory, func(i, j int) bool {\\n\\t\\t    return inventory[i] > inventory[j]\\n        })\\n\\n\\t    bound := binarySearch(inventory, orders) // not including bound itself\\n\\n\\t    var profit int64\\n\\t    mod := int64(1e9 + 7)\\n\\n\\t    // add profit to lower bound\\n\\t    for idx := 0; idx < len(inventory) && inventory[idx] > bound; idx++ {\\n\\t\\t    size := inventory[idx] - bound\\n\\t\\t    profit += int64(inventory[idx]+bound+1) * int64(size) / int64(2) % mod\\n\\t\\t    profit = profit % mod\\n        }\\n\\n\\t    count := sumLarger(inventory, bound)\\n\\t    if count < orders {\\n\\t\\t    profit += int64(bound) * int64(orders-count) % mod\\n        }\\n\\n\\t    return int(profit % mod)\\n    }\\n\\n    func sumLarger(inv []int, criteria int) int {\\n\\t    var sum int\\n\\n\\t    for _, i := range inv {\\n\\t\\t    sum += max(0, i-criteria)\\n        }\\n\\n\\t    return sum\\n    }\\n\\n    func binarySearch(inv []int, orders int) int {\\n\\t    var largest int\\n\\t    for _, i := range inv {\\n\\t\\t    largest = max(largest, i)\\n        }\\n\\n\\t    var ans int\\n\\n\\t    for low, high := 0, largest; low <= high; {\\n\\t\\t    mid := low + (high-low)>>1\\n\\t\\t    count := sumLarger(inv, mid)\\n\\n            if count == orders {\\n\\t\\t\\t    return mid\\n\\t\\t    } else if count > orders {\\n\\t\\t\\t    low = mid + 1\\n\\t\\t    } else {\\n\\t\\t\\t    ans = mid\\n\\t\\t\\t    high = mid - 1\\n\\t\\t    }\\n        }\\n\\n\\t    return ans\\n    }\\n    ```",
                "solutionTags": [
                    "Go",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```golang\\n\\ttype MaxHeap []int\\n\\n\\tfunc (h MaxHeap) Len() int           { return len(h) }\\n\\tfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\n\\tfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\tfunc (h MaxHeap) Peek() int          { return h[0] }\\n\\n\\tfunc (h *MaxHeap) Push(x interface{}) {\\n\\t\\t*h = append(*h, x.(int))\\n\\t}\\n\\n\\tfunc (h *MaxHeap) Pop() interface{} {\\n\\t    old := *h\\n\\t    n := len(old)\\n\\t    x := old[n-1]\\n\\t    *h = old[0 : n-1]\\n\\t    return x\\n    }\\n\\n    func maxProfit1(inventory []int, orders int) int {\\n\\t    // sell balls with maximum length\\n\\t    h := &MaxHeap{}\\n\\t    heap.Init(h)\\n\\n\\t    var profit int64\\n\\t    mod := int64(1e9 + 7)\\n\\t    heap.Push(h, 0) // always exist one number 0\\n\\n\\t    for _, i := range inventory {\\n\\t\\t    heap.Push(h, i)\\n        }\\n\\n        for i := 0; i < orders; i++ {\\n\\t\\t    tmp := heap.Pop(h).(int)\\n\\t\\t    diff := tmp - h.Peek()\\n\\n            for j := 0; j <= diff && tmp > 0 && i < orders; i, j = i+1, j+1 {\\n\\t\\t\\t    profit += int64(tmp)\\n\\t\\t\\t    if profit > mod {\\n\\t\\t\\t\\t    profit -= mod\\n                }\\n\\t\\t\\t    tmp--\\n\\t\\t    }\\n            i--\\n\\n            heap.Push(h, tmp)\\n\\t    }\\n\\n\\t    return int(profit)\\n    }\\n  ```\n```\\n  1, 1, 1, 1, 1,\\n  2, 2, 2, 2, 2,\\n  3, 3, 3, 3,\\n  4, 4, 4, 4,\\n  5, 5, 5,\\n  6, 6, 6,\\n  7, 7,\\n  8, 8,\\n  9,\\n  10\\n  ```\n```\\n  x - not sold\\n  number - sold price\\n\\n  x, x, x, x, x,\\n  x, x, x, x, x,\\n  x, x, x, x,\\n  x, x, x, x,\\n  x, x, 5,        - sold 1\\n  6, 6, 6,        - sold 3\\n  7, 7,           - sold 2\\n  8, 8,           - sold 2\\n  9,              - sold 1\\n  10              - sold 1\\n\\n  total sold = 1 + 1 + 2 + 2 + 3 + 1 = 10\\n  maximum prices = 10 + 9 + 8 * 2 + 7 * 2 + 6 * 3 + 5\\n  ```\n```\\n   x - not sold\\n\\n   x, x, x, x, x,\\n   x, x, x, x, x,\\n   x, x, x, x,\\n   x, x, x, x,\\n   x, x, x,\\n   6, x, x,\\n   7, x,\\n   8, x,\\n   9,\\n   10\\n   ```\n```\\n   x, x, x, x, x,\\n   x, x, x, x, x,\\n   x, x, x, x,\\n   x, x, x, x,\\n   x, x, x,\\n   6, 6, x,\\n   7, 7,\\n   8, 8,\\n   9,\\n   10\\n   ```\n```\\n    x - not sold\\n    number- sold price\\n\\n    x, x, x, x, x,\\n    x, x, x, x, x,\\n    x, x, x, x,\\n    x, x, x, x,\\n    x, x, 5,        - sold 1\\n    6, 6, 6,        - sold 3\\n    7, 7,           - sold 2\\n    8, 8,           - sold 2\\n    9,              - sold 1\\n    10              - sold 1\\n    ```\n```golang\\n    func maxProfit(inventory []int, orders int) int {\\n\\t    sort.Slice(inventory, func(i, j int) bool {\\n\\t\\t    return inventory[i] > inventory[j]\\n        })\\n\\n\\t    bound := binarySearch(inventory, orders) // not including bound itself\\n\\n\\t    var profit int64\\n\\t    mod := int64(1e9 + 7)\\n\\n\\t    // add profit to lower bound\\n\\t    for idx := 0; idx < len(inventory) && inventory[idx] > bound; idx++ {\\n\\t\\t    size := inventory[idx] - bound\\n\\t\\t    profit += int64(inventory[idx]+bound+1) * int64(size) / int64(2) % mod\\n\\t\\t    profit = profit % mod\\n        }\\n\\n\\t    count := sumLarger(inventory, bound)\\n\\t    if count < orders {\\n\\t\\t    profit += int64(bound) * int64(orders-count) % mod\\n        }\\n\\n\\t    return int(profit % mod)\\n    }\\n\\n    func sumLarger(inv []int, criteria int) int {\\n\\t    var sum int\\n\\n\\t    for _, i := range inv {\\n\\t\\t    sum += max(0, i-criteria)\\n        }\\n\\n\\t    return sum\\n    }\\n\\n    func binarySearch(inv []int, orders int) int {\\n\\t    var largest int\\n\\t    for _, i := range inv {\\n\\t\\t    largest = max(largest, i)\\n        }\\n\\n\\t    var ans int\\n\\n\\t    for low, high := 0, largest; low <= high; {\\n\\t\\t    mid := low + (high-low)>>1\\n\\t\\t    count := sumLarger(inv, mid)\\n\\n            if count == orders {\\n\\t\\t\\t    return mid\\n\\t\\t    } else if count > orders {\\n\\t\\t\\t    low = mid + 1\\n\\t\\t    } else {\\n\\t\\t\\t    ans = mid\\n\\t\\t\\t    high = mid - 1\\n\\t\\t    }\\n        }\\n\\n\\t    return ans\\n    }\\n    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 928630,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] nums, int orders) {\\n        long low = 0, high = 1_000_000_000, order = orders;\\n        while(low < high) {\\n            long count = 0, mid = low + (high - low) / 2;\\n            for(int num : nums)\\n                count += Math.max(0, num - mid);\\n            if(count > order)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        long result = 0;\\n        for(int num : nums) {\\n            if(num > low) {\\n                long n = num, l = low;\\n                result += (n * (n + 1) / 2) - (l * (l + 1) / 2);\\n                result = result % 1_000_000_007;\\n                order -= (num - low);\\n            }\\n        }\\n        \\n        return (int)((result + low * order) % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] nums, int orders) {\\n        long low = 0, high = 1_000_000_000, order = orders;\\n        while(low < high) {\\n            long count = 0, mid = low + (high - low) / 2;\\n            for(int num : nums)\\n                count += Math.max(0, num - mid);\\n            if(count > order)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        long result = 0;\\n        for(int num : nums) {\\n            if(num > low) {\\n                long n = num, l = low;\\n                result += (n * (n + 1) / 2) - (l * (l + 1) / 2);\\n                result = result % 1_000_000_007;\\n                order -= (num - low);\\n            }\\n        }\\n        \\n        return (int)((result + low * order) % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928124,
                "title": "o-n-log-n-easy-and-straightforward-solution",
                "content": "Pretty simple question.\\nJust for ease of writting, I created <strong> calc(n, r) </strong> which returns sum of numbers from [r+1, n].\\n\\n<strong> ALGORITHM </strong>\\n- Sort array in descending order.\\n- For each i, calculate number of changes for converting all elements till i, to value at <strong> i+1</strong> (Simple Maths can do that, <i> (i+1)*cnt</i> ). \\n- Also, For each i, calculate <strong> cost </strong> of converting all elements till i, to value at <strong> i+1</strong>.\\n- *IF*: the  number of changes is more than or equal to orders, then update **res** and break.\\n- *ELSE*: update **res** and update **orders**.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    \\n    long calc(long n, long r){\\n        long a= n*(n+1)/2;\\n        long b= r*(r+1)/2;\\n        \\n        return (a-b)%M;\\n    }\\n    \\n    int maxProfit(vector<int>& inv, int orders) {\\n        int n=inv.size();\\n        sort(inv.begin(), inv.end(), greater<int>());\\n        long res=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            long next = ( (i+1)<n )? inv[i+1] : 0;\\n            long x = inv[i]-next;\\n            \\n            if(x*(i+1) >= orders){\\n                int cnt = orders/(i+1);\\n                res = (res+ (i+1)*calc(inv[i], inv[i]-cnt) )%M;\\n                \\n                orders %= (i+1);\\n                res = (res+ 1LL*orders*(inv[i]-cnt))%M;\\n                break;\\n            }\\n            \\n            res= ( res + (i+1)*calc(inv[i], next))%M;\\n            orders -= (i+1)*x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nHope you guys understood the soution. If any doubts, hit in the comments section.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    \\n    long calc(long n, long r){\\n        long a= n*(n+1)/2;\\n        long b= r*(r+1)/2;\\n        \\n        return (a-b)%M;\\n    }\\n    \\n    int maxProfit(vector<int>& inv, int orders) {\\n        int n=inv.size();\\n        sort(inv.begin(), inv.end(), greater<int>());\\n        long res=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            long next = ( (i+1)<n )? inv[i+1] : 0;\\n            long x = inv[i]-next;\\n            \\n            if(x*(i+1) >= orders){\\n                int cnt = orders/(i+1);\\n                res = (res+ (i+1)*calc(inv[i], inv[i]-cnt) )%M;\\n                \\n                orders %= (i+1);\\n                res = (res+ 1LL*orders*(inv[i]-cnt))%M;\\n                break;\\n            }\\n            \\n            res= ( res + (i+1)*calc(inv[i], next))%M;\\n            orders -= (i+1)*x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927644,
                "title": "ruby-python-combine-colored-bolls-with-same-num-sort-desc-sell-up-to-the-next-num",
                "content": "Combine colored bolls with same available number in inventory, sort by number descending.\\nEach iteration sell max number up to the next number.\\n\\n```\\nMOD = 1000000007\\ndef max_profit(inventory, orders)\\n  res = 0\\n  colors_of_count = Hash.new(0)\\n  inventory.each { |cnt| colors_of_count[cnt] += 1 }\\n  # list of balls count and different colors (types) which has such count in the inventory.\\n  # sorted by available count descending.\\n  inv = colors_of_count.sort_by(&:first).reverse\\n  while orders > 0\\n    n, t = inv.shift\\n    n0 = inv.first&.first || 0 # next number of bolls\\n\\t# sell bolls of each color with max number till reach the next number.\\n    # max count to sell on this iteration is `k * t` bolls\\n    k = n - n0\\n    if orders >= k * t\\n      orders -= k * t\\n\\t  # use arithmetic progression formula and multiply by `t`.\\n      # t * (n + n-1 + n-2 + ... + n-k+1)\\n      res = (res + t * ((n + n0 + 1) * k / 2)) % MOD\\n      inv[0][1] += t unless inv.empty? # increase next number of bolls colors (types)\\n    else\\n      # sell all remaining orders\\n      k = orders / t\\n\\t  # t * (n + n-1 + n-2 + ... + n-k+1)\\n      res = (res + t * (n + n - k + 1) * k / 2) % MOD\\n      orders -= (t * k)\\n      return (res + (n - k) * orders) % MOD\\n    end\\n  end\\n  res\\nend\\n# Runtime: 228 ms\\n```\\n\\nPython version:\\n\\n```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n    res, mod = 0, 1000000007\\n    f = {}\\n    for cnt in inventory:\\n        if cnt in f:\\n            f[cnt] += 1\\n        else:\\n            f[cnt] = 1\\n\\n    inv = [[c, f[c]] for c in f]\\n    inv.sort()\\n\\n    while orders > 0:\\n        n, t = inv.pop()\\n        n0 = inv[-1][0] if inv else 0 # next number of bolls\\n        k = n - n0\\n        if orders >= k * t:\\n            orders -= k * t\\n            res = (res + t * ((n + n0 + 1) * k // 2)) % mod\\n            if inv:\\n                inv[-1][1] += t\\n        else:\\n            k = orders // t\\n            res = (res + t * (n + n - k + 1) * k // 2) % mod\\n            orders -= (t * k)\\n            return (res + (n - k) * orders) % mod\\n    return res\\n# Runtime: 832 ms\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ruby"
                ],
                "code": "```\\nMOD = 1000000007\\ndef max_profit(inventory, orders)\\n  res = 0\\n  colors_of_count = Hash.new(0)\\n  inventory.each { |cnt| colors_of_count[cnt] += 1 }\\n  # list of balls count and different colors (types) which has such count in the inventory.\\n  # sorted by available count descending.\\n  inv = colors_of_count.sort_by(&:first).reverse\\n  while orders > 0\\n    n, t = inv.shift\\n    n0 = inv.first&.first || 0 # next number of bolls\\n\\t# sell bolls of each color with max number till reach the next number.\\n    # max count to sell on this iteration is `k * t` bolls\\n    k = n - n0\\n    if orders >= k * t\\n      orders -= k * t\\n\\t  # use arithmetic progression formula and multiply by `t`.\\n      # t * (n + n-1 + n-2 + ... + n-k+1)\\n      res = (res + t * ((n + n0 + 1) * k / 2)) % MOD\\n      inv[0][1] += t unless inv.empty? # increase next number of bolls colors (types)\\n    else\\n      # sell all remaining orders\\n      k = orders / t\\n\\t  # t * (n + n-1 + n-2 + ... + n-k+1)\\n      res = (res + t * (n + n - k + 1) * k / 2) % MOD\\n      orders -= (t * k)\\n      return (res + (n - k) * orders) % MOD\\n    end\\n  end\\n  res\\nend\\n# Runtime: 228 ms\\n```\n```\\ndef maxProfit(self, inventory: List[int], orders: int) -> int:\\n    res, mod = 0, 1000000007\\n    f = {}\\n    for cnt in inventory:\\n        if cnt in f:\\n            f[cnt] += 1\\n        else:\\n            f[cnt] = 1\\n\\n    inv = [[c, f[c]] for c in f]\\n    inv.sort()\\n\\n    while orders > 0:\\n        n, t = inv.pop()\\n        n0 = inv[-1][0] if inv else 0 # next number of bolls\\n        k = n - n0\\n        if orders >= k * t:\\n            orders -= k * t\\n            res = (res + t * ((n + n0 + 1) * k // 2)) % mod\\n            if inv:\\n                inv[-1][1] += t\\n        else:\\n            k = orders // t\\n            res = (res + t * (n + n - k + 1) * k // 2) % mod\\n            orders -= (t * k)\\n            return (res + (n - k) * orders) % mod\\n    return res\\n# Runtime: 832 ms\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927603,
                "title": "greedy-max-heap-solution-help-needed-for-optimizing",
                "content": "Tried solving it greedily. Passes all the sample test cases, but getting a TLE for the testcase:\\n[497978859,167261111,483575207,591815159]\\n836556809\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((x, y) -> Integer.compare(y, x));\\n        long sum=0;\\n        for(int i:inventory){\\n            heap.add(i);\\n        }\\n        int constant = 1000000007;\\n        int res=0;\\n        \\n        while(orders>0){\\n            int mr = heap.poll();\\n            if(mr<=0) break;\\n            int diff=mr+1;\\n            int next=(heap.size()>0)?heap.peek():0;\\n            diff-=(next!=0)?next:1;\\n            \\n            if(diff>=orders){\\n                diff=orders;\\n            }\\n            \\n            long ans = (calc(mr)-calc(mr-diff));\\n            res=(int)((res+ans)%constant);\\n            \\n            orders-=diff;\\n            heap.add(mr-diff);\\n        }\\n        return res;\\n    } \\n    \\n    private long calc(int n){\\n        if(n<=0) return 0;\\n        long res = (long)n*(n+1)/2;\\n        return res;\\n    }\\n}\\n```\\n\\nThankyou",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((x, y) -> Integer.compare(y, x));\\n        long sum=0;\\n        for(int i:inventory){\\n            heap.add(i);\\n        }\\n        int constant = 1000000007;\\n        int res=0;\\n        \\n        while(orders>0){\\n            int mr = heap.poll();\\n            if(mr<=0) break;\\n            int diff=mr+1;\\n            int next=(heap.size()>0)?heap.peek():0;\\n            diff-=(next!=0)?next:1;\\n            \\n            if(diff>=orders){\\n                diff=orders;\\n            }\\n            \\n            long ans = (calc(mr)-calc(mr-diff));\\n            res=(int)((res+ans)%constant);\\n            \\n            orders-=diff;\\n            heap.add(mr-diff);\\n        }\\n        return res;\\n    } \\n    \\n    private long calc(int n){\\n        if(n<=0) return 0;\\n        long res = (long)n*(n+1)/2;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927577,
                "title": "a-brute-force-solution-python3",
                "content": "a  brute force solution for you to laugh at\\n\\n\\t\\tclass Solution:\\n\\t\\tdef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\t\\t\\tif len(inventory) == 1:\\n\\t\\t\\t\\treturn (inventory[0] + (inventory[0]- orders + 1)) * orders // 2 % (10**9 + 7)        \\n\\t\\t\\tinventory.sort(reverse = True)\\n\\t\\t\\tcnt, res = 1, 0\\n\\t\\t\\twhile orders > 0 and inventory:\\n\\t\\t\\t\\tif len(inventory) >= 2:\\n\\t\\t\\t\\t\\th = inventory[0] - inventory[1]\\n\\t\\t\\t\\t\\tif orders >= h * cnt:\\n\\t\\t\\t\\t\\t\\torders -= h * cnt\\n\\t\\t\\t\\t\\t\\tres += ((inventory[0] + (inventory[1]+1) ) * h // 2  * cnt) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\t\\t\\tinventory.pop(0)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th = orders // cnt\\n\\t\\t\\t\\t\\t\\torders = orders % cnt\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] + (inventory[0] - h + 1)) * h // 2 * cnt\\n\\t\\t\\t\\t\\t\\tres += orders * (inventory[0] - h)\\n\\t\\t\\t\\t\\t\\torders = 0\\n\\t\\t\\t\\t\\t\\treturn res % (10**9 + 7)            \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif orders >= cnt:\\n\\t\\t\\t\\t\\t\\torders -= cnt\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] * cnt) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\tinventory[0] -= 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] * orders) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\torders = 0\\n\\t\\t\\treturn res % (10**9 + 7)",
                "solutionTags": [],
                "code": "a  brute force solution for you to laugh at\\n\\n\\t\\tclass Solution:\\n\\t\\tdef maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\t\\t\\tif len(inventory) == 1:\\n\\t\\t\\t\\treturn (inventory[0] + (inventory[0]- orders + 1)) * orders // 2 % (10**9 + 7)        \\n\\t\\t\\tinventory.sort(reverse = True)\\n\\t\\t\\tcnt, res = 1, 0\\n\\t\\t\\twhile orders > 0 and inventory:\\n\\t\\t\\t\\tif len(inventory) >= 2:\\n\\t\\t\\t\\t\\th = inventory[0] - inventory[1]\\n\\t\\t\\t\\t\\tif orders >= h * cnt:\\n\\t\\t\\t\\t\\t\\torders -= h * cnt\\n\\t\\t\\t\\t\\t\\tres += ((inventory[0] + (inventory[1]+1) ) * h // 2  * cnt) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\t\\t\\tinventory.pop(0)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th = orders // cnt\\n\\t\\t\\t\\t\\t\\torders = orders % cnt\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] + (inventory[0] - h + 1)) * h // 2 * cnt\\n\\t\\t\\t\\t\\t\\tres += orders * (inventory[0] - h)\\n\\t\\t\\t\\t\\t\\torders = 0\\n\\t\\t\\t\\t\\t\\treturn res % (10**9 + 7)            \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif orders >= cnt:\\n\\t\\t\\t\\t\\t\\torders -= cnt\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] * cnt) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\tinventory[0] -= 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += (inventory[0] * orders) % (10**9 + 7)\\n\\t\\t\\t\\t\\t\\torders = 0\\n\\t\\t\\treturn res % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 4075244,
                "title": "easy-to-understand-javascript-solution-greedy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar maxProfit = function(inventory, orders) {\\n    const MODULO = BigInt(10 ** 9 + 7);\\n    const size = inventory.length;\\n    let result = BigInt(0);\\n    let index = 0;\\n\\n    inventory.sort((a, b) => b - a);\\n    let current = inventory[0];\\n\\n    while (orders > 0) {\\n        while (index < size && inventory[index] === current) index += 1;\\n        const next = index === size ? 0 : inventory[index];\\n        let times = current - next;\\n        let remain = 0;\\n        const count = index * times;\\n\\n        if (orders < count) {\\n            times = Math.floor(orders / index);\\n            remain = orders % index;\\n        }\\n        const endValue = current - times;\\n        const sell = (BigInt(current + endValue + 1) * BigInt(times * index) / 2n) % MODULO;\\n\\n        result = (result + sell + BigInt(endValue * remain)) % MODULO;\\n        orders -= count;\\n        current = next;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(inventory, orders) {\\n    const MODULO = BigInt(10 ** 9 + 7);\\n    const size = inventory.length;\\n    let result = BigInt(0);\\n    let index = 0;\\n\\n    inventory.sort((a, b) => b - a);\\n    let current = inventory[0];\\n\\n    while (orders > 0) {\\n        while (index < size && inventory[index] === current) index += 1;\\n        const next = index === size ? 0 : inventory[index];\\n        let times = current - next;\\n        let remain = 0;\\n        const count = index * times;\\n\\n        if (orders < count) {\\n            times = Math.floor(orders / index);\\n            remain = orders % index;\\n        }\\n        const endValue = current - times;\\n        const sell = (BigInt(current + endValue + 1) * BigInt(times * index) / 2n) % MODULO;\\n\\n        result = (result + sell + BigInt(endValue * remain)) % MODULO;\\n        orders -= count;\\n        current = next;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003154,
                "title": "c-solution-using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution is just a C# version from the approach https://leetcode.com/problems/sell-diminishing-valued-colored-balls/solutions/1116418/java-sorting-solution-easy-to-understand-o-nlogn/, not come up originally.\\n\\n# Complexity\\n- Time complexity:\\nO(NLog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] inventory, int orders)\\n    {\\n        long tot = 0;\\n        int cnt = 0;\\n        int n = inventory.Length;\\n        System.Array.Sort(inventory, (e1, e2) => e2 - e1);\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        int idx = 0;\\n\\n        while (idx < n)\\n        {\\n            int currVal = inventory[idx];\\n            while (idx < n - 1 && inventory[idx + 1] == inventory[idx])\\n            {\\n                idx++;\\n            }\\n\\n            int totRows = idx + 1;\\n            int nextVal = idx == n - 1 ? 0 : inventory[idx + 1];\\n\\n            long tryAdd = (long)totRows * (currVal - nextVal);\\n\\n            if (cnt + tryAdd <= orders)\\n            {\\n                tot += (long)(currVal + nextVal + 1) * (currVal - nextVal) / 2 * totRows;\\n                tot %= mod;\\n                \\n                idx++;\\n                cnt += (int)tryAdd;\\n            }\\n            else\\n            {\\n                int prevCols = (orders - cnt) / totRows;\\n                int remn = (orders - cnt) % totRows;\\n\\n                nextVal = currVal - prevCols;\\n                tot += (long)(currVal + nextVal + 1) * (currVal - nextVal) / 2 * totRows;\\n                tot %= mod;\\n\\n                tot += (long)nextVal*remn;\\n                tot %= mod;\\n                break;\\n            }\\n        }\\n\\n        return (int)tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] inventory, int orders)\\n    {\\n        long tot = 0;\\n        int cnt = 0;\\n        int n = inventory.Length;\\n        System.Array.Sort(inventory, (e1, e2) => e2 - e1);\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        int idx = 0;\\n\\n        while (idx < n)\\n        {\\n            int currVal = inventory[idx];\\n            while (idx < n - 1 && inventory[idx + 1] == inventory[idx])\\n            {\\n                idx++;\\n            }\\n\\n            int totRows = idx + 1;\\n            int nextVal = idx == n - 1 ? 0 : inventory[idx + 1];\\n\\n            long tryAdd = (long)totRows * (currVal - nextVal);\\n\\n            if (cnt + tryAdd <= orders)\\n            {\\n                tot += (long)(currVal + nextVal + 1) * (currVal - nextVal) / 2 * totRows;\\n                tot %= mod;\\n                \\n                idx++;\\n                cnt += (int)tryAdd;\\n            }\\n            else\\n            {\\n                int prevCols = (orders - cnt) / totRows;\\n                int remn = (orders - cnt) % totRows;\\n\\n                nextVal = currVal - prevCols;\\n                tot += (long)(currVal + nextVal + 1) * (currVal - nextVal) / 2 * totRows;\\n                tot %= mod;\\n\\n                tot += (long)nextVal*remn;\\n                tot %= mod;\\n                break;\\n            }\\n        }\\n\\n        return (int)tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977908,
                "title": "java-o-n-solution-recursive-partitioning-similar-to-quickselect-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first glance, this problem seems like it requires sorting, implying a $$\\\\Omega(n\\\\log n)$$ time bound. However, it really only requires *partitioning*, which only requires $$\\\\Omega(n)$$ time.\\n\\nThe idea is similar to quickselect (see https://en.wikipedia.org/wiki/Quickselect).\\n\\nWe choose a pivot, and partition the array into two groups: elements smaller than the pivot, and elements larger than the pivot. We then check if we can fulfill all our orders using only elements larger (and more valuable) than the pivot. If so, we recurse on those elements, discarding the rest. If not, we instead recurse on the group of elements smaller than the pivot, and carry along sums of the number of elements greater than our new recursive subgroup, as well as their value.\\n\\nThe recursion discards a constant fraction of the array in each iteration, on average, so the total time will be $$O(n)$$ as long as we are not exceptionally unlucky when choosing pivots.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThroughout the algorithm we maintain a window from `low` to `high`. We also maintain several sums and counts:\\n- `orders` is the number of balls we still need to sell\\n- `extraColors` is the number of ball colors that are outside of our current window that we haven\\'t sold and therefore still need to track\\n- `extraCounts` is the number of balls that we have left of each of the `extraColors` colors (when recursing, we arrange for them to all have the same count)\\n- `value` is the total value of the balls we\\'ve sold so far\\n\\nIn each recursive call, we will partition our window into two groups using a pivot, with one group greater than the pivot and one group lesser than the pivot. We will then use the pivot as a threshold and try to sell balls of the greater group until we have reduced their counts down to the same count as the pivot.\\n\\nWhen we do this, we will either find that we have sold too many balls, in which case we can discard the lesser group and recurse on the greater group to find a better pivot, or we will find that we haven\\'t sold enough balls, in which case we can recurse on the lesser group and add the greater group\\'s balls and value into the sums we are maintaining (`extraColors`, `extraCounts`, and `value`).\\n\\nSpecifically, in each recursive call, we do the following:\\n\\n- Choose a pivot from the elements in our current window.\\n- Scan through the window, partitioning the elements into two groups by moving them to the left side or the right side of the window. Also keep track of the number of elements equal to the pivot.\\n- For each element greater than the pivot, add its excess above the pivot into a sum (we will be attempting to sell the balls in excess of the pivot).\\n- Also add the value of this excess into a separate sum. We can compute this value using a variation of the $$\\\\frac{(n+1)n}{2}$$ formula for the sum of an arithmetic sequence.\\n- Check if selling all balls above the pivot threshold will exceed our remaining `orders`. If so, recurse on the larger group. If not, recurse on the smaller group, adding the counts and values we computed into our `extraColors`, `extraCounts`, and `value` parameters, and decreasing the `orders` parameter appropriately.\\n- At some point, we will either run out of orders or our window will be of size $$0$$. In either case, we just compute the final value based on what we have kept track of and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\nEach recursive call will discard a constant fraction of the elements in the array, on average. The times spent in each call will then be bounded by a geometric series that converges to a constant multiple of $$n$$.\\n\\nNote that if we are exceptionally unlucky with choosing pivots, the performance can be as bad as $$O(n^2)$$. To fix this, we can use a median-of-medians strategy (https://en.wikipedia.org/wiki/Median_of_medians) to guarantee that we select a good pivot, but this adds a lot of overhead.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        return partition(Arrays.copyOf(inventory, inventory.length), 0, inventory.length, orders, 0, 0, 0, new Random(4782987397424892L));\\n    }\\n\\n    private int partition(int[] inventory, int low, int high, int orders, int extraColors, int extraCounts, int value, Random random) {\\n        if (orders == 0) {\\n            return value;\\n        }\\n\\n        if (high - low == 0) {\\n            if ((long)extraColors * extraCounts <= orders) {\\n                return (int)((value + (extraColors * ((long)extraCounts + 1)) % 1000000007 * extraCounts / 2) % 1000000007);\\n            }\\n\\n            return (int)((value + extraColors * ((2L * extraCounts - orders / extraColors + 1) * (orders / extraColors) / 2 % 1000000007) + orders % extraColors * ((long)extraCounts - orders / extraColors) % 1000000007) % 1000000007);\\n        }\\n\\n        long pivot = inventory[low + random.nextInt(high - low)];\\n        int i = low;\\n        int j = high;\\n        int k = low;\\n        long newCounts = 0;\\n        long newValue = 0;\\n        while (k < j) {\\n            if (inventory[k] < pivot) {\\n                inventory[i] = inventory[k];\\n                i++;\\n                k++;\\n                continue;\\n            }\\n\\n            if (inventory[k] == pivot) {\\n                k++;\\n                continue;\\n            }\\n\\n            j--;\\n            int tmp = inventory[j];\\n            inventory[j] = inventory[k];\\n            inventory[k] = tmp;\\n            newCounts += inventory[j] - pivot;\\n            newValue = (newValue + (inventory[j] - pivot) * (inventory[j] + pivot + 1) / 2) % 1000000007;\\n        }\\n\\n        if (newCounts + extraColors * (extraCounts - pivot) > orders) {\\n            return partition(inventory, j, high, orders, extraColors, extraCounts, value, random);\\n        }\\n\\n        return partition(inventory, low, i, (int)(orders - newCounts - extraColors * (extraCounts - pivot)), extraColors - i + high, (int)pivot, (int)(((long)value + newValue + extraColors * (((long)extraCounts - pivot) * (extraCounts + pivot + 1) / 2 % 1000000007)) % 1000000007), random);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Quickselect",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        return partition(Arrays.copyOf(inventory, inventory.length), 0, inventory.length, orders, 0, 0, 0, new Random(4782987397424892L));\\n    }\\n\\n    private int partition(int[] inventory, int low, int high, int orders, int extraColors, int extraCounts, int value, Random random) {\\n        if (orders == 0) {\\n            return value;\\n        }\\n\\n        if (high - low == 0) {\\n            if ((long)extraColors * extraCounts <= orders) {\\n                return (int)((value + (extraColors * ((long)extraCounts + 1)) % 1000000007 * extraCounts / 2) % 1000000007);\\n            }\\n\\n            return (int)((value + extraColors * ((2L * extraCounts - orders / extraColors + 1) * (orders / extraColors) / 2 % 1000000007) + orders % extraColors * ((long)extraCounts - orders / extraColors) % 1000000007) % 1000000007);\\n        }\\n\\n        long pivot = inventory[low + random.nextInt(high - low)];\\n        int i = low;\\n        int j = high;\\n        int k = low;\\n        long newCounts = 0;\\n        long newValue = 0;\\n        while (k < j) {\\n            if (inventory[k] < pivot) {\\n                inventory[i] = inventory[k];\\n                i++;\\n                k++;\\n                continue;\\n            }\\n\\n            if (inventory[k] == pivot) {\\n                k++;\\n                continue;\\n            }\\n\\n            j--;\\n            int tmp = inventory[j];\\n            inventory[j] = inventory[k];\\n            inventory[k] = tmp;\\n            newCounts += inventory[j] - pivot;\\n            newValue = (newValue + (inventory[j] - pivot) * (inventory[j] + pivot + 1) / 2) % 1000000007;\\n        }\\n\\n        if (newCounts + extraColors * (extraCounts - pivot) > orders) {\\n            return partition(inventory, j, high, orders, extraColors, extraCounts, value, random);\\n        }\\n\\n        return partition(inventory, low, i, (int)(orders - newCounts - extraColors * (extraCounts - pivot)), extraColors - i + high, (int)pivot, (int)(((long)value + newValue + extraColors * (((long)extraCounts - pivot) * (extraCounts + pivot + 1) / 2 % 1000000007)) % 1000000007), random);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447814,
                "title": "find-error",
                "content": "can anybody help me to find my mistake?? why my answer is not right\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        res = 0\\n        sorted(inventory)\\n        while orders>0:\\n            for i in range(len(inventory)):\\n                while inventory[i]>1:\\n                    res += inventory[i]\\n                    inventory[i] -= 1\\n                    orders -= 1\\n                    if orders == 0:\\n                        return res\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        res = 0\\n        sorted(inventory)\\n        while orders>0:\\n            for i in range(len(inventory)):\\n                while inventory[i]>1:\\n                    res += inventory[i]\\n                    inventory[i] -= 1\\n                    orders -= 1\\n                    if orders == 0:\\n                        return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391536,
                "title": "python3-heap-680-ms",
                "content": "```py3\\nclass Solution:\\n    def maxProfit(self, h: List[int], orders: int) -> int:\\n        MOD = int(1e9 + 7)\\n        def series_sum_length(b, i):\\n            a = b - (i - 1)\\n            a_quotient, a_remainder = divmod(a * i, 2)\\n            b_quotient, b_remainder = divmod(b * i, 2)\\n            result = (a_quotient % MOD + b_quotient % MOD + b_remainder % MOD) % MOD\\n            return int(result)\\n        h = [-v for v in h]\\n        heapify(h)\\n        ans = 0\\n        multiplier = 1\\n        ret = False\\n        while orders > 0:\\n            last = heappop(h)\\n            if not h:\\n                return (ans + series_sum_length(-last, orders)) % MOD\\n            ball = heappop(h)\\n            while ball == last:\\n                multiplier += 1\\n                if not h:\\n                    ret = True\\n                    break\\n                ball = heappop(h)\\n            res, rem = divmod(orders, multiplier)\\n            if ret or res < ball - last:\\n                ans += (series_sum_length(-last, res) * multiplier) % MOD\\n                ans %= MOD\\n                ans += ((-last - res) * rem) % MOD\\n                return ans % MOD\\n            ans += (series_sum_length(-last, ball - last) * multiplier) % MOD\\n            ans %= MOD\\n            res -= ball - last\\n            orders = multiplier * res + rem\\n            heappush(h, ball)\\n            heappush(h, ball)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py3\\nclass Solution:\\n    def maxProfit(self, h: List[int], orders: int) -> int:\\n        MOD = int(1e9 + 7)\\n        def series_sum_length(b, i):\\n            a = b - (i - 1)\\n            a_quotient, a_remainder = divmod(a * i, 2)\\n            b_quotient, b_remainder = divmod(b * i, 2)\\n            result = (a_quotient % MOD + b_quotient % MOD + b_remainder % MOD) % MOD\\n            return int(result)\\n        h = [-v for v in h]\\n        heapify(h)\\n        ans = 0\\n        multiplier = 1\\n        ret = False\\n        while orders > 0:\\n            last = heappop(h)\\n            if not h:\\n                return (ans + series_sum_length(-last, orders)) % MOD\\n            ball = heappop(h)\\n            while ball == last:\\n                multiplier += 1\\n                if not h:\\n                    ret = True\\n                    break\\n                ball = heappop(h)\\n            res, rem = divmod(orders, multiplier)\\n            if ret or res < ball - last:\\n                ans += (series_sum_length(-last, res) * multiplier) % MOD\\n                ans %= MOD\\n                ans += ((-last - res) * rem) % MOD\\n                return ans % MOD\\n            ans += (series_sum_length(-last, ball - last) * multiplier) % MOD\\n            ans %= MOD\\n            res -= ball - last\\n            orders = multiplier * res + rem\\n            heappush(h, ball)\\n            heappush(h, ball)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307482,
                "title": "c",
                "content": "```\\nclass Solution {\\n    const int M = 1e9 + 7;\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(), inventory.end(), greater<int>());\\n        long long ans = 0, count = 1;\\n        for (auto i=0; i<inventory.size(); ++i) {\\n            long long cur = inventory[i];\\n            long long nxt ; \\n            if(i == inventory.size() -1)\\n                nxt = 0 ;\\n            else\\n                nxt = inventory[i+1] ;\\n            if ((cur - nxt) * count <= orders) {\\n                ans = (ans + (cur + (nxt+1)) * (cur-nxt) / 2 * count) % M;\\n                orders -= (cur - nxt) * count;\\n                ++count;\\n            } else {\\n                int stop = orders / count;\\n                ans = (ans + (cur + (cur-stop+1)) * stop / 2 * count) % M;\\n                ans = (ans + (orders % count) * (cur-stop)) % M;\\n                break;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int M = 1e9 + 7;\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(), inventory.end(), greater<int>());\\n        long long ans = 0, count = 1;\\n        for (auto i=0; i<inventory.size(); ++i) {\\n            long long cur = inventory[i];\\n            long long nxt ; \\n            if(i == inventory.size() -1)\\n                nxt = 0 ;\\n            else\\n                nxt = inventory[i+1] ;\\n            if ((cur - nxt) * count <= orders) {\\n                ans = (ans + (cur + (nxt+1)) * (cur-nxt) / 2 * count) % M;\\n                orders -= (cur - nxt) * count;\\n                ++count;\\n            } else {\\n                int stop = orders / count;\\n                ans = (ans + (cur + (cur-stop+1)) * stop / 2 * count) % M;\\n                ans = (ans + (orders % count) * (cur-stop)) % M;\\n                break;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138018,
                "title": "c-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to sort the inventory in descending order and then look for the longest consecutive sequence of numbers. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to use a greedy algorithm to solve this problem. First, we sort the inventory in descending order. Then, we loop through and find the longest consecutive sequence of numbers. Then, we calculate the number of items that can be sold for that sequence and subtract it from the total number of orders. We then loop through and subtract the number of items sold from each item\\'s inventory count until we reach 0 orders. Finally, we add the total number of items sold multiplied by the last item\\'s inventory count.\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int mod = 1e9 + 7;\\n        sort(inventory.begin(), inventory.end(), greater<int>());\\n        long long ans = 0;\\n        for (int i = 0; i < inventory.size() && orders > 0; i++) {\\n            long long cur = inventory[i];\\n            long long next = i + 1 < inventory.size() ? inventory[i + 1] : 0;\\n            if (cur <= next) {\\n                continue;\\n            }\\n            long long diff = cur - next;\\n            long long count = (i + 1) * diff;\\n            if (orders >= count) {\\n                ans += (cur + next + 1) * diff / 2 * (i + 1);\\n                ans %= mod;\\n                orders -= count;\\n            } else {\\n                long long q = orders / (i + 1), r = orders % (i + 1);\\n                ans += (cur + cur - q + 1) * q / 2 * (i + 1);\\n                ans %= mod;\\n                ans += (cur - q) * r;\\n                ans %= mod;\\n                orders = 0;\\n            }\\n        }\\n        if (orders > 0) {\\n            ans += (long long)inventory.back() * orders;\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int mod = 1e9 + 7;\\n        sort(inventory.begin(), inventory.end(), greater<int>());\\n        long long ans = 0;\\n        for (int i = 0; i < inventory.size() && orders > 0; i++) {\\n            long long cur = inventory[i];\\n            long long next = i + 1 < inventory.size() ? inventory[i + 1] : 0;\\n            if (cur <= next) {\\n                continue;\\n            }\\n            long long diff = cur - next;\\n            long long count = (i + 1) * diff;\\n            if (orders >= count) {\\n                ans += (cur + next + 1) * diff / 2 * (i + 1);\\n                ans %= mod;\\n                orders -= count;\\n            } else {\\n                long long q = orders / (i + 1), r = orders % (i + 1);\\n                ans += (cur + cur - q + 1) * q / 2 * (i + 1);\\n                ans %= mod;\\n                ans += (cur - q) * r;\\n                ans %= mod;\\n                orders = 0;\\n            }\\n        }\\n        if (orders > 0) {\\n            ans += (long long)inventory.back() * orders;\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3132045,
                "title": "solution-in-c",
                "content": "```\\nclass Solution {\\n    map<int, int, greater<>> m;\\n    bool valid(int M, int T) {\\n        for (auto &[n , cnt] : m) {\\n            if (n <= M) break;\\n            T -= (long)cnt * (n - M);\\n            if (T <= 0) return true;\\n        }\\n        return T <= 0;\\n    }\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        long ans = 0, mod = 1e9+7, L = 0, R = *max_element(begin(A), end(A));\\n        for (int n : A) m[n]++;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(M, T)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        for (auto &[n , cnt] : m) {\\n            if (n <= L) break;\\n            T -= cnt * (n - L);\\n            ans = (ans + (n + L + 1) * (n - L) / 2 % mod * cnt % mod) % mod;\\n        }\\n        if (T) ans = (ans + L * T % mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<int, int, greater<>> m;\\n    bool valid(int M, int T) {\\n        for (auto &[n , cnt] : m) {\\n            if (n <= M) break;\\n            T -= (long)cnt * (n - M);\\n            if (T <= 0) return true;\\n        }\\n        return T <= 0;\\n    }\\npublic:\\n    int maxProfit(vector<int>& A, int T) {\\n        long ans = 0, mod = 1e9+7, L = 0, R = *max_element(begin(A), end(A));\\n        for (int n : A) m[n]++;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(M, T)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        for (auto &[n , cnt] : m) {\\n            if (n <= L) break;\\n            T -= cnt * (n - L);\\n            ans = (ans + (n + L + 1) * (n - L) / 2 % mod * cnt % mod) % mod;\\n        }\\n        if (T) ans = (ans + L * T % mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124238,
                "title": "python-greedy-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inv, curOrders, curSum, MOD = sorted(inventory, reverse=True) + [0], 0, 0, 1000000007\\n        for i in range(1, len(inv)):\\n            if inv[i - 1] == inv[i]: continue\\n            increments = i * (inv[i - 1] - inv[i])\\n            if increments + curOrders < orders:\\n                curOrders += increments\\n                curSum += ((inv[i - 1] + inv[i] + 1) * increments // 2) % MOD\\n                continue\\n            q, r = divmod(orders - curOrders, i)\\n            return (curSum + q * i * (2 * inv[i - 1] - q + 1) // 2 + (inv[i - 1] - q) * r) % MOD\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inv, curOrders, curSum, MOD = sorted(inventory, reverse=True) + [0], 0, 0, 1000000007\\n        for i in range(1, len(inv)):\\n            if inv[i - 1] == inv[i]: continue\\n            increments = i * (inv[i - 1] - inv[i])\\n            if increments + curOrders < orders:\\n                curOrders += increments\\n                curSum += ((inv[i - 1] + inv[i] + 1) * increments // 2) % MOD\\n                continue\\n            q, r = divmod(orders - curOrders, i)\\n            return (curSum + q * i * (2 * inv[i - 1] - q + 1) // 2 + (inv[i - 1] - q) * r) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004976,
                "title": "python-8-line-greedy-solution-sort-deque-time-o-nlogn",
                "content": "```\\ndef maxProfit(self, nums: List[int], x: int) -> int:\\n\\tq = [[n, k] for n, k in Counter(nums).items()]+[[0, 0]]\\n\\tq, s, mod = deque(sorted(q, key = lambda p:-p[0])), 0, 10**9+7\\n\\twhile(x):\\n\\t\\tn, k = q.popleft()\\n\\t\\tdx, q[0][1] = min((n-q[0][0])*k, x), q[0][1]+k\\n\\t\\ti, j = divmod(dx, k)\\n\\t\\ts, x = (s+(n*2-i+1)*k*i//2+(n-i)*j)%mod, x-dx\\n\\treturn s\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProfit(self, nums: List[int], x: int) -> int:\\n\\tq = [[n, k] for n, k in Counter(nums).items()]+[[0, 0]]\\n\\tq, s, mod = deque(sorted(q, key = lambda p:-p[0])), 0, 10**9+7\\n\\twhile(x):\\n\\t\\tn, k = q.popleft()\\n\\t\\tdx, q[0][1] = min((n-q[0][0])*k, x), q[0][1]+k\\n\\t\\ti, j = divmod(dx, k)\\n\\t\\ts, x = (s+(n*2-i+1)*k*i//2+(n-i)*j)%mod, x-dx\\n\\treturn s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952993,
                "title": "binary-search-this-can-help-if-trouble-understanding-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBreakdown the problem in sub problem and it will decode itself .Find a val which can get you atleast orders ball and try to find the sum of balls having weight greater than it + fulfill remaing balls equal to the least value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSum(for a range m,m+1,m+2....m+n-1) is calclated using the formula (no of element)*(lower+upper)/2\\nMin weight needed is what we can get from binary search we will take all the balls above this values and fulfill remaining orderds from the balls with val we got from binary search\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mod=1000000007;    \\n    bool pos(vector<int>&v,int x,int t){\\n        int curr=0;\\n        for(int i=0;i<v.size();i++){\\n            curr+=max(0,v[i]-x+1);\\n            if(curr>t)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int calculate(vector<int>&v,int x,int t){\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            if(x+1>v[i])\\n            break;\\n            ans=(ans+((1ll*(v[i]+x+1)*(v[i]-x))/2)%mod)%mod;\\n            t-=(v[i]-x);    \\n        }\\n        ans=(ans+(1ll*t*x)%mod)%mod;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>&v, int total) {\\n        sort(v.begin(),v.end(),greater<int>());\\n        v.push_back(0);\\n        int ans=0;\\n        int lo=0;\\n        int hi=v[0];\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(v,mid,total)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return calculate(v,ans,total); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mod=1000000007;    \\n    bool pos(vector<int>&v,int x,int t){\\n        int curr=0;\\n        for(int i=0;i<v.size();i++){\\n            curr+=max(0,v[i]-x+1);\\n            if(curr>t)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int calculate(vector<int>&v,int x,int t){\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            if(x+1>v[i])\\n            break;\\n            ans=(ans+((1ll*(v[i]+x+1)*(v[i]-x))/2)%mod)%mod;\\n            t-=(v[i]-x);    \\n        }\\n        ans=(ans+(1ll*t*x)%mod)%mod;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>&v, int total) {\\n        sort(v.begin(),v.end(),greater<int>());\\n        v.push_back(0);\\n        int ans=0;\\n        int lo=0;\\n        int hi=v[0];\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(v,mid,total)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return calculate(v,ans,total); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952158,
                "title": "javascript-2-solutions-binary-search-sorting",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(n)$$\\n- n = inventory.length\\n```\\nvar maxProfit = function(inventory, orders) {\\n    inventory = [0, ...inventory].sort((b, a) => b - a);\\n\\n    let score = 0n, n = inventory.length;\\n    for (let i = n - 1; orders > 0; i--) {\\n        if (inventory[i] === inventory[i - 1]) continue;\\n\\n        const diff = Math.min(\\n            inventory[i] - inventory[i - 1], Math.floor(orders / (n - i)));\\n        const balls = diff * (n - i);\\n\\n        orders -= balls;\\n        score += BigInt(balls) * BigInt(2 * inventory[i] - diff + 1) / 2n;\\n        if (diff < inventory[i] - inventory[i - 1])\\n            score += BigInt(inventory[i] - diff) * BigInt(orders), orders = 0;\\n    }\\n\\n    return score % 1000000007n;\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(nlog(10^9))$$\\n- Space complexity: $$O(n)$$\\n- n = inventory.length\\n```\\nvar maxProfit = function(inventory, orders) {\\n    let lBalls = 0, rBalls = Math.max(...inventory), score = 0n;\\n \\n    while (lBalls < rBalls) {\\n        const midBalls = (lBalls + rBalls) >> 1;\\n        let balls = 0;\\n        for (const ball of inventory)\\n            balls += Math.max(0, ball - midBalls + 1);\\n\\n        balls > orders ? lBalls = midBalls + 1 : rBalls = midBalls;\\n    }\\n\\n    for (const balls of inventory) {\\n        if (balls >= lBalls) {\\n            score += BigInt(balls + lBalls) * (BigInt(balls - lBalls) + 1n) / 2n;\\n            orders -= balls - lBalls + 1;\\n        }\\n    }\\n\\n    score += BigInt(orders) * BigInt(lBalls - 1);\\n    return score % 1000000007n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfit = function(inventory, orders) {\\n    inventory = [0, ...inventory].sort((b, a) => b - a);\\n\\n    let score = 0n, n = inventory.length;\\n    for (let i = n - 1; orders > 0; i--) {\\n        if (inventory[i] === inventory[i - 1]) continue;\\n\\n        const diff = Math.min(\\n            inventory[i] - inventory[i - 1], Math.floor(orders / (n - i)));\\n        const balls = diff * (n - i);\\n\\n        orders -= balls;\\n        score += BigInt(balls) * BigInt(2 * inventory[i] - diff + 1) / 2n;\\n        if (diff < inventory[i] - inventory[i - 1])\\n            score += BigInt(inventory[i] - diff) * BigInt(orders), orders = 0;\\n    }\\n\\n    return score % 1000000007n;\\n};\\n```\n```\\nvar maxProfit = function(inventory, orders) {\\n    let lBalls = 0, rBalls = Math.max(...inventory), score = 0n;\\n \\n    while (lBalls < rBalls) {\\n        const midBalls = (lBalls + rBalls) >> 1;\\n        let balls = 0;\\n        for (const ball of inventory)\\n            balls += Math.max(0, ball - midBalls + 1);\\n\\n        balls > orders ? lBalls = midBalls + 1 : rBalls = midBalls;\\n    }\\n\\n    for (const balls of inventory) {\\n        if (balls >= lBalls) {\\n            score += BigInt(balls + lBalls) * (BigInt(balls - lBalls) + 1n) / 2n;\\n            orders -= balls - lBalls + 1;\\n        }\\n    }\\n\\n    score += BigInt(orders) * BigInt(lBalls - 1);\\n    return score % 1000000007n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733989,
                "title": "o-nlogn-python-solution-with-heap-inline-explanations",
                "content": "# Intuition\\nFor this problem you need to consider in order the balls with the highest inventory. Since you always need to sell the ball with the highest inventory to make the most profit. To accomplish this, you can use a heap to remove balls with the highest inventory, add it to the order and then push it back into the heap and then repeat until you\\'ve fulfilled the order. The problem with this approach however is that you have to go back to the heap orders times. so you end up with orders*logn time complexity. \\nIn order to avoid this, we will fulfill as much of the order as we can with the current ball of highest inventory, before it makes sense to consider any other balls. To maximize profit, we should add as many balls from the balls with the highest inventory until their inventory is equal to the next inventory of the ball with the next highest inventory. That ball, and all other balls with that inventory number are now added to the set of balls with the highest inventory and then we repeat until we have fulfilled our order. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(nlogn)**\\nWhere n is the number of balls in the inventory. In practice however, this time complexity will be smaller because we do not consider balls with 0 inventory and we only pop from the heap as many times as necessary which may be much less than n if we have many balls with high inventory and small orders. \\n\\n- Space complexity: **O(n)**\\nTo store the heap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nMOD = 10**9 + 7\\n\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \"\"\"\\n        Using a heap means we don\\'t necessarily have to sort the list. \\n        When we have lots of balls with high inventory and small orders, \\n        we won\\'t do nlogn. Further, if we are keeping track of our \\n        inventory in a heap, and the inventory doesn\\'t change, we can \\n        avoid resorting when a new set of orders comes in.\\n        \"\"\"\\n\\n        heap = [-num for num in inventory if num is not 0]\\n\\n        heapq.heapify(heap)\\n\\n        profit = 0\\n        fulfilled = 0\\n        amt = heapq.heappop(heap)\\n        size = 0\\n\\n        \"\"\"\\n        ball with the highest inventory is at the top of the heap\\n        \"\"\"\\n        next_ = amt\\n\\n        while fulfilled < orders:\\n\\n            \"\"\"\\n            find all balls that have inventory equal to the ball(s) with \\n            the highest current inventory -> \\'amt\\'. These are the only \\n            balls currently under consideration for sale right now. If we \\n            sold any other balls, we wouldn\\'t make as much. At the end \\n            there will be \\'size\\' such balls and the \\'next_\\' ball we see \\n            will have an inventory less than the balls under consideration.\\n            \"\"\"\\n\\n            while next_ == amt:\\n                size +=1\\n\\n                if len(heap) > 0:\\n                    next_ = heapq.heappop(heap) \\n                else: \\n                    next_ = 0\\n\\n            \\n            \"\"\" \\n            all \\'size\\' balls under consideration have the same inventory. \\n            In order to maximize profit, we will select a ball from each \\n            color, one after the other until they again have the same \\n            inventory. We continue to do this until the inventory for each \\n            ball is equal to the \\'next_\\' lowest ball. We don\\'t go any \\n            further with our current balls under consideration because we \\n            will need to include the \\'next_\\' ball to maximize our profit. \\n            \"\"\"\\n            \\n\\n            \"\"\"\\n            Since we must stop at the inventory of \\'next_\\', we can      \\n            decrease theinventory of each ball under consideration by amt_ \\n            - next. This will beused to fulfill the order. Since we do \\n            this for all balls currently under consideration which total \\n            \\'size\\'. The max number of balls we can add to the order right \\n            now is \\'n\\' as below\\n            \"\"\"\\n\\n            n = int(size * (-1)*(amt - next_))\\n\\n            \"\"\"\\n            However, we can\\'t add more than is currently required to \\n            fulfill the order, so we will take the minimum of the max \\n            balls we can add the order and the order minus the amount we  \\n            have already fullfilled. \\n            \"\"\"\\n\\n            n = min(n, orders - fulfilled)\\n\\n            \"\"\"\\n            As mentioned above, the order in which we take the balls from \\n            inventory which maximizes the profit is to take from each ball \\n            once until they all have the same inventory and then repeat. \\n            The number of times that we can do this is going to be the \\n            total number of balls we are going to remove, \\'n\\', divided by \\n            the number of balls under consideration, \\'remove_each\\'. There \\n            may be some balls remaining that don\\'t add up to size and we \\n            can take these remaining balls in the last round, remove_rem\\n            \"\"\"\\n\\n            remove_each, remove_rem = divmod(n, size)\\n\\n            \"\"\" \\n            First we calculate the profit from removing each ball in each \\n            \\'remove_each\\' round. Consider one ball. In the first \\n            iteration, it\\'s price is \\'amt\\', the second time it\\'s removed, \\n            it is amt-1, then amt-2 and so on until in the last round, it \\n            is amt-(remove_each -1). In otherwords, for each ball, the \\n            profit gained through this process will be  amt + amt -1 + amt \\n            -2 +...+ amt - (remove_each -1) = remove_each*amt - (1+2+...+\\n            (remove_each-1)). We can recognize the last part as the sum of \\n            i from i =1 to remove_each -1 (k(k+1)/2)So we have remove_each \\n            *amt - (remove_each -1)(remove_each)/2. In order to avoid \\n            overflow, we rearrage the formula to (remove_each*(2*(-1)*amt \\n            - (remove_each-1))//2). because our heap is a min heap and all \\n            values are negative, we multiply amt by (-1). This is the \\n            profit for each ball under consideration so we multiply this \\n            by the number of balls under consideration \\'size\\' \\n            \"\"\"\\n\\n            profit += size*(remove_each*(2*(-1)*amt - (remove_each-1))//2)\\n\\n            \"\"\"\\n            reduce the inventory of each ball under consideration by the \\n            number of rounds we made.\\n            \"\"\"\\n            amt += remove_each\\n\\n            \"\"\"\\n            If there is a remainder, which only occurs when we can sell \\n            more balls than required, cover that remainder with as many \\n            balls as required. \\n            \"\"\"\\n            profit += (-1)*amt*remove_rem\\n\\n            \"\"\"\\n            update the number of balls we fulfilled in this round and \\n            repeat.\\n            \"\"\"\\n            fulfilled += n\\n\\n\\n        return int(profit % MOD)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nMOD = 10**9 + 7\\n\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \"\"\"\\n        Using a heap means we don\\'t necessarily have to sort the list. \\n        When we have lots of balls with high inventory and small orders, \\n        we won\\'t do nlogn. Further, if we are keeping track of our \\n        inventory in a heap, and the inventory doesn\\'t change, we can \\n        avoid resorting when a new set of orders comes in.\\n        \"\"\"\\n\\n        heap = [-num for num in inventory if num is not 0]\\n\\n        heapq.heapify(heap)\\n\\n        profit = 0\\n        fulfilled = 0\\n        amt = heapq.heappop(heap)\\n        size = 0\\n\\n        \"\"\"\\n        ball with the highest inventory is at the top of the heap\\n        \"\"\"\\n        next_ = amt\\n\\n        while fulfilled < orders:\\n\\n            \"\"\"\\n            find all balls that have inventory equal to the ball(s) with \\n            the highest current inventory -> \\'amt\\'. These are the only \\n            balls currently under consideration for sale right now. If we \\n            sold any other balls, we wouldn\\'t make as much. At the end \\n            there will be \\'size\\' such balls and the \\'next_\\' ball we see \\n            will have an inventory less than the balls under consideration.\\n            \"\"\"\\n\\n            while next_ == amt:\\n                size +=1\\n\\n                if len(heap) > 0:\\n                    next_ = heapq.heappop(heap) \\n                else: \\n                    next_ = 0\\n\\n            \\n            \"\"\" \\n            all \\'size\\' balls under consideration have the same inventory. \\n            In order to maximize profit, we will select a ball from each \\n            color, one after the other until they again have the same \\n            inventory. We continue to do this until the inventory for each \\n            ball is equal to the \\'next_\\' lowest ball. We don\\'t go any \\n            further with our current balls under consideration because we \\n            will need to include the \\'next_\\' ball to maximize our profit. \\n            \"\"\"\\n            \\n\\n            \"\"\"\\n            Since we must stop at the inventory of \\'next_\\', we can      \\n            decrease theinventory of each ball under consideration by amt_ \\n            - next. This will beused to fulfill the order. Since we do \\n            this for all balls currently under consideration which total \\n            \\'size\\'. The max number of balls we can add to the order right \\n            now is \\'n\\' as below\\n            \"\"\"\\n\\n            n = int(size * (-1)*(amt - next_))\\n\\n            \"\"\"\\n            However, we can\\'t add more than is currently required to \\n            fulfill the order, so we will take the minimum of the max \\n            balls we can add the order and the order minus the amount we  \\n            have already fullfilled. \\n            \"\"\"\\n\\n            n = min(n, orders - fulfilled)\\n\\n            \"\"\"\\n            As mentioned above, the order in which we take the balls from \\n            inventory which maximizes the profit is to take from each ball \\n            once until they all have the same inventory and then repeat. \\n            The number of times that we can do this is going to be the \\n            total number of balls we are going to remove, \\'n\\', divided by \\n            the number of balls under consideration, \\'remove_each\\'. There \\n            may be some balls remaining that don\\'t add up to size and we \\n            can take these remaining balls in the last round, remove_rem\\n            \"\"\"\\n\\n            remove_each, remove_rem = divmod(n, size)\\n\\n            \"\"\" \\n            First we calculate the profit from removing each ball in each \\n            \\'remove_each\\' round. Consider one ball. In the first \\n            iteration, it\\'s price is \\'amt\\', the second time it\\'s removed, \\n            it is amt-1, then amt-2 and so on until in the last round, it \\n            is amt-(remove_each -1). In otherwords, for each ball, the \\n            profit gained through this process will be  amt + amt -1 + amt \\n            -2 +...+ amt - (remove_each -1) = remove_each*amt - (1+2+...+\\n            (remove_each-1)). We can recognize the last part as the sum of \\n            i from i =1 to remove_each -1 (k(k+1)/2)So we have remove_each \\n            *amt - (remove_each -1)(remove_each)/2. In order to avoid \\n            overflow, we rearrage the formula to (remove_each*(2*(-1)*amt \\n            - (remove_each-1))//2). because our heap is a min heap and all \\n            values are negative, we multiply amt by (-1). This is the \\n            profit for each ball under consideration so we multiply this \\n            by the number of balls under consideration \\'size\\' \\n            \"\"\"\\n\\n            profit += size*(remove_each*(2*(-1)*amt - (remove_each-1))//2)\\n\\n            \"\"\"\\n            reduce the inventory of each ball under consideration by the \\n            number of rounds we made.\\n            \"\"\"\\n            amt += remove_each\\n\\n            \"\"\"\\n            If there is a remainder, which only occurs when we can sell \\n            more balls than required, cover that remainder with as many \\n            balls as required. \\n            \"\"\"\\n            profit += (-1)*amt*remove_rem\\n\\n            \"\"\"\\n            update the number of balls we fulfilled in this round and \\n            repeat.\\n            \"\"\"\\n            fulfilled += n\\n\\n\\n        return int(profit % MOD)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733957,
                "title": "java-simple-intuitive-solution",
                "content": "# Intuition\\nMath and greedy\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ that too just to sort the array\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        inventory = Arrays.stream(inventory).boxed()\\n        .sorted(Collections.reverseOrder())\\n        .mapToInt(Integer::intValue)\\n        .toArray();\\n        long sum = 0;\\n        int top=inventory[0],j=0,n=0,nexttop=0;\\n\\n        while(orders>0){\\n            while(j+1<inventory.length && top==inventory[j+1]){j++;}\\n            n=j+1;\\n            if(j==inventory.length-1){nexttop=0;}\\n            else{nexttop=inventory[j+1];}\\n            int diff = top-nexttop;\\n            long dec = (long)n*diff;\\n            if(dec<=orders){\\n                sum= (long)sum+n*(sumFromNtoX(top,nexttop));\\n                orders-=dec;\\n            }\\n            else{\\n                long div = orders/n;\\n                long rem = orders%n;\\n\\n                sum= (long)sum+n*(sumFromNtoX(top,top-div));\\n                sum= (long)sum+rem*(top-div);\\n\\n                orders=0;\\n            }\\n            top=nexttop;\\n            sum=(long)sum%(1000000007);\\n        }\\n        return (int)(sum%(1000000007));\\n    }\\n\\n    long sumFromNtoX(long n, long x){\\n        long ret = (long)(n * (n+1))/2 - (x * (x+1))/2;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        inventory = Arrays.stream(inventory).boxed()\\n        .sorted(Collections.reverseOrder())\\n        .mapToInt(Integer::intValue)\\n        .toArray();\\n        long sum = 0;\\n        int top=inventory[0],j=0,n=0,nexttop=0;\\n\\n        while(orders>0){\\n            while(j+1<inventory.length && top==inventory[j+1]){j++;}\\n            n=j+1;\\n            if(j==inventory.length-1){nexttop=0;}\\n            else{nexttop=inventory[j+1];}\\n            int diff = top-nexttop;\\n            long dec = (long)n*diff;\\n            if(dec<=orders){\\n                sum= (long)sum+n*(sumFromNtoX(top,nexttop));\\n                orders-=dec;\\n            }\\n            else{\\n                long div = orders/n;\\n                long rem = orders%n;\\n\\n                sum= (long)sum+n*(sumFromNtoX(top,top-div));\\n                sum= (long)sum+rem*(top-div);\\n\\n                orders=0;\\n            }\\n            top=nexttop;\\n            sum=(long)sum%(1000000007);\\n        }\\n        return (int)(sum%(1000000007));\\n    }\\n\\n    long sumFromNtoX(long n, long x){\\n        long ret = (long)(n * (n+1))/2 - (x * (x+1))/2;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730347,
                "title": "greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedily Maths\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a, int k) {\\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        int d = 0;\\n        long long c = 1;\\n        int u = -1;\\n        int i=0;\\n        for(i=0;i<n-1;i++) {\\n            if(k<=0) break;\\n            d = a[i]-a[i+1];\\n            if(d*c<k) {\\n                long long p1 = a[i];\\n                long long p2 = a[i+1];\\n                ans = (ans + (long long)(c*(a[i]-a[i+1])*(a[i]+a[i+1]+1))/2)%mod;\\n                cout<<ans<<\"+\";\\n                k=k-(a[i]-a[i+1])*c;\\n                c++;\\n            }\\n            else {\\n            break;\\n            }\\n        }\\n        cout<<k<<\" \";\\n        if(k>0) {\\n            long long z = a[i];\\n            long long y = k/c;\\n            long long x = k%c;\\n            cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            long long sum = (long long)((((c)*((y)*(z+z-y+1)))/2))%mod;\\n         \\n            sum=(sum+((x)*((z-y))))%mod;\\n            ans=(ans+sum)%mod;\\n        }\\n        return ans%mod;\\n\\n    }\\n//[497978859,167261111,483575207,591815159]\\n//836556809\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a, int k) {\\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        int d = 0;\\n        long long c = 1;\\n        int u = -1;\\n        int i=0;\\n        for(i=0;i<n-1;i++) {\\n            if(k<=0) break;\\n            d = a[i]-a[i+1];\\n            if(d*c<k) {\\n                long long p1 = a[i];\\n                long long p2 = a[i+1];\\n                ans = (ans + (long long)(c*(a[i]-a[i+1])*(a[i]+a[i+1]+1))/2)%mod;\\n                cout<<ans<<\"+\";\\n                k=k-(a[i]-a[i+1])*c;\\n                c++;\\n            }\\n            else {\\n            break;\\n            }\\n        }\\n        cout<<k<<\" \";\\n        if(k>0) {\\n            long long z = a[i];\\n            long long y = k/c;\\n            long long x = k%c;\\n            cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            long long sum = (long long)((((c)*((y)*(z+z-y+1)))/2))%mod;\\n         \\n            sum=(sum+((x)*((z-y))))%mod;\\n            ans=(ans+sum)%mod;\\n        }\\n        return ans%mod;\\n\\n    }\\n//[497978859,167261111,483575207,591815159]\\n//836556809\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2692307,
                "title": "python3-beats-100-time-and-space",
                "content": "``` \\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inv = inventory\\n        inv.sort()\\n        currIdx=len(inv)-1\\n        currVal=inv[currIdx]\\n        profit =0\\n        mod = 1000000007\\n        while orders>0:\\n            while currIdx >=0 and inv[currIdx]==currVal:\\n                currIdx-=1\\n            nextVal = inv[currIdx] if currIdx >=0 else 0\\n            numSameColor = len(inv) - 1 - currIdx\\n            nums = (currVal - nextVal)* numSameColor\\n            if orders >=nums:\\n                profit+= (currVal + nextVal + 1)*(currVal - nextVal)//2*numSameColor\\n            else:\\n                numRows = (orders //numSameColor)\\n                rem= int(orders % numSameColor)\\n                profit+= (currVal + currVal - numRows + 1)*(numRows)//2 * numSameColor\\n                profit+=(currVal - numRows)*rem\\n            orders-=nums\\n            profit%=mod\\n            currVal = nextVal\\n        return int(profit)",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` \\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inv = inventory\\n        inv.sort()\\n        currIdx=len(inv)-1\\n        currVal=inv[currIdx]\\n        profit =0\\n        mod = 1000000007\\n        while orders>0:\\n            while currIdx >=0 and inv[currIdx]==currVal:\\n                currIdx-=1\\n            nextVal = inv[currIdx] if currIdx >=0 else 0\\n            numSameColor = len(inv) - 1 - currIdx\\n            nums = (currVal - nextVal)* numSameColor\\n            if orders >=nums:\\n                profit+= (currVal + nextVal + 1)*(currVal - nextVal)//2*numSameColor\\n            else:\\n                numRows = (orders //numSameColor)\\n                rem= int(orders % numSameColor)\\n                profit+= (currVal + currVal - numRows + 1)*(numRows)//2 * numSameColor\\n                profit+=(currVal - numRows)*rem\\n            orders-=nums\\n            profit%=mod\\n            currVal = nextVal\\n        return int(profit)",
                "codeTag": "Java"
            },
            {
                "id": 2673970,
                "title": "golang-simple-easy-solution-140ms-beats-100",
                "content": "```\\nfunc maxProfit(inventory []int, orders int) int {\\n\\tsort.Slice(inventory, func(i, j int) bool {\\n\\t\\treturn inventory[i] > inventory[j]\\n\\t})\\n\\n\\tn := len(inventory)\\n\\ttotal := 0\\n\\tremaining := orders\\n\\tindex := 0\\n\\n\\tfor index < n {\\n\\t\\tcurr := inventory[index]\\n\\t\\tnext := 0\\n\\n\\t\\tif index < n-1 {\\n\\t\\t\\tnext = inventory[index+1]\\n\\t\\t}\\n\\n\\t\\tcount := (curr - next)\\n\\t\\tdiff := count * (index + 1)\\n\\t\\tcorrection := false\\n\\n\\t\\tif diff > remaining {\\n\\t\\t\\tcorrection = true\\n\\t\\t\\tcount = remaining / (index + 1)\\n\\t\\t}\\n\\n\\t\\ttotal += ((curr * 2 + 1 - count) * count / 2) * (index + 1)\\n\\t\\tremaining -= (index + 1) * count\\n\\t\\tcurr -= count\\n\\n\\t\\tif correction {\\n\\t\\t\\ttotal += (curr * remaining)\\n\\t\\t\\tremaining = 0\\n\\t\\t}\\n\\n\\t\\tindex += 1\\n\\t\\ttotal %= 1000000007\\n\\t}\\n\\n\\treturn total\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(inventory []int, orders int) int {\\n\\tsort.Slice(inventory, func(i, j int) bool {\\n\\t\\treturn inventory[i] > inventory[j]\\n\\t})\\n\\n\\tn := len(inventory)\\n\\ttotal := 0\\n\\tremaining := orders\\n\\tindex := 0\\n\\n\\tfor index < n {\\n\\t\\tcurr := inventory[index]\\n\\t\\tnext := 0\\n\\n\\t\\tif index < n-1 {\\n\\t\\t\\tnext = inventory[index+1]\\n\\t\\t}\\n\\n\\t\\tcount := (curr - next)\\n\\t\\tdiff := count * (index + 1)\\n\\t\\tcorrection := false\\n\\n\\t\\tif diff > remaining {\\n\\t\\t\\tcorrection = true\\n\\t\\t\\tcount = remaining / (index + 1)\\n\\t\\t}\\n\\n\\t\\ttotal += ((curr * 2 + 1 - count) * count / 2) * (index + 1)\\n\\t\\tremaining -= (index + 1) * count\\n\\t\\tcurr -= count\\n\\n\\t\\tif correction {\\n\\t\\t\\ttotal += (curr * remaining)\\n\\t\\t\\tremaining = 0\\n\\t\\t}\\n\\n\\t\\tindex += 1\\n\\t\\ttotal %= 1000000007\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640385,
                "title": "python-solution",
                "content": "Add balls from top to bottom. If the inventory is sorted with descending order, the balls with larger number will always be added, so we can increment the width of block on each iteration.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        inventory.sort(reverse = True)\\n        inventory.append(0) # add additional 0 in the list to calculate the height of last column.\\n        idx = res = width = 0\\n        \\n        while orders > 0:\\n            width += 1\\n            \\n            height = inventory[idx] - inventory[idx + 1]\\n            if height == 0:\\n\\t\\t\\t    # if the current column and next column are the same,\\n\\t\\t\\t\\t# they can be added with same value in the following iterations.\\n                idx += 1\\n                continue\\n            \\n\\t\\t\\t# if current column is larger than the next one, sell all of them if the total numbers are less than remaining orders.\\n            num_sell = width * height\\n            if num_sell <= orders:\\n                val = height * (inventory[idx] + (inventory[idx] - height + 1)) // 2\\n                res += val * width\\n                idx += 1\\n                orders -= num_sell\\n            else:\\n\\t\\t\\t   # if the total numbers in the block is larger than remaining orders\\n\\t\\t\\t   # calculate the top nrows and the remaining balls.\\n                nrows, remainder = divmod(orders, width)\\n\\t\\t\\t\\t# sum of values in each column:  n + n-1 + n-2 ... + n - nrows + 1\\n                val_nrow = nrows * (inventory[idx] + (inventory[idx] - nrows + 1)) // 2\\n                val_remainder = remainder * (inventory[idx] - nrows)\\n                res += val_nrow * width + val_remainder\\n                break\\n                \\n        return res % 1_000_000_007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        inventory.sort(reverse = True)\\n        inventory.append(0) # add additional 0 in the list to calculate the height of last column.\\n        idx = res = width = 0\\n        \\n        while orders > 0:\\n            width += 1\\n            \\n            height = inventory[idx] - inventory[idx + 1]\\n            if height == 0:\\n\\t\\t\\t    # if the current column and next column are the same,\\n\\t\\t\\t\\t# they can be added with same value in the following iterations.\\n                idx += 1\\n                continue\\n            \\n\\t\\t\\t# if current column is larger than the next one, sell all of them if the total numbers are less than remaining orders.\\n            num_sell = width * height\\n            if num_sell <= orders:\\n                val = height * (inventory[idx] + (inventory[idx] - height + 1)) // 2\\n                res += val * width\\n                idx += 1\\n                orders -= num_sell\\n            else:\\n\\t\\t\\t   # if the total numbers in the block is larger than remaining orders\\n\\t\\t\\t   # calculate the top nrows and the remaining balls.\\n                nrows, remainder = divmod(orders, width)\\n\\t\\t\\t\\t# sum of values in each column:  n + n-1 + n-2 ... + n - nrows + 1\\n                val_nrow = nrows * (inventory[idx] + (inventory[idx] - nrows + 1)) // 2\\n                val_remainder = remainder * (inventory[idx] - nrows)\\n                res += val_nrow * width + val_remainder\\n                break\\n                \\n        return res % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623860,
                "title": "using-priority-queue-but-time-is-exceeding-where-is-the-problem",
                "content": "\\n    PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int profit = 0;\\n        for(int item: inventory){\\n            \\n            pQueue.add(item);\\n        }\\n         \\n        for(int i=0;i<orders;i++){\\n            int cost = pQueue.poll();\\n            profit = profit+cost;\\n            pQueue.add(cost-1);\\n        }\\n        return profit;\\n    }",
                "solutionTags": [],
                "code": "\\n    PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int profit = 0;\\n        for(int item: inventory){\\n            \\n            pQueue.add(item);\\n        }\\n         \\n        for(int i=0;i<orders;i++){\\n            int cost = pQueue.poll();\\n            profit = profit+cost;\\n            pQueue.add(cost-1);\\n        }\\n        return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2554117,
                "title": "simple-sorting-greedy-solution-w-explanation-python",
                "content": "```\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        #to make the most amount of money, it makes sense to start selling the most valuable balls first\\n        #reverse sorting to get the highest value balls first\\n        #sum of integers from 1 to n is n*(n+1)/2\\n        inventory.sort(reverse=True)\\n        n = len(inventory)\\n        \\n        def cleanup():\\n            nonlocal orders; nonlocal money\\n            end = balls; start = balls - orders//freq\\n            Sum = (end*(end+1) - start*(start+1))//2\\n            money += Sum*freq\\n\\n            remainingOrders = orders%freq\\n            money += remainingOrders*start; money %= MOD\\n            orders = 0\\n        #two pointer approach: one points to highest value ball, second points to second highest value ball\\n        #the highest value balls may come in different color, so we keep track of that using freq variable\\n        #sell all the highest value balls until its value is equal to second highest value balls\\n        #keep doing that until u complete the order        \\n        freq = 1 #no of highest value balls\\n        balls = inventory[0] #highest value ball\\n        money = 0; MOD = 10**9 + 7\\n        \\n        for i in range(1, n):\\n            if inventory[i] == balls:\\n                freq += 1\\n                continue\\n            \\n            #(ball - inventory[i])*freq is the number of highest value balls u can sell, until highest_value==second_highest_value\\n            #if that is less than order, then its not enough to complete order\\n            if (balls - inventory[i])*freq <= orders:\\n                start = inventory[i]; end = balls\\n                Sum = (end*(end+1) - start*(start+1))//2\\n                money += Sum*freq; money %= MOD\\n                \\n                balls = start #highest value is now equal to second highest value\\n                orders -= (end - start)*freq\\n                freq += 1 #another colored ball with highest value, so freq increases\\n            else:#enough to complete order\\n                cleanup()\\n            \\n            if not orders: break\\n        \\n        if orders: cleanup() #final clean up, if order is not complete\\n        \\n        return money\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        #to make the most amount of money, it makes sense to start selling the most valuable balls first\\n        #reverse sorting to get the highest value balls first\\n        #sum of integers from 1 to n is n*(n+1)/2\\n        inventory.sort(reverse=True)\\n        n = len(inventory)\\n        \\n        def cleanup():\\n            nonlocal orders; nonlocal money\\n            end = balls; start = balls - orders//freq\\n            Sum = (end*(end+1) - start*(start+1))//2\\n            money += Sum*freq\\n\\n            remainingOrders = orders%freq\\n            money += remainingOrders*start; money %= MOD\\n            orders = 0\\n        #two pointer approach: one points to highest value ball, second points to second highest value ball\\n        #the highest value balls may come in different color, so we keep track of that using freq variable\\n        #sell all the highest value balls until its value is equal to second highest value balls\\n        #keep doing that until u complete the order        \\n        freq = 1 #no of highest value balls\\n        balls = inventory[0] #highest value ball\\n        money = 0; MOD = 10**9 + 7\\n        \\n        for i in range(1, n):\\n            if inventory[i] == balls:\\n                freq += 1\\n                continue\\n            \\n            #(ball - inventory[i])*freq is the number of highest value balls u can sell, until highest_value==second_highest_value\\n            #if that is less than order, then its not enough to complete order\\n            if (balls - inventory[i])*freq <= orders:\\n                start = inventory[i]; end = balls\\n                Sum = (end*(end+1) - start*(start+1))//2\\n                money += Sum*freq; money %= MOD\\n                \\n                balls = start #highest value is now equal to second highest value\\n                orders -= (end - start)*freq\\n                freq += 1 #another colored ball with highest value, so freq increases\\n            else:#enough to complete order\\n                cleanup()\\n            \\n            if not orders: break\\n        \\n        if orders: cleanup() #final clean up, if order is not complete\\n        \\n        return money\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2550430,
                "title": "simple-python-solution-using-priority-queue-maxheap",
                "content": "```python\\nimport heapq\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        class MaxHeap:\\n            def __init__(self):\\n                self.data=[]\\n            def push(self, val):\\n                heapq.heappush(self.data, val*(-1))\\n            def pop(self):\\n                return -1 * heapq.heappop(self.data)\\n        \\n        heap_vals = MaxHeap()\\n        \\n        for i in inventory:\\n            heap_vals.push(i)\\n        \\n        res = 0\\n        cnt = 0\\n        while cnt < orders:\\n            v = heap_vals.pop()\\n            res += v\\n            \\n            heap_vals.push(v-1)\\n            cnt += 1\\n        \\n        return res\\n```\\n\\nIt does have a timeout. The complexity is n*log(n) though... \\nAny suggestions would be welcome.",
                "solutionTags": [],
                "code": "```python\\nimport heapq\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        class MaxHeap:\\n            def __init__(self):\\n                self.data=[]\\n            def push(self, val):\\n                heapq.heappush(self.data, val*(-1))\\n            def pop(self):\\n                return -1 * heapq.heappop(self.data)\\n        \\n        heap_vals = MaxHeap()\\n        \\n        for i in inventory:\\n            heap_vals.push(i)\\n        \\n        res = 0\\n        cnt = 0\\n        while cnt < orders:\\n            v = heap_vals.pop()\\n            res += v\\n            \\n            heap_vals.push(v-1)\\n            cnt += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478469,
                "title": "python-sorting",
                "content": "```\\n\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        \\n        inventory.sort()\\n        \\n        amount = 0\\n        k = 1\\n        \\n        for i in range(len(inventory) - 1, -1, -1):\\n   \\n\\n            n = inventory[i]\\n            if i == 0:\\n                t = 0\\n            else:\\n                t = inventory[i-1]\\n\\n            rem = (n - t) * k\\n\\n\\n            if orders >= rem:\\n                orders -= rem\\n                amount += (n*(n+1)//2 - t*(t+1)//2) * k\\n\\n            else:\\n\\n                q = orders // k\\n                rem = orders % k\\n\\n                if q != 0:\\n                    n = inventory[i]\\n                    t = inventory[i] - q\\n                    amount += (n*(n+1)//2 - t*(t+1)//2) * k\\n\\n                amount += rem * (inventory[i] - q)\\n\\n                break\\n\\n            k += 1\\n            \\n        return (amount) % (10 ** 9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        \\n        \\n        inventory.sort()\\n        \\n        amount = 0\\n        k = 1\\n        \\n        for i in range(len(inventory) - 1, -1, -1):\\n   \\n\\n            n = inventory[i]\\n            if i == 0:\\n                t = 0\\n            else:\\n                t = inventory[i-1]\\n\\n            rem = (n - t) * k\\n\\n\\n            if orders >= rem:\\n                orders -= rem\\n                amount += (n*(n+1)//2 - t*(t+1)//2) * k\\n\\n            else:\\n\\n                q = orders // k\\n                rem = orders % k\\n\\n                if q != 0:\\n                    n = inventory[i]\\n                    t = inventory[i] - q\\n                    amount += (n*(n+1)//2 - t*(t+1)//2) * k\\n\\n                amount += rem * (inventory[i] - q)\\n\\n                break\\n\\n            k += 1\\n            \\n        return (amount) % (10 ** 9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431642,
                "title": "my-solution-times-out-but-it-s-nlog-n-can-someone-explain",
                "content": "```\\nvar maxProfit = function(inventory, orders) {\\n    const mod = (10**9 + 7)\\n    let sum = 0, i = 0, count = 0\\n    const arr = inventory.sort((a,b) => b-a)\\n    while(count < orders){\\n        while(arr[i] > (arr[i+1]|| -1) && count < orders){\\n            sum+= (arr[i]*(i+1)) % mod\\n            arr[i]--\\n            count+= i+1\\n        }\\n        i++\\n    }\\n    if(count > orders){\\n        sum = (sum -((arr[i-1]+1) * (count-orders))) % mod\\n    }\\n    return sum % mod \\n};",
                "solutionTags": [],
                "code": "```\\nvar maxProfit = function(inventory, orders) {\\n    const mod = (10**9 + 7)\\n    let sum = 0, i = 0, count = 0\\n    const arr = inventory.sort((a,b) => b-a)\\n    while(count < orders){\\n        while(arr[i] > (arr[i+1]|| -1) && count < orders){\\n            sum+= (arr[i]*(i+1)) % mod\\n            arr[i]--\\n            count+= i+1\\n        }\\n        i++\\n    }\\n    if(count > orders){\\n        sum = (sum -((arr[i-1]+1) * (count-orders))) % mod\\n    }\\n    return sum % mod \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2423828,
                "title": "c-solution-o-nlogn-greedy-sort-math",
                "content": "```\\nclass Solution {\\npublic:\\n    const long M=1e9+7;\\n    long long  getrangesum(long long first,long long  second)\\n    {   \\n        return ((first+1)*first-(second+1)*second)/2;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(),inventory.end(),greater<int>());\\n        int n=inventory.size();\\n        inventory.push_back(0);\\n        \\n        long long  prev=0;\\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int first=inventory[i];\\n            int second=inventory[i+1];\\n            long long winsum=getrangesum(first,second);\\n            prev++;\\n          \\n            if(prev*(first-second)<=orders)\\n            {\\n                ans=(ans+(prev*winsum))%M;\\n                orders-=prev*(first-second);\\n                \\n            }\\n            else\\n            {   \\n                long long  dividen,rem=0;\\n                dividen=orders/prev,rem=orders%prev;\\n                ans=(ans+(prev*getrangesum(first,first-dividen)))%M;\\n                ans=(ans+((first-dividen)*rem))%M;\\n                break;\\n            }                      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long M=1e9+7;\\n    long long  getrangesum(long long first,long long  second)\\n    {   \\n        return ((first+1)*first-(second+1)*second)/2;\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        sort(inventory.begin(),inventory.end(),greater<int>());\\n        int n=inventory.size();\\n        inventory.push_back(0);\\n        \\n        long long  prev=0;\\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int first=inventory[i];\\n            int second=inventory[i+1];\\n            long long winsum=getrangesum(first,second);\\n            prev++;\\n          \\n            if(prev*(first-second)<=orders)\\n            {\\n                ans=(ans+(prev*winsum))%M;\\n                orders-=prev*(first-second);\\n                \\n            }\\n            else\\n            {   \\n                long long  dividen,rem=0;\\n                dividen=orders/prev,rem=orders%prev;\\n                ans=(ans+(prev*getrangesum(first,first-dividen)))%M;\\n                ans=(ans+((first-dividen)*rem))%M;\\n                break;\\n            }                      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345368,
                "title": "c-heap-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    int maxProfit(vector<int>& inv, int order) {\\n        int n = inv.size();\\n       priority_queue<ll>pq ; \\n        int mod=1e9+7;\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n            pq.push(inv[i]);\\n        while(order > 0){\\n            ll val = pq.top();pq.pop();\\n            ll c=1;\\n            while(pq.size()>0 && pq.top()==val )\\n            {\\n                c++; pq.pop();\\n            }\\n          \\n            if(pq.size()>0){\\n              \\n               ll req = val-pq.top();\\n               req *=c ; \\n                if(order>=req){\\n                    ans = (ans +  c*((val)*(val+1)/2 - (pq.top())*(pq.top()+1)/2)%mod)%mod;\\n                    order-=req ; \\n                }\\n                else{\\n                    ll u = order/c ; ll v = order%c ;\\n              \\n                      ans =(ans+ c*((val)*(val+1)/2 - (val-u)*(val-u+1)/2)%mod)%mod;\\n                   \\n                    val-=u ; \\n                    ans+=v*(val);\\n                    order=0;\\n                    \\n                }\\n                if(order<=0)return ans%mod;\\n                int add = pq.top();\\n                while(c){pq.push(add);c--;}\\n                \\n            }\\n            else{\\n               \\n                   ll u = order/c ; ll v = order%c ;\\n            \\n                    ans =(ans+ c*((val)*(val+1)/2 - (val-u)*(val-u+1)/2)%mod)%mod;\\n                \\n                    val-=u ; \\n                    ans+=v*(val);\\n                    order=0;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    int maxProfit(vector<int>& inv, int order) {\\n        int n = inv.size();\\n       priority_queue<ll>pq ; \\n        int mod=1e9+7;\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n            pq.push(inv[i]);\\n        while(order > 0){\\n            ll val = pq.top();pq.pop();\\n            ll c=1;\\n            while(pq.size()>0 && pq.top()==val )\\n            {\\n                c++; pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2340017,
                "title": "java-binarysearch-o-n-log-m-n-is-the-length-of-inventory-m-is-the-max-value-in-inventory",
                "content": "```java\\n// O (N log M) N is the length of inventory, M is the max value in inventory.\\nclass Solution {\\n\\tprivate final static int MOD = 1_000_000_007;\\n\\n\\tpublic int maxProfit(int[] inventory, int orders) {\\n\\t\\tint len = inventory.length;\\n\\t\\tif (len == 1) {\\n\\t\\t\\tlong temp = (orders)*((long)inventory[0] * 2 - orders + 1) / 2;\\n\\t\\t\\treturn (int)(temp % MOD);\\n\\t\\t}\\n\\t\\tint maxN = Integer.MIN_VALUE;\\n\\t\\tfor (int i : inventory) {\\n\\t\\t\\tif (i > maxN) maxN = i;\\n\\t\\t}\\n\\n\\t\\t// binary search\\n\\t\\tint start = 1; int end = maxN + 1;\\n\\t\\twhile (start < end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tlong temp = getOrders(inventory, mid);\\n\\t\\t\\tif (temp == orders) {\\n\\t\\t\\t\\tstart = mid;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (temp < orders) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t} else if (temp > orders) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i : inventory) { \\n\\t\\t\\tif (i >= start) {\\n\\t\\t\\t\\tres += ((long)start + i)*(i-start+1)/2;\\n\\t\\t\\t\\tres %= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres += (orders - getOrders(inventory, start)) * (start - 1);\\n\\t\\tres %= MOD;\\n\\n\\t\\treturn (int)res;\\n\\t}\\n\\n\\tprivate long getOrders(int[] inventory, int n) {\\n\\t\\tlong ret = 0;\\n\\t\\tfor (int i : inventory) {\\n\\t\\t\\tif (i >= n) {\\n\\t\\t\\t\\tret += i - n + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// O (N log M) N is the length of inventory, M is the max value in inventory.\\nclass Solution {\\n\\tprivate final static int MOD = 1_000_000_007;\\n\\n\\tpublic int maxProfit(int[] inventory, int orders) {\\n\\t\\tint len = inventory.length;\\n\\t\\tif (len == 1) {\\n\\t\\t\\tlong temp = (orders)*((long)inventory[0] * 2 - orders + 1) / 2;\\n\\t\\t\\treturn (int)(temp % MOD);\\n\\t\\t}\\n\\t\\tint maxN = Integer.MIN_VALUE;\\n\\t\\tfor (int i : inventory) {\\n\\t\\t\\tif (i > maxN) maxN = i;\\n\\t\\t}\\n\\n\\t\\t// binary search\\n\\t\\tint start = 1; int end = maxN + 1;\\n\\t\\twhile (start < end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tlong temp = getOrders(inventory, mid);\\n\\t\\t\\tif (temp == orders) {\\n\\t\\t\\t\\tstart = mid;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (temp < orders) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t} else if (temp > orders) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i : inventory) { \\n\\t\\t\\tif (i >= start) {\\n\\t\\t\\t\\tres += ((long)start + i)*(i-start+1)/2;\\n\\t\\t\\t\\tres %= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres += (orders - getOrders(inventory, start)) * (start - 1);\\n\\t\\tres %= MOD;\\n\\n\\t\\treturn (int)res;\\n\\t}\\n\\n\\tprivate long getOrders(int[] inventory, int n) {\\n\\t\\tlong ret = 0;\\n\\t\\tfor (int i : inventory) {\\n\\t\\t\\tif (i >= n) {\\n\\t\\t\\t\\tret += i - n + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318338,
                "title": "intuitive-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    long long get_orders(const vector<int>& inv, int val) {\\n        long long o = 0;\\n        for (auto i : inv) {\\n            o += max(0, i - val);\\n        }\\n        return o;\\n    }\\n    \\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        long long res = 0;\\n        long long kMod = 1\\'000\\'000\\'000 + 7;\\n        \\n        long long low = 0;\\n        long long high = 1\\'000\\'000\\'000;\\n        while (low <= high) {\\n            auto mid = (low + high) / 2;\\n            auto temp = get_orders(inventory, mid);\\n            if (temp > orders) {\\n                low = mid + 1;\\n            } else if (temp == orders) {\\n                high = mid;\\n                low = mid;\\n                break;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        for (long long i : inventory) {\\n            if (i > low) {\\n                res += (i - low) * (i + low + 1LL) / 2;\\n                res %= kMod;\\n                orders -= (i - low);\\n                orders = max(0, orders);\\n            }\\n        }\\n        return (res + low * orders) % kMod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    long long get_orders(const vector<int>& inv, int val) {\\n        long long o = 0;\\n        for (auto i : inv) {\\n            o += max(0, i - val);\\n        }\\n        return o;\\n    }\\n    \\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        long long res = 0;\\n        long long kMod = 1\\'000\\'000\\'000 + 7;\\n        \\n        long long low = 0;\\n        long long high = 1\\'000\\'000\\'000;\\n        while (low <= high) {\\n            auto mid = (low + high) / 2;\\n            auto temp = get_orders(inventory, mid);\\n            if (temp > orders) {\\n                low = mid + 1;\\n            } else if (temp == orders) {\\n                high = mid;\\n                low = mid;\\n                break;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        for (long long i : inventory) {\\n            if (i > low) {\\n                res += (i - low) * (i + low + 1LL) / 2;\\n                res %= kMod;\\n                orders -= (i - low);\\n                orders = max(0, orders);\\n            }\\n        }\\n        return (res + low * orders) % kMod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297424,
                "title": "help-needed-java-priorityqueue",
                "content": "Hello,\\nI\\'m trying to find the error in my code. \\nLogic: \\n1. Add all values to Priorty Queue where max value going to be polled each time. \\n2. Compare polled value with the next value of queue. \\n3. Find the sum of all values between polled value and peeked (next) value.\\n4. If orders>0 add peek-1 to queue.\\n\\nMy code passing following cases: \\n* {2, 5}, 4, 14\\n* {3, 5}, 6, 19\\n* {1000000000}, 1000000000, 21\\n\\nHowever failing for following:\\n* {773160767}, 252264991, 70267492    -> result of my code 70267476.\\n\\nThis leads me thinking that I\\'ve an issue with following line:\\n```java\\nprofit += times * (peek + (double) (polled - peek) / 2);\\n```\\n\\nTried Math.multipyExact, Math.multipyFull, Math.multipyHigh and no luck. \\nWhen I use BigDecimal my code runs as expected but I hit Time Limit Exceeded error with that.\\n\\nAny suggestions?\\n\\n\\n\\n```java\\n\\n  public int maxProfit(int[] inventory, int orders) {\\n    int mod = 1000000007; // mod provided by question\\n\\n    double profit = 0;\\n\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n    pq.offer(\\n        -1); // to handle cases where there is only 1 value. This will be used as peeked value after queue polled\\n\\n    // fill priority queue\\n    for (int i : inventory) {\\n      pq.offer(i);\\n    }\\n\\n    // we can use polled one as long as it\\'s equal or bigger than the next element.\\n    // looping this takes more time so trying to calculate sum of all the value between polled value and peeked (next) one\\n    int polled;\\n    int peek;\\n    int times;\\n    while (orders > 0) {\\n      polled = pq.poll();\\n      peek = Math.max(pq.peek(), polled - orders + 1);\\n      times = polled - peek + 1;\\n      profit += times * (peek + (double) (polled - peek) / 2);\\n      orders -= times;\\n      if (orders > 0) {\\n        pq.offer(peek - 1);\\n      }\\n    }\\n\\n    return (int) (profit % mod);\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nprofit += times * (peek + (double) (polled - peek) / 2);\\n```\n```java\\n\\n  public int maxProfit(int[] inventory, int orders) {\\n    int mod = 1000000007; // mod provided by question\\n\\n    double profit = 0;\\n\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n    pq.offer(\\n        -1); // to handle cases where there is only 1 value. This will be used as peeked value after queue polled\\n\\n    // fill priority queue\\n    for (int i : inventory) {\\n      pq.offer(i);\\n    }\\n\\n    // we can use polled one as long as it\\'s equal or bigger than the next element.\\n    // looping this takes more time so trying to calculate sum of all the value between polled value and peeked (next) one\\n    int polled;\\n    int peek;\\n    int times;\\n    while (orders > 0) {\\n      polled = pq.poll();\\n      peek = Math.max(pq.peek(), polled - orders + 1);\\n      times = polled - peek + 1;\\n      profit += times * (peek + (double) (polled - peek) / 2);\\n      orders -= times;\\n      if (orders > 0) {\\n        pq.offer(peek - 1);\\n      }\\n    }\\n\\n    return (int) (profit % mod);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222656,
                "title": "java-binarysearch-19ms",
                "content": "```\\n    public int maxProfit(int[] inventory, int orders) {\\n        int min = 0, max = inventory[0];\\n        int mod = 1000000007;\\n        for (int n : inventory) {\\n            max = Math.max(max, n);\\n        }\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            if (check(inventory, orders, mid)) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        long sum = 0;\\n        for (int n : inventory) {\\n            if (n >= min) {\\n                long count = n - min + 1;\\n                sum = (sum + count * (n + min) / 2) %mod;\\n                orders -= count;\\n            }\\n        }\\n        --min;\\n        sum = (sum + (long)min * orders) % mod;\\n        return (int) sum;\\n    }\\n\\n    private boolean check(int[] inventory, int orders, long val) {\\n        int sum = 0;\\n        for (int n : inventory) {\\n            if (n >= val)\\n                sum += n - val + 1;\\n            if (sum > orders) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int maxProfit(int[] inventory, int orders) {\\n        int min = 0, max = inventory[0];\\n        int mod = 1000000007;\\n        for (int n : inventory) {\\n            max = Math.max(max, n);\\n        }\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            if (check(inventory, orders, mid)) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        long sum = 0;\\n        for (int n : inventory) {\\n            if (n >= min) {\\n                long count = n - min + 1;\\n                sum = (sum + count * (n + min) / 2) %mod;\\n                orders -= count;\\n            }\\n        }\\n        --min;\\n        sum = (sum + (long)min * orders) % mod;\\n        return (int) sum;\\n    }\\n\\n    private boolean check(int[] inventory, int orders, long val) {\\n        int sum = 0;\\n        for (int n : inventory) {\\n            if (n >= val)\\n                sum += n - val + 1;\\n            if (sum > orders) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2210309,
                "title": "pyhton3",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def getSum(start , end):\\n            return start*(start+1)//2 - end * (end+1)//2\\n    \\n\\n        \\n\\n        inventory.sort(reverse= True)\\n        n = len(inventory)\\n        i =0 \\n        res = 0\\n        fac = 1\\n        mod = 10**9+7\\n        while orders>0:\\n            #if we can sum all eqaul values\\n            if i<(n-1) and inventory[i]>inventory[i+1] and orders>= fac*(inventory[i]-inventory[i+1]):      \\n                res+=fac*getSum(inventory[i], inventory[i+1])\\n                orders-=fac*(inventory[i]-inventory[i+1])\\n            elif i == n-1 or inventory[i]>inventory[i+1]:\\n                comp_sell = orders//fac\\n                res+=fac*getSum(inventory[i], inventory[i]-comp_sell)\\n                par_sell = orders%fac\\n                res+=par_sell*(inventory[i]-comp_sell)\\n                break\\n            i+=1\\n            fac+=1\\n\\n        return(res%mod)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        def getSum(start , end):\\n            return start*(start+1)//2 - end * (end+1)//2\\n    \\n\\n        \\n\\n        inventory.sort(reverse= True)\\n        n = len(inventory)\\n        i =0 \\n        res = 0\\n        fac = 1\\n        mod = 10**9+7\\n        while orders>0:\\n            #if we can sum all eqaul values\\n            if i<(n-1) and inventory[i]>inventory[i+1] and orders>= fac*(inventory[i]-inventory[i+1]):      \\n                res+=fac*getSum(inventory[i], inventory[i+1])\\n                orders-=fac*(inventory[i]-inventory[i+1])\\n            elif i == n-1 or inventory[i]>inventory[i+1]:\\n                comp_sell = orders//fac\\n                res+=fac*getSum(inventory[i], inventory[i]-comp_sell)\\n                par_sell = orders%fac\\n                res+=par_sell*(inventory[i]-comp_sell)\\n                break\\n            i+=1\\n            fac+=1\\n\\n        return(res%mod)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190811,
                "title": "c-max-heap-calculate-in-layers",
                "content": "* The obvious method to get max element first and take 1 ball each time will not work here , due to large constraints.\\n\\n* Instead, we Do calculations in layers. Say our `inventory` is `[10,10,10,8,8,3,3,3]`. Then we try to take balls from all the larger groups of balls simulatenously at each step/round to **reduce our time.**\\n\\n* `[10,10,10,8,8,3,3,3]` --> `[8,8,8,8,8,3,3,3]` --> `[3,3,3,3,3,3,3,3]` -->  `[0,0,0,0,0,0,0,0]`.\\n\\n* `Sum of N terms in Ap == N * (first_term + last_term) / 2`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int MOD = 1e9 + 7 ;\\n    ll profit = 0 ;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        unordered_map<ll,ll> freq ;\\n        for(auto &x : inventory) ++freq[x] ;\\n        \\n        priority_queue<pair<ll,ll>> pq ;\\n        for(auto &x : freq) pq.push({x.first,x.second}) ;\\n        \\n        //arranged acccording to largest number first--> \\n        while(orders and pq.size()){\\n\\t\\t//Lno -> Larger number  Lf-> larger number frequency \\n\\t\\t//Sno-> Smaller number Sf-> Smaller number freq\\n            auto [Lno , Lf] = pq.top() ; pq.pop() ;\\n            auto [Sno , Sf] = pair<ll,ll>{0,0} ;\\n            if(pq.size()){\\n                Sno = pq.top().first ;\\n                Sf = pq.top().second ;\\n                pq.pop() ;\\n            }\\n            \\n            if(orders >= Lf * (Lno-Sno)){\\n                ll n = Lno - Sno , lastTerm = Sno + 1LL , firstTerm = Lno ;\\n                profit = profit + (n*Lf*(firstTerm + lastTerm) / 2LL) % MOD ;\\n                orders -= n*Lf ;\\n                if(Sno) pq.push({Sno,Sf + Lf});          \\n            } \\n            else{\\n                ll each = orders / Lf ;\\n                if(each){\\n                   profit = (profit + Lf * each * (Lno + Lno - each + 1) / 2LL) % MOD ;\\n                   orders -= Lf * each ;\\n                   if(Lno - each) {pq.push({Lno-each,Lf}) ; pq.push({Sno,Sf}); }  \\n                } else{\\n                    profit = (profit + orders * Lno) % MOD ;\\n                    orders = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return profit % MOD ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int MOD = 1e9 + 7 ;\\n    ll profit = 0 ;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        unordered_map<ll,ll> freq ;\\n        for(auto &x : inventory) ++freq[x] ;\\n        \\n        priority_queue<pair<ll,ll>> pq ;\\n        for(auto &x : freq) pq.push({x.first,x.second}) ;\\n        \\n        //arranged acccording to largest number first--> \\n        while(orders and pq.size()){\\n\\t\\t//Lno -> Larger number  Lf-> larger number frequency \\n\\t\\t//Sno-> Smaller number Sf-> Smaller number freq\\n            auto [Lno , Lf] = pq.top() ; pq.pop() ;\\n            auto [Sno , Sf] = pair<ll,ll>{0,0} ;\\n            if(pq.size()){\\n                Sno = pq.top().first ;\\n                Sf = pq.top().second ;\\n                pq.pop() ;\\n            }\\n            \\n            if(orders >= Lf * (Lno-Sno)){\\n                ll n = Lno - Sno , lastTerm = Sno + 1LL , firstTerm = Lno ;\\n                profit = profit + (n*Lf*(firstTerm + lastTerm) / 2LL) % MOD ;\\n                orders -= n*Lf ;\\n                if(Sno) pq.push({Sno,Sf + Lf});          \\n            } \\n            else{\\n                ll each = orders / Lf ;\\n                if(each){\\n                   profit = (profit + Lf * each * (Lno + Lno - each + 1) / 2LL) % MOD ;\\n                   orders -= Lf * each ;\\n                   if(Lno - each) {pq.push({Lno-each,Lf}) ; pq.push({Sno,Sf}); }  \\n                } else{\\n                    profit = (profit + orders * Lno) % MOD ;\\n                    orders = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return profit % MOD ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177625,
                "title": "cpp-binary-search",
                "content": "```\\n\\nconst int mod=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int getans(long long int a,long long int b)\\n    {\\n        long long int num1=a*(a+1);\\n        long long int num2=b*(b+1);\\n        num1/=2;\\n        num2/=2;\\n        long long int num=num1-num2;\\n        return (int)(num%mod);\\n    }\\n    bool isPossible(long long int k,vector<int>& inventory,long long int req,int& sum)\\n    {\\n        vector<int> invent(inventory.begin(),inventory.end());\\n        long long int count=0,currsum=0,ballcount=0;\\n        for(int i=0;i<invent.size();i++)\\n        {\\n            if(invent[i]>k)\\n            {\\n                count+=(invent[i]-k);\\n                 currsum=(currsum%mod+getans(invent[i],k))%mod;\\n                invent[i]=k;\\n               ballcount++;\\n            }\\n          else  if(invent[i]==k)\\n                ballcount++;\\n        }\\n        if(count<req)\\n        {\\n            int diff=req-count;\\n            if(ballcount<diff)return false;\\n            count=req;\\n            currsum=(currsum%mod+(diff%mod*k%mod)%mod);\\n        }\\n        sum=currsum%mod;\\n        cout<<k<<\" \"<<sum<<\" \";\\n        return (count>=req);\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int lo=1;\\n        int ans=0;\\n        int hi=*(max_element(inventory.begin(),inventory.end()));\\n        while(lo+1<hi)\\n        {\\n            int k=lo+(hi-lo)/2;\\n            if(isPossible(k,inventory,orders,ans))\\n                lo=k;\\n            else\\n                hi=k-1;\\n        }\\n         if(isPossible(hi,inventory,orders,ans))\\n                return ans;\\n        else if(isPossible(lo,inventory,orders,ans))\\n            return ans;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst int mod=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int getans(long long int a,long long int b)\\n    {\\n        long long int num1=a*(a+1);\\n        long long int num2=b*(b+1);\\n        num1/=2;\\n        num2/=2;\\n        long long int num=num1-num2;\\n        return (int)(num%mod);\\n    }\\n    bool isPossible(long long int k,vector<int>& inventory,long long int req,int& sum)\\n    {\\n        vector<int> invent(inventory.begin(),inventory.end());\\n        long long int count=0,currsum=0,ballcount=0;\\n        for(int i=0;i<invent.size();i++)\\n        {\\n            if(invent[i]>k)\\n            {\\n                count+=(invent[i]-k);\\n                 currsum=(currsum%mod+getans(invent[i],k))%mod;\\n                invent[i]=k;\\n               ballcount++;\\n            }\\n          else  if(invent[i]==k)\\n                ballcount++;\\n        }\\n        if(count<req)\\n        {\\n            int diff=req-count;\\n            if(ballcount<diff)return false;\\n            count=req;\\n            currsum=(currsum%mod+(diff%mod*k%mod)%mod);\\n        }\\n        sum=currsum%mod;\\n        cout<<k<<\" \"<<sum<<\" \";\\n        return (count>=req);\\n    }\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int lo=1;\\n        int ans=0;\\n        int hi=*(max_element(inventory.begin(),inventory.end()));\\n        while(lo+1<hi)\\n        {\\n            int k=lo+(hi-lo)/2;\\n            if(isPossible(k,inventory,orders,ans))\\n                lo=k;\\n            else\\n                hi=k-1;\\n        }\\n         if(isPossible(hi,inventory,orders,ans))\\n                return ans;\\n        else if(isPossible(lo,inventory,orders,ans))\\n            return ans;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2164082,
                "title": "c-o-nlogn-detail-explanation",
                "content": "for inventory = [2,3,3,5,5]\\nwe can think it as  \\n![image](https://assets.leetcode.com/users/images/014fbe46-5f25-4750-9648-7dc4a94b5076_1655513910.790563.png)\\n\\n\\nand we can count the order as \\n![image](https://assets.leetcode.com/users/images/0cbff341-9399-480d-8592-5f1483742c37_1655513929.6767068.png)\\n\\ncost for ith-order  is the height of the ith-order in the figure\\nand we can calculate total costs in different blocks as below if orders in problem is 12\\n![image](https://assets.leetcode.com/users/images/3bf5ac9c-75e4-4c1a-a348-7aef6c15d156_1655515432.2874732.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        inventory.push_back(0);\\n        sort(inventory.begin(), inventory.end());\\n        int i = inventory.size()-1, modv = 1000000007, nondecreasingc = 1;\\n        long long ans = 0;\\n        while(orders>0)\\n        {\\n            while(inventory[i] == inventory[i-1])\\n            {\\n                nondecreasingc++;\\n                i--;\\n            }\\n\\t\\t\\t//nondecreasing, d, c, r are indicated in the figure\\n            int d = inventory[i] - inventory[i-1];\\n            int c = (orders-1)/nondecreasingc;\\n            int r = (orders-1)%nondecreasingc;\\n            if (c >= d) { c = d - 1; r = nondecreasingc -1; };\\n            ans += (((long long)(inventory[i] + inventory[i] - c)) * (c+1))/2  * (nondecreasingc);\\n            ans -= ((long long)(nondecreasingc - 1 - r) * (inventory[i] - c));\\n            ans = ans % modv;\\n            orders -=  (c+1) * nondecreasingc;\\n            if (orders <= 0)\\n                  break;\\n            i--;\\n            nondecreasingc++;\\n        }\\n        return ans;\\n    }\\n```\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        inventory.push_back(0);\\n        sort(inventory.begin(), inventory.end());\\n        int i = inventory.size()-1, modv = 1000000007, nondecreasingc = 1;\\n        long long ans = 0;\\n        while(orders>0)\\n        {\\n            while(inventory[i] == inventory[i-1])\\n            {\\n                nondecreasingc++;\\n                i--;\\n            }\\n\\t\\t\\t//nondecreasing, d, c, r are indicated in the figure\\n            int d = inventory[i] - inventory[i-1];\\n            int c = (orders-1)/nondecreasingc;\\n            int r = (orders-1)%nondecreasingc;\\n            if (c >= d) { c = d - 1; r = nondecreasingc -1; };\\n            ans += (((long long)(inventory[i] + inventory[i] - c)) * (c+1))/2  * (nondecreasingc);\\n            ans -= ((long long)(nondecreasingc - 1 - r) * (inventory[i] - c));\\n            ans = ans % modv;\\n            orders -=  (c+1) * nondecreasingc;\\n            if (orders <= 0)\\n                  break;\\n            i--;\\n            nondecreasingc++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147985,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\n        public int MaxProfit(int[] inventory, int orders)\\n        {\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n            inventory = inventory.OrderBy(x => -x).ToArray();//sort desc\\n            int n = inventory.Length;\\n\\n            int left = 1;\\n            int right = 10_0000_0000;\\n            while (left < right)\\n            {\\n                int mid = (left + right + 1) / 2;//select the right center\\n                long sum = 0;\\n                foreach (var i in inventory)\\n                {\\n                    if (i < mid) break;//select all balls which count >=mid\\n                    else sum += i - mid + 1;//all balls [mid,i]\\n                }\\n\\n                if (sum == orders)\\n                {\\n                    left = mid;\\n                    break;\\n                }\\n                else if (sum > orders)\\n                {\\n                    left = mid;\\n                }\\n                else\\n                {\\n                    right = mid - 1;//this cause we choose the right center, (left+right)/2 will select left center and will never end\\n                }\\n            }\\n\\t\\t\\t//now we have the left-value, so we must :\\n\\t\\t\\t//First, select all >=left+1, if these balls not enough...\\n\\t\\t\\t//Then ,orders still >0, select orders count of left\\n            for (int i = 0; i < n && orders > 0; i++)\\n            {\\n                long a = inventory[i];\\n                if (a <= left) break;\\n                int count = Math.Min(inventory[i] - left, orders);//count is of range [left+1,inventory[i] ]\\n                res += (a + (a - count + 1)) * count / 2;\\n                res %= mod;\\n                orders -= count;\\n            }\\n\\n            res += orders % mod * left;//must % mod, or cause overflow\\n            return (int)(res % mod);\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MaxProfit(int[] inventory, int orders)\\n        {\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n            inventory = inventory.OrderBy(x => -x).ToArray();//sort desc\\n            int n = inventory.Length;\\n\\n            int left = 1;\\n            int right = 10_0000_0000;\\n            while (left < right)\\n            {\\n                int mid = (left + right + 1) / 2;//select the right center\\n                long sum = 0;\\n                foreach (var i in inventory)\\n                {\\n                    if (i < mid) break;//select all balls which count >=mid\\n                    else sum += i - mid + 1;//all balls [mid,i]\\n                }\\n\\n                if (sum == orders)\\n                {\\n                    left = mid;\\n                    break;\\n                }\\n                else if (sum > orders)\\n                {\\n                    left = mid;\\n                }\\n                else\\n                {\\n                    right = mid - 1;//this cause we choose the right center, (left+right)/2 will select left center and will never end\\n                }\\n            }\\n\\t\\t\\t//now we have the left-value, so we must :\\n\\t\\t\\t//First, select all >=left+1, if these balls not enough...\\n\\t\\t\\t//Then ,orders still >0, select orders count of left\\n            for (int i = 0; i < n && orders > 0; i++)\\n            {\\n                long a = inventory[i];\\n                if (a <= left) break;\\n                int count = Math.Min(inventory[i] - left, orders);//count is of range [left+1,inventory[i] ]\\n                res += (a + (a - count + 1)) * count / 2;\\n                res %= mod;\\n                orders -= count;\\n            }\\n\\n            res += orders % mod * left;//must % mod, or cause overflow\\n            return (int)(res % mod);\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129939,
                "title": "o-nlogn-solution",
                "content": "here the main part is to sort the array and maintain a pointer of curr prev value and cnt of that value.\\nlet\\'s say we have array 5 3  and operation as 6 \\n\\nso let\\'s make 2 d array   5 4 3 2 1 0 \\n                                       0 0 3 2 1 0 \\nso in this we will decrease the maximum and maintain the count of it \\nso initially   we have maxi=5 cnt=1 \\nthen we can have 2 operations as 5 4 then our pointer will become maxi:3 cnt:2 \\nthen we have 4 operations left so we will take 3 2 1   first square of 2*2 there is some math involved here \\n                                                                          3 2 1  \\n\\ntake complete matrix till   k/cnt  + leftover*value  in this case leftover is 0",
                "solutionTags": [],
                "code": "here the main part is to sort the array and maintain a pointer of curr prev value and cnt of that value.\\nlet\\'s say we have array 5 3  and operation as 6 \\n\\nso let\\'s make 2 d array   5 4 3 2 1 0 \\n                                       0 0 3 2 1 0 \\nso in this we will decrease the maximum and maintain the count of it \\nso initially   we have maxi=5 cnt=1 \\nthen we can have 2 operations as 5 4 then our pointer will become maxi:3 cnt:2 \\nthen we have 4 operations left so we will take 3 2 1   first square of 2*2 there is some math involved here \\n                                                                          3 2 1  \\n\\ntake complete matrix till   k/cnt  + leftover*value  in this case leftover is 0",
                "codeTag": "Unknown"
            },
            {
                "id": 2118173,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::*;\\n\\nconst MOD:usize = 1_000_000_007;\\nimpl Solution {\\n  pub fn max_profit(inventory: Vec<i32>, orders: i32) -> i32 {\\n    let mut left = orders as usize;\\n    let mut map = HashMap::new();\\n    for v in inventory {\\n      *map.entry(v as usize).or_insert(0) += 1 as usize;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(usize, usize)>>();\\n    arr.sort();\\n\\n    let mut result = 0;\\n    while 1 < arr.len() {\\n      let (rv, num) = arr.pop().unwrap();\\n      let li = arr.len() - 1;\\n      let nv = arr[li].0;\\n      let diff = rv - nv;\\n      let tot = diff * num;\\n\\n      if tot < left {\\n        left -= tot;\\n        let lv = nv + 1;\\n        let av = (lv + rv) * diff / 2 % MOD * num % MOD;\\n        result += av;\\n        result %= MOD;\\n        arr[li].1 += num;\\n      } else {\\n        let need = left / num;\\n        let rnum = left % num;\\n\\n        let lv = rv - need + 1;\\n        result += (lv + rv) * need / 2 % MOD * num % MOD;\\n        result %= MOD;\\n        result += (rv-need) * rnum % MOD;\\n        result %= MOD;\\n\\n        return result as i32;\\n      }\\n    }\\n\\n    let (rv, num) = arr[0];\\n    let need = left / num;\\n    let rnum = left % num;\\n\\n    let lv = rv - need + 1;\\n    result += (lv + rv) * need / 2 % MOD * num % MOD;\\n    result %= MOD;\\n    result += (rv-need) * rnum % MOD;\\n    result %= MOD;\\n    \\n    result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nconst MOD:usize = 1_000_000_007;\\nimpl Solution {\\n  pub fn max_profit(inventory: Vec<i32>, orders: i32) -> i32 {\\n    let mut left = orders as usize;\\n    let mut map = HashMap::new();\\n    for v in inventory {\\n      *map.entry(v as usize).or_insert(0) += 1 as usize;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(usize, usize)>>();\\n    arr.sort();\\n\\n    let mut result = 0;\\n    while 1 < arr.len() {\\n      let (rv, num) = arr.pop().unwrap();\\n      let li = arr.len() - 1;\\n      let nv = arr[li].0;\\n      let diff = rv - nv;\\n      let tot = diff * num;\\n\\n      if tot < left {\\n        left -= tot;\\n        let lv = nv + 1;\\n        let av = (lv + rv) * diff / 2 % MOD * num % MOD;\\n        result += av;\\n        result %= MOD;\\n        arr[li].1 += num;\\n      } else {\\n        let need = left / num;\\n        let rnum = left % num;\\n\\n        let lv = rv - need + 1;\\n        result += (lv + rv) * need / 2 % MOD * num % MOD;\\n        result %= MOD;\\n        result += (rv-need) * rnum % MOD;\\n        result %= MOD;\\n\\n        return result as i32;\\n      }\\n    }\\n\\n    let (rv, num) = arr[0];\\n    let need = left / num;\\n    let rnum = left % num;\\n\\n    let lv = rv - need + 1;\\n    result += (lv + rv) * need / 2 % MOD * num % MOD;\\n    result %= MOD;\\n    result += (rv-need) * rnum % MOD;\\n    result %= MOD;\\n    \\n    result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2097202,
                "title": "c-math-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inv, int orders) \\n    {\\n        long res=0,colors=1;\\n        sort(inv.begin(),inv.end());\\n        for(int i=inv.size()-1;i>=0&&orders>=0;i--,colors++)\\n        {\\n            long curr=inv[i],prev=0;\\n            if(i>0)\\n            {\\n                prev=inv[i-1];\\n            }\\n            long rounds=min(orders/colors,curr-prev);\\n            orders-=rounds*colors;\\n            res=(res+(curr*(curr+1)-(curr-rounds)*(curr-rounds+1))/2*colors)%1000000007;\\n            if(curr-prev>rounds)\\n            {\\n                res=(res+orders*(curr-rounds))%1000000007;\\n                break;\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& inv, int orders) \\n    {\\n        long res=0,colors=1;\\n        sort(inv.begin(),inv.end());\\n        for(int i=inv.size()-1;i>=0&&orders>=0;i--,colors++)\\n        {\\n            long curr=inv[i],prev=0;\\n            if(i>0)\\n            {\\n                prev=inv[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2094724,
                "title": "nlogn",
                "content": "**greedy/sorting**\\n**time: `O(N)`; space: `O(1)`**\\n\\nIt\\'s preferable to start from the most abundant balls.\\n\\nThis is the basic idea:\\n* sort data to get a Young diagram;\\n* slice diagram horizontally and \\'add up\\' the horizontal bars one by one until the number of added element reaches the `orders` limit.\\n* the last bar may need some extra consideration as only part of it will be added.\\n\\n![image](https://assets.leetcode.com/users/images/8f0461de-b524-4e45-bc8f-46d6f0c566a9_1654015597.187999.png)\\n\\nHere\\'s a more detailed picture:\\n\\n![image](https://assets.leetcode.com/users/images/c594f439-579c-42a5-b8f9-d09753e51d2e_1654013894.6066058.png)\\n\\n\\n**Useful identity:**\\n\\n`(s+1) + (s+2) + ... + t = t*(t+1)/2 - s*(s+1)/2`\\n\\nthat is based on:\\n\\n`1 + 2 + 3 +  ... + t = t*(t+1)/2`.\\n\\n```\\nint maxProfit(vector<int>& n, int o) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\tint out{}, i{}, t{n[0]};\\n\\tfor(int t1{t}; i*(t-t1)<o; )\\n    {\\n        out  = (out+i*(t*(t+1ll)-t1*(t1+1ll))/2)%1000000007;\\n        o   -= i*(t-t1);\\n        t    = exchange(t1, i<size(n)? n[i] : 0);\\n        i    = distance(begin(n), upper_bound(begin(n)+i, end(n), t, greater{}));\\n    }\\n    long long t2 = t-o/i;\\n    return (out+i*(t*(t+1ll)-t2*(t2+1ll))/2+o%i*t2)%1000000007;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& n, int o) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\tint out{}, i{}, t{n[0]};\\n\\tfor(int t1{t}; i*(t-t1)<o; )\\n    {\\n        out  = (out+i*(t*(t+1ll)-t1*(t1+1ll))/2)%1000000007;\\n        o   -= i*(t-t1);\\n        t    = exchange(t1, i<size(n)? n[i] : 0);\\n        i    = distance(begin(n), upper_bound(begin(n)+i, end(n), t, greater{}));\\n    }\\n    long long t2 = t-o/i;\\n    return (out+i*(t*(t+1ll)-t2*(t2+1ll))/2+o%i*t2)%1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088833,
                "title": "java-short-soln-no-heap",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        int n = inventory.length;\\n        long result = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            long diff = inventory[i] - (i > 0 ? inventory[i-1]: 0);\\n            long x = Math.min((long)orders, (n - i) * diff);\\n            long r = inventory[i];\\n            long l = r - x/(n - i);\\n            \\n            result += ((r * (r+1)/2 ) - (l * (l+1)/2)) * (n - i);\\n            result %= 1000000007;\\n            \\n            result += l * (x % (n - i));\\n            result %= 1000000007;\\n            orders -= x;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        Arrays.sort(inventory);\\n        int n = inventory.length;\\n        long result = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            long diff = inventory[i] - (i > 0 ? inventory[i-1]: 0);\\n            long x = Math.min((long)orders, (n - i) * diff);\\n            long r = inventory[i];\\n            long l = r - x/(n - i);\\n            \\n            result += ((r * (r+1)/2 ) - (l * (l+1)/2)) * (n - i);\\n            result %= 1000000007;\\n            \\n            result += l * (x % (n - i));\\n            result %= 1000000007;\\n            orders -= x;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079947,
                "title": "kotlin-priority-queue-time-n-log-n-space-o-n",
                "content": "The first solution is used for initial illustration, it is actually TLE, but it helped to get the idea further : \\n\\n```\\n\\n    private val modulo = Math.pow(10.0, 9.0).toInt() + 7\\n    \\n    fun maxProfit(inventory: IntArray, orders: Int): Int {\\n\\n        var result = 0L\\n        val queue = PriorityQueue<Long>(Comparator<Long>{first, second -> (second - first).toInt() })\\n        \\n        inventory.forEach{queue.offer(it.toLong())}\\n        \\n        var remOrders = orders.toLong()\\n        \\n        while(remOrders > 0){\\n            \\n            val item = queue.poll()\\n            \\n            var count = 1\\n            while(queue.size > 0 && queue.peek() == item){\\n                queue.poll()\\n                count++\\n            }\\n            \\n            val nextItem = if(queue.size == 0) 0 else {queue.peek()}\\n            \\n            /**\\n             * If at any point we are left with the case such as : \\n             *\\n             * priority queue : [10,10,10,10,10,10,10,10,10,10]\\n             * remOrders = 3\\n             *\\n             * then the result = result +  remOrders * 10 = 30\\n             */\\n            if(remOrders <= count){\\n                result+=remOrders * item\\n                break\\n            }\\n\\n            /**\\n             * We have two cases here:\\n             *\\n             * Case1\\n             * [10, 10, 10, 2]\\n             * remOrders = 5\\n             *\\n             * or\\n             *\\n             * Case 2\\n             * [10,10,8]\\n             * remOrders = 5\\n             *\\n             * In the first case we will take\\n             * 5/3 = 1\\n             * which means that we are taking into account [1] 3 times\\n             * and then the follow up priority queue will look like:\\n             * [9,9,9,2]\\n             *\\n             * In the second case\\n             * (10 - 8) = 2\\n             *\\n             * Basically we will take [2] 2 times\\n             * and then priority queue will look like:\\n             * [8,8,8]\\n             *\\n             */\\n            \\n            val diff1 = (remOrders/count).toLong()\\n            val diff2 = Math.max(1L,((item - nextItem)/count).toLong())\\n            val diff = Math.min(diff1,diff2)\\n            val bottom = item - diff\\n            \\n\\t\\t\\t//Sum of Natural Numbers \\n            val cost = (item * (item + 1))/2 - (bottom* (bottom + 1)/2)\\n            val fullCost = cost * count\\n            result+=fullCost\\n            \\n            remOrders -= (count * diff)\\n            \\n            for(index in 1 .. count) {\\n                queue.offer(bottom)\\n            }\\n        }\\n        \\n        return (result % modulo).toInt()\\n    }\\n}\\n```\\n\\n\\nNow, Let\\'s pay attention how we are modifying the priority queue and let\\'s forget about `remOrders` for a moment. For example: \\n`\\n[10,8,6,4,2] -> [8,8,6,4,2] -> [6,6,6,4,2]->[4,4,4,4,2] -> [2,2,2,2,2] \\n`\\n\\nThe key point here is the more we go towards the array end (priortity queue in the first solution),  in reality we simply increase the count of items. In other words instead of re-adding [bottoms] to priority queue:\\n\\n```\\n for(index in 1 .. count) {\\n                queue.offer(bottom)\\n            }\\n```\\n\\n we can simply have a **counter** which keeps track of how many items we processed. \\n\\n\\n```\\n\\nclass SolutionV2 {\\n\\n    private val modulo = Math.pow(10.0, 9.0).toInt() + 7\\n    \\n    //Time : N(log(n))\\n    //space: O(n)\\n    fun maxProfit(inventory: IntArray, orders: Int): Int {\\n\\n        var result = 0L\\n        val queue = PriorityQueue<Long>(Comparator<Long> { first, second -> (second - first).toInt() })\\n        inventory.forEach { queue.offer(it.toLong()) }\\n        \\n        var remOrders = orders.toLong()\\n        \\n        var count = 1\\n        var item = queue.poll()\\n        \\n        while(remOrders > 0){\\n            \\n            while(queue.size > 0 && queue.peek() == item){\\n                queue.poll()\\n                count++\\n            }\\n            \\n            val nextItem = if(queue.size == 0) 0 else {queue.peek()}\\n\\n            /**\\n             * If at any point we are left with the case\\n             *\\n             * priority queue : [10,10,10,10,10,10,10,10,10,10]\\n             * remOrders = 3\\n             *\\n             * then the result is remOrders = remOrders * 10 = 30\\n             */\\n            if(remOrders <= count){\\n                result+=remOrders * item\\n                break\\n            }\\n\\n            val diff1 = (remOrders/count).toLong()\\n\\n            val diff2 = Math.max(1L,((item - nextItem)/count).toLong())\\n            \\n            val diff = Math.min(diff1,diff2)\\n\\n            val bottom = item - diff\\n\\n            val cost = (item * (item + 1))/2 - (bottom* (bottom + 1)/2)\\n            val fullCost = cost * count\\n\\n            result+=fullCost\\n            remOrders -= (count * diff)\\n            \\n            item = bottom\\n        }\\n        \\n        return (result % modulo).toInt()\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Kotlin",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n    private val modulo = Math.pow(10.0, 9.0).toInt() + 7\\n    \\n    fun maxProfit(inventory: IntArray, orders: Int): Int {\\n\\n        var result = 0L\\n        val queue = PriorityQueue<Long>(Comparator<Long>{first, second -> (second - first).toInt() })\\n        \\n        inventory.forEach{queue.offer(it.toLong())}\\n        \\n        var remOrders = orders.toLong()\\n        \\n        while(remOrders > 0){\\n            \\n            val item = queue.poll()\\n            \\n            var count = 1\\n            while(queue.size > 0 && queue.peek() == item){\\n                queue.poll()\\n                count++\\n            }\\n            \\n            val nextItem = if(queue.size == 0) 0 else {queue.peek()}\\n            \\n            /**\\n             * If at any point we are left with the case such as : \\n             *\\n             * priority queue : [10,10,10,10,10,10,10,10,10,10]\\n             * remOrders = 3\\n             *\\n             * then the result = result +  remOrders * 10 = 30\\n             */\\n            if(remOrders <= count){\\n                result+=remOrders * item\\n                break\\n            }\\n\\n            /**\\n             * We have two cases here:\\n             *\\n             * Case1\\n             * [10, 10, 10, 2]\\n             * remOrders = 5\\n             *\\n             * or\\n             *\\n             * Case 2\\n             * [10,10,8]\\n             * remOrders = 5\\n             *\\n             * In the first case we will take\\n             * 5/3 = 1\\n             * which means that we are taking into account [1] 3 times\\n             * and then the follow up priority queue will look like:\\n             * [9,9,9,2]\\n             *\\n             * In the second case\\n             * (10 - 8) = 2\\n             *\\n             * Basically we will take [2] 2 times\\n             * and then priority queue will look like:\\n             * [8,8,8]\\n             *\\n             */\\n            \\n            val diff1 = (remOrders/count).toLong()\\n            val diff2 = Math.max(1L,((item - nextItem)/count).toLong())\\n            val diff = Math.min(diff1,diff2)\\n            val bottom = item - diff\\n            \\n\\t\\t\\t//Sum of Natural Numbers \\n            val cost = (item * (item + 1))/2 - (bottom* (bottom + 1)/2)\\n            val fullCost = cost * count\\n            result+=fullCost\\n            \\n            remOrders -= (count * diff)\\n            \\n            for(index in 1 .. count) {\\n                queue.offer(bottom)\\n            }\\n        }\\n        \\n        return (result % modulo).toInt()\\n    }\\n}\\n```\n```\\n for(index in 1 .. count) {\\n                queue.offer(bottom)\\n            }\\n```\n```\\n\\nclass SolutionV2 {\\n\\n    private val modulo = Math.pow(10.0, 9.0).toInt() + 7\\n    \\n    //Time : N(log(n))\\n    //space: O(n)\\n    fun maxProfit(inventory: IntArray, orders: Int): Int {\\n\\n        var result = 0L\\n        val queue = PriorityQueue<Long>(Comparator<Long> { first, second -> (second - first).toInt() })\\n        inventory.forEach { queue.offer(it.toLong()) }\\n        \\n        var remOrders = orders.toLong()\\n        \\n        var count = 1\\n        var item = queue.poll()\\n        \\n        while(remOrders > 0){\\n            \\n            while(queue.size > 0 && queue.peek() == item){\\n                queue.poll()\\n                count++\\n            }\\n            \\n            val nextItem = if(queue.size == 0) 0 else {queue.peek()}\\n\\n            /**\\n             * If at any point we are left with the case\\n             *\\n             * priority queue : [10,10,10,10,10,10,10,10,10,10]\\n             * remOrders = 3\\n             *\\n             * then the result is remOrders = remOrders * 10 = 30\\n             */\\n            if(remOrders <= count){\\n                result+=remOrders * item\\n                break\\n            }\\n\\n            val diff1 = (remOrders/count).toLong()\\n\\n            val diff2 = Math.max(1L,((item - nextItem)/count).toLong())\\n            \\n            val diff = Math.min(diff1,diff2)\\n\\n            val bottom = item - diff\\n\\n            val cost = (item * (item + 1))/2 - (bottom* (bottom + 1)/2)\\n            val fullCost = cost * count\\n\\n            result+=fullCost\\n            remOrders -= (count * diff)\\n            \\n            item = bottom\\n        }\\n        \\n        return (result % modulo).toInt()\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069832,
                "title": "c-binary-search-math-do-as-the-hint-says",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        int l = 1;\\n        int u = 1e9;\\n        \\n        while(l<u){\\n            int mid = (l+u+1)/2;\\n            \\n            if(isValid(inventory, orders, mid)){\\n                l = mid;\\n            }\\n            else{\\n                u = mid-1;\\n            }\\n        }\\n        \\n        int k = l;//k is the same k in hint\\n        \\n        //take all balls of value >k and if required take some of k\\n        int num = 0;\\n        int profit = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<inventory.size(); i++){\\n            \\n            if (inventory[i] < k+1) continue;\\n            \\n            int x = inventory[i] - (k+1) + 1;\\n            num += x;\\n            \\n            long long a = x;\\n            long long b = k+1+inventory[i];\\n            long long inc = ((a*b)/2)%mod;\\n            \\n            profit = (profit + inc)%mod;\\n            \\n        }\\n        \\n        long long left = orders - num; //this many number of balls of value k are required\\n        long long extra = (left*k)%mod;\\n        \\n        \\n        profit = (profit + extra)%mod;\\n        \\n        return profit;\\n            \\n        \\n    }\\n    \\n    bool isValid(vector<int>& inventory, int orders, int k){\\n        \\n        long long pos = 0;\\n        \\n        for (int i=0; i<inventory.size(); i++){\\n            \\n            if (inventory[i] < k) continue;\\n            \\n            int num = inventory[i] - k+1;\\n            \\n            pos += num;\\n        }\\n        \\n        return pos >= (long long)orders;\\n        \\n        \\n    }\\n    \\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        int l = 1;\\n        int u = 1e9;\\n        \\n        while(l<u){\\n            int mid = (l+u+1)/2;\\n            \\n            if(isValid(inventory, orders, mid)){\\n                l = mid;\\n            }\\n            else{\\n                u = mid-1;\\n            }\\n        }\\n        \\n        int k = l;//k is the same k in hint\\n        \\n        //take all balls of value >k and if required take some of k\\n        int num = 0;\\n        int profit = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<inventory.size(); i++){\\n            \\n            if (inventory[i] < k+1) continue;\\n            \\n            int x = inventory[i] - (k+1) + 1;\\n            num += x;\\n            \\n            long long a = x;\\n            long long b = k+1+inventory[i];\\n            long long inc = ((a*b)/2)%mod;\\n            \\n            profit = (profit + inc)%mod;\\n            \\n        }\\n        \\n        long long left = orders - num; //this many number of balls of value k are required\\n        long long extra = (left*k)%mod;\\n        \\n        \\n        profit = (profit + extra)%mod;\\n        \\n        return profit;\\n            \\n        \\n    }\\n    \\n    bool isValid(vector<int>& inventory, int orders, int k){\\n        \\n        long long pos = 0;\\n        \\n        for (int i=0; i<inventory.size(); i++){\\n            \\n            if (inventory[i] < k) continue;\\n            \\n            int num = inventory[i] - k+1;\\n            \\n            pos += num;\\n        }\\n        \\n        return pos >= (long long)orders;\\n        \\n        \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064239,
                "title": "binary-search",
                "content": "```\\n\\tint mod = 1e9+7;\\n    bool ispossible(int& mid,vector<int>&v,int &ord,long long &val){\\n        int cnt=0;\\n        long long sub=(long long)mid*(mid+1)/2;\\n        \\n        int ind = lower_bound(v.begin(),v.end(),mid)-v.begin();\\n        int cnt2=v.size()-ind;\\n        for(int i =v.size()-1;i>=ind;i--){\\n            cnt+=v[i]-mid;\\n            val=((long long)v[i])*(v[i]+1)/2-sub+val;\\n            if(cnt>=ord)re\\n        if((cnt2+cnt)>=ord){\\n            val+=(long long)(ord-cnt)*mid;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int maxProfit(vector<int>& inv, int orders) {\\n        sort(inv.begin(),inv.end());\\n        int s =1,e=inv[inv.size()-1]-1,mid;\\n        long long val;\\n        int ans=0;\\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            val=0;\\n            if(ispossible(mid,inv,orders,val)){\\n                s=mid+1;\\n                ans=val%mod;\\n            }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint mod = 1e9+7;\\n    bool ispossible(int& mid,vector<int>&v,int &ord,long long &val){\\n        int cnt=0;\\n        long long sub=(long long)mid*(mid+1)/2;\\n        \\n        int ind = lower_bound(v.begin(),v.end(),mid)-v.begin();\\n        int cnt2=v.size()-ind;\\n        for(int i =v.size()-1;i>=ind;i--){\\n            cnt+=v[i]-mid;\\n            val=((long long)v[i])*(v[i]+1)/2-sub+val;\\n            if(cnt>=ord)re\\n        if((cnt2+cnt)>=ord){\\n            val+=(long long)(ord-cnt)*mid;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int maxProfit(vector<int>& inv, int orders) {\\n        sort(inv.begin(),inv.end());\\n        int s =1,e=inv[inv.size()-1]-1,mid;\\n        long long val;\\n        int ans=0;\\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            val=0;\\n            if(ispossible(mid,inv,orders,val)){\\n                s=mid+1;\\n                ans=val%mod;\\n            }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2060490,
                "title": "using-priority-queue",
                "content": "#define pp pair<long long,long long>\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        priority_queue<pp,vector<pp>>pq;\\n        unordered_map<long long,long long >mp;\\n        for(int i=0;i<inventory.size();i++){\\n          mp[inventory[i]]++;\\n        }\\n        for(auto x:mp){\\n            pq.push({x.first,x.second});\\n        }\\n        long long ans=0;\\n        while(!pq.empty() && orders!=0){\\n            long long  high=pq.top().first;\\n            long long  sh=0;\\n            long long  sfq=0;\\n            long long fq=pq.top().second;\\n            pq.pop();\\n            if(pq.size()>=1){\\n                sh=pq.top().first;\\n                sfq=pq.top().second;\\n                pq.pop();\\n            }\\n            int diff=high-sh;\\n            if(diff*fq<=orders){\\n             ans=(ans+ fq*((high*(high+1))/2-(sh*(sh+1)/2)))%mod;\\n                pq.push({sh,sfq+fq});\\n                orders=orders-(diff*fq);\\n            }else{\\n                long long lo=high-(orders/fq);\\n                ans=(ans+fq*(high*(high+1)/2-(lo*(lo+1)/2)))%mod;\\n                     ans=(ans+((orders%fq)*lo))%mod;\\n           orders=0;\\n            }\\n        }\\n     \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int mod=1000000007;\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        priority_queue<pp,vector<pp>>pq;\\n        unordered_map<long long,long long >mp;\\n        for(int i=0;i<inventory.size();i++){\\n          mp[inventory[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2049473,
                "title": "javascript-maxheap-math-bigint",
                "content": "```\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\nvar maxProfit = function (inventory, orders) {\\n  orders = BigInt(orders);\\n  let ans = BigInt(0);\\n  let count = BigInt(1);\\n  const maxHeap = new MaxHeap(inventory);\\n\\n  while (orders > 0 && maxHeap.getLength() > 0) {\\n    const curr = BigInt(maxHeap.remove());\\n    let next = maxHeap.getLength() > 0 ? BigInt(maxHeap.peek()) : BigInt(0);\\n    const createdOrders = (curr - next) * count;\\n\\n    // we can take all\\n    if (createdOrders <= orders) {\\n      orders -= createdOrders;\\n      const sum = mod((getSum(curr) - getSum(next)) * count);\\n      ans = mod(ans + sum);\\n    } else {\\n      // we can take only partially\\n      next = curr - orders / count;\\n      const sum = mod((getSum(curr) - getSum(next)) * count);\\n      ans = mod(ans + sum);\\n\\n      // for the remaining orders, we can just pick the next.\\n      const remaining = orders % count;\\n      ans = mod(ans + remaining * next);\\n      orders = 0;\\n    }\\n    count++;\\n  }\\n\\n  return ans;\\n};\\n\\nconst getSum = (num) => (num * (num + BigInt(1))) / BigInt(2);\\nconst mod = (num) => num % BigInt(Math.pow(10, 9) + 7);\\n```\\nLink: [MaxHeap](https://github.com/faustaleonardo/data-structure-in-js/blob/main/MaxHeap.js)",
                "solutionTags": [
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\nvar maxProfit = function (inventory, orders) {\\n  orders = BigInt(orders);\\n  let ans = BigInt(0);\\n  let count = BigInt(1);\\n  const maxHeap = new MaxHeap(inventory);\\n\\n  while (orders > 0 && maxHeap.getLength() > 0) {\\n    const curr = BigInt(maxHeap.remove());\\n    let next = maxHeap.getLength() > 0 ? BigInt(maxHeap.peek()) : BigInt(0);\\n    const createdOrders = (curr - next) * count;\\n\\n    // we can take all\\n    if (createdOrders <= orders) {\\n      orders -= createdOrders;\\n      const sum = mod((getSum(curr) - getSum(next)) * count);\\n      ans = mod(ans + sum);\\n    } else {\\n      // we can take only partially\\n      next = curr - orders / count;\\n      const sum = mod((getSum(curr) - getSum(next)) * count);\\n      ans = mod(ans + sum);\\n\\n      // for the remaining orders, we can just pick the next.\\n      const remaining = orders % count;\\n      ans = mod(ans + remaining * next);\\n      orders = 0;\\n    }\\n    count++;\\n  }\\n\\n  return ans;\\n};\\n\\nconst getSum = (num) => (num * (num + BigInt(1))) / BigInt(2);\\nconst mod = (num) => num % BigInt(Math.pow(10, 9) + 7);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045210,
                "title": "python-greedy-counter-stack-popping",
                "content": "maintain a increasing values-count pair list, we can know how to consume order  step by step\\n---\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def maxProfit(self, inventory, orders):\\n        inventory.append(0)  # add dummy in case inventory has only 1 kind of balls\\n\\n        incr_vals = sorted([val, cnt] for val, cnt in Counter(inventory).items())\\n\\n        total = 0\\n\\n        while orders > 0:\\n            # remove max value, it\\'s useless anyway\\n            max_val, cnt = incr_vals.pop()\\n            snd_val, _ = incr_vals[-1]\\n\\n            usable = max_val - snd_val\\n            consume = usable * cnt\\n\\n            if consume <= orders:  # usable to second value is not enough to consume all orders\\n                orders -= consume\\n                total += (max_val + max_val - usable + 1) * usable // 2 * cnt\\n\\n                incr_vals[-1][1] += cnt  # compress max value counts to next value\\n            else:  # order can be consumed, just using parts of usable\\n                usable, remain = divmod(orders, cnt)\\n                total += (max_val + max_val - usable + 1) * usable // 2 * cnt\\n                total += (max_val - usable) * remain\\n                break\\n\\n        return total % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def maxProfit(self, inventory, orders):\\n        inventory.append(0)  # add dummy in case inventory has only 1 kind of balls\\n\\n        incr_vals = sorted([val, cnt] for val, cnt in Counter(inventory).items())\\n\\n        total = 0\\n\\n        while orders > 0:\\n            # remove max value, it\\'s useless anyway\\n            max_val, cnt = incr_vals.pop()\\n            snd_val, _ = incr_vals[-1]\\n\\n            usable = max_val - snd_val\\n            consume = usable * cnt\\n\\n            if consume <= orders:  # usable to second value is not enough to consume all orders\\n                orders -= consume\\n                total += (max_val + max_val - usable + 1) * usable // 2 * cnt\\n\\n                incr_vals[-1][1] += cnt  # compress max value counts to next value\\n            else:  # order can be consumed, just using parts of usable\\n                usable, remain = divmod(orders, cnt)\\n                total += (max_val + max_val - usable + 1) * usable // 2 * cnt\\n                total += (max_val - usable) * remain\\n                break\\n\\n        return total % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033719,
                "title": "c-best-code-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v, int ord) {\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        int mod=1000000007;\\n        for(int i=n-1;i>=0;i--){\\n            long long diff=v[i]-(i==0?0:v[i-1]);\\n            long long x=min((long long)ord,(n-i)*diff);\\n            long long r=v[i];\\n            long long l=r-(x/(n-i));\\n            ans+=(r*(r+1)/2-l*(l+1)/2)*(n-i);\\n            ans=ans%mod;\\n            ans+=l*(x%(n-i));\\n            ans=ans%mod;\\n            ord-=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v, int ord) {\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        int mod=1000000007;\\n        for(int i=n-1;i>=0;i--){\\n            long long diff=v[i]-(i==0?0:v[i-1]);\\n            long long x=min((long long)ord,(n-i)*diff);\\n            long long r=v[i];\\n            long long l=r-(x/(n-i));\\n            ans+=(r*(r+1)/2-l*(l+1)/2)*(n-i);\\n            ans=ans%mod;\\n            ans+=l*(x%(n-i));\\n            ans=ans%mod;\\n            ord-=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011044,
                "title": "java-tc-nlogn-17ms-faster-than-98-43",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = (int)1e9 + 7;\\n        Arrays.parallelSort(inventory);\\n        long sum = 0L;\\n        long pre = 1L;\\n        int n = inventory.length;\\n        int count = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (i > 0 && inventory[i] == inventory[i - 1]) {\\n                count++;\\n                i--;\\n            }\\n            int diff = orders / count;\\n            if (diff == 0) {\\n                sum += pre * inventory[i] * orders;\\n                break;\\n            }\\n            if (i == 0 || inventory[i] - inventory[i - 1] >= diff) {\\n                sum += getSumToDiff(count, inventory[i], diff);\\n                orders -= count * diff;\\n                sum += pre * orders % count * (inventory[i] - diff);\\n                break;\\n                \\n            } else {\\n                diff = inventory[i] - inventory[i - 1];\\n                sum += getSumToDiff(count, inventory[i], diff);                \\n                orders -= count * diff;\\n                count++;\\n            }\\n        }                \\n        return (int)(sum % mod);\\n    }\\n    private long getSumToDiff(int count, long value, long diff) {\\n        return count * (((value << 1) - diff + 1)) * (diff) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        int mod = (int)1e9 + 7;\\n        Arrays.parallelSort(inventory);\\n        long sum = 0L;\\n        long pre = 1L;\\n        int n = inventory.length;\\n        int count = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (i > 0 && inventory[i] == inventory[i - 1]) {\\n                count++;\\n                i--;\\n            }\\n            int diff = orders / count;\\n            if (diff == 0) {\\n                sum += pre * inventory[i] * orders;\\n                break;\\n            }\\n            if (i == 0 || inventory[i] - inventory[i - 1] >= diff) {\\n                sum += getSumToDiff(count, inventory[i], diff);\\n                orders -= count * diff;\\n                sum += pre * orders % count * (inventory[i] - diff);\\n                break;\\n                \\n            } else {\\n                diff = inventory[i] - inventory[i - 1];\\n                sum += getSumToDiff(count, inventory[i], diff);                \\n                orders -= count * diff;\\n                count++;\\n            }\\n        }                \\n        return (int)(sum % mod);\\n    }\\n    private long getSumToDiff(int count, long value, long diff) {\\n        return count * (((value << 1) - diff + 1)) * (diff) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992954,
                "title": "c-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int MOD = 1000000007;\\n        int ans = 0;\\n        \\n\\t\\t// Sort balls by descending count order\\n        sort(inventory.begin(), inventory.end(), std::greater<int>());\\n        \\n        // Used to box group of colours that should be sold next\\n        int leftBoundary = 1;\\n        \\n        // Keep counting profit until orders are fulfilled\\n        while (orders > 0) {\\n            // Find next colour with less balls\\n            while (leftBoundary < inventory.size() && inventory[leftBoundary] == inventory[leftBoundary - 1]) {\\n                ++leftBoundary;\\n            }\\n            long currentCount = inventory[leftBoundary - 1];\\n            long nextCount = (leftBoundary < inventory.size()) ? inventory[leftBoundary] : 0;\\n            // At this point all colours between indexdes 0 and leftBoundary - 1 inclusively have the same highest count (currentCount - nextCount)\\n            \\n            // Determine number of balls that could potentially be sold\\n            int potentialSellCount = (currentCount - nextCount) * leftBoundary;\\n            \\n            // Determine actual number of balls that can be sold (don\\'t sell more than the order)\\n            int sellCount = std::min(potentialSellCount, orders);\\n            \\n            // Number of balls to take from each colour\\n            int ballsPerColour = sellCount / leftBoundary;\\n            // Update number of remaining balls (we should technically update everything between 0 and leftBoundary but it would be a waste of time)\\n            //std::fill_n(inventory.begin(), leftBoundary, currentCount - ballsPerColour);\\n            inventory[leftBoundary - 1] -= ballsPerColour;\\n            \\n            // When orders < potentialSellCount, we won\\'t consume all the colours with max counts. Some leftover orders will have to be fulfilled\\n            int rem  = sellCount % leftBoundary;\\n            \\n            long sumPerColumn = nSum(currentCount) - nSum(currentCount - ballsPerColour);\\n            long profit = sumPerColumn * leftBoundary;\\n            if (rem > 0){\\n                // When orders < potentialSellCount. Take care of leftover orders to fulfill\\n                int nextValue = currentCount - ballsPerColour;\\n                profit += (long)nextValue * rem;\\n            }\\n            \\n            ans = (ans + profit) % MOD;\\n            orders -= sellCount;\\n        }\\n\\n        return ans;\\n    }\\n    \\nprivate:\\n    long nSum(long n) {\\n        // Computes n + (n - 1) + (n - 2) + ... + 1\\n        // Gauss formula: https://nrich.maths.org/2478#:~:text=Gauss%20added%20the%20rows%20pairwise,quantity%20in%20a%20clever%20way.\\n        return n*(n+1)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        const int MOD = 1000000007;\\n        int ans = 0;\\n        \\n\\t\\t// Sort balls by descending count order\\n        sort(inventory.begin(), inventory.end(), std::greater<int>());\\n        \\n        // Used to box group of colours that should be sold next\\n        int leftBoundary = 1;\\n        \\n        // Keep counting profit until orders are fulfilled\\n        while (orders > 0) {\\n            // Find next colour with less balls\\n            while (leftBoundary < inventory.size() && inventory[leftBoundary] == inventory[leftBoundary - 1]) {\\n                ++leftBoundary;\\n            }\\n            long currentCount = inventory[leftBoundary - 1];\\n            long nextCount = (leftBoundary < inventory.size()) ? inventory[leftBoundary] : 0;\\n            // At this point all colours between indexdes 0 and leftBoundary - 1 inclusively have the same highest count (currentCount - nextCount)\\n            \\n            // Determine number of balls that could potentially be sold\\n            int potentialSellCount = (currentCount - nextCount) * leftBoundary;\\n            \\n            // Determine actual number of balls that can be sold (don\\'t sell more than the order)\\n            int sellCount = std::min(potentialSellCount, orders);\\n            \\n            // Number of balls to take from each colour\\n            int ballsPerColour = sellCount / leftBoundary;\\n            // Update number of remaining balls (we should technically update everything between 0 and leftBoundary but it would be a waste of time)\\n            //std::fill_n(inventory.begin(), leftBoundary, currentCount - ballsPerColour);\\n            inventory[leftBoundary - 1] -= ballsPerColour;\\n            \\n            // When orders < potentialSellCount, we won\\'t consume all the colours with max counts. Some leftover orders will have to be fulfilled\\n            int rem  = sellCount % leftBoundary;\\n            \\n            long sumPerColumn = nSum(currentCount) - nSum(currentCount - ballsPerColour);\\n            long profit = sumPerColumn * leftBoundary;\\n            if (rem > 0){\\n                // When orders < potentialSellCount. Take care of leftover orders to fulfill\\n                int nextValue = currentCount - ballsPerColour;\\n                profit += (long)nextValue * rem;\\n            }\\n            \\n            ans = (ans + profit) % MOD;\\n            orders -= sellCount;\\n        }\\n\\n        return ans;\\n    }\\n    \\nprivate:\\n    long nSum(long n) {\\n        // Computes n + (n - 1) + (n - 2) + ... + 1\\n        // Gauss formula: https://nrich.maths.org/2478#:~:text=Gauss%20added%20the%20rows%20pairwise,quantity%20in%20a%20clever%20way.\\n        return n*(n+1)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992714,
                "title": "c-binary-search",
                "content": "```\\nstruct Solution {\\n    static const auto mod = 1\\'000\\'000\\'007;\\n    \\n    bool check(int mid, int orders, vector<int>& arr) {\\n\\t/* Determine if buying all balls of value >= mid yields at least orders orders */\\n        int res = 0;\\n        for(auto t : arr) {\\n            res += (t >= mid) ? t-mid + 1 : 0; /* buy all balls of value >= mid */\\n            \\n            if (res >= orders) /* avoid overflow */\\n                break;\\n        }\\n        return res >= orders;\\n    }\\n    \\n    int maxProfit(vector<int>& arr, int orders) {\\n\\t/* maximum profit given orders orders */\\n        int l = 0, r = 1\\'000\\'000\\'000;\\n                \\n        while(l < r) {\\n            int mid = (l + r + 1) / 2;\\n            if (check(mid, orders, arr)) l = mid;\\n            else r = mid - 1;\\n        } /* l == r */\\n\\n        int64_t ans = 0; /* return value */\\n\\n        for(auto t : arr) {\\n            if (orders == 0) break;\\n            if(t > l) {\\n                int64_t cnt; \\n                orders -= cnt = min(orders, t - l); /* buy all balls of value strictly greater than l */\\n                ans += cnt * (t+t-cnt+1)/2; /* add up the values of the balls bought (sum of arithmetic series) */\\n                ans %= mod;\\n            } \\n        }\\n        if(orders) /* if any orders left, by some balls of value l */\\n            ans = (ans + (int64_t) orders * l) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nstruct Solution {\\n    static const auto mod = 1\\'000\\'000\\'007;\\n    \\n    bool check(int mid, int orders, vector<int>& arr) {\\n\\t/* Determine if buying all balls of value >= mid yields at least orders orders */\\n        int res = 0;\\n        for(auto t : arr) {\\n            res += (t >= mid) ? t-mid + 1 : 0; /* buy all balls of value >= mid */\\n            \\n            if (res >= orders) /* avoid overflow */\\n                break;\\n        }\\n        return res >= orders;\\n    }\\n    \\n    int maxProfit(vector<int>& arr, int orders) {\\n\\t/* maximum profit given orders orders */\\n        int l = 0, r = 1\\'000\\'000\\'000;\\n                \\n        while(l < r) {\\n            int mid = (l + r + 1) / 2;\\n            if (check(mid, orders, arr)) l = mid;\\n            else r = mid - 1;\\n        } /* l == r */\\n\\n        int64_t ans = 0; /* return value */\\n\\n        for(auto t : arr) {\\n            if (orders == 0) break;\\n            if(t > l) {\\n                int64_t cnt; \\n                orders -= cnt = min(orders, t - l); /* buy all balls of value strictly greater than l */\\n                ans += cnt * (t+t-cnt+1)/2; /* add up the values of the balls bought (sum of arithmetic series) */\\n                ans %= mod;\\n            } \\n        }\\n        if(orders) /* if any orders left, by some balls of value l */\\n            ans = (ans + (int64_t) orders * l) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976205,
                "title": "python-solution",
                "content": "Time: **O(N*logN)**, Space: **O(1)**, **N:** the number element in \\'inventory\\'\\n\\n```\\nclass Solution:       \\n    def sequenceSum(self, n):\\n        return n * (n + 1) // 2\\n    \\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        MOD = 10**9 + 7\\n        inventory.sort(reverse=True)\\n        output = 0\\n        width = 0\\n        i = 1\\n        while orders > 0:\\n            width += 1\\n            upper = inventory[i-1]\\n            lower = 0\\n            if i < len(inventory):\\n                lower = inventory[i]\\n                i += 1\\n                if upper == lower:\\n                    continue\\n            height = upper - lower\\n            count = height * width\\n            if count >= orders:\\n                quo = orders // width\\n                rem = orders % width\\n                lower = upper - quo\\n                output += (upper - quo) * rem\\n\\n            output += (self.sequenceSum(upper) - self.sequenceSum(lower)) * width\\n            orders -= count\\n            \\n        return output % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:       \\n    def sequenceSum(self, n):\\n        return n * (n + 1) // 2\\n    \\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        MOD = 10**9 + 7\\n        inventory.sort(reverse=True)\\n        output = 0\\n        width = 0\\n        i = 1\\n        while orders > 0:\\n            width += 1\\n            upper = inventory[i-1]\\n            lower = 0\\n            if i < len(inventory):\\n                lower = inventory[i]\\n                i += 1\\n                if upper == lower:\\n                    continue\\n            height = upper - lower\\n            count = height * width\\n            if count >= orders:\\n                quo = orders // width\\n                rem = orders % width\\n                lower = upper - quo\\n                output += (upper - quo) * rem\\n\\n            output += (self.sequenceSum(upper) - self.sequenceSum(lower)) * width\\n            orders -= count\\n            \\n        return output % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958890,
                "title": "that-greedy-binary-search-python",
                "content": "Initially this seemed like a great heap problem but that didn\\'t seem that useful because once you find the top of heap how do you use it efficiently rather than decrementing by 1.  This proved especially troublesome when there were multiple top max heap elements of same value.\\n\\nI believe greedy binary search is much more elegant.\\n\\nWe want to act greedy and take from the top, so let\\'s use binary search to partition the set with \\nthe following search condition: s = sum of all orders above the line must be <= total orders\\nWe use binary search\\'s cousin with lo < hi and hi = mid and condition s <= orders.  \\nThen hi divides the set precisely.\\nWe can use sum of first n numbers - sum of first hi numbers to calculate the top sum\\nAnd then just add remaining orders that is of value hi until orders are fully exhausted.  \\nWe know they will be fully exhausted because of the binary search partition.\\n\\nThe small detail is throughout this process we have to keep applying modular arithmetic otherwise the summations will probably overflow.\\n\\nTime complexity is logn for binary search times n because in order to sum the orders above hi we go through the whole array O(nlogn)\\nSpace complexity is O(1)\\n```\\n\"\"\"\\n   o\\no oo\\n-----\\no oo\\nooooo\\n\\norders = 6\\nhi = 2\\n\"\"\"\\nclass Solution:\\n  def __init__(self):\\n    self.MOD = 10**9+7\\n  \\n  def getProfit(self, n1, n2):\\n    p1 = (n1*(n1+1)//2) % self.MOD \\n    p2 = (n2*(n2+1)//2) % self.MOD \\n    return (p1-p2) % self.MOD \\n  \\n  def maxProfit(self, inventory: List[int], orders: int) -> int:\\n    profit = 0\\n    lo = 0\\n    hi = max(inventory) + 1\\n    while lo < hi:\\n      mid = lo + (hi-lo)//2\\n      s = 0\\n      for num in inventory:\\n        if num > mid:\\n          s += num - mid\\n      if s > orders:\\n        lo = mid + 1\\n      else:\\n        hi = mid\\n    for num in inventory:\\n      if num <= hi:\\n        continue\\n      profit = (profit + self.getProfit(num, hi)) % self.MOD\\n      orders -= num - hi\\n    for num in inventory:\\n      if orders == 0:\\n        break\\n      if num >= hi:\\n        profit = (profit+hi) % self.MOD\\n        orders -= 1\\n    return profit\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n\"\"\"\\n   o\\no oo\\n-----\\no oo\\nooooo\\n\\norders = 6\\nhi = 2\\n\"\"\"\\nclass Solution:\\n  def __init__(self):\\n    self.MOD = 10**9+7\\n  \\n  def getProfit(self, n1, n2):\\n    p1 = (n1*(n1+1)//2) % self.MOD \\n    p2 = (n2*(n2+1)//2) % self.MOD \\n    return (p1-p2) % self.MOD \\n  \\n  def maxProfit(self, inventory: List[int], orders: int) -> int:\\n    profit = 0\\n    lo = 0\\n    hi = max(inventory) + 1\\n    while lo < hi:\\n      mid = lo + (hi-lo)//2\\n      s = 0\\n      for num in inventory:\\n        if num > mid:\\n          s += num - mid\\n      if s > orders:\\n        lo = mid + 1\\n      else:\\n        hi = mid\\n    for num in inventory:\\n      if num <= hi:\\n        continue\\n      profit = (profit + self.getProfit(num, hi)) % self.MOD\\n      orders -= num - hi\\n    for num in inventory:\\n      if orders == 0:\\n        break\\n      if num >= hi:\\n        profit = (profit+hi) % self.MOD\\n        orders -= 1\\n    return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928992,
                "title": "clean-c-code-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll findSumFromAToB(ll a, ll b){\\n        return (b*(b+1)/2 - (a*(a+1))/2)%mod;\\n    }\\n    \\n    int maxProfit(vector<int>& nums, int orders) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll res=0;\\n        for(int i=n-1;i>=0 && orders>0;i--){\\n            int p=(i==0)?0:nums[i-1];\\n            int k=(n-1-i)+1;\\n            if(orders >= k*(nums[i]-p)){\\n                res += k*findSumFromAToB(p,nums[i]);\\n                orders -= k*(nums[i]-p);\\n            }else{\\n                ll r = orders / k, c = orders % k;\\n                res += k*findSumFromAToB(nums[i]-r,nums[i]) + (nums[i]-r)*c;\\n                orders=0;\\n            }\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll findSumFromAToB(ll a, ll b){\\n        return (b*(b+1)/2 - (a*(a+1))/2)%mod;\\n    }\\n    \\n    int maxProfit(vector<int>& nums, int orders) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll res=0;\\n        for(int i=n-1;i>=0 && orders>0;i--){\\n            int p=(i==0)?0:nums[i-1];\\n            int k=(n-1-i)+1;\\n            if(orders >= k*(nums[i]-p)){\\n                res += k*findSumFromAToB(p,nums[i]);\\n                orders -= k*(nums[i]-p);\\n            }else{\\n                ll r = orders / k, c = orders % k;\\n                res += k*findSumFromAToB(nums[i]-r,nums[i]) + (nums[i]-r)*c;\\n                orders=0;\\n            }\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926375,
                "title": "c-average-tc-o-n-based-on-fast-select-median-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        // inventory array:\\n        // ... large elements (>= last_choice) ... |  ...unsettled elements... | ... small elements (ignored) ...\\n        //                                         ^                           ^\\n        //                                       first                        last\\n        int64_t first = 0, last = inventory.size();\\n        int64_t last_choice = INT_MAX;\\n        int64_t target_orders = orders;\\n        \\n        do\\n        {\\n            if(last - first == 1)\\n            {\\n                // find x, s.t. first * (last_choice - x) + (inventory[first] - x) >= target_orders\\n                last_choice = (first * last_choice + inventory[first] - target_orders) / (first + 1);\\n                break;\\n            }\\n            \\n            int64_t mid = (last + first) / 2;\\n\\n            nth_element(inventory.begin() + first, inventory.begin() + mid, \\n                        inventory.begin() + last, greater<int>());\\n\\n            int64_t trial_orders = accumulate(inventory.begin() + first, inventory.begin() + mid, 0L)\\n                                   - inventory[mid] * mid + first * last_choice;\\n\\n            if(trial_orders > target_orders)\\n            {\\n                last = mid;\\n            }\\n            else\\n            {\\n                target_orders -= trial_orders;\\n                last_choice = inventory[mid];\\n                first = mid;\\n            }\\n            \\n        }while(target_orders > 0);\\n        \\n        int64_t total_profit = 0;\\n        int64_t total_orders = 0;\\n        for(int i = 0; i <= first; ++i)\\n        {\\n            int64_t norders = inventory[i] - last_choice;\\n            total_orders += norders;\\n            total_profit += (inventory[i] + last_choice + 1) * norders / 2;\\n        }\\n        \\n        int64_t overfulfilled_orders = total_orders - orders;\\n        if(overfulfilled_orders > 0)\\n        {\\n            total_profit -= (last_choice + 1) * overfulfilled_orders;\\n        }\\n        \\n        return total_profit % 1000000007;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        \\n        // inventory array:\\n        // ... large elements (>= last_choice) ... |  ...unsettled elements... | ... small elements (ignored) ...\\n        //                                         ^                           ^\\n        //                                       first                        last\\n        int64_t first = 0, last = inventory.size();\\n        int64_t last_choice = INT_MAX;\\n        int64_t target_orders = orders;\\n        \\n        do\\n        {\\n            if(last - first == 1)\\n            {\\n                // find x, s.t. first * (last_choice - x) + (inventory[first] - x) >= target_orders\\n                last_choice = (first * last_choice + inventory[first] - target_orders) / (first + 1);\\n                break;\\n            }\\n            \\n            int64_t mid = (last + first) / 2;\\n\\n            nth_element(inventory.begin() + first, inventory.begin() + mid, \\n                        inventory.begin() + last, greater<int>());\\n\\n            int64_t trial_orders = accumulate(inventory.begin() + first, inventory.begin() + mid, 0L)\\n                                   - inventory[mid] * mid + first * last_choice;\\n\\n            if(trial_orders > target_orders)\\n            {\\n                last = mid;\\n            }\\n            else\\n            {\\n                target_orders -= trial_orders;\\n                last_choice = inventory[mid];\\n                first = mid;\\n            }\\n            \\n        }while(target_orders > 0);\\n        \\n        int64_t total_profit = 0;\\n        int64_t total_orders = 0;\\n        for(int i = 0; i <= first; ++i)\\n        {\\n            int64_t norders = inventory[i] - last_choice;\\n            total_orders += norders;\\n            total_profit += (inventory[i] + last_choice + 1) * norders / 2;\\n        }\\n        \\n        int64_t overfulfilled_orders = total_orders - orders;\\n        if(overfulfilled_orders > 0)\\n        {\\n            total_profit -= (last_choice + 1) * overfulfilled_orders;\\n        }\\n        \\n        return total_profit % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877665,
                "title": "please-i-need-help",
                "content": "```\\n\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\nvar maxProfit = function(inventory, orders) {\\n    const MOD = 1e9 + 7\\n    let totalCost = 0;\\n    let fulfilledOrders = orders\\n\\n    while (fulfilledOrders > 0) {\\n        inventory.sort((a, b)=>b-a)\\n        if (inventory[0] > inventory[1]) {\\n            const ordersCanFulfill = inventory[0] - inventory[1]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill)\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n\\n        } else if (inventory.length > 1) {\\n\\n            const ordersCanFulfill = inventory[0]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill, 1)\\n\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n\\n\\n        } else {\\n            const ordersCanFulfill = inventory[0]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill)\\n\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n        }\\n    }\\n    return totalCost % MOD\\n};\\n\\nconst getSumInSequence = (a, n) => {\\n    return (((2 * a)+(n-1)) * n)/2\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} inventory\\n * @param {number} orders\\n * @return {number}\\n */\\nvar maxProfit = function(inventory, orders) {\\n    const MOD = 1e9 + 7\\n    let totalCost = 0;\\n    let fulfilledOrders = orders\\n\\n    while (fulfilledOrders > 0) {\\n        inventory.sort((a, b)=>b-a)\\n        if (inventory[0] > inventory[1]) {\\n            const ordersCanFulfill = inventory[0] - inventory[1]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill)\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n\\n        } else if (inventory.length > 1) {\\n\\n            const ordersCanFulfill = inventory[0]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill, 1)\\n\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n\\n\\n        } else {\\n            const ordersCanFulfill = inventory[0]\\n\\n            const newFufilledOrders = Math.min(fulfilledOrders, ordersCanFulfill)\\n\\n            fulfilledOrders -= newFufilledOrders\\n\\n            const cost = getSumInSequence(inventory[0]-newFufilledOrders+1, newFufilledOrders)\\n\\n            inventory[0] = inventory[0]-newFufilledOrders\\n            totalCost += cost\\n        }\\n    }\\n    return totalCost % MOD\\n};\\n\\nconst getSumInSequence = (a, n) => {\\n    return (((2 * a)+(n-1)) * n)/2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821162,
                "title": "c-sort-time-o-n-log-n-space-o-1",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A, int orders) {\\n        sort(begin(A), end(A));\\n        int mod = 1000000000 + 7;\\n        int ans = 0;\\n        int cnt = 0;\\n        int n = A.size();\\n        for(int i = n-1; i >= 0; i--){\\n            int H;\\n            if(i == 0){\\n                H = A[i];\\n            }\\n            else H = A[i] - A[i-1];\\n            int left = orders - cnt;\\n            if(H*(n-i) >= left){\\n                int D = left/(n-i);\\n                int R = left%(n-i);\\n                long long tot = (long long)A[i]*(A[i]+1)/2;\\n                long long minus = (long long)(A[i]-D)*(A[i]-D+1)/2;\\n                ans = (ans + (tot - minus)*(n-i)) % mod;\\n                ans = (ans + (long long)(A[i] - D)*R) % mod;\\n                break;\\n            }\\n            else{\\n                long long tot = (long long)A[i]*(A[i]+1)/2;\\n                long long minus = (long long)(A[i]-H)*(A[i]-H+1)/2;\\n                ans = (ans + (tot - minus)*(n-i)) % mod;\\n                cnt += H*(n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A, int orders) {\\n        sort(begin(A), end(A));\\n        int mod = 1000000000 + 7;\\n        int ans = 0;\\n        int cnt = 0;\\n        int n = A.size();\\n        for(int i = n-1; i >= 0; i--){\\n            int H;\\n            if(i == 0){\\n                H = A[i];\\n            }\\n            else H = A[i] - A[i-1];\\n            int left = orders - cnt;\\n            if(H*(n-i) >= left){\\n                int D = left/(n-i);\\n                int R = left%(n-i);\\n                long long tot = (long long)A[i]*(A[i]+1)/2;\\n                long long minus = (long long)(A[i]-D)*(A[i]-D+1)/2;\\n                ans = (ans + (tot - minus)*(n-i)) % mod;\\n                ans = (ans + (long long)(A[i] - D)*R) % mod;\\n                break;\\n            }\\n            else{\\n                long long tot = (long long)A[i]*(A[i]+1)/2;\\n                long long minus = (long long)(A[i]-H)*(A[i]-H+1)/2;\\n                ans = (ans + (tot - minus)*(n-i)) % mod;\\n                cnt += H*(n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811821,
                "title": "python3-linear-math-approach",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        st = []\\n        inventory.sort(reverse = True)\\n        n = len(inventory)\\n        inventory.append(0)\\n\\n        cur = 0\\n        score = 0\\n        p = 10**9 + 7\\n        \\n        for i in range(n):\\n            start,end = inventory[i], inventory[i+1] + 1\\n\\n            if cur + (i+1)*(start - end + 1)<=orders:\\n                cur = cur + (i+1)*(start - end + 1)\\n                score = (score + (i+1)*(start + end)*(start - end + 1) // 2)%p\\n            else:\\n                lap = (orders - cur) // (i+1)\\n                rem = (orders - cur) % (i + 1)\\n                end = start - lap + 1\\n                score = score + (start + end)*(start - end + 1) // 2 * (i+1)\\n                score = (score + (end-1)*rem)%p\\n                break\\n        return score\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        st = []\\n        inventory.sort(reverse = True)\\n        n = len(inventory)\\n        inventory.append(0)\\n\\n        cur = 0\\n        score = 0\\n        p = 10**9 + 7\\n        \\n        for i in range(n):\\n            start,end = inventory[i], inventory[i+1] + 1\\n\\n            if cur + (i+1)*(start - end + 1)<=orders:\\n                cur = cur + (i+1)*(start - end + 1)\\n                score = (score + (i+1)*(start + end)*(start - end + 1) // 2)%p\\n            else:\\n                lap = (orders - cur) // (i+1)\\n                rem = (orders - cur) % (i + 1)\\n                end = start - lap + 1\\n                score = score + (start + end)*(start - end + 1) // 2 * (i+1)\\n                score = (score + (end-1)*rem)%p\\n                break\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808244,
                "title": "c-linear-o-n-k-solution-using-bucket-sort-why-tle",
                "content": "I am wondering why this solution using bucket sort is not acceptable:\\n**C++:**\\n ```\\n     int maxProfit(vector<int>& inventory, int orders) {\\n        long totalValue = 0;\\n        \\n        int maxFreq = -1;\\n        \\n        for(int count : inventory) maxFreq = max(count, maxFreq);\\n        \\n        unordered_map<int, int> buckets;\\n        for(int i = 0; i < inventory.size(); i++) {\\n            buckets[inventory[i]]++;\\n        }\\n        \\n        for(; orders > 0; orders --) {\\n            totalValue += maxFreq;\\n            buckets[maxFreq] --;\\n            buckets[maxFreq - 1]++;\\n            if(buckets[maxFreq] == 0) {\\n                buckets.erase(maxFreq);\\n                maxFreq--;\\n            }\\n        }\\n        \\n        return totalValue % (1000000007);\\n    }\\n ```\\n\\nLet N = inventory.size()\\nLet K = orders\\n\\nThe time complexity of this solution should be O(N + K): O(N) to count the occurrences of each frequency, O(K) to resolve every order.\\n\\nThe space complexity O(N), and should always be better than O(N) unless every single inventory[i] is unique.\\n\\nI believe the overhead of the map operations is somehow causing this solution to fail, despite it being better than O(nlogn)",
                "solutionTags": [
                    "Bucket Sort"
                ],
                "code": "```\\n     int maxProfit(vector<int>& inventory, int orders) {\\n        long totalValue = 0;\\n        \\n        int maxFreq = -1;\\n        \\n        for(int count : inventory) maxFreq = max(count, maxFreq);\\n        \\n        unordered_map<int, int> buckets;\\n        for(int i = 0; i < inventory.size(); i++) {\\n            buckets[inventory[i]]++;\\n        }\\n        \\n        for(; orders > 0; orders --) {\\n            totalValue += maxFreq;\\n            buckets[maxFreq] --;\\n            buckets[maxFreq - 1]++;\\n            if(buckets[maxFreq] == 0) {\\n                buckets.erase(maxFreq);\\n                maxFreq--;\\n            }\\n        }\\n        \\n        return totalValue % (1000000007);\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795342,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    const int mod = 1e9 + 7;\\n    bool check(int mid, int orders, vector<int>& arr) {\\n        LL res = 0;\\n        for(auto &t : arr) {\\n            if(t >= mid) {\\n                res += t-mid + 1;\\n            }    \\n        }\\n        return res >= orders;\\n    }\\n    int maxProfit(vector<int>& arr, int orders) {\\n        int l = 0, r = 1e9;\\n        while(l < r) {\\n            int mid =( l + r + 1) >> 1;\\n            if(check(mid, orders, arr)) l = mid;\\n            else r = mid - 1;\\n        }\\n\\n        LL ans = 0;\\n        int price = l+1;\\n        for(auto &t : arr) {\\n            if(!orders) break;\\n            if(t >= price) {\\n                LL cnt = min(orders, t-price+1);\\n                orders -= cnt;\\n                ans = (ans + (LL)(cnt)*((LL)t+t-cnt+1)/2) % mod;\\n            } \\n        }\\n        if(orders) ans = (ans + (LL)orders * l) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    const int mod = 1e9 + 7;\\n    bool check(int mid, int orders, vector<int>& arr) {\\n        LL res = 0;\\n        for(auto &t : arr) {\\n            if(t >= mid) {\\n                res += t-mid + 1;\\n            }    \\n        }\\n        return res >= orders;\\n    }\\n    int maxProfit(vector<int>& arr, int orders) {\\n        int l = 0, r = 1e9;\\n        while(l < r) {\\n            int mid =( l + r + 1) >> 1;\\n            if(check(mid, orders, arr)) l = mid;\\n            else r = mid - 1;\\n        }\\n\\n        LL ans = 0;\\n        int price = l+1;\\n        for(auto &t : arr) {\\n            if(!orders) break;\\n            if(t >= price) {\\n                LL cnt = min(orders, t-price+1);\\n                orders -= cnt;\\n                ans = (ans + (LL)(cnt)*((LL)t+t-cnt+1)/2) % mod;\\n            } \\n        }\\n        if(orders) ans = (ans + (LL)orders * l) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784475,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n=inventory.size();\\n        long long int ans=0,mod=pow(10,9)+7;\\n        \\n        sort(inventory.begin(),inventory.end());\\n        \\n        int l=0,r=inventory[n-1];\\n        long long int cnt;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(check(inventory,mid,orders))\\n            {\\n                l=mid+1;\\n                cnt=mid;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }   \\n        //cout<<cnt<<endl;\\n        long long value=0,k=0,value1=0;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            value+=inventory[i]-cnt+1-1;\\n            \\n            if(inventory[i]>=cnt+1)\\n            {\\n                long long t=inventory[i];\\n                k=t*(t+1)/2-(cnt+1)*(cnt)/2;\\n                value1+=inventory[i]-cnt+1-1;\\n                ans=(ans+k)%mod;\\n            }\\n        }\\n        \\n        long long more=orders-value1;\\n        ans=(ans+more*cnt)%mod;\\n        \\n        return ans%mod;\\n    }\\n    \\n    bool check(vector<int>& inventory,int mid,int orders)\\n    {\\n        int n=inventory.size();\\n        long long value=0;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            value+=inventory[i]-mid+1;\\n            \\n            if(value>=orders)\\n            return true;\\n        }     \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& inventory, int orders) {\\n        int n=inventory.size();\\n        long long int ans=0,mod=pow(10,9)+7;\\n        \\n        sort(inventory.begin(),inventory.end());\\n        \\n        int l=0,r=inventory[n-1];\\n        long long int cnt;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(check(inventory,mid,orders))\\n            {\\n                l=mid+1;\\n                cnt=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1784235,
                "title": "easiest-solution-to-explain-better-divided-into-two-while-loops-c-soln",
                "content": "the first while loop is used to traverse the array to find summation of answer upto the limit till when the value of passed integers or locations in array when multiplied with difference is still less than the order !\\n\\nThe second loop runs when that condition breaks\\n```\\n  int maxProfit(vector<int>& inventory, int orders) {\\n        int n=inventory.size();\\n        sort(inventory.begin(),inventory.end(),greater<int>() );  \\n        int end=1;\\n        long  sum=0,temp=1;\\n        long  test=1e9 +7;\\n        while(end<n and orders>0)\\n        {\\n            long diff=inventory[end-1]-inventory[end];\\n            if(diff*temp<=orders){\\n            sum += (temp * (diff )*(2*1LL*inventory[end-1] + 1 - diff ) )/2; \\n            orders -= diff*temp;\\n            inventory[end-1]-=diff;    \\n            end++;\\n            temp++;     \\n            }\\n            else\\n                break;\\n        }\\n        while(orders>0)\\n        {\\n            if(orders/temp >0 )\\n            {\\n            int zap=orders/temp; \\n            sum+= ((temp*zap)*( 2*1ll*inventory[end-1]+ 1 - (zap)  ))/2 ;\\n            orders=orders%temp;\\n            inventory[end-1]-=(zap);\\n            }\\n            else\\n            {\\n                sum+= long(orders) * long( inventory[end-1] );\\n                break;\\n            }\\n        }\\n        return ( sum%(test) );\\n    }\\n\\t```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n  int maxProfit(vector<int>& inventory, int orders) {\\n        int n=inventory.size();\\n        sort(inventory.begin(),inventory.end(),greater<int>() );  \\n        int end=1;\\n        long  sum=0,temp=1;\\n        long  test=1e9 +7;\\n        while(end<n and orders>0)\\n        {\\n            long diff=inventory[end-1]-inventory[end];\\n            if(diff*temp<=orders){\\n            sum += (temp * (diff )*(2*1LL*inventory[end-1] + 1 - diff ) )/2; \\n            orders -= diff*temp;\\n            inventory[end-1]-=diff;    \\n            end++;\\n            temp++;     \\n            }\\n            else\\n                break;\\n        }\\n        while(orders>0)\\n        {\\n            if(orders/temp >0 )\\n            {\\n            int zap=orders/temp; \\n            sum+= ((temp*zap)*( 2*1ll*inventory[end-1]+ 1 - (zap)  ))/2 ;\\n            orders=orders%temp;\\n            inventory[end-1]-=(zap);\\n            }\\n            else\\n            {\\n                sum+= long(orders) * long( inventory[end-1] );\\n                break;\\n            }\\n        }\\n        return ( sum%(test) );\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778709,
                "title": "python-sorting-greedy-explained",
                "content": "Keep on making all earlier popped elements equal to newly popped element untill deque is empty and add no * difference to answer.Break while loop whenever orders is going negative.\\nval=value of all popped elements all having same value\\nno=number of such elements\\nNow, as all elements are having same value ,question is much simplified.\\nThen just take floor division of orders with no to take maximum value from all those numbers.\\n( For example for val=8 and orders=33 and no=5, we have quo=6\\n hence, take (8+7+6+5+4+3) * no=(8+7+6+5+4+3) * 5\\n new val is now 2\\n now rem=3, hence take 3 * new val=3 * 2 to complete your computation ). \\nFinally take rem=order%no to take rem of no elements.\\n```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        n=len(inventory)\\n        ans=0\\n        mod=10**9+7\\n        def compute_sum(x):\\n            return (x*(x+1))//2\\n        inventory=deque(sorted(inventory,reverse=True))\\n        no,val,i=0,0,0\\n        while inventory:\\n            a=inventory.popleft()\\n            if i!=0:\\n                x=val-a\\n                if orders-no*x<0: break\\n                ans+=no*(compute_sum(val)-compute_sum(a))\\n                ans%=mod\\n                orders-=no*x\\n            val=a\\n            no+=1\\n            if orders==0: return ans%mod\\n            i+=1\\n        while orders>0:\\n            quo=orders//no\\n            rem=orders%no\\n            if quo!=0: \\n                ans+=no*(compute_sum(val)-compute_sum(val-quo))\\n                val=val-quo\\n                orders=rem\\n            else:\\n                ans+=rem*val\\n                return ans%mod\\n        return ans%mod\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        n=len(inventory)\\n        ans=0\\n        mod=10**9+7\\n        def compute_sum(x):\\n            return (x*(x+1))//2\\n        inventory=deque(sorted(inventory,reverse=True))\\n        no,val,i=0,0,0\\n        while inventory:\\n            a=inventory.popleft()\\n            if i!=0:\\n                x=val-a\\n                if orders-no*x<0: break\\n                ans+=no*(compute_sum(val)-compute_sum(a))\\n                ans%=mod\\n                orders-=no*x\\n            val=a\\n            no+=1\\n            if orders==0: return ans%mod\\n            i+=1\\n        while orders>0:\\n            quo=orders//no\\n            rem=orders%no\\n            if quo!=0: \\n                ans+=no*(compute_sum(val)-compute_sum(val-quo))\\n                val=val-quo\\n                orders=rem\\n            else:\\n                ans+=rem*val\\n                return ans%mod\\n        return ans%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759142,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        long modulo = 1000000007;\\n        Arrays.sort(inventory);\\n        \\n        int cnt = 0, i  = inventory.length - 1;\\n        long sum = 0;\\n        while (orders > 0) {\\n            cnt++;\\n            int n = inventory[i];\\n            int d = i >= 1? n - inventory[i - 1] : 0; // difference between next ball\\n\\n            if (d == 0 && i != 0) {\\n                i--;\\n                continue;\\n            }\\n\\n\\n            if (i > 0 && orders >= d * cnt) {\\n                sum += (long) (n - d + 1 + n) *d / 2 * cnt;\\n                orders -=  d * cnt;\\n            } else {\\n                int a = orders / cnt;\\n                sum += (long) (n - a + 1 + n) * a / 2 * cnt;\\n                int b = orders % cnt;\\n                sum += (long) (n - a) * b;\\n                orders = 0;\\n            }\\n            sum = (sum + modulo) % modulo;\\n            i--;\\n        }\\n        return (int) sum;     \\n    }\\n}\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        long modulo = 1000000007;\\n        Arrays.sort(inventory);\\n        \\n        int cnt = 0, i  = inventory.length - 1;\\n        long sum = 0;\\n        while (orders > 0) {\\n            cnt++;\\n            int n = inventory[i];\\n            int d = i >= 1? n - inventory[i - 1] : 0; // difference between next ball\\n\\n            if (d == 0 && i != 0) {\\n                i--;\\n                continue;\\n            }\\n\\n\\n            if (i > 0 && orders >= d * cnt) {\\n                sum += (long) (n - d + 1 + n) *d / 2 * cnt;\\n                orders -=  d * cnt;\\n            } else {\\n                int a = orders / cnt;\\n                sum += (long) (n - a + 1 + n) * a / 2 * cnt;\\n                int b = orders % cnt;\\n                sum += (long) (n - a) * b;\\n                orders = 0;\\n            }\\n            sum = (sum + modulo) % modulo;\\n            i--;\\n        }\\n        return (int) sum;     \\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748192,
                "title": "scala-ac-math-math-math",
                "content": "```\\n  // Time Complexity: O(nlogn)\\n  // Space complexity: O(1)\\n  def maxProfit(inventory: Array[Int], orders: Int): Int = {\\n    val kMod = (scala.math.pow(10, 9) + 7).toInt\\n    val n = inventory.size\\n    val sortedInventory = inventory.sorted.reverse\\n    var cur = sortedInventory(0)\\n    var ans: Long = 0\\n    var groupCount = 1\\n    var newOrders = orders\\n    // 10, 9, 6, 6, 4, 2\\n    while (newOrders != 0) {\\n      while (groupCount < n && sortedInventory(groupCount) == cur) groupCount += 1\\n      val nxt = if (groupCount == n) 0 else sortedInventory(groupCount)\\n      val count = newOrders.min(groupCount * (cur - nxt))\\n      val (times, r): (Long, Long) =\\n        if (newOrders >= groupCount * (cur - nxt)) {\\n          (cur - nxt, 0) // 10 - 9, 9 - 6\\n        } else {\\n          (newOrders / groupCount, newOrders % groupCount)\\n        }\\n      val next_point: Long = cur - times // 10 - 1, 9 - 3 = (6)\\n\\n      // ((6 + 1) + 9) * 3 / 2 * 2 (idx: 0 and 1 )\\n      ans += ((next_point + 1) + cur) * times / 2 * groupCount + next_point * r\\n      newOrders -= count\\n      cur = nxt\\n    }\\n    (ans % kMod).toInt\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n  // Time Complexity: O(nlogn)\\n  // Space complexity: O(1)\\n  def maxProfit(inventory: Array[Int], orders: Int): Int = {\\n    val kMod = (scala.math.pow(10, 9) + 7).toInt\\n    val n = inventory.size\\n    val sortedInventory = inventory.sorted.reverse\\n    var cur = sortedInventory(0)\\n    var ans: Long = 0\\n    var groupCount = 1\\n    var newOrders = orders\\n    // 10, 9, 6, 6, 4, 2\\n    while (newOrders != 0) {\\n      while (groupCount < n && sortedInventory(groupCount) == cur) groupCount += 1\\n      val nxt = if (groupCount == n) 0 else sortedInventory(groupCount)\\n      val count = newOrders.min(groupCount * (cur - nxt))\\n      val (times, r): (Long, Long) =\\n        if (newOrders >= groupCount * (cur - nxt)) {\\n          (cur - nxt, 0) // 10 - 9, 9 - 6\\n        } else {\\n          (newOrders / groupCount, newOrders % groupCount)\\n        }\\n      val next_point: Long = cur - times // 10 - 1, 9 - 3 = (6)\\n\\n      // ((6 + 1) + 9) * 3 / 2 * 2 (idx: 0 and 1 )\\n      ans += ((next_point + 1) + cur) * times / 2 * groupCount + next_point * r\\n      newOrders -= count\\n      cur = nxt\\n    }\\n    (ans % kMod).toInt\\n  }\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566202,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1567061,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1568635,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1654029,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1576924,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1798478,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            },
            {
                "id": 1734439,
                "content": [
                    {
                        "username": "paulonteri",
                        "content": "How are you expected to come up with that math in an interview?"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "I stucked on this for hours, don\\'t think I did anything wrong but just couldn\\'t pass the test case 8 [773160767] 252264991.\\n\\nThe issue is with float precision.\\nTo compute consecutive sum, there are 2 ways:\\n1) (start+end) * n //2\\n2) end(end+1)*//2 - (start-1)start//2\\n\\nuse 2), because 1) leads to stack overflow (this might not cause real problem for all current test cases)\\n\\nMore importantly, you have to use // instead of / or *0.5.\\nBecause using / or *0.5 leads to float, and float is approximated and can\\'t give you the right number. using // gives you integer without approximation.\\nExample:\\nend = 773160767\\n(end+1)*end//2: 298888786200594528 (correct!)\\n(end+1)*end/2: 597777572401189056 (wrong!)\\n(end+1)*end * 0.5: 298888786200594560.00000 (wrong!)\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This is wired. \\nSince I only have one color ball, so I just sell 252264991 from [773160767].\\nThe answer should equal the summation starting from 773160767, 773160766, 773160765... all the way to 520895776,\\nbecause 773160767-252264991+1 = 520895777.\\nThen the sum of this should be (520895777+773160766) * (252264991) * 0.5 = 163222581212825536\\naccording to equation : consecutive sum = (start + end ) * (end-start+1) * 0.5\\n\\n163222581212825536 % 1000000007 = 70267476\\nWhy the answer is 70267492?\\n"
                    },
                    {
                        "username": "belikeakash",
                        "content": "This must be in hard category"
                    },
                    {
                        "username": "xixixi23333",
                        "content": "**It has something wrong with the complier. **\\n\\nFor the test case [773160767] 252264991 -> 70267492 (True)\\nAnd my formula is\\uFF1A(2*inventory[0] +1 - orders)/2 * orders % (10**9 +7)\\nThus for the above test case: 773160767*2-252264991+1)/2 * 252264991 % (10**9 +7) == 70267492\\nBut when it runs in the platform of leetcode, it turns out to be 70267476. \\nSo there must be something wrong with the complier."
                    },
                    {
                        "username": "Irving09",
                        "content": "I dont understand this question. Can somebody rewrite it?"
                    },
                    {
                        "username": "PratikKumar123",
                        "content": "I think leetcode added it here by mistake, it should be on any math\\'s portal."
                    }
                ]
            }
        ]
    }
]