[
    {
        "title": "Promise Time Limit",
        "question_content": "Given an&nbsp;asynchronous function&nbsp;fn&nbsp;and a time t&nbsp;in milliseconds, return&nbsp;a new&nbsp;time limited&nbsp;version of the input function. fn takes arguments provided to the&nbsp;time limited&nbsp;function.\nThe time limited function should follow these rules:\n\n\tIf the fn completes within the time limit of t milliseconds, the time limited function should&nbsp;resolve with the result.\n\tIf the execution of the fn exceeds the time limit, the time limited function should reject with the string \"Time Limit Exceeded\".\n\n&nbsp;\nExample 1:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\nOutput: {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\nExplanation:\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // Output\nThe provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached.\n\nExample 2:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\nOutput: {\"resolved\":25,\"time\":100}\nExplanation:\nThe function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached.\n\nExample 3:\n\nInput: \nfn = async (a, b) => { \n&nbsp; await new Promise(res => setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\nOutput: {\"resolved\":15,\"time\":120}\nExplanation:\n​​​​The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached.\n\nExample 4:\n\nInput: \nfn = async () => { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\nOutput: {\"rejected\":\"Error\",\"time\":0}\nExplanation:\nThe function immediately throws an error.\n&nbsp;\nConstraints:\n\n\t0 <= inputs.length <= 10\n\t0 <= t <= 1000\n\tfn returns a promise",
        "solutions": [
            {
                "id": 3406548,
                "title": "easy-promise-race-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413842,
                "title": "settimeout-within-promise-body",
                "content": "# Approach\\nUse promise and call setTimeout for given time t.\\nThis is async call, next line will be executed just after this  call, if callback is returned before next line completes execution then it will return promise rejection, otherwise promise will resolve regurarly.\\n\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529233,
                "title": "promise-real-life-example-dry-run-usecase-o-1-js-ts-beginner-friendly-day12",
                "content": "#Note it will better if you read ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** before reading this post as its a continuation type of post  \\n***\\n## Problem Summary:\\n* Given an `asynchronous` function fn and a time limit `t` in milliseconds, we need to create a new time-limited version of the input function. \\n* The time-limited function should behave identically to the original function, except that if it takes longer than `t` milliseconds to fulfill, it should reject with the string` \"Time Limit Exceeded\"`.\\n***\\n## Intuition:\\nWe can use a combination of `Promise`, `setTimeout`, and `async/await` to implement the time-limited function. By setting a timeout using `setTimeout`, we can enforce the time limit and reject the promise if it exceeds the specified duration.\\n***\\n## Approach:\\n* Create a wrapper function that takes the original function `fn` and the time limit `t` as parameters.\\n* Within the wrapper function, return an `async` function that accepts any number of arguments using the spread operator `...args`.\\n* Inside the `async` function, create a new `Promise` to handle the `asynchronous` execution.\\n* Use `setTimeout` to set a timer with the time limit `t`. If the timer expires before the promise is resolved, reject the `promise` with the string `\"Time Limit Exceeded\"`.\\n* Call the original function `fn` with the provided arguments `...args` and `await` its completion.\\n* If the function completes before the time limit, resolve the promise with the result.\\n* Return the promise from the `async` function.\\n***\\n## Concepts : \\n### you can refer ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** it has detailed explanation of these concepts\\n* Asynchronous functions\\n* Promises\\n* setTimeout\\n* async/await\\n***\\n## Solutions: \\n**Javascript Solution:**\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n**Typescript Solution:**\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n***\\n**Time Complexity: O(fn)\\nSpace Complexity: O(1)**\\n***\\n## Real life Example:\\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```\\n**Now Letsss discuss the flow of the code:** **Less go**\\n* We have an `asynchronous` function `fetchData` that simulates fetching data by returning a `promise` that `resolves` after a delay of `2000` milliseconds.\\n* We create a time-limited version of `fetchData` using `timeLimit` and provide the function and a time limit of `1500` milliseconds.\\n* We call the time-limited function `timeLimitedFetchData` without any arguments.\\n* Inside the time-limited function, a new `promise` is created to handle the `asynchronous` execution.\\n* A timer is set using `setTimeout` for `1500` milliseconds.\\n* The original `fetchData` function is called with no arguments and awaited for its completion.\\n* Since the original function takes `2000` milliseconds to complete, it exceeds the time limit of `1500` milliseconds.\\n* The timer expires, and the `promise` is rejected with the string `\"Time Limit Exceeded\"`.\\n* The rejection is caught in the catch block, and an error message is logged to the console. \\nThat\\'s it you got it!!\\n***\\n*We all have silly questions, so don\\'t be afraid to ask them. I will gladly answer them!!*",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529228,
                "title": "detailed-explanation-of-solution-using-promise-in-javascript-promise-race-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1.Acc to Problem statement we have function fn returning Promise and  time T.if this function takes larger time than T to resolve then we have to return new Promise which reject after Time T with \"Time Limit Exceeded\" message otherwise we have to return fn.\\n2. That means we have to return that Promise which settles earlier and for this `Promise.race([p1,p2])` is used, where p1 and p2 are promised.\\n3.This method takes list of promises and returns that promise which settles earliar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - We will first create original Promise that is return by fn and rejectedPromise that reject after T ms.\\n - Once we have these promises, we will return a promise betweeen these two which settles earliar.\\n# Complexity\\n- Time complexity: O(min(Time taken to settles among all Promises))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411232,
                "title": "easy-to-understand-javascript-typescript-begineer-friendly",
                "content": "# Explaination\\nThe Promise.race() method is one of the promise concurrency methods. It\\'s useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\\n\\nIf the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to the first of these values found in the iterable.\\n\\n***The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.***\\n\\n### Note\\n***If the iterable contains one or more non-promise value and/or an already settled promise, then Promise.race will settle to the first of these values found in the array:***\\n\\n\\n\\n# Code\\n```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004290,
                "title": "javascript-promises-api-functionality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the given problem statement.,\\n->  *if function `fn() executed before the given time period t`, then it\\'s considered that execution is \"**successful**\"*\\n->  *if function `fn() executed after the given time period t`, then it\\'s considered that execution is \"**failed**\"*\\n\\nWe need to implement a normal function execution within the time limit & a rejected function with \"Time limit exceeded\" using Promise constructor.\\n\\n*Why Promise constructor when we can achieve the same using any asynchronous function by throwing an error of \\'time limit exceeded\\'?*\\n\\nTo impose Promise API functionality on the obtained results.\\n\\n> **`Promise.race()`**, which waits only for the first settled promise and gets its result (or error)\\n\\nLet\\'s get it on!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe timeLimit function takes two arguments an asynchronous function **`fn()`** and a time **`t`** in milliseconds\\n\\nreturn an *`async function`* with arbitrary number of arguments which are passed to **`fn()`**\\n\\n**`fn()`** performs a certain execution operation and to be executed before the **`time limit t`**\\n-   ***cond1*** - a successful function exec., ***funcExec = fn(...args)***\\n-   ***cond2*** - when the time limit is exceeded before the execution of above function, a failed function exec., ***funcRej = new promise((_, reject) => {})***\\n\\nimplement a new Promise constructor\\n```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\\nthe constructor returns a rejected promise depending on `t`\\n\\nNow impose a Promise API functionality with **Promise.race()** which takes an array of resolved / rejected promises as parameters\\n**`Promise.race([ ])`**\\n\\nreturn the result \\n```\\nPromise.race([funcExec, funcRej])\\n```\\n\\n`funcExec` *is executed with a result before t milliseconds*\\n`funcRej` *is executed with an error after t milliseconds*\\n# Complexity\\n- **Time complexity :**   $$O(min(funcExecTime, funcRejTime))$$ ~ $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- **Space complexity :**  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\n```\\nPromise.race([funcExec, funcRej])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465010,
                "title": "double-arrow-function-simple-4-line-of-code",
                "content": "# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```\\n\\n# Explanation\\n\\nAn arrow function `var timeLimit = (fn, t) =>` returns another arrow function `(...args) =>` that returns a `Promise`.\\n\\nOn the promise handler, I created *timeout* and on the callback we reject the promise with the message. `setTimeout(() => reject(\"Time Limit Exceeded\"), t);`\\nIf the function doesn\\'t complete within the `t` time, then the callback of *setTimeout* will be called.\\n\\nOn the next line, I called `fn` function with the `...args`. I used spread sytanx. \\nIf the function get done successfully then the `resolve` function will be called. On error `reject` function will be called.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411903,
                "title": "accepted-javascript",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529118,
                "title": "java-script-solution-for-promise-time-limit-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to enforce a time limit on a given function. It wraps the function in a new function that returns a promise. If the wrapped function exceeds the specified time limit, it rejects the promise with a \"Time Limit Exceeded\" error.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The timeLimit function takes two parameters: fn, which is the function to be time-limited, and t, which is the time limit in milliseconds.\\n2. It returns an async function that accepts any number of arguments (...args) and returns a promise.\\n3. Within the returned async function, a new promise is created to handle the time limit.\\n4. A timeout is set using setTimeout, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n5. The wrapped function (fn) is invoked with the provided arguments using await.\\n6. If the wrapped function resolves successfully, the result is passed to resolve of the promise created in step 3.\\n7. If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n8. Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n9. The time-limited function returns the promise.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is dependent on the time complexity of the wrapped function (fn). The time limit is enforced by setting a timeout, which doesn\\'t affect the time complexity of the wrapped function itself. Therefore, the time complexity of the code can be considered the same as the time complexity of the wrapped function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is determined by the memory required to store the wrapped function and the promise. Since the wrapped function and promise are created within the returned function and not stored outside, the space complexity is minimal and mainly depends on the wrapped function and its internal operations.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531308,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is designed to make sure a function doesn\\'t take too long to execute by setting a time limit on it. It does this by wrapping the function in a new function that returns a promise. If the wrapped function takes too long to execute, the promise is rejected with an error message that says \"Time Limit Exceeded\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The timeLimit function takes two arguments: \"fn\", which is the function to be time-limited, and \"t\", which is the time limit in milliseconds.\\n- It returns a new asynchronous function that can take any number of arguments using the spread syntax (...args) and returns a promise.\\n- Inside the returned async function, a new promise is created to handle the time limit.\\n- A timeout is set using the setTimeout function, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n- The wrapped function (fn) is then called with the provided arguments using the \"await\" keyword.\\n- If the wrapped function resolves successfully, its result is passed to the \"resolve\" function of the promise created in step 3.\\n- If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n- Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n- Finally, the time-limited function returns the promise created in step 3.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438827,
                "title": "promise-and-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw that the return was an asynchronous function, my first thought was to return a promise from this function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first thing is, by using the setTimeout function we reject the promise when the given time (``` t ```) has expired, we store the timeout\\'s id for the purpose of clearing the memory. If the promise isn\\'t rejected with the timeout, it\\'s because the time it took to complete the promise of the given function was less than ```t```. Therefore, we simply handle it. Finally, we delete the id of the timeout to clear the memory.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "``` t ```\n```t```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414762,
                "title": "easy-simple-javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027403,
                "title": "promise-race-easy-js-solution",
                "content": "# Intuition\\nWe want to create a version of an asynchronous function that has a time limit. If the function completes within the time limit, it should return the result; otherwise, it should reject with a specific message.\\n\\n# Approach\\n1. We define a timeLimit function that takes two parameters: the asynchronous function fn and the time limit t.\\n\\n2. Inside the timeLimit function, we return an asynchronous function that can accept any number of arguments using the ...args syntax.\\n\\n3. We create a promise called myPromise that will resolve with the string \"success\" after a timeout of t milliseconds.\\n\\n4. We use Promise.race() to race two promises: myPromise and the execution of fn(...args).\\n\\n5. If myPromise wins the race (timeout is reached before fn completes), we return a new promise that rejects with the message \"Time Limit Exceeded.\"\\n\\n6. If fn wins the race (completes within the time limit), we return a new promise that resolves with the result obtained from fn.\\n\\n7. This code effectively provides a time-limited version of the input function fn.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879331,
                "title": "beats-98-20-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\n\\n**1.** First, we create a **new promise, timeoutPromise,** with setTimeout(). If this promise doesn\\'t resolve within the given time limit t, it will reject with the message \"Time Limit Exceeded\".\\n**2.** Call the function **fn(...args)**, which returns a promise.\\n**3.** Use **Promise.race()** to wait for either the result of the asynchronous function or the timeoutPromise to settle. Whichever promise settles first will determine the outcome of the timeLimit function.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683659,
                "title": "using-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing Promise.race, whichever promise (execution or timeout) resolves or rejects first will determine the outcome of the returned promise\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnside the returned asynchronous function, Promise.race is used to race between two promises:\\n\\nThe first promise is the execution of fn(...args). This represents the actual execution of the provided function with the given arguments.\\nThe second promise is created using setTimeout and will reject with the message \"Time Limit Exceeded\" after t milliseconds.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimit function itself is O(1) since it doesn\\'t involve any loops or recursion.\\nThe time complexity of the returned asynchronous function is determined by the time it takes to execute the provided function fn and the timeout duration t. It depends on the implementation of fn and may vary.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimit function is O(1) since it doesn\\'t create any additional data structures that grow with the input size.\\nThe space complexity of the returned asynchronous function depends on the space complexity of fn and the arguments args passed to it.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638379,
                "title": "using-promise-race-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnderstanding problem\\n- call **fn** with (...args)\\n- if **fn** takes more time than the given time(t)\\n    - reject with \"Time limit Exceeded\"  // code -1\\n- else\\n    - return promise response of fn(...args) // code -2\\n    - if **fn** rejects, reject the promise\\n    - if **fn** resolves, resolve the promise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst approach\\n - how to measure the **fn** running time?\\n - make countdown timer from **t** to **0** ?\\n\\n## buggy code (to understand, can skip)\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\\nHere we can measure the time of fn but it will await whatever time it takes. If given t=2s but fn takes 10s to execute then we can return result only after 10s. So by this we can understand we need fastest response whichever code( code-1 or code-2) completes first. Therefore make use of Promise.race.\\n\\nSecond approach\\n - use Promise.race\\n - [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) takes array of promises and returns a single promise whichever settles first. \\n\\n# Complexity\\n- Time complexity: Time complexity of fn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Space complexity of fn\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n## using async await\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n## Explaination\\nInside this function, we create a timeoutId variable to hold the timer ID.\\n\\nWe create a timeoutPromise using a setTimeout function(code-1), which will reject the promise with the \"Time Limit Exceeded\" message after the specified time t has passed.\\n\\nUsing Promise.race, we wait for either the fn(...args) promise or the timeoutPromise to settle. If fn(...args) completes before the timeout, the result is assigned, and the timeoutId is cleared. Otherwise, if the timeout is reached first, the timeoutPromise rejects with the \"Time Limit Exceeded\" message.\\n\\nIn the catch block, we clear the timeoutId and rethrow the error to maintain consistency with the rejected promise behavior.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529368,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407275,
                "title": "effective-js-solution-using-promise-race-with-explanation",
                "content": "\\nThe problem is asking us to write a function that takes an asynchronous function fn and a time limit t, and returns a new version of fn that will reject with the message \"Time Limit Exceeded\" if it takes longer than t milliseconds to complete.\\n\\n\\n# Approach\\nWe can use `Promise.race` to race the original promise returned by fn against a new promise that will reject after t milliseconds if fn hasn\\'t completed yet.\\n\\nIf fn completes before the timeout, the implementation will return the result of fn. However, if the timeout expires before fn completes, the implementation will reject with the message \"Time Limit Exceeded\".\\n\\nWe also keep track of the amount of time elapsed between the start of fn and the completion of the promise (using `Date.now()`), and throw an error if the elapsed time exceeds t. This ensures that our implementation accurately enforces the time limit even if fn takes slightly longer to complete than the specified time limit.\\n\\n# Complexity\\n\\n## Time complexity:\\n\\nThe time complexity of the timeLimited function depends on the time complexity of the fn function passed as an argument. In the worst case, if fn takes longer than the time limit t, the function will have a time complexity of **O(1)**, because it will reject the promise immediately after the timeout expires. If fn completes before the timeout, the time complexity will be the **same as fn**, because it is simply invoking fn with the provided arguments.\\n\\n## Space complexity:\\nThe space complexity of the timeLimited function is constant because the function creates only a few variables to keep track of the timeout and elapsed time, and none of these variables depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102368,
                "title": "easy-promise-solution-34-lines-javascript-beats-100",
                "content": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092683,
                "title": "the-timelimit-function-return-new-async-function-that-can-be-use-as-a-wrapper-around-other-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089503,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087877,
                "title": "promise-time-limit-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077698,
                "title": "the-most-simple-and-single-liner-solution-using-promise",
                "content": "# Intuition\\nConsider 2 methods/promise which ever executes first, return the first executed method.\\n# Approach\\nWe can make the use of Promise.race() to solve the problem. This is exactly what question tryies to make you learn.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061021,
                "title": "easiest-solution",
                "content": "# Approach\\nPromise.race is the best way to solve this. All you need are 2 promise objects, one is result of fn(...args) and second one is called from a timeout function that will wait for t mseconds.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041202,
                "title": "await-solution-detailed-explanation-of-javascript-event-loop-beginner-friendly",
                "content": "# Intuition\\nTo start off we know that if we want to have a time limit a `setTimeout` is needed. This `setTimeout` has to reject our promise within time `t`. Why did I know that we need a `Promise`? Well if the words resolve and reject are in the problem description it is then pretty obvious. \\n\\n# Approach\\nThe approach is quite standard: set a timeout, await the data, resolve it, and then reject it if time `t` has elapsed.\\n\\nAdditionally, there are a couple of important considerations. Simply leaving the `setTimeout` as is could potentially result in memory leaks, especially if an infinite loop were to run. Therefore, for each call to the `timeLimit` function, it is essential to ensure that the timeout is cleared.\\n\\nHowever, there is one aspect that might be confusing\\u2014how can `setTimeout` and `fn` seemingly run concurrently in JavaScript, given that it is a single-threaded language? Let me explain why they can.\\n\\nYou see, `fn` is an asynchronous function, and so \"is\" `setTimeout`. But why is `fn` able to execute when `setTimeout` is called first?\\n\\nIf we were to visualize the call stack, it might look like this: `fn` (called second) -> `setTimeout` (called first) -> next line to be executed. So how is it possible?\\n\\nWell that is because `setTimeout` works a little bit differently in the sense that when its called it will execute after `t` seconds and not in the asynchronous callstack (***Queue***) but rather in the normal one (***Stack***). So if `fn` is still calculating after `t` seconds the code in `setTimeout` will execute because it\\'s in the normal call stack and **set** the state or rejected. But what if `fn` finishes in time, what will happen to setTimeout? Well it would \"still\" execute but since we **set** the state of resolved before the time period of `t` to where that part of the call stack will not show up.\\n\\nIn summary, the order of execution may not match the order of function calls, and operations like `setTimeout` and `await` interact within the JavaScript event loop differently to determine the actual execution sequence. Clearing the `timeout` is essential to prevent potential memory leaks.\"\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because `...args` can have the size of 0 &rarr; n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036955,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035522,
                "title": "multiple-clean-solution-with-explanation",
                "content": "\\n\\n# Explanation\\nThe function is supposed to return a new promise with either resolve or reject based on the provided time. So declare a variable `timeOut` that returns `reject(\"Time Limit Exceeded\")` after the provided time excedeed. If this is executed prior to whatever is returned from `fn(...args)`, promise is resolved with rejected no matter what the returned value of fn is at the later time.\\n\\nOn the other hand, if `fn(...args)` completes executing prior `setTimeout`, promise is considered fulfilled with whatever is returned from it and ignores the reject of `timeOut`.\\n\\n# Why `clearTimeout(timeOut)` on `fn(...args)`?\\nIf the fn(...args) is executed prior to setTimeout, we do not want this setTimeout to execute at latter point even if this doesn\\'t bring any value. We want the process to cancel it once our purpose is met. \\n\\n\\n# Approach 1\\nUsing `.then`\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\\n\\n\\n# Approach 2\\nUsing `async await`\\n\\nNote: One of the minor difference is we need to wrap the callback fn `(resolve, reject) => {}` with `async` unlike in `Approach 1`. We could technically have `async` wrapped in `Approach 1` as well but it works without as well.\\n\\n# code\\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017259,
                "title": "promise-time-limit-with-ukrainian-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u0414\\u043B\\u044F \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u0446\\u0456\\u0454\\u0457 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0456 \\u044F \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u044E \\u043C\\u0435\\u0442\\u043E\\u0434 `race`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. \\u0421\\u043F\\u043E\\u0447\\u0430\\u0442\\u043A\\u0443 \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `originalPromise`, \\u044F\\u043A\\u0430 \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0454 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441, \\u044F\\u043A\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043F\\u0435\\u0432\\u043D\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0436\\u043E\\u043A \\u0447\\u0430\\u0441\\u0443.\\n2. \\u041F\\u043E\\u0442\\u0456\\u043C \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `timeLimiter`, \\u044F\\u043A\\u0430 \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u0434\\u043B\\u044F \\u043E\\u0431\\u043C\\u0435\\u0436\\u0435\\u043D\\u043D\\u044F \\u0447\\u0430\\u0441\\u0443 \\u0432\\u0438\\u043A\\u043E\\u043D\\u0430\\u043D\\u043D\\u044F \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443. \\u041D\\u0430\\u043F\\u0440\\u0438\\u043A\\u043B\\u0430\\u0434, \\u044F\\u043A\\u0449\\u043E \\u043F\\u0435\\u0440\\u0448\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 \\u043D\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u0442\\u044F\\u0433\\u043E\\u043C 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0432\\u0438\\u043A\\u043E\\u043D\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 `timeLimiter`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\'Time Limit Exceeded\\'.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014698,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011255,
                "title": "solution",
                "content": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007367,
                "title": "the-10x-approach-promise-race",
                "content": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3993804,
                "title": "easy-solution",
                "content": "# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984040,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982844,
                "title": "simple-solution-with-promise-race",
                "content": "# What is Promise.race\\n\\n`race()` is a static method of the Promise class that accepts an array of promises and returns the data of first completed promise irrespective of whether it\\'s accepted or rejected.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978684,
                "title": "2-very-simple-approaches",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978018,
                "title": "easy-solution-go-for-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950782,
                "title": "settimeout-with-async-await-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote that you need the try catch block to catch when the `reject()` by setTimeout\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944940,
                "title": "js-explanation-with-code",
                "content": "# Intuition\\nUsing Promise, settimeout.\\n\\n# Approach\\nSimplifying, we have to return a rejected promise if the fn function which returns a resolved result does not complete in the given t ms.\\n\\n- we make to promises one with the given functin fn which is a promise function,\\n- other promise is a rejected promise, which gets executed in t ms\\n- Now, we use Promsie.race to see which promise finishes earlier, Promise.race takes input as an array of promises.\\n\\n# Complexity\\n- Time complexity:\\nO(fn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932697,
                "title": "typescript-race-solution",
                "content": "# Approach\\nWe use *Promise.race* to solve a problem\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923944,
                "title": "extremely-simple-typescript-solution",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858244,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853008,
                "title": "2637-promise-time-limit",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830247,
                "title": "simple-soln-for-timeouts-using-promise-race",
                "content": "# Note \\nPromise.race() is a an method that represents the eventual completion of an very first asynchronous operation either it is fulfilled or rejected. (Already resolved promises are returned first and \\'non-promise\\' values).\\n\\n# Code\\n```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819491,
                "title": "this-type-of-qns-wants-you-to-control-the-state-of-the-promise",
                "content": "# Intuition\\nFor such qns never uses async await as they want you to suspend the promise for a time and run functions in parallel. \\nAsync await makes logic sequential and doesnt give you the explicit control over resolve and rejection of the promise, it always return a fullfilled promise once the function call terminates. \\nUsing native promise you can run function in parallel to timeout and then also be able to control which rejects and resolves. \\nIf a fn is faster than timeout  will be first fullfilled as either a resolve/reject otherwise timeout will be fullfilled as a rejection.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808985,
                "title": "typescript-o-max-t-n-1",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```\\n\\n# Complexity\\n`fn` is denoted as `T(n)`, where `n` is the size of the input.\\n\\n- Time complexity: $$O(max(T(n), 1))$$\\n- Space complexity: $$O(max(T(n), 1))$$",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805803,
                "title": "typescript-solution-4-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786119,
                "title": "super-easy-and-imp-concept-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the problem requires two distinct conditions to execute and compete with each other on the basis of time so it seems like a good place to use promise.race() .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine the two separate promises - the function acts inherently as a promise when it executes later on in the code.\\nIn the end we use promise.race to return whichever promise that executes first. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757854,
                "title": "ts-very-simple-implementation-promise",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703511,
                "title": "promise-race-concept",
                "content": "# Intuition\\nBoth of them are promise. Whichever gives outcome first will be run, may it be resolve or reject. \\nWe pass an iterable in the Promise race method.\\nIterable consists of all the promises to check for resolve/reject whichever completes first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694266,
                "title": "time-limit-problem-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678465,
                "title": "typescript-solution-using-promise-race",
                "content": "# Code\\n```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669060,
                "title": "delightful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652375,
                "title": "solution-using-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere there are 2 async process. whichever completes first we have to get its resp and clear the others. Promise.race([]) helps us with the promise handling for this use case.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple logic\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597609,
                "title": "js-solution-use-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597394,
                "title": "promise-time-limit",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593505,
                "title": "day-12-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578751,
                "title": "promise-race-method-javascript",
                "content": "Promise.race is a method that takes an array of promises as input and returns a new promise. It resolves or rejects and stops as soon as the first promise in the input array resolves or rejects.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555466,
                "title": "simple-and-easy-stepwise-explanation-to-understand-core-concept-as-well-as-code-written",
                "content": "Initially I found it difficult to understand the concept hence here is the simplified way of understanding.\\n1. setTimeout takes first parameter as function to execute after the time is completed and second parameter as time to wait before executing the function\\n2. fn(...args) starts executing asynchronously and the function in setTimeout is made to wait until time t gets completed\\n3. Before time out if function gets executed it is resolved else gives rejection\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548830,
                "title": "js-easy-solution-async-await-beats-100",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543465,
                "title": "javascript-promises-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537709,
                "title": "js-day-12-day-30-two-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    For this Problem i have findout two solutions\\n        1. Using simple promise Callback\\n        2. Using Promise.race (Js inbuilt static method)\\n    This example is about to demonstrate my solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Approach first (Using promise callback)\\n- Return a new Promise with 2 inputs; resolve to continue with our function if everything is fine and reject to stop execution if something is wrong.\\n- Inside the returned promise, declare a timeout  which is a timeout function that will be executed based on input t  \\n    1. If time surpasses t then we return a reject expression with the Time Limit Exceeded string and will be catched in the catch callback function.\\n    2. After timeout we return the eventual function with its parameters (fn(...args)), then we proceed to solution (.then(resolve)), catch any  errors (.catch(reject)) ).\\n\\n---\\n\\n2. Approach Second (Using Promise.race inbuilt method)\\n\\n - The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles(even Promise resolved or rejected)\\n    1. Return both inputs (function and the timelimit) inside Promise.race.\\n    2. So promise.race returns the first settled promise. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(t)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535424,
                "title": "promise-time-limit-problem",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534588,
                "title": "sol-n-javascript-typescript-easy",
                "content": "# Revised Approach\\n\\nTo create a time-limited version of an asynchronous function, we can make use of the Promise.race() method. We\\'ll create a new Promise that rejects with the string \"Time Limit Exceeded\" after the specified time limit. We\\'ll also invoke the original function and return the result of the Promise.race() method, which will either be the resolved value of the original function or the rejected value indicating the time limit was exceeded.\\n\\n# Complexity Analysis\\n\\nThe time complexity is dependent on the execution time of the original function. If the original function resolves or rejects within the time limit, the time complexity will be determined by the original function. Otherwise, it will be determined by the time limit.\\n\\nThe space complexity is constant as we\\'re not using any additional data structures that scale with the input size.\\n\\n# Code\\n\\n```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533947,
                "title": "javascript-code-only",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533778,
                "title": "beats-99-js-ts-promises-promise-time-limit-easy-solution-with-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/12bd08fc-832a-41a0-9840-1bd0f7c8af74_1684310493.7335916.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was thinking about using Promises, like everyone else. This example is about to demonstrate my solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Return a new `Promise` with 2 inputs; `resolve` to continue with our function if everything is fine and `reject` to stop execution if something is wrong.\\n    - Inside the returned promise, declare a `timeout` variable which is a timeout that will be executed based on time delay (if we have surpassed `t`) as we specify below.\\n    - If time surpasses `t` then we return a `reject` expression with the `Time Limit Exceeded` string.\\n    - After `timeout` we return the eventual function with its parameters (`fn(...a)`), then we proceed to solution (`.then(resolve)`), catch any potential errors (`.catch(reject)`) and finally clear `timeout` (`finally(() => clearTimeout(timeout))`).\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n`JavaScript`\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n`TypeScript`\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Feedback\\nI would appreciate your feedback and would like to receive your comments and perspectives regarding my approach. I would also enjoy suggestions about how to hone my DSA skills because I am very new to this sector and it\\'s challenging at first. Thanks a lot!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533059,
                "title": "using-promise-race-with-formatted-promise-s-responses",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532549,
                "title": "creating-a-time-limited-version-of-an-asynchronous-function",
                "content": "# Intuition\\nThe goal is to create a time-limited version of an asynchronous function, where if the function takes longer than the specified time limit to fulfill, it rejects with a \"Time Limit Exceeded\" message.\\n\\n# Approach\\n1. The timeLimited function takes two arguments: fn, the original asynchronous function, and t, the time limit in milliseconds.\\n2. It returns a new function that acts as the time-limited version of fn.\\n3. Inside the new function, the original function fn is called with the provided arguments using the spread operator (...args), and its promise is stored in the promise variable.\\n4. A new promise timeoutPromise is created using the setTimeout function. If the timeout expires before the original function completes, the promise is rejected with the message \"Time Limit Exceeded\".\\n5. The Promise.race method is used to wait for either the original function\\'s promise or the timeout promise to settle. The settled promise (either resolved or rejected) will be returned.\\n6. If the original function completes before the timeout, its promise will resolve first, and the overall promise will resolve with the result.\\n7. If the timeout expires before the original function completes, the timeout promise will reject first, and the overall promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532293,
                "title": "javascript-solution-with-return-await-new-promise",
                "content": "# Intuition\\nfllow the hints ;P\\n# Approach\\ncreate a new promise that you have to return and await. inside it start a timer that rejects when it is reached. Call the function and resolve/reject in the then/catch clause\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532006,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531960,
                "title": "simple-explanation-of-solution-javascript-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn simpler terms, the problem is asking for a function that takes another function, and a time limit as inputs. The function should return a new function that, when called, will execute the provided function with the given arguments. However, if the execution takes longer than the specified time limit, the new function should reject the promise instead of resolving it.\\n\\nTo achieve this, we need to utilize a concept called `Promise.race()`. This concept allows us to create a race between multiple promises, and the first promise to either resolve or reject will determine the outcome of the race. In our case, we want to race between the execution of the function and a timeout promise.\\n\\nSo, the goal is to create a time-limited version of a function that either returns the resolved value within the specified time or rejects the promise with a timeout message if it exceeds the time limit.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, the `timeLimit` function takes an asynchronous function `fn` and a time limit `t` in milliseconds as arguments. It returns a new function that uses Promise.race to race between the `fn() promise` and a `timeout promise` created using setTimeout.\\n\\nIf `fn()` fulfills before the timeout occurs, the timeLimited function resolves with the same value. However, if `fn()` takes longer than t milliseconds to `fulfill`, the timeout promise will `reject` with the message `Time Limit Exceeded`.\\n\\n---\\n\\n# Code\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531840,
                "title": "promise-pool-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531817,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531534,
                "title": "self-explanatory-two-solution-beginner-friendly",
                "content": "# Solution One - (Using Callback)\\n\\n# Code\\n\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\\n\\n# Solution Two - (Using async/await)\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531526,
                "title": "2637-promise-time-limit-javascript-day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531456,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531404,
                "title": "you-just-need-to-know-the-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just need to know the Promise.race():\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\n```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\\n\\n# Approach\\nwe have fn which is the promise function and we need another promise function To throw a race between two Promises.\\n\\n# Complexity\\n- Time complexity: O(t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531338,
                "title": "advanced-approach-with-concept-building-and-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem we should know a in-built function Promise.race().Here is some information about Promise.race().\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\nSo here we are just gonna create our new custom promise which will then be run against the given promise. So the winner will be executed.\\n\\n# Please upvote.\\u2705\\u261D\\uFE0F\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531293,
                "title": "java-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531291,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531245,
                "title": "beginner-s-js-solution",
                "content": "> DISCLAIMER: I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nPromise static method might be helpful \\uD83E\\uDD14\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F\\n\\n# Approach\\nIf we need to race between two promises which one reaches end state first and end state doesn\\'t matter than we can use Promise static method `Promise.race()`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/164dd62e-ac15-4f2c-8e02-6f19553df88f_1684249915.0756152.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531099,
                "title": "promise-time-limit-easy-solution-with-explanation",
                "content": "# Intuition\\nThe intuition behind this problem is to limit the execution time of a given function to a specific duration. If the function takes longer than the specified time limit, it should be terminated and return a predefined error message.\\n\\n# Approach\\nThe approach to solving this problem is to wrap the given function in another function that incorporates a timeout mechanism. The wrapper function will execute the original function and also create a timeout promise that rejects with an error message after the specified time limit. By using Promise.race, we can wait for either the original function to complete or the timeout to occur. Whichever promise resolves or rejects first will be the result of the overall wrapper function.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531083,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530980,
                "title": "2637-promise-time-limit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can create a time-limited version of an asynchronous function by using the Promise.race() method to race between the original function and a timeout promise. Here\\'s an example implementation in JavaScript:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the above code, the timeLimited function takes two arguments: fn (the original asynchronous function) and t (the time limit in milliseconds). It returns a new asynchronous function that wraps the original function.\\n\\nInside the new function, we create a timeout promise using setTimeout which will reject with the string \"Time Limit Exceeded\" after t milliseconds. Then, we use Promise.race() to race between the original function fn(...args) and the timeout promise. Whichever promise resolves or rejects first will be returned by Promise.race().\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimited function itself is constant, O(1), as it performs basic operations without any loops or recursive calls. However, the time complexity of executing the time-limited function depends on the time complexity of the original function fn.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimited function is also constant, O(1), as it only creates a few variables and promises regardless of the input size.\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530877,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530843,
                "title": "async-w-o-async",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530628,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530512,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530496,
                "title": "explanation-from-the-senior-developer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code defines a function called timeLimit that takes two parameters: fn and t. Here\\'s a step-by-step explanation of how it works:\\n\\nThe timeLimit function is defined using the const keyword.\\nIt is an asynchronous function, indicated by the async keyword before the function declaration.\\nThe function takes two parameters: fn and t.\\nfn is a function that will be executed.\\nt is the time limit in milliseconds.\\nInside the function, a new anonymous async function is defined using the async function(...args) syntax. This function takes any number of arguments using the rest parameter syntax (...args).\\nThe originalFnPromise variable is declared and assigned the result of calling the fn function with the provided arguments (fn(...args)). This means that the fn function is executed with the passed arguments, and it returns a promise representing the asynchronous operation.\\nThe timeoutPromise variable is declared and assigned a new promise.\\nInside the timeoutPromise, a setTimeout function is used to delay the execution of its callback by t milliseconds.\\nIn the callback function, the promise is rejected by calling the reject function with the message \\'Time Limit Exceeded\\'. This means that if the setTimeout callback is executed after t milliseconds, the timeoutPromise will be rejected with the given error message.\\nThe Promise.race function is used to race between two promises: originalFnPromise and timeoutPromise.\\nThe Promise.race function takes an array of promises and returns a new promise that resolves or rejects as soon as one of the promises in the array settles (either resolves or rejects).\\nIn this case, it races between originalFnPromise and timeoutPromise, so whichever promise settles first will determine the outcome of the returned promise.\\nThe final result of the timeLimit function is the promise returned by Promise.race.\\nIf originalFnPromise settles (either resolves or rejects) before the timeoutPromise, the result of originalFnPromise will be passed through.\\nIf the timeoutPromise settles (rejects) before originalFnPromise, it means the time limit has been exceeded, and the rejection reason will be \\'Time Limit Exceeded\\'.\\nIn summary, the timeLimit function creates a wrapper function that adds a time limit to the execution of another function (fn). The wrapped function can be called with any number of arguments, and it returns a promise that resolves with the result of fn if it completes within the specified time (t), or rejects with the error message \\'Time Limit Exceeded\\' if fn takes longer than the specified time.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530495,
                "title": "easiest-explanation-let-s-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Promise:**\\n    - A JavaScript object which holds the producing code and calls to the consuming code.\\n    - It ensures to produce a single value when required (in the future).\\n    - It\\'s main purpose is to track & manage multiple asynchronous operations\\n    - It has *4 Stages*:\\n        1. *Fulfilled*: Promise succeeded\\n        2. *Rejected*: Promise failed\\n        3. *Pending*: Promise is still pending\\n        4. *Settled*: Promise is either fulfilled or rejected\\n    - Syntax:\\n    `var promise = new Promise(function(resolve, reject){\\n     //do something\\n});`\\n\\n- **setTimeout**:\\n    - This method is used to execute a function, after waiting for a specified number of milliseconds.\\n    - Syntax: `setTimeout(function, milliseconds);` \\n\\n- **Promise.race():** \\n    - It is one of the promise concurrency methods.\\n    - It is used when we want the first asynchronous task to complete, but do not care about its eventual state (either succeed or fail).\\n    - *For Example:* Take it as a race, so which ever promise gets successfully completed (fulfills or rejects) early will get executed and rest promise\\'s results will not be displayed as an output.\\n    - Syntax: `Promise.race(iterable);`\\n\\n\\n# Code\\n``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```\\n\\n\\uD83D\\uDC47\\uD83C\\uDFFC ***Do Share your Opinion, by voting.***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530493,
                "title": "simple-easy-and-sort-solution",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530483,
                "title": "chatgpt-code-snippet",
                "content": "# Intuition\\n\\nThe problem requires us to implement a time-limited version of an asynchronous function. Given an asynchronous function `fn` and a time limit `t` in milliseconds, we need to create a new function that behaves like the original function `fn` but rejects the promise with a \"Time Limit Exceeded\" message if it takes longer than `t` milliseconds to fulfill.\\n\\nTo solve this problem, we can use a wrapper function that wraps the original function `fn` and adds a timeout mechanism to enforce the time limit. If the wrapped function exceeds the specified time limit, we reject the promise with the appropriate message. Otherwise, we resolve the promise with the result.\\n\\n# Approach\\n\\n1. We define the `timeLimit` function that takes `fn` (the original asynchronous function) and `t` (the time limit) as input.\\n2. Inside the `timeLimit` function, we return a new wrapper function that accepts any number of arguments (`...args`).\\n3. In the wrapper function, we create a new promise using the `Promise` constructor. This promise will be returned to the caller of the wrapper function.\\n4. Within the promise, we start a timeout using `setTimeout` and specify the time limit `t` as the duration. If the timeout expires before the wrapped function resolves, we reject the promise with the message \"Time Limit Exceeded\".\\n5. We then invoke the original function `fn` with the provided arguments (`fn(...args)`). If the original function resolves before the timeout, we clear the timeout using `clearTimeout` and resolve the wrapper function\\'s promise with the result.\\n6. If the original function rejects, we also clear the timeout and reject the wrapper function\\'s promise with the error.\\n7. Finally, we return the wrapper function, which serves as the time-limited version of the original function.\\n\\n# Complexity Analysis\\n\\n## Time Complexity:\\nThe time complexity of the `timeLimit` function is constant, O(1), as it performs a fixed number of operations regardless of the size of the input.\\n\\n## Space Complexity:\\nThe space complexity is also constant, O(1), as no additional data structures or recursive calls are used. The memory usage remains constant throughout the execution.\\n\\n# Code\\n\\n```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\\n\\n# Example Usage\\n\\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```\\n\\nIn this example, we create a time-limited version of an asynchronous function that waits for the specified time before resolving. The time limit is set to 100 milliseconds, but the function takes 150 milliseconds to complete. As a result, the promise is rejected with the \"Time Limit Exceeded\" message at t=100ms.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530316,
                "title": "easy-solution-3-line-code-75-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\nIt returns an asynchronous function that takes any number of arguments using the spread syntax ...args. This function executes the input function fn with the input arguments args and saves the result in a variable called s1.\\n\\nThe function also creates a new promise, s2, using the setTimeout method. This promise rejects with a message of \\'Time Limit Exceeded\\' if it is not resolved within t milliseconds.\\n\\nFinally, the function returns a promise that uses Promise.race to resolve with s1 if it is resolved before s2. Otherwise, it rejects with the message \\'Time Limit Exceeded\\'.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530225,
                "title": "js-promise-without-the-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously we have time window when we either resolve or fail.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. use setTimeout where our error is being sent to the promise \\n2. start our fn with args\\n3. when the timer gets resolved then we just fail\\n4. when the fn is complete  - we either resolve or fail depends when it succeeded\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530162,
                "title": "day-12-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530121,
                "title": "promise-settimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530038,
                "title": "javascript-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/822d61df-974d-44c0-8bb1-186b62dbbe65_1684225412.9392846.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530029,
                "title": "promise-time-limit-solution-with-promise-race-and-settimeout-js-day-12",
                "content": "# Intuition\\nTo solve this problem we need to take into account the time limit during which our function can be executed.\\nFor this we will use `setTimeout` inside a promise and the `Promise.race` method to get the first settled promise.\\n\\n# Approach\\nLets create a new Promise `timeLimitedPromise` to control execution time based on a time.\\nThen we should call it together with our function in `Promise.race`. \\n`race` method will return the first fulfilled promise and that will be our function call or time limit promise if time limit was exceeded.\\nP.s. We can omit errors as they are not specified in the problem requirements.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```\\n\\n\\nIf you like this solution and it looks simple and clean please vote. It would motivate me ;)\\n\\nThanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529962,
                "title": "promise-time-limit-easy-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529944,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529901,
                "title": "well-explained-clean-solution-promise-race",
                "content": "# Question Explanation\\nA promise \"fn\" is provided which is going to be resolved in some x time we dont know. We have to build a new Promise which should be rejected in \"t\" seconds.\\nIf the promise fn takes more than \"t\" seconds to be resolved then the newly created promise should reject by Time Limit Exceeded, else the resolved value of the \"fn\" promise should be returned.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAll we have to do is to check which Promise is executed first, is it \\n\"fn\" Promise or the newly created promise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This single promise is the promise which get resolved or rejected first.\\nHence, if \"fn\" promise gets resolved within t time, then is send the resolved value, else the newly created Prommise sends \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529870,
                "title": "day-12-js-simple-and-easy-promise-race-solution",
                "content": "# Intuition\\nThe Question states that we have given a fn function that returns a promise .\\n\\nNow we are also Given the timelimit t\\n\\nif the promise is resolved within t miliseconds then the promise with fn if returned\\n\\nElse the promise with **Time Limit Exceeded** is Returned\\n\\n# Approach\\nToday from one of the solution I learned about **Promise.race**\\n\\n1. **Promise.race** : it takes different promises and returns the promise that resolves faster\\n2. So We Are going to use this approach to solve the question\\n3. First we will have the promise returned by the function fn\\n\\n```\\n const ogPromise = fn(...args)\\n```\\n4. Now we will have a delayed promise with t time that rejects with message of \"TIME LIMIT EXCEEDED\"\\n5. We wil be using the setTimeout function for the delay of t miliseconds\\n\\n ```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\\n\\n6. Now we will be returning the promise with faster resolving time . i.e. if promise ogPromise is resolved first it is returned or if the promise with delayed time is resolved first then it is returned.\\n7. For this purpose we will be using Promise.rece with both promises as parameters\\n\\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nHere n will be the max time required to resolve a promise\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# **If You Like my solution Dont forget to upvote \\uD83D\\uDE07**\\n![upvote.jpg](https://assets.leetcode.com/users/images/2b07485f-1a17-487f-923c-66b3b03e39ca_1684221712.7089345.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n const ogPromise = fn(...args)\\n```\n```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529780,
                "title": "time-juggler-putting-async-functions-on-a-leash",
                "content": "# Intuition\\nThe timeLimit function takes an original asynchronous function fn and a time limit t as input. It returns a new asynchronous function that ensures the execution of fn is time-limited.\\n\\nInside the new function, a promise is created with a timeout using setTimeout to reject if the time limit is exceeded. fn is then invoked with the provided arguments, and its promise is chained to the timeout promise using .then() and .catch().\\n\\nIf fn resolves within the time limit, the new function resolves with the resolved value. If fn rejects or the time limit is exceeded, the new function rejects with the appropriate value or message.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe timeLimit function takes two parameters: fn, which represents the original asynchronous function, and t, which is the time limit in milliseconds.\\n\\nIt returns a new asynchronous function that accepts any number of arguments (...args).\\n\\nInside the new function, a promise is created using the Promise constructor. This promise is responsible for tracking the time limit.\\n\\nA setTimeout function is used to set up a timer. After the specified time t has elapsed, the timer triggers and the promise is rejected with the message \"Time Limit Exceeded\".\\n\\nThe original function fn is invoked with the provided arguments (fn(...args)). It returns a promise representing the execution of the original function.\\n\\nThe promise returned by fn(...args) is chained using .then() and .catch(). If the original function resolves within the time limit, the promise chain resolves with the resolved value. If it rejects, the promise chain rejects with the same error.\\n\\nThe promise chain is wrapped inside the outer promise created in step 3. This ensures that the overall promise returned by the new function resolves or rejects based on the execution of the original function and the time limit.\\n\\nThe new function returns the promise, allowing the caller to handle the result using .then() and .catch().\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529742,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529731,
                "title": "day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529707,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing wrapper function having two argument fn and t.Now check fot each condition and return result accordingly;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate wrapper function having two argument fn(original function) and t(time limit).If the timer expire before the promise resolved , reject the promise by the string \"Time Limit Exceeded\".If the function complete before the time limit ,resolve the promise by result.At last return promise from async function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(f(n));\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529678,
                "title": "promise-with-handlers",
                "content": "# Explanation\\n##### Given the time limit (t), the async function should :-\\n1. If function **(fn)** gets fullfilled (either *resolved* or *rejected* ) before time limit **(t)**, then either *resolve with the return value* or *reject with the error* related to the function (fn)\\n2. If function **(fn)** is *not fullfilled* before time limit **(t)**, then *reject* with the message (\"Time Limit Exceeded\") **at time (t)**;\\n\\n# Approach\\n1. Declare a **setTimeout** function to reject at time (t) if the function (fn) is not fullfilled before that time.\\n2. Invoke the function **(fn)** and attach handlers (**.then** -> to resolve with response and **.catch** to handle reject with errors). \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529574,
                "title": "easy-98-beaten-code-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529573,
                "title": "without-race-function-simple-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529569,
                "title": "1-liner",
                "content": "\\n```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529501,
                "title": "js-promise-race-time-57ms-75-space-42mb-47",
                "content": "# Approach\\nWe\\'ll try out the `Promise.race` method which automatically returns the first promise to finish,\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529439,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3529432,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529419,
                "title": "try-to-understand-the-problem",
                "content": "**Understand the problem -**\\n\\nGiven an asyncronous function `fn` and a time `t` in milliseconds, return a new time limited version of the input function.\\n\\nWe have to return a new time limited version of the input function. What is time limited function then ?\\n\\nA time limited function is a function that is identical to the original unless it takes longer than `t` milliseconds to fullfill. In that case, it will reject with \"Time Limit Exceeded\".  Note that it should reject with a string, not an Error.\\n\\nBreakdown the definition ->\\n\\nA time limited function is a function means we have to return a function (We have to return a time limited version of the input function)-> \\n\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\\ntime limited function is identical to the original function ->\\nmeans return function is also asyncronous\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\\nIf the input function take more time to resolve then it will reject with time limit exceeded otherwise resolve.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529397,
                "title": "js-solution-40-8-mb-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529377,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529369,
                "title": "day-12-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529362,
                "title": "javascript-simple-solution-using-promise-then-catch-and-finally",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529299,
                "title": "day-12-javascript-challenge",
                "content": "# Intuition\\nRace condition in Promise\\n\\n# Approach\\nUsed Promise.race for checking function call\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529294,
                "title": "time-limited-function-optimized-solution",
                "content": "# Intuition\\nThe problem requires us to implement a time-limited version of an asynchronous function. If the original function takes longer than the specified time limit to fulfill, it should reject with a \"Time Limit Exceeded\" message. Our task is to design an optimized solution that efficiently handles the time limit.\\n\\n# Approach\\nTo solve the problem, we can use the `Promise.race` method, which allows us to race two promises against each other: the result of the original function and a timer-based promise that rejects if the time limit is exceeded. By leveraging this approach, we can effectively control the execution time and handle the time limit with simplicity.\\n\\nIn the implementation, we define a higher-order function `timeLimit `that takes the original function `fn` and the time limit `t` as parameters. Inside this function, we return an asynchronous function that serves as the time-limited version of `fn`. Within this asynchronous function, we use `Promise.race` to race two promises: the result of `fn(...args)` and a new promise created using `setTimeout`. If the original function resolves or rejects before the timeout, the corresponding result or error will be returned. However, if the timeout occurs first, the promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Complexity\\n- Time complexity:\\n The time complexity of this solution depends on the execution time of the original function `fn` and the timeout duration `t`. In the worst case, if `fn` takes longer than `t` to complete, the time complexity will be determined by the longer of the two. Therefore, the time complexity can vary between **O(fn) and O(t)**, whichever is larger.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is relatively low and remains constant. It primarily depends on the memory required to store the original function `fn`, the timeout duration `t`, and the arguments passed to the time-limited function. Hence, the space complexity is **O(1)**, as it does not grow significantly with the input size or time limit.\\n\\nPlease note that the actual time complexity will depend on the characteristics of the original function and the specified time limit, and it may vary in different scenarios.\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529278,
                "title": "easy-solution-with-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529252,
                "title": "easy-javascript-solution",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529248,
                "title": "promise-time-limit-in-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529218,
                "title": "typescript-solution-with-promise-race",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529205,
                "title": "beats-98-74-with-promise-race",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n[Promise.race() documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\\n# Approach\\nThe timeLimit function takes in an asynchronous function and a time limit in milliseconds as its arguments. It returns a new function that has the same signature as the original function. This returned function is also an asynchronous function that can be called with any number of arguments.\\n\\nInside the returned function, a timeout promise is created using setTimeout with the specified time limit. If the original function takes longer than the time limit, the timeout promise will reject with the error message \\'Time Limit Exceeded\\'.\\n\\n** Then, Promise.race is used to race the original function with the timeout promise. The result of the race is stored in a variable called result.\\n\\nIf the original function resolves before the timeout promise, the timeout promise is still active and needs to be cleared using clearTimeout. Then, result is returned.\\n\\nIf the timeout promise rejects first, clearTimeout is called to cancel the timer, and the function rejects with the string \\'Time Limit Exceeded\\'. **\\n\\nOverall, the timeLimit function provides a simple and effective way to time-limit an asynchronous function and return a specific error message if the time limit is exceeded.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529142,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529093,
                "title": "typescript-solution",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529087,
                "title": "with-promice",
                "content": "# With Promice\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529082,
                "title": "new-promise-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529035,
                "title": "easy-way-solution",
                "content": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3528977,
                "title": "using-promise-race-30-days-of-lc-javascript-challenge-js-and-ts-solution-day-11",
                "content": "## Intuition\\n- We use Javascript\\'s Promise.race function to choose between the timeout and the async function `fn`\\n- We create a `new Promise` `timeLimit` represent the countdown of the time limit `t`\\n- We create another variable to store represent the countdown of our function `fnTime`\\n- We then Promise.race `timeLimit` and `fnTime` and return whichever completes first\\n\\n## Code\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528934,
                "title": "day-12-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528882,
                "title": "easy-algorithm-explained-javascript",
                "content": "# Intuition:\\nThe timeLimit function returns a higher-order function that takes two arguments: a function (fn) and a time limit (t), and returns a promise that wraps the execution of the fn function. If the fn function takes longer than t milliseconds to execute, the promise is rejected with a \"Time Limit Exceeded\" error message.\\n\\n# Algorithm:\\n\\n1. Define a timeLimit function that takes two arguments:\\n   - fn: the function to execute within the time limit\\n   - t: the time limit in milliseconds\\n2. The timeLimit function returns a new function that takes an arbitrary number of arguments using the spread syntax ...args.\\n3. Within the new function, return a Promise that wraps the execution of the fn function.\\n4. Set a timeout function that rejects the promise with a \"Time Limit Exceeded\" error message after t milliseconds.\\n5. Execute the fn function with the spread syntax ...args.\\n6. If the fn function resolves its promise, then resolve the outer promise with the same value.\\n7. If the fn function rejects its promise, then reject the outer promise with the same reason.\\n# Time complexity:\\nThe time complexity of the timeLimit function is O(1), as it performs a constant amount of work and does not depend on the size of the input.\\n\\n# Space complexity:\\nThe space complexity of the timeLimit function is O(1), as it uses a constant amount of memory and does not depend on the size of the input. However, the memory usage may increase depending on the implementation of the fn function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528870,
                "title": "promise-race-js-solution",
                "content": "# Promises\\n\\nA `Promise` is an object representing the `eventual completion / failure`  of an `asynchronous` operation and its resulting value\\n\\n`Promises` are helpful as it provides a way to handle `asynchronous` operations involving a sequences of steps, making us write cleaner, maintainable `asynchronous` code\\n\\n### Three State Promise\\n\\n`Promise` has three states:\\n\\n- `Pending` - This is the initial state of a `Promise` it is yet `fulfilled` nor `rejected`\\n- `Fulfilled` - The `Promise` has successfully been `resolved` . Thus, the `resulting value` is now available\\n- `Rejected` - The `Promises` has `failed`  . Thus, an `error` or the `rejected reasoning` is now available\\n\\nFrom `Pending` state `Promise` can transition to either being `Fulfilled` or  `Rejected` . Once, a Promise is `Fulfilled` or  `Rejected` , it will remain in either one of these states with its fixed value\\n\\n### Promise.race\\n\\nWe can use `Promise.race` to directly handle the resolved and rejected states of `promise` or `timeout` for our code. Whichever promise settles first will determine the returned promise state\\n\\n- If the `promise` resolves first, the `timeLimit function` will properly display the desired output value\\n- If the `timeout` resolves first, the `timeLimit function` will properly reject with `Time Limit Exceeded` message\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528848,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528829,
                "title": "promise-solution-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528819,
                "title": "video-blog-deep-dive",
                "content": "**DAY 12 - 30 Days of LC JS\\n2637. Promise Time Limit**\\n\\n**Easy Explanation:**\\nhttps://youtu.be/mKAAdiddkkw\\nhttps://code-crusaders.epizy.com/day-12-promise-time-limit/\\n\\n**Code**\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```\\n\\n**Happy Coding ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528786,
                "title": "day-12-javascript-typescript",
                "content": "# Code - JS\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n# TS\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521517,
                "title": "promise-time-limit-js-two-promise-60-ms",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515831,
                "title": "ts-promise-race-vs-returning-a-new-promise-52ms-42-8mb",
                "content": "This is a nice challenge, directly between the easier [sleep](https://leetcode.com/problems/sleep/) ([cracked here](https://leetcode.com/problems/sleep/solutions/3495914/)) and the more challenging [promise pool](https://leetcode.com/problems/promise-pool/) ([cracked here](https://leetcode.com/problems/promise-pool/solutions/3534230/)): definitely consider solving all of them to consolidate!\\n\\nFirst, let\\'s go with the easiest approach of having two promises running at the same time:\\n* `p1` will be our rejection promise, \"rejecting\" the planned message after `t` milliseconds;\\n* `p2` will be our resolve promise.\\n\\nWhat makes us solve this problem easily is the built-in `Promise` method [`.race()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race): unlike [`.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any) (click either to read the documentation on MDN), this will register both resolutions and rejections, giving us the result of the first one to happen, we want.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAnd since `async`-`await` is basically still syntactic sugar to get a promise effect, we don\\'t even need to wrap `p2` into a new one:\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAlternatively we can just `return` a new `Promise` with inside an instruction to time out in `t` milliseconds and reject, followed by the call to our function `fn` with the matching resolution and rejection clauses (We need the latter for the fourth case, that tests that explicitly):\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491503,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491055,
                "title": "typescript-3-lines",
                "content": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3488562,
                "title": "beginner-friendly-solution-detailed-explanation-about-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Promises is object that will return a resolve - if fulfilled or reject - if failed or rejected. \\n- In this case, we are given a function with a set TimeOut, and a `t` number variable.\\n- We need to test wheter if the function given can be finished within `t` time\\n- Basic approach will be comparing the `t` with the time in the function, however we do not have the variable of time in the function because it uses `...args` as props.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Ways to do it is to make a promise with a setTimeout, that will return a  reject if not fulfilled. \\n2. We will delete the promise (setTimeout) if the function  given are executed first, using `.finally(()=> clearTimeout(timeoutId));` executed if the given function runs first\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479510,
                "title": "typescript-simple-solution",
                "content": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453361,
                "title": "using-simple-then-and-catch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452980,
                "title": "javascript-ez-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444251,
                "title": "one-liner",
                "content": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441155,
                "title": "a-bit-better-memory-usage",
                "content": "# Intuition\\nI have to create a function which return first Promise resolve or reject  depends on time limit.\\n\\n# Approach\\nmy aproach is a little different from others. I moved **maxDelay** function to the top of **timeLimit** function because it creates only when we call first time **timelimit** function and we avoid creating **maxDelay** function each call.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440059,
                "title": "with-arrow-function-and-promise-race-code-is-more-readable",
                "content": "# Approach\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436392,
                "title": "10-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433043,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1896498,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1862654,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895484,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895738,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1965010,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895562,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1987420,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1941828,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895951,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            }
        ]
    },
    {
        "title": "Color the Triangle Red",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find the Prefix Common Array of Two Arrays",
        "question_content": "<p>You are given two <strong>0-indexed </strong>integer<strong> </strong>permutations <code>A</code> and <code>B</code> of length <code>n</code>.</p>\n\n<p>A <strong>prefix common array</strong> of <code>A</code> and <code>B</code> is an array <code>C</code> such that <code>C[i]</code> is equal to the count of numbers that are present at or before the index <code>i</code> in both <code>A</code> and <code>B</code>.</p>\n\n<p>Return <em>the <strong>prefix common array</strong> of </em><code>A</code><em> and </em><code>B</code>.</p>\n\n<p>A sequence of <code>n</code> integers is called a&nbsp;<strong>permutation</strong> if it contains all integers from <code>1</code> to <code>n</code> exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> A = [1,3,2,4], B = [3,1,2,4]\n<strong>Output:</strong> [0,2,3,4]\n<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> A = [2,3,1], B = [3,1,2]\n<strong>Output:</strong> [0,1,3]\n<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>\n\t<li><code>It is guaranteed that A and B are both a permutation of n integers.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3466676,
                "title": "frequency-array-solution-explained-o-n-time-and-space-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf it was easy for you to understand, make sure to upvote and help others!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466857,
                "title": "day-394-brute-optimal-one-pass-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to find an array C of the same length such that C[i] is the number of elements that are common to both A and B in the prefix of length i+1.\\n\\nWe can start by creating two hash maps indexStoreOfA and indexStoreOfB to store the indices of each element in A and B, respectively.\\n\\nWe then iterate over the prefix of A and count the number of elements that are common to both A and B up to that point. We do this by checking if the index of each element in A is less than or equal to i and the index of the same element in B is also less than or equal to i.\\n\\nWe store the count in an array answer and return it as the answer.\\n\\nSince we iterate over the prefix of A and perform constant time operations for each element, the time complexity of this solution is O(n^2), where n is the length of the arrays A and B.\\n\\n\\n# Code\\n```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\nTC: The time complexity of the code is O(n^2), where n is the length of the input arrays A and B. This is because the code iterates over each element in A and then iterates over each element in the prefix of A up to i, resulting in a nested loop. The time complexity of the nested loop is O(n^2) because the maximum number of iterations is n(n+1)/2. Therefore, the overall time complexity of the code is O(n^2).\\nSC: The space complexity of the code is O(n), where n is the length of the input\\n\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Optimal approach using frequency array \\nWe are given two integer permutations A and B of length n, and we need to find the prefix common array of A and B.\\n\\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\\n\\nTo find the prefix common array, we can iterate over both arrays A and B simultaneously and keep track of the frequency of each integer in both arrays using an array cnt.\\n\\nFor each element in A and B, we increment the corresponding element in cnt and check if its frequency becomes 2. If the frequency becomes 2, it means that the element is present in both A and B at or before the current index i.\\n\\nWe update the corresponding element in the result array res by adding 1 if the frequency of the element in A or B becomes 2, otherwise we add 0.\\n\\nFinally, we compute the prefix sum of the res array to get the prefix common array of A and B.\\n\\nThe time complexity of this approach is O(n), where n is the length of the input arrays A and B.\\n\\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```\\n# TC = o(n)\\n# SC = O(51)==>o(1)\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3466857/day-394-brute-optimal-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466962,
                "title": "java-c-python-one-pass",
                "content": "# **Explanation**\\nIterate A[i] and B[i],\\nand record if we have ever seen A[i] and B[i].\\n\\nThe second time we have seen the same value,\\nwe will increment the number `cur` of current common elements.\\n\\nFinall return the result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)` for output\\n<br>\\n\\n**Java**\\n```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466638,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466695,
                "title": "explained-using-bit-set-very-simple-easy-to-understand-solution",
                "content": "\\n<b> Up vote if you like the solution</b>\\n\\n# Approach\\nLets consider the case if the constraint is, value of array is less than 32 in place of 50\\nHere we can take two flags a & b. Keep setting its bits as per the array value we see on iteration.\\n    Then taking the bit wise AND of a & b, then counting the 1\\'s will give us no. of common elements till we traversed.\\n\\nSo if you understand above case, for constraint above we can take 4 variables a1, a2, b1 & b2 to store status of seen element.\\nHere a1 will store status of 1-31 & a2 store status of 32 to 50. Same is the case for b1 & b2.\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466640,
                "title": "counter",
                "content": "\\nWe go left-to-right and count the elements in both arrays.\\n\\nThe element `n` appears in both arrays when `cnt[n] == 2`.\\n\\n```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467191,
                "title": "c-python-o-n-solution-using-set",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466802,
                "title": "c-best-solution-one-time-traversal-o-n-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(3n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469401,
                "title": "java-find-the-prefix-common-array-of-two-arrays",
                "content": "\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467846,
                "title": "python-3-8-lines-w-example-t-m-132-ms-16-mb",
                "content": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```\\n[https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/submissions/941774522/](http://)\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497523,
                "title": "c-solution-using-set-one-pass-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the values are equal, then count the value as common one\\n- Else check if any of the value is present in the set or not, if present, the increase the count, else insert it into the set\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492154,
                "title": "c-maintain-a-count-array-easy-to-understand",
                "content": "# Intuition\\nSTORE COUNT OF ELEMENT OF ARRAT\\n\\n# Approach\\nMAINTAIN COUNT OF ELEMENT\\'S OF ARRAY\\nFOR 1st ARRAY INCREMENT COUNT FOR 2nd ARRAY DECREMENT COUNT OF ELEMENT\\n1st ARRAY: BEFORE INCREMENT COUNT CHECK ELEMENT COUNT < 0  OR NOTE\\n2nd ARRAY: BEFRE DECREMENT COUNT CHECK ELEMENT PREVIOSLY EXISTS OF NOT\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467605,
                "title": "python3-one-line",
                "content": "Loop over the intersection of arrays, increasing the length of the window, moving the index to the right at each iteration. An array composed of the length of the intersection of the arrays at each step will be the answer.\\n\\nFor example: (current step, set(A[:i + 1]), set(B[:i + 1]), length of intersection)\\ni = 0: {1}, {3} -> 0\\ni = 1: {1, 3}, {1, 3} -> 2\\ni = 2: {1, 2, 3}, {1, 2, 3} -> 3\\ni = 3: {1, 2, 3, 4}, {1, 2, 3, 4} -> 4\\n\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466741,
                "title": "easy-to-understand-map-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466729,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816661,
                "title": "python-3-two-set-solution",
                "content": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481901,
                "title": "easy-c-solution-single-loop-set",
                "content": "# Intuition\\nWe start filling elements in the set\\nset oonly has unique elements\\nAs we fill elements in set the size should increase by 2 every time but due to duplicacy it does not\\nso we just see how many should be there - how many there are. \\n\\n# Approach\\n2*(i+1)-st.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467133,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466858,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466822,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466722,
                "title": "c-solution-using-set",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466708,
                "title": "set-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466635,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950768,
                "title": "easy-c-solution-maps-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765411,
                "title": "java-hashset-easy-to-understand-o-n",
                "content": "# Intuition\\nBasically the problem statement says we need to check how many duplicate elements we got upto every index from both arrays A and B.\\n\\n# Approach\\nAs soon as the word duplicate strikes your mind.. you should think of HashSets. Maintain a HashSet to store unique elements and create array C denoting how many duplicates we have found upto that index in both arrays A and B.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603166,
                "title": "frequency-array-solution-o-n-time-and-space-faster-than-100-online-java-solution",
                "content": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3467151,
                "title": "simple-easy-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467075,
                "title": "java-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the number of common elements between the two given integer arrays for each prefix of the arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two ArrayList objects, al and bl, to store the elements of the input arrays a and b, respectively.\\n\\n1. Initialize the size of the input arrays to n and create an integer array ans of size n to store the number of common elements between a and b for each prefix of the arrays.\\n\\n1. Initialize a counter variable cnt to 0.\\n\\n1. Loop through each prefix of the input arrays using a for loop that iterates over the indices i from 0 to n-1.\\n\\n1. In each iteration, add the ith element of a and b to their respective ArrayLists.\\n\\n1. If the ith elements of a and b are equal, increment the counter variable cnt by 1.\\n\\n1. If the ith elements of a and b are not equal, check if bl (the ArrayList for b) contains the ith element of a. If true, increment the counter variable cnt by 1.\\n\\n1. Similarly, check if al (the ArrayList for a) contains the ith element of b. If true, increment the counter variable cnt by 1.\\n\\n1. Store the count of common elements cnt in the ith index of the ans array.\\n\\n1. After looping through all prefixes, return the ans array.\\n\\n**The overall approach of the code is to use two ArrayList objects to keep track of the elements of the input arrays and then iterate over each prefix of the arrays to count the number of common elements between them.**\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466861,
                "title": "java-simplest-solution-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466801,
                "title": "brute-c-solution",
                "content": "\\n# Approach\\nFor each index check in both arrays for the common elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987843,
                "title": "c-o-n-hashmap-o-n-time",
                "content": "# Intuition\\nBecause there are guaranteed to be the same permutation of n elements, if we can have the indices of each element from {1..n} available in O(1) time, we can quickly check in an iterative fashion if we want to add to the prefix or not.\\n\\n# Approach\\nCreate two index-maps for the two arrays. If the elements are the same, then we add 1 to our answer till before. Else, we may encounter an element in `A` which was present in `B` before, or the vice-versa. Hence, we need to add 1 based on both checks.\\n\\n# Complexity\\n- Time complexity:\\nO(n) : 3 loops.\\n\\n- Space complexity:\\nO(n) : 2 Hashmaps + 1 solution array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937672,
                "title": "2657-find-the-prefix-common-array-of-two-arrays-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721347,
                "title": "easy-solution-using-hashset-o-n-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718097,
                "title": "c-easiest-possible-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```\\n\\n**Time Complexity:**\\n\\nThe outer loop runs for A.size() iterations, and the inner loop iterates over the elements of the unordered map, which has a maximum size of 2 * A.size() (as it stores elements from both A and B). Therefore, the time complexity of the inner loop is O(A.size()).\\nSince the inner loop runs inside the outer loop, the overall time complexity of the function is O(A.size() * A.size()).\\n\\n**Space Complexity:**\\n\\nThe unordered map map1 can store up to 2 * A.size() elements, each containing a unique element from A and B. Therefore, the space complexity of the unordered map is O(A.size()).\\nThe ans vector has the same size as vector A, so its space complexity is also O(A.size()).\\nOverall, the space complexity of the function is O(A.size()).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710294,
                "title": "intuative-solution-beats-98-79-in-rn-98-42-in-m",
                "content": "# Intuition\\nlet,\\n\\ni = current number of elements being checked in the lists\\nn = length of list\\nk = number of common elements\\nd = Length of dictionary\\n\\nIf we store the all unique elements in a dictionary upto the **i**th length and let\\'s assume that no element is common between the two list, then the length of the dictionary will be i*2. However, now let us assume there are k number of common elements, then the length of the dictionary is:\\n$$d = i*2 - k$$\\n\\nor\\n\\n$$k = i*2 - d$$\\n\\nfor example:\\n    A = [1,3]\\n    B = [3,1]\\n    n = 2\\n    \\n    when i = 1\\n    d = 2 #dictionary = [1,3]\\n    k = 1 * 2 - 2 = 0\\n\\n    when i = 2\\n    d = 2 #dictionary = [1,3]\\n    k = 2 * 2 - 2 = 2\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n\\n- Space complexity:\\n    worst case, 2n from dictionary (tmp) and n from list (C):\\n    3n\\n    $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690673,
                "title": "swift-hash-table-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first, I wanted to solve through dictionaries, because I did not understand the task at all. Because a friend explained that whenever we iterate over an array we count everything to count all the same numbers. From 0 to i. This turned out to be very important!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI realized that a dictionary is not needed. We can use a set. Each time we insert numbers into a set, we know the difference in the number. Thus, we can understand how many identical numbers are already in the set.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688343,
                "title": "easy-lvl-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670342,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince each integer can only appear once in each array, if the integer is already in the set seen, then increment by one. Otherwise, add to the set. No concerns of duplicate counting due to distinct integers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) due to iteratring through entire array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) due to seen set that will contain every element.\\n# Code\\n```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668005,
                "title": "beats-100-optimal-o-n-hashing",
                "content": "# Approach\\nThe main logic of the code involves keeping track of the frequency of elements in both arrays using the `freq` array. By checking if an element has a frequency of 2, we can determine if it is common in both prefix arrays. The cumulative count `cumcount` is incremented whenever a new common element is found. Finally, the count array is populated with the cumulative `count` up to each index.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$, for storing `count[]`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### Please do upvote!! \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656547,
                "title": "extremely-easy-beginner-friendly-method-brute-force",
                "content": "\\n# Approach\\n                           Brute force method\\nTo solve the problem, we can iterate through the arrays A and B simultaneously and create a counter vector to store the elements encountered at each index. For each iteration, we sort the counter vector and count the number of duplicates. The count represents the number of common elements between the prefixes A[0:i+1] and B[0:i+1]. We store this count in the solution vector.\\n\\n# Complexity\\n- Time complexity: O(n^2 log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(min(n,m))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553756,
                "title": "solution-using-set-identities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are probably easier solutions, but here is a mathematical one that shows the power of set identities.\\n\\nWhat you want is to maintain the intersection between the sets of numbers in either array that you\\'ve already seen so far. The size of this intersection at each $$i$$ is equal to $$C[i]$$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $$sA$$ and $$sB$$ be sets containing elements from $$A$$ and $$B$$ respectively as we traverse the arrays. Let $$sA_i$$ and $$sB_i$$ be the two sets after iteration $$i$$. Then, in iteration $$i+1$$, the elements $$A[i+1]$$ and $$B[i+1]$$ come along. \\n\\nWe want $$C[i+1] = |sA_{i+1} \\\\cap sB_{i+1}| = |(sA_i \\\\cup \\\\{A[i]\\\\}) \\\\cap (sB_i \\\\cup \\\\{B[i]\\\\})|$$.\\n\\nNow, recall the following set identity: $$A \\\\cap (B \\\\cup C) = (A \\\\cap B) \\\\cup (A \\\\cap C)$$. Using this identity, $$C[i+1]$$ can be written as:\\n\\n$$C[i+1] = (sA_i \\\\cap sB_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap sB_i) \\\\cup (\\\\{B[i]\\\\} \\\\cap sA_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap \\\\{B[i]\\\\})$$.\\n\\nBut $$sA_i \\\\cap sB_i = C[i]$$ which we have from the previous iteration, and the other three terms in the union above can be obtained by simply query-ing $$sA$$ and $$sB$$ for the elements. One can do this using a set or a hashmap.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$ improvable to $$O(n)$$ with hashmap.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531758,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525437,
                "title": "two-solutions-to-find-the-prefix-common-array-of-two-arrays-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*OPTIMIZED APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4edc6144-1286-417b-a06b-f2c829b9d98e_1684120230.4192863.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522472,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519710,
                "title": "c-easy-solution-with-o-n-time-complexity",
                "content": "# Intuition\\nusing ordered map\\n\\n# Approach\\nusing map to count the common values so far.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507561,
                "title": "single-pass-easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to just need to count the seen element\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a unordered_set to store the count of distinct elements.\\nIf we know that how many elements are new then we can easily calculate the no.of same elsement\\'s.\\n\\nFirst run a loop from i=0 to i<n(size of array) Then we start inserting the each element of both the array\\'s in unordered_set.\\nif any of the element\\'s are same the it not pushed in unordered_set so in this way we can easily know the no. of diffrent element\\'s so far.\\nand then we If all the visited numbers are distinct the the size of unordered_set is  equal to (i+1)*2.\\nAnd by comparing the these two we can easily know the no. of same element\\'s.\\nand that is push_back to the Our answer array(C).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we run a loop i=0 to i<n \\nTime complexity:$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we use an unordered_set.\\nSpace complexity:$$O(n)$$\\n\\n# Code\\n`If you like the solution then please give an UP-VOTE`\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504846,
                "title": "c-simplest-using-only-one-set-only",
                "content": "##### Algorithm \\n* Check if A\\'s index is already present , cnt+1 if yes\\n* Insert A[i] to check with B\\n* Check B\\'s index is already present , cnt+1 if yes\\n* Insert B[i] for \\n\\nWe don\\'t need extra map for 2nd array as we are counting comman indexs from both arrays\\n\\n\\n\\n#####  C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n##### Complexity \\n* TC : O(n)\\n* SC : O(2n) : set + ans vector\\n\\n##### *Upvote if it helped you :)*\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488004,
                "title": "easy-c-solution-using-set",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481183,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475896,
                "title": "easy-understanding-o-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474066,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469415,
                "title": "find-the-prefix-common-array-of-two-arrays-c-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469162,
                "title": "c-solution",
                "content": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468672,
                "title": "hash-table-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468175,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/b5f5c2fb-9367-4e2c-b6eb-593965b340d3_1682824695.380845.png)\\n```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467669,
                "title": "c-code-using-vector",
                "content": "# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467653,
                "title": "simple-python-solution-using-intersection-between-the-sets",
                "content": "# Approach:\\nPerform intersection of both the sets after adding each new element in both the sets A and B\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467279,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467278,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467189,
                "title": "using-set-damn-easy-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3467150,
                "title": "simplest-solution-o-n-hashset-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467148,
                "title": "c-easy-approach-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467105,
                "title": "simple-easy-8-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466989,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466930,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we know that we have to get common elements till i, while iterating in array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow if we have 1 at position 0 in vector 1 and position 2 in vector 2, then 1 won\\'t be common till positon 2. \\n\\nSo we get choose maximum of indices for this number and store it in common array.\\n\\nNow we have a ans vector, to store the total new answers we have for a particular indice in the array.\\n\\nNow for our answer, we know from above example at positon 2 we will have this pair as answer. But all of the pairs behind are also the answer.\\n\\nSo to add those we run the last loop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466894,
                "title": "java-contest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466867,
                "title": "easy-java-solution-sets-o-n-approach",
                "content": "\\n# Approach\\nTake a Set and start putting values inside it one by one. Make a expected Size which would represent the exptected size of the set if all the elements are unique.\\n\\nNow, if there are unique elements, then set wouldn\\'t add those elements, and therefore subtracting exptectedSize with the set size would result to our answer\\n\\n- Time complexity:\\nSince we traverse the array, therefore complexity would be O(N)\\n# Code\\n```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466793,
                "title": "simple-code-using-mapping",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466783,
                "title": "only-map-tc-o-n-easy-understsnding-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466761,
                "title": "dart-solution-using-hashmaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466734,
                "title": "python-set-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466686,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466669,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466650,
                "title": "beginner-friendly-java-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097211,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097156,
                "title": "best-solution-using-brute-force-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095762,
                "title": "using-simple-map-c-o-n-beats-others",
                "content": "\\n\\nTIME COMPLEXITY IS O(N)\\nAFTER READING SOLUTION STILL FACE ANY DOUBTS-\\n1> COMMENT BELOW , I M ACTIVE ON LC \\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }\\n        else\\n        {\\n            //remain count be 0 bcz dono element alg h \\n            v.push_back(0);\\n        }\\n        // now bcz we have visited 0 index elements of a and b \\n        // now we will store them in map\\n        \\n        unordered_map<int,int>mp;  //key,frequency\\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        //now we must traverse for index 1 to n-1\\n        \\n        for(int i=1;i<A.size();i++)\\n        {\\n            //check if they are same \\n            if(A[i]==B[i])\\n            {\\n                count++;  //  for eg a[0],b[0] = 1,3 and a[1]b[1]= 1,1 toh 1 -> comes 3 times ..so common pair for both array will be only 1,1 so count+=1;\\n                \\n                v.push_back(count);\\n            }\\n            else\\n            {\\n                //agr same ni different ho tbh \\n                //check kro vo map mh h ya nhi , if exist in map then we can count them as repeated \\n                if(mp.find(A[i])!=mp.end())   \\n                {   count++; }\\n                if(mp.find(B[i])!=mp.end())\\n                {\\n                    count++;\\n                }\\n                  v.push_back(count);\\n                // add all visited elemnts in map \\n                mp[A[i]]++;\\n                mp[B[i]]++;\\n            }\\n        }\\n        \\n      return v;\\n        \\'\\'\\'\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4090389,
                "title": "o-n-solution-one-set-easely-can-be-rewriten-for-any-language",
                "content": "# Intuition\\nThere were too many overcomplicated solutions so I decided to try to use only one Set \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079189,
                "title": "solve-using-stack-o-n-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073550,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071263,
                "title": "a-simple-solution-with-two-sets-beats-94",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065710,
                "title": "super-easy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058591,
                "title": "java-simple-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053192,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046828,
                "title": "very-easy-c-code-beginner-friendly",
                "content": "# Intuition\\nThe intution is to use 2 hash maps to keep check of what integers we\\'ve encountered so far in both vectors A and B. As we pass through an integer we\\'ll add that number and it\\'s freq(1) in the maps.\\nthen in second loop we\\'ll iterate through maps. As it is given that size of both arrays will be equal, that means size of hashMaps will also be equal, till integers traversed. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045163,
                "title": "1ms-100-java-no-map",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically whenever a number has occured two times, that is in both arrays, we increment count.So, count keeps track of all the COMMON elements that have occured yet in both arrays. So in each iteration we put value of count in our ans array\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043985,
                "title": "short-one",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040536,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4039869,
                "title": "easy-python-solution-using-dict",
                "content": "# Approach\\nInitialize a dict to keep the counter. Loop through A and B if the element is there in the dict then increment the counter else add the key to the dict. Finally add the counter to the `output`.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038273,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023323,
                "title": "java-solution-using-hashmap-o-n-tc-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022377,
                "title": "map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022366,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017925,
                "title": "very-simple-approach-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015110,
                "title": "95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012750,
                "title": "using-hash-set-and-indexing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010121,
                "title": "very-simple-javascript-typescript-solution-set-array",
                "content": "\\n# Set\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\\n\\n\\n\\n# Array\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005931,
                "title": "my-solution-is-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004417,
                "title": "95-faster-and-i-think-smarter-one-too",
                "content": "# Intuition\\niterate from end to start. as every list in the end will have n number of matches i.e., len of list.\\n\\n# Approach\\nat the end there will be n no. of matches for sure. use a set and have the unique values in it. which will help in determining the number of matches.\\nEX:\\nA = [1,2,3,4] len of A = 4\\nB = [1,3,2,4]\\n\\nas said above last value of result will be 4. iterate from back. \\n\\n=> insert ***len(A)-len(uniqueset)*** to the start of the list to each iteration.\\nExplanation:\\n\\n:i=3 uniqueset = () result=[4] \\n    :i=2 uniqueset = (4) result = ( [len(A)-len(uniqueset),4] => [4-1,4] ) = [3,4]\\n    :i=1 uniqueset = (2,3,4) => result = [1,3,4]\\n    :i=0 uniqueset = (1,2,3,4) => result = [0,1,3,4]\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```\\n\\nThak you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997181,
                "title": "ruby-one-liner-250ms",
                "content": "# Intuition\\nCan be solved simply by counting the matches of one array slice with another array slice, although there may be a way of taking advantage of the consecutive integers in each permutation\\n\\n# Approach\\n`map` the `b.size` array using `count`, `include?` and front-inclusive slices `[..i]`\\n\\n# Code\\n```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3992166,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991127,
                "title": "o-n-time-complexity-o-1-space-complexity-solution",
                "content": "# Intuition\\ncreate a map to keep track of integers seen till now. \\n# Approach\\ncreate a map to keep track of integers seen till now. Since the number is till 50  and array of bool is enough to keep track to keep time complexity to minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988258,
                "title": "essay-c-solution-using-multiset-for-beginner",
                "content": "\\n\\nHere\\'s a simplified explanation of the code:\\n\\n**Intuition**:\\nThe code aims to find the number of common elements between two vectors while considering their positions.\\n\\n**Approach**:\\n1. Initialize two multisets, `m1` and `m2`, to store the elements from vectors `A` and `B`, respectively. Multisets are used because they allow duplicate elements and automatically sort them.\\n\\n2. Find the sizes of vectors `A` and `B` and store them in `n` and `m`, respectively.\\n\\n3. Determine the maximum length between `n` and `m` and store it in the variable `len`. This is used for iterating through both vectors.\\n\\n4. Create an empty vector `ans` to store the results.\\n\\n5. Iterate from `i` equals 0 to `len - 1`:\\n   - Insert the element at position `i` in vector `A` into `m1`.\\n   - Insert the element at position `i` in vector `B` into `m2`.\\n\\n6. Initialize a variable `count` to 0 to keep track of the number of common elements at each position.\\n\\n7. Iterate through the elements in `m1`:\\n   - For each element, check if it exists in `m2` by using `m2.find(ele)`. If it does, increment the `count` variable.\\n\\n8. After counting the common elements for the current position, push the `count` value into the `ans` vector.\\n\\n9. Continue this process for all positions in the vectors.\\n\\n10. Finally, return the `ans` vector containing the counts of common elements at each position.\\n\\n**Complexity**:\\n\\n- Time complexity: The code has a nested loop that iterates through both vectors, so the time complexity is O(max(n, m)), where n and m are the sizes of vectors A and B, respectively.\\n\\n- Space complexity: The code uses two multisets, `m1` and `m2`, to store the elements from vectors A and B. The space complexity is O(n + m), where n and m are the sizes of vectors A and B, respectively, because the multisets store the unique elements from each vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988058,
                "title": "two-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982412,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975706,
                "title": "java-one-pass",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974183,
                "title": "elixir-simple-solution-using-mapset",
                "content": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973931,
                "title": "java-beginner-friendly-approach-using-arrays-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the occurances and carry forwarding the current count and saving space by modifying exisiting input Array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971811,
                "title": "easy-soln-for-beginners-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969337,
                "title": "beats-99",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958656,
                "title": "java-observation-hashset-solution-se",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958071,
                "title": "c-unordered-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955548,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946368,
                "title": "java-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942129,
                "title": "easy-c-solution-o-n-approach-beats-94",
                "content": "# Intuition\\nUse a hashmap to store the frequency of each element.\\n\\n# Approach\\n- If A[i] and B[i] have frequency as 2 and both of them are equal then add only 1 to count.\\n- If both of them are not equal then separately check whether their frequency is 2 or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941030,
                "title": "o-n-time-o-n-space-c-solution",
                "content": "# Intuition\\nFew observations:\\n1. All 3 vectors (A, B, Resulting) must be of the same size.\\n2. On each iteration we need to determine how much common elements A and B have.\\n3. Thus this common number may only grow or stay the same.\\n4. If it grows it only can grow by 1 or 2.\\n\\n# Approach\\nWe traverse both arrays at the same time comparing its values.\\nWe use hash to store the \"not yet matching\" elements encountered in it.\\nIf elements match we increase common counter by 1.\\nIf they dont - we check if the elements are already in the hash, increasing common counter by 1 with each match, or adding \"not yet matched\" element to the hash.\\nOn each iteration set the resulting value for this position in the array to current common counter.\\n\\n \\n# Complexity\\n- Time complexity:\\nO(N) since we traverse all sets exactly 1 time and hash usage is limited to add\\\\search methods which both are O(1).\\n\\n- Space complexity:\\nO(N) - in the worst case we will end up having a hash with all the values from A and from B in it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940890,
                "title": "jai-shree-ram-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926209,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920725,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920463,
                "title": "easy-solution-using-vector-unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913127,
                "title": "simple-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inialize two hashmap\\n2. Traverse each element\\n3. If Both elements are same then increement as 1\\n4. other wise verify the elements in hasmaps\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911665,
                "title": "easy-readable-solution-12-lines-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911071,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have a map to store if the number appeared in both array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910580,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908607,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900971,
                "title": "c-easy-solution-with-unordered-maps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898891,
                "title": "python-simple-python-solution-prefix-sum",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3896199,
                "title": "beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892907,
                "title": "o-n-solution-using-single-for-loop",
                "content": "# Intuition\\n1. We know that the possible numbers are between 1,n.\\n2. We know that each number can only occur once in each array.\\n\\n# Approach\\nWe setup a hashtable to keep track if a number has occured before in either array. \\n\\nStep 1:\\nIterate through both arrays simoltaneously. If the number at the current index is the same in both arrays increment the counter.\\n\\nStep 2:\\nIf the numbers at the current index are not the same, we check our hashtable to see if the number occured before.\\n\\nStep 3:\\nIf the number occured previously, we increment the counter.\\nIf it did not occur previously, we update the hashtable.\\n\\nStep 4:\\nAppend the current state of the counter to our results array at the end of each itteration. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890396,
                "title": "easiest-python-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884494,
                "title": "easy-to-understand-solution-time-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878964,
                "title": "python-one-pass-set-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873944,
                "title": "systumm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873414,
                "title": "beats-98-24-of-users-with-c-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859960,
                "title": "beginner-friendly-easy-hashtable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859005,
                "title": "c-easy-solution-using-both-map-and-set",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854667,
                "title": "c-hash-table-time-o-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853201,
                "title": "easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850395,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848110,
                "title": "worst-complexities-but-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845955,
                "title": "c-solution-hashset-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845401,
                "title": "simple-implementation-using-dictionary",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843482,
                "title": "simple-c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841827,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841773,
                "title": "c-beats-95-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840438,
                "title": "python-linear-in-time-and-space-simply-use-two-sets",
                "content": "# Intuition\\nUse Python\\'s set\\n\\n# Approach\\nIterate from the beginning. At each step add element from A to one set and element B to another set. The result at this point is size of the intersection of the sets.\\n\\n# Complexity\\n- Time complexity: O(N) : each set operation is constant time\\n\\n- Space complexity: O(N) : sets store every number once\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832737,
                "title": "easy-to-understand-c-solution-using-set-using-map-beats-97-50",
                "content": "\\n\\n# Code\\n```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code\\n\\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829437,
                "title": "easy-kotlin-solution-with-just-one-set",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827242,
                "title": "simple-code-one-pass-using-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826923,
                "title": "2657-find-the-prefix-common-array-of-two-arrays",
                "content": "# Intuition\\n<!-- using Hashset we can determine the common elements of both the arrays a and b at specified index -->\\n\\n# Approach\\n<!-- using Hashset and two for loops -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- )(n^2)-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877149,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880977,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880320,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880083,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1877672,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1876990,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Adjacent Elements With the Same Color",
        "question_content": "<p>There is a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>. Initially, all elements are <strong>uncolored </strong>(has a value of <code>0</code>).</p>\n\n<p>You are given a 2D integer array <code>queries</code> where <code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>.</p>\n\n<p>For each query, you color the index <code>index<sub>i</sub></code> with the color <code>color<sub>i</sub></code> in the array <code>nums</code>.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> of the same length as </em><code>queries</code><em> where </em><code>answer[i]</code><em> is the number of adjacent elements with the same color <strong>after</strong> the </em><code>i<sup>th</sup></code><em> query</em>.</p>\n\n<p>More formally, <code>answer[i]</code> is the number of indices <code>j</code>, such that <code>0 &lt;= j &lt; n - 1</code> and <code>nums[j] == nums[j + 1]</code> and <code>nums[j] != 0</code> after the <code>i<sup>th</sup></code> query.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n<strong>Output:</strong> [0,1,1,0,2]\n<strong>Explanation:</strong> Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.\n- After the 1<sup>st</sup> query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.\n- After the 2<sup>nd</sup> query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.\n- After the 3<sup>rd</sup>&nbsp;query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.\n- After the 4<sup>th</sup>&nbsp;query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.\n- After the 5<sup>th</sup>&nbsp;query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, queries = [[0,100000]]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> Initially array nums = [0], where 0 denotes uncolored elements of the array.\n- After the 1<sup>st</sup> query nums = [100000]. The count of adjacent elements with the same color is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length&nbsp;== 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494883,
                "title": "c-java-python3-simple-counting",
                "content": "\\n\\n# Intuition\\nCreate the nums array and track the count of adjacent numbers that are same\\n\\n# Approach\\n* Create the array `nums`\\n* For each query first check if the values at `index - 1` or `index + 1` are the same as `nums[index]`. If any of them are equal, **decrement** the counter\\n* Update the value of `nums[index]`\\n* Now check if values at `index - 1` or `index + 1` are the same as `nums[index]`. If any of them are equal, **increment** the counter\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef colorTheArray(self, n: int, queries):\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index - 1] if index > 0 else 0, nums[index + 1] if index < n-1 else 0\\n        if nums[index] and nums[index] == pre: c -= 1\\n        if nums[index] and nums[index] == nex: c -= 1\\n        nums[index] = color\\n        if nums[index] == pre: c += 1\\n        if nums[index] == nex: c += 1\\n        yield c\\n```\\n\\n**C++**:\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] && nums[index] == pre) c--;\\n        if (nums[index] && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```\\n\\n**Java**:\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n    int[] nums = new int[n], result = new int[queries.length];\\n    int c = 0;\\n\\n    for (int i = 0; i < queries.length; i++) {\\n        int index = queries[i][0], color = queries[i][1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] != 0 && nums[index] == pre) c--;\\n        if (nums[index] != 0 && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result[i] = c;\\n    }\\n    return result;\\n}\\n```\\n\\n## Shorter Version\\n**Python3**:\\n```\\ndef colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index-1] if index > 0 else 0, nums[index+1] if index < n-1 else 0\\n        if nums[index]: c -= (nums[index] == pre) + (nums[index] == nex)\\n        nums[index] = color\\n        c += (nums[index] == pre) + (nums[index] == nex)\\n        yield c\\n```\\n\\n**C++**:\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n        if (nums[index]) c -= (nums[index] == pre) + (nums[index] == nex);\\n        nums[index] = color;\\n        c += (nums[index] == pre) + (nums[index] == nex);\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef colorTheArray(self, n: int, queries):\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index - 1] if index > 0 else 0, nums[index + 1] if index < n-1 else 0\\n        if nums[index] and nums[index] == pre: c -= 1\\n        if nums[index] and nums[index] == nex: c -= 1\\n        nums[index] = color\\n        if nums[index] == pre: c += 1\\n        if nums[index] == nex: c += 1\\n        yield c\\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] && nums[index] == pre) c--;\\n        if (nums[index] && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n    int[] nums = new int[n], result = new int[queries.length];\\n    int c = 0;\\n\\n    for (int i = 0; i < queries.length; i++) {\\n        int index = queries[i][0], color = queries[i][1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] != 0 && nums[index] == pre) c--;\\n        if (nums[index] != 0 && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result[i] = c;\\n    }\\n    return result;\\n}\\n```\n```\\ndef colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index-1] if index > 0 else 0, nums[index+1] if index < n-1 else 0\\n        if nums[index]: c -= (nums[index] == pre) + (nums[index] == nex)\\n        nums[index] = color\\n        c += (nums[index] == pre) + (nums[index] == nex)\\n        yield c\\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n        if (nums[index]) c -= (nums[index] == pre) + (nums[index] == nex);\\n        nums[index] = color;\\n        c += (nums[index] == pre) + (nums[index] == nex);\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494948,
                "title": "explained-very-simple-and-easy-to-understand",
                "content": "<b> Up vote if you like the solution </b>\\n# Intution \\nWhen we add one number to nums then only impact of this to left & right adacent values. Like it can have same adjacent to the previous or to the next one only. So we have to check the status of adjacent equality before updating the index and after updating the index.\\n\\n# Approach\\n\\nSimply traverse the querries and keep subtracting the previously same adjacent count \\nand then add the newly formed same adjacent count.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494899,
                "title": "centinel",
                "content": "We use a number line (`c`), and track the number of adjacent elements (`adj`).\\n\\nTo make it simple, the number line is shifted/padded on the left and right, so that `i - 1` and `i + 1` positions are always valid.\\n\\n**C++**\\n```cpp\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    int c[100003] = {}, adj = 0;\\n    vector<int> res;\\n    for (const auto &q : queries) {\\n        int i = q[0] + 1, color_i = q[1];\\n        if (c[i])\\n            adj -= (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        c[i] = color_i;\\n        adj += (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        res.push_back(adj);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    int c[100003] = {}, adj = 0;\\n    vector<int> res;\\n    for (const auto &q : queries) {\\n        int i = q[0] + 1, color_i = q[1];\\n        if (c[i])\\n            adj -= (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        c[i] = color_i;\\n        adj += (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        res.push_back(adj);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495129,
                "title": "c-easy-to-understand-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans(queries.size(), 0);\\n        vector<int>nums(n, 0);\\n        int count = 0;\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int index = queries[i][0];\\n            int newCol = queries[i][1];\\n            \\n            int prevCol = (index - 1 < 0)? 0 : nums[index - 1];\\n            int nextCol = (index + 1 >= n)? 0 : nums[index + 1];\\n            int oldCol = nums[index];\\n            \\n            nums[index] = newCol;\\n            //===========================================================\\n            //CHECK CONTRIBUTIONS BEFORE COLORING WITH NEW COLOR\\n            if (oldCol != 0 && oldCol == prevCol) count--;\\n            if (oldCol != 0 && oldCol == nextCol) count--;\\n            //===============================================================\\n            //CHECK CONTRIBUTIONS AFTER COLORING WITH NEW COLOR\\n            if (newCol == prevCol) count++;\\n            if (newCol == nextCol) count++;\\n            //====================================================================\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans(queries.size(), 0);\\n        vector<int>nums(n, 0);\\n        int count = 0;\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int index = queries[i][0];\\n            int newCol = queries[i][1];\\n            \\n            int prevCol = (index - 1 < 0)? 0 : nums[index - 1];\\n            int nextCol = (index + 1 >= n)? 0 : nums[index + 1];\\n            int oldCol = nums[index];\\n            \\n            nums[index] = newCol;\\n            //===========================================================\\n            //CHECK CONTRIBUTIONS BEFORE COLORING WITH NEW COLOR\\n            if (oldCol != 0 && oldCol == prevCol) count--;\\n            if (oldCol != 0 && oldCol == nextCol) count--;\\n            //===============================================================\\n            //CHECK CONTRIBUTIONS AFTER COLORING WITH NEW COLOR\\n            if (newCol == prevCol) count++;\\n            if (newCol == nextCol) count++;\\n            //====================================================================\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495439,
                "title": "110-understandable-simple-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n**Just think when new element is added to nums then there will be two case** *(nums is our final array of length n that has intially all values is equal to 0)* :\\n\\n---\\n\\n\\ncase 1: **nums[i]==0** (where 0<=i<n) then check its both side  \\n\\n    if new element that we want to insert in nums[i] is equal to nums[i-1]    then do cnt++ (bcoz it will contribute in our answer).\\n    if new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.\\n\\n---\\n\\n\\n\\ncase 2 : **nums[i]!=0** (where 0<=i<n) then there will be 4 conditions \\n```\\n\\nif element that is already present in nums[i] is equal to nums[i-1] then we have to do cnt-- (bcoz this element is no more contributing after inserting new element)\\nif element that is already present in nums[i] is equal to nums[i+1] then we have to do again cnt-- (bcoz this element is no more contributing after inserting new element)\\nif new element that we want to insert  in nums[i] is equal to nums[i-1]   then do cnt++.\\nif new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.`\\n```\\n\\n##### NOTE : please see the code !  you will understand 110%\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n*please upvote if you like it!*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> ans(q.size());\\n        vector<int> nums(n,0);\\n        \\n        int cnt=0;\\n        ans[0]=0;\\n        nums[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(nums[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n                \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]]==nums[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && nums[q[i][0]]==nums[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n            }\\n        }\\n        return ans;                                 \\n                                        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser",
                    "Counting"
                ],
                "code": "```\\n\\nif element that is already present in nums[i] is equal to nums[i-1] then we have to do cnt-- (bcoz this element is no more contributing after inserting new element)\\nif element that is already present in nums[i] is equal to nums[i+1] then we have to do again cnt-- (bcoz this element is no more contributing after inserting new element)\\nif new element that we want to insert  in nums[i] is equal to nums[i-1]   then do cnt++.\\nif new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.`\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> ans(q.size());\\n        vector<int> nums(n,0);\\n        \\n        int cnt=0;\\n        ans[0]=0;\\n        nums[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(nums[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n                \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]]==nums[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && nums[q[i][0]]==nums[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n            }\\n        }\\n        return ans;                                 \\n                                        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497262,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$, m-> length of queries array\\n\\n- Space complexity: $$O(n + m)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495014,
                "title": "maintain-the-colors-directly",
                "content": "# Intuition\\nSimply count.\\n\\n# Approach\\nWhen change the color of one cell, consider the neighbors, update the counts.\\n\\n# Complexity\\n- Time complexity:\\nO(1) per operation.\\n\\n- Space complexity:\\nO(n) in total.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n), r;\\n        int num = 0;\\n        for (const auto& q : queries) {\\n            if (v[q[0]]) {\\n                if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                    --num;\\n                }\\n                if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                    --num;\\n                }\\n            }\\n            v[q[0]] = q[1];\\n            if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            r.push_back(num);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n), r;\\n        int num = 0;\\n        for (const auto& q : queries) {\\n            if (v[q[0]]) {\\n                if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                    --num;\\n                }\\n                if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                    --num;\\n                }\\n            }\\n            v[q[0]] = q[1];\\n            if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            r.push_back(num);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496243,
                "title": "just-store-the-pairs-whose-color-matches-easy-to-understand-approach-clean-code",
                "content": "\\n# Complexity\\n- Time complexity: O(q log q), where q is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fn1(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x - 1, x};\\n        if (v[x] == v[x - 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    void fn2(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x, x + 1};\\n        if (v[x] == v[x + 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        if(n == 1){\\n            vector<int> ans;\\n            for(auto i: queries) ans.push_back(0);\\n            return ans;\\n        }\\n        vector<int> v(n, 0);\\n        vector<int> ans;\\n        set<pair<int,int>> s;\\n        for(auto i: queries){\\n            int x = i[0], y = i[1];\\n            v[x] = y;\\n            if (x == n - 1) fn1(v, s, x);\\n            else if (x == 0) fn2(v, s, x);\\n            else {\\n                fn1(v, s, x);\\n                fn2(v, s, x);\\n            }\\n            ans.push_back(s.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fn1(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x - 1, x};\\n        if (v[x] == v[x - 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    void fn2(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x, x + 1};\\n        if (v[x] == v[x + 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        if(n == 1){\\n            vector<int> ans;\\n            for(auto i: queries) ans.push_back(0);\\n            return ans;\\n        }\\n        vector<int> v(n, 0);\\n        vector<int> ans;\\n        set<pair<int,int>> s;\\n        for(auto i: queries){\\n            int x = i[0], y = i[1];\\n            v[x] = y;\\n            if (x == n - 1) fn1(v, s, x);\\n            else if (x == 0) fn2(v, s, x);\\n            else {\\n                fn1(v, s, x);\\n                fn2(v, s, x);\\n            }\\n            ans.push_back(s.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495191,
                "title": "too-lazy-to-explain",
                "content": "# Intuition\\nAs given in hints just focus on neighbours of the element whose color you are changing \\n\\n# Approach\\n<!-- before changing color of an index  , check if it contributes i.e. have adjacents with same color , then you need to decrease your current answer.  -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] arr = new int[n]; \\n        \\n        int[] ans = new int[queries.length]; \\n        \\n        int adj = 0; \\n        \\n        for(int i = 0; i < queries.length; i++ ){\\n            \\n            int index = queries[i][0]; \\n            int color = queries[i][1]; \\n            \\n            if( color == arr[index] ){\\n                ans[i] = adj; \\n                continue; \\n            }\\n            \\n            int count = 0; \\n            \\n            if( index != 0 &&  arr[index] != 0 && arr[index-1] == arr[index] ) count++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) count++; \\n            \\n            arr[index] = color; \\n            \\n            adj -= count;\\n            \\n             if( index != 0 && arr[index] != 0 && arr[index-1] == arr[index] ) adj++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) adj++; \\n            \\n            ans[i] = adj; \\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] arr = new int[n]; \\n        \\n        int[] ans = new int[queries.length]; \\n        \\n        int adj = 0; \\n        \\n        for(int i = 0; i < queries.length; i++ ){\\n            \\n            int index = queries[i][0]; \\n            int color = queries[i][1]; \\n            \\n            if( color == arr[index] ){\\n                ans[i] = adj; \\n                continue; \\n            }\\n            \\n            int count = 0; \\n            \\n            if( index != 0 &&  arr[index] != 0 && arr[index-1] == arr[index] ) count++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) count++; \\n            \\n            arr[index] = color; \\n            \\n            adj -= count;\\n            \\n             if( index != 0 && arr[index] != 0 && arr[index-1] == arr[index] ) adj++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) adj++; \\n            \\n            ans[i] = adj; \\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498620,
                "title": "python-3-7-lines-dict-t-m-2675-ms-58-mb",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        ans, d, cnt = [], defaultdict(int), 0\\n\\n        for i, color in queries:\\n\\n            if d[i]: cnt-= (d[i-1] == d[i])+(d[i+1] == d[i])\\n            d[i] = color\\n            if d[i]: cnt+= (d[i-1] == d[i])+(d[i+1] == d[i])\\n\\n            ans.append(cnt)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/submissions/946358857/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        ans, d, cnt = [], defaultdict(int), 0\\n\\n        for i, color in queries:\\n\\n            if d[i]: cnt-= (d[i-1] == d[i])+(d[i+1] == d[i])\\n            d[i] = color\\n            if d[i]: cnt+= (d[i-1] == d[i])+(d[i+1] == d[i])\\n\\n            ans.append(cnt)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496169,
                "title": "image-explanation-easy-c-solution",
                "content": "# Intuition\\nCheck for equality of nums[i] with nums[i-1] & nums[i+1] both.\\n**NOTE:** `Check if nums[i] is already present.` \\n\\n# Approach\\n\\n![Lc_page-0001.jpg](https://assets.leetcode.com/users/images/422ba2de-ae07-406a-b6d8-88622100dfb6_1683450011.98934.jpeg)\\n\\n**STEP 1:** If nums[ind] is already present then check for equality on left\\n\\n```\\nif(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n```\\n\\n**STEP 2:** If nums[ind] is already present then check for equality on right\\n\\n```\\nif(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n```\\n\\n**STEP 3:** Assign the color to the nums[ind]\\n\\n```\\n nums[ind] = color;\\n```\\n\\n **STEP 4:** Check for equality on left\\n\\n```\\nif( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n```\\n\\n**Step 5:** Check for equality on right\\n\\n```\\nif( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n```\\n\\n**STEP 6:** Add cnt to the ans\\n\\n```\\nans.push_back(cnt);\\n```\\n# Complexity\\n- Time complexity: $$ O(q) $$ where q = size of queries\\n- Space complexity: $$ O(n) $$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> nums(n,0);\\n        int cnt = 0;\\n        for(auto it: queries) {\\n            int ind = it[0];\\n            int color = it[1];\\n         \\n            // STEP 1: if nums[ind] is already present then check for equality on left\\n            if(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n            // STEP 2: if nums[ind] is already present then check for equality on right\\n            if(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n\\n            // STEP 3: Assign the color to the nums[ind]\\n            nums[ind] = color;\\n\\n            // Step 4: Check for equality on left\\n            if( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n            // Step 5: Check for equality on right\\n            if( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n\\n            // STEP 6: add to the ans\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n```\n```\\nif(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n```\n```\\n nums[ind] = color;\\n```\n```\\nif( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n```\n```\\nif( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n```\n```\\nans.push_back(cnt);\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> nums(n,0);\\n        int cnt = 0;\\n        for(auto it: queries) {\\n            int ind = it[0];\\n            int color = it[1];\\n         \\n            // STEP 1: if nums[ind] is already present then check for equality on left\\n            if(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n            // STEP 2: if nums[ind] is already present then check for equality on right\\n            if(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n\\n            // STEP 3: Assign the color to the nums[ind]\\n            nums[ind] = color;\\n\\n            // Step 4: Check for equality on left\\n            if( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n            // Step 5: Check for equality on right\\n            if( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n\\n            // STEP 6: add to the ans\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495015,
                "title": "easy-understandable-c-o-q-time-o-n-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntialise count with 0\\nWhile inserting check if the inserting element will distrub the count\\nIf Distrubing decrement and increment accordingly...\\n\\n# Complexity\\n- Time complexity:O(Q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            int idx=q[i][0]; // At idx the new ele is added\\n            int col=q[i][1]; // the color to be added is col\\n            int prev=0;     // the previou elem at idx-1, which may contribute the cnt (also next)\\n            int next=0;\\n            if((idx-1)>=0){\\n                prev=v[idx-1];\\n            }\\n            if((idx+1)<n){\\n                next=v[idx+1];\\n            }\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then decrement cnt\\n                cnt--;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then decrement cnt\\n                cnt--;\\n            }\\n            v[idx]=col; // new color is added at idx \\n\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then increment cnt\\n                cnt++;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then increment cnt\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            int idx=q[i][0]; // At idx the new ele is added\\n            int col=q[i][1]; // the color to be added is col\\n            int prev=0;     // the previou elem at idx-1, which may contribute the cnt (also next)\\n            int next=0;\\n            if((idx-1)>=0){\\n                prev=v[idx-1];\\n            }\\n            if((idx+1)<n){\\n                next=v[idx+1];\\n            }\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then decrement cnt\\n                cnt--;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then decrement cnt\\n                cnt--;\\n            }\\n            v[idx]=col; // new color is added at idx \\n\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then increment cnt\\n                cnt++;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then increment cnt\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517717,
                "title": "java-simple-counting-15-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to keep track of the number of adjacent cells with the same color after every query. So for every query we check the 2 neighboring cells of `queries[i][0]` and update the count factoring in the old color that is going to be removed and the new color that is going to be added. The code should be self-explanatory.\\n\\n# Complexity\\n- Time complexity: $$O(m)$$ where `m = queries.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] colorTheArray(int n, int[][] queries) {\\n    var nums = new int[n];\\n    var m = queries.length;\\n    var ans = new int[m];\\n    var cnt = 0;\\n\\n    for (var i=0; i<m; i++) {\\n      var j = queries[i][0];\\n\\n      if (nums[j] != 0) {\\n        cnt -= j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n        cnt -= j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n      }\\n      nums[j] = queries[i][1];\\n\\n      cnt += j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n      cnt += j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n\\n      ans[i] = cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public int[] colorTheArray(int n, int[][] queries) {\\n    var nums = new int[n];\\n    var m = queries.length;\\n    var ans = new int[m];\\n    var cnt = 0;\\n\\n    for (var i=0; i<m; i++) {\\n      var j = queries[i][0];\\n\\n      if (nums[j] != 0) {\\n        cnt -= j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n        cnt -= j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n      }\\n      nums[j] = queries[i][1];\\n\\n      cnt += j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n      cnt += j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n\\n      ans[i] = cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495848,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n, queries):\\n        ans, nums, count = [], [0]*n, 0\\n\\n        for i in range(len(queries)):\\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n\\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n, queries):\\n        ans, nums, count = [], [0]*n, 0\\n\\n        for i in range(len(queries)):\\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n\\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495785,
                "title": "using-map-c-easy-to-understnad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& v) {\\n        unordered_map<int,int> mp;\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: v){\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==mp[i[0]])x--;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==mp[i[0]])x--;\\n            mp[i[0]] = i[1];\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==i[1])x++;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==i[1])x++;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& v) {\\n        unordered_map<int,int> mp;\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: v){\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==mp[i[0]])x--;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==mp[i[0]])x--;\\n            mp[i[0]] = i[1];\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==i[1])x++;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==i[1])x++;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495524,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr(n);\\n        int prev=0,ind,color,i=0;\\n        for(vector<int>&a:queries)\\n        {\\n            ind=a[0];\\n            color=a[1];\\n         \\n            if(color!=arr[ind]){\\n            if(prev>0)\\n            {\\n                if(ind<=n-2) {\\n                    if(arr[ind]==arr[ind+1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                      \\n                    }\\n                }\\n                if(ind>=1)\\n                {\\n                     if(arr[ind]==arr[ind-1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                    }\\n                }\\n                        \\n            }\\n            arr[ind]=color;\\n          \\n            if(ind>=1) \\n            {\\n                 if(arr[ind-1]==arr[ind]) prev++;\\n            }\\n            if(ind<=n-2)\\n            {\\n                if(arr[ind]==arr[ind+1]) prev++;\\n            }\\n           \\n            }\\n            ans.push_back(prev);\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr(n);\\n        int prev=0,ind,color,i=0;\\n        for(vector<int>&a:queries)\\n        {\\n            ind=a[0];\\n            color=a[1];\\n         \\n            if(color!=arr[ind]){\\n            if(prev>0)\\n            {\\n                if(ind<=n-2) {\\n                    if(arr[ind]==arr[ind+1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                      \\n                    }\\n                }\\n                if(ind>=1)\\n                {\\n                     if(arr[ind]==arr[ind-1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                    }\\n                }\\n                        \\n            }\\n            arr[ind]=color;\\n          \\n            if(ind>=1) \\n            {\\n                 if(arr[ind-1]==arr[ind]) prev++;\\n            }\\n            if(ind<=n-2)\\n            {\\n                if(arr[ind]==arr[ind+1]) prev++;\\n            }\\n           \\n            }\\n            ans.push_back(prev);\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494954,
                "title": "check-contribution-simple-c-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> res(q.size());\\n        vector<int> arr(n,0);\\n        \\n        int cnt=0;\\n        res[0]=0;\\n        arr[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(arr[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n              \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]]==arr[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && arr[q[i][0]]==arr[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n              \\n            }\\n              arr[q[i][0]]=q[i][1];\\n                res[i]=cnt;\\n                \\n        }\\n        return res;                                 \\n                                        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> res(q.size());\\n        vector<int> arr(n,0);\\n        \\n        int cnt=0;\\n        res[0]=0;\\n        arr[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(arr[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n              \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]]==arr[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && arr[q[i][0]]==arr[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n              \\n            }\\n              arr[q[i][0]]=q[i][1];\\n                res[i]=cnt;\\n                \\n        }\\n        return res;                                 \\n                                        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494927,
                "title": "maintain-a-count-c-java-python-o-q-easy-stright-forward",
                "content": "```\\n1. Easy Question And Easy Solution.\\n2. Don\\'t need to do or use any fancy data structure.\\n3. Just maintain a count of number of adjacent elements with the same color and \\n   update the count according to queries\\n4. for index in each query just check the previous and next element and update the count \\n```\\n**C++ CODE**\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      \\n        int count = 0;\\n        \\n        vector<int> nums(n,0), result;\\n        \\n        for(auto &q: queries) {\\n            \\n            int idx = q[0], val = q[1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1])count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1])count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result.push_back(count);\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**JAVA CODE**\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**PYTHON CODE**\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        result = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            result.append(count)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array"
                ],
                "code": "```\\n1. Easy Question And Easy Solution.\\n2. Don\\'t need to do or use any fancy data structure.\\n3. Just maintain a count of number of adjacent elements with the same color and \\n   update the count according to queries\\n4. for index in each query just check the previous and next element and update the count \\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      \\n        int count = 0;\\n        \\n        vector<int> nums(n,0), result;\\n        \\n        for(auto &q: queries) {\\n            \\n            int idx = q[0], val = q[1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1])count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1])count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result.push_back(count);\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        result = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            result.append(count)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598865,
                "title": "c-solution-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int>color(n,0);\\n\\n    vector<int>wholeans;\\n\\n    int ans=0;\\n\\n        for(int i=0;i<queries.size();i++){\\n            int  index = queries[i][0],newcolor = queries[i][1];\\n            \\n            int leftside = index-1 < 0 ? 0 :color[index-1];\\n            int rightside = index+1 == n ? 0 :color[index+1];\\n\\n            if( color[index]!=0 && leftside == color[index] )ans--;\\n            if( color[index]!=0 && rightside == color[index] )ans--;\\n\\n            color[index]=newcolor;\\n\\n            if( leftside==color[index] )ans++;\\n            if( rightside==color[index] )ans++;\\n\\n            wholeans.push_back(ans);\\n        }\\n        return wholeans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int>color(n,0);\\n\\n    vector<int>wholeans;\\n\\n    int ans=0;\\n\\n        for(int i=0;i<queries.size();i++){\\n            int  index = queries[i][0],newcolor = queries[i][1];\\n            \\n            int leftside = index-1 < 0 ? 0 :color[index-1];\\n            int rightside = index+1 == n ? 0 :color[index+1];\\n\\n            if( color[index]!=0 && leftside == color[index] )ans--;\\n            if( color[index]!=0 && rightside == color[index] )ans--;\\n\\n            color[index]=newcolor;\\n\\n            if( leftside==color[index] )ans++;\\n            if( rightside==color[index] )ans++;\\n\\n            wholeans.push_back(ans);\\n        }\\n        return wholeans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496911,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        ans = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            ans.append(count)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        ans = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            ans.append(count)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496152,
                "title": "day-402-brute-better-optimal-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99 \\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCOMMING SOON\\n\\n# Code\\n```JAVA []\\npublic int[] colorTheArray(int n, int[][] q) {\\n    int nums[] = new int[n];\\n    int len = q.length;\\n    int answer[] = new int[len];\\n    int cnt =0;\\n    for(int i=0;i<len;i++){\\n        int ind=q[i][0],col=q[i][1];\\n        int prev = (ind>0)?nums[ind-1]:0;\\n        int next = (ind<n-1)?nums[ind+1]:0;\\n        if(nums[ind]!=0 && (nums[ind]==prev))cnt--;\\n        if(nums[ind]!=0 && (nums[ind]==next))cnt--;\\n        nums[ind]=col;\\n        if(nums[ind]==prev)cnt++;\\n        if( nums[ind]==next)cnt++;\\n        answer[i]=cnt;\\n    }return answer;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```JAVA []\\npublic int[] colorTheArray(int n, int[][] q) {\\n    int nums[] = new int[n];\\n    int len = q.length;\\n    int answer[] = new int[len];\\n    int cnt =0;\\n    for(int i=0;i<len;i++){\\n        int ind=q[i][0],col=q[i][1];\\n        int prev = (ind>0)?nums[ind-1]:0;\\n        int next = (ind<n-1)?nums[ind+1]:0;\\n        if(nums[ind]!=0 && (nums[ind]==prev))cnt--;\\n        if(nums[ind]!=0 && (nums[ind]==next))cnt--;\\n        nums[ind]=col;\\n        if(nums[ind]==prev)cnt++;\\n        if( nums[ind]==next)cnt++;\\n        answer[i]=cnt;\\n    }return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495354,
                "title": "c-best-solution-o-n-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0), ans;\\n        int cnt = 0;\\n        for(auto it : queries)  {\\n            int ind = it[0], color = it[1];\\n            if(ind - 1 >= 0 && arr[ind - 1] == arr[ind] && arr[ind] != 0)    cnt--;\\n            if(ind+1<n && arr[ind+1] == arr[ind] && arr[ind] != 0)  cnt--;\\n            if(ind - 1 >= 0 && arr[ind - 1] == color)    cnt++;\\n            if(ind+1<n && arr[ind+1] == color)  cnt++;\\n            arr[ind] = color;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0), ans;\\n        int cnt = 0;\\n        for(auto it : queries)  {\\n            int ind = it[0], color = it[1];\\n            if(ind - 1 >= 0 && arr[ind - 1] == arr[ind] && arr[ind] != 0)    cnt--;\\n            if(ind+1<n && arr[ind+1] == arr[ind] && arr[ind] != 0)  cnt--;\\n            if(ind - 1 >= 0 && arr[ind - 1] == color)    cnt++;\\n            if(ind+1<n && arr[ind+1] == color)  cnt++;\\n            arr[ind] = color;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495293,
                "title": "very-simple-and-beginner-friendly-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse last matching adjacent colors to calculate for current query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every query we will save matching adjacent colors and use it in next query. And check if on changing current query if no of matching adjacent colors increases or decreases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int x=0;\\n        vector<int>color(n+2,0);\\n        ans.push_back(0);\\n        color[queries[0][0]+1]=queries[0][1];\\n        for(int i=1;i<queries.size();i++)\\n        {\\n            int p=0,q=0;\\n            if(color[queries[i][0]+1]==color[queries[i][0]] && color[queries[i][0]+1]!=0)\\n                p++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2] && color[queries[i][0]+1]!=0)\\n                p++;\\n            color[queries[i][0]+1]=queries[i][1];\\n            if(color[queries[i][0]+1]==color[queries[i][0]])\\n                q++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2])\\n                q++;\\n            x+=(q-p);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int x=0;\\n        vector<int>color(n+2,0);\\n        ans.push_back(0);\\n        color[queries[0][0]+1]=queries[0][1];\\n        for(int i=1;i<queries.size();i++)\\n        {\\n            int p=0,q=0;\\n            if(color[queries[i][0]+1]==color[queries[i][0]] && color[queries[i][0]+1]!=0)\\n                p++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2] && color[queries[i][0]+1]!=0)\\n                p++;\\n            color[queries[i][0]+1]=queries[i][1];\\n            if(color[queries[i][0]+1]==color[queries[i][0]])\\n                q++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2])\\n                q++;\\n            x+=(q-p);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495200,
                "title": "easy-c-solution-o-queries-size-time-complexity-solution",
                "content": "# Intuition\\nBefore painting an index just check how the color present at the index is reducing the number of adjacent elements. Now check the new color that we are going to paint at that index is increaing the adjacent element or not.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> arr(n,0);\\n        int m = queries.size();\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            if(i == 0){\\n                ans = 0;\\n                arr[queries[i][0]] = queries[i][1];\\n            } else {\\n                int ind = queries[i][0];\\n                if(ind > 0 && arr[ind - 1] == arr[ind] && arr[ind - 1] != 0) ans--;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind] && arr[ind + 1] != 0) ans--;\\n                arr[ind] = queries[i][1];\\n                if(ind > 0 && arr[ind - 1] == arr[ind]) ans++;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind]) ans++;\\n            }\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> arr(n,0);\\n        int m = queries.size();\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            if(i == 0){\\n                ans = 0;\\n                arr[queries[i][0]] = queries[i][1];\\n            } else {\\n                int ind = queries[i][0];\\n                if(ind > 0 && arr[ind - 1] == arr[ind] && arr[ind - 1] != 0) ans--;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind] && arr[ind + 1] != 0) ans--;\\n                arr[ind] = queries[i][1];\\n                if(ind > 0 && arr[ind - 1] == arr[ind]) ans++;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind]) ans++;\\n            }\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495099,
                "title": "c-easy-to-understand-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<int> v(n, 0);\\n        int adjacentColorCount = 0;\\n        for(int i = 0; i < q.size(); i++) {\\n            int index = q[i][0];\\n            int color = q[i][1];\\n            int prevColorAtIndex = v[index];\\n            // color with current color at index.\\n            v[index] = color;\\n            // if adjacent color is same means we have to increase the adjacentColorCount\\n            if(index > 0 && v[index - 1] == v[index]) adjacentColorCount++;\\n            if(index < n - 1 && v[index + 1] == v[index]) adjacentColorCount++;\\n            // if previously adjacent color is changed after coloring with new color, means we have to decrease the adjacentColorCount\\n            if(index > 0 && prevColorAtIndex > 0 && v[index - 1] == prevColorAtIndex) adjacentColorCount--;\\n            if(index < n - 1 && prevColorAtIndex > 0 && v[index + 1] == prevColorAtIndex) adjacentColorCount--;\\n            ans.push_back(adjacentColorCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<int> v(n, 0);\\n        int adjacentColorCount = 0;\\n        for(int i = 0; i < q.size(); i++) {\\n            int index = q[i][0];\\n            int color = q[i][1];\\n            int prevColorAtIndex = v[index];\\n            // color with current color at index.\\n            v[index] = color;\\n            // if adjacent color is same means we have to increase the adjacentColorCount\\n            if(index > 0 && v[index - 1] == v[index]) adjacentColorCount++;\\n            if(index < n - 1 && v[index + 1] == v[index]) adjacentColorCount++;\\n            // if previously adjacent color is changed after coloring with new color, means we have to decrease the adjacentColorCount\\n            if(index > 0 && prevColorAtIndex > 0 && v[index - 1] == prevColorAtIndex) adjacentColorCount--;\\n            if(index < n - 1 && prevColorAtIndex > 0 && v[index + 1] == prevColorAtIndex) adjacentColorCount--;\\n            ans.push_back(adjacentColorCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495059,
                "title": "easy-c-solution-compare-1-before-and-after-element-only",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialized nums of size n, ans of size querr.size() and a map for checking 1st time occurance of any index.\\n2. In every querry we checking firstly if it have adjacent same than decrementing counter else incrementing.\\n3. then adding that count in ans;\\n\\n# Complexity\\n- Time complexity: $$O(m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> nums(n,0);\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n        unordered_map<int,int> y;\\n        int x=0;\\n        for(int i=0;i<m;i++){\\n            if(y[q[i][0]]!=0){\\n                if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x--;\\n                if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x--;\\n            }\\n            y[q[i][0]]++;\\n            nums[q[i][0]]=q[i][1];\\n            if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x++;\\n            if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x++;\\n            ans[i]=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> nums(n,0);\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n        unordered_map<int,int> y;\\n        int x=0;\\n        for(int i=0;i<m;i++){\\n            if(y[q[i][0]]!=0){\\n                if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x--;\\n                if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x--;\\n            }\\n            y[q[i][0]]++;\\n            nums[q[i][0]]=q[i][1];\\n            if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x++;\\n            if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x++;\\n            ans[i]=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495047,
                "title": "o-n-solution",
                "content": "# Intuition\\n\\nSince n can be 10^5 so we need to have solution in O(n) or O(nlogn) to avoid TLE and it can be observed that we can keep a counter which represents current adjacent equals and simply update it after the query[i].\\n\\nThere can be two cases\\n1. If the currentColor already matches the color being added. Then we do nothing and simply push the current count to the result array.\\n2. If it doesn\\'t then there can be two cases\\n - If the current color at that index is 0 i.e. it is uncolored then we check whether the color that we want to add to that index matches any of the adjacent colors, if yes then we increment the count and udate the index\\'s color to query[i][1]\\n- If the index is colored then we check if existing color matches any of the existing colors. If yes, decrement the count accordingly and then we update the index\\'s to query[i] color and again compute the new count based on the current situation of adjacent index\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> colors(n, 0);\\n        int count = 0;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            if(colors[index] == color) {\\n                ans.push_back(count);\\n            } else {\\n                int currentColor = colors[index];\\n                if(currentColor == 0) {\\n                    if(index > 0 && colors[index-1] == color) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == color) {\\n                        count++;\\n                    }\\n\\n                    colors[index] = color;\\n                    ans.push_back(count);\\n                } \\n                else {\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count--;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count--;\\n                    }\\n\\n                    colors[index] = color;\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count++;\\n                    }\\n\\n                    ans.push_back(count);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> colors(n, 0);\\n        int count = 0;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            if(colors[index] == color) {\\n                ans.push_back(count);\\n            } else {\\n                int currentColor = colors[index];\\n                if(currentColor == 0) {\\n                    if(index > 0 && colors[index-1] == color) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == color) {\\n                        count++;\\n                    }\\n\\n                    colors[index] = color;\\n                    ans.push_back(count);\\n                } \\n                else {\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count--;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count--;\\n                    }\\n\\n                    colors[index] = color;\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count++;\\n                    }\\n\\n                    ans.push_back(count);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049338,
                "title": "c-o-n-simple-counting-easy-to-understand",
                "content": "**Idea :**\\n1. During each iteration, we set the values of two variables - oldT, newT. oldT checks the immediate left and right position if they are equal to the current index as it is going to be modified.\\n2. After setting oldT, we perform the required modification.\\n3. Now, we set the value of newT, performing the same operation as for oldT. \\n4. The differenct of newT and oldT i.e. newT-oldT is the effective change in count which is added into the variable \"cnt\" which is being maintained from start.\\n\\n```\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>colors(n+1,0);\\n        vector<int>ans;\\n        int cnt = 0;\\n        \\n        for(auto i : queries){\\n            int idx = i[0];\\n            int oldT = 0, newT = 0;\\n            \\n            // calculate old effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){oldT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                oldT++;\\n            }\\n            \\n            // perform the required change\\n            colors[idx] = i[1];\\n            \\n            // calculate new effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){newT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                newT++;\\n            }\\n            \\n            // add the difference of new and old effects into the count\\n            cnt+=newT - oldT;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>colors(n+1,0);\\n        vector<int>ans;\\n        int cnt = 0;\\n        \\n        for(auto i : queries){\\n            int idx = i[0];\\n            int oldT = 0, newT = 0;\\n            \\n            // calculate old effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){oldT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                oldT++;\\n            }\\n            \\n            // perform the required change\\n            colors[idx] = i[1];\\n            \\n            // calculate new effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){newT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                newT++;\\n            }\\n            \\n            // add the difference of new and old effects into the count\\n            cnt+=newT - oldT;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578004,
                "title": "self-explanatory-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity : $$O(Q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        \\n        int cnt = 0;\\n        vector<int> ans(queries.size());\\n        for(int x=0 ; x<queries.size() ; x++) {\\n            int i = queries[x][0];\\n            int col = queries[x][1];\\n            \\n            // count will decrease only when the \"i\"th index is already colored\\n            if(color[i] != 0) {\\n                if(i>=1 && color[i]==color[i-1]) cnt--;\\n                if(i<n-1 && color[i]==color[i+1]) cnt--;\\n            }\\n            \\n            // change the color of index \"i\" and update the count\\n            color[i] = col;\\n            if(i>=1 && color[i]==color[i-1]) cnt++;\\n            if(i<n-1 && color[i]==color[i+1]) cnt++;\\n            \\n            ans[x] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        \\n        int cnt = 0;\\n        vector<int> ans(queries.size());\\n        for(int x=0 ; x<queries.size() ; x++) {\\n            int i = queries[x][0];\\n            int col = queries[x][1];\\n            \\n            // count will decrease only when the \"i\"th index is already colored\\n            if(color[i] != 0) {\\n                if(i>=1 && color[i]==color[i-1]) cnt--;\\n                if(i<n-1 && color[i]==color[i+1]) cnt--;\\n            }\\n            \\n            // change the color of index \"i\" and update the count\\n            color[i] = col;\\n            if(i>=1 && color[i]==color[i-1]) cnt++;\\n            if(i<n-1 && color[i]==color[i+1]) cnt++;\\n            \\n            ans[x] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511155,
                "title": "easy-solution-in-c",
                "content": "# Complexity\\n- Time complexity: O(q), where q is the number of queries.\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> ans(m, 0);\\n        for(int i=0; i<m; i++){\\n            auto v = queries[i];\\n            int temp = 0;\\n            if(nums[v[0]]==0){\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                if(i!=0) ans[i]=ans[i-1] + temp;\\n            }\\n            else{\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp--;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp--;\\n                if(i!=0) ans[i] = ans[i-1]-temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> ans(m, 0);\\n        for(int i=0; i<m; i++){\\n            auto v = queries[i];\\n            int temp = 0;\\n            if(nums[v[0]]==0){\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                if(i!=0) ans[i]=ans[i-1] + temp;\\n            }\\n            else{\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp--;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp--;\\n                if(i!=0) ans[i] = ans[i-1]-temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503325,
                "title": "java-basic-approach-o-n-time-o-n-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        if(n==1) return new int[queries.length];\\n        \\n        int ans[]=new int[queries.length];  // for storing the answer of each query\\n        int color[]=new int[n];  \\n        int findPair=0;     // it will keep track of total Number of Pair(adject)\\n\\n        for(int i=0;i<queries.length;i++){\\n\\n                int index=queries[i][0];     // index which we need to color\\n                int assignColor=queries[i][1];  // given color for current index;\\n\\n// find the adjecent leftColor and rightColor of the current Index\\n                int leftColor=(index-1)>=0?color[index-1]:0;    \\n                int rightColor=(index+1)<n?color[index+1]:0;    \\n\\n// if current index color is forming pair to left or right ,then we need to decrease the findPair by 1 because we are going to \\n// color the current index with a new color\\n                if(color[index]!=0 && leftColor==color[index] ) findPair--;  // if current index color matches with left one\\n                if(color[index]!=0 && rightColor==color[index]) findPair--;  // if current index color matches with right one\\n\\n// color the current index with given new Color\\n                color[index]=assignColor;\\n\\n// Now check if, after assigning the new Color to the current index ,it is forming any new Pair,if it is  then increase the \\n// findPair by 1;\\n                if(leftColor!=0 && color[index]==leftColor) findPair++;  // if color matches with leftColor\\n                if(rightColor!=0 && color[index]==rightColor) findPair++; // if color matches with rightColor\\n\\n        // assign the calculated pair to the answer\\n                ans[i]=findPair;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        if(n==1) return new int[queries.length];\\n        \\n        int ans[]=new int[queries.length];  // for storing the answer of each query\\n        int color[]=new int[n];  \\n        int findPair=0;     // it will keep track of total Number of Pair(adject)\\n\\n        for(int i=0;i<queries.length;i++){\\n\\n                int index=queries[i][0];     // index which we need to color\\n                int assignColor=queries[i][1];  // given color for current index;\\n\\n// find the adjecent leftColor and rightColor of the current Index\\n                int leftColor=(index-1)>=0?color[index-1]:0;    \\n                int rightColor=(index+1)<n?color[index+1]:0;    \\n\\n// if current index color is forming pair to left or right ,then we need to decrease the findPair by 1 because we are going to \\n// color the current index with a new color\\n                if(color[index]!=0 && leftColor==color[index] ) findPair--;  // if current index color matches with left one\\n                if(color[index]!=0 && rightColor==color[index]) findPair--;  // if current index color matches with right one\\n\\n// color the current index with given new Color\\n                color[index]=assignColor;\\n\\n// Now check if, after assigning the new Color to the current index ,it is forming any new Pair,if it is  then increase the \\n// findPair by 1;\\n                if(leftColor!=0 && color[index]==leftColor) findPair++;  // if color matches with leftColor\\n                if(rightColor!=0 && color[index]==rightColor) findPair++; // if color matches with rightColor\\n\\n        // assign the calculated pair to the answer\\n                ans[i]=findPair;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503318,
                "title": "python-track-status-of-adjacent-values-after-changes",
                "content": "After the first hint I was able to solve it. Yeah! STRONG NO HIRE!\\nWas thinking about some DSU, anti-DSU and etc, but did not figure out that we do **1 change at a time**:\\n\\nThis allows us to figure out that when before we make a change to `nums[i]`\\nif `nums[i] == nums[i - 1]` but the new one will break this equation we `count -= 1`\\nif `nums[i] == nums[i + 1]` but the new one will break this equation we `count -= 1`\\nchange `nums[i]` to new color\\nif `nums[i] == nums[i - 1]` and the new one will make this equation valid we `count += 1`\\nif `nums[i] == nums[i + 1]` and the new one will make this equation valid we `count += 1`\\n\\nWe need to be careful with the case when old `nums[i]` == new `nums[i]` to avoid double counting.\\nTo avoid boundary checking I just do nothing here. With an array you\\'ll have to check the out of boundaries for +1/-1.\\n\\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = defaultdict(int)\\n        res = []\\n        for i,c in queries:\\n            count -= (nums[i - 1] == nums[i] != 0) + (0 != nums[i] == nums[i + 1])\\n            nums[i] = c\\n            count += (nums[i - 1] == nums[i] == c) + (c == nums[i] == nums[i + 1])\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, N: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = defaultdict(int)\\n        res = []\\n        for i,c in queries:\\n            count -= (nums[i - 1] == nums[i] != 0) + (0 != nums[i] == nums[i + 1])\\n            nums[i] = c\\n            count += (nums[i - 1] == nums[i] == c) + (c == nums[i] == nums[i + 1])\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501399,
                "title": "simple-logical-problem-cpp-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n        {\\n            vector<int> vec(n + 2, 0);//making size+2 array so that it reduce multiple conditional statements like for i+1 exists for i==n-1 or not i-1 exists for i==0 or i in between 0 to n etc.\\n\\t\\t\\t// consider addition of one extra zero at start and end so that element always has one element before and after it.\\n            int cnt = 0;\\n            vector<int> ans;\\n            for (int i = 0; i < queries.size(); i++)\\n            {\\n                int pos = queries[i][0] + 1;\\n                int col = queries[i][1];\\n                if (vec[pos] != 0)//for deletion of adjacent elements.\\n                {\\n                    if (vec[pos] == vec[pos + 1]) cnt--;\\n                    if (vec[pos] == vec[pos - 1]) cnt--;\\n                }\\n                vec[pos] = col;\\n                if (vec[pos] == vec[pos + 1]) cnt++;)//for addition of adjacent elements.\\n                if (vec[pos] == vec[pos - 1]) cnt++;\\n\\n                ans.push_back(cnt);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n        {\\n            vector<int> vec(n + 2, 0);//making size+2 array so that it reduce multiple conditional statements like for i+1 exists for i==n-1 or not i-1 exists for i==0 or i in between 0 to n etc.\\n\\t\\t\\t// consider addition of one extra zero at start and end so that element always has one element before and after it.\\n            int cnt = 0;\\n            vector<int> ans;\\n            for (int i = 0; i < queries.size(); i++)\\n            {\\n                int pos = queries[i][0] + 1;\\n                int col = queries[i][1];\\n                if (vec[pos] != 0)//for deletion of adjacent elements.\\n                {\\n                    if (vec[pos] == vec[pos + 1]) cnt--;\\n                    if (vec[pos] == vec[pos - 1]) cnt--;\\n                }\\n                vec[pos] = col;\\n                if (vec[pos] == vec[pos + 1]) cnt++;)//for addition of adjacent elements.\\n                if (vec[pos] == vec[pos - 1]) cnt++;\\n\\n                ans.push_back(cnt);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498115,
                "title": "c-best-solution-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust see the solution code ....inside the code ihave told told the concept to solve this question....This is a very good question to solve and this  type of question can be \\nasked in onlice assesmenet of the companies as well as many interview also...so\\nwe have to try to cover this type of question before the interview\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int N = queries.size();\\n        vector<int> ans(n+2,0);\\n        vector<int> nums;\\n        int count = 0;\\n        for(int i=0;i<N;i++){\\n            int ind = queries[i][0] +1;\\n            int color = queries[i][1];\\n            //at first we have to cheek if the current index which i want to color now is already clored ot not \\n            // if it is already colored then we have to cheek if the previous color is same as he adjacent color or not \\n            //if the previous color is same as the adjacent color then we have to remove count factor for this \\n            //after removing the count factor for this we have to color the index and after coloring the current index \\n            //we have to cheek if the current color is same as the adjacent color or not \\n            //if the current color is same as the adjacent color then we have to add the count factor for this ind what we have \\n            //colored right now \\n            if(ans[ind]!=0 && ans[ind] == ans[ind+1])count--;\\n            if(ans[ind]!=0 && ans[ind] == ans[ind-1])count--;\\n            \\n            ans[ind] = color;//color the current index \\n            if(ans[ind] == ans[ind-1])count++;//cheek the factor that the adjacent color is same as the color of the current index what we have colored right now ...if same then  please add the count factor for this index \\n            if(ans[ind] == ans[ind+1])count++;// add the count factor for this index \\n            \\n            nums.push_back(count);//find in the current state we have to cheek how many count is there means\\n            //count no = number of index for which nums[j] == nums[j-1] or nums[j] == nums[j+1] occurs\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int N = queries.size();\\n        vector<int> ans(n+2,0);\\n        vector<int> nums;\\n        int count = 0;\\n        for(int i=0;i<N;i++){\\n            int ind = queries[i][0] +1;\\n            int color = queries[i][1];\\n            //at first we have to cheek if the current index which i want to color now is already clored ot not \\n            // if it is already colored then we have to cheek if the previous color is same as he adjacent color or not \\n            //if the previous color is same as the adjacent color then we have to remove count factor for this \\n            //after removing the count factor for this we have to color the index and after coloring the current index \\n            //we have to cheek if the current color is same as the adjacent color or not \\n            //if the current color is same as the adjacent color then we have to add the count factor for this ind what we have \\n            //colored right now \\n            if(ans[ind]!=0 && ans[ind] == ans[ind+1])count--;\\n            if(ans[ind]!=0 && ans[ind] == ans[ind-1])count--;\\n            \\n            ans[ind] = color;//color the current index \\n            if(ans[ind] == ans[ind-1])count++;//cheek the factor that the adjacent color is same as the color of the current index what we have colored right now ...if same then  please add the count factor for this index \\n            if(ans[ind] == ans[ind+1])count++;// add the count factor for this index \\n            \\n            nums.push_back(count);//find in the current state we have to cheek how many count is there means\\n            //count no = number of index for which nums[j] == nums[j-1] or nums[j] == nums[j+1] occurs\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496614,
                "title": "c-maintain-result-at-each-query",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        // length of queries\\n        int qn = queries.size();\\n\\n        vector<int>nums(n,0); // nums which stores colors initially uncolored(means all values 0)\\n        vector<int>result;    // result (number of adjacent elements which has same color)\\n\\n        // running count of pairs which has same colors\\n        int pairs = 0;\\n\\n        for(int i = 0; i < qn; i++){\\n            \\n            int index = queries[i][0];        // current index where we update color\\n            int currentColor = queries[i][1]; // current color which will replace old color of index\\n\\n            // get previous & next adjacent of current index\\n            int prevAdjacent = 0 , nextAdjacent = 0;\\n\\n            // fetching adjacent values in range of 0 to n-1\\n            if(index - 1 >= 0) prevAdjacent = nums[index-1];\\n            if(index + 1 < n ) nextAdjacent = nums[index+1];\\n\\n\\n            int prevColor = nums[index]; // previous color of current index \\n            nums[index] = currentColor;  // assign current color to current index\\n\\n            // we use previous color for checking that previous color had pairs with its adjancent or not\\n            // if yes than we need to decrease the number of pairs bcoz current color will disturb the pairs\\n            // in below example [prevColor = 1] at index 1 and currentColor is 2 which replace 1\\n            // [[1 1 1]  |  [1 2 1]]  | 2 disturbing the pairs\\n            if(prevColor != 0 && prevColor == prevAdjacent) pairs--;\\n            if(prevColor != 0 && prevColor == nextAdjacent) pairs--;\\n\\n            // now check current color is forming pairs with adjancents or not\\n            if(currentColor == prevAdjacent) pairs++;\\n            if(currentColor == nextAdjacent) pairs++;\\n\\n            // update result after each query\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        // length of queries\\n        int qn = queries.size();\\n\\n        vector<int>nums(n,0); // nums which stores colors initially uncolored(means all values 0)\\n        vector<int>result;    // result (number of adjacent elements which has same color)\\n\\n        // running count of pairs which has same colors\\n        int pairs = 0;\\n\\n        for(int i = 0; i < qn; i++){\\n            \\n            int index = queries[i][0];        // current index where we update color\\n            int currentColor = queries[i][1]; // current color which will replace old color of index\\n\\n            // get previous & next adjacent of current index\\n            int prevAdjacent = 0 , nextAdjacent = 0;\\n\\n            // fetching adjacent values in range of 0 to n-1\\n            if(index - 1 >= 0) prevAdjacent = nums[index-1];\\n            if(index + 1 < n ) nextAdjacent = nums[index+1];\\n\\n\\n            int prevColor = nums[index]; // previous color of current index \\n            nums[index] = currentColor;  // assign current color to current index\\n\\n            // we use previous color for checking that previous color had pairs with its adjancent or not\\n            // if yes than we need to decrease the number of pairs bcoz current color will disturb the pairs\\n            // in below example [prevColor = 1] at index 1 and currentColor is 2 which replace 1\\n            // [[1 1 1]  |  [1 2 1]]  | 2 disturbing the pairs\\n            if(prevColor != 0 && prevColor == prevAdjacent) pairs--;\\n            if(prevColor != 0 && prevColor == nextAdjacent) pairs--;\\n\\n            // now check current color is forming pairs with adjancents or not\\n            if(currentColor == prevAdjacent) pairs++;\\n            if(currentColor == nextAdjacent) pairs++;\\n\\n            // update result after each query\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496608,
                "title": "map-of-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<pair<int,int>,pair<int,int>>m;\\n        vector<int>color(n,0);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            m[{i,i+1}]={color[i],color[i+1]};\\n        }\\n        int ans=0;\\n        vector<int>res;\\n        for(auto ele:queries)\\n        {\\n            int i=ele[0];\\n            int c=ele[1];\\n            \\n            //initial\\n            int initial=0;\\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    initial++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    initial++;\\n            }\\n            \\n            //after\\n            int after=0;\\n            color[i]=c;\\n            \\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                m[{i-1,i}]={color[i-1],color[i]};\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    after++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                m[{i,i+1}]={color[i],color[i+1]};\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    after++;\\n            }\\n            ans+=(after-initial);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<pair<int,int>,pair<int,int>>m;\\n        vector<int>color(n,0);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            m[{i,i+1}]={color[i],color[i+1]};\\n        }\\n        int ans=0;\\n        vector<int>res;\\n        for(auto ele:queries)\\n        {\\n            int i=ele[0];\\n            int c=ele[1];\\n            \\n            //initial\\n            int initial=0;\\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    initial++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    initial++;\\n            }\\n            \\n            //after\\n            int after=0;\\n            color[i]=c;\\n            \\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                m[{i-1,i}]={color[i-1],color[i]};\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    after++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                m[{i,i+1}]={color[i],color[i+1]};\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    after++;\\n            }\\n            ans+=(after-initial);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496137,
                "title": "o-n-c-solution-easy-approach",
                "content": "\\n\\n# Approach\\nMake a Color array of size N.\\nNow Traverse on the Queries and Check for Following:\\n- if index to be colored is 0, then we will check the index+1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans by 1.\\n- if index to be colored is N-1, then we will check the index-1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans by 1.\\n- if index to be colored is greater than 0 and smaller that N-1, then we will check the index+1 cell  and index-1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans.\\nAt the End we will return the Resulting array.\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(N)+O(M)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size=queries.size();\\n        vector<int> res(size,0),col(n,0);\\n        if(n==1) return res;\\n        int ans=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int ind=queries[i][0];\\n            int cl=queries[i][1];\\n            if(ind==0)\\n            {\\n                int prev=(col[ind]==col[ind+1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1]);\\n                res[i]=ans;\\n            }\\n            else if(ind==n-1)\\n            {\\n                int prev=(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n            else\\n            {\\n                int prev=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/76ab304e-d2c4-4795-b683-26d8c7d91332_1683449649.8341496.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size=queries.size();\\n        vector<int> res(size,0),col(n,0);\\n        if(n==1) return res;\\n        int ans=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int ind=queries[i][0];\\n            int cl=queries[i][1];\\n            if(ind==0)\\n            {\\n                int prev=(col[ind]==col[ind+1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1]);\\n                res[i]=ans;\\n            }\\n            else if(ind==n-1)\\n            {\\n                int prev=(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n            else\\n            {\\n                int prev=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495666,
                "title": "simple-counting-c-intuition",
                "content": "# Intuition\\nCreate the nums array and track the count of adjacent numbers that are same\\n\\nApproach\\nCreate the array nums\\nFor each query first check if the values at index - 1 or index + 1 are the same as nums[index]. If any of them are equal, decrement the counter\\nUpdate the value of nums[index]\\nNow check if values at index - 1 or index + 1 are the same as nums[index]. If any of them are equal, increment the counter\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n      int count=0;\\n      vector<int> res,nums(n+2,0);\\n      for (auto& q : queries) \\n      {\\n        int i = q[0];\\n        int color = q[1];\\n        // Check if element have same color then decrement count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count--;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count--;\\n        nums[i]=color;\\n        // Check if element have same color then increment count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count++;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count++;\\n        res.push_back(count);\\n      }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n      int count=0;\\n      vector<int> res,nums(n+2,0);\\n      for (auto& q : queries) \\n      {\\n        int i = q[0];\\n        int color = q[1];\\n        // Check if element have same color then decrement count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count--;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count--;\\n        nums[i]=color;\\n        // Check if element have same color then increment count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count++;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count++;\\n        res.push_back(count);\\n      }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495601,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[100005];\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int c=0;\\n        vector<int>ans;\\n        for(int i=0; i<q.size(); i++) {\\n            int x=q[i][0];\\n            int y=q[i][1];\\n            \\n            if(x==0) {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;     \\n            }\\n            else if(x==n-1) {\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                 vis[x]=y;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            else {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            ans.push_back(c);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[100005];\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int c=0;\\n        vector<int>ans;\\n        for(int i=0; i<q.size(); i++) {\\n            int x=q[i][0];\\n            int y=q[i][1];\\n            \\n            if(x==0) {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;     \\n            }\\n            else if(x==n-1) {\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                 vis[x]=y;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            else {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            ans.push_back(c);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495586,
                "title": "easy-counting-implementation-approach",
                "content": "We Will keep track of adjacent count of same element for the coming query index.\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,nums(n,0);\\n        int cnt=0;\\n        for(auto it:queries){\\n            int i=it[0];\\n            int color=it[1];\\n            if(nums[i] and i-1>=0 and nums[i-1]==nums[i]){\\n                cnt--;\\n            }\\n            if(nums[i] and i+1<n and nums[i+1]==nums[i]){\\n                cnt--;\\n            }\\n            nums[i]=color;\\n            if(i-1>=0 and nums[i-1]==nums[i]){\\n                cnt++;\\n            }\\n            if(i+1<n and nums[i+1]==nums[i]){\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,nums(n,0);\\n        int cnt=0;\\n        for(auto it:queries){\\n            int i=it[0];\\n            int color=it[1];\\n            if(nums[i] and i-1>=0 and nums[i-1]==nums[i]){\\n                cnt--;\\n            }\\n            if(nums[i] and i+1<n and nums[i+1]==nums[i]){\\n                cnt--;\\n            }\\n            nums[i]=color;\\n            if(i-1>=0 and nums[i-1]==nums[i]){\\n                cnt++;\\n            }\\n            if(i+1<n and nums[i+1]==nums[i]){\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495461,
                "title": "c-counting-with-simulation",
                "content": "**Algorithm :**\\n\\n1. Extract the color and index of the current index from the query.\\n2. Check if the current index has an existing color. If it does, it updates the map of sets accordingly.\\n3. Check if the adjacent nodes have the same color as the current node in the map of sets. If they do, it decrements ans.\\n4. Update the color of the current index and the map of sets.\\n5. Check if the adjacent index have a same color as the new current index color in the map of sets. If they do, it increments ans.\\n6. Append the current value of ans to the result vector v.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<int,set<int>> mp;\\n        int ans = 0;\\n        vector<int> v;\\n        vector<int> nums(n,0);\\n        for(int i = 0;i<queries.size();i++){\\n            int color = queries[i][1];\\n            int index = queries[i][0];\\n            if(nums[index] != 0){\\n               if(mp[nums[index]].find(index - 1) != mp[nums[index]].end()) ans--;\\n               if(mp[nums[index]].find(index + 1) != mp[nums[index]].end()) ans--;\\n               mp[nums[index]].erase(index);\\n            }\\n            if(mp[color].find(index - 1) != mp[color].end()) ans++;\\n            if(mp[color].find(index + 1) != mp[color].end()) ans++;\\n            v.push_back(ans); nums[index] = color; mp[color].insert(index);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<int,set<int>> mp;\\n        int ans = 0;\\n        vector<int> v;\\n        vector<int> nums(n,0);\\n        for(int i = 0;i<queries.size();i++){\\n            int color = queries[i][1];\\n            int index = queries[i][0];\\n            if(nums[index] != 0){\\n               if(mp[nums[index]].find(index - 1) != mp[nums[index]].end()) ans--;\\n               if(mp[nums[index]].find(index + 1) != mp[nums[index]].end()) ans--;\\n               mp[nums[index]].erase(index);\\n            }\\n            if(mp[color].find(index - 1) != mp[color].end()) ans++;\\n            if(mp[color].find(index + 1) != mp[color].end()) ans++;\\n            v.push_back(ans); nums[index] = color; mp[color].insert(index);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495388,
                "title": "simple-and-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic thing is when color is changed then we only need to focus on neighbors not on others. If the location for which we need to change color matches with neighbors then we need to reduce value and if the changed color matches with neighbors then we need to increase value and add to the previous calculated matches. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n1, vector<vector<int>>& que) {\\n        int n=que.size();\\n        int val=0,ad=0;\\n\\n        vector<int>nums(1000001,0);vector<int>ans(n,0);\\n        for(int i=0;i<que.size();i++){\\n            int temp=que[i][0];\\n            val=0;\\n            if(nums[temp]!=0){\\n                if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                    val+=1;\\n                if(nums[temp]==nums[temp+1])\\n                    val+=1;\\n            }\\n            nums[temp]=que[i][1];\\n            ad=0;\\n            if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                ad+=1;\\n            if(nums[temp]==nums[temp+1])\\n                ad+=1;\\n            if(i==0)\\n                ans[i]=ad;\\n            else\\n                ans[i]=ans[i-1]+ad-val;\\n                \\n        }\\n        // for(int x:nums)\\n        //     cout <<x<<\",\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n1, vector<vector<int>>& que) {\\n        int n=que.size();\\n        int val=0,ad=0;\\n\\n        vector<int>nums(1000001,0);vector<int>ans(n,0);\\n        for(int i=0;i<que.size();i++){\\n            int temp=que[i][0];\\n            val=0;\\n            if(nums[temp]!=0){\\n                if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                    val+=1;\\n                if(nums[temp]==nums[temp+1])\\n                    val+=1;\\n            }\\n            nums[temp]=que[i][1];\\n            ad=0;\\n            if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                ad+=1;\\n            if(nums[temp]==nums[temp+1])\\n                ad+=1;\\n            if(i==0)\\n                ans[i]=ad;\\n            else\\n                ans[i]=ans[i-1]+ad-val;\\n                \\n        }\\n        // for(int x:nums)\\n        //     cout <<x<<\",\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495365,
                "title": "simple-c-solution-linear-time",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- nums is a vector of size n to store the color changes initiated with all zeros\\n- initially total number (t) of adjacent elements with the same color is 0 \\n- Now iterate through the queries, idx has index in query and val has value to which it has to be changed\\n- if (idx-1 is in range )and (nu[idx - 1] is not zero) and (element present  at index is not equal to element at index -1) and (element at index -1 is equal to val) then we got a new pair of adjacent elements with the same color so increment total count t by 1\\n-  if (idx-1 is in range )and (nu[idx - 1] is not zero) and (element present  at index is  equal to element at index -1) and (element at index -1 is not equal to val) then we loose  a  pair of adjacent elements with the  same color so decrement  total count t by 1\\n- do the same for idx+1\\n- push t in ans and finally change the index in nums with val i.e. make change as per the query\\n- Thank You !!\\n\\n\\n# Complexity\\n- Time complexity: O(q.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+queries.size())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n const static auto fast = []\\n{\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n         vector<int>nums(n,0);\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int idx=queries[i][0],val=queries[i][1];\\n            if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]!=nums[idx] && nums[idx-1]==val)t++;\\n            else if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]==nums[idx] && nums[idx-1]!=val)t--;\\n            if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]!=nums[idx] && nums[idx+1]==val)t++;\\n            else if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]==nums[idx] && nums[idx+1]!=val)t--;\\n            ans.push_back(t);\\n            nums[idx]=val;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n const static auto fast = []\\n{\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n         vector<int>nums(n,0);\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int idx=queries[i][0],val=queries[i][1];\\n            if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]!=nums[idx] && nums[idx-1]==val)t++;\\n            else if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]==nums[idx] && nums[idx-1]!=val)t--;\\n            if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]!=nums[idx] && nums[idx+1]==val)t++;\\n            else if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]==nums[idx] && nums[idx+1]!=val)t--;\\n            ans.push_back(t);\\n            nums[idx]=val;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495159,
                "title": "c-multiple-if",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] ColorTheArray(int n, int[][] queries) \\n    {\\n        int[] nums = new int[n];\\n        int[] answer = new int[queries.Length];\\n        int currAdjacent = 0;\\n\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index - 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index < n - 1 && nums[index + 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index > 0 && nums[index - 1] == color && color != 0)\\n                currAdjacent++;\\n            if (index < n - 1 && nums[index + 1] == color && color != 0)\\n                currAdjacent++;\\n\\n            answer[i] = currAdjacent;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] ColorTheArray(int n, int[][] queries) \\n    {\\n        int[] nums = new int[n];\\n        int[] answer = new int[queries.Length];\\n        int currAdjacent = 0;\\n\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index - 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index < n - 1 && nums[index + 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index > 0 && nums[index - 1] == color && color != 0)\\n                currAdjacent++;\\n            if (index < n - 1 && nums[index + 1] == color && color != 0)\\n                currAdjacent++;\\n\\n            answer[i] = currAdjacent;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495096,
                "title": "easy-counting-based-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check adjacent element and maintain a count of pair where adjacent color are same\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise array as 0 of size n, array of ans and a counter c.\\n2. for each query, we will check if(i>0) then check if current and preivious color are same then c--, if(i<n-1) then check if current and next color is same then c--.\\n3. change color of arr[ind] with new color, and then check if(i>0) the check current and previous element is same then c++ and if(i<n-1) then check if current and next element is same then c++\\n4. Push c in ans at end of query\\n\\n# Complexity\\n- Time complexity:(O(m)) where m is number of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: max(n,m) where n is size of array and m is number of queriescount\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n,0);\\n        vector<int> ans;\\n        int c=0;\\n       for(auto x:queries)\\n       {\\n           int ind=x[0];\\n           int co=x[1];\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c--;\\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n               c--;\\n           }\\n           arr[ind]=co;\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c++;\\n               \\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n                 c++;\\n           }\\n           ans.push_back(c);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n,0);\\n        vector<int> ans;\\n        int c=0;\\n       for(auto x:queries)\\n       {\\n           int ind=x[0];\\n           int co=x[1];\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c--;\\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n               c--;\\n           }\\n           arr[ind]=co;\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c++;\\n               \\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n                 c++;\\n           }\\n           ans.push_back(c);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495001,
                "title": "easy-java-solution-100-beat",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n    public int update_color(int c, int[] a, int p, boolean inc) {\\n        if (p > 0 && a[p - 1] == a[p] && a[p - 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        if (p < a.length - 1 && a[p + 1] == a[p] && a[p + 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n    public int update_color(int c, int[] a, int p, boolean inc) {\\n        if (p > 0 && a[p - 1] == a[p] && a[p - 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        if (p < a.length - 1 && a[p + 1] == a[p] && a[p + 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494928,
                "title": "explaining-like-you-are-five-years-old",
                "content": "# Intuition\\nYou just need to check previous color and next color and modify number of current adjacent element with same color\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1. Simulate the change in color on index\\n2. Note down the current color on index\\n    a. check index-1 color\\n        if index-1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index-1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n    b. check index+1 color\\n        if index+1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index+1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n3. Update the new color to that index\\n        \\n```\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        \\n        elements = [0] * n # This will simulate the problem\\n        \\n        result = 0  # keeps record of current adjacent element with same color\\n        \\n        array = [] # This array will be our output\\n        \\n        # check function takes \\n            # number of current adjacent element with same color\\n            # earlier color on index we about to change\\n            # index to check = comp_index\\n            # index which will have color change\\n            # color on new index\\n            \\n        def check(result, earlier_color, comp_index, index, color): \\n            \\n            # if the comp_index is in bounds\\n            if 0 <= comp_index < n :\\n                \\n                # check if colored and comp_index has same earlier_color if yes that means the number of adjacent element with same color will be reduced by 1\\n                if earlier_color and elements[comp_index] == earlier_color:\\n                    result-=1\\n                # check if colored and comp_index has same color if yes that means the number of adjacent elements with same color will increase by 1\\n                if color and color == elements[comp_index]:\\n                    result +=1\\n                    \\n            return result\\n            \\n        \\n        for index, color in queries:\\n            earlier_color = elements[index]\\n            # check for previous element\\n            result = check(result, earlier_color, index - 1, index, color)\\n            # check for next element\\n            result = check(result, earlier_color, index + 1, index, color)\\n            \\n            elements[index] = color\\n            \\n            array.append(result)\\n            \\n        return array\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n1. Simulate the change in color on index\\n2. Note down the current color on index\\n    a. check index-1 color\\n        if index-1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index-1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n    b. check index+1 color\\n        if index+1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index+1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n3. Update the new color to that index\\n        \\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        \\n        elements = [0] * n # This will simulate the problem\\n        \\n        result = 0  # keeps record of current adjacent element with same color\\n        \\n        array = [] # This array will be our output\\n        \\n        # check function takes \\n            # number of current adjacent element with same color\\n            # earlier color on index we about to change\\n            # index to check = comp_index\\n            # index which will have color change\\n            # color on new index\\n            \\n        def check(result, earlier_color, comp_index, index, color): \\n            \\n            # if the comp_index is in bounds\\n            if 0 <= comp_index < n :\\n                \\n                # check if colored and comp_index has same earlier_color if yes that means the number of adjacent element with same color will be reduced by 1\\n                if earlier_color and elements[comp_index] == earlier_color:\\n                    result-=1\\n                # check if colored and comp_index has same color if yes that means the number of adjacent elements with same color will increase by 1\\n                if color and color == elements[comp_index]:\\n                    result +=1\\n                    \\n            return result\\n            \\n        \\n        for index, color in queries:\\n            earlier_color = elements[index]\\n            # check for previous element\\n            result = check(result, earlier_color, index - 1, index, color)\\n            # check for next element\\n            result = check(result, earlier_color, index + 1, index, color)\\n            \\n            elements[index] = color\\n            \\n            array.append(result)\\n            \\n        return array\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494926,
                "title": "simple-c-solution-easy-maintainance",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vals(n, 0), res;\\n        int ans = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            auto v = queries[i];\\n            int idx = v[0], val = v[1];\\n            if(idx-1>=0 and val == vals[idx-1]) ans++;\\n            if(idx+1<n and val == vals[idx+1]) ans++;\\n            if(idx-1>=0 and vals[idx] == vals[idx-1] and vals[idx] != 0) ans--;\\n            if(idx+1<n and vals[idx] == vals[idx+1] and vals[idx] != 0) ans--;\\n            vals[idx] = val;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vals(n, 0), res;\\n        int ans = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            auto v = queries[i];\\n            int idx = v[0], val = v[1];\\n            if(idx-1>=0 and val == vals[idx-1]) ans++;\\n            if(idx+1<n and val == vals[idx+1]) ans++;\\n            if(idx-1>=0 and vals[idx] == vals[idx-1] and vals[idx] != 0) ans--;\\n            if(idx+1<n and vals[idx] == vals[idx+1] and vals[idx] != 0) ans--;\\n            vals[idx] = val;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080376,
                "title": "simple-2-step-approach-explained-in-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vec(n,0), ans;\\n        int adj = 0;\\n        for(auto it : queries)\\n        {\\n          int index = it[0];\\n          int color = it[1];\\n          \\n          //if the index is already colored\\n          if(vec[index]) \\n          { //decrement adj if current index is same colored as its left or right\\n           adj -= (index > 0 && vec[index-1] == vec[index]) ? 1 : 0;\\n           adj -= (index < n-1 && vec[index+1] == vec[index]) ? 1 : 0;\\n          }\\n\\n          vec[index] = color; //color the current index\\n\\n          //increment adj, if current index becomes same colored as its left or right\\n          adj += (index > 0 && vec[index-1] == color) ? 1 : 0;\\n          adj += (index < n-1 && vec[index+1] == color) ? 1 : 0;  \\n        ans.push_back(adj);\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vec(n,0), ans;\\n        int adj = 0;\\n        for(auto it : queries)\\n        {\\n          int index = it[0];\\n          int color = it[1];\\n          \\n          //if the index is already colored\\n          if(vec[index]) \\n          { //decrement adj if current index is same colored as its left or right\\n           adj -= (index > 0 && vec[index-1] == vec[index]) ? 1 : 0;\\n           adj -= (index < n-1 && vec[index+1] == vec[index]) ? 1 : 0;\\n          }\\n\\n          vec[index] = color; //color the current index\\n\\n          //increment adj, if current index becomes same colored as its left or right\\n          adj += (index > 0 && vec[index-1] == color) ? 1 : 0;\\n          adj += (index < n-1 && vec[index+1] == color) ? 1 : 0;  \\n        ans.push_back(adj);\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930234,
                "title": "c-solution-using-just-count-variable-easy-peasy",
                "content": "# Intuition\\nWe just need to maintain the count of adjacent element.\\n\\n# Approach\\nChecking if previous and next index contains the same color that we are going to color, then we will increment the count and similarly decrement the count if the same colour was already present.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        int adjCnt = 0;\\n        vector<int> res(queries.size(), 0);\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int idx = queries[i][0], color = queries[i][1];\\n            if(idx - 1 >= 0 && nums[idx - 1] == color) adjCnt++;\\n            if(idx + 1 < n && nums[idx + 1] == color) adjCnt++;\\n            \\n            if(nums[idx] != 0){\\n                if(idx - 1 >= 0 && nums[idx - 1] == nums[idx]) adjCnt--;\\n                if(idx + 1 < n && nums[idx + 1] == nums[idx]) adjCnt--;\\n            }\\n            nums[idx] = color;\\n            res[i] = adjCnt;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        int adjCnt = 0;\\n        vector<int> res(queries.size(), 0);\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int idx = queries[i][0], color = queries[i][1];\\n            if(idx - 1 >= 0 && nums[idx - 1] == color) adjCnt++;\\n            if(idx + 1 < n && nums[idx + 1] == color) adjCnt++;\\n            \\n            if(nums[idx] != 0){\\n                if(idx - 1 >= 0 && nums[idx - 1] == nums[idx]) adjCnt--;\\n                if(idx + 1 < n && nums[idx + 1] == nums[idx]) adjCnt--;\\n            }\\n            nums[idx] = color;\\n            res[i] = adjCnt;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929381,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int m = queries.size();\\n        if(m==1){return {0};} \\n        vector<int> ans(m, 0);\\n        vector<int> clr(n, 0);\\n        int curr = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ind = queries[i][0];\\n            int newc = queries[i][1];\\n            int pm = 0;\\n            if(ind>0){if(newc==clr[ind-1]){pm--;}}\\n            if(ind<n-1){if(newc==clr[ind+1]){pm--;}}\\n            if(clr[ind]!=0)\\n            {\\n                if(ind>0){if(clr[ind]==clr[ind-1]){pm++;}}\\n                if(ind<n-1){if(clr[ind]==clr[ind+1]){pm++;}}\\n            }\\n            curr-=pm;\\n            ans[i]=curr;\\n            clr[queries[i][0]]=queries[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int m = queries.size();\\n        if(m==1){return {0};} \\n        vector<int> ans(m, 0);\\n        vector<int> clr(n, 0);\\n        int curr = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ind = queries[i][0];\\n            int newc = queries[i][1];\\n            int pm = 0;\\n            if(ind>0){if(newc==clr[ind-1]){pm--;}}\\n            if(ind<n-1){if(newc==clr[ind+1]){pm--;}}\\n            if(clr[ind]!=0)\\n            {\\n                if(ind>0){if(clr[ind]==clr[ind-1]){pm++;}}\\n                if(ind<n-1){if(clr[ind]==clr[ind+1]){pm++;}}\\n            }\\n            curr-=pm;\\n            ans[i]=curr;\\n            clr[queries[i][0]]=queries[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903903,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> ans;\\n    vector<int> arr(n);\\n    int sameColors = 0;\\n\\n    for (const vector<int>& query : queries) {\\n      const int i = query[0];\\n      const int color = query[1];\\n      if (i + 1 < n) {\\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\\n          --sameColors;\\n        if (arr[i + 1] == color)\\n          ++sameColors;\\n      }\\n      if (i > 0) {\\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\\n          --sameColors;\\n        if (arr[i - 1] == color)\\n          ++sameColors;\\n      }\\n      arr[i] = color;\\n      ans.push_back(sameColors);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> ans;\\n    vector<int> arr(n);\\n    int sameColors = 0;\\n\\n    for (const vector<int>& query : queries) {\\n      const int i = query[0];\\n      const int color = query[1];\\n      if (i + 1 < n) {\\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\\n          --sameColors;\\n        if (arr[i + 1] == color)\\n          ++sameColors;\\n      }\\n      if (i > 0) {\\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\\n          --sameColors;\\n        if (arr[i - 1] == color)\\n          ++sameColors;\\n      }\\n      arr[i] = color;\\n      ans.push_back(sameColors);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898463,
                "title": "c-easy-clean-code-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> v,a(n,0);\\n        int c=0;\\n        map<int,int> p;\\n        for(auto i : q)\\n        {     \\n              if(p[i[0]]>0)\\n              {\\n                if(i[0]-1>=0 && a[i[0]]==a[i[0]-1])\\n                c--;\\n                if(i[0]+1<n && a[i[0]]==a[i[0]+1])\\n                c--;\\n              }\\n\\n               a[i[0]]=i[1];\\n               p[i[0]]++;\\n               if(i[0]-1>=0 && i[1]==a[i[0]-1])\\n                c++;\\n               if(i[0]+1<n && i[1]==a[i[0]+1])\\n                c++;\\n               v.push_back(c);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> v,a(n,0);\\n        int c=0;\\n        map<int,int> p;\\n        for(auto i : q)\\n        {     \\n              if(p[i[0]]>0)\\n              {\\n                if(i[0]-1>=0 && a[i[0]]==a[i[0]-1])\\n                c--;\\n                if(i[0]+1<n && a[i[0]]==a[i[0]+1])\\n                c--;\\n              }\\n\\n               a[i[0]]=i[1];\\n               p[i[0]]++;\\n               if(i[0]-1>=0 && i[1]==a[i[0]-1])\\n                c++;\\n               if(i[0]+1<n && i[1]==a[i[0]+1])\\n                c++;\\n               v.push_back(c);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886278,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ q: [[Int]]) -> [Int] {\\n\\n        var n = Array(repeating: 0, count: n)\\n        var r = [Int]()\\n\\n        for q in q {\\n            r.append(r.last ?? 0)\\n\\n            if n[q[0]] != 0 {\\n                if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] -= 1 }\\n                if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] -= 1 }\\n            }\\n            \\n            n[q[0]] = q[1]\\n            \\n            if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] += 1 }\\n            if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] += 1 }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ q: [[Int]]) -> [Int] {\\n\\n        var n = Array(repeating: 0, count: n)\\n        var r = [Int]()\\n\\n        for q in q {\\n            r.append(r.last ?? 0)\\n\\n            if n[q[0]] != 0 {\\n                if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] -= 1 }\\n                if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] -= 1 }\\n            }\\n            \\n            n[q[0]] = q[1]\\n            \\n            if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] += 1 }\\n            if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] += 1 }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884459,
                "title": "my-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840996,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int size=queries.size();\\n        vector<int>ans(size,0);\\n        if(n==1) return ans;\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            int j=queries[i][0];\\n            int clr=queries[i][1];\\n            // check if it is alreay colored or not\\n            if(v[j]!=0){\\n                if(j==0) {\\n                   if(v[0]==v[1]) count--;\\n                }    \\n                else if(j==n-1){\\n                  if(v[n-2]==v[n-1]) count--;\\n                }  \\n                else{\\n                    if(v[j+1]==v[j]) count--;\\n                    if(v[j-1]==v[j]) count--;\\n                }\\n            }\\n            v[j]=clr;\\n            // conditions for adjacent elements\\n                if(j==0) {\\n                    if(v[0]==v[1]) count++;\\n                }\\n                else if(j==n-1){\\n                    if(v[n-2]==v[n-1]) count++;\\n                }    \\n                else{\\n                    if(v[j+1]==v[j]) count++;\\n                    if(v[j-1]==v[j]) count++;\\n                }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int size=queries.size();\\n        vector<int>ans(size,0);\\n        if(n==1) return ans;\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            int j=queries[i][0];\\n            int clr=queries[i][1];\\n            // check if it is alreay colored or not\\n            if(v[j]!=0){\\n                if(j==0) {\\n                   if(v[0]==v[1]) count--;\\n                }    \\n                else if(j==n-1){\\n                  if(v[n-2]==v[n-1]) count--;\\n                }  \\n                else{\\n                    if(v[j+1]==v[j]) count--;\\n                    if(v[j-1]==v[j]) count--;\\n                }\\n            }\\n            v[j]=clr;\\n            // conditions for adjacent elements\\n                if(j==0) {\\n                    if(v[0]==v[1]) count++;\\n                }\\n                else if(j==n-1){\\n                    if(v[n-2]==v[n-1]) count++;\\n                }    \\n                else{\\n                    if(v[j+1]==v[j]) count++;\\n                    if(v[j-1]==v[j]) count++;\\n                }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808813,
                "title": "easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        if(n == 1){\\n            return new int[q.length];\\n        }\\n\\n        int[] ans = new int[q.length];\\n        int[] color = new int[n];\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < q.length; i++){\\n            int ind = q[i][0];\\n            int assColor = q[i][1];\\n\\n            int leftColor = 0;\\n            int rytColor = 0;\\n\\n            if(ind - 1 >= 0){\\n                leftColor = color[ind - 1];\\n            }\\n            if(ind + 1 < n){\\n                rytColor = color[ind + 1];\\n            }\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt--;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt--;\\n            }\\n\\n            color[ind] = assColor;\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt++;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt++;\\n            }\\n\\n            ans[i] = cnt;\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        if(n == 1){\\n            return new int[q.length];\\n        }\\n\\n        int[] ans = new int[q.length];\\n        int[] color = new int[n];\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < q.length; i++){\\n            int ind = q[i][0];\\n            int assColor = q[i][1];\\n\\n            int leftColor = 0;\\n            int rytColor = 0;\\n\\n            if(ind - 1 >= 0){\\n                leftColor = color[ind - 1];\\n            }\\n            if(ind + 1 < n){\\n                rytColor = color[ind + 1];\\n            }\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt--;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt--;\\n            }\\n\\n            color[ind] = assColor;\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt++;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt++;\\n            }\\n\\n            ans[i] = cnt;\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769748,
                "title": "segment-trees-unique-solution-different-approach",
                "content": "# Intuition\\nPerformed update and query operation in O(log n) using segment Tree\\n\\n# Approach\\nCompared mid and mid+1 while doing point update\\n\\n# Complexity\\n- Time complexity:\\no(QlogN)\\n\\n- Space complexity:\\nO(N)\\nNote: Reinitialize global variables to avoid unnecesary test case failure\\n# Code\\n```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769747,
                "title": "segment-trees-unique-solution-different-approach",
                "content": "# Intuition\\nPerformed update and query operation in O(log n) using segment Tree\\n\\n# Approach\\nCompared mid and mid+1 while doing point update\\n\\n# Complexity\\n- Time complexity:\\no(QlogN)\\n\\n- Space complexity:\\nO(N)\\nNote: Reinitialize global variables to avoid unnecesary test case failure\\n# Code\\n```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3765648,
                "title": "as-simple-as-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int q=queries.size();\\n        vector<int> ans(q,0);\\n        int curr=0,i;\\n        vector<int> mat(n,0);\\n        for(i=0;i<q;i++){\\n            int a=queries[i][0],b=queries[i][1];\\n            if(mat[a]==b){ ans[i]=curr;continue;}\\n            if(a-1>=0 && mat[a]!=0 && mat[a]==mat[a-1]) curr--; \\n            if(a+1<n && mat[a]!=0 && mat[a]==mat[a+1]) curr--;\\n            if(a-1>=0 && b==mat[a-1]) curr++;\\n            if(a+1<n && b==mat[a+1]) curr++;\\n            mat[a]=b;\\n            ans[i]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int q=queries.size();\\n        vector<int> ans(q,0);\\n        int curr=0,i;\\n        vector<int> mat(n,0);\\n        for(i=0;i<q;i++){\\n            int a=queries[i][0],b=queries[i][1];\\n            if(mat[a]==b){ ans[i]=curr;continue;}\\n            if(a-1>=0 && mat[a]!=0 && mat[a]==mat[a-1]) curr--; \\n            if(a+1<n && mat[a]!=0 && mat[a]==mat[a+1]) curr--;\\n            if(a-1>=0 && b==mat[a-1]) curr++;\\n            if(a+1<n && b==mat[a+1]) curr++;\\n            mat[a]=b;\\n            ans[i]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756437,
                "title": "the-easiest-and-the-most-elaborate-java-code",
                "content": "# Complexity\\n- Time complexity: O ( N )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O ( N )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] query) {\\n        int []a = new int [query.length];\\n        int []nums = new int[n];\\n        int answer=0;\\n        for (int i=0;i<query.length;i++)\\n        {\\n            int preadjacency=0;\\n            int curradjacency=0;\\n\\n            int index=query[i][0];\\n            int colornow= query[i][1];\\n            int colorpre=nums[index];\\n\\n            if (nums[index]!=0)\\n            {\\n                int left=0;\\n                int right=0;\\n                if (index-1>=0)\\n                left= (nums[index-1]==nums[index])? 1:0;\\n                if (index+1<nums.length)\\n                right= (nums[index+1]==nums[index])? 1:0;\\n\\n                preadjacency=left+right;\\n            }\\n            nums[index]=colornow;\\n            int l=0;\\n            int r=0;\\n            if (index-1>=0)\\n            l = (nums[index-1]==nums[index])? 1:0;\\n            if (index+1<nums.length)\\n            r= (nums[index+1]==nums[index])? 1:0;\\n            curradjacency=l+r;\\n\\n            answer+= curradjacency-preadjacency;\\n            a[i]=answer;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] query) {\\n        int []a = new int [query.length];\\n        int []nums = new int[n];\\n        int answer=0;\\n        for (int i=0;i<query.length;i++)\\n        {\\n            int preadjacency=0;\\n            int curradjacency=0;\\n\\n            int index=query[i][0];\\n            int colornow= query[i][1];\\n            int colorpre=nums[index];\\n\\n            if (nums[index]!=0)\\n            {\\n                int left=0;\\n                int right=0;\\n                if (index-1>=0)\\n                left= (nums[index-1]==nums[index])? 1:0;\\n                if (index+1<nums.length)\\n                right= (nums[index+1]==nums[index])? 1:0;\\n\\n                preadjacency=left+right;\\n            }\\n            nums[index]=colornow;\\n            int l=0;\\n            int r=0;\\n            if (index-1>=0)\\n            l = (nums[index-1]==nums[index])? 1:0;\\n            if (index+1<nums.length)\\n            r= (nums[index+1]==nums[index])? 1:0;\\n            curradjacency=l+r;\\n\\n            answer+= curradjacency-preadjacency;\\n            a[i]=answer;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755916,
                "title": "straight-forward-c-solution-easy-code",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0), result;\\n        int c = 0;\\n    \\n        for (auto query : queries) {\\n            int index = query[0], color = query[1];\\n            int pre = (index > 0) ? nums[index - 1] : 0;\\n            int nex = (index < n-1) ? nums[index + 1] : 0;\\n    \\n            if (nums[index] && nums[index] == pre) c--;\\n            if (nums[index] && nums[index] == nex) c--;\\n            nums[index] = color;\\n            if (nums[index] == pre) c++;\\n            if (nums[index] == nex) c++;\\n    \\n            result.push_back(c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0), result;\\n        int c = 0;\\n    \\n        for (auto query : queries) {\\n            int index = query[0], color = query[1];\\n            int pre = (index > 0) ? nums[index - 1] : 0;\\n            int nex = (index < n-1) ? nums[index + 1] : 0;\\n    \\n            if (nums[index] && nums[index] == pre) c--;\\n            if (nums[index] && nums[index] == nex) c--;\\n            nums[index] = color;\\n            if (nums[index] == pre) c++;\\n            if (nums[index] == nex) c++;\\n    \\n            result.push_back(c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694959,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        var arr = new int[n];\\n        var res = new int[queries.Length];\\n        var count = 0;\\n        for(var i = 0; i < queries.Length; i++){\\n            res[i] = count;\\n            var pre = arr[queries[i][0]];\\n            var cur = queries[i][1];\\n            arr[queries[i][0]] =  cur;\\n            var leftIndex = queries[i][0] - 1;\\n            var rightIndex = queries[i][0] + 1;\\n            if(pre == cur) continue;\\n            if(pre != 0 && leftIndex >= 0 && pre == arr[leftIndex])\\n                res[i]--;\\n            if(pre != 0 && rightIndex <= arr.Length - 1 && pre == arr[rightIndex])\\n                res[i]--;\\n            if(cur != 0  && leftIndex >= 0 && cur == arr[leftIndex])\\n                res[i]++;\\n            if(cur != 0 && rightIndex <= arr.Length - 1 && cur == arr[rightIndex])\\n                res[i]++;\\n            count = res[i];\\n        } \\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        var arr = new int[n];\\n        var res = new int[queries.Length];\\n        var count = 0;\\n        for(var i = 0; i < queries.Length; i++){\\n            res[i] = count;\\n            var pre = arr[queries[i][0]];\\n            var cur = queries[i][1];\\n            arr[queries[i][0]] =  cur;\\n            var leftIndex = queries[i][0] - 1;\\n            var rightIndex = queries[i][0] + 1;\\n            if(pre == cur) continue;\\n            if(pre != 0 && leftIndex >= 0 && pre == arr[leftIndex])\\n                res[i]--;\\n            if(pre != 0 && rightIndex <= arr.Length - 1 && pre == arr[rightIndex])\\n                res[i]--;\\n            if(cur != 0  && leftIndex >= 0 && cur == arr[leftIndex])\\n                res[i]++;\\n            if(cur != 0 && rightIndex <= arr.Length - 1 && cur == arr[rightIndex])\\n                res[i]++;\\n            count = res[i];\\n        } \\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671721,
                "title": "c-query-and-count",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> v(n),ans;\\n        for(auto &i:queries){\\n            if(v[i[0]] && i[0]>0 && v[i[0]]==v[i[0]-1])--c;\\n            if(v[i[0]] && i[0]<n-1 && v[i[0]]==v[i[0]+1])--c;\\n            v[i[0]]=i[1];\\n            if(i[0]>0 && v[i[0]]==v[i[0]-1])++c;\\n            if(i[0]<n-1 && v[i[0]]==v[i[0]+1])++c;\\n            ans.emplace_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> v(n),ans;\\n        for(auto &i:queries){\\n            if(v[i[0]] && i[0]>0 && v[i[0]]==v[i[0]-1])--c;\\n            if(v[i[0]] && i[0]<n-1 && v[i[0]]==v[i[0]+1])--c;\\n            v[i[0]]=i[1];\\n            if(i[0]>0 && v[i[0]]==v[i[0]-1])++c;\\n            if(i[0]<n-1 && v[i[0]]==v[i[0]+1])++c;\\n            ans.emplace_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667859,
                "title": "number-of-adjacent-elements-with-the-same-color-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>col(n,0);\\n        vector<int>ans;\\n        long long int t = 0;\\n        long long int idx = queries[0][0];\\n        long long int color = queries[0][1];\\n        col[idx] = color;\\n        ans.push_back(0);\\n        long long int x = 0;\\n\\n        for(long long int i = 1; i<queries.size(); i++)\\n        {\\n            long long int idx = queries[i][0];\\n            long long int color = queries[i][1];\\n            x = 0;\\n            if(col[idx]!=0 and idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(col[idx]!=0 and idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            //cout<<x<<endl;\\n            t = t-x;\\n            col[idx] = color;\\n\\n            x = 0;\\n            if(idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            t = t+x;\\n            //cout<<x<<endl;\\n            ans.push_back(t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>col(n,0);\\n        vector<int>ans;\\n        long long int t = 0;\\n        long long int idx = queries[0][0];\\n        long long int color = queries[0][1];\\n        col[idx] = color;\\n        ans.push_back(0);\\n        long long int x = 0;\\n\\n        for(long long int i = 1; i<queries.size(); i++)\\n        {\\n            long long int idx = queries[i][0];\\n            long long int color = queries[i][1];\\n            x = 0;\\n            if(col[idx]!=0 and idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(col[idx]!=0 and idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            //cout<<x<<endl;\\n            t = t-x;\\n            col[idx] = color;\\n\\n            x = 0;\\n            if(idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            t = t+x;\\n            //cout<<x<<endl;\\n            ans.push_back(t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3641655,
                "title": "c-simple-observations-simple-implementation-starightforward-o-k-queries-size-1-k-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int>nums(n,0);\\n        int prev=0;\\n        int sz=queries.size();\\n        for(int x=0;x<sz;x++){\\n            int curr=0;\\n            int idx=queries[x][0];\\n            int colour=queries[x][1];\\n            int prevcolour=nums[idx];\\n            if(nums[idx]==colour){\\n                curr+=0;\\n                curr+=prev;\\n                ans.push_back(curr);\\n                prev=curr;\\n                nums[idx]=colour;\\n            }\\n            else{\\n                int sub=0;\\n         if((idx-1)>=0 and (idx)<=(n-1) and nums[idx]==nums[idx-1] and nums[idx]!=0)sub++;\\n         if((idx+1)<=(n-1) and idx>=0 and (nums[idx+1]==nums[idx]) and nums[idx]!=0)sub++;\\n        nums[idx]=colour;\\n        if((idx-1)>=0 and (idx)<=n-1 and nums[idx]==nums[idx-1] and nums[idx]!=0)curr++;\\n         if(idx>=0 and (idx+1)<=(n-1) and nums[idx]==nums[idx+1] and nums[idx]!=0)curr++;\\n                curr+=prev;\\n                curr-=sub;\\n                ans.push_back(curr);\\n                prev=curr;\\n            }\\n        }\\n        for(auto x:ans)cout<<x<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int>nums(n,0);\\n        int prev=0;\\n        int sz=queries.size();\\n        for(int x=0;x<sz;x++){\\n            int curr=0;\\n            int idx=queries[x][0];\\n            int colour=queries[x][1];\\n            int prevcolour=nums[idx];\\n            if(nums[idx]==colour){\\n                curr+=0;\\n                curr+=prev;\\n                ans.push_back(curr);\\n                prev=curr;\\n                nums[idx]=colour;\\n            }\\n            else{\\n                int sub=0;\\n         if((idx-1)>=0 and (idx)<=(n-1) and nums[idx]==nums[idx-1] and nums[idx]!=0)sub++;\\n         if((idx+1)<=(n-1) and idx>=0 and (nums[idx+1]==nums[idx]) and nums[idx]!=0)sub++;\\n        nums[idx]=colour;\\n        if((idx-1)>=0 and (idx)<=n-1 and nums[idx]==nums[idx-1] and nums[idx]!=0)curr++;\\n         if(idx>=0 and (idx+1)<=(n-1) and nums[idx]==nums[idx+1] and nums[idx]!=0)curr++;\\n                curr+=prev;\\n                curr-=sub;\\n                ans.push_back(curr);\\n                prev=curr;\\n            }\\n        }\\n        for(auto x:ans)cout<<x<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3635438,
                "title": "golang-simple-solution-check-left-and-right",
                "content": "# Code\\n```\\nfunc colorTheArray(n int, queries [][]int) []int {\\n  arr := make([]int, n)\\n  answer := make([]int, len(queries))\\n  var cnt int\\n  for i, query := range queries {\\n    idx, col := query[0], query[1]\\n    if arr[idx] == col {\\n      answer[i] = cnt\\n      continue // no change\\n    }\\n    if idx > 0 {\\n      if arr[idx-1] == col {\\n        // New color can be paired up with left\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx-1] == arr[idx] {\\n        // Previous color was contributing to left previously; not anymore\\n        cnt--\\n      }\\n    }\\n    if idx < n-1 {\\n      if arr[idx+1] == col {\\n        // New color can be paired with right\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx+1] == arr[idx] {\\n        // Previous color was contributing to right previously; not anymore\\n        cnt--\\n      }\\n    }\\n    arr[idx] = col // update the color\\n    answer[i] = cnt // set the answer for the current query\\n  }\\n  return answer\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc colorTheArray(n int, queries [][]int) []int {\\n  arr := make([]int, n)\\n  answer := make([]int, len(queries))\\n  var cnt int\\n  for i, query := range queries {\\n    idx, col := query[0], query[1]\\n    if arr[idx] == col {\\n      answer[i] = cnt\\n      continue // no change\\n    }\\n    if idx > 0 {\\n      if arr[idx-1] == col {\\n        // New color can be paired up with left\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx-1] == arr[idx] {\\n        // Previous color was contributing to left previously; not anymore\\n        cnt--\\n      }\\n    }\\n    if idx < n-1 {\\n      if arr[idx+1] == col {\\n        // New color can be paired with right\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx+1] == arr[idx] {\\n        // Previous color was contributing to right previously; not anymore\\n        cnt--\\n      }\\n    }\\n    arr[idx] = col // update the color\\n    answer[i] = cnt // set the answer for the current query\\n  }\\n  return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632279,
                "title": "simple-easy-to-understand-maintaining-the-count-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust maintain the count of equal adjacent elements .\\nAlso remember adjacent means both ahead and behind, so we will check both.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int ct=0;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int index=queries[i][0];\\n            int color=queries[i][1];\\n            if(index-1>=0){\\n                if(v[index-1]==color && v[index-1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index-1] == v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            if(index+1<n){\\n                if(v[index+1]==color && v[index+1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index+1]==v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            v[index]=color;\\n            ans.push_back(ct);\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int ct=0;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int index=queries[i][0];\\n            int color=queries[i][1];\\n            if(index-1>=0){\\n                if(v[index-1]==color && v[index-1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index-1] == v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            if(index+1<n){\\n                if(v[index+1]==color && v[index+1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index+1]==v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            v[index]=color;\\n            ans.push_back(ct);\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628213,
                "title": "easy-to-understand-basic-code-simplest-code-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust keep track of the temporary state of the array and have a variable storing the adjacent count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<--N---i----N-->\\nassume N elements of same color on left and n elements of same color on right and now you put an element at i at the middle joining this chain.\\n\\nWhat would be the new adjacent count?\\nsoln. previous_adjacent_count + 2.\\n\\nWhat if the situation was like - <---N--i > \\nSoln. previous_adjacent_count + 1.\\n\\n\\nNow one case left : we change the color of the element at index i?\\nSoln Just decrease like we increased earlier.\\n \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v(n,0); // stores the temporary states of the vector.\\n        int temp = 0;\\n        vector<int>res;\\n\\n        for(int i = 0 ;i < queries.size() ;i++){\\n\\n            int ind = queries[i][0]; // query at index ind\\n            int col = queries[i][1]; // query for color col.\\n\\n            // decrease the temp count if there exists  similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] &&v[ind] != 0 )temp--; // left side same but not 0\\n            if(ind != n-1 && v[ind+1] == v[ind]&&v[ind] != 0 )temp--; // right side same but not 0\\n\\n            v[ind] = col; // change the color.\\n\\n            // increase the temp count if there exists new similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] )temp++; // left same\\n            if(ind != n-1 && v[ind+1] == v[ind])temp++; // right same\\n\\n            res.push_back(temp);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v(n,0); // stores the temporary states of the vector.\\n        int temp = 0;\\n        vector<int>res;\\n\\n        for(int i = 0 ;i < queries.size() ;i++){\\n\\n            int ind = queries[i][0]; // query at index ind\\n            int col = queries[i][1]; // query for color col.\\n\\n            // decrease the temp count if there exists  similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] &&v[ind] != 0 )temp--; // left side same but not 0\\n            if(ind != n-1 && v[ind+1] == v[ind]&&v[ind] != 0 )temp--; // right side same but not 0\\n\\n            v[ind] = col; // change the color.\\n\\n            // increase the temp count if there exists new similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] )temp++; // left same\\n            if(ind != n-1 && v[ind+1] == v[ind])temp++; // right same\\n\\n            res.push_back(temp);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617189,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603948,
                "title": "simple-if-else-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        vector<int> nums(n,0);\\n        vector<int> ans(m,0);\\n        int count=0;\\n\\n        for(int i=0;i<m;i++){\\n            int flag=0;\\n\\n            int index=q[i][0];\\n            int color=q[i][1];\\n\\n            int x=index+1;\\n            int y=index-1;\\n\\n\\n            \\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    flag++;\\n\\n                }\\n            }\\n            if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                    flag++;\\n                }\\n            }\\n\\n            nums[index]=color;\\n\\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    count++;\\n                }\\n            }\\n             if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                        count++;\\n                }\\n            }\\n\\n            count=count-flag;\\n\\n            ans[i]=count;\\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        vector<int> nums(n,0);\\n        vector<int> ans(m,0);\\n        int count=0;\\n\\n        for(int i=0;i<m;i++){\\n            int flag=0;\\n\\n            int index=q[i][0];\\n            int color=q[i][1];\\n\\n            int x=index+1;\\n            int y=index-1;\\n\\n\\n            \\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    flag++;\\n\\n                }\\n            }\\n            if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                    flag++;\\n                }\\n            }\\n\\n            nums[index]=color;\\n\\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    count++;\\n                }\\n            }\\n             if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                        count++;\\n                }\\n            }\\n\\n            count=count-flag;\\n\\n            ans[i]=count;\\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599619,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586827,
                "title": "super-complicated-solution-mustsee",
                "content": "# Intuition\\nYes,\\nit\\'s time to implement storing of segments of the same color with update query.\\n\\n# Approach\\nWe need to know to which segment a point from a query relates. If all segments are sorted by right side (or left, since they are disjoint), then the first right side that is greater or equal to the given point is a one that is needed. That is exactly what lower_bound is supposed to be. Alternatively, segment of a given point has left side \\'the first greater\\' minus one. Introducing `map<int,int> rl`.\\n\\nNOW (for point `p` and segment `[l, r]` inclusive, when `color[p]!=new_color`):\\n1. l==r. `p` can join two segments (to the left and to the right) into one. `\\n2. l==r. `p` can join to a segment on the right. \\n3. l==r. `p` can join to a segment on the left.\\n4. l==r. `p` might not join anything.\\n5. p==r. `p` can join to a segment on the right.\\n6. p==r. `p` might not join anything.\\n7. p==l. `p` can join to a segment on the left.\\n8. p==l. `p` might not join anything.\\n9. otherwise `p` is in a middle of `[l, r]` and will break it into three pieces.\\n\\nThis cases were created with a thought to be able to update `rl`. So, all things that a given point with a given color can do to a data of `rl`.\\n\\nIf someone knows a better approach to the problem of storing and updating segments with color, a comment is appreciated.\\n\\nA good thing about this problem is that it is a one of easy debug. I\\'m not a person to speak for the programming in a general way, but if I were asked, what is the most important thing about a problem/program, what is the most important aspect, I would answer - complexity of debug, everything else is less time/effort consuming.\\n\\n# Complexity\\n- Time complexity: $$O(q\\\\cdot log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        map<int,int> rl{{n-1, 0}};\\n        vector<int> color(n);\\n        int cnt{};\\n        vector<int> answer;\\n        for(auto q : q){\\n            int p{q[0]}, c{q[1]};\\n            //cout << p << \\' \\' << c << \\':\\' <<\\'\\\\n\\';\\n            //for(auto [_, __] : rl)\\n            //    cout << __ << \\'*\\' << _ << \\' \\';\\n            //cout << \\'\\\\n\\';\\n            if(c!=color[p]){\\n                auto i{rl.lower_bound(p)};\\n                auto [r, l] {*i};\\n                if(r==l){\\n                    if(p<n-1 && p>0 && color[p+1]==color[p-1] && color[p+1]==c){\\n                        auto jl{prev(i)}, jr{next(i)};\\n                        rl.erase(i);\\n                        int L{jl->second}, R{jr->first};\\n                        rl.erase(jl);\\n                        rl.erase(jr);\\n                        rl.insert({R,L});\\n                        cnt += 2;\\n                    }\\n                    else if(p<n-1 && color[p+1]==c){\\n                        auto j{next(i)};\\n                        rl.erase(i);\\n                        --j->second;\\n                        cnt += 1;\\n                    }\\n                    else if(p>0 && color[p-1]==c){\\n                        auto j{prev(i)};\\n                        rl.erase(i);\\n                        auto handle{rl.extract(j)};\\n                        ++handle.key();\\n                        rl.insert(move(handle));\\n                        cnt += 1;\\n                    }\\n                }else if(p==r){\\n                    auto handle{rl.extract(i)};\\n                    --handle.key();\\n                    rl.insert(move(handle));\\n                    if(p<n-1){\\n                        if(color[p+1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{next(i)};\\n                            --j->second;\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p+1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else if(p==l){\\n                    ++i->second;\\n                    if(p>0){\\n                        if(color[p-1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{prev(i)};\\n                            auto handle{rl.extract(j)};\\n                            ++handle.key();\\n                            rl.insert(move(handle));\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p-1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else{\\n                    rl.erase(i);\\n                    rl.insert({p-1,l});\\n                    rl.insert({p,p});\\n                    rl.insert({r,p+1});\\n                    cnt -= 2 * (color[p]>0);\\n                }\\n                color[p] = c;\\n            }\\n            answer.push_back(cnt);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        map<int,int> rl{{n-1, 0}};\\n        vector<int> color(n);\\n        int cnt{};\\n        vector<int> answer;\\n        for(auto q : q){\\n            int p{q[0]}, c{q[1]};\\n            //cout << p << \\' \\' << c << \\':\\' <<\\'\\\\n\\';\\n            //for(auto [_, __] : rl)\\n            //    cout << __ << \\'*\\' << _ << \\' \\';\\n            //cout << \\'\\\\n\\';\\n            if(c!=color[p]){\\n                auto i{rl.lower_bound(p)};\\n                auto [r, l] {*i};\\n                if(r==l){\\n                    if(p<n-1 && p>0 && color[p+1]==color[p-1] && color[p+1]==c){\\n                        auto jl{prev(i)}, jr{next(i)};\\n                        rl.erase(i);\\n                        int L{jl->second}, R{jr->first};\\n                        rl.erase(jl);\\n                        rl.erase(jr);\\n                        rl.insert({R,L});\\n                        cnt += 2;\\n                    }\\n                    else if(p<n-1 && color[p+1]==c){\\n                        auto j{next(i)};\\n                        rl.erase(i);\\n                        --j->second;\\n                        cnt += 1;\\n                    }\\n                    else if(p>0 && color[p-1]==c){\\n                        auto j{prev(i)};\\n                        rl.erase(i);\\n                        auto handle{rl.extract(j)};\\n                        ++handle.key();\\n                        rl.insert(move(handle));\\n                        cnt += 1;\\n                    }\\n                }else if(p==r){\\n                    auto handle{rl.extract(i)};\\n                    --handle.key();\\n                    rl.insert(move(handle));\\n                    if(p<n-1){\\n                        if(color[p+1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{next(i)};\\n                            --j->second;\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p+1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else if(p==l){\\n                    ++i->second;\\n                    if(p>0){\\n                        if(color[p-1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{prev(i)};\\n                            auto handle{rl.extract(j)};\\n                            ++handle.key();\\n                            rl.insert(move(handle));\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p-1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else{\\n                    rl.erase(i);\\n                    rl.insert({p-1,l});\\n                    rl.insert({p,p});\\n                    rl.insert({r,p+1});\\n                    cnt -= 2 * (color[p]>0);\\n                }\\n                color[p] = c;\\n            }\\n            answer.push_back(cnt);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583839,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int freq = 0;\\n        int color[] = new int[n];\\n        int answer[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int col = queries[i][1];\\n            \\n            if(color[index]!=0 && index!=0 && color[index-1]==color[index]){\\n                freq--;\\n            }\\n            if(color[index]!=0 && index!=(n-1) && color[index]==color[index+1]){\\n                freq--;\\n            }\\n            color[index] = col;\\n            if(index!=(n-1) && color[index]==color[index+1]){\\n                freq++;\\n            }\\n            if(index!=0 && color[index]==color[index-1]){\\n                freq++;\\n            }\\n            \\n            answer[i] = freq;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int freq = 0;\\n        int color[] = new int[n];\\n        int answer[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int col = queries[i][1];\\n            \\n            if(color[index]!=0 && index!=0 && color[index-1]==color[index]){\\n                freq--;\\n            }\\n            if(color[index]!=0 && index!=(n-1) && color[index]==color[index+1]){\\n                freq--;\\n            }\\n            color[index] = col;\\n            if(index!=(n-1) && color[index]==color[index+1]){\\n                freq++;\\n            }\\n            if(index!=0 && color[index]==color[index-1]){\\n                freq++;\\n            }\\n            \\n            answer[i] = freq;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561559,
                "title": "easy-best-optimal-code-in-c",
                "content": "\\n# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size = queries.size(), prevAns = 0;\\n        vector<int> nums(n),ans(size);\\n        for(int i = 0; i < size; i++){ \\n            int ind = queries[i][0], color = queries[i][1];\\n            if(nums[ind] != 0){\\n                if(ind - 1 >= 0)\\n                    if(nums[ind] == nums[ind - 1])\\n                        prevAns --;\\n                if(ind + 1 < n)\\n                    if(nums[ind] == nums[ind + 1])\\n                        prevAns --;\\n            }\\n            nums[ind] = color;\\n            if(ind - 1 >= 0)\\n                if(nums[ind] == nums[ind - 1])\\n                    prevAns ++;\\n            if(ind + 1 < n)\\n                if(nums[ind] == nums[ind + 1])\\n                    prevAns ++;\\n            ans[i] = prevAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size = queries.size(), prevAns = 0;\\n        vector<int> nums(n),ans(size);\\n        for(int i = 0; i < size; i++){ \\n            int ind = queries[i][0], color = queries[i][1];\\n            if(nums[ind] != 0){\\n                if(ind - 1 >= 0)\\n                    if(nums[ind] == nums[ind - 1])\\n                        prevAns --;\\n                if(ind + 1 < n)\\n                    if(nums[ind] == nums[ind + 1])\\n                        prevAns --;\\n            }\\n            nums[ind] = color;\\n            if(ind - 1 >= 0)\\n                if(nums[ind] == nums[ind - 1])\\n                    prevAns ++;\\n            if(ind + 1 < n)\\n                if(nums[ind] == nums[ind + 1])\\n                    prevAns ++;\\n            ans[i] = prevAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550080,
                "title": "a-few-solutions",
                "content": "Let the function `f` update the array `A` by assigning the `A[i] = x` along with updating and returning the ongoing total `t` adjacent element count via helper functions `L` and `R` which return true if-and-only-if two adjacent *non-zero* elements exist in `A` to-the-left and to-the-right of index `i` inclusive, ie. `i - 1` and `i + 1` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun colorTheArray(N: Int, updates: Array<IntArray>): IntArray {\\n        var t = 0\\n        var A = IntArray(N) { 0 }\\n        var L = { i: Int -> A[i] != 0 && 0 <= i - 1 && A[i - 1] == A[i] }\\n        var R = { i: Int -> A[i] != 0 && i + 1 < N && A[i] == A[i + 1] }\\n        fun f(i: Int, x: Int): Int {\\n            if (L(i)) --t\\n            if (R(i)) --t\\n            A[i] = x\\n            if (L(i)) ++t\\n            if (R(i)) ++t\\n            return t\\n        }\\n        return updates.map{ (i, x) -> f(i, x) }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet colorTheArray = (N, updates, A = Array(N).fill(0), t = 0) => {\\n    let L = i => A[i] && 0 <= i - 1 && A[i - 1] == A[i],\\n        R = i => A[i] && i + 1 < N && A[i] == A[i + 1];\\n    let f = (i, x) => {\\n        t -= Number(L(i)) + Number(R(i));\\n        A[i] = x;\\n        t += Number(L(i)) + Number(R(i));\\n        return t;\\n    };\\n    return updates.map(([i, x]) => f(i, x));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, updates: List[List[int]], t = 0) -> List[int]:\\n        A = [0] * N\\n        L = lambda i: A[i] and 0 <= i - 1 and A[i - 1] == A[i]\\n        R = lambda i: A[i] and i + 1 < N and A[i] == A[i + 1]\\n        def f(i, x):\\n            nonlocal t\\n            t -= int(L(i)) + int(R(i))\\n            A[i] = x\\n            t += int(L(i)) + int(R(i))\\n            return t\\n        return [f(i, x) for i, x in updates]\\n```\\n\\n*Rust*\\n```\\n// FIXME: we cannot borrow A as immutable and mutable\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn color_the_array(N: i32, updates: VVI) -> VI {\\n        let N = N as usize;\\n        let mut t = 0;\\n        let mut A = vec![0; N];\\n        let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n        let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n        let mut f = (|pair: VI| {\\n            let (i, x) = (pair[0] as usize, pair[1]);\\n            if L(i) { t -= 1; }\\n            if R(i) { t -= 1; }\\n            A[i] = x;\\n            if L(i) { t += 1; }\\n            if R(i) { t += 1; }\\n            t\\n        });\\n        updates.into_iter().map(|pair| f(pair)).collect::<VI>()\\n    }\\n}\\n/*\\nLine 10, Char 22: cannot borrow `A` as mutable because it is also borrowed as immutable (solution.rs)\\n   |\\n8  |         let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n   |                  --- - first borrow occurs due to use of `A` in closure\\n   |                  |\\n   |                  immutable borrow occurs here\\n9 |         let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n10 |         let mut f = (|pair: VI| {\\n   |                      ^^^^^^^^^^ mutable borrow occurs here\\n11 |             let (i, x) = (pair[0] as usize, pair[1]);\\n12 |             if L(i) { t -= 1; }\\n   |                - immutable borrow later captured here by closure\\n13 |             if R(i) { t -= 1; }\\n14 |             A[i] = x;\\n   |             - second borrow occurs due to use of `A` in closure\\nFor more information about this error, try `rustc --explain E0502`.\\nerror: could not compile `prog` due to previous error\\nmv: cannot stat \\'/leetcode/rust_compile/target/release/prog\\': No such file or directory\\n*/\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI colorTheArray(int N, VVI& updates, int t = 0, VI ans = {}) {\\n        auto A = VI(N);\\n        auto L = [&](auto i) { return A[i] && 0 <= i - 1 && A[i - 1] == A[i]; }; \\n        auto R = [&](auto i) { return A[i] && i + 1 < N && A[i] == A[i + 1]; };\\n        auto f = [&](auto i, auto x) {\\n            t -= int(L(i)) + int(R(i));\\n            A[i] = x;\\n            t += int(L(i)) + int(R(i));\\n            return t;\\n        };\\n        transform(updates.begin(), updates.end(), back_inserter(ans), [&](auto& pair) { return f(pair[0], pair[1]); });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun colorTheArray(N: Int, updates: Array<IntArray>): IntArray {\\n        var t = 0\\n        var A = IntArray(N) { 0 }\\n        var L = { i: Int -> A[i] != 0 && 0 <= i - 1 && A[i - 1] == A[i] }\\n        var R = { i: Int -> A[i] != 0 && i + 1 < N && A[i] == A[i + 1] }\\n        fun f(i: Int, x: Int): Int {\\n            if (L(i)) --t\\n            if (R(i)) --t\\n            A[i] = x\\n            if (L(i)) ++t\\n            if (R(i)) ++t\\n            return t\\n        }\\n        return updates.map{ (i, x) -> f(i, x) }.toIntArray()\\n    }\\n}\\n```\n```\\nlet colorTheArray = (N, updates, A = Array(N).fill(0), t = 0) => {\\n    let L = i => A[i] && 0 <= i - 1 && A[i - 1] == A[i],\\n        R = i => A[i] && i + 1 < N && A[i] == A[i + 1];\\n    let f = (i, x) => {\\n        t -= Number(L(i)) + Number(R(i));\\n        A[i] = x;\\n        t += Number(L(i)) + Number(R(i));\\n        return t;\\n    };\\n    return updates.map(([i, x]) => f(i, x));\\n};\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, updates: List[List[int]], t = 0) -> List[int]:\\n        A = [0] * N\\n        L = lambda i: A[i] and 0 <= i - 1 and A[i - 1] == A[i]\\n        R = lambda i: A[i] and i + 1 < N and A[i] == A[i + 1]\\n        def f(i, x):\\n            nonlocal t\\n            t -= int(L(i)) + int(R(i))\\n            A[i] = x\\n            t += int(L(i)) + int(R(i))\\n            return t\\n        return [f(i, x) for i, x in updates]\\n```\n```\\n// FIXME: we cannot borrow A as immutable and mutable\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn color_the_array(N: i32, updates: VVI) -> VI {\\n        let N = N as usize;\\n        let mut t = 0;\\n        let mut A = vec![0; N];\\n        let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n        let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n        let mut f = (|pair: VI| {\\n            let (i, x) = (pair[0] as usize, pair[1]);\\n            if L(i) { t -= 1; }\\n            if R(i) { t -= 1; }\\n            A[i] = x;\\n            if L(i) { t += 1; }\\n            if R(i) { t += 1; }\\n            t\\n        });\\n        updates.into_iter().map(|pair| f(pair)).collect::<VI>()\\n    }\\n}\\n/*\\nLine 10, Char 22: cannot borrow `A` as mutable because it is also borrowed as immutable (solution.rs)\\n   |\\n8  |         let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n   |                  --- - first borrow occurs due to use of `A` in closure\\n   |                  |\\n   |                  immutable borrow occurs here\\n9 |         let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n10 |         let mut f = (|pair: VI| {\\n   |                      ^^^^^^^^^^ mutable borrow occurs here\\n11 |             let (i, x) = (pair[0] as usize, pair[1]);\\n12 |             if L(i) { t -= 1; }\\n   |                - immutable borrow later captured here by closure\\n13 |             if R(i) { t -= 1; }\\n14 |             A[i] = x;\\n   |             - second borrow occurs due to use of `A` in closure\\nFor more information about this error, try `rustc --explain E0502`.\\nerror: could not compile `prog` due to previous error\\nmv: cannot stat \\'/leetcode/rust_compile/target/release/prog\\': No such file or directory\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI colorTheArray(int N, VVI& updates, int t = 0, VI ans = {}) {\\n        auto A = VI(N);\\n        auto L = [&](auto i) { return A[i] && 0 <= i - 1 && A[i - 1] == A[i]; }; \\n        auto R = [&](auto i) { return A[i] && i + 1 < N && A[i] == A[i + 1]; };\\n        auto f = [&](auto i, auto x) {\\n            t -= int(L(i)) + int(R(i));\\n            A[i] = x;\\n            t += int(L(i)) + int(R(i));\\n            return t;\\n        };\\n        transform(updates.begin(), updates.end(), back_inserter(ans), [&](auto& pair) { return f(pair[0], pair[1]); });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542799,
                "title": "faster-than-98-just-a-bunch-of-ifs",
                "content": "# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        col = [0] * (n+1)  # to make sure ends are accounted for\\n        ret = []\\n        cur = 0\\n        for i, c in queries:\\n            if c != col[i]:\\n                # removal:\\n                if col[i] != 0:\\n                    if col[i-1] == col[i]:\\n                        cur -= 1\\n                    if col[i+1] == col[i]:\\n                        cur -= 1\\n                # addition\\n                if col[i-1] == c:\\n                    cur += 1\\n                if col[i+1] == c:\\n                    cur += 1\\n            ret.append(cur)\\n            col[i] = c\\n        return ret\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        col = [0] * (n+1)  # to make sure ends are accounted for\\n        ret = []\\n        cur = 0\\n        for i, c in queries:\\n            if c != col[i]:\\n                # removal:\\n                if col[i] != 0:\\n                    if col[i-1] == col[i]:\\n                        cur -= 1\\n                    if col[i+1] == col[i]:\\n                        cur -= 1\\n                # addition\\n                if col[i-1] == c:\\n                    cur += 1\\n                if col[i+1] == c:\\n                    cur += 1\\n            ret.append(cur)\\n            col[i] = c\\n        return ret\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541643,
                "title": "python-explained-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt iteration of from Queries , we are provided the index of element of array to color and the color . After each iteration of Queries we have to cheak how element have same color value as of it\\'s adjacent element .\\nStore the above and return Array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have are inserting only one element at a time , it will only effect it\\'s adjacent element not the whole array .\\nSo instead of monitoring the whole array after each iteration , we will just monitor the effect of insertion on adjacent element . \\nFor Example\\n```\\narr=[1,2,3,2,1]\\nQuery=[2,2]\\n```\\nSo we have to insert Color 2 at index 2 \\nInitially there are 0 pairs with same color .\\nSo we will just see if the index we are updating have any adjacent element with same color value .\\n[ No in above example as 2!=3 and 3!=2 ]\\nIf yes and we are updating the index with different value then that pairs will no longer there so we will subtract 1 from previos result for each pair (maximum -2 as it can have only 2 adjacent element).\\n\\nNow we will cheak if new color value have any adjacent element with same value . In case we found any we will add 1 for each pair(maximum 2 ) in previous result.\\n[Yes Inserting 2 in place of 3 will give as two pairs at index (1,2) and (2,3) so we add 2 in previos result i.e. 0+2==> 2 and this is our answer]\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(n+len(queries))$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        out=[0]*len(queries)\\n        op=[0]*n\\n        i=1\\n        for i in range(len(queries)):\\n            query=queries[i]\\n            if i>0:\\n                out[i]=out[i-1]\\n            if query[0]!=n-1:\\n                if op[query[0]+1] != op[query[0]] and op[query[0]+1]==query[1] and op[query[0]+1]!=0:\\n                    out[i]+=1\\n                if op[query[0]+1] == op[query[0]] and op[query[0]+1]!=query[1] and op[query[0]+1]!=0:\\n                    out[i]-=1\\n            if query[0]!=0:\\n                if op[query[0]-1] != op[query[0]] and op[query[0]-1]==query[1] and op[query[0]-1]!=0:\\n                    out[i]+=1\\n                if op[query[0]-1] == op[query[0]] and op[query[0]-1]!=query[1] and op[query[0]-1]!=0:\\n                    out[i]-=1\\n            op[query[0]]=query[1]\\n        return out\\n            \\n            \\n                \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\narr=[1,2,3,2,1]\\nQuery=[2,2]\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        out=[0]*len(queries)\\n        op=[0]*n\\n        i=1\\n        for i in range(len(queries)):\\n            query=queries[i]\\n            if i>0:\\n                out[i]=out[i-1]\\n            if query[0]!=n-1:\\n                if op[query[0]+1] != op[query[0]] and op[query[0]+1]==query[1] and op[query[0]+1]!=0:\\n                    out[i]+=1\\n                if op[query[0]+1] == op[query[0]] and op[query[0]+1]!=query[1] and op[query[0]+1]!=0:\\n                    out[i]-=1\\n            if query[0]!=0:\\n                if op[query[0]-1] != op[query[0]] and op[query[0]-1]==query[1] and op[query[0]-1]!=0:\\n                    out[i]+=1\\n                if op[query[0]-1] == op[query[0]] and op[query[0]-1]!=query[1] and op[query[0]-1]!=0:\\n                    out[i]-=1\\n            op[query[0]]=query[1]\\n        return out\\n            \\n            \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538726,
                "title": "java-c-o-n-solution-with-in-depth-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to run the queries, for every query we need to iterate the nums and check the how many adjacent colors\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook carefully: for the above intuition take n^2 time we need to optimize the iteration of the nums to check adj color \\n\\nFor that we need to write preprocessing kind of code it will help you to get adj color in O(1) time\\n\\n- Before update, 1st check nums [i-1] == [i] or [i+1] == [i] if it is adjacent present we need to decrease in samecolor\\n- After update, again check nums [i-1] == [i] or [i+1] == [i] if it is adjacent present increase the samecolor\\n\\nAt last store answer[i] = scolor and return\\uD83D\\uDE42\\n\\nUpvote if it is helpfull\\uD83E\\uDD18\\n\\n# Complexity\\n- Time complexity: O(q) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(q)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nq - length of the queries\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int nums[] = new int[n];\\n        int q = queries.length;\\n        int answer[] = new int[q];\\n        int scolor = 0;\\n        for(int i = 0; i<q; i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            int dcolor = 0;\\n            if(nums[index] != 0){\\n                if(index > 0 && nums[index]==nums[index-1]) dcolor++;\\n                if(index < n-1 && nums[index] == nums[index+1]) dcolor++;\\n            }\\n            nums[index] = color;\\n            if(index > 0 && nums[index]==nums[index-1]) scolor += 1;\\n            if(index < n-1 && nums[index] == nums[index+1]) scolor += 1;\\n            scolor -= dcolor;\\n            answer[i] = scolor;\\n        }\\n\\n        return answer;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int nums[] = new int[n];\\n        int q = queries.length;\\n        int answer[] = new int[q];\\n        int scolor = 0;\\n        for(int i = 0; i<q; i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            int dcolor = 0;\\n            if(nums[index] != 0){\\n                if(index > 0 && nums[index]==nums[index-1]) dcolor++;\\n                if(index < n-1 && nums[index] == nums[index+1]) dcolor++;\\n            }\\n            nums[index] = color;\\n            if(index > 0 && nums[index]==nums[index-1]) scolor += 1;\\n            if(index < n-1 && nums[index] == nums[index+1]) scolor += 1;\\n            scolor -= dcolor;\\n            answer[i] = scolor;\\n        }\\n\\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535867,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n            \\n            vector<int> nums(n,0);\\n            vector<int> ans(q.size(),0);\\n            int cnt = 0; \\n            for(int i = 0; i < q.size();i++){\\n                    if(nums[q[i][0]] == 0){\\n                      nums[q[i][0]] = q[i][1];\\n                      if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                      }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                      \\n                    }\\n                    else{\\n                         if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          } \\n                          }\\n\\n                        nums[q[i][0]] = q[i][1];\\n                        \\n                        if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                            \\n\\n                    }\\n\\n                    //ans[i] = cnt;\\n                    \\n                    \\n\\n                    ans[i] = cnt;\\n            }\\n\\n            return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n            \\n            vector<int> nums(n,0);\\n            vector<int> ans(q.size(),0);\\n            int cnt = 0; \\n            for(int i = 0; i < q.size();i++){\\n                    if(nums[q[i][0]] == 0){\\n                      nums[q[i][0]] = q[i][1];\\n                      if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                      }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                      \\n                    }\\n                    else{\\n                         if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          } \\n                          }\\n\\n                        nums[q[i][0]] = q[i][1];\\n                        \\n                        if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                            \\n\\n                    }\\n\\n                    //ans[i] = cnt;\\n                    \\n                    \\n\\n                    ans[i] = cnt;\\n            }\\n\\n            return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534338,
                "title": "c-easy-count-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& vec) {\\n     vector<int>po(n,0);\\n        int  pair=0;\\n        vector<int>k;\\n        if(n==1)\\n        {\\n            vector<int> ppp(vec.size(),0);\\n            return ppp;\\n            \\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            int p= vec[i][0];\\n            int v= vec[i][1];\\n            if(p>0 and p<po.size()-1)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else \\n            if(p==0)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v; \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else if(p==po.size()-1){\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            }\\n            k.push_back(pair);\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& vec) {\\n     vector<int>po(n,0);\\n        int  pair=0;\\n        vector<int>k;\\n        if(n==1)\\n        {\\n            vector<int> ppp(vec.size(),0);\\n            return ppp;\\n            \\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            int p= vec[i][0];\\n            int v= vec[i][1];\\n            if(p>0 and p<po.size()-1)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else \\n            if(p==0)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v; \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else if(p==po.size()-1){\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            }\\n            k.push_back(pair);\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532125,
                "title": "java-c-python-o-m-with-explanation",
                "content": "# TL;DR\\n\\n``` java []\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        var nums = new int[n];\\n        var adjacentSameColor = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        std::vector<int> nums(n, 0);\\n        std::vector<int> adjacentSameColor(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = [0] * n\\n        adjacentSameColor = [0] * len(queries)\\n        for i in range(len(queries)):\\n            if i > 0:\\n                adjacentSameColor[i] = adjacentSameColor[i - 1]\\n\\n            index = queries[i][0]\\n            newColor = queries[i][1]\\n            oldColor = nums[index]\\n            nums[index] = newColor\\n\\n            if newColor == oldColor:\\n                continue\\n            if index > 0:\\n                if oldColor != 0 and nums[index - 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index - 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n            if index < n - 1:\\n                if oldColor != 0 and nums[index + 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index + 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n        return adjacentSameColor\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Don\\'t forget to upvote if you like the content below. \\uD83D\\uDE43\\n---\\n\\n\\n# Intuition \\n\\nIn the problem, we\\'re only changing the color of one element at a time, and we need to find the number of adjacent elements with the same color. This tells us that after each operation, the number of adjacent elements with the same color can change by at most 2 (one on either side of the colored index). Therefore, instead of recalculating the number of adjacent elements with the same color for the whole array after each operation, we can just track the changes at the colored index.\\n\\n# Approach\\n\\n1. **Initialize `nums` and `adjacentSameColor` arrays**: Create an array `nums` of size `n` initialized with zeros to represent the uncolored elements, and an array `adjacentSameColor` of the same size as `queries` to store the number of adjacent elements with the same color for each query.\\n\\n2. **Iterate over `queries`**: For each query, get the index `index` and the new color `newColor` to be applied. Also, store the old color of the element at index `index` in the `nums` array.\\n\\n3. **Update color and count adjacent elements with same color**: Update the color at `index` in `nums` with `newColor`. If `newColor` is different from `oldColor`, check the elements adjacent to `index` in `nums`. If any of them have the same color as `oldColor` or `newColor`, update the count in `adjacentSameColor` accordingly.\\n\\n4. **Return the result**: After iterating over all queries, return the `adjacentSameColor` array.\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity is $$O(m)$$, where $$m$$ is the number of queries. This is because we\\'re iterating over the list of queries once.\\n\\n- **Space Complexity**: The space complexity is $$O(n + m)$$, as we use an array to store the colors of the elements and another array to store the results for each query.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        var nums = new int[n];\\n        var adjacentSameColor = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        std::vector<int> nums(n, 0);\\n        std::vector<int> adjacentSameColor(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = [0] * n\\n        adjacentSameColor = [0] * len(queries)\\n        for i in range(len(queries)):\\n            if i > 0:\\n                adjacentSameColor[i] = adjacentSameColor[i - 1]\\n\\n            index = queries[i][0]\\n            newColor = queries[i][1]\\n            oldColor = nums[index]\\n            nums[index] = newColor\\n\\n            if newColor == oldColor:\\n                continue\\n            if index > 0:\\n                if oldColor != 0 and nums[index - 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index - 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n            if index < n - 1:\\n                if oldColor != 0 and nums[index + 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index + 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n        return adjacentSameColor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529769,
                "title": "easy-approach-with-comment-as-per-hint",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<int> nums(n, 0);\\n\\t\\t\\tvector<int> ans(queries.size());\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < queries.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint idx = queries[i][0];\\n\\n\\t\\t\\t\\t// If an element that is changed on the i-th query had the same color as its right  element answer decreases by 1. Similarly contributes its left element too.\\n\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n      \\n\\t     // puting the color of queries in nums \\n\\t\\t\\t\\tnums[queries[i][0]] = queries[i][1];\\n\\n\\t\\t\\t\\t// After changing the color, if the element has the same color as its right element   answer increases by 1. Similarly contributes its left element too.\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<int> nums(n, 0);\\n\\t\\t\\tvector<int> ans(queries.size());\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < queries.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint idx = queries[i][0];\\n\\n\\t\\t\\t\\t// If an element that is changed on the i-th query had the same color as its right  element answer decreases by 1. Similarly contributes its left element too.\\n\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n      \\n\\t     // puting the color of queries in nums \\n\\t\\t\\t\\tnums[queries[i][0]] = queries[i][1];\\n\\n\\t\\t\\t\\t// After changing the color, if the element has the same color as its right element   answer increases by 1. Similarly contributes its left element too.\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525936,
                "title": "counting-solution-for-c-explanation-complexity",
                "content": "# Approach\\nIt\\'s the task of counting. For each query, we will track if there is a difference between the current and neighboring values.\\nWe need to check two variants: if the neighbor is equal to the new value, and if we break the same color, like:\\n - Input array: 0 0 0 0, counter: 0\\n - Query 1: 0 1 0 0, counter: 0\\n - Query 2: 0 1 1 0, counter: 1\\n - Query 3: 0 1 1 1, counter: 2\\n  - Query 4: 0 1 0 1, counter: 0\\n\\nSo:\\n- We check index and index+1. If the old value equals index+1 value then decrement the counter (query 4);\\n- If the new value equals index+1 value then increment the counter (query 2 and 3).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic int[] ColorAdjacentElements(int[][] queries, int n)\\n{\\n    var result = new int[queries.Length];\\n\\n    var colors = new int[n];\\n    var currentNeighbors = 0;\\n\\n    for (var i = 0; i < queries.Length; i++)\\n    {\\n        var index = queries[i][0];\\n        var color = queries[i][1];\\n\\n        currentNeighbors += Check(colors, colors[index], color, index - 1);\\n        currentNeighbors += Check(colors, colors[index], color, index + 1);\\n\\n        colors[index] = color;\\n        result[i] = currentNeighbors;\\n    }\\n\\n    return result;\\n}\\n\\nprivate int Check(int[] colors, int oldColor, int newColor, int neighborIndex)\\n{\\n    if (neighborIndex == -1 || neighborIndex == colors.Length)\\n    {\\n        return 0;\\n    }\\n\\n    if (oldColor == newColor)\\n    {\\n        return 0;\\n    }\\n\\n    if (colors[neighborIndex] == 0)\\n    {\\n        return 0;\\n    }\\n\\n    var neighborColor = colors[neighborIndex];\\n\\n    if (newColor == neighborColor)\\n    {\\n        return 1;\\n    }\\n\\n    return oldColor == neighborColor ? -1 : 0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int[] ColorAdjacentElements(int[][] queries, int n)\\n{\\n    var result = new int[queries.Length];\\n\\n    var colors = new int[n];\\n    var currentNeighbors = 0;\\n\\n    for (var i = 0; i < queries.Length; i++)\\n    {\\n        var index = queries[i][0];\\n        var color = queries[i][1];\\n\\n        currentNeighbors += Check(colors, colors[index], color, index - 1);\\n        currentNeighbors += Check(colors, colors[index], color, index + 1);\\n\\n        colors[index] = color;\\n        result[i] = currentNeighbors;\\n    }\\n\\n    return result;\\n}\\n\\nprivate int Check(int[] colors, int oldColor, int newColor, int neighborIndex)\\n{\\n    if (neighborIndex == -1 || neighborIndex == colors.Length)\\n    {\\n        return 0;\\n    }\\n\\n    if (oldColor == newColor)\\n    {\\n        return 0;\\n    }\\n\\n    if (colors[neighborIndex] == 0)\\n    {\\n        return 0;\\n    }\\n\\n    var neighborColor = colors[neighborIndex];\\n\\n    if (newColor == neighborColor)\\n    {\\n        return 1;\\n    }\\n\\n    return oldColor == neighborColor ? -1 : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520100,
                "title": "java-o-m-optimal-solution-easy-explanation-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(m)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m+n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE !! **If you liked my solution**\\n\\n**Code WITHOUT COMMENTS BELOW**\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    //ans array\\n        int[] ar=new int[n];    // array to store color\\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];     //position of element to be changed color of\\n            int c=q[i][1];     // new color\\n            int k=0;           //no. of adjeacent elements with same colors changed can be negative if new color breaks the adjaceny and positive if new color is equal to adjacent\\n            if(ar[p]==0){\\n                //if element has no color just check if new color is equal to adjacent color ans increment k\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                    \\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n\\n            }else{\\n\\n                int j=ar[p];  //old color at position p\\n                ar[p]=c;       // changed to new color\\n\\n                //if old color equal to adjecent elements decrement k and if equal to new color increment k\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                    \\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;   //add k to prev ans\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    \\n        int[] ar=new int[n];   \\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];    \\n            int c=q[i][1];     \\n            int k=0;           \\n            if(ar[p]==0){\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n            }else{\\n                int j=ar[p];\\n                ar[p]=c;\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    //ans array\\n        int[] ar=new int[n];    // array to store color\\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];     //position of element to be changed color of\\n            int c=q[i][1];     // new color\\n            int k=0;           //no. of adjeacent elements with same colors changed can be negative if new color breaks the adjaceny and positive if new color is equal to adjacent\\n            if(ar[p]==0){\\n                //if element has no color just check if new color is equal to adjacent color ans increment k\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                    \\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n\\n            }else{\\n\\n                int j=ar[p];  //old color at position p\\n                ar[p]=c;       // changed to new color\\n\\n                //if old color equal to adjecent elements decrement k and if equal to new color increment k\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                    \\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;   //add k to prev ans\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    \\n        int[] ar=new int[n];   \\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];    \\n            int c=q[i][1];     \\n            int k=0;           \\n            if(ar[p]==0){\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n            }else{\\n                int j=ar[p];\\n                ar[p]=c;\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519954,
                "title": "python-n-2-linear-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    typically with problems like this i always ask if its really needed to \\n    to check the entire array for the matching neighbors\\n\\n    try to think about what the change effects and if it affects the entire\\n    colors array or not\\n\\n    you see that it only changes the relationship to its buddys next to it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    on color change look at its neighbors\\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def colorTheArray(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n\\n\\n\\n        my basic starting soln\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n        for i in range(len(queries)):\\n            idx,c = queries[i]\\n            colors[idx] = c\\n            # check for adj color\\n            amt = 0\\n        .  we optimize this by only looking at the neighbors of the changed idx\\n            # as a change at idx only affects the two neighbors next to it\\n\\n            for j in range(len(colors)-1):\\n                if colors[j] and colors[j] ==colors[j+1]:\\n                    amt+=1\\n            ans[i] = amt\\n\\n        return ans\\n\\n\\n        how change affects neighbors \\n        when the changing idx is the middle number\\n        101 -- > 111        amt + 2 \\n        102 -- > 112        amt + 1 \\n        102 -- > 132        amt + 0\\n        112 -- > 102        amt - 1\\n        111 -- > 101        amt  2 \\n\\n        color not changing \\n        111 -- > 111        amt + 0\\n        111 -- > 112        amt + 0\\n\\n        \"\"\"\\n\\n\\n        \\n        # edge ase\\n        if n == 1:\\n            return [0]*len(queries)\\n\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n\\n        # total same color next to each other\\n        self.amt = 0\\n\\n        def calc_change(idx,nc):\\n\\n            # no change to color at idx\\n            if colors[idx] == nc:\\n                return \\n\\n            # forward 1 neighbor only \\n            if idx == 0:\\n                neighbors = [1]\\n\\n            # back 1 neighbor only \\n            elif idx == len(colors)-1:\\n                neighbors = [-1]\\n\\n            # both forward and back neighbors\\n            else:\\n                neighbors = [1,-1]\\n\\n            # for each neighbor see the change\\n            for dx in neighbors:\\n                # neighbors colors were not eq but now WILL be after change\\n                if colors[idx+dx] and colors[idx+dx] != colors[idx] and colors[idx+dx] == nc:\\n                    self.amt += 1\\n                # neighbors colors were eq but now will NOT be after change\\n                elif colors[idx+dx] and colors[idx+dx] == colors[idx] and colors[idx+dx] != nc:\\n                    self.amt -= 1\\n            # color\\n            colors[idx] = nc\\n\\n            \\n\\n\\n\\n        for i in range(len(queries)):\\n\\n            idx,c = queries[i]\\n\\n            calc_change(idx,c)\\n            \\n            ans[i] = self.amt\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def colorTheArray(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n\\n\\n\\n        my basic starting soln\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n        for i in range(len(queries)):\\n            idx,c = queries[i]\\n            colors[idx] = c\\n            # check for adj color\\n            amt = 0\\n        .  we optimize this by only looking at the neighbors of the changed idx\\n            # as a change at idx only affects the two neighbors next to it\\n\\n            for j in range(len(colors)-1):\\n                if colors[j] and colors[j] ==colors[j+1]:\\n                    amt+=1\\n            ans[i] = amt\\n\\n        return ans\\n\\n\\n        how change affects neighbors \\n        when the changing idx is the middle number\\n        101 -- > 111        amt + 2 \\n        102 -- > 112        amt + 1 \\n        102 -- > 132        amt + 0\\n        112 -- > 102        amt - 1\\n        111 -- > 101        amt  2 \\n\\n        color not changing \\n        111 -- > 111        amt + 0\\n        111 -- > 112        amt + 0\\n\\n        \"\"\"\\n\\n\\n        \\n        # edge ase\\n        if n == 1:\\n            return [0]*len(queries)\\n\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n\\n        # total same color next to each other\\n        self.amt = 0\\n\\n        def calc_change(idx,nc):\\n\\n            # no change to color at idx\\n            if colors[idx] == nc:\\n                return \\n\\n            # forward 1 neighbor only \\n            if idx == 0:\\n                neighbors = [1]\\n\\n            # back 1 neighbor only \\n            elif idx == len(colors)-1:\\n                neighbors = [-1]\\n\\n            # both forward and back neighbors\\n            else:\\n                neighbors = [1,-1]\\n\\n            # for each neighbor see the change\\n            for dx in neighbors:\\n                # neighbors colors were not eq but now WILL be after change\\n                if colors[idx+dx] and colors[idx+dx] != colors[idx] and colors[idx+dx] == nc:\\n                    self.amt += 1\\n                # neighbors colors were eq but now will NOT be after change\\n                elif colors[idx+dx] and colors[idx+dx] == colors[idx] and colors[idx+dx] != nc:\\n                    self.amt -= 1\\n            # color\\n            colors[idx] = nc\\n\\n            \\n\\n\\n\\n        for i in range(len(queries)):\\n\\n            idx,c = queries[i]\\n\\n            calc_change(idx,c)\\n            \\n            ans[i] = self.amt\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518901,
                "title": "easy-solution-checking-prev-and-next-value-in-each-query-c",
                "content": "# Approach\\n\\nCheck the previous and next place throughout each query if that place is contributing the adjacent condition then decrease (unpaint it) the counter (check for next value and previous value) and after painting it then check again if it is contributing then inc the counter and push the counter value in the answer array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> arr(n,0),ans;\\n        for(auto i:queries){      \\nint prev=i[0]-1;\\nint next=i[0]+1;\\n\\n//checking that if that place satisfies the adjacent condition\\n\\n//if yes then dec the counter for prev and next value respectively\\n            if(prev>=0&&arr[prev]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n            if(next<n&&arr[next]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n\\n//now checking that if the new color would satify the adjacent condition\\n\\n            if(prev>=0&&arr[prev]==i[1]){\\n                c++;\\n            }\\n            if(next<n&&arr[next]==i[1]){\\n                c++;\\n            }\\n\\n//updating the paint array\\n            arr[i[0]]=i[1];\\n//saving c for that query in the ans array\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> arr(n,0),ans;\\n        for(auto i:queries){      \\nint prev=i[0]-1;\\nint next=i[0]+1;\\n\\n//checking that if that place satisfies the adjacent condition\\n\\n//if yes then dec the counter for prev and next value respectively\\n            if(prev>=0&&arr[prev]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n            if(next<n&&arr[next]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n\\n//now checking that if the new color would satify the adjacent condition\\n\\n            if(prev>=0&&arr[prev]==i[1]){\\n                c++;\\n            }\\n            if(next<n&&arr[next]==i[1]){\\n                c++;\\n            }\\n\\n//updating the paint array\\n            arr[i[0]]=i[1];\\n//saving c for that query in the ans array\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518473,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] nums = new int[n];\\n        int[] ans = new int[queries.length];\\n        int cnt = 0;\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            int prev = idx > 0 ? nums[idx - 1] : 0;\\n            int nxt  = idx < nums.length - 1 ? nums[idx + 1] : 0;\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt--;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt--;\\n\\n            nums[idx] = color;\\n\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt++;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt++;\\n\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] nums = new int[n];\\n        int[] ans = new int[queries.length];\\n        int cnt = 0;\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            int prev = idx > 0 ? nums[idx - 1] : 0;\\n            int nxt  = idx < nums.length - 1 ? nums[idx + 1] : 0;\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt--;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt--;\\n\\n            nums[idx] = color;\\n\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt++;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt++;\\n\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516673,
                "title": "c-easy-to-understand-just-some-bunch-of-if-else-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries){\\n        vector<int>arr(n,0);\\n        vector<int>ans(queries.size(),0);\\n        int count=0;\\n        if(n<=1)return ans;\\n        for(int i=0;i<ans.size();i++){\\n            \\n            int index=queries[i][0];\\n            int val=queries[i][1];\\n            //blank position\\n            if(arr[index]==0){\\n                \\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index+1])count++;\\n                    }else{\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                if(arr[index-1]==val && arr[index+1]==val && val!=arr[index])count+=2;\\n                else if(arr[index-1]==val && val!=arr[index])count++;\\n                else if(arr[index+1]==val && val!=arr[index])count++;\\n                arr[index]=val;\\n                }\\n            }\\n            else{\\n                if(arr[index]==val){\\n                    ans[i]=count;\\n                    /*for(auto i:arr)cout<<i<<\" \";\\n                    cout<<\" \"<<count<<endl;*/\\n                    continue;\\n                }\\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                        \\n                        if(arr[index]==arr[index+1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index+1])count++;\\n                        \\n                    }else{\\n                        \\n                        if(arr[index]==arr[index-1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                \\n\\n                if((arr[index]==arr[index-1] || arr[index]==arr[index+1])){\\n                    if(arr[index]==arr[index-1] && arr[index]==arr[index+1])count-=2;\\n                    else if(arr[index-1]==arr[index]){\\n                        count--;\\n                    }\\n                    else if(arr[index+1]==arr[index]){\\n                        count--;\\n                    }\\n                }\\n                arr[index]=val;\\n                if(arr[index]==arr[index-1])count++;\\n                if(arr[index]==arr[index+1])count++;\\n                }\\n            }\\n            /*for(auto i:arr)cout<<i<<\" \";\\n            cout<<\" \"<<count<<endl;*/\\n            ans[i]=count;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries){\\n        vector<int>arr(n,0);\\n        vector<int>ans(queries.size(),0);\\n        int count=0;\\n        if(n<=1)return ans;\\n        for(int i=0;i<ans.size();i++){\\n            \\n            int index=queries[i][0];\\n            int val=queries[i][1];\\n            //blank position\\n            if(arr[index]==0){\\n                \\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index+1])count++;\\n                    }else{\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                if(arr[index-1]==val && arr[index+1]==val && val!=arr[index])count+=2;\\n                else if(arr[index-1]==val && val!=arr[index])count++;\\n                else if(arr[index+1]==val && val!=arr[index])count++;\\n                arr[index]=val;\\n                }\\n            }\\n            else{\\n                if(arr[index]==val){\\n                    ans[i]=count;\\n                    /*for(auto i:arr)cout<<i<<\" \";\\n                    cout<<\" \"<<count<<endl;*/\\n                    continue;\\n                }\\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                        \\n                        if(arr[index]==arr[index+1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index+1])count++;\\n                        \\n                    }else{\\n                        \\n                        if(arr[index]==arr[index-1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                \\n\\n                if((arr[index]==arr[index-1] || arr[index]==arr[index+1])){\\n                    if(arr[index]==arr[index-1] && arr[index]==arr[index+1])count-=2;\\n                    else if(arr[index-1]==arr[index]){\\n                        count--;\\n                    }\\n                    else if(arr[index+1]==arr[index]){\\n                        count--;\\n                    }\\n                }\\n                arr[index]=val;\\n                if(arr[index]==arr[index-1])count++;\\n                if(arr[index]==arr[index+1])count++;\\n                }\\n            }\\n            /*for(auto i:arr)cout<<i<<\" \";\\n            cout<<\" \"<<count<<endl;*/\\n            ans[i]=count;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3513783,
                "title": "2672-number-of-adjacent-elements-with-the-same-color",
                "content": "Explanation:\\nTaking a count variable to track before changing the color at concerned index if in its right or left same color was present decrement count respectively in both positions however, if after changing color same color is present in either left or right neighbour increase the count respectively. Please upvote if you like:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> answer(m,0);\\n        vector<int> nums(n,0);\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> jk = queries[i];\\n            int ind = jk[0];\\n            int color = jk[1];\\n            if(ind+1<n && nums[ind] != 0 && (nums[ind+1]==nums[ind])){\\n                count--;\\n            }\\n            if(ind-1>=0 && nums[ind] != 0 && (nums[ind-1]==nums[ind])){\\n                count--;\\n            }\\n             nums[ind]=color;\\n            if(ind+1<n && (nums[ind+1]==color)){\\n                count++;\\n            }\\n            if(ind-1>=0 && (nums[ind-1]==color)){\\n                count++;\\n            }\\n          answer[i]=count;\\n            \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> answer(m,0);\\n        vector<int> nums(n,0);\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> jk = queries[i];\\n            int ind = jk[0];\\n            int color = jk[1];\\n            if(ind+1<n && nums[ind] != 0 && (nums[ind+1]==nums[ind])){\\n                count--;\\n            }\\n            if(ind-1>=0 && nums[ind] != 0 && (nums[ind-1]==nums[ind])){\\n                count--;\\n            }\\n             nums[ind]=color;\\n            if(ind+1<n && (nums[ind+1]==color)){\\n                count++;\\n            }\\n            if(ind-1>=0 && (nums[ind-1]==color)){\\n                count++;\\n            }\\n          answer[i]=count;\\n            \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513528,
                "title": "c-counting-based-solution",
                "content": "# Intuition\\nSimple Counting Based Solution\\n\\n# Approach\\nTry adjusting both the neighbours using an array (initially all elements = 0)\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>curr(n,0);\\n        int c = 0;\\n        for(auto x:queries)\\n        {\\n             int pos = x[0];\\n             int col = x[1];\\n           \\n            if(pos-1>=0&&curr[pos]==curr[pos-1]&&curr[pos]>0)\\n                  c--;\\n            if(pos-1>=0&&curr[pos-1]==col)\\n                 c++;\\n            if(pos+1<n&&curr[pos]==curr[pos+1]&&curr[pos]>0)\\n                 c--;\\n            if(pos+1<n&&curr[pos+1]==col)\\n                  c++;\\n\\n            curr[pos] = col;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>curr(n,0);\\n        int c = 0;\\n        for(auto x:queries)\\n        {\\n             int pos = x[0];\\n             int col = x[1];\\n           \\n            if(pos-1>=0&&curr[pos]==curr[pos-1]&&curr[pos]>0)\\n                  c--;\\n            if(pos-1>=0&&curr[pos-1]==col)\\n                 c++;\\n            if(pos+1<n&&curr[pos]==curr[pos+1]&&curr[pos]>0)\\n                 c--;\\n            if(pos+1<n&&curr[pos+1]==col)\\n                  c++;\\n\\n            curr[pos] = col;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513323,
                "title": "easy-cpp-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int arr[n];\\n        \\n        for(int x=0;x<n;x++)\\n            arr[x]=0;\\n        \\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int x=0;x<queries.size();x++){\\n            \\n            int i = queries[x][0];\\n            int c = queries[x][1];\\n            \\n            if(c!=arr[i]){\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count--;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count--;\\n                }\\n                \\n                arr[i] = c;\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count++;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int arr[n];\\n        \\n        for(int x=0;x<n;x++)\\n            arr[x]=0;\\n        \\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int x=0;x<queries.size();x++){\\n            \\n            int i = queries[x][0];\\n            int c = queries[x][1];\\n            \\n            if(c!=arr[i]){\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count--;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count--;\\n                }\\n                \\n                arr[i] = c;\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count++;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512932,
                "title": "intuitive-approach-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply keep in mind that the maximum number of times the ans may change by altering one colour is simply 2, once on the left and once on the right, while the rest stays the same. When you understand this, it is quite easy.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> arr(n, 0); // Array to store the colors\\n        int tans = 0; // Variable to track the count of adjacent elements with the same color\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n\\n            if (oldColor) {\\n                // Check if the old color is non-zero, which means it\\'s already colored\\n                // Need to subtract the adjacent count if reducing the number of adjacent elements\\n\\n                // Check the element after the current index\\n                if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                    tans--;\\n                }\\n\\n                // Check the element before the current index\\n                if (index != 0 && arr[index] == arr[index - 1]) {\\n                    tans--;\\n                }\\n            }\\n\\n            // Assign the new color to the array\\n            arr[index] = newColor;\\n\\n            // Check the element after the current index\\n            if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                tans++;\\n            }\\n\\n            // Check the element before the current index\\n            if (index != 0 && arr[index] == arr[index - 1]) {\\n                tans++;\\n            }\\n\\n            ans.push_back(tans); // Store the current count in the result vector\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> arr(n, 0); // Array to store the colors\\n        int tans = 0; // Variable to track the count of adjacent elements with the same color\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n\\n            if (oldColor) {\\n                // Check if the old color is non-zero, which means it\\'s already colored\\n                // Need to subtract the adjacent count if reducing the number of adjacent elements\\n\\n                // Check the element after the current index\\n                if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                    tans--;\\n                }\\n\\n                // Check the element before the current index\\n                if (index != 0 && arr[index] == arr[index - 1]) {\\n                    tans--;\\n                }\\n            }\\n\\n            // Assign the new color to the array\\n            arr[index] = newColor;\\n\\n            // Check the element after the current index\\n            if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                tans++;\\n            }\\n\\n            // Check the element before the current index\\n            if (index != 0 && arr[index] == arr[index - 1]) {\\n                tans++;\\n            }\\n\\n            ans.push_back(tans); // Store the current count in the result vector\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512532,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        vector<int> v(n,0);\\n        \\n        map<int,int> mp;\\n        vector<int> res(m,0);\\n        int cnt = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) mp[i] = 0;\\n        \\n        for(int i=0 ; i<m ; ++i){\\n            \\n            int idx = queries[i][0];\\n            int val = queries[i][1];\\n            int prev = v[idx];\\n            \\n            if(prev == val){\\n                res[i] = cnt;\\n                continue;\\n            }\\n            \\n            if(idx != 0 && v[idx - 1] != 0){\\n                if(v[idx - 1] == val){\\n                   mp[v[idx - 1]] += 1;\\n                   cnt += 1; \\n                }\\n                \\n                if(v[idx - 1] == prev){\\n                    mp[v[idx - 1]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            \\n            if(idx != n - 1 && v[idx + 1] != 0){\\n                if(v[idx + 1] == val){\\n                    mp[v[idx]] += 1;\\n                    cnt += 1;\\n                }\\n                \\n                if(v[idx + 1] == prev){\\n                    mp[v[idx]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            v[idx] = val;\\n            res[i] = cnt;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        vector<int> v(n,0);\\n        \\n        map<int,int> mp;\\n        vector<int> res(m,0);\\n        int cnt = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) mp[i] = 0;\\n        \\n        for(int i=0 ; i<m ; ++i){\\n            \\n            int idx = queries[i][0];\\n            int val = queries[i][1];\\n            int prev = v[idx];\\n            \\n            if(prev == val){\\n                res[i] = cnt;\\n                continue;\\n            }\\n            \\n            if(idx != 0 && v[idx - 1] != 0){\\n                if(v[idx - 1] == val){\\n                   mp[v[idx - 1]] += 1;\\n                   cnt += 1; \\n                }\\n                \\n                if(v[idx - 1] == prev){\\n                    mp[v[idx - 1]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            \\n            if(idx != n - 1 && v[idx + 1] != 0){\\n                if(v[idx + 1] == val){\\n                    mp[v[idx]] += 1;\\n                    cnt += 1;\\n                }\\n                \\n                if(v[idx + 1] == prev){\\n                    mp[v[idx]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            v[idx] = val;\\n            res[i] = cnt;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511172,
                "title": "simple-python3-solution-upto-90-faster-o-n",
                "content": "# Intuition\\nAs we add new element  to the respective index we check if any previous colors are getting affected or not. And as we add the new color to the index position we check if any new similar color pairs are forming and increase or decrease the count(Same color count).\\n\\nAfter each iteration we append the count to the list and return it.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        res = [0]*(n+1)\\n        same_count = 0\\n\\n        same_count_list =[]\\n        for ind,i in queries:\\n            if res[ind] == 0:\\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n            \\n            else:\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count -= 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count -= 1\\n                \\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n\\n            same_count_list.append(same_count)\\n\\n        return same_count_list\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        res = [0]*(n+1)\\n        same_count = 0\\n\\n        same_count_list =[]\\n        for ind,i in queries:\\n            if res[ind] == 0:\\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n            \\n            else:\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count -= 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count -= 1\\n                \\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n\\n            same_count_list.append(same_count)\\n\\n        return same_count_list\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508284,
                "title": "counting-adj-same-colors-using-easy-trick-arrays",
                "content": "# Intuition\\nThis problem has a striaght forward intuition that we need to use Arrays for maintaining the colors and count for each query.\\nColors can be stored in array bcoz array size(n) <= 10^5\\n\\n# Approach\\nIn order to evaluate the adjacent count, first of all we should be able to track the number of adjacent elements getting created on each query.\\nlet query has index=i and color=C\\nthen it will be possible to evaluate the contribution it does to the current number of adjacent elements by using:\\n    current adj count = ( (is same as left) + (is same as right) )\\n    i.e. curr += ((color[i-1]==color[i]) + (color[i] == color[i+1]))\\n\\nfor -> color[i-1], either we can add (i>0) in the condition,\\n. . . -> color[i+1], either we can add (i<n) in the condition\\nor else, we can simply create an array of bigger size i.e. n+2\\nand then use 1 based indexing for performing all computations.\\n\\nThe trick is while decreasing the current adjacent element count.\\nWe need to check if the current cell has been already colored or not.\\n\\n# Complexity\\n- Time complexity:\\nHere we are iterating over all queries and computing the current outcome using simple math in O(1). So the time complexity will be O(queries.length)\\n\\n- Space complexity:\\nAs we have created an array of size n (or, n+2)\\nand an array of size queries.length (let queries.length be qlen)\\nIt means that the space complexity will be the max(n,qlen)\\ni.e. O(max(n,qlen))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n+2, 0);\\n        int i,col,curr(0);\\n        vector<int> ans;\\n\\n        for(auto q : queries){\\n            i = q[0] + 1;\\n            col = q[1];\\n\\n            if(color[i])\\n                curr = curr - ( (color[i-1]==color[i]) + (color[i]==color[i+1]));\\n            color[i] = col;\\n\\n            curr = curr + ( (color[i-1]==color[i]) + (color[i] == color[i+1]));\\n            ans.push_back(curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n+2, 0);\\n        int i,col,curr(0);\\n        vector<int> ans;\\n\\n        for(auto q : queries){\\n            i = q[0] + 1;\\n            col = q[1];\\n\\n            if(color[i])\\n                curr = curr - ( (color[i-1]==color[i]) + (color[i]==color[i+1]));\\n            color[i] = col;\\n\\n            curr = curr + ( (color[i-1]==color[i]) + (color[i] == color[i+1]));\\n            ans.push_back(curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506420,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: ([Int](),Array(repeating: 0, count: n+2))) { d, q in let i=q[0]+1;func f(_ n:Int) -> Int {(n>0 && n==d.1[i-1] ? 1 : 0) + (n>0 && n==d.1[i+1] ? 1 : 0)};d.0+=[(d.0.last ?? 0)-f(d.1[i])+f(q[1])];d.1[i]=q[1]}.0\\n    }\\n}\\n```\\n**NOTE:** This is technically a one-liner, since the `return` keyword could be omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: (\\n                result: [Int](),\\n                nums: Array(repeating: 0, count: n+1)\\n        )) { data, q in\\n            func countAdjacents(_ n:Int) -> Int {\\n                n > 0 ? (q[0] > 0 && n==data.nums[q[0]-1] ? 1:0) + (n==data.nums[q[0]+1] ? 1:0) : 0\\n            }                                 \\n            data.result.append((data.result.last ?? 0) - countAdjacents(data.nums[q[0]]) + countAdjacents(q[1]))\\n            data.nums[q[0]] = q[1]\\n        }.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: ([Int](),Array(repeating: 0, count: n+2))) { d, q in let i=q[0]+1;func f(_ n:Int) -> Int {(n>0 && n==d.1[i-1] ? 1 : 0) + (n>0 && n==d.1[i+1] ? 1 : 0)};d.0+=[(d.0.last ?? 0)-f(d.1[i])+f(q[1])];d.1[i]=q[1]}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: (\\n                result: [Int](),\\n                nums: Array(repeating: 0, count: n+1)\\n        )) { data, q in\\n            func countAdjacents(_ n:Int) -> Int {\\n                n > 0 ? (q[0] > 0 && n==data.nums[q[0]-1] ? 1:0) + (n==data.nums[q[0]+1] ? 1:0) : 0\\n            }                                 \\n            data.result.append((data.result.last ?? 0) - countAdjacents(data.nums[q[0]]) + countAdjacents(q[1]))\\n            data.nums[q[0]] = q[1]\\n        }.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505362,
                "title": "easy-prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- for first query answer will be zero always \\n- for second query answer will previous answer + something or previous answer-something.\\n- we will add something to previous answer if after coloring the shell its color become same as previous cell or its color become same as next shell\\n- we will subtract something if the cell is alredy colored \\n=> then there is two possibilty \\n    --- previous configuration get disturbed \\n            -----previous config got disturbed \\nif v[ind]==v[ind-1]or v[ind]==v[ind+1]\\n    --- previous configuration does not get disturbed\\n    - subtract as per no. of configuration get destroyed .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans(q.size(),0);\\n        if (q.size()<=1)\\n        {\\n            return ans; \\n        }\\n        vector<int>v(n,0);\\n        v[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            int temp=0;\\n            int ind=q[i][0];\\n            int col=q[i][1];\\n            if (v[ind]==0)\\n            {\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            else \\n            {\\n                \\n                if (ind-1>=0 && v[ind-1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            temp+=ans[i-1];\\n            ans[i]=temp;\\n            v[ind]=col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans(q.size(),0);\\n        if (q.size()<=1)\\n        {\\n            return ans; \\n        }\\n        vector<int>v(n,0);\\n        v[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            int temp=0;\\n            int ind=q[i][0];\\n            int col=q[i][1];\\n            if (v[ind]==0)\\n            {\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            else \\n            {\\n                \\n                if (ind-1>=0 && v[ind-1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            temp+=ans[i-1];\\n            ans[i]=temp;\\n            v[ind]=col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505297,
                "title": "typescript-solution",
                "content": "```\\nconst colorTheArray = (n: number, queries: number[][]): number[] => {\\n  const colorArr = Array(n);\\n  const adjacentElements = Array(queries.length).fill(0);\\n  let count = 0;\\n\\n  queries.forEach(([index, color], i) => {\\n    const prevColor = colorArr[index];\\n    colorArr[index] = color;\\n\\n    if (prevColor === color) {\\n      adjacentElements[i] = count;\\n      return;\\n    }\\n\\n    if (count && prevColor && colorArr[index - 1] === prevColor) count--;\\n    if (count && prevColor && colorArr[index + 1] === prevColor) count--;\\n\\n    if (colorArr[index - 1] === color) count++;\\n    if (colorArr[index + 1] === color) count++;\\n\\n    adjacentElements[i] = count;\\n  });\\n\\n  return adjacentElements;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst colorTheArray = (n: number, queries: number[][]): number[] => {\\n  const colorArr = Array(n);\\n  const adjacentElements = Array(queries.length).fill(0);\\n  let count = 0;\\n\\n  queries.forEach(([index, color], i) => {\\n    const prevColor = colorArr[index];\\n    colorArr[index] = color;\\n\\n    if (prevColor === color) {\\n      adjacentElements[i] = count;\\n      return;\\n    }\\n\\n    if (count && prevColor && colorArr[index - 1] === prevColor) count--;\\n    if (count && prevColor && colorArr[index + 1] === prevColor) count--;\\n\\n    if (colorArr[index - 1] === color) count++;\\n    if (colorArr[index + 1] === color) count++;\\n\\n    adjacentElements[i] = count;\\n  });\\n\\n  return adjacentElements;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505161,
                "title": "simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>a(n,0);\\n        int ans=0;\\n        vector<int>result;\\n        for(auto it:queries)\\n        {\\n            int index=it[0];\\n            int col=it[1];\\n            if(a[index]==col)\\n            {\\n                result.push_back(ans);\\n                continue;\\n            }\\n            if(index-1>=0 && a[index-1]==a[index] && a[index]!=0)ans--;\\n            if(index+1<n && a[index+1]==a[index] && a[index]!=0)ans--;\\n            if(index-1>=0 && col==a[index-1])ans++;\\n            if(index+1<n && col==a[index+1])ans++;\\n            a[index]=col;\\n            result.push_back(ans);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>a(n,0);\\n        int ans=0;\\n        vector<int>result;\\n        for(auto it:queries)\\n        {\\n            int index=it[0];\\n            int col=it[1];\\n            if(a[index]==col)\\n            {\\n                result.push_back(ans);\\n                continue;\\n            }\\n            if(index-1>=0 && a[index-1]==a[index] && a[index]!=0)ans--;\\n            if(index+1<n && a[index+1]==a[index] && a[index]!=0)ans--;\\n            if(index-1>=0 && col==a[index-1])ans++;\\n            if(index+1<n && col==a[index+1])ans++;\\n            a[index]=col;\\n            result.push_back(ans);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505024,
                "title": "simple-c-solution-with-cases",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> org(n,0);\\n        int count = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int ind = queries[i][0], color = queries[i][1], curr = org[ind];\\n            // Case 1.2 - If Current is Not Coloured AND Left Index has same color value\\n            if(curr == 0 && ind-1 >=0 && org[ind-1] == color)\\n               count++;\\n            \\n            // Case 1.2 - If Current is Not Coloured AND Right Index has same color value\\n            if(curr == 0 && ind+1 < n && org[ind+1] == color)\\n                count++;\\n            \\n            \\n            // Case 2.1 - If Current is Coloured AND Left Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] == curr && org[ind-1] != color)\\n               count--;\\n            \\n            // Case 2.1 - If Current->Coloured AND Left Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] != curr && org[ind-1] == color)\\n                count++;\\n            \\n            // Case 2.3 - If Current is Coloured AND Right Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] == curr && org[ind+1] != color)\\n               count--;\\n            \\n            // Case 2.4 - If Current->Coloured AND Right Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] != curr && org[ind+1] == color)\\n                count++;\\n            \\n            res.push_back(count);\\n            org[ind] = color;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> org(n,0);\\n        int count = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int ind = queries[i][0], color = queries[i][1], curr = org[ind];\\n            // Case 1.2 - If Current is Not Coloured AND Left Index has same color value\\n            if(curr == 0 && ind-1 >=0 && org[ind-1] == color)\\n               count++;\\n            \\n            // Case 1.2 - If Current is Not Coloured AND Right Index has same color value\\n            if(curr == 0 && ind+1 < n && org[ind+1] == color)\\n                count++;\\n            \\n            \\n            // Case 2.1 - If Current is Coloured AND Left Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] == curr && org[ind-1] != color)\\n               count--;\\n            \\n            // Case 2.1 - If Current->Coloured AND Left Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] != curr && org[ind-1] == color)\\n                count++;\\n            \\n            // Case 2.3 - If Current is Coloured AND Right Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] == curr && org[ind+1] != color)\\n               count--;\\n            \\n            // Case 2.4 - If Current->Coloured AND Right Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] != curr && org[ind+1] == color)\\n                count++;\\n            \\n            res.push_back(count);\\n            org[ind] = color;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503548,
                "title": "python-solution-o-m-beats-100-solns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the cases where adjacent elements can change.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are four main cases where adjacent elements can change : \\n1. If previous index has same color.\\n2. if next index has same color.\\n3. if previous and current index already had same color,i.e, they were already adjacent elements.\\n4. if current and next indexes already had same color,i.e, they were already adjacent elements.\\n\\n# Complexity\\n- Time complexity: O(m) , where m is number of queries. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) , if we account for the answer array that should be returned.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = n*[0] #nums is an array of length n, initially uncolored\\n        adj_elements = 0\\n        answer = len(queries)*[0]\\n        for i in range(len(queries)):\\n            index = queries[i][0] #current query index\\n            color = queries[i][1] #current query color\\n            \\n            #if index == 0, there are no previous elements\\n            if index !=0 :\\n                if nums[index - 1] == color:\\n                    adj_elements += 1\\n                if nums[index - 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1\\n            #if index == last index then there are no next index\\n            if index != n-1:\\n                if nums[index + 1] == color:\\n                    adj_elements += 1\\n                if nums[index + 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1  \\n            answer[i] = adj_elements\\n            nums[index] = color\\n            \\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = n*[0] #nums is an array of length n, initially uncolored\\n        adj_elements = 0\\n        answer = len(queries)*[0]\\n        for i in range(len(queries)):\\n            index = queries[i][0] #current query index\\n            color = queries[i][1] #current query color\\n            \\n            #if index == 0, there are no previous elements\\n            if index !=0 :\\n                if nums[index - 1] == color:\\n                    adj_elements += 1\\n                if nums[index - 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1\\n            #if index == last index then there are no next index\\n            if index != n-1:\\n                if nums[index + 1] == color:\\n                    adj_elements += 1\\n                if nums[index + 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1  \\n            answer[i] = adj_elements\\n            nums[index] = color\\n            \\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503296,
                "title": "simple-counting-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int size = queries.size(); \\n        vector<int> ans(size,0);\\n        vector<int> temp(n,0);\\n        int count =0;\\n        for(int i=0; i<size;i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevcol = (index-1<0)?0:temp[index-1];    \\n            int nextcol = (index+1>=n)?0:temp[index+1];\\n            int oldcol = temp[index];\\n            \\n            temp[index] = color;\\n//checking old color contribution if there remove it\\n            if(oldcol!=0 && oldcol==prevcol)\\n            count--;\\n            if(oldcol!=0 && oldcol==nextcol)\\n            count--;\\n//adding new color contribution\\n            if(color==prevcol)\\n            count++;\\n            if(color==nextcol)\\n            count++;\\n\\n            ans[i] = count;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int size = queries.size(); \\n        vector<int> ans(size,0);\\n        vector<int> temp(n,0);\\n        int count =0;\\n        for(int i=0; i<size;i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevcol = (index-1<0)?0:temp[index-1];    \\n            int nextcol = (index+1>=n)?0:temp[index+1];\\n            int oldcol = temp[index];\\n            \\n            temp[index] = color;\\n//checking old color contribution if there remove it\\n            if(oldcol!=0 && oldcol==prevcol)\\n            count--;\\n            if(oldcol!=0 && oldcol==nextcol)\\n            count--;\\n//adding new color contribution\\n            if(color==prevcol)\\n            count++;\\n            if(color==nextcol)\\n            count++;\\n\\n            ans[i] = count;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503272,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int qlen=queries.length;\\n        int ans[]=new int[qlen];\\n        int color[]=new int[n];\\n        int prevAdj=0;\\n        for(int i=0;i<qlen;i++){\\n            int left=0,right=0,qidx=queries[i][0],qcol=queries[i][1];\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=prevAdj-left-right;\\n            color[qidx]=qcol;\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=left+right;\\n            prevAdj=ans[i];\\n        }\\n        return ans;\\n    }\\n}//upvote if helpful...\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int qlen=queries.length;\\n        int ans[]=new int[qlen];\\n        int color[]=new int[n];\\n        int prevAdj=0;\\n        for(int i=0;i<qlen;i++){\\n            int left=0,right=0,qidx=queries[i][0],qcol=queries[i][1];\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=prevAdj-left-right;\\n            color[qidx]=qcol;\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=left+right;\\n            prevAdj=ans[i];\\n        }\\n        return ans;\\n    }\\n}//upvote if helpful...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502431,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut colours = vec![0; n as usize + 2];\\n        let mut res = vec![];\\n        let mut adjacent = 0;\\n\\n        for q in queries {\\n            let (i, colour) = (q[0] as usize + 1, q[1]);\\n\\n            if colours[i] != 0 {\\n                // Check the previous colour against its adjacent colours.\\n                match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                    (true, true) => adjacent -= 2,\\n                    (false, false) => (),\\n                    _ => adjacent -= 1,\\n                }\\n            }\\n\\n            colours[i] = colour;\\n            // Check the new colour against its adjacent colours.\\n            match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                (true, true) => adjacent += 2,\\n                (false, false) => (),\\n                _ => adjacent += 1,\\n            }\\n\\n            res.push(adjacent)\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut colours = vec![0; n as usize + 2];\\n        let mut res = vec![];\\n        let mut adjacent = 0;\\n\\n        for q in queries {\\n            let (i, colour) = (q[0] as usize + 1, q[1]);\\n\\n            if colours[i] != 0 {\\n                // Check the previous colour against its adjacent colours.\\n                match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                    (true, true) => adjacent -= 2,\\n                    (false, false) => (),\\n                    _ => adjacent -= 1,\\n                }\\n            }\\n\\n            colours[i] = colour;\\n            // Check the new colour against its adjacent colours.\\n            match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                (true, true) => adjacent += 2,\\n                (false, false) => (),\\n                _ => adjacent += 1,\\n            }\\n\\n            res.push(adjacent)\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502290,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n), ans;\\n        int count = 0;\\n        for(vector<int> query: queries) {\\n            if(query[0] != 0) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] - 1]: 0;\\n            if(query[0] != n - 1) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] + 1]: 0;\\n            color[query[0]] = query[1];\\n            if(query[0] != 0) \\n                count += color[query[0]] == color[query[0] - 1];\\n            if(query[0] != n - 1) \\n                count += color[query[0]] == color[query[0] + 1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n), ans;\\n        int count = 0;\\n        for(vector<int> query: queries) {\\n            if(query[0] != 0) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] - 1]: 0;\\n            if(query[0] != n - 1) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] + 1]: 0;\\n            color[query[0]] = query[1];\\n            if(query[0] != 0) \\n                count += color[query[0]] == color[query[0] - 1];\\n            if(query[0] != n - 1) \\n                count += color[query[0]] == color[query[0] + 1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502245,
                "title": "direct-counting-increment-decrement-solution-python",
                "content": "Note that the problem asks to find answer[i]\\'s where answer[i] is the number of adjacent elements with the same color after the ith query. So it is an accumulated counting. Therefore, after each querey in the for-loop, we do not reset the running variable `cnt`.\\n\\n```\\n\"\"\"\\nWhen the color at index i is changed, we check the the colors at indices i-1 and\\ni+1 when they are in bound.\\n\\nIn the solution, to avoid check i - 1 >= 0 and i + 1 < n, we made an array of size\\nn + 2, and making the indexing in queries to be 1-indexing. This is purely for convenience.\\n\"\"\"\\n\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        array = [0] * (n + 2)\\n        \\n        res = []\\n        cnt = 0\\n        for q in queries:\\n            i, color = q[0] + 1, q[1]\\n            if array[i] != 0:\\n                if array[i] == array[i+1]:\\n                    cnt -= 1\\n                if array[i] == array[i-1]:\\n                    cnt -= 1\\n                \\n            array[i] = color\\n            if array[i] == array[i+1]:\\n                cnt += 1\\n            if array[i] == array[i-1]:\\n                cnt += 1\\n                \\n            res.append(cnt)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nWhen the color at index i is changed, we check the the colors at indices i-1 and\\ni+1 when they are in bound.\\n\\nIn the solution, to avoid check i - 1 >= 0 and i + 1 < n, we made an array of size\\nn + 2, and making the indexing in queries to be 1-indexing. This is purely for convenience.\\n\"\"\"\\n\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        array = [0] * (n + 2)\\n        \\n        res = []\\n        cnt = 0\\n        for q in queries:\\n            i, color = q[0] + 1, q[1]\\n            if array[i] != 0:\\n                if array[i] == array[i+1]:\\n                    cnt -= 1\\n                if array[i] == array[i-1]:\\n                    cnt -= 1\\n                \\n            array[i] = color\\n            if array[i] == array[i+1]:\\n                cnt += 1\\n            if array[i] == array[i-1]:\\n                cnt += 1\\n                \\n            res.append(cnt)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501529,
                "title": "fast-elegant-rust-solution",
                "content": "```rust\\nimpl Solution {\\n  pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = n as usize;\\n    let m = n - 1;\\n    let mut colors = vec![0; n];\\n    let mut sum = 0;\\n    queries\\n      .iter()\\n      .map(|query| {\\n        let index = query[0] as usize;\\n        let curr = query[1];\\n        let prev = colors[index];\\n        if prev == curr {\\n          return sum;\\n        }\\n        let mut f = |color, aug| {\\n          if index > 0 && colors[index - 1] == color {\\n            sum += aug;\\n          }\\n          if index < m && colors[index + 1] == color {\\n            sum += aug;\\n          }\\n          true\\n        };\\n        prev > 0 && f(prev, -1);\\n        f(curr, 1);\\n        colors[index] = curr;\\n        return sum;\\n      })\\n      .collect()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n  pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = n as usize;\\n    let m = n - 1;\\n    let mut colors = vec![0; n];\\n    let mut sum = 0;\\n    queries\\n      .iter()\\n      .map(|query| {\\n        let index = query[0] as usize;\\n        let curr = query[1];\\n        let prev = colors[index];\\n        if prev == curr {\\n          return sum;\\n        }\\n        let mut f = |color, aug| {\\n          if index > 0 && colors[index - 1] == color {\\n            sum += aug;\\n          }\\n          if index < m && colors[index + 1] == color {\\n            sum += aug;\\n          }\\n          true\\n        };\\n        prev > 0 && f(prev, -1);\\n        f(curr, 1);\\n        colors[index] = curr;\\n        return sum;\\n      })\\n      .collect()\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501417,
                "title": "java-o-n-solution-addduplicates-minusduplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k) k is the length of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n + k) k is the length of queries.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] colors = new int[n];\\n        int[] res = new int[queries.length];\\n        int duplicate = 0;\\n        for(int i = 0; i < queries.length; ++i){\\n            int idx = queries[i][0];\\n            int color = colors[idx];\\n            if(color != 0){\\n                if(idx >= 1 && color == colors[idx - 1])\\n                    duplicate--;\\n                if(idx < n - 1 && color == colors[idx + 1])\\n                    duplicate--;\\n            }\\n            color = queries[i][1];\\n            if(idx >= 1 && color == colors[idx - 1])\\n                duplicate++;\\n            if(idx < n - 1 && color == colors[idx + 1])\\n                duplicate++;\\n            colors[idx] = color;\\n            res[i] = duplicate;\\n            // System.out.println(Arrays.toString(colors) + \" \" + duplicate);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] colors = new int[n];\\n        int[] res = new int[queries.length];\\n        int duplicate = 0;\\n        for(int i = 0; i < queries.length; ++i){\\n            int idx = queries[i][0];\\n            int color = colors[idx];\\n            if(color != 0){\\n                if(idx >= 1 && color == colors[idx - 1])\\n                    duplicate--;\\n                if(idx < n - 1 && color == colors[idx + 1])\\n                    duplicate--;\\n            }\\n            color = queries[i][1];\\n            if(idx >= 1 && color == colors[idx - 1])\\n                duplicate++;\\n            if(idx < n - 1 && color == colors[idx + 1])\\n                duplicate++;\\n            colors[idx] = color;\\n            res[i] = duplicate;\\n            // System.out.println(Arrays.toString(colors) + \" \" + duplicate);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501070,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr=new int[n];\\n        int[] ans=new int[queries.length];\\n        int c=0;\\n        for(int i=0;i<queries.length;i++){\\n            int ind=queries[i][0];\\n            int col=queries[i][1];\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            arr[ind]=col;\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr=new int[n];\\n        int[] ans=new int[queries.length];\\n        int c=0;\\n        for(int i=0;i<queries.length;i++){\\n            int ind=queries[i][0];\\n            int col=queries[i][1];\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            arr[ind]=col;\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500861,
                "title": "you-won-t-regret-reading-it-intuition-explained-very-easy-to-understand",
                "content": "**Please upvote if useful!** \\n\\nThe given problem involves coloring elements in an array and counting the number of adjacent elements with the same color after each query.\\n\\nHere\\'s the **intuition** behind it:\\n\\n1.  ***\\'colors\\'*** array will store the colors assigned to each element in the array, and ***\\'answer\\'*** will store the count of adjacent elements with the same color after each query.\\n2. ***\\'numberOfPairs\\'*** variable is used to keep track of the count of adjacent pairs with the same color.\\n3.  Iterate through each query in the ***\\'queries\\'*** array. For each query:\\n\\t* Check if the color at the given index is already assigned in the ***\\'colors\\'*** array. If it is, it means that we are overriding the color at that index with a new color.\\n\\t\\t1. If the color at the previous index (index-1) is the same as the current color, it implies that we had a pair of adjacent elements with the same color before the query. By overriding the color, we lose one pair, **so we decrement \\'numberOfPairs\\' by 1**.\\n\\t\\t2. If the color at the next index (index+1) is the same as the current color, it means we had a pair of adjacent elements with the same color after the query. **Again, we decrement \\'numberOfPairs\\' by 1**.\\n\\t* Update the \\'colors\\' array with the new color at the given index. After updating color:\\n\\t* Check if the color at the previous index (index-1) is the same as the current color. If it is, we have a new pair of adjacent elements with the same color, **so we increment \\'numberOfPairs\\' by 1**.\\n\\t* Check if the color at the next index (index+1) is the same as the current color. If it is, we have another pair of adjacent elements with the same color, **so we increment \\'numberOfPairs\\' by 1**.\\n4.  Store the current value of \\'numberOfPairs\\' in the \\'answer\\' array for the corresponding query.\\n\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int [] colors = new int[n];\\n        int [] answer = new int[queries.length];\\n        \\n        int numberOfPairs = 0;\\n        \\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            if(colors[index] != 0){\\n                if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n                if(index+1 < n && colors[index+1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n            }\\n            \\n            colors[index] = color;\\n            \\n            if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            if(index+1 < n && colors[index+1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            \\n            answer[i] = numberOfPairs;\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int [] colors = new int[n];\\n        int [] answer = new int[queries.length];\\n        \\n        int numberOfPairs = 0;\\n        \\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            if(colors[index] != 0){\\n                if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n                if(index+1 < n && colors[index+1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n            }\\n            \\n            colors[index] = color;\\n            \\n            if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            if(index+1 < n && colors[index+1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            \\n            answer[i] = numberOfPairs;\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500698,
                "title": "c-straight-solution-faster-than-67",
                "content": "# Complexity\\n- Time complexity: O(m), here m = query.size() \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) and not O(n+m) as we do not consider the size that we have to return for the answer.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {  \\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans (q.size());\\n        vector<int> nums(n+1,0);\\n        int count=0;\\n\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            int index = q[i][0], newcolor = q[i][1];\\n            int initial = nums[index];\\n            nums[index]=newcolor;\\n            \\n            if(initial==newcolor)\\n                {\\n                ans[i]=count;\\n                continue;\\n                }\\n            if(index!=0 && nums[index-1]!=0)\\n            {\\n                if(nums[index-1]==newcolor)\\n                    count++;\\n                else if(nums[index-1]==initial)\\n                    count--;\\n            }\\n            if(index<n && nums[index+1]!=0)\\n            {\\n                if(nums[index+1]==newcolor)\\n                    count++;\\n                else if(nums[index+1]==initial)\\n                   count--;\\n            }     \\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {  \\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans (q.size());\\n        vector<int> nums(n+1,0);\\n        int count=0;\\n\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            int index = q[i][0], newcolor = q[i][1];\\n            int initial = nums[index];\\n            nums[index]=newcolor;\\n            \\n            if(initial==newcolor)\\n                {\\n                ans[i]=count;\\n                continue;\\n                }\\n            if(index!=0 && nums[index-1]!=0)\\n            {\\n                if(nums[index-1]==newcolor)\\n                    count++;\\n                else if(nums[index-1]==initial)\\n                    count--;\\n            }\\n            if(index<n && nums[index+1]!=0)\\n            {\\n                if(nums[index+1]==newcolor)\\n                    count++;\\n                else if(nums[index+1]==initial)\\n                   count--;\\n            }     \\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500667,
                "title": "simple-c-solution",
                "content": "C++:\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\t\\n        vector<int> col(n,0);   //track color\\n        int ans=0;    //total adjacent \\n        vector<int> adj;   //final vector\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            int ind=queries[i][0];     //position\\n\\t\\t\\t\\n\\t\\t\\t//checking is changed before or not\\n            if(col[ind]!=0){\\n                if(ind>0 && col[ind-1]==col[ind]){\\n                    ans--;\\n                }\\n                if(ind+1<n && col[ind]==col[ind+1]){\\n                    ans--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//changing and checking for new color\\n            col[ind]=queries[i][1];\\n            if(ind>0 && col[ind-1]==col[ind]){\\n                ans++;\\n            }\\n            if(ind+1<n && col[ind]==col[ind+1]){\\n                ans++;\\n            }\\n            adj.push_back(ans);\\n        }\\n        return adj;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\t\\n        vector<int> col(n,0);   //track color\\n        int ans=0;    //total adjacent \\n        vector<int> adj;   //final vector\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            int ind=queries[i][0];     //position\\n\\t\\t\\t\\n\\t\\t\\t//checking is changed before or not\\n            if(col[ind]!=0){\\n                if(ind>0 && col[ind-1]==col[ind]){\\n                    ans--;\\n                }\\n                if(ind+1<n && col[ind]==col[ind+1]){\\n                    ans--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//changing and checking for new color\\n            col[ind]=queries[i][1];\\n            if(ind>0 && col[ind-1]==col[ind]){\\n                ans++;\\n            }\\n            if(ind+1<n && col[ind]==col[ind+1]){\\n                ans++;\\n            }\\n            adj.push_back(ans);\\n        }\\n        return adj;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500417,
                "title": "easy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        A=[0]*n\\n        ans=[]\\n        \\n        for i in queries:\\n            \\n            count=ans[-1] if len(ans)>0 else 0\\n            if i[0] >0 and A[i[0]-1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            if i[0] <n-1 and A[i[0]+1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            A[i[0]]=i[1]\\n            if i[0] >0 and A[i[0]-1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            if i[0] <n-1 and A[i[0]+1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            \\n            ans.append(count)\\n        return ans\\n    \\n    \\n    \\n   \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        A=[0]*n\\n        ans=[]\\n        \\n        for i in queries:\\n            \\n            count=ans[-1] if len(ans)>0 else 0\\n            if i[0] >0 and A[i[0]-1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            if i[0] <n-1 and A[i[0]+1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            A[i[0]]=i[1]\\n            if i[0] >0 and A[i[0]-1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            if i[0] <n-1 and A[i[0]+1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            \\n            ans.append(count)\\n        return ans\\n    \\n    \\n    \\n   \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500409,
                "title": "c-carry-a-global-variable-for-counting-equal-adj-eles-before-after-executing-coloring-arr-q-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like explanation,You \\'can\\'..NOT FORCING AT ALL,Upvote! \\nThanks in advance :-)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)..brought from O(n^2) brute force..only due to global variable temp/cnt wise usage!!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size(),temp=0,i;\\n        vector<int> nums(n,0),ans(m,0);\\n        for(i=0;i<m;i++){\\n            int idx=q[i][0],clr=q[i][1];\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp--;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp--;\\n            nums[idx]=clr;\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp++;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp++;\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size(),temp=0,i;\\n        vector<int> nums(n,0),ans(m,0);\\n        for(i=0;i<m;i++){\\n            int idx=q[i][0],clr=q[i][1];\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp--;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp--;\\n            nums[idx]=clr;\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp++;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp++;\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499151,
                "title": "change-the-score-as-your-color-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        vector<int> ans;\\n        int score=0;\\n        for (vector<int> &query:queries)\\n        {\\n            int index=query[0];\\n            int new_color=query[1];\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score--;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score--;\\n            color[index]=new_color;\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score++;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score++;\\n            ans.push_back(score);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        vector<int> ans;\\n        int score=0;\\n        for (vector<int> &query:queries)\\n        {\\n            int index=query[0];\\n            int new_color=query[1];\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score--;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score--;\\n            color[index]=new_color;\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score++;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score++;\\n            ans.push_back(score);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498564,
                "title": "python-dict-with-sets",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        s=0\\n        d=defaultdict(set)\\n        arr=[0 for x in range(n)]\\n        r=[]\\n        for q in queries:\\n            if arr[q[0]]!=0:\\n                d[arr[q[0]]].remove(q[0])\\n                if q[0]+1 in d[arr[q[0]]]:s-=1\\n                if q[0]-1 in d[arr[q[0]]]:s-=1\\n            arr[q[0]]=q[1]\\n            if q[0]+1 in d[arr[q[0]]]:s+=1\\n            if q[0]-1 in d[arr[q[0]]]:s+=1\\n            d[arr[q[0]]].add(q[0])\\n            r.append(s)\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        s=0\\n        d=defaultdict(set)\\n        arr=[0 for x in range(n)]\\n        r=[]\\n        for q in queries:\\n            if arr[q[0]]!=0:\\n                d[arr[q[0]]].remove(q[0])\\n                if q[0]+1 in d[arr[q[0]]]:s-=1\\n                if q[0]-1 in d[arr[q[0]]]:s-=1\\n            arr[q[0]]=q[1]\\n            if q[0]+1 in d[arr[q[0]]]:s+=1\\n            if q[0]-1 in d[arr[q[0]]]:s+=1\\n            d[arr[q[0]]].add(q[0])\\n            r.append(s)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498549,
                "title": "easy-simple-intuitive-solution-breaking-and-adding-links-using-1-var",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust store value of adjacent occurrences and when new color comes break the link, substract prev occ if it was there and count adjacent colors again add to store value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n     where n=queries.size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+m)\\n    where n= n input array size\\n    where m= queries size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> colorTheArray(int n, vector<vector<int>> &queries)\\n{\\n    int qsize = queries.size();\\n    vector<int> res(n);\\n    int curr=0;\\n    vector<int> ans(qsize);\\n\\n    for (int i = 0; i < qsize; i++)\\n    {\\n        int ind = queries[i][0];\\n        int color = queries[i][1];\\n\\n        if (res[ind] != color)\\n        {\\n            int temp = 0;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if (ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n\\n            curr -= temp;\\n            temp = 0;\\n            res[ind] = color;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if ( ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n            curr += temp;\\n        }\\n        ans[i] = curr;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> colorTheArray(int n, vector<vector<int>> &queries)\\n{\\n    int qsize = queries.size();\\n    vector<int> res(n);\\n    int curr=0;\\n    vector<int> ans(qsize);\\n\\n    for (int i = 0; i < qsize; i++)\\n    {\\n        int ind = queries[i][0];\\n        int color = queries[i][1];\\n\\n        if (res[ind] != color)\\n        {\\n            int temp = 0;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if (ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n\\n            curr -= temp;\\n            temp = 0;\\n            res[ind] = color;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if ( ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n            curr += temp;\\n        }\\n        ans[i] = curr;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498314,
                "title": "simple-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        set<pair<int,int>>s;\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++){\\n            int id=q[i][0];\\n            int val=q[i][1];\\n            if(s.find({id-1,id})!=s.end()){\\n                s.erase({id-1,id});\\n            }\\n            if(s.find({id,id+1})!=s.end()){\\n                s.erase({id,id+1});\\n            }\\n            \\n            v[id]=val;\\n            if(id>0 && v[id-1]==v[id] && v[id-1]!=0 && v[id]!=0){\\n                s.insert({id-1,id});    \\n            }\\n            if(id<n-1 && v[id]==v[id+1] && v[id+1]!=0 && v[id]!=0){\\n                s.insert({id,id+1});\\n            }\\n            ans.push_back(s.size());\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        set<pair<int,int>>s;\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++){\\n            int id=q[i][0];\\n            int val=q[i][1];\\n            if(s.find({id-1,id})!=s.end()){\\n                s.erase({id-1,id});\\n            }\\n            if(s.find({id,id+1})!=s.end()){\\n                s.erase({id,id+1});\\n            }\\n            \\n            v[id]=val;\\n            if(id>0 && v[id-1]==v[id] && v[id-1]!=0 && v[id]!=0){\\n                s.insert({id-1,id});    \\n            }\\n            if(id<n-1 && v[id]==v[id+1] && v[id+1]!=0 && v[id]!=0){\\n                s.insert({id,id+1});\\n            }\\n            ans.push_back(s.size());\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498192,
                "title": "javascript-counting",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function (n, queries) {\\n  let counter = 0;\\n  const colors = new Array(n).fill(0);\\n  const ans = new Array(queries.length).fill();\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    const [idx, color] = queries[i];\\n    const prev = idx - 1 >= 0 ? colors[idx - 1] : 0;\\n    const next = idx + 1 < n ? colors[idx + 1] : 0;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter--;\\n    if (colors[idx] === next && colors[idx] > 0) counter--;\\n\\n    colors[idx] = color;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter++;\\n    if (colors[idx] === next && colors[idx] > 0) counter++;\\n\\n    ans[i] = counter;\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function (n, queries) {\\n  let counter = 0;\\n  const colors = new Array(n).fill(0);\\n  const ans = new Array(queries.length).fill();\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    const [idx, color] = queries[i];\\n    const prev = idx - 1 >= 0 ? colors[idx - 1] : 0;\\n    const next = idx + 1 < n ? colors[idx + 1] : 0;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter--;\\n    if (colors[idx] === next && colors[idx] > 0) counter--;\\n\\n    colors[idx] = color;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter++;\\n    if (colors[idx] === next && colors[idx] > 0) counter++;\\n\\n    ans[i] = counter;\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498185,
                "title": "3-approaches-count-count-with-sentinel-frequency-and-segments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // use an array of size n\\n    // maintain a count of adjacent elements\\n    vector<int> colorTheArrayDirectly(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0);\\n        vector<int> ret;\\n        \\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n\\n            // original color not 0\\n            if (arr[idx] > 0) {\\n                // making arr[idx - 1] not adjacent element\\n                if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                    adj--;\\n                }\\n                // making add[idx] not an adjacent element\\n                if (idx + 1 < n && arr[idx + 1] == arr[idx]) {\\n                    adj--;\\n                }\\n            }\\n\\n            arr[idx] = color;\\n            if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                adj++;\\n            }\\n            if (idx + 1 < n && arr[idx] == arr[idx + 1]) {\\n                adj++;\\n            }\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n    array of size n:       _ _ _ _ _\\n    array of size n + 2: _ _ _ _ _ _ _\\n    arr[0] and arr[n + 1] act as sentinel of array\\n    so that arr[1] can freely access arr[0] and arr[n] access arr[n + 1]\\n    */\\n    vector<int> colorTheArraySentinel(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n + 2, 0);\\n        vector<int> ret;\\n\\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            // [0, n-1] -> [1, n], arr[0] and arr[n+1] act as sentinel\\n            int idx = queries[i][0] + 1;\\n            int color = queries[i][1];\\n\\n            if (arr[idx] > 0) {\\n                adj -= arr[idx - 1] == arr[idx];\\n                adj -= arr[idx] == arr[idx + 1];\\n            }\\n\\n            arr[idx] = color;\\n            adj += arr[idx - 1] == arr[idx];\\n            adj += arr[idx] == arr[idx + 1];\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        // return colorTheArrayDirectly(n, queries);\\n        // return colorTheArraySentinel(n, queries);\\n\\n        /*\\n        adj elements of color = color frequency - color segments\\n        */\\n        vector<int> arr(n, 0), ret;\\n        // total number count\\n        unordered_map<int, int> freq;\\n        // number of segments for each number\\n        unordered_map<int, int> segs;\\n        \\n        // current number of adjacent elements\\n        int curr = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            /*\\n            if (arr[idx] == color) {\\n                ret.push_back(curr);\\n                continue;\\n            }\\n            */\\n            \\n            if (arr[idx] > 0) {\\n                bool left = idx > 0 && arr[idx - 1] == arr[idx];\\n                bool right = idx + 1 < n && arr[idx] == arr[idx + 1];\\n                curr -= freq[arr[idx]] - segs[arr[idx]];\\n                \\n                freq[arr[idx]]--;\\n                if (left && right) {\\n                    segs[arr[idx]]++;\\n                } else if (left || right) {\\n                    \\n                } else {\\n                    segs[arr[idx]]--;\\n                }\\n                curr += freq[arr[idx]] - segs[arr[idx]];\\n            }\\n            \\n            // update arr[idx] with color\\n            bool left = idx > 0 && arr[idx - 1] == color;\\n            bool right = idx + 1 < n && arr[idx + 1] == color;\\n            curr -= freq[color] - segs[color];\\n            \\n            freq[color]++;\\n            if (left && right) {\\n                segs[color]--;\\n            } else if (left || right) {\\n                \\n            } else {\\n                segs[color]++;\\n            }\\n            curr += freq[color] - segs[color];\\n            \\n            // std::cout << idx << \" \" << color << \" \" << curr << std::endl;\\n            ret.push_back(curr);\\n            arr[idx] = color;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // use an array of size n\\n    // maintain a count of adjacent elements\\n    vector<int> colorTheArrayDirectly(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0);\\n        vector<int> ret;\\n        \\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n\\n            // original color not 0\\n            if (arr[idx] > 0) {\\n                // making arr[idx - 1] not adjacent element\\n                if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                    adj--;\\n                }\\n                // making add[idx] not an adjacent element\\n                if (idx + 1 < n && arr[idx + 1] == arr[idx]) {\\n                    adj--;\\n                }\\n            }\\n\\n            arr[idx] = color;\\n            if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                adj++;\\n            }\\n            if (idx + 1 < n && arr[idx] == arr[idx + 1]) {\\n                adj++;\\n            }\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n    array of size n:       _ _ _ _ _\\n    array of size n + 2: _ _ _ _ _ _ _\\n    arr[0] and arr[n + 1] act as sentinel of array\\n    so that arr[1] can freely access arr[0] and arr[n] access arr[n + 1]\\n    */\\n    vector<int> colorTheArraySentinel(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n + 2, 0);\\n        vector<int> ret;\\n\\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            // [0, n-1] -> [1, n], arr[0] and arr[n+1] act as sentinel\\n            int idx = queries[i][0] + 1;\\n            int color = queries[i][1];\\n\\n            if (arr[idx] > 0) {\\n                adj -= arr[idx - 1] == arr[idx];\\n                adj -= arr[idx] == arr[idx + 1];\\n            }\\n\\n            arr[idx] = color;\\n            adj += arr[idx - 1] == arr[idx];\\n            adj += arr[idx] == arr[idx + 1];\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        // return colorTheArrayDirectly(n, queries);\\n        // return colorTheArraySentinel(n, queries);\\n\\n        /*\\n        adj elements of color = color frequency - color segments\\n        */\\n        vector<int> arr(n, 0), ret;\\n        // total number count\\n        unordered_map<int, int> freq;\\n        // number of segments for each number\\n        unordered_map<int, int> segs;\\n        \\n        // current number of adjacent elements\\n        int curr = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            /*\\n            if (arr[idx] == color) {\\n                ret.push_back(curr);\\n                continue;\\n            }\\n            */\\n            \\n            if (arr[idx] > 0) {\\n                bool left = idx > 0 && arr[idx - 1] == arr[idx];\\n                bool right = idx + 1 < n && arr[idx] == arr[idx + 1];\\n                curr -= freq[arr[idx]] - segs[arr[idx]];\\n                \\n                freq[arr[idx]]--;\\n                if (left && right) {\\n                    segs[arr[idx]]++;\\n                } else if (left || right) {\\n                    \\n                } else {\\n                    segs[arr[idx]]--;\\n                }\\n                curr += freq[arr[idx]] - segs[arr[idx]];\\n            }\\n            \\n            // update arr[idx] with color\\n            bool left = idx > 0 && arr[idx - 1] == color;\\n            bool right = idx + 1 < n && arr[idx + 1] == color;\\n            curr -= freq[color] - segs[color];\\n            \\n            freq[color]++;\\n            if (left && right) {\\n                segs[color]--;\\n            } else if (left || right) {\\n                \\n            } else {\\n                segs[color]++;\\n            }\\n            curr += freq[color] - segs[color];\\n            \\n            // std::cout << idx << \" \" << color << \" \" << curr << std::endl;\\n            ret.push_back(curr);\\n            arr[idx] = color;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3497938,
                "title": "kotlin-o-n",
                "content": "# Approach\\nWe keep track of color of adjecent neighbours as go through `queries` and make changes. We check color for `i - 1` and `i + 1` both **before** and **after** each change and update our count of number of adjecent elements of color variable `count` and set `res[i]` to `count`\\n\\nTime complexity is $$O(q)$$ where $$q$$ is the size of queries, and space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {\\n        val nums = IntArray(n)\\n\\n        val res = IntArray(queries.size)\\n        var count = 0\\n        for ((i, q) in queries.withIndex()) {\\n            val (e, c) = q\\n            \\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count--\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count--\\n\\n            nums[e] = c\\n\\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count++\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count++\\n\\n            res[i] = count\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {\\n        val nums = IntArray(n)\\n\\n        val res = IntArray(queries.size)\\n        var count = 0\\n        for ((i, q) in queries.withIndex()) {\\n            val (e, c) = q\\n            \\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count--\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count--\\n\\n            nums[e] = c\\n\\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count++\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count++\\n\\n            res[i] = count\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497911,
                "title": "java-100-speed-43-memory-o-n-in-line-comments",
                "content": "```\\n// Runtime: 5 ms, faster than 100.00% of Java online submissions for Number of Adjacent Elements With the Same Color.\\n// Memory Usage: 105.1 MB, less than 42.86% of Java online submissions for Number of Adjacent Elements With the Same Color.\\n    \\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        // let\\'s use array to store data about color and it position\\n\\t\\t// +2 in size we need to avoid checking is it first or last element in array\\n        int[] array = new int[n + 2];\\n\\t\\t// result array\\n        int[] result = new int[queries.length];\\n\\t\\t// counter of adjacent elements with the same color\\n        int count = 0;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            // color number\\n            int col = queries[i][1];\\n\\t\\t\\t// position number, we need make +1 to shift right because we have n+2 array length\\n            int pos = queries[i][0] + 1;\\n            \\n\\t\\t\\t// if this pos was \\'colored\\' already we need to check if we need decrease our counter \\n\\t\\t\\t// due to changing color value\\n            if (array[pos] != 0) {\\n                if (array[pos] == array[pos - 1]) {\\n                  count--;\\n                }\\n                \\n                if (array[pos] == array[pos + 1]) {\\n                count--;\\n                }            \\n            }\\n            \\n\\t\\t\\t// setting new color value\\n            array[pos] = col;\\n            \\n\\t\\t\\t// checking of we have same color value near by\\n            if (array[pos - 1] == col) {\\n               count++;\\n            }\\n            if (array[pos + 1] == col) {\\n               count++;\\n            }\\n            \\n            result[i] = count;\\n        }\\n        return result;\\n     }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        // let\\'s use array to store data about color and it position\\n\\t\\t// +2 in size we need to avoid checking is it first or last element in array\\n        int[] array = new int[n + 2];\\n\\t\\t// result array\\n        int[] result = new int[queries.length];\\n\\t\\t// counter of adjacent elements with the same color\\n        int count = 0;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            // color number\\n            int col = queries[i][1];\\n\\t\\t\\t// position number, we need make +1 to shift right because we have n+2 array length\\n            int pos = queries[i][0] + 1;\\n            \\n\\t\\t\\t// if this pos was \\'colored\\' already we need to check if we need decrease our counter \\n\\t\\t\\t// due to changing color value\\n            if (array[pos] != 0) {\\n                if (array[pos] == array[pos - 1]) {\\n                  count--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3497844,
                "title": "javascript-counting-neighbors",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    const nums = Array(n).fill(0);\\n    let count = 0;\\n    const res = [];\\n    \\n    for (const [index, color] of queries) {\\n        if (nums[index] === color) {\\n            res.push(count);\\n            \\n            continue;\\n        }    \\n        \\n        // change previous color on `index` position\\n        const old = nums[index];\\n        \\n        if (old !== 0) {\\n            let reduce = 0;\\n\\n            if (index > 0 && nums[index - 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            if (index < nums.length - 1 && nums[index + 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            count -= reduce;\\n        }\\n        \\n        // update new color on `index` position\\n        nums[index] = color;\\n        let add = 0;\\n        \\n        if (index > 0 && nums[index - 1] === color) {\\n            add += 1;\\n        }\\n        \\n        if (index < nums.length - 1 && nums[index + 1] === color) {\\n            add += 1;\\n        }\\n        \\n        count += add;\\n        \\n        res.push(count);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    const nums = Array(n).fill(0);\\n    let count = 0;\\n    const res = [];\\n    \\n    for (const [index, color] of queries) {\\n        if (nums[index] === color) {\\n            res.push(count);\\n            \\n            continue;\\n        }    \\n        \\n        // change previous color on `index` position\\n        const old = nums[index];\\n        \\n        if (old !== 0) {\\n            let reduce = 0;\\n\\n            if (index > 0 && nums[index - 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            if (index < nums.length - 1 && nums[index + 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            count -= reduce;\\n        }\\n        \\n        // update new color on `index` position\\n        nums[index] = color;\\n        let add = 0;\\n        \\n        if (index > 0 && nums[index - 1] === color) {\\n            add += 1;\\n        }\\n        \\n        if (index < nums.length - 1 && nums[index + 1] === color) {\\n            add += 1;\\n        }\\n        \\n        count += add;\\n        \\n        res.push(count);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497462,
                "title": "best-and-easy-approach-c-with-o-n-tc-and-constant-sc",
                "content": "# Intuition\\nThe intuition comes from understanding that we have to take ans while updating the array simultaneously and also we are only concerned with next and prev adjacent elements and not on others.\\n\\n# Approach\\nI have used a cnt variable which keeps the track of no of adjacent pairs having same colors and after each query i am checking is it was involved previously in any pair if so then reduce cnt and if after updating it make ant pair then increase cnt.\\n\\n# Complexity\\n- Time complexity:\\nTC - O(n)\\n\\n\\n- Space complexity:\\nSC - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      vector<int> nums(n,0);\\n      int cnt=0;\\n      int m=queries.size();\\n      vector<int> ans(m,0);\\n      for(int i=0;i<m;i++){\\n          int ind=queries[i][0];\\n          int col=queries[i][1];\\n          int pre=nums[ind];\\n          //if previously equal to adjacent elements then reduce the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==pre) cnt--;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==pre) cnt--;\\n          //update the color\\n          nums[ind]=col;\\n          //if after updating become equal to adjacent elements the increase the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==col) cnt++;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==col) cnt++;\\n          //pushing the current cnt in ans array\\n          ans[i]=cnt;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      vector<int> nums(n,0);\\n      int cnt=0;\\n      int m=queries.size();\\n      vector<int> ans(m,0);\\n      for(int i=0;i<m;i++){\\n          int ind=queries[i][0];\\n          int col=queries[i][1];\\n          int pre=nums[ind];\\n          //if previously equal to adjacent elements then reduce the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==pre) cnt--;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==pre) cnt--;\\n          //update the color\\n          nums[ind]=col;\\n          //if after updating become equal to adjacent elements the increase the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==col) cnt++;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==col) cnt++;\\n          //pushing the current cnt in ans array\\n          ans[i]=cnt;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496988,
                "title": "easy-solution-in-c-with-commented-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply checking no of contribution before adding color and after adding color will give the no of adjacent after sub after - before adj \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>nums(n);\\n        vector<int>ans;\\n        int c=0;\\n        for(auto i :queries){\\n             int color= i[1];\\n             int indx= i[0];\\n               \\n\\n            if(nums[indx]==color){\\n                ans.push_back(c);\\n            }\\n            else{\\n                int Bcnt=0; //checking before coloring the value \\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n\\n                //checking after coloring of ele\\n                int Acnt=0; //checking before coloring the value \\n                nums[indx]= color;\\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n          //FINAL ANS \\n              c+=(Acnt-Bcnt);\\n              ans.push_back(c);\\n            }\\n\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>nums(n);\\n        vector<int>ans;\\n        int c=0;\\n        for(auto i :queries){\\n             int color= i[1];\\n             int indx= i[0];\\n               \\n\\n            if(nums[indx]==color){\\n                ans.push_back(c);\\n            }\\n            else{\\n                int Bcnt=0; //checking before coloring the value \\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n\\n                //checking after coloring of ele\\n                int Acnt=0; //checking before coloring the value \\n                nums[indx]= color;\\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n          //FINAL ANS \\n              c+=(Acnt-Bcnt);\\n              ans.push_back(c);\\n            }\\n\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496962,
                "title": "simple-c-sol-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int qsize,n1;\\n    bool prevColor(int i,vector<int>&color){\\n        if(i==0) return false;\\n        return color[i-1]==color[i];\\n        \\n    }\\n    \\n     bool nxtColor(int i,vector<int>&color){\\n        if(i==n1-1) return false;\\n        return color[i+1]==color[i];\\n        \\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        n1=n;\\n        vector<int>color(n,0);\\n        int totalAdj=0;\\n         qsize=queries.size();\\n        vector<int>ans(qsize,0);\\n        for(int i=0;i<qsize;i++){\\n            int ind=queries[i][0],col=queries[i][1];\\n            if(color[ind]!=0){\\n                if(prevColor(ind,color)){\\n                    totalAdj--;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj--;\\n                }\\n            }\\n            color[ind]=col;\\n             if(prevColor(ind,color)){\\n                    totalAdj++;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj++;\\n                }\\n            ans[i]=totalAdj;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int qsize,n1;\\n    bool prevColor(int i,vector<int>&color){\\n        if(i==0) return false;\\n        return color[i-1]==color[i];\\n        \\n    }\\n    \\n     bool nxtColor(int i,vector<int>&color){\\n        if(i==n1-1) return false;\\n        return color[i+1]==color[i];\\n        \\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        n1=n;\\n        vector<int>color(n,0);\\n        int totalAdj=0;\\n         qsize=queries.size();\\n        vector<int>ans(qsize,0);\\n        for(int i=0;i<qsize;i++){\\n            int ind=queries[i][0],col=queries[i][1];\\n            if(color[ind]!=0){\\n                if(prevColor(ind,color)){\\n                    totalAdj--;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj--;\\n                }\\n            }\\n            color[ind]=col;\\n             if(prevColor(ind,color)){\\n                    totalAdj++;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj++;\\n                }\\n            ans[i]=totalAdj;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496922,
                "title": "c-easy-and-beginner-friendly",
                "content": "# Intuition\\nfocus only on neighbour colors,\\ne.g. \\nRRR\\nchanging rightmost to new color -> one adjacent will be affected\\nchanging leftmost to new color -> one adjacent will be affected\\nchanging middle to new color -> two adjacents will be affected\\n\\n# Approach\\nfor every color change -> count how many adjacents are affected and keep track of sum of all adjacents\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) : for using auxillary color array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, color(n,0);\\n        int adjacents=0;\\n        \\n        for(auto it: queries) {\\n            int index=it[0], newcolor=it[1], oldcolor=color[index];\\n            \\n            //old color\\n            int adj=0;\\n            if(index>0 && oldcolor==color[index-1] && oldcolor!=0) adj++;\\n            if(index<n-1 && oldcolor==color[index+1] && oldcolor!=0) adj++;\\n            adjacents-=adj;\\n            \\n            //new color\\n            adj=0;\\n            if(index>0 && newcolor==color[index-1]) adj++;\\n            if(index<n-1 && newcolor==color[index+1]) adj++;\\n            adjacents+=adj;\\n            \\n            color[index]=newcolor;\\n            ans.push_back(adjacents);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, color(n,0);\\n        int adjacents=0;\\n        \\n        for(auto it: queries) {\\n            int index=it[0], newcolor=it[1], oldcolor=color[index];\\n            \\n            //old color\\n            int adj=0;\\n            if(index>0 && oldcolor==color[index-1] && oldcolor!=0) adj++;\\n            if(index<n-1 && oldcolor==color[index+1] && oldcolor!=0) adj++;\\n            adjacents-=adj;\\n            \\n            //new color\\n            adj=0;\\n            if(index>0 && newcolor==color[index-1]) adj++;\\n            if(index<n-1 && newcolor==color[index+1]) adj++;\\n            adjacents+=adj;\\n            \\n            color[index]=newcolor;\\n            ans.push_back(adjacents);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496610,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially everything would be zero so the result is zero.  \\nFrom the first query the result will start changing, the idea is that whenever we change the color of an element it would only affect the neighbors and others would not be affected. So we need to add or subtract to the previous state of the color array based on whether the elements were satisfying before and not satisfying now or vice versa\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n).     \\n- Space complexity:\\n$$O(n+len(queries))\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        color_arr = [0]*n\\n        res = [0]\\n        \\n        def find_res_delta(curr_color1,next_color1,color2):\\n            curr_satisfying = curr_color1 == color2 and color2 != 0\\n            next_satisfying = next_color1 == color2 and color2 != 0\\n            \\n            if curr_satisfying and not next_satisfying:\\n                return -1\\n            elif not curr_satisfying and next_satisfying:\\n                return 1\\n            else:\\n                return 0\\n            \\n        \\n        for e_idx,color in queries:\\n            sub_res = res[-1]\\n            \\n            curr_color = color_arr[e_idx]\\n            next_color = color\\n            \\n            if e_idx > 0:\\n                sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx-1])\\n                if e_idx < n-1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            else:\\n                if n > 1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            \\n            color_arr[e_idx] = color\\n            \\n            res.append(sub_res)\\n                    \\n        return res[1:]\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        color_arr = [0]*n\\n        res = [0]\\n        \\n        def find_res_delta(curr_color1,next_color1,color2):\\n            curr_satisfying = curr_color1 == color2 and color2 != 0\\n            next_satisfying = next_color1 == color2 and color2 != 0\\n            \\n            if curr_satisfying and not next_satisfying:\\n                return -1\\n            elif not curr_satisfying and next_satisfying:\\n                return 1\\n            else:\\n                return 0\\n            \\n        \\n        for e_idx,color in queries:\\n            sub_res = res[-1]\\n            \\n            curr_color = color_arr[e_idx]\\n            next_color = color\\n            \\n            if e_idx > 0:\\n                sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx-1])\\n                if e_idx < n-1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            else:\\n                if n > 1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            \\n            color_arr[e_idx] = color\\n            \\n            res.append(sub_res)\\n                    \\n        return res[1:]\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496559,
                "title": "brute-force-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        arr = [0 for i in range(n)]\\n        count = 0\\n        ans = [0 for i in range(len(queries))]\\n        i = 0\\n        for idx,color in queries:\\n            \\n            if idx-1 >= 0 and arr[idx-1] == arr[idx]  and arr[idx-1] != 0:\\n                count -= 1\\n            if idx + 1 < n and arr[idx+1]  == arr[idx] and arr[idx+1] != 0 :\\n                count -= 1 \\n                \\n            arr[idx] = color\\n            \\n            if idx -1 >=0 and arr[idx-1] == arr[idx]:\\n                count += 1\\n            \\n            if idx + 1 < n and arr[idx] == arr[idx+1]:\\n                count += 1\\n            \\n            ans[i] = count\\n            i += 1\\n        \\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        arr = [0 for i in range(n)]\\n        count = 0\\n        ans = [0 for i in range(len(queries))]\\n        i = 0\\n        for idx,color in queries:\\n            \\n            if idx-1 >= 0 and arr[idx-1] == arr[idx]  and arr[idx-1] != 0:\\n                count -= 1\\n            if idx + 1 < n and arr[idx+1]  == arr[idx] and arr[idx+1] != 0 :\\n                count -= 1 \\n                \\n            arr[idx] = color\\n            \\n            if idx -1 >=0 and arr[idx-1] == arr[idx]:\\n                count += 1\\n            \\n            if idx + 1 < n and arr[idx] == arr[idx+1]:\\n                count += 1\\n            \\n            ans[i] = count\\n            i += 1\\n        \\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496454,
                "title": "c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simulate the process of painting cells. When painting the cell, all we should take into account are the left and right neighbours, what was `before` and `after` painting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSentinel: in order not to check boundaries, we can add additional cells to the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        int[] result = new int[queries.Length];\\n        int[] array = new int[n + 2];\\n\\n        for (int index = 0, count = 0; index < queries.Length; ++index) {\\n            int at = queries[index][0] + 1;\\n            int before = (array[at] == array[at - 1] && array[at] != 0 ? 1 : 0) + \\n                         (array[at] == array[at + 1] && array[at] != 0 ? 1 : 0);\\n            \\n            array[at] = queries[index][1];\\n            \\n            int after = (array[at] == array[at - 1] ? 1 : 0) + (array[at] == array[at + 1] ? 1 : 0);  \\n\\n            result[index] = (count += after - before);\\n        }\\n\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        int[] result = new int[queries.Length];\\n        int[] array = new int[n + 2];\\n\\n        for (int index = 0, count = 0; index < queries.Length; ++index) {\\n            int at = queries[index][0] + 1;\\n            int before = (array[at] == array[at - 1] && array[at] != 0 ? 1 : 0) + \\n                         (array[at] == array[at + 1] && array[at] != 0 ? 1 : 0);\\n            \\n            array[at] = queries[index][1];\\n            \\n            int after = (array[at] == array[at - 1] ? 1 : 0) + (array[at] == array[at + 1] ? 1 : 0);  \\n\\n            result[index] = (count += after - before);\\n        }\\n\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496443,
                "title": "from-o-n-q-to-o-q-track-the-count-of-adjacent-elements-with-the-same-color-as-we-go-along",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is that we check the adjacent elements with the same color as we go along.\\n\\n# Naive Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will need to update the nums array with the new color for each query, and then for each query, loop through the nums array to count the number of adjacent elements that have the same color.\\n\\n## Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(n * q)$$ \\n Here, n is the length of the array and q is the number of queries. This is because we loop through the entire `nums` array for each query. As the size of the array and the number of queries increase, this approach becomes very slow and inefficient.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$, where n is the length of the array.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int s = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> answer(s, 0);\\n\\n        for (int i = 0; i < s; i++) {\\n            nums[queries[i][0]] = queries[i][1];\\n            int count = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (nums[j] != 0 && nums[j] == nums[j+1]) {\\n                    count++;\\n                }\\n            }\\n            answer[i] = count;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\nAs the Code has a time complexity of $$O(n * q)$$; it will not work when the query.length is 10<sup>5</sup> and array length is also 10<sup>5</sup>.\\n\\n# Approach 2: A bit optimal\\nHere, I need to reduce the loop or decrease the complexity of the code from $$O(n \\\\cdot q)$$ to O(q) (processing the query does not take any time).*Italic* \\nIf I can keep the track of the count of adjacent elements with the same color as we go along, so that we don\\'t need to iterate over the entire nums array for each query. This way, we can compute the answer for each query in constant time.\\n\\nWe can keep track of a running `count` of the number of adjacent elements with the same color. \\nFor each query, \\n- We update the color at the specified index and check the adjacent elements to the left and right of the updated index. \\n- We increment the count if any of these adjacent elements have the same color as the new color. \\n- We also check the adjacent elements to the left and right of the updated index to see if they had the same color as the old color, and decrement the count if this is the case. \\n- Finally, we append the current count to the answer array and return it.\\n\\n## Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(q)$$, where q is the number of queries (we process each query in constant time).\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$, where n is the length of the array.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        vector<int> answer;\\n        int count = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index-1] != 0 && nums[index-1] == color) {\\n                count++;\\n            }\\n\\n            if (index < n-1 && nums[index+1] != 0 && nums[index+1] == color) {\\n                count++;\\n            }\\n\\n            if (prevColor != 0) {\\n                if (index > 0 && nums[index-1] != 0 && nums[index-1] == prevColor) {\\n                    count--;\\n                }\\n\\n                if (index < n-1 && nums[index+1] != 0 && nums[index+1] == prevColor) {\\n                    count--;\\n                }\\n            }\\n\\n            answer.push_back(count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int s = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> answer(s, 0);\\n\\n        for (int i = 0; i < s; i++) {\\n            nums[queries[i][0]] = queries[i][1];\\n            int count = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (nums[j] != 0 && nums[j] == nums[j+1]) {\\n                    count++;\\n                }\\n            }\\n            answer[i] = count;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        vector<int> answer;\\n        int count = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index-1] != 0 && nums[index-1] == color) {\\n                count++;\\n            }\\n\\n            if (index < n-1 && nums[index+1] != 0 && nums[index+1] == color) {\\n                count++;\\n            }\\n\\n            if (prevColor != 0) {\\n                if (index > 0 && nums[index-1] != 0 && nums[index-1] == prevColor) {\\n                    count--;\\n                }\\n\\n                if (index < n-1 && nums[index+1] != 0 && nums[index+1] == prevColor) {\\n                    count--;\\n                }\\n            }\\n\\n            answer.push_back(count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496420,
                "title": "most-optimized-solution-in-c-with-proper-explanation",
                "content": "# Intuition\\nThe intuition behind the given code is to simulate the color updates in an array and keep track of the count of adjacent elements with the same color before and after each update.\\n\\n# Approach\\nThe helper function takes the current count of adjacent elements with the same color, the array of colors, the index p of the element that was just colored, and a boolean flag to indicate whether we are adding or subtracting from the count. The function checks if the neighboring elements of the indexed element have the same color as the indexed element and are not uncolored (0). If so, it updates the count accordingly.\\n\\nIn the main function, we iterate through the queries one by one. For each query, we first call the helper function with the flag set to false to subtract the count of adjacent elements with the same color before changing the color of the indexed element. We then update the color of the indexed element in the temporary array \\'temp\\'. Finally, we call the helper function again with the flag set to true to add the count of adjacent elements with the same color after changing the color of the indexed element. We store the updated count in the \\'cur\\' variable and append it to the result array \\'res\\'.\\n\\nAt the end of the loop, we return the \\'res\\' array containing the counts of adjacent elements with the same color after each query.\\n\\n# Complexity\\n- Time complexity: $$O(nq)$$\\n\\n- Space complexity: $$O(n + q)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int temp, vector<int>& arr, int p, bool flag) {\\n        if (p > 0 && arr[p - 1] == arr[p] && arr[p - 1] != 0) temp += flag ? 1 : -1;\\n        \\n        if (p < arr.size() - 1 && arr[p + 1] == arr[p] && arr[p + 1] != 0) temp += flag ? 1 : -1;\\n        \\n        return temp;\\n    }\\n\\n    vector<int> colorTheArray(int n, vector<vector<int>>& inp) {\\n        int cur = 0;\\n        vector<int> temp(n, 0);\\n        vector<int> res;\\n\\n        for (auto q : inp) {\\n            int p = q[0];\\n            int c = q[1];\\n            cur = helper(cur, temp, p, false);\\n            temp[p] = c;\\n            cur = helper(cur, temp, p, true);\\n            res.emplace_back(cur);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int temp, vector<int>& arr, int p, bool flag) {\\n        if (p > 0 && arr[p - 1] == arr[p] && arr[p - 1] != 0) temp += flag ? 1 : -1;\\n        \\n        if (p < arr.size() - 1 && arr[p + 1] == arr[p] && arr[p + 1] != 0) temp += flag ? 1 : -1;\\n        \\n        return temp;\\n    }\\n\\n    vector<int> colorTheArray(int n, vector<vector<int>>& inp) {\\n        int cur = 0;\\n        vector<int> temp(n, 0);\\n        vector<int> res;\\n\\n        for (auto q : inp) {\\n            int p = q[0];\\n            int c = q[1];\\n            cur = helper(cur, temp, p, false);\\n            temp[p] = c;\\n            cur = helper(cur, temp, p, true);\\n            res.emplace_back(cur);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496356,
                "title": "easy-and-understandable-c-solution",
                "content": "# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n           vector<int> nums(n, 0);\\n           vector<int> ans(queries.size(), 0);           \\n           int count = 0;\\n           \\n           nums[queries[0][0]] = queries[0][1];\\n\\n          for(int i=1; i<queries.size(); i++)\\n           {\\n               int index= queries[i][0];\\n               int color = queries[i][1];\\n                   \\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count--;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                         && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count--;\\n          }\\n\\n        nums[index] = color;\\n\\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count++;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                        && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count++;\\n          }\\n\\n         ans[i] = count;\\n           }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n           vector<int> nums(n, 0);\\n           vector<int> ans(queries.size(), 0);           \\n           int count = 0;\\n           \\n           nums[queries[0][0]] = queries[0][1];\\n\\n          for(int i=1; i<queries.size(); i++)\\n           {\\n               int index= queries[i][0];\\n               int color = queries[i][1];\\n                   \\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count--;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                         && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count--;\\n          }\\n\\n        nums[index] = color;\\n\\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count++;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                        && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count++;\\n          }\\n\\n         ans[i] = count;\\n           }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496330,
                "title": "simple-manipulation-based-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int a[]=new int[n];\\n        int res[]=new int[queries.length];\\n        int s=0;\\n        for(int i=0;i<queries.length;i++){\\n            int x=queries[i][0];\\n            int c=queries[i][1];\\n            int cnt=0;\\n            if((x-1)>=0){\\n                if(a[x-1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if((x+1)<n){\\n                if(a[x+1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if(a[x]!=0){\\n                if((x-1)>=0){\\n                    if(a[x-1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n                if((x+1)<n){\\n                    if(a[x+1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n            }\\n            a[x]=c;\\n            s+=cnt;\\n            res[i]=s;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int a[]=new int[n];\\n        int res[]=new int[queries.length];\\n        int s=0;\\n        for(int i=0;i<queries.length;i++){\\n            int x=queries[i][0];\\n            int c=queries[i][1];\\n            int cnt=0;\\n            if((x-1)>=0){\\n                if(a[x-1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if((x+1)<n){\\n                if(a[x+1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if(a[x]!=0){\\n                if((x-1)>=0){\\n                    if(a[x-1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n                if((x+1)<n){\\n                    if(a[x+1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n            }\\n            a[x]=c;\\n            s+=cnt;\\n            res[i]=s;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496305,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(q)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>m(n,0);\\n        vector<int>ans;\\n        int mn=queries.size();\\n        int cnt=0;\\n        for(int i=0;i<mn;i++){\\n           int idx=queries[i][0];\\n           int val=queries[i][1];\\n           int prev=0;\\n           int next=0;\\n           if(idx-1>=0){\\n               prev=m[idx-1];\\n               \\n           }\\n           if(idx+1<n){\\n               next=m[idx+1];\\n           }\\n           if(m[idx]==prev && prev!=0){\\n               cnt--;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt--;\\n           }\\n           m[idx]=val;\\n           if(m[idx]==prev && prev!=0){\\n               cnt++;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt++;\\n           }\\n           ans.push_back(cnt);\\n        }return ans;\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>m(n,0);\\n        vector<int>ans;\\n        int mn=queries.size();\\n        int cnt=0;\\n        for(int i=0;i<mn;i++){\\n           int idx=queries[i][0];\\n           int val=queries[i][1];\\n           int prev=0;\\n           int next=0;\\n           if(idx-1>=0){\\n               prev=m[idx-1];\\n               \\n           }\\n           if(idx+1<n){\\n               next=m[idx+1];\\n           }\\n           if(m[idx]==prev && prev!=0){\\n               cnt--;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt--;\\n           }\\n           m[idx]=val;\\n           if(m[idx]==prev && prev!=0){\\n               cnt++;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt++;\\n           }\\n           ans.push_back(cnt);\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496214,
                "title": "c-solution-with-approach-and-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nJust remember that the max number by which the ans can change by changing one colour is just 2, one for the left side and one for the right side, and all others remain same. Once you get this, it is very simple\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector <int> ans;\\n        vector <int> arr(n,0);\\n        int tans = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n            if(oldColor){\\n                // need to take care of before math... that is subtract if you are reducing the adjacement elements.\\n                if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans--;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans--;\\n                    }\\n                }\\n            }\\n            // after changing the color, adding the newly formed adjacement elements.\\n            arr[index] = newColor;\\n            if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans++;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans++;\\n                    }\\n                }\\n            ans.push_back(tans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector <int> ans;\\n        vector <int> arr(n,0);\\n        int tans = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n            if(oldColor){\\n                // need to take care of before math... that is subtract if you are reducing the adjacement elements.\\n                if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans--;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans--;\\n                    }\\n                }\\n            }\\n            // after changing the color, adding the newly formed adjacement elements.\\n            arr[index] = newColor;\\n            if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans++;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans++;\\n                    }\\n                }\\n            ans.push_back(tans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496189,
                "title": "easy-to-follow",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] res = new int[queries.length];\\n        int[] freq = new int[n+2];\\n            \\n        for(int i = 0; i < queries.length; i++){\\n            int[] nums = queries[i];\\n            int index = nums[0];\\n            int value = nums[1];\\n            int prev = freq[index];\\n            if(i == 0){\\n                freq[index] = value;\\n                continue;\\n            }\\n            if(prev == value){\\n                res[i]= res[i-1];\\n                continue;\\n            }\\n            int minus = 0;\\n            int add = 0;\\n            if(index != 0 && freq[index-1] !=0 && freq[index-1] == prev){\\n                --minus;\\n            }\\n            if(freq[index+1] != 0 && freq[index+1] == prev){\\n                --minus;\\n            }\\n            if(index != 0 && value == freq[index-1]) add++;\\n            if(value == freq[index+1]) add++;\\n            \\n            freq[index] = value;\\n            res[i] = res[i-1] + add + minus;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] res = new int[queries.length];\\n        int[] freq = new int[n+2];\\n            \\n        for(int i = 0; i < queries.length; i++){\\n            int[] nums = queries[i];\\n            int index = nums[0];\\n            int value = nums[1];\\n            int prev = freq[index];\\n            if(i == 0){\\n                freq[index] = value;\\n                continue;\\n            }\\n            if(prev == value){\\n                res[i]= res[i-1];\\n                continue;\\n            }\\n            int minus = 0;\\n            int add = 0;\\n            if(index != 0 && freq[index-1] !=0 && freq[index-1] == prev){\\n                --minus;\\n            }\\n            if(freq[index+1] != 0 && freq[index+1] == prev){\\n                --minus;\\n            }\\n            if(index != 0 && value == freq[index-1]) add++;\\n            if(value == freq[index+1]) add++;\\n            \\n            freq[index] = value;\\n            res[i] = res[i-1] + add + minus;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496081,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>data(n) ;\\n        vector<int>ret ;\\n        int sum = 0 ;\\n        for(auto q : queries){\\n            int idx = q[0] ;\\n            int color = q[1] ;\\n            if(data[idx] == color){\\n                ret.push_back(sum) ;\\n                continue ;\\n            }\\n            if(data[idx] == 0){\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            else{\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum-- ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum-- ;\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            ret.push_back(sum) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>data(n) ;\\n        vector<int>ret ;\\n        int sum = 0 ;\\n        for(auto q : queries){\\n            int idx = q[0] ;\\n            int color = q[1] ;\\n            if(data[idx] == color){\\n                ret.push_back(sum) ;\\n                continue ;\\n            }\\n            if(data[idx] == 0){\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            else{\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum-- ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum-- ;\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            ret.push_back(sum) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496075,
                "title": "c-easy-counting-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> col(n,0),ans;int count=0;\\n        for(auto it : queries){\\n            int idx = it[0],c = it[1];\\n            if(col[idx]==0){\\n               if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n              }\\n            else if(c!=col[idx]){\\n                if(idx-1>=0 && col[idx]==col[idx-1])count--;\\n                if(idx+1<n && col[idx]==col[idx+1])count--;\\n                if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n            }\\n                col[idx] = c;\\n                ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> col(n,0),ans;int count=0;\\n        for(auto it : queries){\\n            int idx = it[0],c = it[1];\\n            if(col[idx]==0){\\n               if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n              }\\n            else if(c!=col[idx]){\\n                if(idx-1>=0 && col[idx]==col[idx-1])count--;\\n                if(idx+1<n && col[idx]==col[idx+1])count--;\\n                if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n            }\\n                col[idx] = c;\\n                ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496022,
                "title": "easy-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif prev and next is same before we need to reduce count,due to previous count of same element and then we count current same elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        temp = [0] * n\\n        res = []\\n        count = 0\\n        \\n        for i, j in queries:\\n            # print(count,res,temp,(i,j))\\n            prev, next = i - 1, i + 1\\n            # count=0\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            temp[i] = j\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count += 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count += 1\\n            res.append(count)\\n            \\n            \\n        return res\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        temp = [0] * n\\n        res = []\\n        count = 0\\n        \\n        for i, j in queries:\\n            # print(count,res,temp,(i,j))\\n            prev, next = i - 1, i + 1\\n            # count=0\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            temp[i] = j\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count += 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count += 1\\n            res.append(count)\\n            \\n            \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495990,
                "title": "c-very-easy-solution",
                "content": "```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int k = queries.size();\\n        vector<int> ans(k,0);\\n        vector<int> v(n, 0);\\n        v[queries[0][0]] = queries[0][1];\\n        ans[0] = 0;\\n        \\n        int count = 0;\\n        for(int i=1; i<k; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            //color nahi hai pehle se\\n            if(v[index] == 0)\\n            {\\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n            else\\n            {\\n                //pehle wala color ka ans data do count se kyuki new update hoga color ka\\n                if(index-1 >=0 && v[index-1] == v[index]) count--;\\n                if(index+1 < n && v[index+1] == v[index]) count--;\\n                \\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int k = queries.size();\\n        vector<int> ans(k,0);\\n        vector<int> v(n, 0);\\n        v[queries[0][0]] = queries[0][1];\\n        ans[0] = 0;\\n        \\n        int count = 0;\\n        for(int i=1; i<k; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            //color nahi hai pehle se\\n            if(v[index] == 0)\\n            {\\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n            else\\n            {\\n                //pehle wala color ka ans data do count se kyuki new update hoga color ka\\n                if(index-1 >=0 && v[index-1] == v[index]) count--;\\n                if(index+1 < n && v[index+1] == v[index]) count--;\\n                \\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495965,
                "title": "simple-cakewalk-10-line-code-o-n-time-specially-designed-for-beginner-s-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int ans=0; // storing the current existing value of the possible number of adjacent pairs count\\n        vector<int>arr(n,0); // initialise al of them initially with 0\\n        vector<int>res;\\n        for(auto x: queries){\\n            int i = x[0], val = x[1];\\n            // before inserting firstly check and subtract\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans--;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans--;\\n            arr[i]=val;\\n\\t\\t\\t// now after inserting check the same steps\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans++;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans++;\\n            res.push_back(ans);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity -> O(n)\\nSpace Complexity -> O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int ans=0; // storing the current existing value of the possible number of adjacent pairs count\\n        vector<int>arr(n,0); // initialise al of them initially with 0\\n        vector<int>res;\\n        for(auto x: queries){\\n            int i = x[0], val = x[1];\\n            // before inserting firstly check and subtract\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans--;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans--;\\n            arr[i]=val;\\n\\t\\t\\t// now after inserting check the same steps\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans++;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans++;\\n            res.push_back(ans);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495943,
                "title": "c-conditional-statements-easy-solution",
                "content": "# Intuition\\nAfter every query we only need to care about the left and right element of the changed index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n);\\n        int cnt = 0;\\n        int k = queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            int idx = queries[i][0];\\n            int col = queries[i][1];\\n            if(idx-1>=0 && idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    if(nums[idx]!=col)\\n                    cnt-=2;\\n                    nums[idx] = col;\\n                }\\n                else if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n                else if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n                else \\n                {\\n                    nums[idx] = col; \\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;   \\n                }\\n            }\\n            else if(idx-1>=0)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n            }\\n            else if(idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n);\\n        int cnt = 0;\\n        int k = queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            int idx = queries[i][0];\\n            int col = queries[i][1];\\n            if(idx-1>=0 && idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    if(nums[idx]!=col)\\n                    cnt-=2;\\n                    nums[idx] = col;\\n                }\\n                else if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n                else if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n                else \\n                {\\n                    nums[idx] = col; \\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;   \\n                }\\n            }\\n            else if(idx-1>=0)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n            }\\n            else if(idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495931,
                "title": "just-focus-on-those-neighbor-blocks-before-and-after-colored-index",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut graph = vec![0; n as usize];\\n        let mut result = vec![];\\n        let mut temp = 0;\\n\\n        for query in queries.iter() {\\n            let index = query[0] as usize;\\n            let color = query[1];\\n\\n            for index_graph in [index-1, index+1] {\\n                // valid index between 0 ~ n-1\\n                if index_graph < 0 || index_graph >= graph.len() {\\n                    continue;\\n                }\\n\\n                // original color isn\\'t 0 && new color != old color\\n                if graph[index] != 0 && color != graph[index] {\\n                    // before colored: 2 neighbor colors both equal\\n                    if graph[index_graph] == graph[index] {\\n                        temp -= 1;\\n                    }\\n                    // after colored: 2 neighbor colors both equal\\n                    else if graph[index_graph] == color {\\n                        temp += 1;\\n                    }\\n                }\\n                // original color is 0 && color in both positions are equal after colored\\n                else if graph[index] == 0 && graph[index_graph] == color {\\n                    temp += 1;\\n                }\\n            }\\n            result.push(temp);\\n\\n            graph[index] = color;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut graph = vec![0; n as usize];\\n        let mut result = vec![];\\n        let mut temp = 0;\\n\\n        for query in queries.iter() {\\n            let index = query[0] as usize;\\n            let color = query[1];\\n\\n            for index_graph in [index-1, index+1] {\\n                // valid index between 0 ~ n-1\\n                if index_graph < 0 || index_graph >= graph.len() {\\n                    continue;\\n                }\\n\\n                // original color isn\\'t 0 && new color != old color\\n                if graph[index] != 0 && color != graph[index] {\\n                    // before colored: 2 neighbor colors both equal\\n                    if graph[index_graph] == graph[index] {\\n                        temp -= 1;\\n                    }\\n                    // after colored: 2 neighbor colors both equal\\n                    else if graph[index_graph] == color {\\n                        temp += 1;\\n                    }\\n                }\\n                // original color is 0 && color in both positions are equal after colored\\n                else if graph[index] == 0 && graph[index_graph] == color {\\n                    temp += 1;\\n                }\\n            }\\n            result.push(temp);\\n\\n            graph[index] = color;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495897,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr = new int[n];\\n        int res[] = new int[queries.length], prevRes = 0, count = 0;\\n        for(int query[]: queries){\\n            int ind = query[0];\\n            if(ind > 0 && ind < n - 1 && arr[ind] != 0){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes -= 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes --;\\n                else if(arr[ind] == arr[ind + 1]) prevRes --;\\n            }\\n            if(ind == 0 && ind + 1 < n && arr[ind] != 0){\\n                if(arr[ind] == arr[ind + 1]) prevRes -= 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0 && arr[ind] != 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes -= 1;\\n            }\\n            \\n            arr[ind] = query[1];\\n            if(ind > 0 && ind < n - 1){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes += 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes ++;\\n                else if(arr[ind] == arr[ind + 1]) prevRes ++;\\n            }\\n            if(ind == 0 && ind + 1 < n){\\n                if(arr[ind] == arr[ind + 1]) prevRes += 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes += 1;\\n            }\\n            res[count] = prevRes;\\n            count ++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr = new int[n];\\n        int res[] = new int[queries.length], prevRes = 0, count = 0;\\n        for(int query[]: queries){\\n            int ind = query[0];\\n            if(ind > 0 && ind < n - 1 && arr[ind] != 0){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes -= 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes --;\\n                else if(arr[ind] == arr[ind + 1]) prevRes --;\\n            }\\n            if(ind == 0 && ind + 1 < n && arr[ind] != 0){\\n                if(arr[ind] == arr[ind + 1]) prevRes -= 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0 && arr[ind] != 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes -= 1;\\n            }\\n            \\n            arr[ind] = query[1];\\n            if(ind > 0 && ind < n - 1){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes += 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes ++;\\n                else if(arr[ind] == arr[ind + 1]) prevRes ++;\\n            }\\n            if(ind == 0 && ind + 1 < n){\\n                if(arr[ind] == arr[ind + 1]) prevRes += 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes += 1;\\n            }\\n            res[count] = prevRes;\\n            count ++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495880,
                "title": "properly-commented-beginner-friendly-fast-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n    int[]ans=new int[queries.length];//this is the answer array\\n    int []nums=new int[n];//nums array of length n\\n    int count=0;//it stores the number of adjacent element\\n    for(int i=0;i<queries.length;i++){\\n    int index=queries[i][0];\\n    int prevval=nums[index];//it store the previous value of the index\\n    //guyz before panting the index we check that if the previous value is contributing to the count variable or not in simple words we are gonna check that if the previous value has the same colored adjacent values or not if yes then we are gonna subtract 2(if both adjacent were same) or 1(if only one adjacent is same)\\n    if(prevval!=0)\\n    {\\n    if(index>0&&prevval==nums[index-1]&&index<nums.length-1&&prevval==nums[index+1]){\\n        count-=2;\\n    }\\n    else if(index>0&&prevval==nums[index-1]||index<nums.length-1&&prevval==nums[index+1]){\\n        count-=1;\\n    }\\n    }\\n    nums[index]=queries[i][1];\\n//now after coloring the index we check whether the index have same colored adjacent or not if yes then we will add values in the count variable accordingly\\n    if(index>0&&nums[index]==nums[index-1]&&index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=2;\\n    }\\n    else if(index>0&&nums[index]==nums[index-1]||index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=1;\\n    }\\n\\n    ans[i]=count;//storing the count variable value into answer array\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n    int[]ans=new int[queries.length];//this is the answer array\\n    int []nums=new int[n];//nums array of length n\\n    int count=0;//it stores the number of adjacent element\\n    for(int i=0;i<queries.length;i++){\\n    int index=queries[i][0];\\n    int prevval=nums[index];//it store the previous value of the index\\n    //guyz before panting the index we check that if the previous value is contributing to the count variable or not in simple words we are gonna check that if the previous value has the same colored adjacent values or not if yes then we are gonna subtract 2(if both adjacent were same) or 1(if only one adjacent is same)\\n    if(prevval!=0)\\n    {\\n    if(index>0&&prevval==nums[index-1]&&index<nums.length-1&&prevval==nums[index+1]){\\n        count-=2;\\n    }\\n    else if(index>0&&prevval==nums[index-1]||index<nums.length-1&&prevval==nums[index+1]){\\n        count-=1;\\n    }\\n    }\\n    nums[index]=queries[i][1];\\n//now after coloring the index we check whether the index have same colored adjacent or not if yes then we will add values in the count variable accordingly\\n    if(index>0&&nums[index]==nums[index-1]&&index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=2;\\n    }\\n    else if(index>0&&nums[index]==nums[index-1]||index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=1;\\n    }\\n\\n    ans[i]=count;//storing the count variable value into answer array\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495771,
                "title": "python-with-explain-is-cumulative-count",
                "content": "# Intuition\\n Each query operation colors an element at a specific index. The color array and counter are updated accordingly. After each query, the ***cumulative count*** of adjacent elements with the same non-zero color is calculated. The previous adjacent elements are checked and updated (-1) before adding the new element, and then the neighboring elements are checked again to determine if they should be counted (+1).\\n\\n\\nI didn\\'t notice the problem of calculating the accumulation ...\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        nums = [0]*n\\n        count = 0\\n\\n        for i in range(len(queries)):\\n            \\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n            \\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        nums = [0]*n\\n        count = 0\\n\\n        for i in range(len(queries)):\\n            \\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n            \\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495650,
                "title": "c-o-length-of-queries-using-map",
                "content": "# Intuition\\nKeep a count of the values as we iterate inside a map. Any change to that index, check if it still maintains its adjacent rule. If not, decrease the count!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<queries.size();i++){\\n            int idx=queries[i][0];\\n            int col = queries[i][1];\\n            arr[idx]=col;\\n                           \\n            if(idx>0 && idx<n && arr[idx-1]==arr[idx]){\\n cout<<\",\"<<mp.size();\\n                mp[idx]=1;\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]==arr[idx+1]){\\n  cout<<\",\"<<mp.size();\\n                mp[idx+1]=1;\\n            }\\n            if(idx>0 && idx<n && arr[idx-1]!=arr[idx] && mp.count(idx)>0){\\n\\n                mp.erase(idx);\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]!=arr[idx+1] && mp.count(idx+1)>0){\\n \\n                mp.erase(idx+1);\\n            }\\n\\n            ans.push_back(mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<queries.size();i++){\\n            int idx=queries[i][0];\\n            int col = queries[i][1];\\n            arr[idx]=col;\\n                           \\n            if(idx>0 && idx<n && arr[idx-1]==arr[idx]){\\n cout<<\",\"<<mp.size();\\n                mp[idx]=1;\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]==arr[idx+1]){\\n  cout<<\",\"<<mp.size();\\n                mp[idx+1]=1;\\n            }\\n            if(idx>0 && idx<n && arr[idx-1]!=arr[idx] && mp.count(idx)>0){\\n\\n                mp.erase(idx);\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]!=arr[idx+1] && mp.count(idx+1)>0){\\n \\n                mp.erase(idx+1);\\n            }\\n\\n            ans.push_back(mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495552,
                "title": "runtime-and-memory-beats-100-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    let nums = Array(n).fill(0);\\n    let ans = [];\\n    let memo = 0;\\n    for (let i = 0; i < queries.length; i++) {\\n        let [index, color] = queries[i];\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo--;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo--;\\n        }\\n\\n        nums[index] = color;\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo++;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo++;\\n        }\\n        ans.push(memo);\\n\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    let nums = Array(n).fill(0);\\n    let ans = [];\\n    let memo = 0;\\n    for (let i = 0; i < queries.length; i++) {\\n        let [index, color] = queries[i];\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo--;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo--;\\n        }\\n\\n        nums[index] = color;\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo++;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo++;\\n        }\\n        ans.push(memo);\\n\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1885909,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1938646,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1887072,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1936711,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1885455,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Losers of the Circular Game",
        "question_content": "<p>There are <code>n</code> friends that are playing a game. The friends are sitting in a circle and are numbered from <code>1</code> to <code>n</code> in <strong>clockwise order</strong>. More formally, moving clockwise from the <code>i<sup>th</sup></code> friend brings you to the <code>(i+1)<sup>th</sup></code> friend for <code>1 &lt;= i &lt; n</code>, and moving clockwise from the <code>n<sup>th</sup></code> friend brings you to the <code>1<sup>st</sup></code> friend.</p>\n\n<p>The rules of the game are as follows:</p>\n\n<p><code>1<sup>st</sup></code> friend receives the ball.</p>\n\n<ul>\n\t<li>After that, <code>1<sup>st</sup></code> friend passes it to the friend who is <code>k</code> steps away from them in the <strong>clockwise</strong> direction.</li>\n\t<li>After that, the friend who receives the ball should pass it to the friend who is <code>2 * k</code> steps away from them in the <strong>clockwise</strong> direction.</li>\n\t<li>After that, the friend who receives the ball should pass it to the friend who is <code>3 * k</code> steps away from them in the <strong>clockwise</strong> direction, and so on and so forth.</li>\n</ul>\n\n<p>In other words, on the <code>i<sup>th</sup></code> turn, the friend holding the ball should pass it to the friend who is <code>i * k</code> steps away from them in the <strong>clockwise</strong> direction.</p>\n\n<p>The game is finished when some friend receives the ball for the second time.</p>\n\n<p>The <strong>losers</strong> of the game are friends who did not receive the ball in the entire game.</p>\n\n<p>Given the number of friends, <code>n</code>, and an integer <code>k</code>, return <em>the array answer, which contains the losers of the game in the <strong>ascending</strong> order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, k = 2\n<strong>Output:</strong> [4,5]\n<strong>Explanation:</strong> The game goes as follows:\n1) Start at 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 2 steps away from them - 3<sup>rd</sup>&nbsp;friend.\n2) 3<sup>rd</sup>&nbsp;friend passes the ball to the friend who is 4 steps away from them - 2<sup>nd</sup>&nbsp;friend.\n3) 2<sup>nd</sup>&nbsp;friend passes the ball to the friend who is 6 steps away from them  - 3<sup>rd</sup>&nbsp;friend.\n4) The game ends as 3<sup>rd</sup>&nbsp;friend receives the ball for the second time.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 4\n<strong>Output:</strong> [2,3,4]\n<strong>Explanation:</strong> The game goes as follows:\n1) Start at the 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 4 steps away from them - 1<sup>st</sup>&nbsp;friend.\n2) The game ends as 1<sup>st</sup>&nbsp;friend receives the ball for the second time.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3522190,
                "title": "simulation",
                "content": "We pre-populate the result array with all numbers, and set a number to zero once visited.\\n\\nAfter the simulation, we return remaining non-zero numbers.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        s = set([i for i in range(1, n + 1)])\\n        for mul in accumulate([i for i in range(n)]):\\n            if k * mul % n + 1 not in s:\\n                break\\n            s.remove(k * mul % n + 1)\\n        return s\\n```\\n\\n**C++**\\n``` cpp\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> res(n);\\n    iota(begin(res), end(res), 1);\\n    for (int cur = 0, mul = 1; res[cur]; ++mul) {\\n        res[cur] = 0;\\n        cur = (cur + mul * k) % n;\\n    }\\n    res.erase(remove(begin(res), end(res), 0), end(res));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        s = set([i for i in range(1, n + 1)])\\n        for mul in accumulate([i for i in range(n)]):\\n            if k * mul % n + 1 not in s:\\n                break\\n            s.remove(k * mul % n + 1)\\n        return s\\n```\n``` cpp\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> res(n);\\n    iota(begin(res), end(res), 1);\\n    for (int cur = 0, mul = 1; res[cur]; ++mul) {\\n        res[cur] = 0;\\n        cur = (cur + mul * k) % n;\\n    }\\n    res.erase(remove(begin(res), end(res), 0), end(res));\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521949,
                "title": "simple-bruteforce",
                "content": "\\n<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Just take an array and keep tracking its value with bruteforce.\\n    \\n# Code\\n\\n```\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> v(n, 0);\\n    int i = 1, t = 0; \\n    while(v[i-1] == 0){\\n        v[i-1] = 1;\\n        t = t + k;\\n        i = (i + t)%n;\\n        if(i == 0) i = n;\\n    }\\n    vector<int> ans;\\n    for(int i = 0; i < v.size(); ++i){\\n        if(v[i] == 0) ans.push_back(i+1);\\n    }\\n    return ans;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> v(n, 0);\\n    int i = 1, t = 0; \\n    while(v[i-1] == 0){\\n        v[i-1] = 1;\\n        t = t + k;\\n        i = (i + t)%n;\\n        if(i == 0) i = n;\\n    }\\n    vector<int> ans;\\n    for(int i = 0; i < v.size(); ++i){\\n        if(v[i] == 0) ans.push_back(i+1);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521902,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean visited[] = new boolean[n];\\n        int v = 0, i=0;\\n        while(visited[i%n] == false){\\n            v++;\\n            visited[i%n] = true;\\n            i += v*k;\\n        }\\n        int[] res = new int[n-v];\\n        int j=0;\\n        for(i=0; i<visited.length; i++){\\n            if(visited[i] == false) res[j++]=i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean visited[] = new boolean[n];\\n        int v = 0, i=0;\\n        while(visited[i%n] == false){\\n            v++;\\n            visited[i%n] = true;\\n            i += v*k;\\n        }\\n        int[] res = new int[n-v];\\n        int j=0;\\n        for(i=0; i<visited.length; i++){\\n            if(visited[i] == false) res[j++]=i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522531,
                "title": "most-optimised-c-easy-to-understnad",
                "content": "make an array of size n. initially no one have ball so all are false.\\n1st person have ball\\nthan 1+i*k person have ball (i = ith step)\\nmodulo is use for circular\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 1,y=1;\\n        vector<int> v(n+1,false);\\n            // cout<<y<<\" \";\\n        while(!v[y]){\\n            v[y] = true;\\n            y = ((y+x*k)%n);\\n            if(y==0)y = n;\\n            // cout<<y<<\" \";\\n            x++;\\n        }\\n        vector<int> ans;\\n        for(x = 1; x <= n; x++){\\n            if(!v[x])ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 1,y=1;\\n        vector<int> v(n+1,false);\\n            // cout<<y<<\" \";\\n        while(!v[y]){\\n            v[y] = true;\\n            y = ((y+x*k)%n);\\n            if(y==0)y = n;\\n            // cout<<y<<\" \";\\n            x++;\\n        }\\n        vector<int> ans;\\n        for(x = 1; x <= n; x++){\\n            if(!v[x])ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522350,
                "title": "c-best-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n, 0);\\n        int i=0, j=1;\\n        while(1)    {\\n            if(vis[i] == 1) break;\\n            vis[i] = 1;\\n            i = (i + j*k) % n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)  {\\n            if(vis[i] == 0) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n, 0);\\n        int i=0, j=1;\\n        while(1)    {\\n            if(vis[i] == 1) break;\\n            vis[i] = 1;\\n            i = (i + j*k) % n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)  {\\n            if(vis[i] == 0) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528741,
                "title": "java-beats-99-10-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Maintain a boolean map of size `n`.\\n2. Simulate the scenario described in the problem statement and keep marking each player that receives the ball in the map.\\n3. Break the loop once the ball reaches a player that had already got it before.\\n4. Parse through the boolean map and extract the indices of the players that didn\\'t receive the ball at all.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] circularGameLosers(int n, int k) {\\n    var map = new boolean[n];\\n    int x = 0, i;\\n    \\n    for (i=1; !map[x]; i++) {\\n      map[x] = true;\\n      x = (x + i*k) % n;\\n    }\\n    var ans = new int[n-i+1];\\n    var j = 0;\\n\\n    for (i=0; i<n; i++)\\n      if (!map[i])\\n        ans[j++] = i+1;\\n\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public int[] circularGameLosers(int n, int k) {\\n    var map = new boolean[n];\\n    int x = 0, i;\\n    \\n    for (i=1; !map[x]; i++) {\\n      map[x] = true;\\n      x = (x + i*k) % n;\\n    }\\n    var ans = new int[n-i+1];\\n    var j = 0;\\n\\n    for (i=0; i<n; i++)\\n      if (!map[i])\\n        ans[j++] = i+1;\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522093,
                "title": "simulation-easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        start = 0\\n        sset = set()\\n        p = 1\\n        while start not in sset:\\n            sset.add(start)\\n            start += p*k\\n            start = start%n\\n            p += 1\\n        ans = []\\n        for i in range(n):\\n            if i not in sset:\\n                ans.append(i+1)\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        start = 0\\n        sset = set()\\n        p = 1\\n        while start not in sset:\\n            sset.add(start)\\n            start += p*k\\n            start = start%n\\n            p += 1\\n        ans = []\\n        for i in range(n):\\n            if i not in sset:\\n                ans.append(i+1)\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531491,
                "title": "python-3-7-lines-w-example-t-m-100-78",
                "content": "```\\nclass Solution:\\n    def circularGameLosers(self, n, k):\\n\\n        remain, ball, nxt = set(N:=range(1,n)), k,0\\n\\n        for _ in N:                         #  Example: n = 5   k = 2\\n\\n            nxt = (nxt + ball)%n            #  ball     nxt    remain\\n            if nxt not in remain: break     #  -----   -----   -----\\n                                            #    2       0     [1, 2, 3, 4]\\n            remain.remove(nxt)              #    4       2     [1, 3, 4]\\n            ball+= k                        #    6       1     [3, 4]\\n                                            #    6       2     [3, 4] <-- 2 appears again\\n\\n        return [i+1 for i in remain]        #  return [3+1, 4+1] --> [4, 5]\\n```\\n[https://leetcode.com/problems/find-the-losers-of-the-circular-game/submissions/1006269450/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n\\n[Edited 7/28/23] See [@almostmonday](/almostmonday) in comments.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n, k):\\n\\n        remain, ball, nxt = set(N:=range(1,n)), k,0\\n\\n        for _ in N:                         #  Example: n = 5   k = 2\\n\\n            nxt = (nxt + ball)%n            #  ball     nxt    remain\\n            if nxt not in remain: break     #  -----   -----   -----\\n                                            #    2       0     [1, 2, 3, 4]\\n            remain.remove(nxt)              #    4       2     [1, 3, 4]\\n            ball+= k                        #    6       1     [3, 4]\\n                                            #    6       2     [3, 4] <-- 2 appears again\\n\\n        return [i+1 for i in remain]        #  return [3+1, 4+1] --> [4, 5]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523206,
                "title": "poetic-solution-experimental-solution-c",
                "content": "# Code in Poem\\n\\nAmidst a circle of players fair,\\nA game is played with utmost care.\\nEvery kth player must be gone,\\nUntil just one is left alone.\\n\\nTo simulate this game we\\'ll try,\\nUsing a map to bid goodbye.\\nEliminating till the end,\\nKeeping track of all our friends.\\n\\nWith time complexity of n,\\nAnd space complexity of the same yen.\\nThe code we\\'ll write in just a snap,\\nTo solve the problem with a tap.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n         vector<int> ans;\\n        map<int,int> mp;\\n        int i=1,j=k;\\n       \\n        \\n        while(mp.find(i)==mp.end())\\n        {\\n            mp[i]++;\\n            i = (i+k)%n;\\n            if(i == 0)\\n            {\\n                i = n;\\n            }\\n            \\n            k=k+j;\\n            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i) == mp.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n         vector<int> ans;\\n        map<int,int> mp;\\n        int i=1,j=k;\\n       \\n        \\n        while(mp.find(i)==mp.end())\\n        {\\n            mp[i]++;\\n            i = (i+k)%n;\\n            if(i == 0)\\n            {\\n                i = n;\\n            }\\n            \\n            k=k+j;\\n            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i) == mp.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535150,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem asks us to find the losers of a circular game played by n friends sitting in a circle. The game involves passing a ball between friends according to certain rules. The losers of the game are friends who did not receive the ball in the entire game. Our first thought might be to simulate the game and keep track of the friends who have received the ball.\\n\\n# Approach\\n1. We can use an array `visited` of size n to keep track of the friends who have received the ball. We initialize all elements of `visited` to 0.\\n2. We then use a while loop to simulate the game. In each iteration of the loop, we calculate the next friend to receive the ball using the formula `pos = (pos+(count*k))%n` where `pos` is the current friend holding the ball, `count` is the turn number, and `k` is the number of steps to move in the clockwise direction.\\n3. We increment `visited[pos]` by 1 to indicate that this friend has received the ball. If `visited[pos]` becomes 2, it means that this friend has received the ball for the second time and the game is finished.\\n4. After simulating the game, we can iterate over `visited` and add all friends who have not received the ball to a list `res`. We then return `res` which contains the losers of the game.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of friends. This is because we need to simulate n turns of the game and each turn takes constant time.\\n- Space complexity: $$O(n)$$ since we use an array of size n to keep track of the friends who have received the ball.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        visited = [0] * n\\n        count = 1\\n        pos = 0\\n        visited[pos] = 1\\n        while (visited[pos]!=2):\\n            pos = (pos+(count*k))%n\\n            visited[pos]+=1\\n            count+=1\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        visited = [0] * n\\n        count = 1\\n        pos = 0\\n        visited[pos] = 1\\n        while (visited[pos]!=2):\\n            pos = (pos+(count*k))%n\\n            visited[pos]+=1\\n            count+=1\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534872,
                "title": "python-simple-and-clean-beats-93-99",
                "content": "# Intuition\\nThe problem asks us to find the losers of a circular game played by n friends sitting in a circle. The game involves passing a ball between friends according to certain rules. The losers of the game are friends who did not receive the ball in the entire game. Our first thought might be to simulate the game and keep track of the friends who have not received the ball yet.\\n\\n# Approach\\n1. We can use a list `res` to keep track of the friends who have not received the ball yet. We initialize `res` with all the friends from 1 to n and remove the first friend since they receive the ball first.\\n2. We then use a while loop to simulate the game. In each iteration of the loop, we calculate the next friend to receive the ball using the formula `curr = (curr+(count*k))%n` where `curr` is the current friend holding the ball, `count` is the turn number, and `k` is the number of steps to move in the clockwise direction.\\n3. If `curr` is not in `res`, it means that this friend has already received the ball and the game is finished. In this case, we return `res` which contains the losers of the game. Otherwise, we remove `curr` from `res` and increment `count`.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where n is the number of friends. This is because in the worst case, we need to remove n-1 elements from `res`, and removing an element from a list takes $$O(n)$$ time.\\n- Space complexity: $$O(n)$$ since we use a list of size n to keep track of the friends who have not received the ball yet.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        res = [i for i in range(1,n+1)]\\n        res.remove(1)\\n        curr = 1\\n        count = 1\\n        while True:\\n            curr = (curr+(count*k))%n\\n            if curr == 0:\\n                curr = n\\n            if curr not in res:\\n                return res\\n            else:\\n                res.remove(curr)\\n            count+=1                \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        res = [i for i in range(1,n+1)]\\n        res.remove(1)\\n        curr = 1\\n        count = 1\\n        while True:\\n            curr = (curr+(count*k))%n\\n            if curr == 0:\\n                curr = n\\n            if curr not in res:\\n                return res\\n            else:\\n                res.remove(curr)\\n            count+=1                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522915,
                "title": "easy-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> gotBall = new HashSet<>();\\n        \\n        for(int i=1,mul=1;!gotBall.contains(i); i = (i+(k*mul))%n,mul++){\\n            gotBall.add(i);\\n        }\\n        if(gotBall.contains(0)){\\n            gotBall.add(n);\\n            gotBall.remove(0);\\n        }\\n        int[] ans = new int[n-gotBall.size()];\\n        int index = 0;\\n        for(int i=1;i<=n;i++) if(!gotBall.contains(i)) ans[index++] = i;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> gotBall = new HashSet<>();\\n        \\n        for(int i=1,mul=1;!gotBall.contains(i); i = (i+(k*mul))%n,mul++){\\n            gotBall.add(i);\\n        }\\n        if(gotBall.contains(0)){\\n            gotBall.add(n);\\n            gotBall.remove(0);\\n        }\\n        int[] ans = new int[n-gotBall.size()];\\n        int index = 0;\\n        for(int i=1;i<=n;i++) if(!gotBall.contains(i)) ans[index++] = i;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525573,
                "title": "java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach time it goes to the Remaider\\'s friend. Use hashMap to cache all the friend (remainder) caught the ball.\\n\\nNote it is 1 indexed, so has to transform to 0 indexed for easy to adop remaineder.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\npublic int[] circularGameLosers(int n, int k) {\\n    Set<Integer> vis = new HashSet<>();\\n    int i = 0, rem = 0;\\n    while(true) {\\n        rem = (rem + k * i++) % n;\\n        if (!vis.add(rem)) break; //rem has been visited\\n    }\\n    int j = 0, res[] = new int[n - vis.size()];\\n    for (i = 0; i < n; i++) {\\n        if (!vis.contains(i)) res[j++] = i + 1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] circularGameLosers(int n, int k) {\\n    Set<Integer> vis = new HashSet<>();\\n    int i = 0, rem = 0;\\n    while(true) {\\n        rem = (rem + k * i++) % n;\\n        if (!vis.add(rem)) break; //rem has been visited\\n    }\\n    int j = 0, res[] = new int[n - vis.size()];\\n    for (i = 0; i < n; i++) {\\n        if (!vis.contains(i)) res[j++] = i + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522056,
                "title": "c-easy-to-understand-hashing-brute-force-approach",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        map<int,int> mp;\\n        int i=1; int turn=1;\\n        while (mp[i]!=1){\\n            mp[i]++;\\n            int addy= (i+(turn*k));\\n            if (addy%n==0)i=n;\\n            else i= addy%n;\\n            turn++;\\n        }\\n        vector<int> ans;\\n        for (int i=1; i<=n; i++){\\n            if (mp[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        map<int,int> mp;\\n        int i=1; int turn=1;\\n        while (mp[i]!=1){\\n            mp[i]++;\\n            int addy= (i+(turn*k));\\n            if (addy%n==0)i=n;\\n            else i= addy%n;\\n            turn++;\\n        }\\n        vector<int> ans;\\n        for (int i=1; i<=n; i++){\\n            if (mp[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521921,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }\\n        \\n        int count = 0; \\n        for(boolean b : visited) {\\n            if(!b) {\\n                count++;\\n            }\\n        }\\n        \\n        int[]ans = new int[count];\\n        int index = 0;\\n        for(int j = 0; j < visited.length; j++) {\\n            if(!visited[j]) {\\n                ans[index++] = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }\\n        \\n        int count = 0; \\n        for(boolean b : visited) {\\n            if(!b) {\\n                count++;\\n            }\\n        }\\n        \\n        int[]ans = new int[count];\\n        int index = 0;\\n        for(int j = 0; j < visited.length; j++) {\\n            if(!visited[j]) {\\n                ans[index++] = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971113,
                "title": "c-bool-array",
                "content": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k)\\n    {\\n        bool[] game = new bool[n];\\n\\n        for (int i = 0, j = 0; !game[i]; i = (i + ++j * k) % n)\\n        {\\n            game[i] = true;\\n        }\\n\\n        var losers = new List<int>();\\n\\n        for (int i = 0; i < game.Length; i++)\\n        {\\n            if (!game[i])\\n            {\\n                losers.Add(i + 1);\\n            }\\n        }\\n\\n        return losers.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k)\\n    {\\n        bool[] game = new bool[n];\\n\\n        for (int i = 0, j = 0; !game[i]; i = (i + ++j * k) % n)\\n        {\\n            game[i] = true;\\n        }\\n\\n        var losers = new List<int>();\\n\\n        for (int i = 0; i < game.Length; i++)\\n        {\\n            if (!game[i])\\n            {\\n                losers.Add(i + 1);\\n            }\\n        }\\n\\n        return losers.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688006,
                "title": "java-clean-code-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // the game simulation\\n        final boolean[] friends = new boolean[n];\\n        int index = 0;\\n        int counter = 0;\\n        int loosersAmount = n;\\n\\n        // the game is finished when some friend receives the ball for the second time\\n        while (!friends[index]) {\\n            friends[index] = true;\\n            --loosersAmount;\\n\\n            index = (index + ++counter * k) % n;\\n        }\\n\\n        // let\\'s gather the loosers\\n        final int[] loosers = new int[loosersAmount];\\n        int loosersCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!friends[i]) {\\n                loosers[loosersCount++] = i + 1;\\n            }\\n        }\\n\\n        return loosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // the game simulation\\n        final boolean[] friends = new boolean[n];\\n        int index = 0;\\n        int counter = 0;\\n        int loosersAmount = n;\\n\\n        // the game is finished when some friend receives the ball for the second time\\n        while (!friends[index]) {\\n            friends[index] = true;\\n            --loosersAmount;\\n\\n            index = (index + ++counter * k) % n;\\n        }\\n\\n        // let\\'s gather the loosers\\n        final int[] loosers = new int[loosersAmount];\\n        int loosersCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!friends[i]) {\\n                loosers[loosersCount++] = i + 1;\\n            }\\n        }\\n\\n        return loosers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646969,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=0,rem=0;\\n        ArrayList<Integer> set=new ArrayList<>();\\n        while(true){\\n            rem=(rem+(k*i))%n;\\n            if(set.contains(rem+1)){\\n                break;\\n            }\\n            else{\\n                set.add(rem+1);\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(i=1;i<=n;i++){\\n           if(!set.contains(i)){\\n               list.add(i);\\n           }\\n        }\\n        int ans[]=new int[list.size()];\\n        for( i=0;i<list.size();i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=0,rem=0;\\n        ArrayList<Integer> set=new ArrayList<>();\\n        while(true){\\n            rem=(rem+(k*i))%n;\\n            if(set.contains(rem+1)){\\n                break;\\n            }\\n            else{\\n                set.add(rem+1);\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(i=1;i<=n;i++){\\n           if(!set.contains(i)){\\n               list.add(i);\\n           }\\n        }\\n        int ans[]=new int[list.size()];\\n        for( i=0;i<list.size();i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556352,
                "title": "c-solution-frequency-vector",
                "content": "# Intuition\\nfrequency vector\\n\\n# Approach\\nCreate a vector of length n with initial values 0, Simulate whole process and increment the corresponding index value in vector till frequency of any index reaches 2,\\n\\nfinally Return indexes whose value is 0.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n      vector<int> v(n,0);\\n      vector<int> ans;\\n      int i = 1;\\n      int index = 0;\\n      v[index]=1;\\n\\n      while(1){\\n        if(v[index]>1){\\n          break;\\n        }\\n        index=(index+(i*k))%n;\\n        v[index]++;\\n        i++;\\n      }\\n      for(int j=0;j<n;j++){\\n        if(v[j]==0){\\n          ans.push_back(j+1);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n      vector<int> v(n,0);\\n      vector<int> ans;\\n      int i = 1;\\n      int index = 0;\\n      v[index]=1;\\n\\n      while(1){\\n        if(v[index]>1){\\n          break;\\n        }\\n        index=(index+(i*k))%n;\\n        v[index]++;\\n        i++;\\n      }\\n      for(int j=0;j<n;j++){\\n        if(v[j]==0){\\n          ans.push_back(j+1);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554819,
                "title": "c-solution-using-set-and-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using Set\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans;\\n        unordered_set<int> s;\\n        int turn=1;\\n        int curr=1;\\n        while(1){\\n            s.insert(curr);\\n            curr+=turn*k;\\n            if(curr>n) curr%=n;\\n            if(curr==0) curr=n;\\n            turn++;\\n            if(s.find(curr)!=s.end())\\n                break;\\n            \\n        }\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)==s.end())\\n                ans.push_back(i);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n# Code using Vector\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v(n+1,0);\\n        int curr=1,turn=1;\\n         while(v[curr]==0){\\n             v[curr]++;\\n             curr=(curr+turn*k)%n;\\n             if(curr==0) curr=n;\\n             turn++;\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans;\\n        unordered_set<int> s;\\n        int turn=1;\\n        int curr=1;\\n        while(1){\\n            s.insert(curr);\\n            curr+=turn*k;\\n            if(curr>n) curr%=n;\\n            if(curr==0) curr=n;\\n            turn++;\\n            if(s.find(curr)!=s.end())\\n                break;\\n            \\n        }\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)==s.end())\\n                ans.push_back(i);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v(n+1,0);\\n        int curr=1,turn=1;\\n         while(v[curr]==0){\\n             v[curr]++;\\n             curr=(curr+turn*k)%n;\\n             if(curr==0) curr=n;\\n             turn++;\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527224,
                "title": "c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\t\\t// Here I\\'ve used 0 based indexing, so range will be [0, ..., n-1].\\n\\t\\t\\n\\t\\t// Assign the ball count for all friends to 0.\\n        vector<int> count(n, 0), res;\\n\\t\\t\\n\\t\\t// We start from the first friend, \\n\\t\\t// so assign starting value for first friend to 1.\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        \\n\\t\\t// Loop until we found the friend which got 2nd time ball\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                res.push_back(i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\t\\t// Here I\\'ve used 0 based indexing, so range will be [0, ..., n-1].\\n\\t\\t\\n\\t\\t// Assign the ball count for all friends to 0.\\n        vector<int> count(n, 0), res;\\n\\t\\t\\n\\t\\t// We start from the first friend, \\n\\t\\t// so assign starting value for first friend to 1.\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        \\n\\t\\t// Loop until we found the friend which got 2nd time ball\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                res.push_back(i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524615,
                "title": "c-best-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans(n,1);\\n        vector<int>ans2;\\n        int i=2;\\n        ans[0]=0;\\n        int first=0,temp=k;\\n       \\n        while(true)\\n        {\\n            \\n            first=(first+temp)%n;\\n            if(ans[first]==0) break;\\n            else\\n            {\\n\\n            ans[first]=0;\\n            temp=k*i;\\n            i++;\\n            }\\n        }\\n        for(int j=0;j<ans.size();j++)\\n        {\\n            if(ans[j]==1) {ans2.push_back(j+1);}\\n        }\\n        return ans2;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans(n,1);\\n        vector<int>ans2;\\n        int i=2;\\n        ans[0]=0;\\n        int first=0,temp=k;\\n       \\n        while(true)\\n        {\\n            \\n            first=(first+temp)%n;\\n            if(ans[first]==0) break;\\n            else\\n            {\\n\\n            ans[first]=0;\\n            temp=k*i;\\n            i++;\\n            }\\n        }\\n        for(int j=0;j<ans.size();j++)\\n        {\\n            if(ans[j]==1) {ans2.push_back(j+1);}\\n        }\\n        return ans2;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523304,
                "title": "c-easy-set-solution",
                "content": "\\n        vector<int> circularGameLosers(int n, int k)\\n        {\\n            unordered_set<int> s;\\n            \\n            int curr = 1, i = 1;\\n            \\n            while (s.find(curr) == s.end())//stopping condition\\n            {\\n                s.insert(curr);//mask as visited\\n                curr = (curr + i *k ) % n;\\n                if (curr == 0) curr = n;\\n                i++;\\n            }\\n            vector<int> ans;\\n            for (int i = 1; i <= n; i++)//check which are not visited\\n            {\\n                if (s.find(i) == s.end())\\n                    ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "\\n        vector<int> circularGameLosers(int n, int k)\\n        {\\n            unordered_set<int> s;\\n            \\n            int curr = 1, i = 1;\\n            \\n            while (s.find(curr) == s.end())//stopping condition\\n            {\\n                s.insert(curr);//mask as visited\\n                curr = (curr + i *k ) % n;\\n                if (curr == 0) curr = n;\\n                i++;\\n            }\\n            vector<int> ans;\\n            for (int i = 1; i <= n; i++)//check which are not visited\\n            {\\n                if (s.find(i) == s.end())\\n                    ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3523215,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        ans=[0]\\n        m=k\\n        while True:\\n            if (ans[-1]+m)%n not in ans:\\n                ans.append((ans[-1]+m)%n)\\n                m=m+k\\n\\n            else:\\n                break\\n\\n\\n        return [i+1 for i in range(n) if i not in ans]            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        ans=[0]\\n        m=k\\n        while True:\\n            if (ans[-1]+m)%n not in ans:\\n                ans.append((ans[-1]+m)%n)\\n                m=m+k\\n\\n            else:\\n                break\\n\\n\\n        return [i+1 for i in range(n) if i not in ans]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522987,
                "title": "implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int,bool> mp;\\n        vector<int> ans;\\n        long long st = 0, i = 1;\\n        while(!mp.count(st)){\\n            mp[st] = true;\\n            st += i*k;\\n            st %= n;\\n            i++;\\n        }\\n        for(int i=0; i<n; ++i)\\n            if(!mp.count(i)) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int,bool> mp;\\n        vector<int> ans;\\n        long long st = 0, i = 1;\\n        while(!mp.count(st)){\\n            mp[st] = true;\\n            st += i*k;\\n            st %= n;\\n            i++;\\n        }\\n        for(int i=0; i<n; ++i)\\n            if(!mp.count(i)) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522527,
                "title": "easy-to-read-simulation-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522323,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n, 0), ans;\\n        int i=0, turn=1;\\n        while(v[i]!=1){\\n            v[i]=1;\\n            cout<<i<<\" \"<<(turn*k)%n<<endl;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n        for(int k=0; k<n; k++){\\n            if(!v[k]){\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n, 0), ans;\\n        int i=0, turn=1;\\n        while(v[i]!=1){\\n            v[i]=1;\\n            cout<<i<<\" \"<<(turn*k)%n<<endl;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n        for(int k=0; k<n; k++){\\n            if(!v[k]){\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522312,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>frq(n+1,0);\\n        vector<int>ans;\\n        int i = 0;\\n        int round = 1;\\n       while(true){\\n           frq[i]++;\\n           if(frq[i] >= 2) break;\\n            i = (i + ( round++ * k))%n;\\n       }\\n        for(int  i = 0 ; i<n ; i++)\\n            if( frq[i] == 0) ans.push_back(i+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>frq(n+1,0);\\n        vector<int>ans;\\n        int i = 0;\\n        int round = 1;\\n       while(true){\\n           frq[i]++;\\n           if(frq[i] >= 2) break;\\n            i = (i + ( round++ * k))%n;\\n       }\\n        for(int  i = 0 ; i<n ; i++)\\n            if( frq[i] == 0) ans.push_back(i+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522305,
                "title": "steps-explained-beginner-friendly-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, the index of an array starts from 0 there will be a huge confusion during the circular traversal.\\nThe cicular traversal of an array is always a hectic process until or unless you don\\'t know how to handle the edge cases.\\n\\nHere, by following the gven above conditions:\\n\\nOur Solution includes 3 steps\\n1. Passing the ball and marking the **visited** friends in visited array.\\n2. Finding the no of losers(unvisited) from visited array.\\n3. Adding the losers(unvisited) to the resultant array and returning it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n\\n\\n```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       \\n        boolean[] vis=new boolean[n+1];\\n        \\n        //Step - 1\\n        int curr_friend=1,i=1;\\n        do\\n        {\\n            vis[curr_friend]=true;\\n            curr_friend=(curr_friend+i*k)%n;\\n            if(curr_friend==0)\\n            {\\n                curr_friend=n;\\n            }\\n            i++;\\n        }while(vis[curr_friend]==false);\\n        \\n        \\n        //Step-2\\n        int size=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                size++;\\n        }\\n\\n        //Step-3\\n        int[] res=new int[size];\\n        int j=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                res[j++]=i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Game Theory"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       \\n        boolean[] vis=new boolean[n+1];\\n        \\n        //Step - 1\\n        int curr_friend=1,i=1;\\n        do\\n        {\\n            vis[curr_friend]=true;\\n            curr_friend=(curr_friend+i*k)%n;\\n            if(curr_friend==0)\\n            {\\n                curr_friend=n;\\n            }\\n            i++;\\n        }while(vis[curr_friend]==false);\\n        \\n        \\n        //Step-2\\n        int size=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                size++;\\n        }\\n\\n        //Step-3\\n        int[] res=new int[size];\\n        int j=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                res[j++]=i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522257,
                "title": "java-easy-simulation-fully-explained",
                "content": "Feel free to suggest any improvements, corrections\\uD83D\\uDC4D\\uD83C\\uDFFB\\nDo **UPVOTE**\\uD83D\\uDD3A\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] map = new int[n];\\n\\t\\t//map[i] tracks the number of times ith member recieves the ball\\n        \\n        int i = 0, cnt = 1;\\n        while(true){\\n            map[i]++;\\n            if(map[i] == 2) break; //break out of the loop whenever any member recieves the ball 2nd time, i.e. GAME_OVER\\n            i = (i + (cnt * k)) % n;\\n            cnt++; //to increase the multiple of k: k, 2*k, 3*k, 4*k, etc\\n        }\\n        \\n        int len = 0; //For storing how many members are the losers, i.e. did not recieve the ball even once\\n        for(int num : map) if(num == 0) len++;\\n        \\n        \\n        int index = 0, ans[] = new int[len];\\n        for(int j=0;j<n;j++){\\n          if(map[j] == 0) ans[index++] = j+1;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] map = new int[n];\\n\\t\\t//map[i] tracks the number of times ith member recieves the ball\\n        \\n        int i = 0, cnt = 1;\\n        while(true){\\n            map[i]++;\\n            if(map[i] == 2) break; //break out of the loop whenever any member recieves the ball 2nd time, i.e. GAME_OVER\\n            i = (i + (cnt * k)) % n;\\n            cnt++; //to increase the multiple of k: k, 2*k, 3*k, 4*k, etc\\n        }\\n        \\n        int len = 0; //For storing how many members are the losers, i.e. did not recieve the ball even once\\n        for(int num : map) if(num == 0) len++;\\n        \\n        \\n        int index = 0, ans[] = new int[len];\\n        for(int j=0;j<n;j++){\\n          if(map[j] == 0) ans[index++] = j+1;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522240,
                "title": "hashing-c-solution",
                "content": "# Intuition\\n we will decleare a hash array of size n+1 intially marked with zero . freind will start 1 to  n . we will mark hash(i)=1 as we get the ball pass to freind  . before marking we will check that wether it is previously marked or not , if it is marked as 1 then that  freind is geeting ball second time and the game end by break out of loop    \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)+O(n) = O(2n)   ; \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n) for hash array \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int>hash(n+1,0) ; \\n         hash[1]=1 ; \\n        vector<int>ans ; \\n        \\n          int prev  = 1 ;  \\n       int  i =1 ; \\n            while(1) \\n            {\\n               int nextstep = i*k ; \\n                int move = (prev+nextstep)%n ; \\n              if (move%n==0)move=n;\\n              \\n                if(hash[move]==0) \\n                {\\n                    hash[move] =1 ; \\n                    prev = move ;\\n                \\n                }\\n                else \\n                {\\n                    break ; \\n                } \\n                i++ ; \\n                \\n            }\\n         for( int i = 1 ; i<=n ; i++) \\n         {\\n             if(hash[i]==0) \\n                  ans.push_back(i)  ; \\n         }\\n      \\n        \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int>hash(n+1,0) ; \\n         hash[1]=1 ; \\n        vector<int>ans ; \\n        \\n          int prev  = 1 ;  \\n       int  i =1 ; \\n            while(1) \\n            {\\n               int nextstep = i*k ; \\n                int move = (prev+nextstep)%n ; \\n              if (move%n==0)move=n;\\n              \\n                if(hash[move]==0) \\n                {\\n                    hash[move] =1 ; \\n                    prev = move ;\\n                \\n                }\\n                else \\n                {\\n                    break ; \\n                } \\n                i++ ; \\n                \\n            }\\n         for( int i = 1 ; i<=n ; i++) \\n         {\\n             if(hash[i]==0) \\n                  ans.push_back(i)  ; \\n         }\\n      \\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522017,
                "title": "only-map-explained-easy-to-understand",
                "content": "# Intuition\\nuse map to mark the friend that received the ball\\n\\n# Approach\\nbe carefull when your next friends value come to zero then you make that value equal to n because 0 is not a friend and for finding the next value of friend simply int** **nf=(currf + (i+1)*k) % n;**** and make your current friend cf  equal to newfriend nf, \\n\\n1.Also store the number of friend at vector or any datastructure to keep track of marked one and lastly return the unmarked one\\n\\n# Complexity\\n- Time complexity:\\n appx O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        if(k>n) return {};\\n        vector<int> ans;\\n        vector<int> temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back(i+1);\\n        }\\n        map<int , int> mp;\\n        mp[1]=1;\\n        int currf=1;\\n        for(int i=0;i<1000;i++)\\n        {\\n            \\n            int nf=(currf + (i+1)*k) % n;\\n            if (nf == 0) {\\n            nf = n;\\n            }\\n            if(mp[nf]==1) break;\\n            mp[nf]=1;\\n            currf=nf; \\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        if(k>n) return {};\\n        vector<int> ans;\\n        vector<int> temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back(i+1);\\n        }\\n        map<int , int> mp;\\n        mp[1]=1;\\n        int currf=1;\\n        for(int i=0;i<1000;i++)\\n        {\\n            \\n            int nf=(currf + (i+1)*k) % n;\\n            if (nf == 0) {\\n            nf = n;\\n            }\\n            if(mp[nf]==1) break;\\n            mp[nf]=1;\\n            currf=nf; \\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521979,
                "title": "c-o-n-solution-beats-95-24",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int turn = 2;\\n        vector<int> vec, vis(n);\\n        int i = k;\\n        while(i >= n) i -= n;\\n        vis[0] = 1;\\n\\n        while(true) {\\n            if(vis[i]) break;\\n            vis[i] = 1;\\n            i += (k * turn);\\n            while(i >= n) i = i - n;\\n            turn++;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) vec.push_back(i + 1);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int turn = 2;\\n        vector<int> vec, vis(n);\\n        int i = k;\\n        while(i >= n) i -= n;\\n        vis[0] = 1;\\n\\n        while(true) {\\n            if(vis[i]) break;\\n            vis[i] = 1;\\n            i += (k * turn);\\n            while(i >= n) i = i - n;\\n            turn++;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) vec.push_back(i + 1);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521946,
                "title": "rust-python-linear-track-people-who-have-been-selected",
                "content": "# Intuition\\nStore all positions of people who has already been selected. Then iterate over all jumps (there will be at most n of them) until you will see a selected person. \\n\\nThen return all people who has not been selected.\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n\\n\\n\\n```Python []\\nclass Solution:\\n  def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;\\n\\n    let (mut pos, mut jump) = (0, k);\\n    loop {\\n      pos = (pos + jump) % n;\\n      if seen[pos as usize] {\\n        break;\\n      }\\n      \\n      seen[pos as usize] = true;\\n      jump += k;\\n    }\\n    \\n    let mut res = vec![];\\n    for i in 0 .. n {\\n      if !seen[i as usize] {\\n        res.push(i + 1);\\n      }\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Python []\\nclass Solution:\\n  def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;\\n\\n    let (mut pos, mut jump) = (0, k);\\n    loop {\\n      pos = (pos + jump) % n;\\n      if seen[pos as usize] {\\n        break;\\n      }\\n      \\n      seen[pos as usize] = true;\\n      jump += k;\\n    }\\n    \\n    let mut res = vec![];\\n    for i in 0 .. n {\\n      if !seen[i as usize] {\\n        res.push(i + 1);\\n      }\\n    }\\n    \\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521881,
                "title": "day-409-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate an array vis of the same size as n and fill it with zeros. Then they iterate over the array and update the value of p using the given formula. They also check if p has already been visited before and break the loop if it has. Finally, they create a list of all the elements that have not been visited and return it.\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic int[] circularGameLosers(int n, int k) {\\n    int  vis[] = new int[n+1];\\n    vis[1]=1;\\n    int p = 1;\\n    for(int i=1;i<=n;i++){\\n        p=(p+(k*i) )%(n);\\n        if(p==0) p=n;\\n        if(vis[p]==1) break;\\n        vis[p]=1;\\n        \\n    }\\n    var list = new ArrayList<Integer>();\\n    for(int i=1;i<=n;i++){\\n        if(vis[i]==0){\\n            list.add(i);\\n        }\\n    }return list.stream().mapToInt(i->i).toArray();\\n}\\n```\\n\\n```python []\\ndef circularGameLosers(self, n: int, k: int) -> List[int]:\\n        vis = [0] * (n + 1)\\n        vis[1] = 1\\n        p = 1\\n        for i in range(1, n + 1):\\n            p = (p + k * i) % n\\n            if p == 0:\\n                p = n\\n            if vis[p] == 1:\\n                break\\n            vis[p] = 1\\n        return [i for i in range(1, n + 1) if vis[i] == 0]\\n```\\n```c++ []\\nvector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        int p = 1;\\n        for (int i = 1; i <= n; i++) {\\n            p = (p + k * i) % n;\\n            if (p == 0) {\\n                p = n;\\n            }\\n            if (vis[p] == 1) {\\n                break;\\n            }\\n            vis[p] = 1;\\n        }\\n        vector<int> res;\\n        for (int i = 1; i <= n; i++) {\\n            if (vis[i] == 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int[] circularGameLosers(int n, int k) {\\n    int  vis[] = new int[n+1];\\n    vis[1]=1;\\n    int p = 1;\\n    for(int i=1;i<=n;i++){\\n        p=(p+(k*i) )%(n);\\n        if(p==0) p=n;\\n        if(vis[p]==1) break;\\n        vis[p]=1;\\n        \\n    }\\n    var list = new ArrayList<Integer>();\\n    for(int i=1;i<=n;i++){\\n        if(vis[i]==0){\\n            list.add(i);\\n        }\\n    }return list.stream().mapToInt(i->i).toArray();\\n}\\n```\n```python []\\ndef circularGameLosers(self, n: int, k: int) -> List[int]:\\n        vis = [0] * (n + 1)\\n        vis[1] = 1\\n        p = 1\\n        for i in range(1, n + 1):\\n            p = (p + k * i) % n\\n            if p == 0:\\n                p = n\\n            if vis[p] == 1:\\n                break\\n            vis[p] = 1\\n        return [i for i in range(1, n + 1) if vis[i] == 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3521872,
                "title": "2682-find-the-losers-of-the-circular-game-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n    int[] result = new int[n];\\n    int[] p = new int[n + 1];\\n    int i = 1, j = 1, count = 0; \\n    while (p[i] == 0) {\\n        p[i] = -1;\\n        i = (i + (j * k));\\n        while (i > n)\\n            i -= n;\\n        j++;\\n    }\\n    for (i = 1; i <= n; i++) {\\n        if (p[i] != -1) {\\n            result[count++] = i;\\n        }\\n    }\\n    return Arrays.copyOf(result, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n    int[] result = new int[n];\\n    int[] p = new int[n + 1];\\n    int i = 1, j = 1, count = 0; \\n    while (p[i] == 0) {\\n        p[i] = -1;\\n        i = (i + (j * k));\\n        while (i > n)\\n            i -= n;\\n        j++;\\n    }\\n    for (i = 1; i <= n; i++) {\\n        if (p[i] != -1) {\\n            result[count++] = i;\\n        }\\n    }\\n    return Arrays.copyOf(result, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521870,
                "title": "python-using-mod-beginners",
                "content": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        losers = [0]*n\\n        losers[0] = 1\\n        index = 0\\n        turn = 1\\n        while losers[index] != 2:\\n            index = ((turn * k) + index) % n\\n            losers[index] += 1\\n            turn += 1\\n            \\n        answer = []\\n        for index, loser in enumerate(losers):\\n            if loser == 0:\\n                answer.append(index + 1)\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        losers = [0]*n\\n        losers[0] = 1\\n        index = 0\\n        turn = 1\\n        while losers[index] != 2:\\n            index = ((turn * k) + index) % n\\n            losers[index] += 1\\n            turn += 1\\n            \\n        answer = []\\n        for index, loser in enumerate(losers):\\n            if loser == 0:\\n                answer.append(index + 1)\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088359,
                "title": "simple-elegant",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        unordered_map<int, bool> visited{};\\n\\n        int currFriend = 1, turn = 1;\\n\\n        while(visited[currFriend] == false){\\n\\n            visited[currFriend] = true;\\n\\n            currFriend += turn * k;\\n\\n            if(currFriend % n != 0) currFriend %= n;     \\n            else currFriend = n;\\n            \\n            turn++;\\n        }\\n\\n        vector<int> ans{};\\n\\n        for(int i = 1; i <= n; i++){\\n            if(visited[i] == false) \\n                ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        unordered_map<int, bool> visited{};\\n\\n        int currFriend = 1, turn = 1;\\n\\n        while(visited[currFriend] == false){\\n\\n            visited[currFriend] = true;\\n\\n            currFriend += turn * k;\\n\\n            if(currFriend % n != 0) currFriend %= n;     \\n            else currFriend = n;\\n            \\n            turn++;\\n        }\\n\\n        vector<int> ans{};\\n\\n        for(int i = 1; i <= n; i++){\\n            if(visited[i] == false) \\n                ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079969,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n      public int[] circularGameLosers(int n, int k) {\\n        List<Integer> players = new ArrayList<>();\\n        int temp = 0;\\n        int lastPlayer = 1;\\n        players.add(1);\\n        for(int i = 1; i <= n; i++){\\n            temp = i * k;\\n            lastPlayer = (temp + lastPlayer) % n == 0 ? n :  (temp + lastPlayer) % n;\\n           \\n            if(players.contains(lastPlayer)){\\n                break;\\n            }else{\\n                players.add(lastPlayer);\\n            }\\n        }\\n        int[] losers = new int[n - players.size()]; \\n        int index = 0;\\n        for(int i = 1; i <=n ; i++){\\n            if(!players.contains(i)){\\n                losers[index] = i;\\n                index++;\\n            }\\n        }\\n    \\n        return losers;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int[] circularGameLosers(int n, int k) {\\n        List<Integer> players = new ArrayList<>();\\n        int temp = 0;\\n        int lastPlayer = 1;\\n        players.add(1);\\n        for(int i = 1; i <= n; i++){\\n            temp = i * k;\\n            lastPlayer = (temp + lastPlayer) % n == 0 ? n :  (temp + lastPlayer) % n;\\n           \\n            if(players.contains(lastPlayer)){\\n                break;\\n            }else{\\n                players.add(lastPlayer);\\n            }\\n        }\\n        int[] losers = new int[n - players.size()]; \\n        int index = 0;\\n        for(int i = 1; i <=n ; i++){\\n            if(!players.contains(i)){\\n                losers[index] = i;\\n                index++;\\n            }\\n        }\\n    \\n        return losers;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061344,
                "title": "5-line-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst circularGameLosers = (n: number, k: number): number[] => {\\n  const losers = new Set<number>(Array.from({ length: n }, (_el, i) => i + 1));\\n  let cur = 1;\\n  let round = 1;\\n  while (losers.delete(cur)) cur = ((cur - 1 + k * round++) % n) + 1;\\n  return [...losers.values()];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst circularGameLosers = (n: number, k: number): number[] => {\\n  const losers = new Set<number>(Array.from({ length: n }, (_el, i) => i + 1));\\n  let cur = 1;\\n  let round = 1;\\n  while (losers.delete(cur)) cur = ((cur - 1 + k * round++) % n) + 1;\\n  return [...losers.values()];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060796,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        numSet = set()\\n        start = 0\\n        index = 1\\n\\n        while start not in numSet:\\n            numSet.add(start)\\n            start += index * k\\n            start = start % n\\n            index += 1\\n\\n        res = []\\n        for i in range(n):\\n            if i not in numSet:\\n                res.append(i + 1)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        numSet = set()\\n        start = 0\\n        index = 1\\n\\n        while start not in numSet:\\n            numSet.add(start)\\n            start += index * k\\n            start = start % n\\n            index += 1\\n\\n        res = []\\n        for i in range(n):\\n            if i not in numSet:\\n                res.append(i + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057085,
                "title": "1ms-simplest-java-solution",
                "content": "TC: O(n); Space: O(n)\\nNo intermediate List used\\n\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        if(n==0 || k ==0) return new int[]{};\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr,1);\\n        \\n        int pass =1; //an iterating variable to maintain passing\\n        int idx =0; //index as it says\\n        int times =k;\\n        arr[0]++;\\n        \\n        while(true)\\n        {\\n            idx = (pass*times) + idx;\\n            if(arr[idx%n] == 2)  // when index is > n; we do modulo operation to stay in array bounds - giving circular connection in array\\n                break;\\n            arr[idx%n]++;\\n            pass++;\\n        }\\n        \\n        //based on pass value make a new array, remeber after last pass nothing \\n\\t\\t//occured because we broke out of while lopp, \\n\\t\\t//so new array size  = n - pass;\\n        \\n        //System.out.println(\" Total pass : \"+ pass + \"  && new len = \" + (n-pass) );\\n        \\n        int[] res = new int[n - pass];\\n        for(int i=0, j=0 ; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n                res[j++] = i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        if(n==0 || k ==0) return new int[]{};\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr,1);\\n        \\n        int pass =1; //an iterating variable to maintain passing\\n        int idx =0; //index as it says\\n        int times =k;\\n        arr[0]++;\\n        \\n        while(true)\\n        {\\n            idx = (pass*times) + idx;\\n            if(arr[idx%n] == 2)  // when index is > n; we do modulo operation to stay in array bounds - giving circular connection in array\\n                break;\\n            arr[idx%n]++;\\n            pass++;\\n        }\\n        \\n        //based on pass value make a new array, remeber after last pass nothing \\n\\t\\t//occured because we broke out of while lopp, \\n\\t\\t//so new array size  = n - pass;\\n        \\n        //System.out.println(\" Total pass : \"+ pass + \"  && new len = \" + (n-pass) );\\n        \\n        int[] res = new int[n - pass];\\n        for(int i=0, j=0 ; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n                res[j++] = i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055851,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        d = {}\\n        d[1] = 1\\n\\n        start, place = 1, 1\\n        while True:\\n            jump = start + k * place\\n\\n            while jump > n:\\n                jump -= n\\n            \\n            if jump in d:\\n                break\\n            \\n            d[jump] = 1\\n            start = jump\\n            place += 1\\n        \\n        print(d)\\n        # {1: 1, 3: 1, 2: 1}\\n        res = []\\n\\n        for i in range(1, n+1):\\n            if i not in d:\\n                res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        d = {}\\n        d[1] = 1\\n\\n        start, place = 1, 1\\n        while True:\\n            jump = start + k * place\\n\\n            while jump > n:\\n                jump -= n\\n            \\n            if jump in d:\\n                break\\n            \\n            d[jump] = 1\\n            start = jump\\n            place += 1\\n        \\n        print(d)\\n        # {1: 1, 3: 1, 2: 1}\\n        res = []\\n\\n        for i in range(1, n+1):\\n            if i not in d:\\n                res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027429,
                "title": "php-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function circularGameLosers($n, $k) {\\n        $players =  range(1, $n);\\n        $carry = [];\\n        $player = 1;\\n        $turn = 1;\\n\\n        while(1) {\\n            if (in_array($player, $carry)) {\\n                return array_diff($players, $carry);\\n            }\\n\\n            $carry[] = $player;\\n            $next = $k * $turn;\\n            $turn++;\\n\\n            while($next > 0) {\\n                if ($player === $n) {\\n                    $player = 1;\\n                } else {\\n                    $player++;\\n                }\\n\\n                $next--;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function circularGameLosers($n, $k) {\\n        $players =  range(1, $n);\\n        $carry = [];\\n        $player = 1;\\n        $turn = 1;\\n\\n        while(1) {\\n            if (in_array($player, $carry)) {\\n                return array_diff($players, $carry);\\n            }\\n\\n            $carry[] = $player;\\n            $next = $k * $turn;\\n            $turn++;\\n\\n            while($next > 0) {\\n                if ($player === $n) {\\n                    $player = 1;\\n                } else {\\n                    $player++;\\n                }\\n\\n                $next--;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002610,
                "title": "simple-c-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> mp(n,0);\\n        mp[0]++;\\n        bool f=true;\\n        vector<int> a;\\n        int i=1;\\n        int srt=0;\\n        while(mp[srt]!=2){\\n            srt=(srt+(k*i))%n;\\n            mp[srt]++;\\n            i++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]==0){\\n                a.push_back(i+1);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> mp(n,0);\\n        mp[0]++;\\n        bool f=true;\\n        vector<int> a;\\n        int i=1;\\n        int srt=0;\\n        while(mp[srt]!=2){\\n            srt=(srt+(k*i))%n;\\n            mp[srt]++;\\n            i++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]==0){\\n                a.push_back(i+1);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999639,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (i == 1) map.put(1, 1);\\n            else map.put(i, 0);\\n        }\\n        int temp = 1;\\n        int current = 1;\\n        while (!map.entrySet().stream().filter(x -> x.getValue() >= 2).findFirst().isPresent()) {\\n            current += (temp * k);\\n            if (current > n) {\\n                while (current > n) {\\n                    current -= n;\\n                }\\n            }\\n\\n            map.put(current, map.get(current) + 1);\\n            temp++;\\n        }\\n\\n        List<Integer> l = map.entrySet().stream().filter(x -> x.getValue() == 0).map(x -> x.getKey()).toList();\\n        int[] arr = new int[l.size()];\\n        for (int i = 0; i < l.size(); i++) {\\n            arr[i] = l.get(i);\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (i == 1) map.put(1, 1);\\n            else map.put(i, 0);\\n        }\\n        int temp = 1;\\n        int current = 1;\\n        while (!map.entrySet().stream().filter(x -> x.getValue() >= 2).findFirst().isPresent()) {\\n            current += (temp * k);\\n            if (current > n) {\\n                while (current > n) {\\n                    current -= n;\\n                }\\n            }\\n\\n            map.put(current, map.get(current) + 1);\\n            temp++;\\n        }\\n\\n        List<Integer> l = map.entrySet().stream().filter(x -> x.getValue() == 0).map(x -> x.getKey()).toList();\\n        int[] arr = new int[l.size()];\\n        for (int i = 0; i < l.size(); i++) {\\n            arr[i] = l.get(i);\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970857,
                "title": "java-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] table = new int[n];\\n        int i = 1, current = 0;\\n        \\n        table[0] = 1;\\n\\n        while(true){\\n            current = (i * k + current) % n;\\n            table[current]++;\\n            i++;\\n            if(table[current] == 2)\\n              break;\\n        }\\n\\n        for(int j = 0; j < n; j++)\\n            if(table[j] == 0) list.add(j+1);\\n        \\n        int[] array = new int[list.size()];\\n        for(int j = 0; j < list.size(); j++) \\n            array[j] = list.get(j);\\n        \\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] table = new int[n];\\n        int i = 1, current = 0;\\n        \\n        table[0] = 1;\\n\\n        while(true){\\n            current = (i * k + current) % n;\\n            table[current]++;\\n            i++;\\n            if(table[current] == 2)\\n              break;\\n        }\\n\\n        for(int j = 0; j < n; j++)\\n            if(table[j] == 0) list.add(j+1);\\n        \\n        int[] array = new int[list.size()];\\n        for(int j = 0; j < list.size(); j++) \\n            array[j] = list.get(j);\\n        \\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967861,
                "title": "python-game-simulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the nature of the problem, it\\'s evident that a circular structure such as a circular linked list or an array with wrap-around indexing would be beneficial. Since the ball is passed in a repeating pattern, modulo arithmetic will be essential to keep the pointer within the bounds of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialization: Create a list friends that contains the numbers from 1 to n. Also, initialize an empty list visited_friends to keep track of friends who received the ball. A pointer initialized to 0 will indicate the current friend with the ball.\\n2.Passing the Ball: Use a loop to pass the ball among friends:\\nFor the ith pass, compute the position of the friend to receive the ball as (pointer + i * k) % n.\\n3.Add this friend to the visited_friends list.\\n4.Stop the loop when a friend receives the ball for the second time.\\n5.Finding Losers: Any friend not in visited_friends is a loser. Identify these friends and return them in ascending order.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = []\\n        visited_friends = []\\n        res = []\\n\\n        for i in range(1, n+1):\\n            friends.append(i)\\n        pointer = 0\\n\\n        cur_circle_count = 1\\n        while friends[pointer] not in visited_friends:\\n            visited_friends.append(friends[pointer])\\n            next_pointer_pos = (pointer + k * cur_circle_count) % n\\n            cur_circle_count += 1\\n            pointer = next_pointer_pos\\n\\n        for f in friends:\\n            if f not in visited_friends:\\n                res.append(f)\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = []\\n        visited_friends = []\\n        res = []\\n\\n        for i in range(1, n+1):\\n            friends.append(i)\\n        pointer = 0\\n\\n        cur_circle_count = 1\\n        while friends[pointer] not in visited_friends:\\n            visited_friends.append(friends[pointer])\\n            next_pointer_pos = (pointer + k * cur_circle_count) % n\\n            cur_circle_count += 1\\n            pointer = next_pointer_pos\\n\\n        for f in friends:\\n            if f not in visited_friends:\\n                res.append(f)\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930295,
                "title": "python-rust-solution-3-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        scores = [0 for _ in range(n + 1)]\\n        scores[0], scores[1] = 1, 1\\n        rounds, player = 1, 1\\n\\n        while scores[player] <= 1:\\n            pos = player + (rounds * k) % n\\n            if pos > n:\\n                player = pos - n\\n            else:\\n                player = pos\\n\\n            scores[player] += 1\\n            rounds += 1\\n\\n        return [index for index, score in enumerate(scores) if score == 0]\\n```\\n```rust []\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let mut scores = vec![0; n as usize + 1];\\n        let (mut round, mut player) = (1, 1);\\n        scores[0] = 1; \\n        scores[1] = 1;\\n\\n        while scores[player as usize] <= 1 {\\n            let pos = player + (round * k) % n;\\n            player = if pos > n { pos - n } else { pos };\\n            scores[player as usize] += 1;\\n            round += 1;\\n        }\\n\\n        scores\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &score)| score == 0)\\n            .map(|(index, _)| index as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        scores = [0 for _ in range(n + 1)]\\n        scores[0], scores[1] = 1, 1\\n        rounds, player = 1, 1\\n\\n        while scores[player] <= 1:\\n            pos = player + (rounds * k) % n\\n            if pos > n:\\n                player = pos - n\\n            else:\\n                player = pos\\n\\n            scores[player] += 1\\n            rounds += 1\\n\\n        return [index for index, score in enumerate(scores) if score == 0]\\n```\n```rust []\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let mut scores = vec![0; n as usize + 1];\\n        let (mut round, mut player) = (1, 1);\\n        scores[0] = 1; \\n        scores[1] = 1;\\n\\n        while scores[player as usize] <= 1 {\\n            let pos = player + (round * k) % n;\\n            player = if pos > n { pos - n } else { pos };\\n            scores[player as usize] += 1;\\n            round += 1;\\n        }\\n\\n        scores\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &score)| score == 0)\\n            .map(|(index, _)| index as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916218,
                "title": "simple-beginner-level-c-solution-slow-but-easy-to-understand-beats-69-23-in-runtime",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n- Space complexity: ```O(n)```\\n\\n\\n# Code\\n```cpp\\n// Runtime 13 ms Beats 69.23% Memory 7.8 MB Beats 84.62%\\nint* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }\\n\\n    int* result = (int*)calloc(n, sizeof(int));\\n    int arrSize = 0;\\n    for (int friendIndex = 0; friendIndex < n; friendIndex++) {\\n        if (seen[friendIndex]) continue;\\n        result[arrSize++] = friendIndex + 1;\\n    }\\n\\n    *returnSize = arrSize;\\n    free(seen);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```O(n)```\n```O(n)```\n```cpp\\n// Runtime 13 ms Beats 69.23% Memory 7.8 MB Beats 84.62%\\nint* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }\\n\\n    int* result = (int*)calloc(n, sizeof(int));\\n    int arrSize = 0;\\n    for (int friendIndex = 0; friendIndex < n; friendIndex++) {\\n        if (seen[friendIndex]) continue;\\n        result[arrSize++] = friendIndex + 1;\\n    }\\n\\n    *returnSize = arrSize;\\n    free(seen);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910833,
                "title": "c-single-parse-with-increasing-step-100-time-0ms-99-space-8-12mb",
                "content": "Funny problem we can solve by basically coding what we are told should happen.\\n\\nTo do so, we will start with our usual support variables:\\n* `w` is our pointer to first walk and then write (more about that in a moment), initially set to `0`, since we always start from the first cell;\\n* `step` will store how much we move at each new round, initially set to be `k`;\\n* `unexplored` in an array of `n` booleans we will use to keep track of where we have been or not;\\n* `res` is our usual result variable, preset to be `n` cells this time, to avoid too many reallocations laters.\\n\\nWe will then go and prepare `unexplored`, setting all its cells to `true`, then we will loop `while` the current cell `unexplored[w]` is `true` and:\\n* flag the current cell `unexplored[w]` as `false`;\\n* increase our pointer `w` by step;\\n* make sure `w` stays `< n`, by reducing it to `% n` when it exceeds this value;\\n* increase `step` by `k` (cheaper than multiplying by `k` each time).\\n\\nNow that we have flagged all the cells we would touch before the game ends (ie: before we land in an already explored cell), we can confidently populate `res` by:\\n* resetting `w` to be `0`, this time to write in `res`;\\n* loop through all the values in `unexplored` from the second (index `1`, remember we know the first one will always be visited) and:\\n    * when we find a cell we did not touch (ie: `unexplored[i] == true`), we will:\\n        * increase `i` by `1` (since the original problem was `1`-based);\\n        * write its value in `res[w]`\\n        * advance `w` by `1`, ready to write in the next cell;\\n    * if the cell was visited, we will just advance `i` by `1`\\n* finally, we will `resize` `res` to be only `w` cells.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // support variables\\n        int w = 0, step = k;\\n        bool unexplored[n];\\n        vector<int> res(n);\\n        // preparing unexplored\\n        memset(unexplored, 1, n * sizeof(bool));\\n        while (unexplored[w]) {\\n            unexplored[w] = 0;\\n            w += step;\\n            if (w >= n) w %= n;\\n            step += k;\\n        }\\n        // populating res\\n        w = 0;\\n        for (int i = 1; i < n;) {\\n            if (unexplored[i]) res[w++] = ++i;\\n            else ++i;\\n        }\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```\\n\\n#Brag\\n![image.png](https://assets.leetcode.com/users/images/2b781d23-8eef-43a3-bbec-e352eefbe752_1692055030.28059.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // support variables\\n        int w = 0, step = k;\\n        bool unexplored[n];\\n        vector<int> res(n);\\n        // preparing unexplored\\n        memset(unexplored, 1, n * sizeof(bool));\\n        while (unexplored[w]) {\\n            unexplored[w] = 0;\\n            w += step;\\n            if (w >= n) w %= n;\\n            step += k;\\n        }\\n        // populating res\\n        w = 0;\\n        for (int i = 1; i < n;) {\\n            if (unexplored[i]) res[w++] = ++i;\\n            else ++i;\\n        }\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887814,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI think we should have flag vector to check whether a player received ball yet\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans(n,1);\\n        int i = 0;\\n        int j = 1;\\n        while(ans[i] == 1)\\n        {\\n            ans[i] = 0;\\n            i = (i+j*k) > n ? (i+j*k)%n : (i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> res; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ans[i] == 1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans(n,1);\\n        int i = 0;\\n        int j = 1;\\n        while(ans[i] == 1)\\n        {\\n            ans[i] = 0;\\n            i = (i+j*k) > n ? (i+j*k)%n : (i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> res; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ans[i] == 1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880111,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans, res(n, 0);\\n        int temp = 0;\\n        int i = 1;\\n        res[temp] = 1;\\n\\n        while(res[temp] != 2){\\n            temp = (temp + i*k)%n;\\n            res[temp]++;\\n            i++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(res[i] == 0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans, res(n, 0);\\n        int temp = 0;\\n        int i = 1;\\n        res[temp] = 1;\\n\\n        while(res[temp] != 2){\\n            temp = (temp + i*k)%n;\\n            res[temp]++;\\n            i++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(res[i] == 0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876783,
                "title": "find-the-losers-of-the-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lst=[i for i in range(1,n+1)]\\n        i=0\\n        j=1\\n        while True:\\n            if lst[i]==0:\\n                while 0 in lst:\\n                    lst.remove(0)\\n                return lst\\n            lst[i]=0\\n            i=(i+j*k)%n\\n            j+=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lst=[i for i in range(1,n+1)]\\n        i=0\\n        j=1\\n        while True:\\n            if lst[i]==0:\\n                while 0 in lst:\\n                    lst.remove(0)\\n                return lst\\n            lst[i]=0\\n            i=(i+j*k)%n\\n            j+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875518,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int i=0;\\n        int turn=1;\\n        while(v[i]!=1)\\n        {\\n            v[i]=1;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n            if(!v[k])\\n            {\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int i=0;\\n        int turn=1;\\n        while(v[i]!=1)\\n        {\\n            v[i]=1;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n            if(!v[k])\\n            {\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874775,
                "title": "java-2ms-beats-97-94",
                "content": "\\n\\n# Code\\n```\\n// build int[] `losers_array` manually: 2ms Beats 97.94%\\n// stream `losers_list` to int[]: 6ms beats 20.99%\\n\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // strategy: simulation.\\n        // in my implementation, list of friends is zero-indexed\\n\\n        boolean[] hasReceivedBall = new boolean[n];\\n\\n        int round = 1;\\n        int curFriend = 0;\\n        hasReceivedBall[0] = true;\\n\\n        while (true) {\\n            int nextFriend = (curFriend + k * round++) % n;\\n\\n            if (hasReceivedBall[nextFriend]) {\\n                break;\\n            }\\n\\n            hasReceivedBall[nextFriend] = true;\\n            curFriend = nextFriend;\\n        }\\n\\n        // assemble list of losers\\n        LinkedList<Integer> losers_list = new LinkedList<>();\\n        for (int i = 0; i < hasReceivedBall.length; ++i) {\\n            if (!hasReceivedBall[i]) {\\n                losers_list.add(i + 1);\\n            }\\n        }\\n\\n        // return losers_list.stream().mapToInt(Integer::intValue).toArray();\\n\\n        int[] losers_array = new int[losers_list.size()];\\n        int idxIntoLosersArray = 0;\\n        while (!losers_list.isEmpty()) {\\n            losers_array[idxIntoLosersArray++] = losers_list.removeFirst();\\n        }\\n\\n        return losers_array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// build int[] `losers_array` manually: 2ms Beats 97.94%\\n// stream `losers_list` to int[]: 6ms beats 20.99%\\n\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // strategy: simulation.\\n        // in my implementation, list of friends is zero-indexed\\n\\n        boolean[] hasReceivedBall = new boolean[n];\\n\\n        int round = 1;\\n        int curFriend = 0;\\n        hasReceivedBall[0] = true;\\n\\n        while (true) {\\n            int nextFriend = (curFriend + k * round++) % n;\\n\\n            if (hasReceivedBall[nextFriend]) {\\n                break;\\n            }\\n\\n            hasReceivedBall[nextFriend] = true;\\n            curFriend = nextFriend;\\n        }\\n\\n        // assemble list of losers\\n        LinkedList<Integer> losers_list = new LinkedList<>();\\n        for (int i = 0; i < hasReceivedBall.length; ++i) {\\n            if (!hasReceivedBall[i]) {\\n                losers_list.add(i + 1);\\n            }\\n        }\\n\\n        // return losers_list.stream().mapToInt(Integer::intValue).toArray();\\n\\n        int[] losers_array = new int[losers_list.size()];\\n        int idxIntoLosersArray = 0;\\n        while (!losers_list.isEmpty()) {\\n            losers_array[idxIntoLosersArray++] = losers_list.removeFirst();\\n        }\\n\\n        return losers_array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871896,
                "title": "find-the-losers-of-the-circular-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        if(n==1&&k==1)\\n        return new int[0];\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        boolean flag = true;\\n        int i=1;\\n        int l=1;\\n        while(flag==true&&i<=n)\\n        {\\n            if(arr.contains(i))\\n            {flag = false;}\\n            if(arr.contains(i)==false)\\n            arr.add(i);\\n            i=(i+l*k)%n;\\n            l++;\\n        }\\n        int[] arr1 = new int[n-arr.size()];\\n        i=1;\\n        int j=0;\\n        while(i<=n&&j<arr1.length)\\n        {\\n            if(arr.contains(i)==false)\\n            {\\n                arr1[j] = i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        if(n==1&&k==1)\\n        return new int[0];\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        boolean flag = true;\\n        int i=1;\\n        int l=1;\\n        while(flag==true&&i<=n)\\n        {\\n            if(arr.contains(i))\\n            {flag = false;}\\n            if(arr.contains(i)==false)\\n            arr.add(i);\\n            i=(i+l*k)%n;\\n            l++;\\n        }\\n        int[] arr1 = new int[n-arr.size()];\\n        i=1;\\n        int j=0;\\n        while(i<=n&&j<arr1.length)\\n        {\\n            if(arr.contains(i)==false)\\n            {\\n                arr1[j] = i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870920,
                "title": "kotlin-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        var result = mutableListOf<Int>()\\n        var set = mutableSetOf<Int>()\\n        var i = 1\\n        var landing = 1\\n\\n        while (!set.contains(landing)) {\\n            set.add(landing)\\n            landing = (landing + (i * k)) % n\\n            if (landing == 0) landing = n\\n            i++\\n        }\\n\\n        for (i in 1..n) {\\n            if (!set.contains(i)) result.add(i)\\n        }\\n\\n        return result.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        var result = mutableListOf<Int>()\\n        var set = mutableSetOf<Int>()\\n        var i = 1\\n        var landing = 1\\n\\n        while (!set.contains(landing)) {\\n            set.add(landing)\\n            landing = (landing + (i * k)) % n\\n            if (landing == 0) landing = n\\n            i++\\n        }\\n\\n        for (i in 1..n) {\\n            if (!set.contains(i)) result.add(i)\\n        }\\n\\n        return result.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830863,
                "title": "memory-optimized-version-similar-to-dodgeball",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ when step_size (k) == 1\\n\\n- Space complexity:\\nWe start with $$O(n)$$ \\nIn worst case we end with $$O(n-1)$$ \\n==> step_size == number_of_players ==> only Player 1 gets to play \\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n        players = list(range(1, numer_of_players + 1))  # +1 ==> includes the numer_of_players in range as the last player\\n\\n        # we start at INDEX 0 ==> Player #1\\n        current_player = 1\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        # O(n) when step_size == 1\\n        while current_player in players:\\n            # with the current player value still intact ... we calculate the next step width\\n            # (current_player - 1) ==> this is the index\\n            speed = ((current_player - 1) + ball_touched * step_size)  # accelerate the \\'speed\\'\\n\\n            # remove player from players list\\n            players.remove(current_player)\\n\\n            # this helps us get the correct player wrapping around at the end of the array\\n            current_player = speed % numer_of_players + 1\\n\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n\\n        # We only return all loosers (never played) players\\n        return players\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n        players = list(range(1, numer_of_players + 1))  # +1 ==> includes the numer_of_players in range as the last player\\n\\n        # we start at INDEX 0 ==> Player #1\\n        current_player = 1\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        # O(n) when step_size == 1\\n        while current_player in players:\\n            # with the current player value still intact ... we calculate the next step width\\n            # (current_player - 1) ==> this is the index\\n            speed = ((current_player - 1) + ball_touched * step_size)  # accelerate the \\'speed\\'\\n\\n            # remove player from players list\\n            players.remove(current_player)\\n\\n            # this helps us get the correct player wrapping around at the end of the array\\n            current_player = speed % numer_of_players + 1\\n\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n\\n        # We only return all loosers (never played) players\\n        return players\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830559,
                "title": "while-loop-until-finished",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n         # set the # of hits to 0 for all players\\n        player_hit = [0] * numer_of_players\\n\\n        # we start at INDEX 0 ==> Player #1\\n        next = 0\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        while True:\\n\\n            player_hit[next] += 1\\n\\n            # The game is finished when some friend receives the ball for the second time.\\n            if player_hit[next] == 2:\\n                # we look at all values of the player_hit array and return the ones which have NEVER been hit\\n                # The losers of the game are friends who did not receive the ball in the entire game.\\n                return [index + 1 for index, value in enumerate(player_hit) if value == 0]\\n\\n            next = (next + ball_touched * step_size) % numer_of_players  # accelerate the \\'speed\\'\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n         # set the # of hits to 0 for all players\\n        player_hit = [0] * numer_of_players\\n\\n        # we start at INDEX 0 ==> Player #1\\n        next = 0\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        while True:\\n\\n            player_hit[next] += 1\\n\\n            # The game is finished when some friend receives the ball for the second time.\\n            if player_hit[next] == 2:\\n                # we look at all values of the player_hit array and return the ones which have NEVER been hit\\n                # The losers of the game are friends who did not receive the ball in the entire game.\\n                return [index + 1 for index, value in enumerate(player_hit) if value == 0]\\n\\n            next = (next + ball_touched * step_size) % numer_of_players  # accelerate the \\'speed\\'\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827554,
                "title": "c-easy-understanding",
                "content": "# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* circularGameLosers(int n, int k, int* returnSize){\\n    int *res = malloc(sizeof(int)*n);\\n    memset(res, 0, n*sizeof(int) );\\n    int i=1,s=0;\\n    res[0]=1;\\n    while(1){\\n        res[(s+i*k)%n]++;\\n        if(res[(s+i*k)%n]==2){\\n            break;\\n        }\\n        s = (s+i*k)%n;\\n        i++;\\n    }\\n    int x=0;\\n    int *ans = malloc(sizeof(int)*n);\\n    memset(ans, 0, sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        if(res[i]==0){\\n            ans[x]=i+1;\\n            x++;\\n        }\\n    }\\n    *returnSize=x;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* circularGameLosers(int n, int k, int* returnSize){\\n    int *res = malloc(sizeof(int)*n);\\n    memset(res, 0, n*sizeof(int) );\\n    int i=1,s=0;\\n    res[0]=1;\\n    while(1){\\n        res[(s+i*k)%n]++;\\n        if(res[(s+i*k)%n]==2){\\n            break;\\n        }\\n        s = (s+i*k)%n;\\n        i++;\\n    }\\n    int x=0;\\n    int *ans = malloc(sizeof(int)*n);\\n    memset(ans, 0, sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        if(res[i]==0){\\n            ans[x]=i+1;\\n            x++;\\n        }\\n    }\\n    *returnSize=x;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817792,
                "title": "c-easy-to-understand-solution-o-n-solution-beats-97-75-runtime",
                "content": "# Intuition\\nThe function aims to simulate a circular game of elimination, where n players are standing in a circle, and every k-th player gets eliminated. The function then returns the list of players who are losers in this game.\\n\\n# Approach\\n1. Initialize an array visited of size 100 (it could be any large enough constant) to keep track of visited players. Set all elements in the array to false.\\n2. Start from the first player (index 0) and mark it as visited (visited[0] = true).\\n3. Use two variables i and j to keep track of the current step and player index, respectively. Start with i = 1 and j = 0.\\n4. Iterate until the first player (visited[0]) is visited again:\\n    a. Calculate the new player index j as (j + (i * k)) % n, where n is   the total number of players.\\n    b. If the new player j is already visited (visited[j] == true), it means we have reached the starting player again, and we break the loop.\\n    c. Otherwise, mark the new player j as visited (visited[j] = true) and increment i.\\n5. After the loop, create a vector ans to store the losers\\' indices.\\n6. Iterate over the entire array to find the players whose corresponding indices are not visited (i.e., they are losers) and add them to the ans vector.\\n7. Return the ans vector containing the indices of the losers.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the circularGameLosers function is O(n) since it iterates through the array once to find the losers.\\n\\n- Space complexity:\\nSpace complexity: The space complexity is O(n) since the function uses an array of size 100 (or any large enough constant) to track visited players, and the ans vector can store at most n/2 players (losers).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        bool visited[100]={false};\\n        visited[0]=true;\\n        int i=1;\\n        int j=0;\\n        while(visited[0]){\\n            j=(j+(i*k))%n;\\n            if(visited[j]==true){\\n                break;\\n            }\\n            else{\\n                visited[j]=true;\\n                i++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int h=0;h<n;h++){\\n            if(visited[h]==false){\\n                ans.push_back(h+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        bool visited[100]={false};\\n        visited[0]=true;\\n        int i=1;\\n        int j=0;\\n        while(visited[0]){\\n            j=(j+(i*k))%n;\\n            if(visited[j]==true){\\n                break;\\n            }\\n            else{\\n                visited[j]=true;\\n                i++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int h=0;h<n;h++){\\n            if(visited[h]==false){\\n                ans.push_back(h+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809281,
                "title": "simple-c-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        vector<bool>visited(n+1, false);\\n        int step = 1;\\n        int i = 1;\\n\\n        while(1){\\n            int nextFriend = i%n;\\n            if(nextFriend == 0){\\n                nextFriend = n;\\n            }\\n            if(visited[nextFriend]){\\n                break;\\n            }\\n            visited[nextFriend] = true;\\n            \\n            i = i + (step*k);\\n            step++;\\n        }\\n\\n        for(int i=1; i<visited.size(); i++){\\n            if(!visited[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        vector<bool>visited(n+1, false);\\n        int step = 1;\\n        int i = 1;\\n\\n        while(1){\\n            int nextFriend = i%n;\\n            if(nextFriend == 0){\\n                nextFriend = n;\\n            }\\n            if(visited[nextFriend]){\\n                break;\\n            }\\n            visited[nextFriend] = true;\\n            \\n            i = i + (step*k);\\n            step++;\\n        }\\n\\n        for(int i=1; i<visited.size(); i++){\\n            if(!visited[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799457,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 0;\\n        \\n        int z = 1;\\n        \\n        vector<int>vis(n,0);\\n        vector<int>ans;\\n        set<int>st;\\n        for(int i=1; i <= n; i++)st.insert(i);\\n        while(!vis[x])\\n        {\\n            vis[x] = 1;\\n            st.erase(x+1);\\n            x = (x%n + z*k)%n;\\n            z++;\\n            \\n        }\\n        \\n        for(auto i : st)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 0;\\n        \\n        int z = 1;\\n        \\n        vector<int>vis(n,0);\\n        vector<int>ans;\\n        set<int>st;\\n        for(int i=1; i <= n; i++)st.insert(i);\\n        while(!vis[x])\\n        {\\n            vis[x] = 1;\\n            st.erase(x+1);\\n            x = (x%n + z*k)%n;\\n            z++;\\n            \\n        }\\n        \\n        for(auto i : st)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781458,
                "title": "simple-traversal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool>visited(n,false);\\n        vector<int>res;\\n        int i = 0;\\n        visited[0] = true;\\n        int count = 1;\\n        while(1)\\n        {\\n            i = (i + count * k) % n;\\n            if(visited[i] == true)\\n                break;\\n            visited[i] = true;\\n            count++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i] == false)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool>visited(n,false);\\n        vector<int>res;\\n        int i = 0;\\n        visited[0] = true;\\n        int count = 1;\\n        while(1)\\n        {\\n            i = (i + count * k) % n;\\n            if(visited[i] == true)\\n                break;\\n            visited[i] = true;\\n            count++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i] == false)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777942,
                "title": "worst-solution-ever-must-see-tried-very-hard-but-at-last-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] a=new int[n+1];\\n        int i=1;\\n        int curr=1;\\n        a[1]++;\\n        while(true){\\n            if(curr+i*k>n){\\n                curr = (curr + k * i - 1) % n + 1;\\n                if(a[curr]>0){\\n                    break;\\n                }\\n                else{\\n                    a[curr]++;\\n                }\\n            }\\n            else{\\n                if(a[curr+i*k]>0){\\n                    break;\\n                }\\n                else{\\n                    \\n                    curr=curr+i*k;\\n                    a[curr]++;\\n                }\\n            }\\n            i++;\\n        }\\n        int s=0;\\n        for(int j : a){\\n            if(j==0){\\n                s++;\\n            }\\n        }\\n        int idx=0;\\n        int[] ans=new int[s-1];\\n        System.out.println(Arrays.toString(a));\\n        for(int j=1;j<a.length;j++){\\n            if(a[j]==0){\\n                ans[idx++]=j;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] a=new int[n+1];\\n        int i=1;\\n        int curr=1;\\n        a[1]++;\\n        while(true){\\n            if(curr+i*k>n){\\n                curr = (curr + k * i - 1) % n + 1;\\n                if(a[curr]>0){\\n                    break;\\n                }\\n                else{\\n                    a[curr]++;\\n                }\\n            }\\n            else{\\n                if(a[curr+i*k]>0){\\n                    break;\\n                }\\n                else{\\n                    \\n                    curr=curr+i*k;\\n                    a[curr]++;\\n                }\\n            }\\n            i++;\\n        }\\n        int s=0;\\n        for(int j : a){\\n            if(j==0){\\n                s++;\\n            }\\n        }\\n        int idx=0;\\n        int[] ans=new int[s-1];\\n        System.out.println(Arrays.toString(a));\\n        for(int j=1;j<a.length;j++){\\n            if(a[j]==0){\\n                ans[idx++]=j;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774351,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val pointsMap = IntArray(n)\\n        var friend = 0\\n        var turn = 1\\n\\n        while (true) {\\n            pointsMap[friend] = pointsMap[friend] + 1\\n\\n            if (pointsMap[friend] == 2)\\n                break\\n\\n            friend = (friend + turn * k) % n\\n            turn++\\n        }\\n\\n        val result = IntArray(n - (turn - 1))\\n        var i = 0\\n\\n        pointsMap.forEachIndexed { index, points ->\\n            if (points == 0) {\\n                result[i] = index + 1\\n                i++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val pointsMap = IntArray(n)\\n        var friend = 0\\n        var turn = 1\\n\\n        while (true) {\\n            pointsMap[friend] = pointsMap[friend] + 1\\n\\n            if (pointsMap[friend] == 2)\\n                break\\n\\n            friend = (friend + turn * k) % n\\n            turn++\\n        }\\n\\n        val result = IntArray(n - (turn - 1))\\n        var i = 0\\n\\n        pointsMap.forEachIndexed { index, points ->\\n            if (points == 0) {\\n                result[i] = index + 1\\n                i++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766614,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const visited = new Set()\\n    let currunt = 0, count = 1;\\n    while(!visited.has(currunt)) {\\n        visited.add(currunt);\\n        currunt = (currunt + k * count) % n;\\n        count++;\\n    }\\n    const result = [];\\n    for(let i = 1; i<=n; i++) {\\n        if(!visited.has(i-1)) result.push(i);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const visited = new Set()\\n    let currunt = 0, count = 1;\\n    while(!visited.has(currunt)) {\\n        visited.add(currunt);\\n        currunt = (currunt + k * count) % n;\\n        count++;\\n    }\\n    const result = [];\\n    for(let i = 1; i<=n; i++) {\\n        if(!visited.has(i-1)) result.push(i);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760991,
                "title": "hash-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>visited(n,0);\\n       visited[0]=1;vector<int>ans;\\n       int i=1;int j=0;\\n       while(visited[j]<2){\\n           j=(j+i*k)%n;\\n           visited[j]++;\\n           i++;\\n       }\\n       for(int i=0;i<n;i++){\\n           if(visited[i]==0){\\n               ans.push_back(i+1);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>visited(n,0);\\n       visited[0]=1;vector<int>ans;\\n       int i=1;int j=0;\\n       while(visited[j]<2){\\n           j=(j+i*k)%n;\\n           visited[j]++;\\n           i++;\\n       }\\n       for(int i=0;i<n;i++){\\n           if(visited[i]==0){\\n               ans.push_back(i+1);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757758,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> players(n, 0);\\n        vector<int> result {};\\n        int time = 1;\\n        int current = 0;\\n        bool stop = false;\\n        while (true)\\n        {\\n            for (int i=0; i<n; ++i)\\n            {\\n                if (players[i] == 2)\\n                {\\n                    stop = true;\\n                    break;\\n                }\\n            }\\n            if (stop)\\n            {\\n                break;\\n            }\\n            players[current] ++;\\n            current = (current + time * k) % n;\\n            time ++;\\n        }\\n\\n        for (int i=0; i<n; ++i)\\n        {\\n            if (players[i] == 0)\\n            {\\n                result.push_back(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> players(n, 0);\\n        vector<int> result {};\\n        int time = 1;\\n        int current = 0;\\n        bool stop = false;\\n        while (true)\\n        {\\n            for (int i=0; i<n; ++i)\\n            {\\n                if (players[i] == 2)\\n                {\\n                    stop = true;\\n                    break;\\n                }\\n            }\\n            if (stop)\\n            {\\n                break;\\n            }\\n            players[current] ++;\\n            current = (current + time * k) % n;\\n            time ++;\\n        }\\n\\n        for (int i=0; i<n; ++i)\\n        {\\n            if (players[i] == 0)\\n            {\\n                result.push_back(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3756087,
                "title": "java-easy-array-without-collection-o-n-magic-of-while-loop",
                "content": "# Approach\\nloop in while until we get true again and increase count each time\\nnow remaining `n-count+1` is the number of people who didn\\'t get the ball in the game.\\ndefine new array with size of `n-count+1` and add each person who has false in its index\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        int i = 0;\\n        int count = 1;\\n        while(visited[i]!=true){\\n            visited[i] = true;\\n            i = (i + count*k)%n;\\n            count++;\\n        }\\n        count = n-count+1; // these many people didn\\'t get the ball\\n        int[] answer = new int[count];\\n        i=0;\\n        for(int j=0; j<visited.length ; j++){\\n            if(visited[j]==false){\\n                answer[i++]=j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        int i = 0;\\n        int count = 1;\\n        while(visited[i]!=true){\\n            visited[i] = true;\\n            i = (i + count*k)%n;\\n            count++;\\n        }\\n        count = n-count+1; // these many people didn\\'t get the ball\\n        int[] answer = new int[count];\\n        i=0;\\n        for(int j=0; j<visited.length ; j++){\\n            if(visited[j]==false){\\n                answer[i++]=j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754110,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> v;\\n        for(int i=1;i<=n;i++) v.push_back(i);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[v[i]]=0;\\n        int iter=0;\\n        for(int i=0;;i=(i+iter*k)%n)\\n        {\\n            if(mp[v[i]]==1)break;\\n            mp[v[i]]++;\\n            iter++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[v[i]]==0) ans.push_back(v[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> v;\\n        for(int i=1;i<=n;i++) v.push_back(i);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[v[i]]=0;\\n        int iter=0;\\n        for(int i=0;;i=(i+iter*k)%n)\\n        {\\n            if(mp[v[i]]==1)break;\\n            mp[v[i]]++;\\n            iter++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[v[i]]==0) ans.push_back(v[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754099,
                "title": "java-solution-using-recursion-and-circular-linked-list",
                "content": "# Approach\\nStraight forward approach by using recursion and circular linked list\\n\\n# Code\\n```\\nclass Solution {\\n    private class ListNode {\\n        public int num;\\n        public boolean visited = false;\\n\\n        public ListNode next;\\n\\n        public ListNode(int num, ListNode next) {\\n            this.num = num;\\n            this.next = next;\\n        }\\n    }\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        ListNode head = createLinkedList(n);\\n\\n        passTheBall(head, k, 1);\\n\\n        ListNode cur = head.next;\\n        List<Integer> losers = new ArrayList<>();\\n        while(cur != head) {\\n            if(!cur.visited) {\\n                losers.add(cur.num);\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return losers.stream().mapToInt(i->i).toArray();\\n    }\\n\\n    public void passTheBall(ListNode head, int step, int i) {\\n        if(!head.visited) {\\n            head.visited = true;\\n            int k = i * step;\\n            while(k != 0) {\\n                head = head.next;\\n                k--;\\n            }\\n            passTheBall(head, step, (i+1));\\n        }\\n    }\\n\\n    private ListNode createLinkedList(int n) {\\n        ListNode head = new ListNode(1, null);\\n        ListNode cur = head;\\n        for(int i = 2; i <= n; i++) {\\n            ListNode node = new ListNode(i, null);\\n            cur.next = node;\\n            cur = node;\\n        }\\n        cur.next = head;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private class ListNode {\\n        public int num;\\n        public boolean visited = false;\\n\\n        public ListNode next;\\n\\n        public ListNode(int num, ListNode next) {\\n            this.num = num;\\n            this.next = next;\\n        }\\n    }\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        ListNode head = createLinkedList(n);\\n\\n        passTheBall(head, k, 1);\\n\\n        ListNode cur = head.next;\\n        List<Integer> losers = new ArrayList<>();\\n        while(cur != head) {\\n            if(!cur.visited) {\\n                losers.add(cur.num);\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return losers.stream().mapToInt(i->i).toArray();\\n    }\\n\\n    public void passTheBall(ListNode head, int step, int i) {\\n        if(!head.visited) {\\n            head.visited = true;\\n            int k = i * step;\\n            while(k != 0) {\\n                head = head.next;\\n                k--;\\n            }\\n            passTheBall(head, step, (i+1));\\n        }\\n    }\\n\\n    private ListNode createLinkedList(int n) {\\n        ListNode head = new ListNode(1, null);\\n        ListNode cur = head;\\n        for(int i = 2; i <= n; i++) {\\n            ListNode node = new ListNode(i, null);\\n            cur.next = node;\\n            cur = node;\\n        }\\n        cur.next = head;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744366,
                "title": "java-hashing-explained",
                "content": "**Idea:** Hash the people who have received the ball, then create `losers` array for who those who didn\\'t get the ball\\n>**T/S:** O(n)/O(n)\\n```\\npublic int[] circularGameLosers(int n, int k) {\\n\\tvar received = new boolean[n];\\n\\tvar current = 0;\\n\\tvar i = 1;\\n\\tvar m = 0;\\n\\n\\tfor (; !received[current]; i++) {\\n\\t\\treceived[current] = true;\\n\\t\\tcurrent = (current + i * k) % n;\\n\\t}\\n\\n\\tvar losers = new int[n - --i];\\n\\n\\tfor (var j = 0; j < n; j++)\\n\\t\\tif (!received[j])\\n\\t\\t\\tlosers[m++] = j + 1;\\n\\n\\treturn losers;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] circularGameLosers(int n, int k) {\\n\\tvar received = new boolean[n];\\n\\tvar current = 0;\\n\\tvar i = 1;\\n\\tvar m = 0;\\n\\n\\tfor (; !received[current]; i++) {\\n\\t\\treceived[current] = true;\\n\\t\\tcurrent = (current + i * k) % n;\\n\\t}\\n\\n\\tvar losers = new int[n - --i];\\n\\n\\tfor (var j = 0; j < n; j++)\\n\\t\\tif (!received[j])\\n\\t\\t\\tlosers[m++] = j + 1;\\n\\n\\treturn losers;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727744,
                "title": "simple-java-solution-beats-99",
                "content": "\\nStore the players in an array.\\n```\\narr = [1,2,3,4,5]\\n```\\nIf a player has the ball, update the value by ```-1``` at that index. At every iteration check if the value is -1. If yes then the game is completed.\\nThe catch here is this: we need to store the current index (the index at which the ball is present). Now we need to add ```i*k``` value to the current index and then do a ```%n```. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] players = new int[n];\\n        for(int i = 0; i < n; i++) players[i] = i+1;        \\n        int a = 0; \\n        int currentIndex = 0;\\n        \\n        while(true){\\n            int index = (a*k);\\n            currentIndex = currentIndex + index;\\n            currentIndex = currentIndex % n;\\n            if(players[currentIndex] == -1) break;\\n            players[currentIndex] = -1;\\n            a++;\\n        }        \\n        int[] r = new int[n-a];\\n        int j = 0;\\n        for(int i = 0; i < n; i++){\\n            if(players[i] != -1) r[j++] = players[i];\\n        } \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\narr = [1,2,3,4,5]\\n```\n```-1```\n```i*k```\n```%n```\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] players = new int[n];\\n        for(int i = 0; i < n; i++) players[i] = i+1;        \\n        int a = 0; \\n        int currentIndex = 0;\\n        \\n        while(true){\\n            int index = (a*k);\\n            currentIndex = currentIndex + index;\\n            currentIndex = currentIndex % n;\\n            if(players[currentIndex] == -1) break;\\n            players[currentIndex] = -1;\\n            a++;\\n        }        \\n        int[] r = new int[n-a];\\n        int j = 0;\\n        for(int i = 0; i < n; i++){\\n            if(players[i] != -1) r[j++] = players[i];\\n        } \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699824,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  List<int> circularGameLosers(int n, int k) {\\n    List<int> count = List<int>.filled(n, 0);\\n    int currentFriend = 1;\\n    int turn = 1;\\n\\n    while (true) {\\n      count[currentFriend - 1]++;\\n      if (count[currentFriend - 1] == 2) {\\n        break;\\n      }\\n      currentFriend = (currentFriend + turn * k) % n;\\n      if (currentFriend == 0) {\\n        currentFriend = n;\\n      }\\n      turn++;\\n    }\\n\\n    List<int> losers = [];\\n    for (int i = 0; i < n; i++) {\\n      if (count[i] == 0) {\\n        losers.add(i + 1);\\n      }\\n    }\\n\\n    return losers;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> circularGameLosers(int n, int k) {\\n    List<int> count = List<int>.filled(n, 0);\\n    int currentFriend = 1;\\n    int turn = 1;\\n\\n    while (true) {\\n      count[currentFriend - 1]++;\\n      if (count[currentFriend - 1] == 2) {\\n        break;\\n      }\\n      currentFriend = (currentFriend + turn * k) % n;\\n      if (currentFriend == 0) {\\n        currentFriend = n;\\n      }\\n      turn++;\\n    }\\n\\n    List<int> losers = [];\\n    for (int i = 0; i < n; i++) {\\n      if (count[i] == 0) {\\n        losers.add(i + 1);\\n      }\\n    }\\n\\n    return losers;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698194,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n+1 , 0);\\n        vector<int> ans;\\n\\n        int i=1 , j=1;\\n        while (true){\\n            if (vis[i]==1){\\n                break;\\n            }\\n            vis[i] = 1;\\n            i += j*k;\\n            j++;\\n            if (i>n){\\n                while (i>n){\\n                    i -= n;\\n                }\\n            }\\n        } \\n\\n        for (int i=1 ; i<n+1 ; i++){\\n            if (vis[i]==0)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n+1 , 0);\\n        vector<int> ans;\\n\\n        int i=1 , j=1;\\n        while (true){\\n            if (vis[i]==1){\\n                break;\\n            }\\n            vis[i] = 1;\\n            i += j*k;\\n            j++;\\n            if (i>n){\\n                while (i>n){\\n                    i -= n;\\n                }\\n            }\\n        } \\n\\n        for (int i=1 ; i<n+1 ; i++){\\n            if (vis[i]==0)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693047,
                "title": "very-easy-ts-js-solution-using-hashmap-and-circular-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question is very simple, we have to stop the game as soon as someone gets the ball for the second time.\\n1) First we declar a hashmap to store the points of all the players. Initialy its zero for all. \\n2) We declar a counter that tracks how many times we iterate over the array of players. Each time we iterate over the array of players we increase the k value by counter times and increase the points of the plyer in hashmap which is present at k index. \\n3) We our index go out of bound we compute the circular index using the modulo operator (index = (index + kn) % arr.length) . \\n4) Every time we increase the score/points of a player in the hashmap we first check if its previous score is less than or equal to 1 or not. If its more than one we break the loop there itself.\\n5) Once we come out of the loop we iterate over the hashmap and check which all players have zero score and thats our answer.\\n\\n**If you like my solution, please upvote. It motivates me a lot.**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction circularGameLosers(n: number, k: number): number[] {\\n    let arr = []\\n    let hash = {}\\n    for(let i = 0 ; i < n ; i++){\\n        arr.push(i+1)\\n        hash[i+1] = 0\\n    }\\n\\n    let status = true\\n    let count = 0\\n    let index = 0\\n    while(status){\\n        let kn = count * k\\n        index = (index + kn) % arr.length\\n        if(hash[arr[index]] + 1 <= 1){\\n            hash[arr[index]] = hash[arr[index]] + 1\\n        }else{\\n            break\\n        }\\n    \\n        count ++ \\n    }\\n\\n    let res = []\\n    for(let i in hash){\\n        if(hash[i] == 0){\\n            res.push(+i)\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nfunction circularGameLosers(n: number, k: number): number[] {\\n    let arr = []\\n    let hash = {}\\n    for(let i = 0 ; i < n ; i++){\\n        arr.push(i+1)\\n        hash[i+1] = 0\\n    }\\n\\n    let status = true\\n    let count = 0\\n    let index = 0\\n    while(status){\\n        let kn = count * k\\n        index = (index + kn) % arr.length\\n        if(hash[arr[index]] + 1 <= 1){\\n            hash[arr[index]] = hash[arr[index]] + 1\\n        }else{\\n            break\\n        }\\n    \\n        count ++ \\n    }\\n\\n    let res = []\\n    for(let i in hash){\\n        if(hash[i] == 0){\\n            res.push(+i)\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685898,
                "title": "easy-hashing-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> count(n, 0);\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        vector<int> ans;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                ans.push_back(i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> count(n, 0);\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        vector<int> ans;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                ans.push_back(i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683179,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int>ans;\\n        int start=1;\\n        int i=1;\\n        map<int,bool>umap;\\n        for(int i =1;i<=n;i++){\\n            umap[i]=false;\\n        }\\n        int helper=1;\\n\\n        while(umap[start]==false){\\n\\n            if(umap[start] !=true){\\n                umap[start]=true;\\n                  helper = (k*i+start);\\n                start= (k*i+start)%(n);\\n              \\n                if(start==0){\\n                   start=n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(auto x:umap){\\n            if(x.second==false){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int>ans;\\n        int start=1;\\n        int i=1;\\n        map<int,bool>umap;\\n        for(int i =1;i<=n;i++){\\n            umap[i]=false;\\n        }\\n        int helper=1;\\n\\n        while(umap[start]==false){\\n\\n            if(umap[start] !=true){\\n                umap[start]=true;\\n                  helper = (k*i+start);\\n                start= (k*i+start)%(n);\\n              \\n                if(start==0){\\n                   start=n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(auto x:umap){\\n            if(x.second==false){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682409,
                "title": "java-1ms-99-10-fast-bitwise",
                "content": "# Complexity\\n- Time complexity:\\nO(n) - in worst case we give ball to every friend.\\n\\n- Space complexity:\\nO(1) - since we know that number of friends cannot exceed 50 we can always use one var of LONG type\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        long friends = 2L, mask = 0L;\\n        int resultI = 0, turn = 1;\\n        for (int currFriend = 1, nextFriend = 0; ; friends |= mask, currFriend = nextFriend) {\\n            nextFriend = (currFriend + k * turn++) % n;\\n            if (nextFriend == 0) nextFriend = n;\\n            mask = 1L << nextFriend;\\n            if ( (friends & mask) == mask) break;\\n        }\\n        final int[] result = new int[n - turn + 1];\\n        for (int i = 1; i <= n; i++)\\n            if ( ((friends >> i) & 1L) != 1L)\\n                result[resultI++] = i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        long friends = 2L, mask = 0L;\\n        int resultI = 0, turn = 1;\\n        for (int currFriend = 1, nextFriend = 0; ; friends |= mask, currFriend = nextFriend) {\\n            nextFriend = (currFriend + k * turn++) % n;\\n            if (nextFriend == 0) nextFriend = n;\\n            mask = 1L << nextFriend;\\n            if ( (friends & mask) == mask) break;\\n        }\\n        final int[] result = new int[n - turn + 1];\\n        for (int i = 1; i <= n; i++)\\n            if ( ((friends >> i) & 1L) != 1L)\\n                result[resultI++] = i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673733,
                "title": "brute-force-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> st = new LinkedHashSet<>();\\n        for(int i = 1;i <= n;i++){\\n            st.add(i);\\n        }\\n        int curr = 1;\\n        for(int turn = 1;st.contains(curr);turn++){\\n            st.remove(curr);\\n            curr = (curr + (turn * k) % n) % n;\\n            if(curr == 0) curr = n;\\n            \\n        }\\n        int ans[] = new int[st.size()];\\n        int i = 0;\\n        for(var e:st) ans[i++] = e;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> st = new LinkedHashSet<>();\\n        for(int i = 1;i <= n;i++){\\n            st.add(i);\\n        }\\n        int curr = 1;\\n        for(int turn = 1;st.contains(curr);turn++){\\n            st.remove(curr);\\n            curr = (curr + (turn * k) % n) % n;\\n            if(curr == 0) curr = n;\\n            \\n        }\\n        int ans[] = new int[st.size()];\\n        int i = 0;\\n        for(var e:st) ans[i++] = e;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672708,
                "title": "python-dictionary-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        current_num = 1\\n        ans_dict = {1:1}\\n        i = 1\\n        while current_num not in ans_dict or ans_dict[current_num] == 1:\\n            next_num = current_num + i * k\\n            print(next_num)\\n            if next_num > n:\\n                next_num = next_num % n\\n                if next_num == 0:\\n                    next_num = n\\n            if next_num not in ans_dict:\\n                ans_dict[next_num] = 1\\n            else:\\n                break\\n            current_num = next_num\\n            i += 1\\n\\n        ans = list(set(list(range(1, n+1))) - set(ans_dict.keys()))\\n        ans.sort()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        current_num = 1\\n        ans_dict = {1:1}\\n        i = 1\\n        while current_num not in ans_dict or ans_dict[current_num] == 1:\\n            next_num = current_num + i * k\\n            print(next_num)\\n            if next_num > n:\\n                next_num = next_num % n\\n                if next_num == 0:\\n                    next_num = n\\n            if next_num not in ans_dict:\\n                ans_dict[next_num] = 1\\n            else:\\n                break\\n            current_num = next_num\\n            i += 1\\n\\n        ans = list(set(list(range(1, n+1))) - set(ans_dict.keys()))\\n        ans.sort()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663771,
                "title": "c-basic-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0),ans;\\n        for(int i=0,j=1;!v[i];++j){\\n            v[i]=1;\\n            i=(i+j*k)%n;\\n        }\\n        for(int i=0;i<n;++i)if(!v[i])ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0),ans;\\n        for(int i=0,j=1;!v[i];++j){\\n            v[i]=1;\\n            i=(i+j*k)%n;\\n        }\\n        for(int i=0;i<n;++i)if(!v[i])ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657133,
                "title": "c-easy-and-fast-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n            SortedSet<int> te = new SortedSet<int>();\\n            int pos = 1;\\n            te.Add(pos);\\n            int loop = 1;\\n            while(true)\\n            {\\n                pos = pos + k*loop;\\n                int th = pos % n;\\n                if(th==0)\\n                {\\n                    th = n;\\n                }\\n                if (!te.Add(th))\\n                {\\n                    break;\\n                }\\n                loop++;\\n            }\\n            int el = n - te.Count;\\n            int[] res = new int[el];\\n            int cou = 0;\\n            for(int i=1; i <= n; i++)\\n            {\\n                if(!te.Contains(i))\\n                {\\n                    res[cou] = i;\\n                    cou++;\\n                }\\n            }\\n            return res;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n            SortedSet<int> te = new SortedSet<int>();\\n            int pos = 1;\\n            te.Add(pos);\\n            int loop = 1;\\n            while(true)\\n            {\\n                pos = pos + k*loop;\\n                int th = pos % n;\\n                if(th==0)\\n                {\\n                    th = n;\\n                }\\n                if (!te.Add(th))\\n                {\\n                    break;\\n                }\\n                loop++;\\n            }\\n            int el = n - te.Count;\\n            int[] res = new int[el];\\n            int cou = 0;\\n            for(int i=1; i <= n; i++)\\n            {\\n                if(!te.Contains(i))\\n                {\\n                    res[cou] = i;\\n                    cou++;\\n                }\\n            }\\n            return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652370,
                "title": "simulation-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int[] counts = new int[n];        \\n        int iTurn = 1;\\n        int iBall = 0;\\n        while (true)\\n        {            \\n            counts[iBall]++;\\n            if (counts[iBall] == 2)\\n                break;\\n            iBall = (iBall + iTurn * k) % n;\\n            iTurn++;\\n        }\\n        \\n        return counts.Select((item, index) => (item, index)).\\n                      Where(x => x.item == 0).\\n                      Select(x => x.index + 1).\\n                      ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int[] counts = new int[n];        \\n        int iTurn = 1;\\n        int iBall = 0;\\n        while (true)\\n        {            \\n            counts[iBall]++;\\n            if (counts[iBall] == 2)\\n                break;\\n            iBall = (iBall + iTurn * k) % n;\\n            iTurn++;\\n        }\\n        \\n        return counts.Select((item, index) => (item, index)).\\n                      Where(x => x.item == 0).\\n                      Select(x => x.index + 1).\\n                      ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651369,
                "title": "beats-99-faster-solution-c-optimised-easy-approach-maths-bruteforce",
                "content": "# Intuition\\njust doing the mathematics based on the question as mentioned \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: < O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector<int> ans;\\n        vector<bool> visited(n+1,false);\\n        visited[1] = true;\\n        int i=1;\\n        int curri = 0;\\n        for(int j=1;j<=n;j++){\\n            int steps = i*k;\\n            int index = (steps + curri)%n;\\n            if(visited[index+1] == true){\\n                break;\\n            }else{\\n                visited[index+1] = true;\\n                i+=1;\\n                curri = index;\\n            }\\n        }\\n        vector<int> ans ;\\n\\n        for(int i=1;i<n+1;i++){\\n            if(visited[i] == false){\\n                ans.push_back(i);\\n            }\\n        }\\n        return (ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector<int> ans;\\n        vector<bool> visited(n+1,false);\\n        visited[1] = true;\\n        int i=1;\\n        int curri = 0;\\n        for(int j=1;j<=n;j++){\\n            int steps = i*k;\\n            int index = (steps + curri)%n;\\n            if(visited[index+1] == true){\\n                break;\\n            }else{\\n                visited[index+1] = true;\\n                i+=1;\\n                curri = index;\\n            }\\n        }\\n        vector<int> ans ;\\n\\n        for(int i=1;i<n+1;i++){\\n            if(visited[i] == false){\\n                ans.push_back(i);\\n            }\\n        }\\n        return (ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648617,
                "title": "javascript-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    let map=new Map()\\n    let i=1\\n    let count=1\\n    while(true){\\n        i=i%n\\n        if(i==0){\\n            i=n\\n        }\\n        if(!map.has(i)){\\n           map.set(i,1)\\n        }\\n        else{\\n            break\\n        }\\n        i+=count*k\\n        count++\\n    }\\n    console.log(map)\\n    let arr=[]\\n    for(let i=1;i<=n;i++){\\n        if(map.has(i)){\\n            continue\\n        }\\n        else{\\n            arr.push(i)\\n        }\\n\\n\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    let map=new Map()\\n    let i=1\\n    let count=1\\n    while(true){\\n        i=i%n\\n        if(i==0){\\n            i=n\\n        }\\n        if(!map.has(i)){\\n           map.set(i,1)\\n        }\\n        else{\\n            break\\n        }\\n        i+=count*k\\n        count++\\n    }\\n    console.log(map)\\n    let arr=[]\\n    for(let i=1;i<=n;i++){\\n        if(map.has(i)){\\n            continue\\n        }\\n        else{\\n            arr.push(i)\\n        }\\n\\n\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3635557,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> result;\\n        bool players[50] = {};\\n        auto current = 0, turn = 1;\\n        do {\\n            players[current] = true;\\n            current = (current + turn++ * k) % n;\\n        } while (!players[current]);\\n        for (auto i = 0; i < n; ++i)\\n            if (!players[i])\\n                result.push_back(i + 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> result;\\n        bool players[50] = {};\\n        auto current = 0, turn = 1;\\n        do {\\n            players[current] = true;\\n            current = (current + turn++ * k) % n;\\n        } while (!players[current]);\\n        for (auto i = 0; i < n; ++i)\\n            if (!players[i])\\n                result.push_back(i + 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630425,
                "title": "java-hashset-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int[] circularGameLosers(int n, int k) {\\n    Set<Integer> set = new HashSet<>();\\n    int number = 1, step = 1;\\n\\n    while (true) {\\n        if (set.contains(number))\\n            break;\\n\\n        set.add(number);\\n        number = ((step * k) + number) % n;\\n        step++;\\n    }\\n\\n   if(set.contains(0)){\\n       set.remove(0);\\n       set.add(n);\\n   }\\n    int arr[]=new int[n-set.size()];\\n    int p=0;\\n    for (int i = 1; i <= n; i++) {\\n        if (!set.contains(i)) {\\n            arr[p++] = i;\\n        }\\n    }\\n\\n    return arr;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int[] circularGameLosers(int n, int k) {\\n    Set<Integer> set = new HashSet<>();\\n    int number = 1, step = 1;\\n\\n    while (true) {\\n        if (set.contains(number))\\n            break;\\n\\n        set.add(number);\\n        number = ((step * k) + number) % n;\\n        step++;\\n    }\\n\\n   if(set.contains(0)){\\n       set.remove(0);\\n       set.add(n);\\n   }\\n    int arr[]=new int[n-set.size()];\\n    int p=0;\\n    for (int i = 1; i <= n; i++) {\\n        if (!set.contains(i)) {\\n            arr[p++] = i;\\n        }\\n    }\\n\\n    return arr;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618964,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(1, n + 1)]\\n        winners = {1}\\n        index = 0\\n        i = 1\\n        while True:\\n            index = (index + (i * k)) % n\\n            if friends[index] in winners:\\n                break\\n            else:\\n                winners.add(friends[index])\\n            i += 1\\n        return sorted(set(friends) - winners)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(1, n + 1)]\\n        winners = {1}\\n        index = 0\\n        i = 1\\n        while True:\\n            index = (index + (i * k)) % n\\n            if friends[index] in winners:\\n                break\\n            else:\\n                winners.add(friends[index])\\n            i += 1\\n        return sorted(set(friends) - winners)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610175,
                "title": "simple-python-solution-beats-85",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        not_recieved = {i for i in range(1, n + 1)}\\n        current = 0\\n        for i in range(50):\\n            current = (current + (k * i)) % n\\n            if current + 1 not in not_recieved:\\n                break\\n            not_recieved.remove(current + 1)\\n        return not_recieved\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        not_recieved = {i for i in range(1, n + 1)}\\n        current = 0\\n        for i in range(50):\\n            current = (current + (k * i)) % n\\n            if current + 1 not in not_recieved:\\n                break\\n            not_recieved.remove(current + 1)\\n        return not_recieved\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609571,
                "title": "very-readable-and-easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        has_played_map = {i: False for i in range (n)}\\n\\n        curr_ball_holder = 0\\n        multiplier = 1\\n\\n        while has_played_map[curr_ball_holder] == False:\\n            has_played_map[curr_ball_holder] = True\\n            curr_ball_holder  = (curr_ball_holder + (multiplier * k)) % n\\n            multiplier += 1\\n        \\n        return [player_no + 1 for player_no, has_played in has_played_map.items() if not has_played]\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        has_played_map = {i: False for i in range (n)}\\n\\n        curr_ball_holder = 0\\n        multiplier = 1\\n\\n        while has_played_map[curr_ball_holder] == False:\\n            has_played_map[curr_ball_holder] = True\\n            curr_ball_holder  = (curr_ball_holder + (multiplier * k)) % n\\n            multiplier += 1\\n        \\n        return [player_no + 1 for player_no, has_played in has_played_map.items() if not has_played]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608593,
                "title": "operating-with-player-number-not-index-o-n",
                "content": "# Intuition\\nWe are playing the game\\n\\n# Approach\\nWe will be operating with player number, not index\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val gotBall = mutableListOf(1)\\n        var turn = 1\\n        while (true) {\\n            var nextPlayer =  (gotBall.last() + k * turn++) % n\\n            // if the last player receives the ball\\n            if (nextPlayer == 0) nextPlayer = n\\n\\n            if (nextPlayer in gotBall) break\\n            gotBall.add(nextPlayer)\\n        }\\n\\n        return (1..n).filter { it !in gotBall }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val gotBall = mutableListOf(1)\\n        var turn = 1\\n        while (true) {\\n            var nextPlayer =  (gotBall.last() + k * turn++) % n\\n            // if the last player receives the ball\\n            if (nextPlayer == 0) nextPlayer = n\\n\\n            if (nextPlayer in gotBall) break\\n            gotBall.add(nextPlayer)\\n        }\\n\\n        return (1..n).filter { it !in gotBall }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603981,
                "title": "elixir-simulation-solution",
                "content": "`i` means (\"the friend holding the ball\" - 1).\\n`j` means the number of steps to pass the ball.\\n`set` contains all the friends who never held the ball.\\n# Code\\n```Elixir\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    play(MapSet.new(1..n), 0, k, n, k)\\n  end\\n\\n  defp play(set, i, j, n, k) do\\n    if MapSet.member?(set, i + 1) do\\n      MapSet.delete(set, i + 1)\\n      |> play(rem(i + j, n), j + k, n, k)\\n    else\\n      Enum.sort(set)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```Elixir\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    play(MapSet.new(1..n), 0, k, n, k)\\n  end\\n\\n  defp play(set, i, j, n, k) do\\n    if MapSet.member?(set, i + 1) do\\n      MapSet.delete(set, i + 1)\\n      |> play(rem(i + j, n), j + k, n, k)\\n    else\\n      Enum.sort(set)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3602093,
                "title": "3ms-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashSet;\\npublic class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        HashSet<Integer> list = new HashSet<>();\\n\\n        int j = 1;\\n        int initial = 1;\\n        while (!list.contains(initial)){\\n            list.add(initial);\\n            initial = (initial+(k*j))%n;\\n            if (initial == 0)initial=n;\\n            j++;\\n        }\\n\\n        j=0;\\n        int[] result = new int[n - list.size()];\\n        for (int i = 1; i < n+1; i++) {\\n            if (!list.contains(i)) {\\n                result[j] = i;\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\npublic class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        HashSet<Integer> list = new HashSet<>();\\n\\n        int j = 1;\\n        int initial = 1;\\n        while (!list.contains(initial)){\\n            list.add(initial);\\n            initial = (initial+(k*j))%n;\\n            if (initial == 0)initial=n;\\n            j++;\\n        }\\n\\n        j=0;\\n        int[] result = new int[n - list.size()];\\n        for (int i = 1; i < n+1; i++) {\\n            if (!list.contains(i)) {\\n                result[j] = i;\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595936,
                "title": "c-python-easy-simple-solution-brute-force-o-n-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<pair<int,int>> vec;\\n        for(int i=1;i<=n;i++){\\n            pair<int,int> p;\\n            p.first = i;\\n            p.second = 0;\\n            vec.push_back(p);\\n        }\\n        int ptr = 0;\\n        int i = 1;\\n        while(vec[ptr].second != 1){\\n            vec[ptr].second = 1;\\n            ptr += (i++)*k ;\\n            ptr %= n;\\n        }\\n        vector<int>ans;\\n        for(auto x: vec) if(x.second==0) ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code : Python\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        nums = [i+1 for i in range(n)]\\n        status = [0]*n\\n        ptr, i = 0, 1\\n        while(status[ptr] != 1):\\n            status[ptr] = 1\\n            ptr = ptr + i*k\\n            i = i + 1\\n            ptr = ptr % n\\n        \\n        ans = []\\n        for i in range(len(status)):\\n            if(status[i] == 0):\\n                ans.append(nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<pair<int,int>> vec;\\n        for(int i=1;i<=n;i++){\\n            pair<int,int> p;\\n            p.first = i;\\n            p.second = 0;\\n            vec.push_back(p);\\n        }\\n        int ptr = 0;\\n        int i = 1;\\n        while(vec[ptr].second != 1){\\n            vec[ptr].second = 1;\\n            ptr += (i++)*k ;\\n            ptr %= n;\\n        }\\n        vector<int>ans;\\n        for(auto x: vec) if(x.second==0) ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        nums = [i+1 for i in range(n)]\\n        status = [0]*n\\n        ptr, i = 0, 1\\n        while(status[ptr] != 1):\\n            status[ptr] = 1\\n            ptr = ptr + i*k\\n            i = i + 1\\n            ptr = ptr % n\\n        \\n        ans = []\\n        for i in range(len(status)):\\n            if(status[i] == 0):\\n                ans.append(nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589652,
                "title": "c-simulation-convert-visualization-into-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int> vis(n,0);\\n        int i = 0 ; \\n        int t = k ; \\n        vis[0] = 1;\\n        while(1)\\n        {\\n            if(vis[(i+k)%n] ) break; \\n            cout<<(i+k)%n<<\" \";            \\n            vis[(i+k)%n] = 1 ;\\n            i = (i+k)%n;\\n            k  += t; \\n            \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for( int i = 0 ; i < n ; ++i )\\n        {\\n            if(!vis[i]) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int> vis(n,0);\\n        int i = 0 ; \\n        int t = k ; \\n        vis[0] = 1;\\n        while(1)\\n        {\\n            if(vis[(i+k)%n] ) break; \\n            cout<<(i+k)%n<<\" \";            \\n            vis[(i+k)%n] = 1 ;\\n            i = (i+k)%n;\\n            k  += t; \\n            \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for( int i = 0 ; i < n ; ++i )\\n        {\\n            if(!vis[i]) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583625,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n\\n- Space complexity:\\n- $$O(n)$$\\n\\n# Code\\n```\\nfunc circularGameLosers(n int, k int) []int {\\n\\twinnerMap := map[int]bool{0: true}\\n\\tcurIdx := 0\\n\\tround := 1\\n\\n\\tfor true {\\n\\t\\tcurIdx = (curIdx + round*k) % n\\n\\n\\t\\tif true == winnerMap[curIdx] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\twinnerMap[curIdx] = true\\n\\t\\tround++\\n\\t}\\n\\n\\tres := []int{}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif false == winnerMap[i] {\\n\\t\\t\\tres = append(res, i+1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc circularGameLosers(n int, k int) []int {\\n\\twinnerMap := map[int]bool{0: true}\\n\\tcurIdx := 0\\n\\tround := 1\\n\\n\\tfor true {\\n\\t\\tcurIdx = (curIdx + round*k) % n\\n\\n\\t\\tif true == winnerMap[curIdx] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\twinnerMap[curIdx] = true\\n\\t\\tround++\\n\\t}\\n\\n\\tres := []int{}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif false == winnerMap[i] {\\n\\t\\t\\tres = append(res, i+1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583578,
                "title": "simple-kotlin-solution",
                "content": "\\n# Approach\\nJust play the game. Since we generally like to work in 0 indexed fashion but the result needs to be 1 indexed, convert at the end when taking indices that aren\\'t in the visited set.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val set = mutableSetOf<Int>()\\n        var current = 0\\n        var turn = 1\\n\\n        while (!set.contains(current)) {\\n            set.add(current)\\n            current = (current + turn++ * k) % n\\n        }\\n\\n        val result = IntArray(n - set.size)\\n        var index = 0\\n        \\n        for (i in 0 until n) {\\n            if (!set.contains(i)) {\\n                result[index++] = i + 1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val set = mutableSetOf<Int>()\\n        var current = 0\\n        var turn = 1\\n\\n        while (!set.contains(current)) {\\n            set.add(current)\\n            current = (current + turn++ * k) % n\\n        }\\n\\n        val result = IntArray(n - set.size)\\n        var index = 0\\n        \\n        for (i in 0 until n) {\\n            if (!set.contains(i)) {\\n                result[index++] = i + 1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575470,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        int[] arr = new int[n];\\n        int i = 0;\\n        int j = 1;\\n\\n        while(arr[i%n] == 0){\\n            \\n            arr[i%n] = 1;\\n            i += k*j;\\n            j++;\\n            \\n        }\\n        \\n        int len = 0;\\n\\n        for(int l : arr) if(l == 0) len++;\\n\\n        int[] ans = new int[len];\\n\\n        int index = 0;\\n\\n        for(int l=0; l<arr.length; l++) if(arr[l] == 0) ans[index++] = l+1;\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        int[] arr = new int[n];\\n        int i = 0;\\n        int j = 1;\\n\\n        while(arr[i%n] == 0){\\n            \\n            arr[i%n] = 1;\\n            i += k*j;\\n            j++;\\n            \\n        }\\n        \\n        int len = 0;\\n\\n        for(int l : arr) if(l == 0) len++;\\n\\n        int[] ans = new int[len];\\n\\n        int index = 0;\\n\\n        for(int l=0; l<arr.length; l++) if(arr[l] == 0) ans[index++] = l+1;\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574127,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirstly ,for keep track of visited number we need a map. \\n# Approach\\nBrute force.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        int p=1,q;\\n        vector<int>v;\\n        map<int ,int >mp;\\n        for(int i=1;i<=5;i++)\\n        {\\n            mp[i]=0;\\n        }\\n        if(k==1 && n<=2)\\n        {\\n            return v;\\n        }\\n        int i=1;\\n        mp[1]++;\\n        while(1)\\n        {\\n           q= (p+k*i);\\n           if(q>n)\\n           {\\n               q=q%n;\\n               if(q==0)\\n               {\\n                   q=n;\\n               }\\n           }\\n           mp[q]++;\\n           if(mp[q]==2)\\n           {\\n               break;\\n           }\\n           p=q;\\n           i++;\\n\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        int p=1,q;\\n        vector<int>v;\\n        map<int ,int >mp;\\n        for(int i=1;i<=5;i++)\\n        {\\n            mp[i]=0;\\n        }\\n        if(k==1 && n<=2)\\n        {\\n            return v;\\n        }\\n        int i=1;\\n        mp[1]++;\\n        while(1)\\n        {\\n           q= (p+k*i);\\n           if(q>n)\\n           {\\n               q=q%n;\\n               if(q==0)\\n               {\\n                   q=n;\\n               }\\n           }\\n           mp[q]++;\\n           if(mp[q]==2)\\n           {\\n               break;\\n           }\\n           p=q;\\n           i++;\\n\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568404,
                "title": "video-in-arabic-language-for-how-to-think-on-the-solution-python-code",
                "content": "\\n# Think how to solve the problem \\n<!-- Describe your approach to solving the problem. -->\\n[https://www.youtube.com/watch?v=itaExMDMoO0]()\\n\\n# Code\\n```\\nclass Solution(object):\\n    def circularGameLosers(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if n == k:\\n            return  list(range(2,n+1))\\n        \\n        res_dict = {}\\n        res_dict[1] = 1\\n        for i in range(2,n+1):\\n            res_dict[i] = 0\\n        \\n        iterationNumber = 1\\n        playerNumber = 1\\n        while(1):\\n            nextPlayer = (playerNumber + ( k * iterationNumber ) ) % n \\n            \\n           \\n        \\n            if (nextPlayer == 0 ):\\n                nextPlayer = n \\n            \\n            if(res_dict.get(nextPlayer) == 1):\\n                return [k for k, v in res_dict.items() if v == 0]\\n            \\n            else:\\n                res_dict[nextPlayer] = 1\\n             \\n            playerNumber = nextPlayer\\n            iterationNumber += 1\\n                \\n            \\n      \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def circularGameLosers(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if n == k:\\n            return  list(range(2,n+1))\\n        \\n        res_dict = {}\\n        res_dict[1] = 1\\n        for i in range(2,n+1):\\n            res_dict[i] = 0\\n        \\n        iterationNumber = 1\\n        playerNumber = 1\\n        while(1):\\n            nextPlayer = (playerNumber + ( k * iterationNumber ) ) % n \\n            \\n           \\n        \\n            if (nextPlayer == 0 ):\\n                nextPlayer = n \\n            \\n            if(res_dict.get(nextPlayer) == 1):\\n                return [k for k, v in res_dict.items() if v == 0]\\n            \\n            else:\\n                res_dict[nextPlayer] = 1\\n             \\n            playerNumber = nextPlayer\\n            iterationNumber += 1\\n                \\n            \\n      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567413,
                "title": "java-javascript-c-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public int[] circularGameLosers(int totalPlayers, int steps) {\\n        boolean[] ballReceivedByPlayer = new boolean[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(boolean[] ballReceivedByPlayer, int totalPlayers, int steps) {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(boolean[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number} totalPlayers\\n * @param {number} steps\\n * @return {number[]}\\n */\\nvar circularGameLosers = function (totalPlayers, steps) {\\n    const ballReceivedByPlayer = new Array(totalPlayers).fill(false);\\n    let uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n    return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n};\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} steps \\n * @return {number}\\n */\\nfunction countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps) {\\n    let currentPlayer = 0;\\n    let uniqueBallReceptions = 1;\\n    ballReceivedByPlayer[currentPlayer] = true;\\n\\n    while (true) {\\n        let nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n        if (ballReceivedByPlayer[nextPlayer]) {\\n            break;\\n        }\\n\\n        ++uniqueBallReceptions;\\n        currentPlayer = nextPlayer;\\n        ballReceivedByPlayer[nextPlayer] = true;\\n    }\\n    return uniqueBallReceptions;\\n}\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} countUniqueBallReceptions \\n * @return {number[]}\\n */\\nfunction extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, countUniqueBallReceptions) {\\n    let index = 0;\\n    const circularGameLosers = new Array(totalPlayers - countUniqueBallReceptions);\\n    for (let i = 0; i < totalPlayers; ++i) {\\n        if (!ballReceivedByPlayer[i]) {\\n            circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n            ++index;\\n        }\\n    }\\n    return circularGameLosers;\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> circularGameLosers(int totalPlayers, int steps) const {\\n        vector<bool> ballReceivedByPlayer(totalPlayers);\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\nprivate:\\n    int countUniqueBallReceptions(vector<bool>& ballReceivedByPlayer, int totalPlayers, int steps) const {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    vector<int> extractLosersFromAllPlayers(const vector<bool>& ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) const {\\n        int index = 0;\\n        vector<int> circularGameLosers(totalPlayers - countUniqueBallReceptions);\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1; //PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n};\\n```\\n**C#**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int[] CircularGameLosers(int totalPlayers, int steps)\\n    {\\n        bool[] ballReceivedByPlayer = new bool[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(bool[] ballReceivedByPlayer, int totalPlayers, int steps)\\n    {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true)\\n        {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer])\\n            {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(bool[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions)\\n    {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i)\\n        {\\n            if (!ballReceivedByPlayer[i])\\n            {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int[] circularGameLosers(int totalPlayers, int steps) {\\n        boolean[] ballReceivedByPlayer = new boolean[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(boolean[] ballReceivedByPlayer, int totalPlayers, int steps) {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(boolean[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number} totalPlayers\\n * @param {number} steps\\n * @return {number[]}\\n */\\nvar circularGameLosers = function (totalPlayers, steps) {\\n    const ballReceivedByPlayer = new Array(totalPlayers).fill(false);\\n    let uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n    return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n};\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} steps \\n * @return {number}\\n */\\nfunction countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps) {\\n    let currentPlayer = 0;\\n    let uniqueBallReceptions = 1;\\n    ballReceivedByPlayer[currentPlayer] = true;\\n\\n    while (true) {\\n        let nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n        if (ballReceivedByPlayer[nextPlayer]) {\\n            break;\\n        }\\n\\n        ++uniqueBallReceptions;\\n        currentPlayer = nextPlayer;\\n        ballReceivedByPlayer[nextPlayer] = true;\\n    }\\n    return uniqueBallReceptions;\\n}\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} countUniqueBallReceptions \\n * @return {number[]}\\n */\\nfunction extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, countUniqueBallReceptions) {\\n    let index = 0;\\n    const circularGameLosers = new Array(totalPlayers - countUniqueBallReceptions);\\n    for (let i = 0; i < totalPlayers; ++i) {\\n        if (!ballReceivedByPlayer[i]) {\\n            circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n            ++index;\\n        }\\n    }\\n    return circularGameLosers;\\n}\\n```\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> circularGameLosers(int totalPlayers, int steps) const {\\n        vector<bool> ballReceivedByPlayer(totalPlayers);\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\nprivate:\\n    int countUniqueBallReceptions(vector<bool>& ballReceivedByPlayer, int totalPlayers, int steps) const {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    vector<int> extractLosersFromAllPlayers(const vector<bool>& ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) const {\\n        int index = 0;\\n        vector<int> circularGameLosers(totalPlayers - countUniqueBallReceptions);\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1; //PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n};\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int[] CircularGameLosers(int totalPlayers, int steps)\\n    {\\n        bool[] ballReceivedByPlayer = new bool[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(bool[] ballReceivedByPlayer, int totalPlayers, int steps)\\n    {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true)\\n        {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer])\\n            {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(bool[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions)\\n    {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i)\\n        {\\n            if (!ballReceivedByPlayer[i])\\n            {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558433,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        \\n        var win = Array(repeating: false, count: n)\\n        var i = 0\\n        var j = 1\\n\\n        while !win[i] {\\n            win[i] = true\\n            i = (i + k * j) % n\\n            j += 1\\n        }\\n\\n        return win\\n            .indices\\n            .filter { !win[$0] }\\n            .map { $0 + 1 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        \\n        var win = Array(repeating: false, count: n)\\n        var i = 0\\n        var j = 1\\n\\n        while !win[i] {\\n            win[i] = true\\n            i = (i + k * j) % n\\n            j += 1\\n        }\\n\\n        return win\\n            .indices\\n            .filter { !win[$0] }\\n            .map { $0 + 1 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557513,
                "title": "javascript-track-players-with-index-0-to-n-1-output-uses-index-i-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    \\n    let visited = new Set()\\n    visited.add(0)\\n    let numK = 1\\n    let current = (0 + numK * k) % n\\n\\n    while (!visited.has(current)) {\\n        visited.add(current)\\n        numK+=1\\n        current = (current + numK * k) % n    \\n    }\\n    \\n    let output = []\\n    let visitedArr = [...visited]\\n    for (let i = 0; i < n; i++) {\\n        if (!visitedArr.includes(i)) output.push(i + 1) // need to push i + 1 because the seat starts from 1\\n    }\\n    \\n    return output\\n};\\n\\n\\n/*\\n# Rank 179,825\\n# Date 5/21/2023\\n# Runtime: 97 ms, faster than 39.02%\\n# Memory Usage: 44.4 MB, less than 92.33%  \\n=======test case ========\\n2\\n1\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    \\n    let visited = new Set()\\n    visited.add(0)\\n    let numK = 1\\n    let current = (0 + numK * k) % n\\n\\n    while (!visited.has(current)) {\\n        visited.add(current)\\n        numK+=1\\n        current = (current + numK * k) % n    \\n    }\\n    \\n    let output = []\\n    let visitedArr = [...visited]\\n    for (let i = 0; i < n; i++) {\\n        if (!visitedArr.includes(i)) output.push(i + 1) // need to push i + 1 because the seat starts from 1\\n    }\\n    \\n    return output\\n};\\n\\n\\n/*\\n# Rank 179,825\\n# Date 5/21/2023\\n# Runtime: 97 ms, faster than 39.02%\\n# Memory Usage: 44.4 MB, less than 92.33%  \\n=======test case ========\\n2\\n1\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556228,
                "title": "easy-solution-with-c-faster-than-82-29",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> player;\\n        vector<int> res;\\n        int i = 1;//first person\\n        int count = 1; //first time\\n        int final = 0;\\n        bool check = false;\\n        player.push_back(i);\\n        while(true){\\n            if(count*k + i <= n){\\n                auto idx = find(player.begin(), player.end(), count*k + i);\\n                if(idx!= player.end()) {\\n                    final = count*k + i;\\n                    check = true;\\n                    break;\\n                }\\n                else {\\n                    player.push_back(count*k + i);\\n                    i += count*k;\\n                    count++;\\n                }\\n            }\\n            else {\\n                int res = count*k - (n - i);\\n                int div = res % n == 0 ? n : (res %n );\\n                auto idx = find(player.begin(), player.end(), div);\\n                if(idx!= player.end()) {\\n                    final = div;\\n                    check = true;\\n                    break;\\n                } else {\\n                    player.push_back(div);\\n                    i = div;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(check){\\n            for(int i = 1 ; i <= n; i++) {\\n                auto idx = find(player.begin(), player.end(), i);\\n                if(idx != player.end())\\n                    continue;\\n                else\\n                    res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> player;\\n        vector<int> res;\\n        int i = 1;//first person\\n        int count = 1; //first time\\n        int final = 0;\\n        bool check = false;\\n        player.push_back(i);\\n        while(true){\\n            if(count*k + i <= n){\\n                auto idx = find(player.begin(), player.end(), count*k + i);\\n                if(idx!= player.end()) {\\n                    final = count*k + i;\\n                    check = true;\\n                    break;\\n                }\\n                else {\\n                    player.push_back(count*k + i);\\n                    i += count*k;\\n                    count++;\\n                }\\n            }\\n            else {\\n                int res = count*k - (n - i);\\n                int div = res % n == 0 ? n : (res %n );\\n                auto idx = find(player.begin(), player.end(), div);\\n                if(idx!= player.end()) {\\n                    final = div;\\n                    check = true;\\n                    break;\\n                } else {\\n                    player.push_back(div);\\n                    i = div;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(check){\\n            for(int i = 1 ; i <= n; i++) {\\n                auto idx = find(player.begin(), player.end(), i);\\n                if(idx != player.end())\\n                    continue;\\n                else\\n                    res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556199,
                "title": "super-simple-bruteforce-with-no-data-structures-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       int a[]=new int[n];\\n       int i=0;\\n       for(i=0;i<n;i++)\\n       a[i]=i;\\n       i=0; \\n       int m=1,x=1,y=0,b=0;\\n       a[0]=0;\\n       while(b!=1){\\n          x=m*k+y;\\n          m++;\\n          while(x>=n){\\n              \\n              x=x-n;\\n          }\\n          if(a[x]==0)\\n          b=1;\\n          a[x]=0;\\n          y=x;\\n       }\\n       a[y]=0;\\n       int c=0;\\n       for(int j=0;j<n;j++)\\n       { \\n           a[j]=a[j]+1;\\n           if(a[j]==1)\\n           c++;\\n       }\\n       c=n-c;\\n       int f[]=new int[c];\\n       int d=0;\\n       for(int j=0;j<n;j++){\\n           if(a[j]!=1){ \\n          f[d]=a[j];\\n          d++;}\\n       }\\n      return f;\\n       \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       int a[]=new int[n];\\n       int i=0;\\n       for(i=0;i<n;i++)\\n       a[i]=i;\\n       i=0; \\n       int m=1,x=1,y=0,b=0;\\n       a[0]=0;\\n       while(b!=1){\\n          x=m*k+y;\\n          m++;\\n          while(x>=n){\\n              \\n              x=x-n;\\n          }\\n          if(a[x]==0)\\n          b=1;\\n          a[x]=0;\\n          y=x;\\n       }\\n       a[y]=0;\\n       int c=0;\\n       for(int j=0;j<n;j++)\\n       { \\n           a[j]=a[j]+1;\\n           if(a[j]==1)\\n           c++;\\n       }\\n       c=n-c;\\n       int f[]=new int[c];\\n       int d=0;\\n       for(int j=0;j<n;j++){\\n           if(a[j]!=1){ \\n          f[d]=a[j];\\n          d++;}\\n       }\\n      return f;\\n       \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553283,
                "title": "brute-force-but-eazy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n\\t{\\n        //we can create the boolean array for the players\\n        vector<bool>v;\\n        v.resize(n,false);   //intially none of the player got the ball in the hand\\n        int ptr = 0;\\n        v[ptr] = true;\\n        \\n        int offset = 1;  //for offset trun --> (offset * k)\\n        while(true)    //now the game begins \\n        {\\n        \\tint dis = offset * k;\\n        \\twhile(dis > 0)\\n        \\t{\\n        \\t\\tif(ptr == (v.size()-1))\\n        \\t\\t{\\n        \\t\\t\\tptr = 0;\\n        \\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tptr++;\\n\\t\\t\\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(v[ptr] == true)   //if the current cell is already true\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i] == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(i+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tv[ptr] = true;\\n\\t\\t\\toffset++;\\n\\t\\t}\\n\\t\\treturn {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n\\t{\\n        //we can create the boolean array for the players\\n        vector<bool>v;\\n        v.resize(n,false);   //intially none of the player got the ball in the hand\\n        int ptr = 0;\\n        v[ptr] = true;\\n        \\n        int offset = 1;  //for offset trun --> (offset * k)\\n        while(true)    //now the game begins \\n        {\\n        \\tint dis = offset * k;\\n        \\twhile(dis > 0)\\n        \\t{\\n        \\t\\tif(ptr == (v.size()-1))\\n        \\t\\t{\\n        \\t\\t\\tptr = 0;\\n        \\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tptr++;\\n\\t\\t\\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(v[ptr] == true)   //if the current cell is already true\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i] == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(i+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tv[ptr] = true;\\n\\t\\t\\toffset++;\\n\\t\\t}\\n\\t\\treturn {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549778,
                "title": "find-the-losers-of-the-circular-game-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> num(n+1,1);\\n        num[1]=0;\\n        int x=1;\\n        int i=1;\\n        int y=x+(i*k);\\n        if(y>n)\\n        {\\n            y=y%n;\\n            if(y==0)\\n            {\\n                y=n;\\n            }\\n        }\\n        while(num[y]!=0)\\n        {\\n            num[y]=0;\\n            i++;\\n            x=y;\\n            y=x+(i*k);\\n            if(y>n)\\n            {\\n                y=y%n;\\n                if(y==0)\\n                {\\n                    y=n;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(num[i]==1)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> num(n+1,1);\\n        num[1]=0;\\n        int x=1;\\n        int i=1;\\n        int y=x+(i*k);\\n        if(y>n)\\n        {\\n            y=y%n;\\n            if(y==0)\\n            {\\n                y=n;\\n            }\\n        }\\n        while(num[y]!=0)\\n        {\\n            num[y]=0;\\n            i++;\\n            x=y;\\n            y=x+(i*k);\\n            if(y>n)\\n            {\\n                y=y%n;\\n                if(y==0)\\n                {\\n                    y=n;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(num[i]==1)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546426,
                "title": "java-solution-set-based-approach",
                "content": "# Intuition\\nSet based approach where keep track of the players who are receiving the balls.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep all the players added in a set.\\n2. Also maintain another set who receive the balls starting with the first player.\\n3. Finally find the difference between these 2 sets.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        Set<Integer> players = new HashSet<>();\\n        Set<Integer> receivers = new HashSet<>();\\n        int nextPlayer = 1;\\n        int count = 2;\\n        int [] loosers = null;\\n        int originalSteps = k;\\n        for(int i=1; i<=n; i++)\\n        {\\n            players.add(i);\\n        }\\n        boolean added = receivers.add(nextPlayer);\\n        while(added)\\n        {\\n            nextPlayer += k;\\n            while(nextPlayer > n)\\n            {\\n                nextPlayer = nextPlayer - n;\\n            }\\n            k = originalSteps * count;\\n            count++;\\n            added = receivers.add(nextPlayer);\\n        } \\n        players.removeAll(receivers);\\n        loosers = new int[players.size()];\\n        count = 0;\\n        for(int i : players)\\n        {\\n            loosers[count++] = i;\\n        }\\n        return loosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        Set<Integer> players = new HashSet<>();\\n        Set<Integer> receivers = new HashSet<>();\\n        int nextPlayer = 1;\\n        int count = 2;\\n        int [] loosers = null;\\n        int originalSteps = k;\\n        for(int i=1; i<=n; i++)\\n        {\\n            players.add(i);\\n        }\\n        boolean added = receivers.add(nextPlayer);\\n        while(added)\\n        {\\n            nextPlayer += k;\\n            while(nextPlayer > n)\\n            {\\n                nextPlayer = nextPlayer - n;\\n            }\\n            k = originalSteps * count;\\n            count++;\\n            added = receivers.add(nextPlayer);\\n        } \\n        players.removeAll(receivers);\\n        loosers = new int[players.size()];\\n        count = 0;\\n        for(int i : players)\\n        {\\n            loosers[count++] = i;\\n        }\\n        return loosers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546388,
                "title": "c-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_set<int> s;\\n        vector<int> ans;\\n        int v = 0;\\n        int i = 1;\\n        while(!s.count(v+1)){\\n            s.insert(v+1);\\n            v = (v + i * k) % n;\\n            i++;\\n        }\\n        for(int i = 1 ; i <= n; i++) if(!s.count(i)) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_set<int> s;\\n        vector<int> ans;\\n        int v = 0;\\n        int i = 1;\\n        while(!s.count(v+1)){\\n            s.insert(v+1);\\n            v = (v + i * k) % n;\\n            i++;\\n        }\\n        for(int i = 1 ; i <= n; i++) if(!s.count(i)) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546225,
                "title": "good-problem-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        players=list(range(1,n+1))\\n        count={1:1}\\n        multiplier=k\\n        i=1\\n        new_player=1\\n        while multiplier>0:\\n            k=i*multiplier\\n            #print(\"In {} iteration, k is {}\".format(i,k))\\n            new_index=players.index(new_player)+k\\n            #print(\"Index incremental is {}\".format(new_index))\\n            if new_index>len(players)-1:\\n                new_index=new_index%len(players)\\n            #print(\"Final Index incremental is {}\".format(new_index))\\n            new_player=players[new_index]\\n            #print(\"Ball is now with {}\".format(new_player))\\n            \\n            if new_player in count:\\n                count[new_player]+=1\\n            else:\\n                count[new_player]=1\\n            #print(count)\\n            #print(\"\")\\n            if count[new_player]==2:\\n                break\\n            i+=1\\n        a=list(count.keys())\\n        b=list(set(players)-set(a))\\n        b.sort()\\n        return b\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        players=list(range(1,n+1))\\n        count={1:1}\\n        multiplier=k\\n        i=1\\n        new_player=1\\n        while multiplier>0:\\n            k=i*multiplier\\n            #print(\"In {} iteration, k is {}\".format(i,k))\\n            new_index=players.index(new_player)+k\\n            #print(\"Index incremental is {}\".format(new_index))\\n            if new_index>len(players)-1:\\n                new_index=new_index%len(players)\\n            #print(\"Final Index incremental is {}\".format(new_index))\\n            new_player=players[new_index]\\n            #print(\"Ball is now with {}\".format(new_player))\\n            \\n            if new_player in count:\\n                count[new_player]+=1\\n            else:\\n                count[new_player]=1\\n            #print(count)\\n            #print(\"\")\\n            if count[new_player]==2:\\n                break\\n            i+=1\\n        a=list(count.keys())\\n        b=list(set(players)-set(a))\\n        b.sort()\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545740,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreated an array of n+1 size to track visited players, initally 0 (not visited). \\nGame starts from position 1, so marking it as visited.\\nModulo for maintaning circular numbers. \\nIf curr is zero, it means current player is \\'nth\\' (tricky part!)\\nFinally returning the players who didn\\'t receive the ball.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        int vis[51] = {0}; vector<int> ans;\\n        vis[1] = 1; int curr = 1; int i=1;\\n\\n        while(true){\\n            curr = (curr+i*k)%n ;\\n            if(curr==0){\\n                curr = n; \\n            }\\n            if(vis[curr]){\\n                break;\\n            }\\n            vis[curr] = 1;\\n            i++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(!vis[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        int vis[51] = {0}; vector<int> ans;\\n        vis[1] = 1; int curr = 1; int i=1;\\n\\n        while(true){\\n            curr = (curr+i*k)%n ;\\n            if(curr==0){\\n                curr = n; \\n            }\\n            if(vis[curr]){\\n                break;\\n            }\\n            vis[curr] = 1;\\n            i++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(!vis[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545530,
                "title": "easy-array-runtime-3-ms-beats-57-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {        \\n        int c = 1, l = 1;\\n        boolean[] used = new boolean[n + 1];\\n        while(true){\\n            if(used[l]) break;\\n            used[l] = true;\\n            l += c * k;\\n            l %= n;\\n            if(l == 0) l = n;\\n            c++;\\n        }\\n        List< Integer > list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) if(!used[i]) list.add(i);\\n        int[] res = new int[list.size()];\\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {        \\n        int c = 1, l = 1;\\n        boolean[] used = new boolean[n + 1];\\n        while(true){\\n            if(used[l]) break;\\n            used[l] = true;\\n            l += c * k;\\n            l %= n;\\n            if(l == 0) l = n;\\n            c++;\\n        }\\n        List< Integer > list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) if(!used[i]) list.add(i);\\n        int[] res = new int[list.size()];\\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545246,
                "title": "python3-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lis=[0]*n\\n        res=[]\\n        i=0\\n        j=1\\n        while(1):\\n            if lis[i]==1:\\n                break\\n            else:\\n                lis[i]=1\\n                i=(i+j*k)%n\\n                \\n                j+=1\\n        for i in range(n):\\n            if lis[i]==0:\\n                res.append(i+1)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lis=[0]*n\\n        res=[]\\n        i=0\\n        j=1\\n        while(1):\\n            if lis[i]==1:\\n                break\\n            else:\\n                lis[i]=1\\n                i=(i+j*k)%n\\n                \\n                j+=1\\n        for i in range(n):\\n            if lis[i]==0:\\n                res.append(i+1)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545064,
                "title": "brute-force-java-using-hasmap-crystal-clear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n  public int[] circularGameLosers(int n, int k) {\\n      int currentPass = 1,currentPlayer = 0, j =0 ;\\n      Map<Integer,Integer> playerTurnHashmap = new HashMap<>();\\n      playerTurnHashmap.put(0,1);\\n      for (int i=1 ;i< n;i++) {\\n          playerTurnHashmap.put(i,0);\\n      }\\n      while (playerTurnHashmap.get(currentPlayer) <=1) {\\n         currentPlayer = (currentPlayer + (currentPass * k)) % n;\\n          playerTurnHashmap.put(currentPlayer,playerTurnHashmap.get(currentPlayer) + 1);\\n          currentPass ++ ;\\n      }\\n       int[] losersArray = new int[playerTurnHashmap.size()];\\n      \\n      for(Map.Entry<Integer,Integer> entry : playerTurnHashmap.entrySet()) {\\n          if (entry.getValue() == 0 ) {\\n              losersArray[j++] = entry.getKey() + 1;\\n          }\\n      } \\n    return  losersArray = Arrays.copyOfRange(losersArray, 0, j );\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  public int[] circularGameLosers(int n, int k) {\\n      int currentPass = 1,currentPlayer = 0, j =0 ;\\n      Map<Integer,Integer> playerTurnHashmap = new HashMap<>();\\n      playerTurnHashmap.put(0,1);\\n      for (int i=1 ;i< n;i++) {\\n          playerTurnHashmap.put(i,0);\\n      }\\n      while (playerTurnHashmap.get(currentPlayer) <=1) {\\n         currentPlayer = (currentPlayer + (currentPass * k)) % n;\\n          playerTurnHashmap.put(currentPlayer,playerTurnHashmap.get(currentPlayer) + 1);\\n          currentPass ++ ;\\n      }\\n       int[] losersArray = new int[playerTurnHashmap.size()];\\n      \\n      for(Map.Entry<Integer,Integer> entry : playerTurnHashmap.entrySet()) {\\n          if (entry.getValue() == 0 ) {\\n              losersArray[j++] = entry.getKey() + 1;\\n          }\\n      } \\n    return  losersArray = Arrays.copyOfRange(losersArray, 0, j );\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544822,
                "title": "c-easy-and-readable-solution-less-than-87",
                "content": "![image.png](https://assets.leetcode.com/users/images/f4742bc2-a302-40de-983f-3229e1d07f0e_1684584515.91254.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int current = 0;\\n        HashSet<int> visited = new() {current};\\n        int turn = 1;\\n        while (true)\\n        {\\n            current = (current + k * turn) % n;\\n            if (visited.Contains(current))\\n                break;\\n            visited.Add(current);\\n            turn++;\\n        }\\n        int[] losers = new int[n - visited.Count];\\n        int index = 0;\\n        for (int i = 0; i < n; i++)\\n            if (!visited.Contains(i))\\n            {\\n                losers[index] = i + 1;\\n                index++;\\n            }\\n        return losers;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int current = 0;\\n        HashSet<int> visited = new() {current};\\n        int turn = 1;\\n        while (true)\\n        {\\n            current = (current + k * turn) % n;\\n            if (visited.Contains(current))\\n                break;\\n            visited.Add(current);\\n            turn++;\\n        }\\n        int[] losers = new int[n - visited.Count];\\n        int index = 0;\\n        for (int i = 0; i < n; i++)\\n            if (!visited.Contains(i))\\n            {\\n                losers[index] = i + 1;\\n                index++;\\n            }\\n        return losers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544775,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> visited = new ArrayList<>();\\n        int[] ans = new int[n];\\n        int friend = 1;\\n        for(int i = 1; i <= n && !visited.contains(friend); i++)\\n        {\\n            int steps = i * k;\\n            visited.add(friend);\\n            friend = (friend + steps)%n;\\n            if(friend == 0)\\n            {\\n                friend = n;\\n            }\\n        }\\n        int z = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(!visited.contains(i))\\n            {\\n                ans[z++] = i;\\n            }\\n        }\\n        return Arrays.copyOfRange(ans, 0, z);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> visited = new ArrayList<>();\\n        int[] ans = new int[n];\\n        int friend = 1;\\n        for(int i = 1; i <= n && !visited.contains(friend); i++)\\n        {\\n            int steps = i * k;\\n            visited.add(friend);\\n            friend = (friend + steps)%n;\\n            if(friend == 0)\\n            {\\n                friend = n;\\n            }\\n        }\\n        int z = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(!visited.contains(i))\\n            {\\n                ans[z++] = i;\\n            }\\n        }\\n        return Arrays.copyOfRange(ans, 0, z);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544323,
                "title": "anurag-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] arr = new boolean[n];\\n        boolean ball = true;\\n        int start = 0;\\n        arr[start] = true;\\n        int turn = 1;\\n        while (ball){\\n            int step = turn*k;\\n            start = (start+step)%n;\\n            turn++;\\n            if (arr[start]){\\n                break;\\n            } else{\\n                arr[start] = true;\\n            }\\n        }\\n\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < n; i++){\\n            if (!arr[i])\\n                res.add(i+1);\\n        }\\n\\n        int[] x = new int[res.size()];\\n        int index = 0;\\n        for (final Integer value: res) {\\n            x[index++] = value;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] arr = new boolean[n];\\n        boolean ball = true;\\n        int start = 0;\\n        arr[start] = true;\\n        int turn = 1;\\n        while (ball){\\n            int step = turn*k;\\n            start = (start+step)%n;\\n            turn++;\\n            if (arr[start]){\\n                break;\\n            } else{\\n                arr[start] = true;\\n            }\\n        }\\n\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < n; i++){\\n            if (!arr[i])\\n                res.add(i+1);\\n        }\\n\\n        int[] x = new int[res.size()];\\n        int index = 0;\\n        for (final Integer value: res) {\\n            x[index++] = value;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544262,
                "title": "java-simple-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n      HashSet<Integer> set = new HashSet<>();\\n\\n        int i=0;\\n        int count=0;\\n    while(true)\\n        {\\n        \\n            i=i+k*count++;\\n            i=i%n;\\n         if(set.contains(i)) break;\\n         else set.add(i);\\n        \\n        }\\n     int[]  result = new int[n-set.size()];\\n     int j=0;\\n        for( i=0;i<n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n               result[j++]=i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n      HashSet<Integer> set = new HashSet<>();\\n\\n        int i=0;\\n        int count=0;\\n    while(true)\\n        {\\n        \\n            i=i+k*count++;\\n            i=i%n;\\n         if(set.contains(i)) break;\\n         else set.add(i);\\n        \\n        }\\n     int[]  result = new int[n-set.size()];\\n     int j=0;\\n        for( i=0;i<n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n               result[j++]=i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543633,
                "title": "easy-c-solution-using-brute-force-approach-100-working-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to continue the game untill anyone gets the ball for the second time.\\nwe keep a visited array of size n+1 for tracking the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe move forward in the circular setup as give in the question.\\nhave to keep in check the modular addition as we might cross the end of the circle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v;\\n        vector<int> visited(n+1,0);\\n        int i = 1;\\n        int temp = 1;\\n        while(visited[i]!=1)\\n        {\\n            visited[i] = 1;\\n            i += (temp*k);\\n            i %= n;\\n            if(i==0)\\n            {\\n                i=n;\\n            }\\n            temp++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v;\\n        vector<int> visited(n+1,0);\\n        int i = 1;\\n        int temp = 1;\\n        while(visited[i]!=1)\\n        {\\n            visited[i] = 1;\\n            i += (temp*k);\\n            i %= n;\\n            if(i==0)\\n            {\\n                i=n;\\n            }\\n            temp++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542345,
                "title": "simple-c-solution-faster-than-94-5",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        int i=1,value=1;\\n        vector<int> v(n+1),res;\\n        v[1]=1;\\n        while(1)\\n        {\\n            int a=((i*k)+value)%n;\\n            if(a==0)\\n            {\\n                v[n]++;\\n                if(v[n]>1) break;\\n            }\\n            else\\n            {\\n                v[a]++;\\n                if(v[a]>1) break;\\n            }\\n            i++;\\n            value=a;\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(v[i]==0) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        int i=1,value=1;\\n        vector<int> v(n+1),res;\\n        v[1]=1;\\n        while(1)\\n        {\\n            int a=((i*k)+value)%n;\\n            if(a==0)\\n            {\\n                v[n]++;\\n                if(v[n]>1) break;\\n            }\\n            else\\n            {\\n                v[a]++;\\n                if(v[a]>1) break;\\n            }\\n            i++;\\n            value=a;\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(v[i]==0) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540181,
                "title": "python-solution",
                "content": "```Python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        i = cur = 1\\n        nums = set(range(1, n + 1))\\n        while cur in nums:\\n            nums.remove(cur)\\n            cur = (k * i + cur) % n\\n            if cur == 0:\\n                cur = n\\n            i += 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        i = cur = 1\\n        nums = set(range(1, n + 1))\\n        while cur in nums:\\n            nums.remove(cur)\\n            cur = (k * i + cur) % n\\n            if cur == 0:\\n                cur = n\\n            i += 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539837,
                "title": "simple-hashing-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int> vec(n+1,0);\\n        int i=0;\\n        int j=1;\\n        while(vec[i]==0){\\n          \\n            vec[i]=1;\\n            i=(i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;++i){\\n            if(vec[i]==0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int> vec(n+1,0);\\n        int i=0;\\n        int j=1;\\n        while(vec[i]==0){\\n          \\n            vec[i]=1;\\n            i=(i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;++i){\\n            if(vec[i]==0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539621,
                "title": "c-visited-array-solution-89ms-97",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) \\n    {\\n        var visited = new bool[n];\\n\\n        var current = 0;\\n\\n        var step = 1;\\n\\n        do\\n        {\\n            visited[current] = true;\\n\\n            current = (current + step * k) % n;\\n\\n            step++;\\n        }\\n        while(!visited[current]);\\n\\n        var r = new List<int>(n);\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            if(!visited[i]) r.Add(i+1);\\n        }\\n\\n        return r.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) \\n    {\\n        var visited = new bool[n];\\n\\n        var current = 0;\\n\\n        var step = 1;\\n\\n        do\\n        {\\n            visited[current] = true;\\n\\n            current = (current + step * k) % n;\\n\\n            step++;\\n        }\\n        while(!visited[current]);\\n\\n        var r = new List<int>(n);\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            if(!visited[i]) r.Add(i+1);\\n        }\\n\\n        return r.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539443,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>vis(n,0);\\n        int curr=0;\\n        int steps=1;\\n        int counter=1;\\n        vis[curr]=1;\\n\\n        steps=k*counter;\\n        curr=curr+steps;\\n        while(vis[curr%n]!=1){\\n            vis[curr%n]=1;\\n            counter++;\\n            steps=counter*k;\\n            curr=curr+steps;\\n            \\n\\n        }        \\n    \\n    \\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        if(vis[i]==0){\\n            ans.push_back(i+1);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n// step=4 \\n// curr=4;\\n// k=2\\n// counter=2;\\n\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>vis(n,0);\\n        int curr=0;\\n        int steps=1;\\n        int counter=1;\\n        vis[curr]=1;\\n\\n        steps=k*counter;\\n        curr=curr+steps;\\n        while(vis[curr%n]!=1){\\n            vis[curr%n]=1;\\n            counter++;\\n            steps=counter*k;\\n            curr=curr+steps;\\n            \\n\\n        }        \\n    \\n    \\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        if(vis[i]==0){\\n            ans.push_back(i+1);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n// step=4 \\n// curr=4;\\n// k=2\\n// counter=2;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538651,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let n = n as usize;\\n        let mut step = k;\\n        \\n        let mut visited = vec![false; n];\\n        let mut i = 0;\\n        \\n        while visited[i] == false {\\n            visited[i] = true;\\n            i = (i + step) % n;\\n            step += k;\\n        }\\n        \\n        visited\\n         .into_iter()\\n         .enumerate()\\n         .filter(|&(i, x)| x == false)\\n         .map(|(i, x)| i as i32 + 1)\\n         .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let n = n as usize;\\n        let mut step = k;\\n        \\n        let mut visited = vec![false; n];\\n        let mut i = 0;\\n        \\n        while visited[i] == false {\\n            visited[i] = true;\\n            i = (i + step) % n;\\n            step += k;\\n        }\\n        \\n        visited\\n         .into_iter()\\n         .enumerate()\\n         .filter(|&(i, x)| x == false)\\n         .map(|(i, x)| i as i32 + 1)\\n         .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538170,
                "title": "java-simple-solution-boolean-array-marker-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] players = new boolean[n];\\n        int turn = 1;\\n        int index = 0;\\n        while (!players[index]) {\\n            players[index] = true;\\n            index = (index + turn * k) % n;            \\n            turn++;\\n        }\\n\\n        int losersIndex = 0;\\n        int[] losers = new int[n - turn + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (!players[i]) {\\n                losers[losersIndex++] = i + 1;\\n            }\\n        }\\n\\n        return losers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] players = new boolean[n];\\n        int turn = 1;\\n        int index = 0;\\n        while (!players[index]) {\\n            players[index] = true;\\n            index = (index + turn * k) % n;            \\n            turn++;\\n        }\\n\\n        int losersIndex = 0;\\n        int[] losers = new int[n - turn + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (!players[i]) {\\n                losers[losersIndex++] = i + 1;\\n            }\\n        }\\n\\n        return losers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537581,
                "title": "c-easy-to-understand-commented-and-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector to store the no of times ith element occurs\\n        vector<int> v(n, 0);\\n        //result vector\\n        vector<int> res;\\n        int temp = k;\\n        //Current value for the increment offset\\n        int i=1;\\n        //base case i.e, first chance is always of the first person\\n        v[0]++;\\n        //variable that stores which is the current person that have the ball\\n        int currPerson = 0;\\n\\n        //infinte loop that will break when a person reaceaves the ball for the second time\\n        while(1){\\n            int offset = i*k;\\n            //% is done so that we can maintian our calculations for circular loop\\n            currPerson = (currPerson + offset)%n;\\n            v[currPerson]++;\\n            if(v[currPerson]>=2)break;\\n            \\n            i++;\\n        }\\n        // loop to check if the ith person did not receive the ball even a single time\\n        for(int i=0; i<n; i++){\\n            if(v[i]==0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector to store the no of times ith element occurs\\n        vector<int> v(n, 0);\\n        //result vector\\n        vector<int> res;\\n        int temp = k;\\n        //Current value for the increment offset\\n        int i=1;\\n        //base case i.e, first chance is always of the first person\\n        v[0]++;\\n        //variable that stores which is the current person that have the ball\\n        int currPerson = 0;\\n\\n        //infinte loop that will break when a person reaceaves the ball for the second time\\n        while(1){\\n            int offset = i*k;\\n            //% is done so that we can maintian our calculations for circular loop\\n            currPerson = (currPerson + offset)%n;\\n            v[currPerson]++;\\n            if(v[currPerson]>=2)break;\\n            \\n            i++;\\n        }\\n        // loop to check if the ith person did not receive the ball even a single time\\n        for(int i=0; i<n; i++){\\n            if(v[i]==0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535952,
                "title": "day-45-60",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::vector<int> circularGameLosers(int n, int k)\\n    {\\n        std::vector<int> check(n + 1, 0), ans;\\n        int i = 1, steps = 1;\\n        while (true && check[i] != 2)\\n        {\\n            check[i]++;\\n            if(check[i]==2)\\n            {\\n                break;\\n            }\\n            i += (steps * k);\\n            i%=n;\\n            if(i==0)\\n            {\\n                i = n;\\n            }\\n            steps++;\\n        }\\n        i = 1;\\n        while (i < check.size())\\n        {\\n            if (check[i] == 0)\\n            {\\n                ans.push_back(i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::vector<int> circularGameLosers(int n, int k)\\n    {\\n        std::vector<int> check(n + 1, 0), ans;\\n        int i = 1, steps = 1;\\n        while (true && check[i] != 2)\\n        {\\n            check[i]++;\\n            if(check[i]==2)\\n            {\\n                break;\\n            }\\n            i += (steps * k);\\n            i%=n;\\n            if(i==0)\\n            {\\n                i = n;\\n            }\\n            steps++;\\n        }\\n        i = 1;\\n        while (i < check.size())\\n        {\\n            if (check[i] == 0)\\n            {\\n                ans.push_back(i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535912,
                "title": "c-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> friends(n);\\n        int pass = 0, step = 0;\\n        while(!friends[pass]) {\\n            friends[pass] = 1;\\n            pass += step += k;\\n            pass %= n;\\n        }\\n\\n        vector<int> answer;\\n        for(size_t i = 0; i < friends.size(); ++i)\\n            if(!friends[i]) answer.push_back(i+1);\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> friends(n);\\n        int pass = 0, step = 0;\\n        while(!friends[pass]) {\\n            friends[pass] = 1;\\n            pass += step += k;\\n            pass %= n;\\n        }\\n\\n        vector<int> answer;\\n        for(size_t i = 0; i < friends.size(); ++i)\\n            if(!friends[i]) answer.push_back(i+1);\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535892,
                "title": "elixir-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 363ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 62.9MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    check = create_check_map(n, k, 1, 0, %{})\\n    Enum.reduce(1..n-1, [], fn i, ans ->\\n      cond do\\n        Map.get(check, i) == true ->\\n          ans\\n        i + 1 <= n ->\\n          [i + 1 | ans]\\n        true ->\\n          ans\\n      end\\n    end) |> Enum.reverse()\\n  end\\n\\n  @spec create_check_map(n :: integer, k :: integer, i :: integer, pre :: integer, check :: %{}) :: %{}\\n  def create_check_map(n, k, i, pre, check) do\\n    if Map.get(check, pre) == true do\\n      check\\n    else\\n      create_check_map(n, k, i + 1, rem(i*k + pre, n), Map.put(check, pre, true))\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    check = create_check_map(n, k, 1, 0, %{})\\n    Enum.reduce(1..n-1, [], fn i, ans ->\\n      cond do\\n        Map.get(check, i) == true ->\\n          ans\\n        i + 1 <= n ->\\n          [i + 1 | ans]\\n        true ->\\n          ans\\n      end\\n    end) |> Enum.reverse()\\n  end\\n\\n  @spec create_check_map(n :: integer, k :: integer, i :: integer, pre :: integer, check :: %{}) :: %{}\\n  def create_check_map(n, k, i, pre, check) do\\n    if Map.get(check, pre) == true do\\n      check\\n    else\\n      create_check_map(n, k, i + 1, rem(i*k + pre, n), Map.put(check, pre, true))\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3535750,
                "title": "cpp-soln-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        set<int> s;\\n        \\n        for(int i=1;i<=n;i++) s.insert(i);\\n        int i=1,j=0;\\n        \\n        while(s.find(i)!=s.end()){\\n            s.erase(i);\\n            j=j+k;\\n            i=(i+j)%n;\\n            if(i == 0) i = n;\\n            \\n        }\\n        vector<int> v;\\n        for(auto &it:s) v.push_back(it);\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        set<int> s;\\n        \\n        for(int i=1;i<=n;i++) s.insert(i);\\n        int i=1,j=0;\\n        \\n        while(s.find(i)!=s.end()){\\n            s.erase(i);\\n            j=j+k;\\n            i=(i+j)%n;\\n            if(i == 0) i = n;\\n            \\n        }\\n        vector<int> v;\\n        for(auto &it:s) v.push_back(it);\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535252,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int v[] = new int[n], i = 0, tot = n, step = 0;\\n        v[0] = 1;\\n        while(true){\\n          if( (i += (step += k)) >= n) i %= n;\\n          if( v[i] == 0) {--tot; v[i] = 1;}\\n          else break;\\n        }\\n        \\n        int ans[] = new int[tot-1], id = -1;\\n        for(int j = 0; j != n; ++j)\\n          if(v[j] == 0) ans[++id] = j+1;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int v[] = new int[n], i = 0, tot = n, step = 0;\\n        v[0] = 1;\\n        while(true){\\n          if( (i += (step += k)) >= n) i %= n;\\n          if( v[i] == 0) {--tot; v[i] = 1;}\\n          else break;\\n        }\\n        \\n        int ans[] = new int[tot-1], id = -1;\\n        for(int j = 0; j != n; ++j)\\n          if(v[j] == 0) ans[++id] = j+1;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535212,
                "title": "favourable-easy-beginner-friendly-approach-can-get-it-just-by-seeing-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> store;\\n        map<int,int> data;\\n        for(int x=1;x<=n;x++)\\n        {\\n            store.push_back(x);\\n            data[x]++;\\n        }\\n        int i=0,c=0;\\n        while(data[store[i]]==1)\\n        {\\n            data[store[i]]++;\\n            c++;\\n            i=(i+(c*k))%n;\\n        }\\n        store.clear();\\n        for(auto x:data)\\n        {\\n            if(x.second==1)\\n            {\\n                store.push_back(x.first);\\n            }\\n        }\\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> store;\\n        map<int,int> data;\\n        for(int x=1;x<=n;x++)\\n        {\\n            store.push_back(x);\\n            data[x]++;\\n        }\\n        int i=0,c=0;\\n        while(data[store[i]]==1)\\n        {\\n            data[store[i]]++;\\n            c++;\\n            i=(i+(c*k))%n;\\n        }\\n        store.clear();\\n        for(auto x:data)\\n        {\\n            if(x.second==1)\\n            {\\n                store.push_back(x.first);\\n            }\\n        }\\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535054,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        int c=1;\\n        int i=1;\\n        while(true)\\n        {\\n            if(st.find(c)!=st.end())\\n            {\\n                break;\\n            }\\n            st.insert(c);\\n            c=(c+(i*k));\\n            if(c>n){\\n                if(c%n==0)\\n                {\\n                    c=n;\\n                }\\n                else\\n                {\\n                    c=c%n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        int c=1;\\n        int i=1;\\n        while(true)\\n        {\\n            if(st.find(c)!=st.end())\\n            {\\n                break;\\n            }\\n            st.insert(c);\\n            c=(c+(i*k));\\n            if(c>n){\\n                if(c%n==0)\\n                {\\n                    c=n;\\n                }\\n                else\\n                {\\n                    c=c%n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534706,
                "title": "java-sollution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int arr[] = new int[n];\\n        Set<Integer> st = new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = i+1;\\n            \\n        }\\n        \\n        boolean barr[] = new boolean[n];\\n        barr[0] = true;\\n        int index =0;\\n        int multiplier = 1;\\n\\n        while(!st.contains(index))\\n        {\\n            st.add(index);\\n            System.out.println((index+multiplier*k)%n);\\n            barr[(index+multiplier*k)%n] =true;\\n            index = (index+multiplier*k)%n;\\n            System.out.println(\"index\"+index);\\n            multiplier++;\\n            \\n           \\n        }\\n        \\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(barr[i]==false)\\n            {\\n                ansList.add(i+1);\\n            }\\n        }\\n    \\n        return ansList.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int arr[] = new int[n];\\n        Set<Integer> st = new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = i+1;\\n            \\n        }\\n        \\n        boolean barr[] = new boolean[n];\\n        barr[0] = true;\\n        int index =0;\\n        int multiplier = 1;\\n\\n        while(!st.contains(index))\\n        {\\n            st.add(index);\\n            System.out.println((index+multiplier*k)%n);\\n            barr[(index+multiplier*k)%n] =true;\\n            index = (index+multiplier*k)%n;\\n            System.out.println(\"index\"+index);\\n            multiplier++;\\n            \\n           \\n        }\\n        \\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(barr[i]==false)\\n            {\\n                ansList.add(i+1);\\n            }\\n        }\\n    \\n        return ansList.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533563,
                "title": "find-the-losers-of-the-circular-game-with-set",
                "content": "# Code\\n```\\n\\'use strict\\';\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nconst circularGameLosers = function(n, k) {\\n    const set = new Set([...Array(n)].map((el, i) => i + 1));\\n    let i = 1;\\n    let val = 1;\\n    while (set.has(val)) {\\n        set.delete(val);\\n        if ((val + i * k) % n === 0) {\\n            val = n;\\n        } else {\\n            val = (val + i * k) % n;\\n        }\\n        i++;\\n    }\\n    return [...set];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n\\'use strict\\';\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nconst circularGameLosers = function(n, k) {\\n    const set = new Set([...Array(n)].map((el, i) => i + 1));\\n    let i = 1;\\n    let val = 1;\\n    while (set.has(val)) {\\n        set.delete(val);\\n        if ((val + i * k) % n === 0) {\\n            val = n;\\n        } else {\\n            val = (val + i * k) % n;\\n        }\\n        i++;\\n    }\\n    return [...set];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533374,
                "title": "easy-c-solution-o-n-modular-approach",
                "content": "\\n# Approach\\n- Initiate a boolean vector of size \\'n\\' and all entries as false \\n- While iterating through the vector, if flag == true, break the loop\\n- else keep on marking the indexes as true\\n- update the current index as $$currIndex = (currIndex+i*k)%n$$\\n- whenever we encounter an index with flag == true, we exit the loop and call the gameOverNow() function which populates the answer array\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> gameOverNow( vector<bool> flagArray, int n){\\n        vector<int> loserArr;\\n        for(int i = 0; i< n; i++){\\n            if(flagArray[i]==false)loserArr.push_back(i+1);\\n        }\\n        return loserArr;\\n    }\\n    \\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool> flagArray(n,false);\\n        int currIndex = 0;\\n        flagArray[currIndex] = true;\\n        int i = 1;\\n        while(true){\\n            currIndex = (currIndex+i*k)%n;\\n            if(flagArray[currIndex] == false){\\n                flagArray[currIndex] = true;\\n                i++;\\n            }\\n            else break;\\n        }\\n        return gameOverNow(flagArray, n);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> gameOverNow( vector<bool> flagArray, int n){\\n        vector<int> loserArr;\\n        for(int i = 0; i< n; i++){\\n            if(flagArray[i]==false)loserArr.push_back(i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3532818,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var count = new int[n + 1];\\n        var list = new List<int>();\\n        var cur = 1;\\n        var steps = 1;\\n        count[cur]++;\\n        \\n        while(true){\\n            cur = cur + steps * k;\\n            while( cur > n)\\n                cur -= n;\\n            count[cur]++;\\n            if(count[cur] == 2)\\n                break; \\n            steps++;\\n        }\\n\\n        for(var i = 1; i < count.Length; i++){\\n            if(count[i] == 0)\\n                list.Add(i);\\n        }\\n\\n        return list.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var count = new int[n + 1];\\n        var list = new List<int>();\\n        var cur = 1;\\n        var steps = 1;\\n        count[cur]++;\\n        \\n        while(true){\\n            cur = cur + steps * k;\\n            while( cur > n)\\n                cur -= n;\\n            count[cur]++;\\n            if(count[cur] == 2)\\n                break; \\n            steps++;\\n        }\\n\\n        for(var i = 1; i < count.Length; i++){\\n            if(count[i] == 0)\\n                list.Add(i);\\n        }\\n\\n        return list.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532618,
                "title": "c-simulation-with-hashset-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `var set = new HashSet<int>();` Used to track visited players\\n- `x` - Multiplier, `k*x, k*(x+1)...`\\n- `curPlayer` Current player, use 0 indexed to `0...n-1`. Insted `1...N`, to correctly identify player position in circle. If `n=4`, players=[0,1,2]. correct `pos = (curPlayer)%4`\\n- `var res = new List<int>();` Store result, and finally put players with `index + 1`, because initial requirements by `1...n` players\\n\\n\\n# Complexity\\n- Time complexity: As players size is small up to `50`, In worst case think that every playes visits only ones:$$O(n)$$, where `n = 50`  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$, where `n = players size`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var set = new HashSet<int>();\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!set.Contains(curPlayer)) {\\n            set.Add(curPlayer);\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!set.Contains(i)) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n\\n```\\n\\n# The same solution with Array\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var arr = new bool[n];\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!arr[curPlayer]) {\\n            arr[curPlayer] = true;\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!arr[i]) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var set = new HashSet<int>();\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!set.Contains(curPlayer)) {\\n            set.Add(curPlayer);\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!set.Contains(i)) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var arr = new bool[n];\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!arr[curPlayer]) {\\n            arr[curPlayer] = true;\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!arr[i]) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532547,
                "title": "98-beats-easy-to-understand-simplest-by-using-queue-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple just push all the element from 2 to n and then push -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        queue<int>q;\\n        vector<int>v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        q.push(-1);\\n        /*while(!q.empty())\\n        {\\n            cout<<q.front()<<\" \";q.pop();\\n        }*/\\n        int a=1;\\n        while(1)\\n        {\\n           int k1=k*a-1;\\n           while(k1--)\\n           {\\n               int a=q.front();\\n              //cout<<a<<\" \";\\n               q.pop();q.push(a);\\n           }\\n         //  cout<<endl;\\n           if(q.front()==-1)\\n           {\\n               break;\\n           }\\n           else\\n           {\\n           cout<<q.front()<<\" \";\\n           q.pop();q.push(-1);\\n           a++;\\n           }\\n        }\\n        while(!q.empty())\\n        {   \\n            if(q.front()!=-1)\\n            {\\n            v.push_back(q.front());q.pop();\\n            }\\n            else\\n            {\\n            q.pop();\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        queue<int>q;\\n        vector<int>v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        q.push(-1);\\n        /*while(!q.empty())\\n        {\\n            cout<<q.front()<<\" \";q.pop();\\n        }*/\\n        int a=1;\\n        while(1)\\n        {\\n           int k1=k*a-1;\\n           while(k1--)\\n           {\\n               int a=q.front();\\n              //cout<<a<<\" \";\\n               q.pop();q.push(a);\\n           }\\n         //  cout<<endl;\\n           if(q.front()==-1)\\n           {\\n               break;\\n           }\\n           else\\n           {\\n           cout<<q.front()<<\" \";\\n           q.pop();q.push(-1);\\n           a++;\\n           }\\n        }\\n        while(!q.empty())\\n        {   \\n            if(q.front()!=-1)\\n            {\\n            v.push_back(q.front());q.pop();\\n            }\\n            else\\n            {\\n            q.pop();\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3532240,
                "title": "python-easy-solution-runtime-beats-94-56",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        step = 1\\n        distance = k\\n        receive_list = [1]  # first receive friend\\n        nums = [num for num in range(1, n+1)]\\n        while nums[k % n] not in receive_list:\\n            receive_list.append(nums[k % n])\\n            step += 1\\n            k += step * distance \\n        return sorted(list(set(nums) - set(receive_list)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        step = 1\\n        distance = k\\n        receive_list = [1]  # first receive friend\\n        nums = [num for num in range(1, n+1)]\\n        while nums[k % n] not in receive_list:\\n            receive_list.append(nums[k % n])\\n            step += 1\\n            k += step * distance \\n        return sorted(list(set(nums) - set(receive_list)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531681,
                "title": "swift-easy-to-understand-solution-using-array-and-while-loop",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        // Store if friend touched ball or not:\\n        // didTouchBall[i] means friend[i+1] has touched ball:\\n        var didTouchBall = Array(repeating: false, count: n)\\n\\n        var hasBallIndex = 0 // index for friend who has ball\\n        var passCount = 1 // times ball has been passed\\n\\n        // Repeat until one friend receives ball a second time:\\n        while didTouchBall[hasBallIndex] != true {\\n            didTouchBall[hasBallIndex] = true // Set friend at hasBallIndex in didTouchBall to true (touched ball)\\n            hasBallIndex = ((passCount * k) + hasBallIndex) % n  // pass ball to next friend using modulo n\\n            passCount += 1 // increment pass count\\n        }\\n\\n        // Loop finished, which means one friend has touch the ball twice:\\n        var result = [Int]()\\n\\n        // Iterate through didTouchBall and add any friend \\n        // who did not touch the ball (false) to result array.\\n        // Since we are iterating in ascending order, the result\\n        // array will be in ascending order:\\n        for index in 0..<didTouchBall.count {\\n            if !didTouchBall[index] {\\n                // Friend did not touch ball.\\n                // Add their index + 1 to result:\\n                result.append(index+1) // +1 because we started at zero\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        // Store if friend touched ball or not:\\n        // didTouchBall[i] means friend[i+1] has touched ball:\\n        var didTouchBall = Array(repeating: false, count: n)\\n\\n        var hasBallIndex = 0 // index for friend who has ball\\n        var passCount = 1 // times ball has been passed\\n\\n        // Repeat until one friend receives ball a second time:\\n        while didTouchBall[hasBallIndex] != true {\\n            didTouchBall[hasBallIndex] = true // Set friend at hasBallIndex in didTouchBall to true (touched ball)\\n            hasBallIndex = ((passCount * k) + hasBallIndex) % n  // pass ball to next friend using modulo n\\n            passCount += 1 // increment pass count\\n        }\\n\\n        // Loop finished, which means one friend has touch the ball twice:\\n        var result = [Int]()\\n\\n        // Iterate through didTouchBall and add any friend \\n        // who did not touch the ball (false) to result array.\\n        // Since we are iterating in ascending order, the result\\n        // array will be in ascending order:\\n        for index in 0..<didTouchBall.count {\\n            if !didTouchBall[index] {\\n                // Friend did not touch ball.\\n                // Add their index + 1 to result:\\n                result.append(index+1) // +1 because we started at zero\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531410,
                "title": "mark-the-friends-if-its-their-turn-map-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v,ans;\\n        unordered_map<int,int>m;\\n        for(int i=1; i<=n; i++) v.push_back(i);\\n        \\n        int x=1;\\n        int Friend = 0;\\n        \\n        while(1){\\n            m[Friend]++;\\n            cout<<v[Friend]<<endl;\\n            if(m[Friend] >= 2) break;\\n            Friend = ((x*k)+Friend)%n;\\n            x++;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(m[i]==0) ans.push_back(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v,ans;\\n        unordered_map<int,int>m;\\n        for(int i=1; i<=n; i++) v.push_back(i);\\n        \\n        int x=1;\\n        int Friend = 0;\\n        \\n        while(1){\\n            m[Friend]++;\\n            cout<<v[Friend]<<endl;\\n            if(m[Friend] >= 2) break;\\n            Friend = ((x*k)+Friend)%n;\\n            x++;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(m[i]==0) ans.push_back(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3530920,
                "title": "a-few-solutions",
                "content": "Perform the simulation of `i`<sup>th</sup> friends, tracking `seen` values in an unordered set for O(1) lookups, then return the 1-based index of *not* seen values `i = 0..N-1` inclusive.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun circularGameLosers(N: Int, K: Int): IntArray {\\n        var (seen, i, step) = Triple(mutableSetOf<Int>(), 0, 0)\\n        while (!seen.contains(i)) {\\n            seen.add(i); step += K; i = (i + step) % N\\n        }\\n        return (0 until N).filter{ !seen.contains(it) }.map{ it + 1 }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet circularGameLosers = (N, K, seen = new Set(), i = 0, step = 0) => {\\n    while (!seen.has(i))\\n        seen.add(i), step += K, i = (i + step) % N;\\n    return _.range(0, N).filter(i => !seen.has(i)).map(i => i + 1);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def circularGameLosers(self, N: int, K: int) -> List[int]:\\n        seen, i, step = set(), 0, 0\\n        while i not in seen:\\n            seen.add(i); step += K; i = (i + step) % N\\n        return [i + 1 for i in range(N) if i not in seen]\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn circular_game_losers(N: i32, K: i32) -> VI {\\n        let (mut seen, mut i, mut step) = (HashSet::new(), 0, 0);\\n        while !seen.contains(&i) {\\n            seen.insert(i); step += K; i = (i + step) % N;\\n        }\\n        (0..N).filter(|i| !seen.contains(&i)).map(|i| i + 1).collect::<VI>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    VI circularGameLosers(int N, int K, Set seen = Set(), int i = 0, int step = 0, VI losers = {}) {\\n        while (seen.insert(i).second)\\n            step += K, i = (i + step) % N;\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (seen.find(i) == seen.end())\\n                losers.push_back(i + 1);\\n        return losers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(N: Int, K: Int): IntArray {\\n        var (seen, i, step) = Triple(mutableSetOf<Int>(), 0, 0)\\n        while (!seen.contains(i)) {\\n            seen.add(i); step += K; i = (i + step) % N\\n        }\\n        return (0 until N).filter{ !seen.contains(it) }.map{ it + 1 }.toIntArray()\\n    }\\n}\\n```\n```\\nlet circularGameLosers = (N, K, seen = new Set(), i = 0, step = 0) => {\\n    while (!seen.has(i))\\n        seen.add(i), step += K, i = (i + step) % N;\\n    return _.range(0, N).filter(i => !seen.has(i)).map(i => i + 1);\\n};\\n```\n```\\nclass Solution:\\n    def circularGameLosers(self, N: int, K: int) -> List[int]:\\n        seen, i, step = set(), 0, 0\\n        while i not in seen:\\n            seen.add(i); step += K; i = (i + step) % N\\n        return [i + 1 for i in range(N) if i not in seen]\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn circular_game_losers(N: i32, K: i32) -> VI {\\n        let (mut seen, mut i, mut step) = (HashSet::new(), 0, 0);\\n        while !seen.contains(&i) {\\n            seen.insert(i); step += K; i = (i + step) % N;\\n        }\\n        (0..N).filter(|i| !seen.contains(&i)).map(|i| i + 1).collect::<VI>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    VI circularGameLosers(int N, int K, Set seen = Set(), int i = 0, int step = 0, VI losers = {}) {\\n        while (seen.insert(i).second)\\n            step += K, i = (i + step) % N;\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (seen.find(i) == seen.end())\\n                losers.push_back(i + 1);\\n        return losers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530722,
                "title": "simple-iterative-hashset-and-arraylist-java-solution-no-recursion",
                "content": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=1;\\n        int turn=1;\\n        HashSet<Integer> set = new HashSet();\\n        while(!set.contains(i) && i<=n){\\n            \\n            set.add(i);\\n            i=i+(k*turn);\\n            \\n            turn++;\\n            if(i>n){\\n                i=i%n;\\n                if(i==0){\\n                    i=n;\\n                }\\n            }\\n            \\n        }\\n       \\n        ArrayList<Integer> list = new ArrayList();\\n        for(int j=1;j<=n;j++){\\n            if(!set.contains(j)){\\n                list.add(j);\\n            }\\n        }\\n        int[] ans = new int[list.size()];\\n        for(int x=0;x<ans.length;x++){\\n            ans[x]=list.get(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=1;\\n        int turn=1;\\n        HashSet<Integer> set = new HashSet();\\n        while(!set.contains(i) && i<=n){\\n            \\n            set.add(i);\\n            i=i+(k*turn);\\n            \\n            turn++;\\n            if(i>n){\\n                i=i%n;\\n                if(i==0){\\n                    i=n;\\n                }\\n            }\\n            \\n        }\\n       \\n        ArrayList<Integer> list = new ArrayList();\\n        for(int j=1;j<=n;j++){\\n            if(!set.contains(j)){\\n                list.add(j);\\n            }\\n        }\\n        int[] ans = new int[list.size()];\\n        for(int x=0;x<ans.length;x++){\\n            ans[x]=list.get(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530286,
                "title": "circulargamelosers-python-86-69-runtime-98-99-space",
                "content": "# Approach\\nWe can create an array with the friends, and simulate the game. \\n\\nEvery time a new player has the ball, we set its value to `-1`, as this player won\\'t lose the game.\\n\\nWe need to know which player receives the ball next by calculating `(ball + step) mod n`\\n\\nOnce a friend has had the ball twice (the current player value is `-1`), the game finishes.\\n\\nWe return the friends that still have their number.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(n)]\\n\\n        ball = 0\\n        step = k\\n        while (friends[ball] != -1):\\n            friends[ball] = -1\\n            ball = (ball + step) % n\\n            step += k\\n\\n        res = []\\n        for f in friends:\\n            if f >= 0:\\n                res.append(f+1)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(n)]\\n\\n        ball = 0\\n        step = k\\n        while (friends[ball] != -1):\\n            friends[ball] = -1\\n            ball = (ball + step) % n\\n            step += k\\n\\n        res = []\\n        for f in friends:\\n            if f >= 0:\\n                res.append(f+1)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529741,
                "title": "scala-set-and-recursion",
                "content": "\\n# Code\\n```\\nobject Solution {\\n  def circularGameLosers(n: Int, k: Int): Array[Int] = {\\n    def go(seen: Set[Int], i: Int, step: Int): Array[Int] = \\n      if (seen.contains(i)) (0 until n).filter(!seen.contains(_)).map(_ + 1).toArray\\n      else go(seen + i, (i + k * step) % n, step + 1)\\n\\n    go(Set.empty, 0, 1)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def circularGameLosers(n: Int, k: Int): Array[Int] = {\\n    def go(seen: Set[Int], i: Int, step: Int): Array[Int] = \\n      if (seen.contains(i)) (0 until n).filter(!seen.contains(_)).map(_ + 1).toArray\\n      else go(seen + i, (i + k * step) % n, step + 1)\\n\\n    go(Set.empty, 0, 1)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1893637,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 2025836,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1893131,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1894724,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1894028,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            }
        ]
    }
]