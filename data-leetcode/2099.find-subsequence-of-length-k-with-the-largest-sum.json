[
    {
        "title": "Find Subsequence of Length K With the Largest Sum",
        "question_content": "You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.\nReturn any such subsequence as an integer array of length k.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,3,3], k = 2\nOutput: [3,3]\nExplanation:\nThe subsequence has the largest sum of 3 + 3 = 6.\nExample 2:\n\nInput: nums = [-1,-2,3,4], k = 3\nOutput: [-1,3,4]\nExplanation: \nThe subsequence has the largest sum of -1 + 3 + 4 = 6.\n\nExample 3:\n\nInput: nums = [3,4,3,3], k = 2\nOutput: [3,4]\nExplanation:\nThe subsequence has the largest sum of 3 + 4 = 7. \nAnother possible subsequence is [4, 3].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t-105&nbsp;<= nums[i] <= 105\n\t1 <= k <= nums.length",
        "solutions": [
            {
                "id": 1623447,
                "title": "simple-c-solution-runtime-15-ms-faster-than-61-54-memory-usage-9-1-mb-less-than-100-00",
                "content": "As in the Problem itself we are give an array and we have to return the sub-array of size k whose sum is maximum.\\nWe can do this in a very simple way and without using any extra space or sorting it.\\n* Step -1 -> Create an ans vector to return and store first k elements in that\\n* Step -2 -> Loop through the remaining array\\n* Step -3 -> At each step calculate the index of minimum element in the ans array and compare it with the current element.\\n* Step -4 -> if element is greater then minimum element then remove minimum from ans and add the greater element.\\n* Step -5 -> Repeat step 3 and 4 till last element.\\n* Finally we have required sub sequence.\\n\\n### Below is the code Given [c++]\\n```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\t// Declare variables\\n        int n = nums.size(), i = 0, t = k;\\n\\t\\t// Answer Array\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// Put first k elements\\n        while(t>0){\\n            ans.push_back(nums[i]);\\n            i++;\\n            t--;\\n        }\\n\\t\\t\\n\\t\\t//Loop Through Remaining Array\\n        for(int j=i;j<n;j++)\\n        {\\n\\t\\t\\t// Calcualate minimum from ans array \\n            int mini = min_element(ans.begin(), ans.end()) - ans.begin();\\n\\t\\t\\t// Comapre it with the current element\\n            if(ans[mini] < nums[j]){\\n                ans.erase(ans.begin()+mini);\\n                ans.push_back(nums[j]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```\\nTime Complexity - O(n*k)\\nSpace Complexity - O(1)\\n\\n##### if You like my solution please Upvote it.[This is my first post \\uD83D\\uDE00]\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\t// Declare variables\\n        int n = nums.size(), i = 0, t = k;\\n\\t\\t// Answer Array\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// Put first k elements\\n        while(t>0){\\n            ans.push_back(nums[i]);\\n            i++;\\n            t--;\\n        }\\n\\t\\t\\n\\t\\t//Loop Through Remaining Array\\n        for(int j=i;j<n;j++)\\n        {\\n\\t\\t\\t// Calcualate minimum from ans array \\n            int mini = min_element(ans.begin(), ans.end()) - ans.begin();\\n\\t\\t\\t// Comapre it with the current element\\n            if(ans[mini] < nums[j]){\\n                ans.erase(ans.begin()+mini);\\n                ans.push_back(nums[j]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623436,
                "title": "java-python-3-from-o-n-logn-to-average-o-n-w-brief-explanation-and-analysis",
                "content": "**Method 1: Sort**\\n\\n*Sort the whole array*\\n1. Combine each index with its corresponding value to create a 2-d array;\\n2. Sort the 2-d array reversely by value, then copy the largest k ones;\\n3. Sort the largest k ones by index, then return the corresponding values by index order.\\n\\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] indexAndVal = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            indexAndVal[i] = new int[]{i, nums[i]};\\n        }\\n        // Reversely sort by value.\\n        Arrays.sort(indexAndVal, Comparator.comparingInt(a -> -a[1]));\\n        int[][] maxK = Arrays.copyOf(indexAndVal, k);\\n        // Sort by index.\\n        Arrays.sort(maxK, Comparator.comparingInt(a -> a[0]));\\n        int[] seq = new int[k];\\n        for (int i = 0; i < k; ++i) {\\n            seq[i] = maxK[i][1];\\n        }\\n        return seq;\\n    }\\n```\\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        val_and_index = sorted([(num, i) for i, num in enumerate(nums)])\\n        return [num for num, i in sorted(val_and_index[-k :], key=lambda x: x[1])]\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n * logn)`, space: `O(n)`.\\n\\n----\\n\\n**Method 2: PriorityQueue/heap**\\n\\n**Two Passes**\\n\\n1. Travse input and use PriorityQueue / heap to store `k` largest items, poll out if its size bigger than `k`;\\n2. Use Map/dict to store the `k` items in 1.;\\n3. Traverse input again, if encounter any item in the afore-mentioned Map/ dict, save it into the output array, then remove the item from the Map/dict.\\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k + 1);\\n        for (int n : nums) {\\n            pq.offer(n);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int n : pq) {\\n            freq.merge(n, 1, Integer::sum);\\n        }\\n        int[] seq = new int[k]; \\n        int i = 0;\\n        for (int n : nums) {\\n            if (freq.merge(n, -1, Integer::sum) >= 0) {\\n                seq[i++] = n;\\n            }\\n        }\\n        return seq;\\n    }\\n```\\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        heap = []\\n        for n in nums:\\n            heapq.heappush(heap, n)\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n        cnt = Counter(heap)\\n        res = []\\n        for n in nums:\\n            if cnt[n] > 0:\\n                cnt[n] -= 1\\n                res.append(n)\\n        return res\\n```\\n\\n----\\n\\n*Simplified the above to **One pass*** - credit to **@climberig**\\n\\nStore indexes of the input array by PriorityQueue/heap, and get rid of Map/dict.\\n\\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>\\n                    (Comparator.comparingInt(i -> nums[i]));\\n        for (int i = 0; i < nums.length; ++i) {\\n            pq.offer(i);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        return pq.stream().sorted().mapToInt(i -> nums[i]).toArray();\\n    }\\n```\\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        heap = []\\n        for i, n in enumerate(nums):\\n            heapq.heappush(heap, (n, i))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n        return [a[0] for a in sorted(heap, key=lambda x: x[1])] \\n```\\n\\nTime: `O(n * logk)`, space: `O(k)`\\n\\n----\\n\\n**Method 3: Quick Select**\\n\\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] index = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            index[i] = i;\\n        }\\n        \\n        // Use Quick Select to put the indexes of the \\n        // max k items to the left of index array. \\n        int lo = 0, hi = n - 1;\\n        while (lo < hi) {\\n            int idx = quickSelect(nums, index, lo, hi);\\n            if (idx < k) {\\n                lo = idx + 1;\\n            }else {\\n                hi = idx;\\n            }\\n        }\\n        \\n        // Count the occurrencs of the kth largest items\\n        // within the k largest ones.\\n        int kthVal = nums[index[k - 1]], freqOfkthVal = 0;\\n        for (int i : Arrays.copyOf(index, k)) {\\n            freqOfkthVal += nums[i] == kthVal ? 1 : 0;\\n        }\\n        \\n        // Greedily copy the subsequence into output array seq.\\n        int[] seq = new int[k];\\n        int i = 0;\\n        for (int num : nums) {\\n            if (num > kthVal || num == kthVal && freqOfkthVal-- > 0) {\\n                seq[i++] = num;\\n            }\\n        }\\n        return seq;\\n    }\\n    \\n    // Divide index[lo...hi] into two parts: larger and less than \\n    // the pivot; Then return the position of the pivot;\\n    private int quickSelect(int[] nums, int[] index, int lo, int hi) {\\n        int pivot = index[lo];\\n        while (lo < hi) {\\n            while (lo < hi && nums[index[hi]] <= nums[pivot]) {\\n                --hi;\\n            }\\n            index[lo] = index[hi];\\n            while (lo < hi && nums[index[lo]] >= nums[pivot]) {\\n                ++lo;\\n            }\\n            index[hi] = index[lo];\\n        } \\n        index[lo] = pivot;\\n        return lo;\\n    }\\n```\\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        # Divide index[lo...hi] into two parts: larger and less than \\n        # the pivot; Then return the position of the pivot;\\n        def quickSelect(lo: int, hi: int) -> int:\\n            pivot = index[lo]\\n            while lo < hi:\\n                while lo < hi and nums[index[hi]] <= nums[pivot]:\\n                    hi -= 1\\n                index[lo] = index[hi]\\n                while lo < hi and nums[index[lo]] >= nums[pivot]:\\n                    lo += 1\\n                index[hi] = index[lo]\\n            index[lo] = pivot\\n            return lo\\n\\n        n = len(nums)\\n        index = list(range(n))\\n        \\n        # Use Quick Select to put the indexes of the \\n        # max k items to the left of index array.\\n        left, right = 0, n - 1\\n        while left < right:\\n            idx = quickSelect(left, right)\\n            if idx < k:\\n                left = idx + 1\\n            else:\\n                right = idx\\n        \\n        # Count the occurrencs of the kth largest items\\n        # within the k largest ones.\\n        kth_val, freq_of_kth_val = nums[index[k - 1]], 0\\n        for i in index[ : k]:\\n            if nums[i] == kth_val:\\n                freq_of_kth_val += 1\\n                \\n        # Greedily copy the subsequence into output array seq.\\n        seq = []\\n        for num in nums:\\n            if num > kth_val or num == kth_val and freq_of_kth_val > 0:\\n                seq.append(num)\\n                if num == kth_val:\\n                    freq_of_kth_val -= 1\\n        return seq\\n```\\nTime: average `O(n)`, worst `O(n ^ 2)`, space: `O(n)`.\\n\\n----\\n\\n***Please feel free to let me know if you can make the codes better.***",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] indexAndVal = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            indexAndVal[i] = new int[]{i, nums[i]};\\n        }\\n        // Reversely sort by value.\\n        Arrays.sort(indexAndVal, Comparator.comparingInt(a -> -a[1]));\\n        int[][] maxK = Arrays.copyOf(indexAndVal, k);\\n        // Sort by index.\\n        Arrays.sort(maxK, Comparator.comparingInt(a -> a[0]));\\n        int[] seq = new int[k];\\n        for (int i = 0; i < k; ++i) {\\n            seq[i] = maxK[i][1];\\n        }\\n        return seq;\\n    }\\n```\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        val_and_index = sorted([(num, i) for i, num in enumerate(nums)])\\n        return [num for num, i in sorted(val_and_index[-k :], key=lambda x: x[1])]\\n```\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k + 1);\\n        for (int n : nums) {\\n            pq.offer(n);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int n : pq) {\\n            freq.merge(n, 1, Integer::sum);\\n        }\\n        int[] seq = new int[k]; \\n        int i = 0;\\n        for (int n : nums) {\\n            if (freq.merge(n, -1, Integer::sum) >= 0) {\\n                seq[i++] = n;\\n            }\\n        }\\n        return seq;\\n    }\\n```\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        heap = []\\n        for n in nums:\\n            heapq.heappush(heap, n)\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n        cnt = Counter(heap)\\n        res = []\\n        for n in nums:\\n            if cnt[n] > 0:\\n                cnt[n] -= 1\\n                res.append(n)\\n        return res\\n```\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>\\n                    (Comparator.comparingInt(i -> nums[i]));\\n        for (int i = 0; i < nums.length; ++i) {\\n            pq.offer(i);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        return pq.stream().sorted().mapToInt(i -> nums[i]).toArray();\\n    }\\n```\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        heap = []\\n        for i, n in enumerate(nums):\\n            heapq.heappush(heap, (n, i))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n        return [a[0] for a in sorted(heap, key=lambda x: x[1])] \\n```\n```java\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] index = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            index[i] = i;\\n        }\\n        \\n        // Use Quick Select to put the indexes of the \\n        // max k items to the left of index array. \\n        int lo = 0, hi = n - 1;\\n        while (lo < hi) {\\n            int idx = quickSelect(nums, index, lo, hi);\\n            if (idx < k) {\\n                lo = idx + 1;\\n            }else {\\n                hi = idx;\\n            }\\n        }\\n        \\n        // Count the occurrencs of the kth largest items\\n        // within the k largest ones.\\n        int kthVal = nums[index[k - 1]], freqOfkthVal = 0;\\n        for (int i : Arrays.copyOf(index, k)) {\\n            freqOfkthVal += nums[i] == kthVal ? 1 : 0;\\n        }\\n        \\n        // Greedily copy the subsequence into output array seq.\\n        int[] seq = new int[k];\\n        int i = 0;\\n        for (int num : nums) {\\n            if (num > kthVal || num == kthVal && freqOfkthVal-- > 0) {\\n                seq[i++] = num;\\n            }\\n        }\\n        return seq;\\n    }\\n    \\n    // Divide index[lo...hi] into two parts: larger and less than \\n    // the pivot; Then return the position of the pivot;\\n    private int quickSelect(int[] nums, int[] index, int lo, int hi) {\\n        int pivot = index[lo];\\n        while (lo < hi) {\\n            while (lo < hi && nums[index[hi]] <= nums[pivot]) {\\n                --hi;\\n            }\\n            index[lo] = index[hi];\\n            while (lo < hi && nums[index[lo]] >= nums[pivot]) {\\n                ++lo;\\n            }\\n            index[hi] = index[lo];\\n        } \\n        index[lo] = pivot;\\n        return lo;\\n    }\\n```\n```python\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        # Divide index[lo...hi] into two parts: larger and less than \\n        # the pivot; Then return the position of the pivot;\\n        def quickSelect(lo: int, hi: int) -> int:\\n            pivot = index[lo]\\n            while lo < hi:\\n                while lo < hi and nums[index[hi]] <= nums[pivot]:\\n                    hi -= 1\\n                index[lo] = index[hi]\\n                while lo < hi and nums[index[lo]] >= nums[pivot]:\\n                    lo += 1\\n                index[hi] = index[lo]\\n            index[lo] = pivot\\n            return lo\\n\\n        n = len(nums)\\n        index = list(range(n))\\n        \\n        # Use Quick Select to put the indexes of the \\n        # max k items to the left of index array.\\n        left, right = 0, n - 1\\n        while left < right:\\n            idx = quickSelect(left, right)\\n            if idx < k:\\n                left = idx + 1\\n            else:\\n                right = idx\\n        \\n        # Count the occurrencs of the kth largest items\\n        # within the k largest ones.\\n        kth_val, freq_of_kth_val = nums[index[k - 1]], 0\\n        for i in index[ : k]:\\n            if nums[i] == kth_val:\\n                freq_of_kth_val += 1\\n                \\n        # Greedily copy the subsequence into output array seq.\\n        seq = []\\n        for num in nums:\\n            if num > kth_val or num == kth_val and freq_of_kth_val > 0:\\n                seq.append(num)\\n                if num == kth_val:\\n                    freq_of_kth_val -= 1\\n        return seq\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1623322,
                "title": "split-point-o-n",
                "content": "Somehow, this was the hardest question for me. I misunderstood the description - twice!\\n \\n> Update: inspired by [qeetcode](https://leetcode.com/qeetcode/), here is an O(n) solution (in average).\\n \\nWe use quick select to determine the k-largest element. The idea is that all elements bigger than k-largest will be in the result array.\\n \\nWhat about the k-largest element itself? Right, duplicates could stir some trouble. So, we count how many times (`cnt`) k-largest elements appear within `k` numbers.\\n\\n**C++**\\n```cpp\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    if (k == nums.size())\\n        return nums;\\n    vector<int> v(begin(nums), end(nums)), res;\\n    nth_element(begin(v), begin(v) + k - 1, end(v), greater<int>());\\n    int cnt = count(begin(v), begin(v) + k, v[k - 1]);\\n    for (int i = 0; i < nums.size(); ++i)\\n        if (nums[i] > v[k - 1] || (nums[i] == v[k - 1] && --cnt >= 0))\\n            res.push_back(nums[i]);\\n    return res;\\n}\\n```\\n\\n#### O(n + k log k)\\nJust for the reference - the original solution. Here we sort k numbers instead of working off the split point.\\n\\n**C++**\\n```cpp\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    vector<pair<int, int>> v;\\n    for (int i = 0; i < nums.size(); ++i)\\n        v.push_back({nums[i], i});\\n    nth_element(begin(v), begin(v) + k, end(v), greater<pair<int, int>>());\\n    sort(begin(v), begin(v) + k, [](const auto &a, const auto &b){ return a.second < b.second; });\\n    vector<int> res;\\n    transform(begin(v), begin(v) + k, back_inserter(res), [](const auto &p){ return p.first; });\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    if (k == nums.size())\\n        return nums;\\n    vector<int> v(begin(nums), end(nums)), res;\\n    nth_element(begin(v), begin(v) + k - 1, end(v), greater<int>());\\n    int cnt = count(begin(v), begin(v) + k, v[k - 1]);\\n    for (int i = 0; i < nums.size(); ++i)\\n        if (nums[i] > v[k - 1] || (nums[i] == v[k - 1] && --cnt >= 0))\\n            res.push_back(nums[i]);\\n    return res;\\n}\\n```\n```cpp\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    vector<pair<int, int>> v;\\n    for (int i = 0; i < nums.size(); ++i)\\n        v.push_back({nums[i], i});\\n    nth_element(begin(v), begin(v) + k, end(v), greater<pair<int, int>>());\\n    sort(begin(v), begin(v) + k, [](const auto &a, const auto &b){ return a.second < b.second; });\\n    vector<int> res;\\n    transform(begin(v), begin(v) + k, back_inserter(res), [](const auto &p){ return p.first; });\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670145,
                "title": "easy-c-solution",
                "content": "```\\ntypedef pair<int,int> p;\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        // Heap \\'q\\' will store the k largest elements of the array \\n        // The following heap is of pair where first element of pair is the element and the second element is the corresponding index\\n        // That\\'s how in queue sorting will be done according to the array element\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q.push({nums[i],i});\\n            if(q.size()>k)\\n            {\\n                q.pop();\\n            }\\n        }\\n        \\n        // heap \\'aux\\' will sort the elements based on their index\\n        // sorting according to the index is necessary in order get the original order of the elements \\n\\t\\t// in the following heap the first element of the pair is the index and the second element is the array element itself\\n        priority_queue<p,vector<p>,greater<p>>aux;\\n        while(!q.empty())\\n        {\\n            aux.push({q.top().second,q.top().first});\\n            q.pop();\\n        }\\n        \\n        // once the elements are sorted according to their indices , push them in a vector\\n        vector<int>ans;\\n        while(!aux.empty())\\n        {\\n            ans.push_back(aux.top().second);\\n            aux.pop();\\n        }\\n        \\n        // finally return the answer\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int> p;\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        // Heap \\'q\\' will store the k largest elements of the array \\n        // The following heap is of pair where first element of pair is the element and the second element is the corresponding index\\n        // That\\'s how in queue sorting will be done according to the array element\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q.push({nums[i],i});\\n            if(q.size()>k)\\n            {\\n                q.pop();\\n            }\\n        }\\n        \\n        // heap \\'aux\\' will sort the elements based on their index\\n        // sorting according to the index is necessary in order get the original order of the elements \\n\\t\\t// in the following heap the first element of the pair is the index and the second element is the array element itself\\n        priority_queue<p,vector<p>,greater<p>>aux;\\n        while(!q.empty())\\n        {\\n            aux.push({q.top().second,q.top().first});\\n            q.pop();\\n        }\\n        \\n        // once the elements are sorted according to their indices , push them in a vector\\n        vector<int>ans;\\n        while(!aux.empty())\\n        {\\n            ans.push_back(aux.top().second);\\n            aux.pop();\\n        }\\n        \\n        // finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623514,
                "title": "python-c-from-o-nlogn-to-o-n-one-liner-100-faster-detailed-explanation",
                "content": "* The subsequence of length k with the largest sum are composed of the largest k numbers in nums.\\n* \\'sorted(nums, reverse=True)[:k]\\' can find the  largest k numbers in num, but destroy their original order.\\n* We can traverse the list again and reconstruct the original order of max_k in the list.\\n\\n**Python 100% Faster**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        ret, max_k = [], sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_k:\\n                ret.append(num)\\n                max_k.remove(num)\\n                if len(max_k) == 0:\\n                    return ret\\n```\\n**An alternative python solution, maybe a little more pythonic!**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        # Build a two-keyword(index, num) list and sort by num in reverse order and intercept the top k\\n        nums_with_idx_topk = sorted(enumerate(nums), reverse=True, key=lambda elem: elem[1])[:k]\\n        nums_with_idx_topk = sorted(nums_with_idx_topk)  # Sort by index in order\\n        return [num for i, num in nums_with_idx_topk]\\n```\\n**Python, One-liner, 100% Faster, Upvote!**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        return [n for i, n in sorted(sorted(enumerate(nums), key=lambda e: -e[1])[:k])]\\n```\\n**Further More O(n), Using Quick Select**\\n* The average Time Complexity of Quick Select is O(n), while the worst-case performance is O(n<sup>2</sup>).\\n\\t* Note that it is very important to choose the split point randomly.\\n* Learn more about quick select algorithm: https://en.wikipedia.org/wiki/Quickselect\\n\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        def findKthLargest(nums, k):\\n            pivot = random.choice(nums)\\n            less = [num for num in nums if num < pivot]\\n            equal = [num for num in nums if num == pivot]\\n            greater = [num for num in nums if num > pivot]\\n\\n            if len(greater) >= k:\\n                return findKthLargest(greater, k)\\n            elif len(greater) + len(equal) < k:\\n                return findKthLargest(less, k - len(greater) - len(equal))\\n            else:\\n                return pivot, k - len(greater)\\n\\n        kth_largest, kth_largest_equal = findKthLargest(nums, k)\\n        ans = []\\n        for num in nums:\\n            if num > kth_largest:\\n                ans.append(num)\\n            elif num == kth_largest and kth_largest_equal:\\n                ans.append(num)\\n                kth_largest_equal -= 1\\n        return ans\\n```\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**\\n\\n**C++ 53% Faster**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> max_k(nums);\\n        vector<int> ret;\\n        sort(max_k.rbegin(), max_k.rend());\\n        for (int i = 0; i < size(nums); i ++) {\\n            for (int j = 0; j < k; j ++) {\\n                if (nums[i] == max_k[j]) {\\n                    ret.push_back(nums[i]);\\n                    nums[i] = -1000000;\\n                    max_k[j] = 1000000;\\n                    if (size(ret) == k) return ret;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        ret, max_k = [], sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_k:\\n                ret.append(num)\\n                max_k.remove(num)\\n                if len(max_k) == 0:\\n                    return ret\\n```\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        # Build a two-keyword(index, num) list and sort by num in reverse order and intercept the top k\\n        nums_with_idx_topk = sorted(enumerate(nums), reverse=True, key=lambda elem: elem[1])[:k]\\n        nums_with_idx_topk = sorted(nums_with_idx_topk)  # Sort by index in order\\n        return [num for i, num in nums_with_idx_topk]\\n```\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        return [n for i, n in sorted(sorted(enumerate(nums), key=lambda e: -e[1])[:k])]\\n```\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        def findKthLargest(nums, k):\\n            pivot = random.choice(nums)\\n            less = [num for num in nums if num < pivot]\\n            equal = [num for num in nums if num == pivot]\\n            greater = [num for num in nums if num > pivot]\\n\\n            if len(greater) >= k:\\n                return findKthLargest(greater, k)\\n            elif len(greater) + len(equal) < k:\\n                return findKthLargest(less, k - len(greater) - len(equal))\\n            else:\\n                return pivot, k - len(greater)\\n\\n        kth_largest, kth_largest_equal = findKthLargest(nums, k)\\n        ans = []\\n        for num in nums:\\n            if num > kth_largest:\\n                ans.append(num)\\n            elif num == kth_largest and kth_largest_equal:\\n                ans.append(num)\\n                kth_largest_equal -= 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> max_k(nums);\\n        vector<int> ret;\\n        sort(max_k.rbegin(), max_k.rend());\\n        for (int i = 0; i < size(nums); i ++) {\\n            for (int j = 0; j < k; j ++) {\\n                if (nums[i] == max_k[j]) {\\n                    ret.push_back(nums[i]);\\n                    nums[i] = -1000000;\\n                    max_k[j] = 1000000;\\n                    if (size(ret) == k) return ret;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623469,
                "title": "6-line-using-hashing-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        vector<int> v , temp = nums;\\n        sort(nums.begin() , nums.end());\\n        unordered_map<int,int> map;\\n        \\n        for(int index = 0 ; index < k ; index ++) map[nums[nums.size() - 1- index]]++; \\n        for(auto it: temp) if(map[it]-- > 0)v.push_back(it);\\n    return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        vector<int> v , temp = nums;\\n        sort(nums.begin() , nums.end());\\n        unordered_map<int,int> map;\\n        \\n        for(int index = 0 ; index < k ; index ++) map[nums[nums.size() - 1- index]]++; \\n        for(auto it: temp) if(map[it]-- > 0)v.push_back(it);\\n    return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623427,
                "title": "c-sorting-or-quick-select",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sorting\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        vector<int> id(A.size());\\n        iota(begin(id), end(id), 0); // Index array 0, 1, 2, ...\\n        sort(begin(id), end(id), [&](int a, int b) { return A[a] > A[b]; }); // Sort the indexes in descending order of their corresponding values in `A`\\n        id.resize(k); // Only keep the first `k` indexes with the greatest `A` values\\n        sort(begin(id), end(id)); // Sort indexes in ascending order\\n        vector<int> ans;\\n        for (int i : id) ans.push_back(A[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Quick Select\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N + KlogK) on average, O(N^2 + KlogK) in the worst case\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        vector<int> id(A.size());\\n        iota(begin(id), end(id), 0);\\n        nth_element(begin(id), begin(id) + k, end(id), [&](int a, int b) { return A[a] > A[b]; });\\n        id.resize(k);\\n        sort(begin(id), end(id));\\n        vector<int> ans;\\n        for (int i : id) ans.push_back(A[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 3. Quick Select\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N) on average, O(N^2) in the worst case\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        if (k == A.size()) return A;\\n        vector<int> v(begin(A), end(A)), ans;\\n        nth_element(begin(v), begin(v) + k - 1, end(v), greater<>());\\n        int cnt = count(begin(v), begin(v) + k, v[k - 1]);\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] > v[k - 1] || (A[i] == v[k - 1] && --cnt >= 0)) ans.push_back(A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        vector<int> id(A.size());\\n        iota(begin(id), end(id), 0); // Index array 0, 1, 2, ...\\n        sort(begin(id), end(id), [&](int a, int b) { return A[a] > A[b]; }); // Sort the indexes in descending order of their corresponding values in `A`\\n        id.resize(k); // Only keep the first `k` indexes with the greatest `A` values\\n        sort(begin(id), end(id)); // Sort indexes in ascending order\\n        vector<int> ans;\\n        for (int i : id) ans.push_back(A[i]);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N + KlogK) on average, O(N^2 + KlogK) in the worst case\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        vector<int> id(A.size());\\n        iota(begin(id), end(id), 0);\\n        nth_element(begin(id), begin(id) + k, end(id), [&](int a, int b) { return A[a] > A[b]; });\\n        id.resize(k);\\n        sort(begin(id), end(id));\\n        vector<int> ans;\\n        for (int i : id) ans.push_back(A[i]);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N) on average, O(N^2) in the worst case\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& A, int k) {\\n        if (k == A.size()) return A;\\n        vector<int> v(begin(A), end(A)), ans;\\n        nth_element(begin(v), begin(v) + k - 1, end(v), greater<>());\\n        int cnt = count(begin(v), begin(v) + k, v[k - 1]);\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] > v[k - 1] || (A[i] == v[k - 1] && --cnt >= 0)) ans.push_back(A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705383,
                "title": "python-simple-solution-100-time",
                "content": "## Code:\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        tuple_heap = [] # Stores (value, index) as min heap\\n        for i, val in enumerate(nums):\\n            if len(tuple_heap) == k:\\n                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k\\n            else:\\n                heappush(tuple_heap, (val, i))\\n\\t\\t# heap now contains only the k largest elements with their indices as well.\\n        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) & not value(x[0])\\n        ans = []\\n        for i in tuple_heap:\\n            ans.append(i[0])\\n        return ans\\n```\\nGive an \\u2B06\\uFE0Fupvote if you found this article helpful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        tuple_heap = [] # Stores (value, index) as min heap\\n        for i, val in enumerate(nums):\\n            if len(tuple_heap) == k:\\n                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k\\n            else:\\n                heappush(tuple_heap, (val, i))\\n\\t\\t# heap now contains only the k largest elements with their indices as well.\\n        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) & not value(x[0])\\n        ans = []\\n        for i in tuple_heap:\\n            ans.append(i[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688113,
                "title": "java-priority-queue-easy-explained",
                "content": "class Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        // Create proirity queue with min priority queue so that min element will be removed first, with index\\n        // Add those unique index in a set\\n        // Loop from 0 to n-1 and add element in result if set contains those index\\n        // For ex. set has index 3,5,6 Just add those element. Order will be maintained\\n            \\n     \\n       // We are defining the min priority queue  \\n       PriorityQueue<int[]> q = new PriorityQueue<>((a,b)-> (a[0]-b[0])); \\n        \\n        // Add element with index to priority queue\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            q.offer(new int[]{nums[i],i});\\n            if(q.size()> k)\\n            {\\n                q.poll();\\n            }\\n        }\\n        \\n        // Set to keep index\\n        Set<Integer> index = new HashSet<>();\\n        \\n        \\n        // Add the index in the set since index are unique \\n        while(!q.isEmpty())\\n        {\\n            int[] top = q.poll();\\n            index.add(top[1]);\\n        }\\n        \\n        // Final result add here\\n        int[] result = new int[k];\\n        \\n        \\n        // Just add the element in the result for those index present in SET\\n        int p =0;\\n        for(int i=0; i< nums.length; i++)\\n        {\\n            if(index.contains(i))\\n            {\\n                result[p] = nums[i];\\n                ++p;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        // Create proirity queue with min priority queue so that min element will be removed first, with index\\n        // Add those unique index in a set\\n        // Loop from 0 to n-1 and add element in result if set contains those index\\n        // For ex. set has index 3,5,6 Just add those element. Order will be maintained\\n            \\n     \\n       // We are defining the min priority queue  \\n       PriorityQueue<int[]> q = new PriorityQueue<>((a,b)-> (a[0]-b[0])); \\n        \\n        // Add element with index to priority queue\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            q.offer(new int[]{nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1623422,
                "title": "python3-easy-intuitive-o-n-k",
                "content": "The idea is to hold maximum **k** elements in order. Therefore we start with an empty array and follow the steps:\\n1- Put `nums[0]` to the array since we know that `len(nums) >= 1`\\n2- Until `max_k` reaches **k** elements, put each element to the array (optimized version: initialize it with first **k** elements of the input)\\n3- When the `max_k` reaches the size of **k**, check if the `i th` element is larger than the minimum of the array, if so remove minumum and put the element at the end.\\n\\nTherefore, the order in the array will stay the same as the input.\\n\\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        max_k = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if len(max_k) < k: max_k.append(nums[i])  # put first k elements \\n            elif len(max_k) == k:  # whenever we have k elements\\n                if nums[i] > min(max_k):  # if the i th element is bigger than the minimum of seen so far\\n                    max_k.remove(min(max_k))  # remove minimum\\n                    max_k.append(nums[i])  # append the current element at the end\\n        return max_k\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        max_k = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if len(max_k) < k: max_k.append(nums[i])  # put first k elements \\n            elif len(max_k) == k:  # whenever we have k elements\\n                if nums[i] > min(max_k):  # if the i th element is bigger than the minimum of seen so far\\n                    max_k.remove(min(max_k))  # remove minimum\\n                    max_k.append(nums[i])  # append the current element at the end\\n        return max_k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568370,
                "title": "java-easy-to-undersatnd-no-hash",
                "content": "```\\n    public int[] maxSubsequence(int[] nums, int k) {\\n      PriorityQueue<Integer> pq=new PriorityQueue<>();\\n       List<Integer> v=new ArrayList<>(); \\n        for(int x:nums){\\n            pq.add(x);\\n            v.add(x);\\n        }\\n        \\n        int[] ans=new int[k];\\n        \\n        for(int i=0;i<nums.length-k;i++)\\n            v.remove(pq.remove());\\n        \\n        for(int i=0;i<k;i++)\\n            ans[i]=v.get(i);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] maxSubsequence(int[] nums, int k) {\\n      PriorityQueue<Integer> pq=new PriorityQueue<>();\\n       List<Integer> v=new ArrayList<>(); \\n        for(int x:nums){\\n            pq.add(x);\\n            v.add(x);\\n        }\\n        \\n        int[] ans=new int[k];\\n        \\n        for(int i=0;i<nums.length-k;i++)\\n            v.remove(pq.remove());\\n        \\n        for(int i=0;i<k;i++)\\n            ans[i]=v.get(i);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903034,
                "title": "easy-code-using-heap-beginner-friendly-well-commented",
                "content": "*Approach:\\n1)Declare a max heap(since we need maximum sum) with datatype as pair of <int,int> to store the value of element present in given array along with the index.\\n2)Push all the elements of given vector along with its index into the heap .\\n3)Separate out the top \\'k\\' index from heap and store it in a vector.\\n4)Sort the vector containing indexes so that the order of elements present at those indexdes is maintained.\\n5)Decalre a new vector to store the values of elements present at these separated out indexes.\\n6)Return this vector containing values of elements.*\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0;i<nums.size();i++)\\n            pq.push({nums[i],i});\\n        \\n        vector<int> index;\\n        while(k--){\\n            pair<int,int> t=pq.top();\\n            index.push_back(t.second);\\n            pq.pop();\\n        }\\n        sort(index.begin(),index.end());\\n        \\n        vector<int> ans;\\n        for(int i=0;i<index.size();i++)\\n            ans.push_back(nums[index[i]]);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease upvote if you liked the solution :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0;i<nums.size();i++)\\n            pq.push({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1628591,
                "title": "c-o-n-log-k-min-heap",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; // {element,idx}\\n        \\n        int n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(pq.size()<k){\\n                pq.push({a[i],i});\\n            }else if(pq.size()==k && pq.top().first<a[i]){ // storing max k elements in priority queue\\n                pq.pop();\\n                pq.push({a[i],i});\\n            }\\n        }\\n        \\n        vector<pair<int,int>> sub;\\n        while(pq.size()>0){\\n            int val=pq.top().first, idx=pq.top().second;\\n            pq.pop();\\n            \\n            sub.push_back({idx,val}); // storing index to print in correct order\\n        }\\n        sort(sub.begin(),sub.end());\\n        \\n        vector<int> ans;\\n        for(int i=0;i<k;i++) ans.push_back(sub[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; // {element,idx}\\n        \\n        int n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(pq.size()<k){\\n                pq.push({a[i],i});\\n            }else if(pq.size()==k && pq.top().first<a[i]){ // storing max k elements in priority queue\\n                pq.pop();\\n                pq.push({a[i],i});\\n            }\\n        }\\n        \\n        vector<pair<int,int>> sub;\\n        while(pq.size()>0){\\n            int val=pq.top().first, idx=pq.top().second;\\n            pq.pop();\\n            \\n            sub.push_back({idx,val}); // storing index to print in correct order\\n        }\\n        sort(sub.begin(),sub.end());\\n        \\n        vector<int> ans;\\n        for(int i=0;i<k;i++) ans.push_back(sub[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624136,
                "title": "c-simple-solution-using-multiset",
                "content": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n        typedef pair<int,int> pii;\\n\\t\\t//we maintain a multiiset of pair [not a set coz our array has duplicates too ]\\n\\t\\t//having value as {element,index}\\n        multiset<pii> st;\\n        int n = size(nums);\\n        \\n\\t\\t//we iterate over the array to find k largest elements along with their indices\\n        for(int i=0;i<n;i++)\\n        {\\n            if(size(st) < k) st.insert({nums[i],i});\\n            else \\n            {\\n                auto it = st.begin();\\n                if((*it).first < nums[i])\\n                {\\n                    st.erase(it);\\n                    st.insert({nums[i],i});\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now we make a set to store the index of previously calculated values in \\n\\t\\t//non-decreasing form\\n        set<int> idx;\\n        for(auto &ele : st) idx.insert(ele.second);\\n        \\n\\t\\t//the only thing remains now is to push the elements into\\n\\t\\t//our answer vector and return it\\n        vector<int> res;\\n        for(auto &ele : idx) res.push_back(nums[ele]);\\n        \\n        return res;\\n    }\\n```\\n\\n**Time Complexity :** O(n * log k)\\n**Space Complexity :** O(k)",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n        typedef pair<int,int> pii;\\n\\t\\t//we maintain a multiiset of pair [not a set coz our array has duplicates too ]\\n\\t\\t//having value as {element,index}\\n        multiset<pii> st;\\n        int n = size(nums);\\n        \\n\\t\\t//we iterate over the array to find k largest elements along with their indices\\n        for(int i=0;i<n;i++)\\n        {\\n            if(size(st) < k) st.insert({nums[i],i});\\n            else \\n            {\\n                auto it = st.begin();\\n                if((*it).first < nums[i])\\n                {\\n                    st.erase(it);\\n                    st.insert({nums[i],i});\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now we make a set to store the index of previously calculated values in \\n\\t\\t//non-decreasing form\\n        set<int> idx;\\n        for(auto &ele : st) idx.insert(ele.second);\\n        \\n\\t\\t//the only thing remains now is to push the elements into\\n\\t\\t//our answer vector and return it\\n        vector<int> res;\\n        for(auto &ele : idx) res.push_back(nums[ele]);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1662796,
                "title": "javascript-one-liner-88-ms",
                "content": "```\\nvar maxSubsequence = function(nums, k) {\\n    return nums.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).slice(-k).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubsequence = function(nums, k) {\\n    return nums.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).slice(-k).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623480,
                "title": "c-using-hashing-re-arranging-answer-after-sorting",
                "content": "```\\n\\t\\tvector<int> temp = nums, ans;\\n        unordered_map<int, int> mp;\\n        sort(temp.begin(), temp.end());\\n        int i = nums.size() - 1;\\n        int ptr = 0;\\n        while(ptr++ < k) ans.push_back(temp[i--]);\\n        for(auto it : ans) mp[it]++;\\n        ans.clear();\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(mp[nums[i]]-- > 0 ) {\\n                ans.push_back(nums[i]);\\n                ptr++;\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tvector<int> temp = nums, ans;\\n        unordered_map<int, int> mp;\\n        sort(temp.begin(), temp.end());\\n        int i = nums.size() - 1;\\n        int ptr = 0;\\n        while(ptr++ < k) ans.push_back(temp[i--]);\\n        for(auto it : ans) mp[it]++;\\n        ans.clear();\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(mp[nums[i]]-- > 0 ) {\\n                ans.push_back(nums[i]);\\n                ptr++;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623455,
                "title": "java-easy-explained-solution",
                "content": "\\'\\'\\'public int[] maxSubsequence(int[] nums, int k) {\\n\\n    int ans[] = new int[k];\\n\\t\\n\\t//get the k largest integers in priority queue\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tpq.add(nums[i]);\\n\\n\\t\\tif(i>=k) pq.poll();\\n\\t}\\n    \\n\\t//store elements present in queue in hashmap\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    for(int i=0; i<k; i++){\\n        int a = pq.poll();\\n        map.put(a, map.getOrDefault(a, 0)+1);\\n    }\\n    \\n\\t//to check values\\n    //System.out.println(\"New HashMap: \" + map.toString());\\n    //add the values in result array in the right order\\n    int l=0;\\n    for(int j=0; j<nums.length; j++){\\n        if(l==k) break;\\n        \\n        if(map.containsKey(nums[j])){\\n            ans[l] = nums[j];\\n            l++;\\n            int f = map.get(nums[j])-1;\\n            if(f>=1)\\n                map.replace(nums[j],f);\\n            else if(f == 0)\\n                map.remove(nums[j]);\\n        }\\n            \\n    }\\n    \\n\\treturn ans;\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "\\'\\'\\'public int[] maxSubsequence(int[] nums, int k) {\\n\\n    int ans[] = new int[k];\\n\\t\\n\\t//get the k largest integers in priority queue\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tpq.add(nums[i]);\\n\\n\\t\\tif(i>=k) pq.poll();\\n\\t}\\n    \\n\\t//store elements present in queue in hashmap\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    for(int i=0; i<k; i++){\\n        int a = pq.poll();\\n        map.put(a, map.getOrDefault(a, 0)+1);\\n    }\\n    \\n\\t//to check values\\n    //System.out.println(\"New HashMap: \" + map.toString());\\n    //add the values in result array in the right order\\n    int l=0;\\n    for(int j=0; j<nums.length; j++){\\n        if(l==k) break;\\n        \\n        if(map.containsKey(nums[j])){\\n            ans[l] = nums[j];\\n            l++;\\n            int f = map.get(nums[j])-1;\\n            if(f>=1)\\n                map.replace(nums[j],f);\\n            else if(f == 0)\\n                map.remove(nums[j]);\\n        }\\n            \\n    }\\n    \\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3144467,
                "title": "concise-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        while len(nums) > k:\\n            nums.remove(min(nums))\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        while len(nums) > k:\\n            nums.remove(min(nums))\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365625,
                "title": "is-this-problem-really-easy-shouldn-t-be-a-medium-one-or-is-it-just-me",
                "content": "Is this problem really easy ? shouldn\\'t be a medium one or is it just me ?!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1842479,
                "title": "java-simple-solution-using-maxheap-sorting",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[0] - a[0]);\\n        \\n        for(int i=0; i<nums.length; i++)\\n            pq.offer(new int[]{nums[i], i});\\n        \\n        List<int[]> l = new ArrayList<>();\\n        \\n        while(k-- != 0)\\n            l.add(pq.poll());\\n        \\n        Collections.sort(l, (a,b) -> a[1] - b[1]);\\n            \\n        int[] res = new int[l.size()];\\n        \\n        int index = 0;\\n        \\n        for(int[] i: l)\\n            res[index++] = i[0];\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[0] - a[0]);\\n        \\n        for(int i=0; i<nums.length; i++)\\n            pq.offer(new int[]{nums[i], i});\\n        \\n        List<int[]> l = new ArrayList<>();\\n        \\n        while(k-- != 0)\\n            l.add(pq.poll());\\n        \\n        Collections.sort(l, (a,b) -> a[1] - b[1]);\\n            \\n        int[] res = new int[l.size()];\\n        \\n        int index = 0;\\n        \\n        for(int[] i: l)\\n            res[index++] = i[0];\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623562,
                "title": "c-solution-explanation-hashing",
                "content": "Algorithm:\\nAcc to the constraints you cannot do it using recursion it gives TLE.\\n\\nThink to optimise it.\\nYou need the k largest values of the array to make the maximum sum. So that can be got by the last ```K``` values of a sorted array.\\nSo we think to sort the array.\\nNow extract the last k values which gives the maximum sum. [ kept it in temp]\\n\\nNow we need to think how to return these values in their original order.\\nWhat if you have the elements in some DS and you traverse the original array. As soon as you see that the presently traversed element is in the DS [will think of this in the next step] you push to the ```answer``` array.\\n\\ncool. soo now what DS to store the values. \\n a. if we consider a set then the duplicates values will be lost and original ordering will mess up.\\n b. can use a map. since the value and its frequency can be mantained you can put the values the exact number of times in the output array as in the input array .\\n \\n Now just traverse the original array. check if the map has the freq greater than 0. if yes push to output array and decrement the frequency ( mark it as seen ) \\n \\n \\n Here you goo.. \\n```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> original = nums;\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp(nums.end()-k, nums.end());\\n\\n        unordered_map<int,int>mp;\\n        for(int x: temp){\\n            mp[x]+=1;\\n        }\\n        vector<int>ans;\\n        for(int x : original){\\n            \\n                if(mp[x]-- >0){\\n                    ans.push_back(x);\\n                }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```K```\n```answer```\n```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> original = nums;\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp(nums.end()-k, nums.end());\\n\\n        unordered_map<int,int>mp;\\n        for(int x: temp){\\n            mp[x]+=1;\\n        }\\n        vector<int>ans;\\n        for(int x : original){\\n            \\n                if(mp[x]-- >0){\\n                    ans.push_back(x);\\n                }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623544,
                "title": "c-faster-than-100-priority-queue-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        //Using a Priority Queue to store pair\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for(int i = 0 ; i <nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        // Store the k elements \\n        vector<pair<int, int>> ans;\\n        while(!pq.empty()){\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back({x.second , x.first});\\n        }\\n        \\n        //Sort k element based on original index\\n        sort(ans.begin(), ans.end());\\n        \\n        //Return the ans\\n        vector<int> finalAns;\\n        for(auto x : ans){\\n            finalAns.push_back(x.second);\\n        }\\n        return finalAns;\\n    }\\n};\\n\\n// Time : O(nlogn) + O(k) + O(klogk) + O(k)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        //Using a Priority Queue to store pair\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for(int i = 0 ; i <nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        // Store the k elements \\n        vector<pair<int, int>> ans;\\n        while(!pq.empty()){\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back({x.second , x.first});\\n        }\\n        \\n        //Sort k element based on original index\\n        sort(ans.begin(), ans.end());\\n        \\n        //Return the ans\\n        vector<int> finalAns;\\n        for(auto x : ans){\\n            finalAns.push_back(x.second);\\n        }\\n        return finalAns;\\n    }\\n};\\n\\n// Time : O(nlogn) + O(k) + O(klogk) + O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021377,
                "title": "simple-c-solution-runtime-8ms-beats-80",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int sum =0;\\n        priority_queue<pair<int, int>,vector<pair<int, int>>,greater<pair<int, int>>> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int i=nums.size()-k;\\n        while(i>0)\\n        {\\n            pq.pop();\\n            i--;\\n        }\\n        priority_queue<pair<int, int>,vector<pair<int, int>>,greater<pair<int, int>>> pq2;\\n        while(!pq.empty())\\n        {\\n                pq2.push({pq.top().second,pq.top().first});\\n                pq.pop();\\n        }\\n        nums.resize(0);\\n        while(!pq2.empty())\\n        {\\n            nums.push_back(pq2.top().second);\\n            pq2.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int sum =0;\\n        priority_queue<pair<int, int>,vector<pair<int, int>>,greater<pair<int, int>>> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int i=nums.size()-k;\\n        while(i>0)\\n        {\\n            pq.pop();\\n            i--;\\n        }\\n        priority_queue<pair<int, int>,vector<pair<int, int>>,greater<pair<int, int>>> pq2;\\n        while(!pq.empty())\\n        {\\n                pq2.push({pq.top().second,pq.top().first});\\n                pq.pop();\\n        }\\n        nums.resize(0);\\n        while(!pq2.empty())\\n        {\\n            nums.push_back(pq2.top().second);\\n            pq2.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496727,
                "title": "python-just-remove-min-items",
                "content": "\\tdef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n\\t\\tfor i in range(len(nums)-k):\\n\\t\\t\\tnums.remove(min(nums))\\n\\t\\treturn nums",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n\\t\\tfor i in range(len(nums)-k):\\n\\t\\t\\tnums.remove(min(nums))\\n\\t\\treturn nums",
                "codeTag": "Python3"
            },
            {
                "id": 2159428,
                "title": "easy-c-solution",
                "content": "```\\n\\tvector<int> maxSubsequence(vector<int>& nums, int k) \\n    {        \\n        vector<int> ans,temp(nums.begin(),nums.end());\\n        \\n        sort(temp.begin(),temp.end(),greater<int>());\\n\\n        temp.resize(k);\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int &i:temp)\\n        {\\n            m[i]++;\\n        }\\n        \\n        for(int &i:nums)\\n        {\\n            if(m[i]!=0)\\n            {\\n                ans.push_back(i);\\n                m[i]--;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tvector<int> maxSubsequence(vector<int>& nums, int k) \\n    {        \\n        vector<int> ans,temp(nums.begin(),nums.end());\\n        \\n        sort(temp.begin(),temp.end(),greater<int>());\\n\\n        temp.resize(k);\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int &i:temp)\\n        {\\n            m[i]++;\\n        }\\n        \\n        for(int &i:nums)\\n        {\\n            if(m[i]!=0)\\n            {\\n                ans.push_back(i);\\n                m[i]--;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947429,
                "title": "solution-without-heap-99-faster",
                "content": "\\'\\'\\'\\n\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        a=[]\\n        for i,char in enumerate(nums):\\n            a.append([char,i])               #putting values with indexes\\n  \\n        a.sort()                #sort and keep the last k beacuse they are the largest\\n        a=a[-k:]\\n        a.sort(key=lambda x:x[1])       #sort by indexing \\n        l=[]\\n        for i in a:                 \\n            l.append(nums[i[1]])\\n        return l\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        a=[]\\n        for i,char in enumerate(nums):\\n            a.append([char,i])               #putting values with indexes\\n  \\n        a.sort()                #sort and keep the last k beacuse they are the largest\\n        a=a[-k:]\\n        a.sort(key=lambda x:x[1])       #sort by indexing \\n        l=[]\\n        for i in a:                 \\n            l.append(nums[i[1]])\\n        return l\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1664708,
                "title": "simple-c-solution-sorting-tc-o-n-lg-n-sc-o-n",
                "content": "We can simply find the solution by simply performing the following steps :-\\nStep -1 -> First copy the given array into another array of pair along with index.\\nStep -2 -> Sort them in decreasing order (It will be sorted wrt value).\\nStep -3 -> Traverse the first k values and mark their indexes in a boolean **taken** array.\\nStep -4 -> Now traverse the original array again and keep the elements marked in previous step into our **result** array sequentially. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<pair<int, int>> numsWithIndex(n);\\n        vector<bool> taken(n, false);\\n        vector<int> result;\\n        \\n\\t\\t//Step 1\\n        for(int i=0;i<n;i++) numsWithIndex[i] = {nums[i], i};\\n\\t\\t\\n\\t\\t//Step 2\\n        sort(numsWithIndex.begin(), numsWithIndex.end(), greater<pair<int, int>>());\\n        \\n\\t\\t//Step 3\\n        for(int i=0;i<k;i++) taken[numsWithIndex[i].second] = true;\\n        \\n\\t\\t//Step 4\\n        for(int i=0;i<n;i++) {\\n            if(taken[i]) result.push_back(nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<pair<int, int>> numsWithIndex(n);\\n        vector<bool> taken(n, false);\\n        vector<int> result;\\n        \\n\\t\\t//Step 1\\n        for(int i=0;i<n;i++) numsWithIndex[i] = {nums[i], i};\\n\\t\\t\\n\\t\\t//Step 2\\n        sort(numsWithIndex.begin(), numsWithIndex.end(), greater<pair<int, int>>());\\n        \\n\\t\\t//Step 3\\n        for(int i=0;i<k;i++) taken[numsWithIndex[i].second] = true;\\n        \\n\\t\\t//Step 4\\n        for(int i=0;i<n;i++) {\\n            if(taken[i]) result.push_back(nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623433,
                "title": "python-quick-and-easy",
                "content": "Starting with sorting the array and then\\nremoving the smaller values upto len(nums)-k\\nand then print the remaining values of nums\\n\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        dup=sorted(nums)\\n        for i in range(len(nums)-k): nums.remove(dup[i])\\n        return nums\\n```\\n\\nDo **Upvote** if you find it useful",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        dup=sorted(nums)\\n        for i in range(len(nums)-k): nums.remove(dup[i])\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623366,
                "title": "using-sorting-c-explained",
                "content": "First add elements and their index in a vector of pair format - {a[i],i}\\nthen reverse sort them\\nNow add first k elements in a temporary array of vector of pair format - {i,a[i]}\\nNow sort this temp and add elements to ans\\n\\nSpace - O(n) Because storing all the elements in another vector\\nTime - O(n*log(n)) Because sorting is involved\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            v.push_back({a[i],i});\\n        \\n        sort(begin(v),end(v));\\n        reverse(begin(v),end(v));\\n        \\n        vector<pair<int,int>> t;\\n        \\n        for(int i = 0 ; i < k ; i++)\\n            t.push_back({v[i].second,v[i].first});\\n        \\n        \\n        sort(begin(t),end(t));\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0 ; i < k ; i++)\\n            ans.push_back(t[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            v.push_back({a[i],i});\\n        \\n        sort(begin(v),end(v));\\n        reverse(begin(v),end(v));\\n        \\n        vector<pair<int,int>> t;\\n        \\n        for(int i = 0 ; i < k ; i++)\\n            t.push_back({v[i].second,v[i].first});\\n        \\n        \\n        sort(begin(t),end(t));\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0 ; i < k ; i++)\\n            ans.push_back(t[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835442,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==k)\\n        return nums;\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(make_pair(nums[i],i));\\n        }\\n        vector<pair<int,int>>v;\\n        while(k--)\\n        {\\n            v.push_back({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans;\\n        for(auto i :v)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==k)\\n        return nums;\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(make_pair(nums[i],i));\\n        }\\n        vector<pair<int,int>>v;\\n        while(k--)\\n        {\\n            v.push_back({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans;\\n        for(auto i :v)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319890,
                "title": "one-liner-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    return nums\\n        .map((num, i) => ({ index: i, num }))\\n        .sort(({ num: n1 }, { num: n2 }) => n2 - n1)\\n        .slice(0, k)\\n        .sort(({ index: i1 }, { index: i2 }) => i1 - i2)\\n        .map(({ num }) => num);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    return nums\\n        .map((num, i) => ({ index: i, num }))\\n        .sort(({ num: n1 }, { num: n2 }) => n2 - n1)\\n        .slice(0, k)\\n        .sort(({ index: i1 }, { index: i2 }) => i1 - i2)\\n        .map(({ num }) => num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641259,
                "title": "c-priority-queue-solution",
                "content": "**Explanation:->**\\n1. since we have to keep the order as well so we will use pair with priority queue to store element ans its idx.\\n2. after that we will store idx in sorted form so that we get back our original idx.\\n3. then push the nums value using these idx in vector and then return it\\n\\n```\\npriority_queue<pair<int,int>> pq;\\n    for(int i=0;i<nums.size();i++)\\n        pq.push({nums[i],i});\\n    \\n    vector<int> index;\\n    while(k--){\\n        pair<int,int> t=pq.top();\\n        index.push_back(t.second);\\n        pq.pop();\\n    }\\n    sort(index.begin(),index.end());\\n    \\n    vector<int> ans;\\n    for(int i=0;i<index.size();i++)\\n        ans.push_back(nums[index[i]]);\\n    \\n    return ans;\\n```",
                "solutionTags": [],
                "code": "```\\npriority_queue<pair<int,int>> pq;\\n    for(int i=0;i<nums.size();i++)\\n        pq.push({nums[i],i});\\n    \\n    vector<int> index;\\n    while(k--){\\n        pair<int,int> t=pq.top();\\n        index.push_back(t.second);\\n        pq.pop();\\n    }\\n    sort(index.begin(),index.end());\\n    \\n    vector<int> ans;\\n    for(int i=0;i<index.size();i++)\\n        ans.push_back(nums[index[i]]);\\n    \\n    return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554784,
                "title": "java-solution-using-list-all-test-cases-passed",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        List<Integer>l=new ArrayList<>();\\n        List<Integer>a=new ArrayList<>();\\n        int b[]=new int[k];\\n        for(int i=0;i<nums.length;i++)l.add(nums[i]);\\n        Collections.sort(l);\\n        Collections.reverse(l);\\n        System.out.println(l);\\n        int j=0,c=k;\\n        while(k>0)\\n        {\\n            a.add(l.get(j));\\n            j+=1;\\n            k-=1;\\n        }\\n        j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(a.contains(nums[i])==true && j<c)\\n            {\\n                b[j]=nums[i];\\n                a.remove(a.indexOf(nums[i]));\\n                j+=1;\\n            }\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        List<Integer>l=new ArrayList<>();\\n        List<Integer>a=new ArrayList<>();\\n        int b[]=new int[k];\\n        for(int i=0;i<nums.length;i++)l.add(nums[i]);\\n        Collections.sort(l);\\n        Collections.reverse(l);\\n        System.out.println(l);\\n        int j=0,c=k;\\n        while(k>0)\\n        {\\n            a.add(l.get(j));\\n            j+=1;\\n            k-=1;\\n        }\\n        j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(a.contains(nums[i])==true && j<c)\\n            {\\n                b[j]=nums[i];\\n                a.remove(a.indexOf(nums[i]));\\n                j+=1;\\n            }\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934603,
                "title": "c-partial-sort",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        vector<pair<int,int>> numWithIndex(size(nums));\\n        for(int i = 0; i < size(nums); i++) numWithIndex[i] = {nums[i], i};\\n        \\n        partial_sort(begin(numWithIndex), \\n                     begin(numWithIndex) + k, \\n                     end(numWithIndex),\\n                     [](auto &left, auto &right) {\\n            return left.first > right.first;\\n        });\\n        \\n        vector<int> result;\\n        sort(begin(numWithIndex), \\n             begin(numWithIndex) + k, \\n             [](pair<int, int> a, pair<int, int> b) {\\n            return a.second < b.second;\\n        });\\n        \\n        for (int i = 0; i < k; i++ ) result.push_back(numWithIndex[i].first);       \\n        return result;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        vector<pair<int,int>> numWithIndex(size(nums));\\n        for(int i = 0; i < size(nums); i++) numWithIndex[i] = {nums[i], i};\\n        \\n        partial_sort(begin(numWithIndex), \\n                     begin(numWithIndex) + k, \\n                     end(numWithIndex),\\n                     [](auto &left, auto &right) {\\n            return left.first > right.first;\\n        });\\n        \\n        vector<int> result;\\n        sort(begin(numWithIndex), \\n             begin(numWithIndex) + k, \\n             [](pair<int, int> a, pair<int, int> b) {\\n            return a.second < b.second;\\n        });\\n        \\n        for (int i = 0; i < k; i++ ) result.push_back(numWithIndex[i].first);       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902345,
                "title": "c-o-n-time-quick-select-o-nlogn-heap-map-three-solution-with-explanation",
                "content": "# Solution 1: quick select\\nWe use quick select to get first k largest elements and then traverse these k elements to check how many same elements at the k-th largest. This is used to make sure we do not use more # than it should be in k largest elements.\\n\\n* time: `O(n)`\\n* space: `O(n)`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res, tmp = nums;\\n        nth_element(tmp.begin(), tmp.begin()+k-1, tmp.end(), [](const int &a, const int &b){\\n            return a > b;\\n        });\\n        int kth = tmp[k-1], kcnt = 0;\\n        for (int i = 0; i < k; ++i) {\\n            kcnt += tmp[i] == kth;\\n        }\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (k && (nums[i] > kth || nums[i] == kth && kcnt-- > 0)) {\\n                res.push_back(nums[i]);\\n                --k;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Solution 2\\nWe can also use heap to get first k largest elements and feed them back to `res` .\\n\\n* time: `O(nlogn)`\\n* space: `O(n)`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res, idx;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            idx.push_back(i);\\n        }\\n        auto comp = [&nums](const int &a, const int &b) {\\n            return nums[a] > nums[b];\\n        };\\n        priority_queue<int, vector<int>, decltype(comp)> que1(comp);\\n        priority_queue<int, vector<int>, greater<int>> que2;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            que1.push(i);\\n            if (que1.size() > k) {\\n                que1.pop();\\n            }\\n        }\\n        while (que1.size()) {\\n            que2.push(que1.top());\\n            que1.pop();\\n        }\\n        while (que2.size()) {\\n            res.push_back(nums[que2.top()]);\\n            que2.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Solution 3\\nUsing ordered map, we easily find k largest elements and save them into this map.\\n\\n* time: `O(nlogn)`\\n* space: `O(n)`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res;\\n        map<int,int> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            ++map[nums[i]];\\n            if (i >= k) {\\n                if (!--map.begin()->second) {\\n                    map.erase(map.begin());\\n                }\\n            }\\n        }\\n        for (auto &num: nums) {\\n            if (map.find(num) != map.end()) {\\n                res.push_back(num);\\n                if (!--map[num]) {\\n                    map.erase(num);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res, tmp = nums;\\n        nth_element(tmp.begin(), tmp.begin()+k-1, tmp.end(), [](const int &a, const int &b){\\n            return a > b;\\n        });\\n        int kth = tmp[k-1], kcnt = 0;\\n        for (int i = 0; i < k; ++i) {\\n            kcnt += tmp[i] == kth;\\n        }\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (k && (nums[i] > kth || nums[i] == kth && kcnt-- > 0)) {\\n                res.push_back(nums[i]);\\n                --k;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res, idx;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            idx.push_back(i);\\n        }\\n        auto comp = [&nums](const int &a, const int &b) {\\n            return nums[a] > nums[b];\\n        };\\n        priority_queue<int, vector<int>, decltype(comp)> que1(comp);\\n        priority_queue<int, vector<int>, greater<int>> que2;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            que1.push(i);\\n            if (que1.size() > k) {\\n                que1.pop();\\n            }\\n        }\\n        while (que1.size()) {\\n            que2.push(que1.top());\\n            que1.pop();\\n        }\\n        while (que2.size()) {\\n            res.push_back(nums[que2.top()]);\\n            que2.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res;\\n        map<int,int> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            ++map[nums[i]];\\n            if (i >= k) {\\n                if (!--map.begin()->second) {\\n                    map.erase(map.begin());\\n                }\\n            }\\n        }\\n        for (auto &num: nums) {\\n            if (map.find(num) != map.end()) {\\n                res.push_back(num);\\n                if (!--map[num]) {\\n                    map.erase(num);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756277,
                "title": "java-easy-solution-sorting-o-nlogn",
                "content": "```\\nclass Node{\\n    int index,value;\\n    Node(int index,int value){\\n        this.index=index;\\n        this.value=value;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        Node nodes[]=new Node[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            nodes[i]=new Node(i,nums[i]);\\n        Arrays.sort(nodes,(a,b)->a.value-b.value);\\n        Arrays.sort(nodes,nums.length-k,nums.length,(a,b)->a.index-b.index);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++)\\n            res[k-1-i]=nodes[nums.length-1-i].value;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n    int index,value;\\n    Node(int index,int value){\\n        this.index=index;\\n        this.value=value;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        Node nodes[]=new Node[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            nodes[i]=new Node(i,nums[i]);\\n        Arrays.sort(nodes,(a,b)->a.value-b.value);\\n        Arrays.sort(nodes,nums.length-k,nums.length,(a,b)->a.index-b.index);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++)\\n            res[k-1-i]=nodes[nums.length-1-i].value;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623484,
                "title": "c-linq-solution",
                "content": "```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k)\\n    {\\n        return nums\\n        .Select((n, i) => new { Number = n, Index = i })\\n        .ToList()\\n        .OrderByDescending(n => n.Number)\\n        .Take(k)\\n        .OrderBy(n => n.Index)\\n        .Select(n => n.Number)\\n        .ToArray();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k)\\n    {\\n        return nums\\n        .Select((n, i) => new { Number = n, Index = i })\\n        .ToList()\\n        .OrderByDescending(n => n.Number)\\n        .Take(k)\\n        .OrderBy(n => n.Index)\\n        .Select(n => n.Number)\\n        .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623443,
                "title": "java-priorityqueue",
                "content": "```\\n\\tpublic int[] maxSubsequence(int[] nums, int k) {\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn nums;\\n\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tint sum = 0;\\n\\t\\tint index = 0;\\n\\t\\t\\n\\t\\tQueue<int[]> q = new PriorityQueue<>((a,b)-> b[0]-a[0]);\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tq.add(new int[] {nums[i], i});\\t// saves index in order to sort k-biggest elements\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[][] res = new int[k][2];\\n\\t\\tint i = 0;\\n\\t\\tint kk = k;\\n\\t\\twhile (kk > 0) {\\n\\t\\t\\tres[i] = q.poll();\\n\\t\\t\\ti++;\\n\\t\\t\\tkk--;\\n\\t\\t}\\n\\t\\t\\n\\t\\tArrays.sort(res, (a,b)->a[1]-b[1]);\\n\\t\\t\\n\\t\\tint[] result = new int[k];\\n\\t\\t\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tresult[i] = res[i][0];\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tpublic int[] maxSubsequence(int[] nums, int k) {\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn nums;\\n\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tint sum = 0;\\n\\t\\tint index = 0;\\n\\t\\t\\n\\t\\tQueue<int[]> q = new PriorityQueue<>((a,b)-> b[0]-a[0]);\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tq.add(new int[] {nums[i], i});\\t// saves index in order to sort k-biggest elements\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[][] res = new int[k][2];\\n\\t\\tint i = 0;\\n\\t\\tint kk = k;\\n\\t\\twhile (kk > 0) {\\n\\t\\t\\tres[i] = q.poll();\\n\\t\\t\\ti++;\\n\\t\\t\\tkk--;\\n\\t\\t}\\n\\t\\t\\n\\t\\tArrays.sort(res, (a,b)->a[1]-b[1]);\\n\\t\\t\\n\\t\\tint[] result = new int[k];\\n\\t\\t\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tresult[i] = res[i][0];\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623316,
                "title": "c-o-n-log-n-sort-and-map",
                "content": "To get the max sum---> just sort a copy of the array and select last K elements.\\nBut while putting those elements into the answer vector, we need to maintain original array order.\\nTo do that we just use a map. \\nso finally we have this - \\n1) sort a copy of the array.\\n2) one by one insert last K elements (of this sorted copy), into the map with the elements frequency.\\n\\tbasically do ```mp[b[i]]++```.\\n3) Iterate over the original aray. If the element is present in map and has non zero frequency, then put it in answer vector. Also, in the map, reduce frequency of that element by 1.\\n4) Return answer vector.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        vector<int>b = a;\\n        sort(b.begin(),b.end());\\n        int n = a.size();\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        int i=n-1;\\n        while(k--){\\n            mp[b[i]]++;\\n            i--;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp.find(a[i])!=mp.end() and mp[a[i]]>0){\\n                ans.push_back(a[i]);\\n                mp[a[i]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```mp[b[i]]++```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& a, int k) {\\n        vector<int>b = a;\\n        sort(b.begin(),b.end());\\n        int n = a.size();\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        int i=n-1;\\n        while(k--){\\n            mp[b[i]]++;\\n            i--;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp.find(a[i])!=mp.end() and mp[a[i]]>0){\\n                ans.push_back(a[i]);\\n                mp[a[i]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637728,
                "title": "easy-to-understand-c-solution-min-heap-92-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({nums[i],i});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(auto p:vp){\\n            pq.push(p);\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<pair<int,int>>temp;\\n        while(!pq.empty()){\\n            temp.push_back({pq.top().second,pq.top().first});pq.pop();\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<int>ans;\\n        for(auto p:temp){\\n            ans.push_back(p.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({nums[i],i});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(auto p:vp){\\n            pq.push(p);\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<pair<int,int>>temp;\\n        while(!pq.empty()){\\n            temp.push_back({pq.top().second,pq.top().first});pq.pop();\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<int>ans;\\n        for(auto p:temp){\\n            ans.push_back(p.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621915,
                "title": "best-solution-using-heap",
                "content": "We can use a heap to store the greatest k elements from the list along with their indices. \\nOnce we have that we can use a set to store those indices and use that list to add the values to the answer. \\n\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        newNums = [[nums[i], i] for i in range(len(nums))]\\n        heap = []\\n        \\n        for i in range(len(nums)):\\n            heappush(heap, newNums[i])\\n            if len(heap) > k:\\n                heappop(heap)\\n        \\n        setOfIndex = set()\\n        for i in range(len(heap)):\\n            setOfIndex.add(heap[i][1])\\n\\n        maxSeq = []\\n        for i in range(len(nums)):\\n            if i in setOfIndex:\\n                maxSeq.append(nums[i])\\n            \\n        return maxSeq\\n\\t\\n```\\n            \\n        \\n                    \\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        newNums = [[nums[i], i] for i in range(len(nums))]\\n        heap = []\\n        \\n        for i in range(len(nums)):\\n            heappush(heap, newNums[i])\\n            if len(heap) > k:\\n                heappop(heap)\\n        \\n        setOfIndex = set()\\n        for i in range(len(heap)):\\n            setOfIndex.add(heap[i][1])\\n\\n        maxSeq = []\\n        for i in range(len(nums)):\\n            if i in setOfIndex:\\n                maxSeq.append(nums[i])\\n            \\n        return maxSeq\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605423,
                "title": "c-simple-priority-queue-beats-90-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> result;\\n        result.reserve(k);\\n        // min heap, pair: nums[i], index\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            // grow the window\\n            if (i < k) {\\n                pq.push({nums[i], i});\\n                continue;\\n            }\\n\\n            // nums[i] is greater than the smallest element\\n            if (nums[i] > pq.top().first) {\\n                pq.pop();     \\n                pq.push({nums[i], i});\\n            }\\n        }\\n\\n        // index, nums[i]\\n        vector<pair<int,int>> v;\\n        v.reserve(k);\\n        \\n        while (!pq.empty()) {\\n            v.emplace_back(pq.top().second, pq.top().first);\\n            pq.pop();\\n        }\\n\\n        sort(v.begin(), v.end());\\n        // v.size() will be k, so use k instead\\n        for (int i = 0; i < k; i++) {\\n            result.emplace_back(v[i].second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> result;\\n        result.reserve(k);\\n        // min heap, pair: nums[i], index\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            // grow the window\\n            if (i < k) {\\n                pq.push({nums[i], i});\\n                continue;\\n            }\\n\\n            // nums[i] is greater than the smallest element\\n            if (nums[i] > pq.top().first) {\\n                pq.pop();     \\n                pq.push({nums[i], i});\\n            }\\n        }\\n\\n        // index, nums[i]\\n        vector<pair<int,int>> v;\\n        v.reserve(k);\\n        \\n        while (!pq.empty()) {\\n            v.emplace_back(pq.top().second, pq.top().first);\\n            pq.pop();\\n        }\\n\\n        sort(v.begin(), v.end());\\n        // v.size() will be k, so use k instead\\n        for (int i = 0; i < k; i++) {\\n            result.emplace_back(v[i].second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496858,
                "title": "c-simple-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        multiset<int> mset;\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++){\\n            mset.insert(nums[i]);\\n        }\\n        while (mset.size()>k)mset.erase(mset.begin());\\n        for (int i=0; i<nums.size(); i++){\\n            auto it= mset.find(nums[i]);\\n            if (it!=mset.end()){\\n                ans.push_back(nums[i]);\\n                mset.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        multiset<int> mset;\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++){\\n            mset.insert(nums[i]);\\n        }\\n        while (mset.size()>k)mset.erase(mset.begin());\\n        for (int i=0; i<nums.size(); i++){\\n            auto it= mset.find(nums[i]);\\n            if (it!=mset.end()){\\n                ans.push_back(nums[i]);\\n                mset.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244087,
                "title": "java-5-ms-beats-94-87-with-priorityqueue",
                "content": "# Approach\\nWe will use PriorityQueue to hold indexes of the largest numbers.\\nThen we will use Set for fast checking if an index is in this set.\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(nums[o1], nums[o2]));\\n        for (int i = 0; i < nums.length; i++) {\\n            if (pq.size() < k) {\\n                pq.add(i); \\n            } else if (nums[pq.peek()] < nums[i]) {\\n                pq.poll(); // remove an index of the smallest number\\n                pq.add(i);\\n            }\\n        }        \\n        int[] res = new int[k];\\n        Set<Integer> indexes = new HashSet<>(pq);\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (indexes.contains(i)) {\\n                res[j++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPlease Upvote \\uD83D\\uDC4D if you find this helpful!\\n\\u041F\\u0440\\u043E\\u0433\\u0440\\u0430\\u043C\\u043C\\u0430 \\u043E\\u0431\\u0443\\u0447\\u0435\\u043D\\u0438\\u044F Java (RU): www.javatutor.ru",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(nums[o1], nums[o2]));\\n        for (int i = 0; i < nums.length; i++) {\\n            if (pq.size() < k) {\\n                pq.add(i); \\n            } else if (nums[pq.peek()] < nums[i]) {\\n                pq.poll(); // remove an index of the smallest number\\n                pq.add(i);\\n            }\\n        }        \\n        int[] res = new int[k];\\n        Set<Integer> indexes = new HashSet<>(pq);\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (indexes.contains(i)) {\\n                res[j++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225521,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(nums.size()==k) return nums;\\n        priority_queue<pair<int,int>>q;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) q.push({nums[i],i});\\n        vector<pair<int,int>>v;\\n        while(k--){\\n            v.push_back({q.top().second,q.top().first});\\n            q.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        for(auto x:v) ans.push_back(x.second);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(nums.size()==k) return nums;\\n        priority_queue<pair<int,int>>q;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) q.push({nums[i],i});\\n        vector<pair<int,int>>v;\\n        while(k--){\\n            v.push_back({q.top().second,q.top().first});\\n            q.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        for(auto x:v) ans.push_back(x.second);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120089,
                "title": "142ms-beats-100-simple-solution-with-explanation",
                "content": "# Intuition\\nKeep a copy of original array. Then sort original array and take first nums.Length-k numbers. Remove them one by one from the copy array of original array. Then we get the result. \\n\\n![image.png](https://assets.leetcode.com/users/images/6362b11c-703e-4f2a-9ec3-386e91ef0bdd_1675105714.419523.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k) {\\n        int len = nums.Length, index = 0;\\n        //to keep the order of original array\\n        var copy = new int[len];\\n        Array.Copy(nums,copy,len);\\n        Array.Sort(nums);\\n        var excludes = nums[0..(len-k)].ToList();\\n        var res = new int[k];\\n        foreach(var c in copy){\\n            if(excludes.Contains(c)){\\n                excludes.Remove(c);\\n            }\\n            else{\\n                res[index++] = c;                \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k) {\\n        int len = nums.Length, index = 0;\\n        //to keep the order of original array\\n        var copy = new int[len];\\n        Array.Copy(nums,copy,len);\\n        Array.Sort(nums);\\n        var excludes = nums[0..(len-k)].ToList();\\n        var res = new int[k];\\n        foreach(var c in copy){\\n            if(excludes.Contains(c)){\\n                excludes.Remove(c);\\n            }\\n            else{\\n                res[index++] = c;                \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779624,
                "title": "python-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea if to keep order of the max numbers and get the max sum at the same time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse min heap to track the largest number inside k values, use i to track all indexes\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        min_heap = []\\n        for i, n in enumerate(nums):\\n            heappush(min_heap, (n, i))\\n            if len(min_heap) > k:\\n                heappop(min_heap)\\n        min_heap.sort(key = lambda x: x[1])\\n        return [i[0] for i in min_heap]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        min_heap = []\\n        for i, n in enumerate(nums):\\n            heappush(min_heap, (n, i))\\n            if len(min_heap) > k:\\n                heappop(min_heap)\\n        min_heap.sort(key = lambda x: x[1])\\n        return [i[0] for i in min_heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764355,
                "title": "c-4ms-faster-than-96-95",
                "content": "Suppose nums = {5,2,3,-1,2,1,3}, k=4\\n\\nNums in Descending Order = {5,3,3,2,2,1,-1} \\nSo, our answer is 5,2,3,3\\n1. Copied the original vector to nums1 \\n2. Sorted nums1 in Descending Order.\\n3. Created a Unordered map and stored the first k elements in the map \\n4. Now a for loop to traverse nums and check if k>0 and the current element exists in the map, if it does we decrement it\\'s value by --large[nums[i]] and also --k.\\n#### WHY WE ARE DOING --large[nums[i]]? \\nAs we know our ans is 5,2,3,3 and nums = {5,2,3,-1,2,1,3}\\n* 5 exist in map? YES\\n* 2 exist in map? YES\\n* 3 exist in map? YES\\n* -1 exist in map? NO\\n* 2 exist in map? YE-(IF WE DIDN\\'T WRITE --large[nums[i]]) BUT WAIT\\n### WE NEED 2 ONLY 1 TIME, THAT\\'S WHY WE DID --large[nums[i]]\\n#####     SO 2 CAN\\'T BE TAKEN AS 2\\'S COUNT IS 0\\n* \\t1 exist in map? NO\\n* \\t3 exist in map? YES\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        vector<int>nums1=nums;\\n        sort(nums1.begin(),nums1.end(),greater<int>());\\n        unordered_map<int,int>large;\\n        for(int i=0; i<k; i++) ++large[nums1[i]];\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(k>0 && large[nums[i]])\\n            {\\n                ans.push_back(nums[i]);\\n                --large[nums[i]];\\n                --k;\\n            }\\n            else if(k<0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        vector<int>nums1=nums;\\n        sort(nums1.begin(),nums1.end(),greater<int>());\\n        unordered_map<int,int>large;\\n        for(int i=0; i<k; i++) ++large[nums1[i]];\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(k>0 && large[nums[i]])\\n            {\\n                ans.push_back(nums[i]);\\n                --large[nums[i]];\\n                --k;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2739140,
                "title": "87-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end(), greater<int>());\\n        \\n        map<int,int> greaterElements;\\n        for(int i=0; i<k; i++){\\n            greaterElements[temp[i]]++;\\n        }\\n        \\n        vector<int> result;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            auto itr = greaterElements.find(nums[i]);\\n            if(itr != greaterElements.end() and itr->second>0){\\n                result.push_back(nums[i]);\\n                itr->second--;\\n            }\\n                     \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end(), greater<int>());\\n        \\n        map<int,int> greaterElements;\\n        for(int i=0; i<k; i++){\\n            greaterElements[temp[i]]++;\\n        }\\n        \\n        vector<int> result;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            auto itr = greaterElements.find(nums[i]);\\n            if(itr != greaterElements.end() and itr->second>0){\\n                result.push_back(nums[i]);\\n                itr->second--;\\n            }\\n                     \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672485,
                "title": "java-solution-faster-100-2ms",
                "content": "class Solution {\\n\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] ans = new int[k];\\n        int sum = 0;\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = nums[i];\\n            sum += nums[i];\\n        }\\n\\n        for (int i = k; i< nums.length; i++) {\\n            int idx = 0;\\n            int small = ans[0];\\n            for (int j = 1; j < k; j++) {\\n                if (ans[j] < small) {\\n                    small = ans[j];\\n                    idx = j;\\n                }\\n            }\\n            if (small < nums[i]) {\\n                for (int m = idx + 1; m < k; m++) {\\n                    ans[m - 1] = ans[m];\\n                }\\n                ans[k-1] = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] ans = new int[k];\\n        int sum = 0;\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = nums[i];\\n            sum += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2671097,
                "title": "python-solution-faster-95",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\theap = []\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\theapq.heappush(heap, n)\\n\\t\\t\\t\\tif len(heap) > k:\\n\\t\\t\\t\\t\\theapq.heappop(heap)\\n\\t\\t\\tcnt = Counter(heap)\\n\\t\\t\\tres = []\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tif cnt[n] > 0:\\n\\t\\t\\t\\t\\tcnt[n] -= 1\\n\\t\\t\\t\\t\\tres.append(n)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\theap = []\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\theapq.heappush(heap, n)\\n\\t\\t\\t\\tif len(heap) > k:\\n\\t\\t\\t\\t\\theapq.heappop(heap)\\n\\t\\t\\tcnt = Counter(heap)\\n\\t\\t\\tres = []\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tif cnt[n] > 0:\\n\\t\\t\\t\\t\\tcnt[n] -= 1\\n\\t\\t\\t\\t\\tres.append(n)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2549154,
                "title": "c-simple-min-heap-solution",
                "content": "```\\ntypedef pair<int, int> pi;\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        if(n==k)return nums;\\n        \\n         priority_queue<pi, vector<pi>, greater<pi> > pq;\\n        for(int i=0;i<n;i++){    // sorting by value  (storing top k greater  value)\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)pq.pop();\\n        }\\n        priority_queue<pi, vector<pi>, greater<pi> > sort;\\n        while(!pq.empty()){        //sorting by index for subsequences\\n            sort.push({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n        while(!sort.empty()){     //pushing in ans\\n            ans.push_back(sort.top().second);\\n            sort.pop();\\n        }\\n            \\n        \\n        return ans;    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        if(n==k)return nums;\\n        \\n         priority_queue<pi, vector<pi>, greater<pi> > pq;\\n        for(int i=0;i<n;i++){    // sorting by value  (storing top k greater  value)\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)pq.pop();\\n        }\\n        priority_queue<pi, vector<pi>, greater<pi> > sort;\\n        while(!pq.empty()){        //sorting by index for subsequences\\n            sort.push({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n        while(!sort.empty()){     //pushing in ans\\n            ans.push_back(sort.top().second);\\n            sort.pop();\\n        }\\n            \\n        \\n        return ans;    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526454,
                "title": "easy-solution-map-priority-queue",
                "content": "```\\nclass Solution{\\npublic:\\n    typedef pair<int, int> pd;\\n    vector<int> maxSubsequence(vector<int> &nums, int k)\\n    {\\n        pair<int, int> p;\\n        priority_queue<pd, vector<pd>, greater<pd>> q;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            p = make_pair(nums[i], i);\\n            q.push(p);\\n            if (q.size() > k)\\n                q.pop();\\n        }\\n        map<int, int> m;\\n        while (!q.empty())\\n        {\\n            m.insert({q.top().second, q.top().first});\\n            q.pop();\\n        }\\n        vector<int> ans;\\n        for (auto itr : m)\\n            ans.push_back(itr.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    typedef pair<int, int> pd;\\n    vector<int> maxSubsequence(vector<int> &nums, int k)\\n    {\\n        pair<int, int> p;\\n        priority_queue<pd, vector<pd>, greater<pd>> q;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            p = make_pair(nums[i], i);\\n            q.push(p);\\n            if (q.size() > k)\\n                q.pop();\\n        }\\n        map<int, int> m;\\n        while (!q.empty())\\n        {\\n            m.insert({q.top().second, q.top().first});\\n            q.pop();\\n        }\\n        vector<int> ans;\\n        for (auto itr : m)\\n            ans.push_back(itr.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390383,
                "title": "python-all-solutions-using-sort-and-heap-sort-heap-one-liner",
                "content": "# Using sort\\n\\nTime: `O(nlogn)`\\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        arr = [(nums[i], i) for i in range(len(nums))]\\n        arr.sort(reverse=True)\\n\\n        arr = arr[:k]\\n        arr.sort(key=lambda k: k[1])\\n\\n        return [val[0] for val in arr]\\n\\n```\\n\\n# Using sort (one-liner)\\n\\nTime: `O(nlogn)`\\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        return [\\n            nums[x]\\n            for x in sorted(\\n                sorted(range(len(nums)), key=lambda k: nums[k], reverse=True)[:k]\\n            )\\n        ]\\n\\n```\\n\\n# Using heap\\n\\nTime: `O(klogn)`\\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        arr = [(-nums[i], i) for i in range(len(nums))]\\n        heapq.heapify(arr)\\n\\n        ans = []\\n        while k > 0:\\n            ans.append(heapq.heappop(arr))\\n            k -= 1\\n\\n        ans.sort(key=lambda k: k[1])\\n        return [-val[0] for val in ans]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        arr = [(nums[i], i) for i in range(len(nums))]\\n        arr.sort(reverse=True)\\n\\n        arr = arr[:k]\\n        arr.sort(key=lambda k: k[1])\\n\\n        return [val[0] for val in arr]\\n\\n```\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        return [\\n            nums[x]\\n            for x in sorted(\\n                sorted(range(len(nums)), key=lambda k: nums[k], reverse=True)[:k]\\n            )\\n        ]\\n\\n```\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        arr = [(-nums[i], i) for i in range(len(nums))]\\n        heapq.heapify(arr)\\n\\n        ans = []\\n        while k > 0:\\n            ans.append(heapq.heappop(arr))\\n            k -= 1\\n\\n        ans.sort(key=lambda k: k[1])\\n        return [-val[0] for val in ans]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206522,
                "title": "ridiculous-answer-tc-average-o-n-2-sc-o-1",
                "content": "**This is for entertainment purposes only and should not be used as an answer in the real world**\\n\\n```\\n\\tvector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\tif (k == 1) return {*max_element(nums.begin(), nums.end())};\\n\\t\\t\\n\\t\\twhile (nums.size() > k)\\n\\t\\t\\tnums.erase(min_element(nums.begin(), nums.end())); \\n\\n\\t\\treturn nums;\\n\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tvector<int> maxSubsequence(vector<int>& nums, int k) {\\n\\t\\tif (k == 1) return {*max_element(nums.begin(), nums.end())};\\n\\t\\t\\n\\t\\twhile (nums.size() > k)\\n\\t\\t\\tnums.erase(min_element(nums.begin(), nums.end())); \\n\\n\\t\\treturn nums;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110522,
                "title": "java-simple-and-easy-code-with-explanation-using-hashmap-no-priority-queue",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        // we\\'ll need hashmap because subsequence can\\'t be formed without it.\\n        // If we\\'ll just sort the array and find k largest from the array it will make a permutation not subsequence\\n        \\n        // Make a new array\\n        int[] arr = new int[nums.length];\\n        \\n        // Store all the values of original array in the new array\\n        for(int i = 0; i < nums.length; i++)\\n            arr[i] = nums[i];\\n        \\n        // sort the new array\\n        Arrays.sort(arr);\\n        \\n        // This hashmap will store k largest elements with their frequencies\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = nums.length - 1; i > nums.length - k - 1; i--){\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }\\n        \\n        // Now we\\'ll traverse the original array and store the elements one by one in the answer array(ans)\\n        int ans[] = new int[k];\\n        \\n        // We\\'ll keep on deleting elements from the hashmap once we found them in the original array\\n        for(int i = 0, j = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                ans[j++] = nums[i];\\n                if(map.get(nums[i]) == 1)\\n                    map.remove(nums[i]);\\n                else\\n                    map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        // we\\'ll need hashmap because subsequence can\\'t be formed without it.\\n        // If we\\'ll just sort the array and find k largest from the array it will make a permutation not subsequence\\n        \\n        // Make a new array\\n        int[] arr = new int[nums.length];\\n        \\n        // Store all the values of original array in the new array\\n        for(int i = 0; i < nums.length; i++)\\n            arr[i] = nums[i];\\n        \\n        // sort the new array\\n        Arrays.sort(arr);\\n        \\n        // This hashmap will store k largest elements with their frequencies\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = nums.length - 1; i > nums.length - k - 1; i--){\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }\\n        \\n        // Now we\\'ll traverse the original array and store the elements one by one in the answer array(ans)\\n        int ans[] = new int[k];\\n        \\n        // We\\'ll keep on deleting elements from the hashmap once we found them in the original array\\n        for(int i = 0, j = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                ans[j++] = nums[i];\\n                if(map.get(nums[i]) == 1)\\n                    map.remove(nums[i]);\\n                else\\n                    map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003152,
                "title": "soln-beating-98-86-c-sort",
                "content": "* I created cpy arr to store number as well as its index\\n* After sorting cpy arr will be sorted\\n* then i take out last k element\\'s index and i sort the ans\\n* form array of idx in ans and return it\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(k>nums.size())\\n            return {};\\n        if(k==nums.size())\\n            return nums;\\n        vector<pair<int,int>>cpy;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cpy.push_back({nums[i],i});\\n        }\\n        sort(cpy.begin(),cpy.end());\\n        vector<int> ans;\\n        for(int i=nums.size()-k;i<nums.size();i++)\\n            ans.push_back(cpy[i].second);\\n        sort(ans.begin(),ans.end());\\n        vector<int> finala;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            finala.push_back(nums[ans[i]]);\\n        }\\n        return finala;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(k>nums.size())\\n            return {};\\n        if(k==nums.size())\\n            return nums;\\n        vector<pair<int,int>>cpy;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cpy.push_back({nums[i],i});\\n        }\\n        sort(cpy.begin(),cpy.end());\\n        vector<int> ans;\\n        for(int i=nums.size()-k;i<nums.size();i++)\\n            ans.push_back(cpy[i].second);\\n        sort(ans.begin(),ans.end());\\n        vector<int> finala;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            finala.push_back(nums[ans[i]]);\\n        }\\n        return finala;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960424,
                "title": "go-lang-solution",
                "content": "```go\\nfunc maxSubsequence(nums []int, k int) []int {\\n    dupe := make([]int, len(nums))\\n    copy(dupe, nums)\\n    sort.Ints(dupe)\\n    \\n    seen := make(map[int]int, k)\\n    \\n    for _, val := range dupe[len(dupe) - k : ] {\\n        seen[val]++\\n    }\\n    \\n    ans := make([]int, 0, k)\\n    \\n    for _, val := range nums {\\n        if v, ok := seen[val]; ok && v > 0 {\\n            ans = append(ans, val)\\n            seen[val]--\\n        }\\n    }    \\n    \\n         \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxSubsequence(nums []int, k int) []int {\\n    dupe := make([]int, len(nums))\\n    copy(dupe, nums)\\n    sort.Ints(dupe)\\n    \\n    seen := make(map[int]int, k)\\n    \\n    for _, val := range dupe[len(dupe) - k : ] {\\n        seen[val]++\\n    }\\n    \\n    ans := make([]int, 0, k)\\n    \\n    for _, val := range nums {\\n        if v, ok := seen[val]; ok && v > 0 {\\n            ans = append(ans, val)\\n            seen[val]--\\n        }\\n    }    \\n    \\n         \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861305,
                "title": "javascript-easy-priority-queue-solution",
                "content": "```\\nconst maxSubsequence = function (nums, k) {\\n\\tconst heap = new MinPriorityQueue({\\n\\t\\tcompare: (el1, el2) => el1.number < el2.number,\\n\\t}), res = [];\\n    \\n\\tfor (let i = 0; i < nums.length; i++)\\n\\t\\theap.enqueue({ number: nums[i], position: i });\\n\\t\\n\\twhile (k--)\\n\\t\\tres.push(heap.dequeue());\\n\\n\\treturn res.sort((a, b) => a.position - b.position).map(v => v.number);\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst maxSubsequence = function (nums, k) {\\n\\tconst heap = new MinPriorityQueue({\\n\\t\\tcompare: (el1, el2) => el1.number < el2.number,\\n\\t}), res = [];\\n    \\n\\tfor (let i = 0; i < nums.length; i++)\\n\\t\\theap.enqueue({ number: nums[i], position: i });\\n\\t\\n\\twhile (k--)\\n\\t\\tres.push(heap.dequeue());\\n\\n\\treturn res.sort((a, b) => a.position - b.position).map(v => v.number);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1687145,
                "title": "java-easy-understanding-8ms-list-array",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int arr[] = Arrays.copyOfRange(nums, 0, nums.length);\\n        Arrays.sort(arr);\\n        for(int i=arr.length-1; i>=(arr.length-k); i--){\\n            list.add(arr[i]);\\n        }\\n        int res[] = new int[k];\\n        int ind = -1;\\n        int index;\\n        for(int i=0; i<nums.length; i++){\\n            index = list.indexOf(nums[i]);\\n            if(index != -1){\\n                list.remove(index);\\n                ind += 1;\\n                if(ind >= k)\\n                    break;\\n                res[ind] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int arr[] = Arrays.copyOfRange(nums, 0, nums.length);\\n        Arrays.sort(arr);\\n        for(int i=arr.length-1; i>=(arr.length-k); i--){\\n            list.add(arr[i]);\\n        }\\n        int res[] = new int[k];\\n        int ind = -1;\\n        int index;\\n        for(int i=0; i<nums.length; i++){\\n            index = list.indexOf(nums[i]);\\n            if(index != -1){\\n                list.remove(index);\\n                ind += 1;\\n                if(ind >= k)\\n                    break;\\n                res[ind] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655871,
                "title": "python3-heapq-o-nlogk",
                "content": "```python\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        res = []\\n        for i,n in enumerate(nums):\\n            if len(res) == k:\\n                heappushpop(res, (n, i))\\n            else:\\n                heappush(res, (n, i))\\n        return [x[0] for x in sorted(res, key=lambda x: x[1])]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        res = []\\n        for i,n in enumerate(nums):\\n            if len(res) == k:\\n                heappushpop(res, (n, i))\\n            else:\\n                heappush(res, (n, i))\\n        return [x[0] for x in sorted(res, key=lambda x: x[1])]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1645175,
                "title": "java-priority-queue-o-n-log-k-k-log-k-time-and-o-k-space",
                "content": "- The idea is that to get kth max sequence is using kth max elements. That can be solved similarly to this problem: https://leetcode.com/problems/kth-largest-element-in-an-array/. \\n- However, we\\'re not only storing the value but also the index so later, we can sort by the index later for the result. \\n- Complexity for PQ is O(N log K) since we only maintain K elements in the heap \\n- Complexity for sorting for the result is O(K log K) \\n- Time is O(K) in the heap.\\n\\n```java\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length; \\n        if (k == 0) return new int[0]; \\n        if (k == n) return nums;\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(pair -> pair[0])); \\n        \\n        for(int i = 0; i < n; i++) {\\n            minHeap.add(new int[] {nums[i], i});\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        \\n        int[][] res = new int[k][2]; \\n        for(int i = 0; i < k; i++) {\\n            res[i] = minHeap.poll();\\n        }\\n        \\n        Arrays.sort(res, Comparator.comparingInt(pair -> pair[1]));\\n        return Arrays.stream(res).map(pair -> pair[0]).mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length; \\n        if (k == 0) return new int[0]; \\n        if (k == n) return nums;\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(pair -> pair[0])); \\n        \\n        for(int i = 0; i < n; i++) {\\n            minHeap.add(new int[] {nums[i], i});\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        \\n        int[][] res = new int[k][2]; \\n        for(int i = 0; i < k; i++) {\\n            res[i] = minHeap.poll();\\n        }\\n        \\n        Arrays.sort(res, Comparator.comparingInt(pair -> pair[1]));\\n        return Arrays.stream(res).map(pair -> pair[0]).mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642701,
                "title": "c-solution-faster-than-94-47",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int,int> a,const pair<int,int> b){\\n        return a.second<b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        while(!pq.empty()){\\n            int num=pq.top().first;\\n            int pos=pq.top().second;\\n            pq.pop();\\n            v.push_back({num,pos});\\n        }\\n        vector<int> ans;\\n        sort(v.begin(),v.end(),comp);\\n        for(auto it:v){\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int,int> a,const pair<int,int> b){\\n        return a.second<b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        while(!pq.empty()){\\n            int num=pq.top().first;\\n            int pos=pq.top().second;\\n            pq.pop();\\n            v.push_back({num,pos});\\n        }\\n        vector<int> ans;\\n        sort(v.begin(),v.end(),comp);\\n        for(auto it:v){\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639621,
                "title": "c-easy-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!pq.empty())\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            ans.push_back({x.second,x.first});\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>res;\\n        for(auto i:ans)\\n            res.push_back(i.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!pq.empty())\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            ans.push_back({x.second,x.first});\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>res;\\n        for(auto i:ans)\\n            res.push_back(i.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635474,
                "title": "python-optimized-solution-with-heap",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        import heapq\\n        \\n        h = []\\n        n = len(nums)\\n        for i in range(n):\\n            heapq.heappush(h, (-nums[i], i))\\n            \\n        res = []\\n        for _ in range(k):\\n            v, idx = heapq.heappop(h)\\n            res.append(idx)\\n        res.sort()\\n        return [nums[idx] for idx in res]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        import heapq\\n        \\n        h = []\\n        n = len(nums)\\n        for i in range(n):\\n            heapq.heappush(h, (-nums[i], i))\\n            \\n        res = []\\n        for _ in range(k):\\n            v, idx = heapq.heappop(h)\\n            res.append(idx)\\n        res.sort()\\n        return [nums[idx] for idx in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626859,
                "title": "easy-python3-solution",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        valindex=sorted([(num,i) for i,num in enumerate(nums)],reverse=True)\\n        return [num for num,i in sorted(valindex[:k],key=lambda x:x[1])]\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        valindex=sorted([(num,i) for i,num in enumerate(nums)],reverse=True)\\n        return [num for num,i in sorted(valindex[:k],key=lambda x:x[1])]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626547,
                "title": "javascript-solution-88ms",
                "content": "**With comments**\\n```\\nvar maxSubsequence = function(nums, k) {\\n\\t// instantiate the result array, also the set the length of nums to a variable\\n    let result = [], len = nums.length\\n\\t\\n\\t// clone the nums array into a new array. Use this to retain the original index of each number\\n    numsIndex = nums.map(i => i)\\n\\t\\n\\t// sort the nums array in ascending order\\n    nums.sort((a, b) => { return a - b })\\n\\t\\n\\t// create a variable to store the largest \\'k\\' amount of numbers\\n\\t// slice the nums array with the value of \\'nums.length\\' minus\\'k\\'. \\n\\t// This will return an array with the \\'k\\' amount of largest numbers, but they may be in the wrong order\\n    let largeNums = nums.slice(len-k)\\n\\t\\n\\t// loop through the cloned nums array\\n    for(let i = 0; i < len; i++){\\n\\t\\n\\t\\t// if the large numbers array contains the number in the cloned nums array at index \\'i\\'...\\n        if(largeNums.includes(numsIndex[i])){\\n\\t\\t\\n\\t\\t\\t// push the number to the result array\\n            result.push(numsIndex[i])\\n\\t\\t\\t\\n\\t\\t\\t// this next step is important, grab the index of the number inside of the large nums array...\\n            let largeNumsIndex = largeNums.indexOf(numsIndex[i])\\n\\t\\t\\t\\n\\t\\t\\t// and remove it. This is done so that if there are duplicates of the number we just pushed to our results array\\n\\t\\t\\t// present in the cloned array they will not be found **again** in the large nums array\\n            largeNums.splice(largeNumsIndex, 1)\\n        }\\n    } \\n\\t// return the result array\\n    return result\\n};\\n```\\n**Just code**\\n```\\nvar maxSubsequence = function(nums, k) {\\n    let result = [], len = nums.length\\n    numsIndex = nums.map(i => i)\\n    nums.sort((a, b) => { return a - b })\\n    let largeNums = nums.slice(len-k)\\n    for(let i = 0; i < len; i++){\\n        if(largeNums.includes(numsIndex[i])){\\n            result.push(numsIndex[i])\\n            let largeNumsIndex = largeNums.indexOf(numsIndex[i])\\n            largeNums.splice(largeNumsIndex, 1)\\n        }\\n    }            \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubsequence = function(nums, k) {\\n\\t// instantiate the result array, also the set the length of nums to a variable\\n    let result = [], len = nums.length\\n\\t\\n\\t// clone the nums array into a new array. Use this to retain the original index of each number\\n    numsIndex = nums.map(i => i)\\n\\t\\n\\t// sort the nums array in ascending order\\n    nums.sort((a, b) => { return a - b })\\n\\t\\n\\t// create a variable to store the largest \\'k\\' amount of numbers\\n\\t// slice the nums array with the value of \\'nums.length\\' minus\\'k\\'. \\n\\t// This will return an array with the \\'k\\' amount of largest numbers, but they may be in the wrong order\\n    let largeNums = nums.slice(len-k)\\n\\t\\n\\t// loop through the cloned nums array\\n    for(let i = 0; i < len; i++){\\n\\t\\n\\t\\t// if the large numbers array contains the number in the cloned nums array at index \\'i\\'...\\n        if(largeNums.includes(numsIndex[i])){\\n\\t\\t\\n\\t\\t\\t// push the number to the result array\\n            result.push(numsIndex[i])\\n\\t\\t\\t\\n\\t\\t\\t// this next step is important, grab the index of the number inside of the large nums array...\\n            let largeNumsIndex = largeNums.indexOf(numsIndex[i])\\n\\t\\t\\t\\n\\t\\t\\t// and remove it. This is done so that if there are duplicates of the number we just pushed to our results array\\n\\t\\t\\t// present in the cloned array they will not be found **again** in the large nums array\\n            largeNums.splice(largeNumsIndex, 1)\\n        }\\n    } \\n\\t// return the result array\\n    return result\\n};\\n```\n```\\nvar maxSubsequence = function(nums, k) {\\n    let result = [], len = nums.length\\n    numsIndex = nums.map(i => i)\\n    nums.sort((a, b) => { return a - b })\\n    let largeNums = nums.slice(len-k)\\n    for(let i = 0; i < len; i++){\\n        if(largeNums.includes(numsIndex[i])){\\n            result.push(numsIndex[i])\\n            let largeNumsIndex = largeNums.indexOf(numsIndex[i])\\n            largeNums.splice(largeNumsIndex, 1)\\n        }\\n    }            \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624184,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>>temp;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back({nums[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<pair<int,int>>ans;\\n        //int n=nums.size();\\n        for(int i=n-1;i>=n-k;i--)\\n            ans.push_back({temp[i].second,temp[i].first});\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n            v.push_back(ans[i].second);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>>temp;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back({nums[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<pair<int,int>>ans;\\n        //int n=nums.size();\\n        for(int i=n-1;i>=n-k;i--)\\n            ans.push_back({temp[i].second,temp[i].first});\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n            v.push_back(ans[i].second);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623904,
                "title": "rust-solution-with-sort",
                "content": "```\\nimpl Solution {\\n    pub fn max_subsequence(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == nums.len() as i32 || nums.len() == 1 {\\n            return nums;\\n        }\\n\\n        let mut num_idx = nums.iter().enumerate().collect::<Vec<_>>();\\n        num_idx.sort_unstable_by_key(|(_, x)| **x);\\n\\n        let mut idx = vec![false; nums.len()];\\n        num_idx\\n            .into_iter()\\n            .rev()\\n            .take(k as usize)\\n            .for_each(|(i, _)| idx[i] = true);\\n\\n        nums.into_iter()\\n            .enumerate()\\n            .filter_map(|(i, x)| if idx[i] { Some(x) } else { None })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_subsequence(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == nums.len() as i32 || nums.len() == 1 {\\n            return nums;\\n        }\\n\\n        let mut num_idx = nums.iter().enumerate().collect::<Vec<_>>();\\n        num_idx.sort_unstable_by_key(|(_, x)| **x);\\n\\n        let mut idx = vec![false; nums.len()];\\n        num_idx\\n            .into_iter()\\n            .rev()\\n            .take(k as usize)\\n            .for_each(|(i, _)| idx[i] = true);\\n\\n        nums.into_iter()\\n            .enumerate()\\n            .filter_map(|(i, x)| if idx[i] { Some(x) } else { None })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623420,
                "title": "easy-solution-o-nlogn-dictionary",
                "content": "```\\n\\tsol=[]\\n        dic={}\\n        for i in sorted(nums)[-k:]:\\n            dic[i]=dic.get(i,0)+1\\n        for i in nums:\\n            \\n            if i in dic and dic[i]>0:\\n                sol.append(i)\\n                dic[i]-=1\\n        return sol\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\tsol=[]\\n        dic={}\\n        for i in sorted(nums)[-k:]:\\n            dic[i]=dic.get(i,0)+1\\n        for i in nums:\\n            \\n            if i in dic and dic[i]>0:\\n                sol.append(i)\\n                dic[i]-=1\\n        return sol\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623298,
                "title": "java-easy-understand-explained-with-comments",
                "content": "Use [index, number] to keep relationship of index and number\\nUse heap to filter largest numbers and then sort by index\\n\\n```\\npublic class Solution {\\n  public int[] maxSubsequence(int[] nums, int k) {\\n    int n = nums.length;\\n    // [index, number]\\n    PriorityQueue<int[]> heap = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n    for (int i = 0; i < n; i++) {\\n      heap.add(new int[] {i, nums[i]});\\n      if (heap.size() > k) {\\n        heap.poll();\\n      }\\n    }\\n\\n    // sort by index\\n    List<int[]> list = new ArrayList<>(heap);\\n    list.sort(Comparator.comparingInt(a -> a[0]));\\n\\n    int[] result = new int[k];\\n    for (int i = 0; i < k; i++) {\\n      result[i] = list.get(i)[1];\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n  public int[] maxSubsequence(int[] nums, int k) {\\n    int n = nums.length;\\n    // [index, number]\\n    PriorityQueue<int[]> heap = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n    for (int i = 0; i < n; i++) {\\n      heap.add(new int[] {i, nums[i]});\\n      if (heap.size() > k) {\\n        heap.poll();\\n      }\\n    }\\n\\n    // sort by index\\n    List<int[]> list = new ArrayList<>(heap);\\n    list.sort(Comparator.comparingInt(a -> a[0]));\\n\\n    int[] result = new int[k];\\n    for (int i = 0; i < k; i++) {\\n      result[i] = list.get(i)[1];\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002648,
                "title": "minheap-solution-in-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the k largest elements in the array and return them in order of there indexes in the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse a minheap to find the largest k elements in the array. also store the indexes of elements in the heap. then use another minheap to sort the elements by there indexes.  \\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int> , vector<pair<int,int>>,greater<pair<int,int>> > pq;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i],i});\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>>,greater<pair<int,int>> > temp;\\n\\n        while(!pq.empty()){\\n            temp.push({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n\\n        vector<int> ans;\\n        while(!temp.empty()){\\n            ans.push_back(temp.top().second);\\n            temp.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int> , vector<pair<int,int>>,greater<pair<int,int>> > pq;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i],i});\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>>,greater<pair<int,int>> > temp;\\n\\n        while(!pq.empty()){\\n            temp.push({pq.top().second,pq.top().first});\\n            pq.pop();\\n        }\\n\\n        vector<int> ans;\\n        while(!temp.empty()){\\n            ans.push_back(temp.top().second);\\n            temp.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592800,
                "title": "java-solution",
                "content": "\\nclass Solution {\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\t\\t\\n\\t\\tint l=nums.length;\\n\\t\\tint[] nums1=new int[l];\\n\\n\\t\\tfor(int i=0;i<l;i++) {\\n\\t\\t\\tnums1[i]=nums[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\tArrays.sort(nums1);\\n\\t\\t\\n\\t\\tint[] ret=new int[k];\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor(int i=l-k;i<l;i++) {\\n\\t\\t\\tlist.add(nums1[i]);\\n\\t\\t}\\n\\n\\t\\tint v=0;\\n\\t\\t\\n\\t\\tfor(int j=0;j<l;j++) {\\n\\t\\t\\tfor(int i=0;i<list.size();i++) {\\n\\t\\t\\t\\tif(nums[j]==list.get(i)) {\\n\\t\\t\\t\\t\\tret[v]=list.get(i);\\n\\t\\t\\t\\t\\tlist.remove(i);\\n\\t\\t\\t\\t\\tv++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(v==k) break;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\t\\t\\n\\t\\tint l=nums.length;\\n\\t\\tint[] nums1=new int[l];\\n\\n\\t\\tfor(int i=0;i<l;i++) {\\n\\t\\t\\tnums1[i]=nums[i];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3456885,
                "title": "javascript-solution-5-steps",
                "content": "# Don\\'t think too much\\nAs the question tell us need to stay the same order, we can\\'t use some magic way to solve it.\\nTherefore:\\n#### step 1: Save original index\\n#### step 2: Sort it by its value\\n#### step 3: Slice k elements\\n#### step 4: Make it up by its index order\\n#### step 5: Filter empty elements\\n\\nThen you get it.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    nums = nums.map((n,i) => [i, n])\\n    \\n    nums.sort((a,b) => b[1] - a[1])\\n\\t\\n    let arr = nums.slice(0, k)\\n    let res = []\\n    \\n    for(let i of arr) {\\n        res[i[0]] = i[1]\\n    }\\n    \\n    return res.filter(i=>i !== undefined)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    nums = nums.map((n,i) => [i, n])\\n    \\n    nums.sort((a,b) => b[1] - a[1])\\n\\t\\n    let arr = nums.slice(0, k)\\n    let res = []\\n    \\n    for(let i of arr) {\\n        res[i[0]] = i[1]\\n    }\\n    \\n    return res.filter(i=>i !== undefined)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3387241,
                "title": "easy-java-solution-sorting-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we create a clone of the given array, and sort the cloned array. \\nAs we want to find the largest sum, we consider elements bigger elements first. So, we store the count of each element starting from the end of array till we find k bigger elements. \\nNext, for each element in original array, we check if it is present in the map, if yes, then we add the element in the result array and reduce count by 1, else we continue. (We check elements according the original array because we need to find a subsequence, which has to ordered).\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n\\n        int n = nums.length;\\n\\n        if(k == nums.length){\\n            return nums;\\n        }\\n\\n        int[] temp = nums.clone();\\n        Arrays.sort(temp);\\n        \\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = n - 1; i >= n - k; i--){\\n            count.put(temp[i], count.getOrDefault(temp[i], 0) + 1);\\n        }\\n\\n        int[] res = new int[k];\\n        int index = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(count.containsKey(nums[i])){\\n                int val = count.get(nums[i]);\\n                res[index++] = nums[i];\\n                if(val == 1){\\n                    count.remove(nums[i]);\\n                }\\n                else{\\n                    count.put(nums[i], --val);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n\\n        int n = nums.length;\\n\\n        if(k == nums.length){\\n            return nums;\\n        }\\n\\n        int[] temp = nums.clone();\\n        Arrays.sort(temp);\\n        \\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = n - 1; i >= n - k; i--){\\n            count.put(temp[i], count.getOrDefault(temp[i], 0) + 1);\\n        }\\n\\n        int[] res = new int[k];\\n        int index = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(count.containsKey(nums[i])){\\n                int val = count.get(nums[i]);\\n                res[index++] = nums[i];\\n                if(val == 1){\\n                    count.remove(nums[i]);\\n                }\\n                else{\\n                    count.put(nums[i], --val);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290821,
                "title": "1-linear-python-solution-99-82-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->we have to sort the array and take the last k elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReturn them according to their indexes in ascending way\\nsort indexes using Lambda founction.\\n.............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................//////////Please Upvote Guys/////\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        return [i[0] for i in sorted(sorted([[j,i] for i,j in enumerate(nums)])[-k:],key=lambda g:g[1])]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        return [i[0] for i in sorted(sorted([[j,i] for i,j in enumerate(nums)])[-k:],key=lambda g:g[1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222570,
                "title": "easy-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>>vec;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            vec.push_back({nums[i],i});\\n        }\\n        \\n        priority_queue<pair<int,int>>pq(vec.begin(),vec.end());\\n        \\n        vector<pair<int,int>>p;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            pair<int,int>tp=pq.top();\\n            pq.pop();\\n            p.push_back({tp.second,tp.first});\\n        }\\n        \\n        sort(p.begin(),p.end());\\n        \\n        vector<int>ans;\\n        \\n        for(auto it:p)\\n            ans.push_back(it.second);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>>vec;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            vec.push_back({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 3101116,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n        nums\\n            .enumerated()\\n            .sorted { $0.element > $1.element }\\n            .prefix(k)\\n            .sorted { $0.offset < $1.offset }\\n            .map { $0.element }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n        nums\\n            .enumerated()\\n            .sorted { $0.element > $1.element }\\n            .prefix(k)\\n            .sorted { $0.offset < $1.offset }\\n            .map { $0.element }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092346,
                "title": "find-subsequence-of-length-k-with-the-largest-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        max_list = sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_list:\\n                result.append(num)\\n                max_list.remove(num)\\n                if len(max_list) == 0:\\n                    return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        max_list = sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_list:\\n                result.append(num)\\n                max_list.remove(num)\\n                if len(max_list) == 0:\\n                    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043739,
                "title": "6-lines-solution-using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. use index to record the index of nums.\\n2. sort index by nums[o2] - nums[o1].\\n3. sort index.range: 0 --> k.\\n4. fill result and return.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] result = new int[k];;\\n        int[] index = IntStream.range(0, nums.length).boxed().sorted((o1, o2) -> nums[o2] - nums[o1])\\n                .mapToInt(Integer::intValue).toArray();\\n\\n        Arrays.sort(index, 0, k);\\n\\n        for (int i = 0; i < k; i++)\\n            result[i] = nums[index[i]];\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] result = new int[k];;\\n        int[] index = IntStream.range(0, nums.length).boxed().sorted((o1, o2) -> nums[o2] - nums[o1])\\n                .mapToInt(Integer::intValue).toArray();\\n\\n        Arrays.sort(index, 0, k);\\n\\n        for (int i = 0; i < k; i++)\\n            result[i] = nums[index[i]];\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925558,
                "title": "easy-solution-using-priority-queue",
                "content": "# A Basic Fact:\\n**We can use Priority Queues as MAX/MIN Heap and can be easily used in various languages. Like here I used them with STL(C++).**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        // Taking the priority queue as a pair for taking account of the \\n        // value and its index\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> v,v1;\\n        \\n        // Insert the values from the array and its index\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n\\n        // Here too take a pair so that you can insert the index value in\\n        // another array.\\n        pair<int,int> temp;\\n        while(k--){\\n            temp = pq.top();\\n            v.push_back(temp.second);\\n            pq.pop();\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        // Now insert the values from the indices\\n        for(int i=0;i<v.size();i++){\\n            v1.push_back(nums[v[i]]);\\n        }\\n\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        // Taking the priority queue as a pair for taking account of the \\n        // value and its index\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> v,v1;\\n        \\n        // Insert the values from the array and its index\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n\\n        // Here too take a pair so that you can insert the index value in\\n        // another array.\\n        pair<int,int> temp;\\n        while(k--){\\n            temp = pq.top();\\n            v.push_back(temp.second);\\n            pq.pop();\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        // Now insert the values from the indices\\n        for(int i=0;i<v.size();i++){\\n            v1.push_back(nums[v[i]]);\\n        }\\n\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908302,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    let sorted = [...nums].sort((a,b)=>a-b);\\n    let arr = sorted.splice(nums.length-k);\\n    let res = [];\\n    for(let i =0; i<nums.length; i++){\\n        if(arr.includes(nums[i])){\\n            res.push(nums[i]);\\n            arr.splice(arr.indexOf(nums[i]),1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSubsequence = function(nums, k) {\\n    let sorted = [...nums].sort((a,b)=>a-b);\\n    let arr = sorted.splice(nums.length-k);\\n    let res = [];\\n    for(let i =0; i<nums.length; i++){\\n        if(arr.includes(nums[i])){\\n            res.push(nums[i]);\\n            arr.splice(arr.indexOf(nums[i]),1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805814,
                "title": "easiest-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n    PriorityQueue<int[]>pq=new PriorityQueue<>((a, b) -> b[0]-a[0]);\\n\\n    for(int i=0;i<nums.length;i++){\\n        \\n        pq.add(new int[]{nums[i],i});\\n    \\n    }\\n\\n    int[]check=new int[k];\\n    \\n    int i=0;\\n    int n=k;\\n    while(n>0){\\n    int m[]=pq.poll();\\n    check[i++]=m[1];\\n    n--;\\n    }\\n\\n    Arrays.sort(check);\\n\\n    int []ans=new int[k];\\n\\n    for(int j=0;j<k;j++){\\n        ans[j]=nums[check[j]];\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n    PriorityQueue<int[]>pq=new PriorityQueue<>((a, b) -> b[0]-a[0]);\\n\\n    for(int i=0;i<nums.length;i++){\\n        \\n        pq.add(new int[]{nums[i],i});\\n    \\n    }\\n\\n    int[]check=new int[k];\\n    \\n    int i=0;\\n    int n=k;\\n    while(n>0){\\n    int m[]=pq.poll();\\n    check[i++]=m[1];\\n    n--;\\n    }\\n\\n    Arrays.sort(check);\\n\\n    int []ans=new int[k];\\n\\n    for(int j=0;j<k;j++){\\n        ans[j]=nums[check[j]];\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719013,
                "title": "c-easy-solution-with-vector-faster-than-62-70",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res;\\n        vector<int> result;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        for(int i = temp.size()-k; i<temp.size(); i++)\\n            res.push_back(temp[i]);\\n        \\n        for(auto it:nums)\\n        {\\n            auto idx = find(res.begin(),res.end(),it);\\n            if(idx!=res.end())\\n            {\\n                result.push_back(it);\\n                res.erase(res.begin()+(idx-res.begin()));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> res;\\n        vector<int> result;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        for(int i = temp.size()-k; i<temp.size(); i++)\\n            res.push_back(temp[i]);\\n        \\n        for(auto it:nums)\\n        {\\n            auto idx = find(res.begin(),res.end(),it);\\n            if(idx!=res.end())\\n            {\\n                result.push_back(it);\\n                res.erase(res.begin()+(idx-res.begin()));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628095,
                "title": "python-heap",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        pp=nums[:]\\n        heapq.heapify(nums)\\n        \\n        \\n        while(len(nums)>k):\\n            ll=heapq.heappop(nums)\\n            pp.remove(ll)\\n            \\n        return pp\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        pp=nums[:]\\n        heapq.heapify(nums)\\n        \\n        \\n        while(len(nums)>k):\\n            ll=heapq.heappop(nums)\\n            pp.remove(ll)\\n            \\n        return pp\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609156,
                "title": "max-heap-and-sorting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> q;\\n        // tmp array to store index for max elements\\n        vector<int> ans, tmp;\\n        \\n        for(int i=0; i<nums.size(); i++) q.push({nums[i], i});\\n        while(k--){\\n            auto a = q.top();\\n            q.pop();\\n            tmp.push_back(a.second);\\n        }\\n        \\n        sort(tmp.begin(), tmp.end());\\n        \\n        for(int i=0; i<tmp.size(); i++){\\n            ans.push_back(nums[tmp[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> q;\\n        // tmp array to store index for max elements\\n        vector<int> ans, tmp;\\n        \\n        for(int i=0; i<nums.size(); i++) q.push({nums[i], i});\\n        while(k--){\\n            auto a = q.top();\\n            q.pop();\\n            tmp.push_back(a.second);\\n        }\\n        \\n        sort(tmp.begin(), tmp.end());\\n        \\n        for(int i=0; i<tmp.size(); i++){\\n            ans.push_back(nums[tmp[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590912,
                "title": "c-priority-queue-runtime-6ms-faster-than-96-68",
                "content": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<pair<int,int>> ans;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n            if(pq.size()>k) pq.pop();\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto x=pq.top();\\n            ans.push_back({x.second,x.first});\\n            pq.pop();\\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        vector<int> res;\\n        \\n        for(auto i:ans)\\n        {\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<pair<int,int>> ans;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2562428,
                "title": "easiest-c-solution-without-any-dirty-hashing-priority-queue",
                "content": "Firstly, you should read the question correctly. All that has really been asked is to print the largest k elements in increasing order of their occurance (index).\\n\\nSo we can create a vector of pairs `{a[i], i}` and sort in a descending order. Next we just have to re-sort the first k elements in ascending order with respect to the second value in the pair (i.e index of its occurance in the array).\\n\\nComplete solution:\\n\\n```cpp\\nbool cmp(const pair<int,int> &a, const pair<int,int> &b)\\n{\\n    return a.second < b.second;\\n}\\n\\nvector<int> maxSubsequence(vector<int>& a, int k) \\n{\\n    int n = a.size();\\n    vector<int> ans;\\n    vector<pair<int, int> > vec;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        vec.push_back({a[i], i});\\n    }\\n    \\n    sort(vec.rbegin(), vec.rend());\\n    sort(vec.begin(), vec.begin() + k, cmp);\\n    \\n    for(int i=0;i<k;i++)\\n    {\\n        ans.push_back(vec[i].first);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```cpp\\nbool cmp(const pair<int,int> &a, const pair<int,int> &b)\\n{\\n    return a.second < b.second;\\n}\\n\\nvector<int> maxSubsequence(vector<int>& a, int k) \\n{\\n    int n = a.size();\\n    vector<int> ans;\\n    vector<pair<int, int> > vec;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        vec.push_back({a[i], i});\\n    }\\n    \\n    sort(vec.rbegin(), vec.rend());\\n    sort(vec.begin(), vec.begin() + k, cmp);\\n    \\n    for(int i=0;i<k;i++)\\n    {\\n        ans.push_back(vec[i].first);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503216,
                "title": "minheap-based-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pd;\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        pair<int,int> p;\\n        priority_queue<pd,vector<pd>, greater<pd>> q;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            p=make_pair(nums[i],i);\\n            q.push(p);\\n            if(q.size()>k) q.pop();\\n        }\\n        \\n        map<int,int> m;\\n     \\n        while(!q.empty()){\\n            m.insert({q.top().second, q.top().first});\\n            q.pop();\\n        }\\n\\n        vector<int>ans;\\n        for(auto itr:m) ans.push_back(itr.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pd;\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        pair<int,int> p;\\n        priority_queue<pd,vector<pd>, greater<pd>> q;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            p=make_pair(nums[i],i);\\n            q.push(p);\\n            if(q.size()>k) q.pop();\\n        }\\n        \\n        map<int,int> m;\\n     \\n        while(!q.empty()){\\n            m.insert({q.top().second, q.top().first});\\n            q.pop();\\n        }\\n\\n        vector<int>ans;\\n        for(auto itr:m) ans.push_back(itr.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466980,
                "title": "python-easy-solution-without-using-heapq",
                "content": "**Please upvote!! if you like the solution/ description**\\n```\\n\"\"\"\\nEssentially 3 steps are required here:\\nStep 1. create list of tuples (num, index_of_num)\\nStep 2. Sorting them by num\\nStep 3. fetch last k item, to make sure placing -ve values at right index, we would sort again by index\\n\\nNOTE: Step 3, makes sure -ve values are added in right order of index\\n\"\"\"\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        _nums = []\\n        \\n        # create list of tuples (num, index) \\n        # [(2, 0), (1, 1), (3, 2), (3, 3)]\\n        for i, num in enumerate(nums):\\n            _nums.append((num, i))\\n\\n        # sort it by \"num\" in the _nums(num, index)\\n        #[(1, 1), (2, 0), (3, 2), (3, 3)]\\n        _nums = sorted(_nums)\\n        \\n        # take the num of last k, that should give you the result\\n        #[(3, 2), (3, 3)]\\n        # we are sorting again by index to take care if -naegative values\\n        # example:\\n        #       [(50, 0), (-75, 1)] => after creating list of tuple\\n        #       [(-75, 1), (50, 0)] => after sorting by nums\\n        #       [(50, 0), (-75, 1)] => now sorted by index  to place -ve value index at correct place\\n        \\n        return [ _[0] for _ in sorted(_nums[-k:], key = lambda x: x[1])]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nEssentially 3 steps are required here:\\nStep 1. create list of tuples (num, index_of_num)\\nStep 2. Sorting them by num\\nStep 3. fetch last k item, to make sure placing -ve values at right index, we would sort again by index\\n\\nNOTE: Step 3, makes sure -ve values are added in right order of index\\n\"\"\"\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        _nums = []\\n        \\n        # create list of tuples (num, index) \\n        # [(2, 0), (1, 1), (3, 2), (3, 3)]\\n        for i, num in enumerate(nums):\\n            _nums.append((num, i))\\n\\n        # sort it by \"num\" in the _nums(num, index)\\n        #[(1, 1), (2, 0), (3, 2), (3, 3)]\\n        _nums = sorted(_nums)\\n        \\n        # take the num of last k, that should give you the result\\n        #[(3, 2), (3, 3)]\\n        # we are sorting again by index to take care if -naegative values\\n        # example:\\n        #       [(50, 0), (-75, 1)] => after creating list of tuple\\n        #       [(-75, 1), (50, 0)] => after sorting by nums\\n        #       [(50, 0), (-75, 1)] => now sorted by index  to place -ve value index at correct place\\n        \\n        return [ _[0] for _ in sorted(_nums[-k:], key = lambda x: x[1])]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2443793,
                "title": "yet-another-python-solutuion-o-nlog-k",
                "content": "1. Create a min-heap and push the first K elements as a tuple of two values: 1) the value of the array nums and 2) the corresponding index in the array. Thus, for each element, we save the index.\\n2. Loop for the array nums starting from element k. If the lowest heap element is lower than iterated element - replace it (push a new and pop minumum). Thus, we always keep top-k maximum elements in the heap.\\n3. Sort the heap by the index of the element.\\n4. Return the values.\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        nums_heap = []\\n        heapq.heapify(nums_heap)\\n        for i, n in enumerate(nums[:k]):\\n            heapq.heappush(nums_heap, (n, i))\\n        \\n        for i in range(k, len(nums)):\\n            if nums[i] > nums_heap[0][0]:\\n                heapq.heappushpop(nums_heap, (nums[i], i))\\n        \\n        nums_heap.sort(key = lambda x: x[1])\\n        \\n        return [x[0] for x in nums_heap]\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        \\n        nums_heap = []\\n        heapq.heapify(nums_heap)\\n        for i, n in enumerate(nums[:k]):\\n            heapq.heappush(nums_heap, (n, i))\\n        \\n        for i in range(k, len(nums)):\\n            if nums[i] > nums_heap[0][0]:\\n                heapq.heappushpop(nums_heap, (nums[i], i))\\n        \\n        nums_heap.sort(key = lambda x: x[1])\\n        \\n        return [x[0] for x in nums_heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438283,
                "title": "c-fast-priority-queue-solution-148ms-98",
                "content": "```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k) \\n    {\\n        if(nums.Length <= k) return nums;\\n        \\n        var pq = new PriorityQueue<int, int>();\\n        \\n        for(var i=0; i<nums.Length; i++)\\n        {\\n            pq.Enqueue(i, nums[i]);\\n            \\n            if(pq.Count > k)\\n                pq.Dequeue();\\n        }\\n        \\n        var selected = new bool[nums.Length];\\n        \\n        while(pq.Count > 0)\\n        {\\n            selected[pq.Dequeue()] = true;\\n        }\\n        \\n        var result = new List<int>(k);\\n        \\n        for(var i=0; i<nums.Length; i++)\\n        {\\n            if(selected[i])\\n            {\\n                result.Add(nums[i]);\\n            }\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] MaxSubsequence(int[] nums, int k) \\n    {\\n        if(nums.Length <= k) return nums;\\n        \\n        var pq = new PriorityQueue<int, int>();\\n        \\n        for(var i=0; i<nums.Length; i++)\\n        {\\n            pq.Enqueue(i, nums[i]);\\n            \\n            if(pq.Count > k)\\n                pq.Dequeue();\\n        }\\n        \\n        var selected = new bool[nums.Length];\\n        \\n        while(pq.Count > 0)\\n        {\\n            selected[pq.Dequeue()] = true;\\n        }\\n        \\n        var result = new List<int>(k);\\n        \\n        for(var i=0; i<nums.Length; i++)\\n        {\\n            if(selected[i])\\n            {\\n                result.Add(nums[i]);\\n            }\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386336,
                "title": "easy-c-solution",
                "content": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k){\\n       //  this heap(maxh) is of pair type where first element of pair is the array element and second element is the corresponding index.\\n        priority_queue<pair<int,int>>maxh;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t// Pushing all the elements of given vector(nums) into the \\'maxh\\' with its corresponding indices.\\n        for(int i=0;i<nums.size();i++){\\n            maxh.push({nums[i],i});\\n        }\\n\\t\\t// In this heap(minh), first element of the pair is the index and the second element is the array element itself\\n        // Taking \\'k\\' elements from the top of the \\'maxh\\' and push it into the \\'minh\\'\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minh;\\n        while(k--){\\n            minh.push({maxh.top().second,maxh.top().first});\\n            maxh.pop();\\n        }\\n\\t\\t// popping all the elements from the \\'minh\\' until it became empty and push the second value of pair into the \\'ans\\'\\n        while(!minh.empty()){\\n            ans.push_back(minh.top().second);\\n            minh.pop();\\n        }\\n        return ans;\\n    }\\n```\\n**Please upvote if you find this helpful. Thankyou.**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k){\\n       //  this heap(maxh) is of pair type where first element of pair is the array element and second element is the corresponding index.\\n        priority_queue<pair<int,int>>maxh;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t// Pushing all the elements of given vector(nums) into the \\'maxh\\' with its corresponding indices.\\n        for(int i=0;i<nums.size();i++){\\n            maxh.push({nums[i],i});\\n        }\\n\\t\\t// In this heap(minh), first element of the pair is the index and the second element is the array element itself\\n        // Taking \\'k\\' elements from the top of the \\'maxh\\' and push it into the \\'minh\\'\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minh;\\n        while(k--){\\n            minh.push({maxh.top().second,maxh.top().first});\\n            maxh.pop();\\n        }\\n\\t\\t// popping all the elements from the \\'minh\\' until it became empty and push the second value of pair into the \\'ans\\'\\n        while(!minh.empty()){\\n            ans.push_back(minh.top().second);\\n            minh.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354023,
                "title": "java-100-fastest-heap",
                "content": "<---//Voteup if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    int res[], maxSum;\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        res = new int[k];\\n        \\n        PriorityQueue<Integer> mQ = new PriorityQueue<>((a,b) -> (nums[a]-nums[b]));\\n        for(int i = 0; i< nums.length; i++) {\\n            mQ.offer(i);\\n            if(mQ.size()>k){\\n                mQ.poll();\\n            }\\n        }\\n\\n        PriorityQueue<Integer> resQ = new PriorityQueue<>((a,b) -> (a-b));\\n        resQ.addAll(mQ);\\n        int count = 0;\\n        for(int i = 0; i < k; i++) {\\n            res[i] = nums[resQ.poll()];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int res[], maxSum;\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        res = new int[k];\\n        \\n        PriorityQueue<Integer> mQ = new PriorityQueue<>((a,b) -> (nums[a]-nums[b]));\\n        for(int i = 0; i< nums.length; i++) {\\n            mQ.offer(i);\\n            if(mQ.size()>k){\\n                mQ.poll();\\n            }\\n        }\\n\\n        PriorityQueue<Integer> resQ = new PriorityQueue<>((a,b) -> (a-b));\\n        resQ.addAll(mQ);\\n        int count = 0;\\n        for(int i = 0; i < k; i++) {\\n            res[i] = nums[resQ.poll()];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313914,
                "title": "i-think-this-should-be-a-medium-python-solution-here-o-n-log-n",
                "content": "Create a min-heap, and a set to keep track of the indexes so when you append the results, it keeps in order.\\n\\nFirst you iterate over the main array, keeping a min Heap of size k. (remember to remove the index when you pop the heap)\\n\\nAnd then just iterate another time through the main array, and append the indexes which kept in the indexSet.\\n\\nfirst for: O(N * log (n)) -> heapush has a time complexity of O(log (n)) and it\\'s performed N times.\\nsecod for: O(N)\\ntime complexity end result: O(N * log(N)) + O(N) = O(N * log(n))\\n\\n\\n```class Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minHeap = []\\n        indexSet = set()\\n\\t\\t\\n        for i in range(len(nums)):\\n            heapq.heappush(minHeap, (nums[i], i))\\n            indexSet.add(i)\\n            if (len(minHeap) > k):\\n                x, index = heapq.heappop(minHeap)\\n                indexSet.remove(index)\\n                \\n        res = []\\n        for i in range(len(nums)):\\n            if i in indexSet:\\n                res.append(nums[i])\\n        return res",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "Create a min-heap, and a set to keep track of the indexes so when you append the results, it keeps in order.\\n\\nFirst you iterate over the main array, keeping a min Heap of size k. (remember to remove the index when you pop the heap)\\n\\nAnd then just iterate another time through the main array, and append the indexes which kept in the indexSet.\\n\\nfirst for: O(N * log (n)) -> heapush has a time complexity of O(log (n)) and it\\'s performed N times.\\nsecod for: O(N)\\ntime complexity end result: O(N * log(N)) + O(N) = O(N * log(n))\\n\\n\\n```class Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minHeap = []\\n        indexSet = set()\\n\\t\\t\\n        for i in range(len(nums)):\\n            heapq.heappush(minHeap, (nums[i], i))\\n            indexSet.add(i)\\n            if (len(minHeap) > k):\\n                x, index = heapq.heappop(minHeap)\\n                indexSet.remove(index)\\n                \\n        res = []\\n        for i in range(len(nums)):\\n            if i in indexSet:\\n                res.append(nums[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2305279,
                "title": "c-sort-2d-vector",
                "content": "```\\nvector<vector<int>> v(nums.size(),vector<int>(2,0)), iv(k,vector<int>(2,0));\\n        for(int i=0;i<nums.size();i++){\\n            v[i][0]=nums[i];\\n            v[i][1]=i;\\n        }\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        for(int i=0;i<k;i++){\\n            iv[i][0]=v[i][1];\\n            iv[i][1]=v[i][0];\\n        }\\n        sort(iv.begin(),iv.end());\\n        vector<int> p;\\n        for(int i=0;i<k;i++){\\n            p.push_back(iv[i][1]);\\n        }\\n        return p;\\n```\\n\\nTime complexity- O(nlogn)\\nSpace complexity- O(n+k)",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> v(nums.size(),vector<int>(2,0)), iv(k,vector<int>(2,0));\\n        for(int i=0;i<nums.size();i++){\\n            v[i][0]=nums[i];\\n            v[i][1]=i;\\n        }\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        for(int i=0;i<k;i++){\\n            iv[i][0]=v[i][1];\\n            iv[i][1]=v[i][0];\\n        }\\n        sort(iv.begin(),iv.end());\\n        vector<int> p;\\n        for(int i=0;i<k;i++){\\n            p.push_back(iv[i][1]);\\n        }\\n        return p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287464,
                "title": "c-o-nlogn-time-o-n-space-priority-queue-max",
                "content": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    vector<int> seq(k);\\n    int n=nums.size();\\n    priority_queue<pair<int,int>> pq;\\n    for (int i=0;i<n;i++) {\\n        pq.push(make_pair(nums[i], i));\\n    }\\n    for (int i=0;i<k;i++) {\\n        seq[i]=pq.top().second;\\n        pq.pop();\\n    }\\n    sort(seq.begin(), seq.end());\\n    for (int i=0;i<k;i++) {\\n        seq[i]=nums[seq[i]];\\n    }\\n    return seq;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> maxSubsequence(vector<int>& nums, int k) {\\n    vector<int> seq(k);\\n    int n=nums.size();\\n    priority_queue<pair<int,int>> pq;\\n    for (int i=0;i<n;i++) {\\n        pq.push(make_pair(nums[i], i));\\n    }\\n    for (int i=0;i<k;i++) {\\n        seq[i]=pq.top().second;\\n        pq.pop();\\n    }\\n    sort(seq.begin(), seq.end());\\n    for (int i=0;i<k;i++) {\\n        seq[i]=nums[seq[i]];\\n    }\\n    return seq;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260800,
                "title": "python3-heap-sort-tc-o-nlogk-sc-o-k",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minHeap = []\\n        \\n        for i in range(len(nums)):\\n            if len(minHeap) < k:\\n                heapq.heappush(minHeap, [nums[i], i])\\n            elif minHeap[0][0] < nums[i]:\\n                heapq.heapreplace(minHeap, [nums[i], i])\\n        \\n        minHeap.sort(key = lambda x: x[1])\\n        ans = [minHeap[i][0] for i in range(k)]\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minHeap = []\\n        \\n        for i in range(len(nums)):\\n            if len(minHeap) < k:\\n                heapq.heappush(minHeap, [nums[i], i])\\n            elif minHeap[0][0] < nums[i]:\\n                heapq.heapreplace(minHeap, [nums[i], i])\\n        \\n        minHeap.sort(key = lambda x: x[1])\\n        ans = [minHeap[i][0] for i in range(k)]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2234680,
                "title": "java-o-n-no-complex-data-structures",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        int[] subsequence = new int[k];\\n        int currentSum = 0;\\n        \\n        //init default subsequence\\n        for(int i = 0; i < k; i++)\\n        {\\n            subsequence[i] = nums[i];\\n            currentSum += nums[i];\\n        }\\n        \\n        for(int i = k; i < nums.length; i++)\\n        {\\n            int idx = 0;\\n            int smallestItem = subsequence[0];\\n            \\n            //get the smallest item\\n            for(int j = 1; j < k; j++)\\n            {\\n                if(subsequence[j] < smallestItem)\\n                {\\n                    smallestItem = subsequence[j];\\n                    idx = j;\\n                }\\n            }\\n            \\n            if(smallestItem > nums[i])\\n            {\\n                continue;\\n            } else\\n            {\\n                //if new item has higher value than current smallest, then we remove smallest and\\n                //shuffle the array\\n                for(int h = idx + 1; h < k; h++)\\n                {\\n                    subsequence[h-1] = subsequence[h];\\n                }\\n                subsequence[k-1] = nums[i];\\n            }\\n           \\n        }    \\n\\n        return subsequence;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        int[] subsequence = new int[k];\\n        int currentSum = 0;\\n        \\n        //init default subsequence\\n        for(int i = 0; i < k; i++)\\n        {\\n            subsequence[i] = nums[i];\\n            currentSum += nums[i];\\n        }\\n        \\n        for(int i = k; i < nums.length; i++)\\n        {\\n            int idx = 0;\\n            int smallestItem = subsequence[0];\\n            \\n            //get the smallest item\\n            for(int j = 1; j < k; j++)\\n            {\\n                if(subsequence[j] < smallestItem)\\n                {\\n                    smallestItem = subsequence[j];\\n                    idx = j;\\n                }\\n            }\\n            \\n            if(smallestItem > nums[i])\\n            {\\n                continue;\\n            } else\\n            {\\n                //if new item has higher value than current smallest, then we remove smallest and\\n                //shuffle the array\\n                for(int h = idx + 1; h < k; h++)\\n                {\\n                    subsequence[h-1] = subsequence[h];\\n                }\\n                subsequence[k-1] = nums[i];\\n            }\\n           \\n        }    \\n\\n        return subsequence;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225979,
                "title": "java-simple-solution-using-priorityqueue",
                "content": "```\\nclass Pair {\\n    int val;\\n    int index;\\n    \\n    public Pair(int val, int index) {\\n        this.val=val;\\n        this.index=index;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a,b) -> a.val-b.val);\\n        \\n        for(int i=0; i<k; i++) {\\n            minHeap.offer(new Pair(nums[i], i));\\n        }\\n        \\n        for(int i=k; i<nums.length; i++) {\\n            if(minHeap.peek().val < nums[i]) {\\n                minHeap.poll();\\n                minHeap.offer(new Pair(nums[i], i));\\n            }\\n        }\\n        \\n        List<Pair> maxElements = new ArrayList(minHeap);\\n        Collections.sort(maxElements, (a,b) -> a.index - b.index);\\n        int[] arr = new int[minHeap.size()];\\n        int p=0;\\n        for(Pair i : maxElements) {\\n            arr[p++] = i.val;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair {\\n    int val;\\n    int index;\\n    \\n    public Pair(int val, int index) {\\n        this.val=val;\\n        this.index=index;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a,b) -> a.val-b.val);\\n        \\n        for(int i=0; i<k; i++) {\\n            minHeap.offer(new Pair(nums[i], i));\\n        }\\n        \\n        for(int i=k; i<nums.length; i++) {\\n            if(minHeap.peek().val < nums[i]) {\\n                minHeap.poll();\\n                minHeap.offer(new Pair(nums[i], i));\\n            }\\n        }\\n        \\n        List<Pair> maxElements = new ArrayList(minHeap);\\n        Collections.sort(maxElements, (a,b) -> a.index - b.index);\\n        int[] arr = new int[minHeap.size()];\\n        int p=0;\\n        for(Pair i : maxElements) {\\n            arr[p++] = i.val;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181678,
                "title": "c-line-by-line-explanation-using-priority-queue-and-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>v(k,0);  //vector container for stroring solution\\n        \\n        priority_queue<pair<int,int>>pq;  //Priority Queue for filtering top K numbers along with index\\n        for(int i=0;i<nums.size();i++){   //inserting numbers into pq with as{number,index}\\n            pq.push({nums[i],i});\\n        }\\n        for(int i=0;i<k;i++){\\n           v[i]=pq.top().second;   //selecting index of top k numbers\\n            pq.pop();\\n        }\\n        sort(v.begin(),v.end());  //sorting based on index to maintain original order of numbers\\n         for(int i=0;i<k;i++){\\n           v[i]=nums[v[i]];      //retieving numbers based on their index\\n        }\\n        return v;   //returning the solution\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>v(k,0);  //vector container for stroring solution\\n        \\n        priority_queue<pair<int,int>>pq;  //Priority Queue for filtering top K numbers along with index\\n        for(int i=0;i<nums.size();i++){   //inserting numbers into pq with as{number,index}\\n            pq.push({nums[i],i});\\n        }\\n        for(int i=0;i<k;i++){\\n           v[i]=pq.top().second;   //selecting index of top k numbers\\n            pq.pop();\\n        }\\n        sort(v.begin(),v.end());  //sorting based on index to maintain original order of numbers\\n         for(int i=0;i<k;i++){\\n           v[i]=nums[v[i]];      //retieving numbers based on their index\\n        }\\n        return v;   //returning the solution\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181327,
                "title": "java-soluiton-using-priority-queue",
                "content": "\\n\\n\\n```\\n\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n=nums.length;\\n        int q=0;\\n        int[] ans=new int[k];\\n    Queue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++){\\n          pq.add(nums[i]);\\n        }\\n        for(int j=0;j<n-k;j++){\\n          int t=pq.poll();\\n            for(int K=n-1;K>=0;K--){\\n             if(nums[K]==t){\\n               nums[K]=Integer.MIN_VALUE;\\n                 break;\\n             }\\n            }\\n        }\\n        for(int p=0;p<n;p++){\\n            if(nums[p]!=Integer.MIN_VALUE)\\n                ans[q++]=nums[p];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n=nums.length;\\n        int q=0;\\n        int[] ans=new int[k];\\n    Queue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++){\\n          pq.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2118377,
                "title": "c-simplest-and-efficient-solution",
                "content": "Here, we create a vector \\'v\\' identical to given nums, then we sort [Decending] and resize it to \"k\" length, Thus we get the \\'k\\' greatest elements in it.\\nNow we use it to allocate the elements in answer in the same order as given nums, as shown.\\n\\n        Runtime:      8 ms, faster than   77.18%\\n        Memory Usage: 9.4 MB, less than   88.78%\\nCode\\n\\n                        UPVOTE if you like the Explanition / Solution \\n\\t\\t \\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        vector<int> v=nums,re;\\n        sort(v.begin(),v.end(),greater<int>());  //rearranges in desending order \\n        v.resize(k);  //only retains the \\'k\\' no. of biggest elements\\n        for(auto i:nums)\\n        {\\n            if(find(v.begin(),v.end(),i)!=v.end()){re.push_back(i);v.erase(find(v.begin(),v.end(),i));} \\n\\t\\t\\t//if the element is in \\'k\\' greatest elements we take it into answer and remove it from \\'k\\' greatest elements\\n\\t\\t\\t\\n            if(re.size()==k){return re;}\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) \\n    {\\n        vector<int> v=nums,re;\\n        sort(v.begin(),v.end(),greater<int>());  //rearranges in desending order \\n        v.resize(k);  //only retains the \\'k\\' no. of biggest elements\\n        for(auto i:nums)\\n        {\\n            if(find(v.begin(),v.end(),i)!=v.end()){re.push_back(i);v.erase(find(v.begin(),v.end(),i));} \\n\\t\\t\\t//if the element is in \\'k\\' greatest elements we take it into answer and remove it from \\'k\\' greatest elements\\n\\t\\t\\t\\n            if(re.size()==k){return re;}\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117472,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        for _ in range(len(nums)-k):\\n            target = min(nums)\\n            nums.remove(target)\\n        return nums",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        for _ in range(len(nums)-k):\\n            target = min(nums)\\n            nums.remove(target)\\n        return nums",
                "codeTag": "Java"
            },
            {
                "id": 2070974,
                "title": "easy-af-c-priority-queue-min-heap",
                "content": "*Hope you find help, pls do consider upvoting \\uD83D\\uDE04.*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq, q;\\n        \\n        vector<int>ans;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            pq.push({nums[i], i});\\n            \\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            q.push({pq.top().second, pq.top().first});\\n            pq.pop();\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n*Have a good day \\uD83D\\uDE04.*",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq, q;\\n        \\n        vector<int>ans;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            pq.push({nums[i], i});\\n            \\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            q.push({pq.top().second, pq.top().first});\\n            pq.pop();\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062682,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] a = new int[k];\\n        int min=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n             a[i]=nums[i];\\n            if(a[i]<a[min])\\n                min=i;\\n        } \\n        \\n        for(int i=k;i<nums.length;i++)\\n        {\\n            if(nums[i]>a[min])\\n                min=replace(a,min,nums[i]);\\n        }\\n        return a;\\n    }\\n    \\n    private int replace(int[] a,int min,int x)\\n    {\\n        for(int i=min;i<a.length-1;i++)\\n            a[i]=a[i+1];\\n        \\n        a[a.length-1]=x;\\n        int minIndex=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]<a[minIndex])\\n                minIndex=i;\\n        }\\n        return minIndex;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int[] a = new int[k];\\n        int min=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n             a[i]=nums[i];\\n            if(a[i]<a[min])\\n                min=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2053399,
                "title": "find-subsequence-of-length-kwith-the-largest-sum",
                "content": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n       vector<pair<int,int>>v;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();++i){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        for(int i=0;i<k;++i){\\n            ans.push_back(v[i].second);\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();++i){\\n            ans[i]=nums[ans[i]];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n       vector<pair<int,int>>v;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();++i){\\n            v.push_back({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2013603,
                "title": "easy-c-solution-using-minheap-and-maxheap",
                "content": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        //first we use maxheap in pairwise order to store all k maximum elements\\n       priority_queue<pair<int,int>>pq;\\n        //then we use min heap in pairwise to store all k top elements of maxheap and their index \\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> p;\\n        for(int i=0;i<nums.size();i++){  \\n            pq.push(make_pair(nums[i],i)); \\n        }\\n        for(int i=0;i<k;i++){\\n            p.push(make_pair(pq.top().second,pq.top().first));//first heap will be arranged in increasing order of first argument which is the index of pq \\n            pq.pop();\\n        }\\n        vector<int>vec;\\n        while(k-- && !p.empty()){\\n       vec.push_back(p.top().second);//push values in vector till k times\\n            p.pop();\\n            \\n        }\\n        \\n        return vec;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        //first we use maxheap in pairwise order to store all k maximum elements\\n       priority_queue<pair<int,int>>pq;\\n        //then we use min heap in pairwise to store all k top elements of maxheap and their index \\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> p;\\n        for(int i=0;i<nums.size();i++){  \\n            pq.push(make_pair(nums[i],i)); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1987300,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n    vector<pair<int,int>> tmp ;vector<int> ans;\\n    for(int i=0; i<nums.size();i++){\\n        q.push({nums[i],i});\\n        if(q.size()>k) q.pop();\\n    }\\n    while(!q.empty())\\n    {\\n        tmp.push_back({q.top().second, q.top().first});\\n        q.pop();\\n    }\\n    sort(tmp.begin(), tmp.end()); // sort with increasing index to get it in the correct order of the subsequence. \\n    for( auto elt:tmp) ans.push_back(elt.second);\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n    vector<pair<int,int>> tmp ;vector<int> ans;\\n    for(int i=0; i<nums.size();i++){\\n        q.push({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1973393,
                "title": "c-linq-one-line",
                "content": "```\\n public int[] MaxSubsequence(int[] nums, int k) \\n    {   \\n        return nums.Select((x, index) => new { x, index }).OrderBy(y => y.x).Skip(nums.Length - k).OrderBy(y=>y.index).Select(y=>y.x).ToArray();\\n    }",
                "solutionTags": [],
                "code": "```\\n public int[] MaxSubsequence(int[] nums, int k) \\n    {   \\n        return nums.Select((x, index) => new { x, index }).OrderBy(y => y.x).Skip(nums.Length - k).OrderBy(y=>y.index).Select(y=>y.x).ToArray();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1936417,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k)\\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q1,q2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q1.push({nums[i],i});\\n            if(q1.size()>k)\\n                q1.pop();\\n        }\\n        while(!q1.empty())\\n        {\\n            q2.push({q1.top().second,q1.top().first});\\n            q1.pop();\\n        }\\n        vector<int> res;\\n        while(!q2.empty())\\n        {\\n            res.push_back(q2.top().second);\\n            q2.pop();\\n        }\\n        return res;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k)\\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q1,q2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q1.push({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1930426,
                "title": "find-subsequence-of-length-k-with-largest-sum",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        int  p = nums.size() - k ;\\n        \\n        while(p)\\n        {\\n          \\n           nums.erase(min_element(nums.begin() , nums.end()));\\n            p--;\\n        }\\n        \\n       \\n        return nums ;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        \\n        int  p = nums.size() - k ;\\n        \\n        while(p)\\n        {\\n          \\n           nums.erase(min_element(nums.begin() , nums.end()));\\n            p--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1856092,
                "title": "java-heap-explained",
                "content": ">**T/S:** O((n + k) lg k)/O(n + k), where n = size(nums)\\n```\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\t// Create a heap by value of size k + 1\\n\\tvar numHeap = new PriorityQueue<int[]>(k  + 1, Comparator.comparingInt(pair -> pair[0])); \\n\\n\\t// populate it with top k numbers\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tnumHeap.add(new int[]{nums[i], i});\\n\\t\\tif (numHeap.size() == k + 1)\\n\\t\\t\\tnumHeap.poll();\\n\\t}\\n\\n\\t// Create a list to sort the numbers by index\\n\\tvar pairs = new ArrayList<>(numHeap);\\n\\tpairs.sort(Comparator.comparingInt(pair -> pair[1]));\\n\\t\\n\\t// build the subsequence array\\n\\treturn IntStream.range(0, k)\\n\\t\\t\\t\\t\\t.map(i -> pairs.get(i)[0])\\n\\t\\t\\t\\t\\t.toArray();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\t// Create a heap by value of size k + 1\\n\\tvar numHeap = new PriorityQueue<int[]>(k  + 1, Comparator.comparingInt(pair -> pair[0])); \\n\\n\\t// populate it with top k numbers\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tnumHeap.add(new int[]{nums[i], i});\\n\\t\\tif (numHeap.size() == k + 1)\\n\\t\\t\\tnumHeap.poll();\\n\\t}\\n\\n\\t// Create a list to sort the numbers by index\\n\\tvar pairs = new ArrayList<>(numHeap);\\n\\tpairs.sort(Comparator.comparingInt(pair -> pair[1]));\\n\\t\\n\\t// build the subsequence array\\n\\treturn IntStream.range(0, k)\\n\\t\\t\\t\\t\\t.map(i -> pairs.get(i)[0])\\n\\t\\t\\t\\t\\t.toArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831364,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>> vec, res;\\n        for (int i = 0; i < nums.size(); i++) {\\n            vec.push_back({nums[i], i}); //Store the elements as {element, index};\\n        }\\n        sort(vec.begin(), vec.end()); //sort them in increasing order;\\n        for (int i = vec.size() - 1; i >= 0 && k-- > 0; i--) { //append only \\'k\\' largest elements...\\n            res.push_back({vec[i].second, vec[i].first}); //Again store them but this time store as {index, element};\\n        }\\n        sort(res.begin(), res.end()); //sort in increasing order;\\n        vector<int> ans;\\n        for (auto &r: res) ans.push_back(r.second); //append the values and done;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>> vec, res;\\n        for (int i = 0; i < nums.size(); i++) {\\n            vec.push_back({nums[i], i}); //Store the elements as {element, index};\\n        }\\n        sort(vec.begin(), vec.end()); //sort them in increasing order;\\n        for (int i = vec.size() - 1; i >= 0 && k-- > 0; i--) { //append only \\'k\\' largest elements...\\n            res.push_back({vec[i].second, vec[i].first}); //Again store them but this time store as {index, element};\\n        }\\n        sort(res.begin(), res.end()); //sort in increasing order;\\n        vector<int> ans;\\n        for (auto &r: res) ans.push_back(r.second); //append the values and done;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823292,
                "title": "c-simplest-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }        \\n          vector<pair<int,int>>temp;\\n        while(!pq.empty())\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            temp.push_back({top.second,top.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<int>res;\\n        for(auto i:temp)\\n            res.push_back(i.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }        \\n          vector<pair<int,int>>temp;\\n        while(!pq.empty())\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            temp.push_back({top.second,top.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<int>res;\\n        for(auto i:temp)\\n            res.push_back(i.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782145,
                "title": "c-brute-force-optimized-solution",
                "content": "**Brute Force**\\n```\\n static bool comp(pair<int,int> a, pair<int,int>b){\\n        return a.second < b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(nums.size()==0){\\n            return {};\\n        }\\n        vector<pair<int,int>> result;\\n        vector<int> res;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        while(k){\\n            result.push_back(pq.top());\\n            pq.pop();\\n            k--;\\n        }\\n        sort(result.begin(), result.end() , comp);\\n        for(auto &p : result){\\n            res.push_back(p.first);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n<hr>\\n\\n**Optimized **\\n```\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<pair<int,int>> vec;\\n        vector<int> res;\\n        for(int i=0; i<nums.size(); ++i){\\n            vec.push_back({nums[i], i});\\n        }\\n        nth_element(begin(vec), begin(vec)+k, end(vec), greater<pair<int,int>>()); // seperating greater & smaller element with (begin + k) pivot\\n        \\n        sort(begin(vec), begin(vec)+k, [](const auto &a, const auto &b){ return a.second < b.second; });// sort first k elements by indices;\\n        \\n        for(int i=0; i<k; ++i){ // k length\\n            res.push_back(vec[i].first);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n static bool comp(pair<int,int> a, pair<int,int>b){\\n        return a.second < b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        if(nums.size()==0){\\n            return {};\\n        }\\n        vector<pair<int,int>> result;\\n        vector<int> res;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        while(k){\\n            result.push_back(pq.top());\\n            pq.pop();\\n            k--;\\n        }\\n        sort(result.begin(), result.end() , comp);\\n        for(auto &p : result){\\n            res.push_back(p.first);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775500,
                "title": "python-o-nlogk-time-using-heaps",
                "content": "We maintain a minheap of size k, to get the k largest elements and their positions in the index O(nlogk)\\nNext we sort the heap of size k O(klogk)\\nFinally we use list comprehension to return the result list\\n\\n```\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minheap = []\\n        for i, num in enumerate(nums): #O(nlogk)\\n            if len(minheap) < k: heapq.heappush(minheap, (num,i))\\n            elif minheap and minheap[0][0] < num:\\n                heapq.heapreplace(minheap, (num,i))\\n        minheap.sort(key=lambda x: x[1]) #O(klogk)\\n        return [x[0] for x in minheap] #O(n)\\n\\t\\t```\\n\\t\\t\\nFeel free to correct me if i got anything wrong, lets learn together.\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        minheap = []\\n        for i, num in enumerate(nums): #O(nlogk)\\n            if len(minheap) < k: heapq.heappush(minheap, (num,i))\\n            elif minheap and minheap[0][0] < num:\\n                heapq.heapreplace(minheap, (num,i))\\n        minheap.sort(key=lambda x: x[1]) #O(klogk)\\n        return [x[0] for x in minheap] #O(n)\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1765339,
                "title": "c-priority-queue",
                "content": "vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pq.push(make_pair(nums[i], i));\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>               min_pq;\\n        for(int i = 0; i < k; i++) {\\n            pair<int, int> p = pq.top();\\n            pq.pop();\\n            min_pq.push(make_pair(p.second, p.first));\\n        }\\n        while(!min_pq.empty()) {\\n            ans.push_back(min_pq.top().second);\\n            min_pq.pop();\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pq.push(make_pair(nums[i], i));\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>               min_pq;\\n        for(int i = 0; i < k; i++) {\\n            pair<int, int> p = pq.top();\\n            pq.pop();\\n            min_pq.push(make_pair(p.second, p.first));\\n        }\\n        while(!min_pq.empty()) {\\n            ans.push_back(min_pq.top().second);\\n            min_pq.pop();\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1761509,
                "title": "swift-clear-solution",
                "content": "```\\nfunc maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n    return nums.indices\\n               .map { [nums[$0], $0] }        // Get array of pairs <IndexValue, Index>\\n               .sorted(by: { $0[0] > $1[0] }) // Sort pair by IndexValue, decreasing\\n               .prefix(k)                     // First k elements of array\\n               .sorted(by: { $0[1] < $1[1]} ) // Sort pairs by index, becouse we want to return it index by index\\n               .map { $0[0] }                 // convert array of pairs to array of just values\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n    return nums.indices\\n               .map { [nums[$0], $0] }        // Get array of pairs <IndexValue, Index>\\n               .sorted(by: { $0[0] > $1[0] }) // Sort pair by IndexValue, decreasing\\n               .prefix(k)                     // First k elements of array\\n               .sorted(by: { $0[1] < $1[1]} ) // Sort pairs by index, becouse we want to return it index by index\\n               .map { $0[0] }                 // convert array of pairs to array of just values\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752943,
                "title": "c-hashmaps-o-nlogn-with-explaination",
                "content": "Approach :\\nLargest K sum means that we need to find the largest k values in the nums array\\n\\nWe can sort the array and easily find out top k values **but we need to return values in a maintained order**\\n\\nNote : As a single int value can occur multiple times in top k, we need to keep track of how many times an integer occurs\\nWe can achieve this by sorting a copy of nums array and putting top k values in unordered_map with their occurence as value\\n\\nNow we simply traverse nums array and check if the int value is in our map or not and return it (subtracting its occurence each time)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        unordered_map<int,int> map;\\n        //copy nums in vector and sort it\\n        vector<int> copy = nums,ans;\\n        sort(copy.begin(),copy.end());\\n        //put top k elements in map (they can occur multiple time)\\n        vector<int> top_k(copy.end()-k,copy.end());\\n        for(auto i : top_k)\\n        {\\n            map[i]++;\\n        }\\n        // check if nums element exist in map and print it thus maintaining order of sequence\\n        for(auto i : nums)\\n        {\\n            if(map[i]-- > 0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        unordered_map<int,int> map;\\n        //copy nums in vector and sort it\\n        vector<int> copy = nums,ans;\\n        sort(copy.begin(),copy.end());\\n        //put top k elements in map (they can occur multiple time)\\n        vector<int> top_k(copy.end()-k,copy.end());\\n        for(auto i : top_k)\\n        {\\n            map[i]++;\\n        }\\n        // check if nums element exist in map and print it thus maintaining order of sequence\\n        for(auto i : nums)\\n        {\\n            if(map[i]-- > 0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732750,
                "title": "python-3-using-heap",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        nums = [[-nums[i],i] for i in range(len(nums))]\\n        heapq.heapify(nums)\\n        ans,fin = [],[]\\n        for i in range(k):\\n            ans.append(heapq.heappop(nums)[::-1])\\n        heapq.heapify(ans)\\n        for i in range(len(ans)):\\n            fin.append(-1*heapq.heappop(ans)[1])\\n        return fin\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        nums = [[-nums[i],i] for i in range(len(nums))]\\n        heapq.heapify(nums)\\n        ans,fin = [],[]\\n        for i in range(k):\\n            ans.append(heapq.heappop(nums)[::-1])\\n        heapq.heapify(ans)\\n        for i in range(len(ans)):\\n            fin.append(-1*heapq.heappop(ans)[1])\\n        return fin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728745,
                "title": "simple-and-concise-solution-by-using-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue <pair<int,int>> pq;\\n        vector <int> res,temp;\\n        for(int i = 0;i<nums.size();i++) pq.push({nums[i],i});\\n        while(k--){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        sort(res.begin(),res.end());\\n        for(int x:res)\\n            temp.push_back(nums[x]);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue <pair<int,int>> pq;\\n        vector <int> res,temp;\\n        for(int i = 0;i<nums.size();i++) pq.push({nums[i],i});\\n        while(k--){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        sort(res.begin(),res.end());\\n        for(int x:res)\\n            temp.push_back(nums[x]);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692151,
                "title": "php-solution",
                "content": "```\\nfunction maxSubsequence($nums, $k) {\\n\\t$count = count($nums) - $k;\\n\\tif ($count > 0) {\\n\\t\\tfor ($i=0; $i < $count; $i++) { \\n\\t\\t\\tunset($nums[array_search(min($nums), $nums)]);\\n\\t\\t}\\n\\t}\\n\\treturn $nums;\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction maxSubsequence($nums, $k) {\\n\\t$count = count($nums) - $k;\\n\\tif ($count > 0) {\\n\\t\\tfor ($i=0; $i < $count; $i++) { \\n\\t\\t\\tunset($nums[array_search(min($nums), $nums)]);\\n\\t\\t}\\n\\t}\\n\\treturn $nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655767,
                "title": "java-o-nlogk",
                "content": "Tougher than your usual Easy question, or... I did it wrong :-)\\n```\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\tint n= nums.length;\\n\\tPriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->a[0]-b[0]);\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tpq.add(new int[]{nums[i], i});\\n\\t\\tif(pq.size()>k) pq.remove();\\n\\t}\\n\\tArrayList<int[]> kSub= new ArrayList<>(pq);\\n\\tCollections.sort(kSub, (a,b)->a[1]-b[1]);\\n\\n\\tint[] ans= new int[k];\\n\\tfor(int i=0; i<k; i++){\\n\\t\\tans[i]= kSub.get(i)[0];            \\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "Tougher than your usual Easy question, or... I did it wrong :-)\\n```\\npublic int[] maxSubsequence(int[] nums, int k) {\\n\\tint n= nums.length;\\n\\tPriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->a[0]-b[0]);\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tpq.add(new int[]{nums[i], i});\\n\\t\\tif(pq.size()>k) pq.remove();\\n\\t}\\n\\tArrayList<int[]> kSub= new ArrayList<>(pq);\\n\\tCollections.sort(kSub, (a,b)->a[1]-b[1]);\\n\\n\\tint[] ans= new int[k];\\n\\tfor(int i=0; i<k; i++){\\n\\t\\tans[i]= kSub.get(i)[0];            \\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1645552,
                "title": "python-counter",
                "content": "```\\n        dic = Counter(sorted(nums,reverse = True)[:k])\\n        ans = []\\n        for c in nums:\\n            if c in dic and dic[c]>0:\\n                ans.append(c)\\n                dic[c] -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n        dic = Counter(sorted(nums,reverse = True)[:k])\\n        ans = []\\n        for c in nums:\\n            if c in dic and dic[c]>0:\\n                ans.append(c)\\n                dic[c] -= 1\\n        return ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1637232,
                "title": "java-solution-sorting",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            arr[i][0] = nums[i];\\n            arr[i][1] = i;\\n        }\\n        \\n        Arrays.sort(arr, (a, b) -> b[0] - a[0]);\\n        Arrays.sort(arr, 0, k, (a, b) -> a[1] - b[1]);\\n        int[] ans = new int[k];\\n        for (int i = 0; i < k; ++i) {\\n            ans[i] = arr[i][0];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            arr[i][0] = nums[i];\\n            arr[i][1] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1628020,
                "title": "swift-easy-and-concise-solution-o-nlogn",
                "content": "- sort indices by values\\n- get first k indices\\n- sort indices again to get the original order\\n- map to the value at the index and return\\n\\n```Swift\\nfunc maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n    (0..<nums.count).sorted(by: { nums[$0] > nums[$1] })[..<k].sorted().map { nums[$0] }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sorting"
                ],
                "code": "```Swift\\nfunc maxSubsequence(_ nums: [Int], _ k: Int) -> [Int] {\\n    (0..<nums.count).sorted(by: { nums[$0] > nums[$1] })[..<k].sorted().map { nums[$0] }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1626557,
                "title": "java-priorityqueue-sol-o-nlog-k",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->nums[a]-nums[b]);\\n        for(int i=0;i<k;i++){\\n            pq.add(i);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            if(nums[pq.peek()]<nums[i]){\\n                pq.remove();\\n                pq.add(i);\\n            }\\n        }\\n        int[]arr=new int[pq.size()];\\n        while(pq.size()!=0){\\n            nums[pq.remove()]+=300000;\\n        }\\n        int idx=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=200000)\\n                arr[idx++]=nums[i]-300000;\\n        }\\n        return arr;\\n    }\\n}\\n//complexity o(n logK)\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->nums[a]-nums[b]);\\n        for(int i=0;i<k;i++){\\n            pq.add(i);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            if(nums[pq.peek()]<nums[i]){\\n                pq.remove();\\n                pq.add(i);\\n            }\\n        }\\n        int[]arr=new int[pq.size()];\\n        while(pq.size()!=0){\\n            nums[pq.remove()]+=300000;\\n        }\\n        int idx=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=200000)\\n                arr[idx++]=nums[i]-300000;\\n        }\\n        return arr;\\n    }\\n}\\n//complexity o(n logK)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624155,
                "title": "java-simple-and-clean-solution",
                "content": "Two sort, this first one is sort by its value, after the greater element are in\\nthe tail, sort it by the index.\\n\\n```java\\nclass Solution {\\n  public int[] maxSubsequence(int[] nums, int k) {\\n    int n = nums.length;\\n    List<Integer> index = new ArrayList<>(n);\\n    for (int i = 0; i < n; i++) {\\n      index.add(i);\\n    }\\n    Collections.sort(index, (a, b) -> nums[a] - nums[b]);\\n\\n    List<Integer> sub = index.subList(n - k, n);\\n    Collections.sort(sub, (a, b) -> a - b);\\n\\n    int[] res = new int[k];\\n    for (int i = 0; i < k; i++) {\\n      res[i] = nums[sub.get(i)];\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public int[] maxSubsequence(int[] nums, int k) {\\n    int n = nums.length;\\n    List<Integer> index = new ArrayList<>(n);\\n    for (int i = 0; i < n; i++) {\\n      index.add(i);\\n    }\\n    Collections.sort(index, (a, b) -> nums[a] - nums[b]);\\n\\n    List<Integer> sub = index.subList(n - k, n);\\n    Collections.sort(sub, (a, b) -> a - b);\\n\\n    int[] res = new int[k];\\n    for (int i = 0; i < k; i++) {\\n      res[i] = nums[sub.get(i)];\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624081,
                "title": "intuitive-approach-by-two-sorting",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        # transform nums into nums_with_index and sort it according to value.\\n        # decreasingly\\n        # . e.g.:\\n        #   (3, 1, 2) -> ((0, 3), (1, 1), (2, 2))\\n        #             -> ((0, 3), (2, 2), (1, 1))\\n        nums_with_index = sorted(\\n            [(i, n) for i, n in enumerate(nums)],\\n            key=lambda t: t[1],\\n            reverse=True\\n        )\\n        \\n        # Retrieve the top K element from nums_with_index and sort it with\\n        # position index increasingly. Finally, transform it again by retrieve\\n        # the value of position index from nums\\n        return list(map(\\n            lambda t: nums[t[0]], \\n            sorted(nums_with_index[:k], key=lambda t: t[0])))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        # transform nums into nums_with_index and sort it according to value.\\n        # decreasingly\\n        # . e.g.:\\n        #   (3, 1, 2) -> ((0, 3), (1, 1), (2, 2))\\n        #             -> ((0, 3), (2, 2), (1, 1))\\n        nums_with_index = sorted(\\n            [(i, n) for i, n in enumerate(nums)],\\n            key=lambda t: t[1],\\n            reverse=True\\n        )\\n        \\n        # Retrieve the top K element from nums_with_index and sort it with\\n        # position index increasingly. Finally, transform it again by retrieve\\n        # the value of position index from nums\\n        return list(map(\\n            lambda t: nums[t[0]], \\n            sorted(nums_with_index[:k], key=lambda t: t[0])))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623713,
                "title": "javascript-greedy-111ms",
                "content": "```\\nconst maxSubsequence = (a, k) => {\\n    let b = a.map((x, i) => [x, i]);\\n    b.sort((x, y) => y[0] - x[0]);\\n    let se = new Set(), res = [], n = a.length;\\n    for (let i = 0; i < k; i++) se.add(b[i][1]); // save selected index\\n    for (let i = 0; i < n; i++) {\\n        if (se.has(i)) res.push(a[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst maxSubsequence = (a, k) => {\\n    let b = a.map((x, i) => [x, i]);\\n    b.sort((x, y) => y[0] - x[0]);\\n    let se = new Set(), res = [], n = a.length;\\n    for (let i = 0; i < k; i++) se.add(b[i][1]); // save selected index\\n    for (let i = 0; i < n; i++) {\\n        if (se.has(i)) res.push(a[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623704,
                "title": "java-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        List<Pair>ls = new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            ls.add(new Pair(nums[i],i));\\n        }\\n        \\n\\t\\t// sort in descending order by values\\n        ls.sort((a,b)->b.val-a.val);\\n        \\n\\t\\t//take the first k values in another list\\n        var sub = ls.subList(0,k);\\n\\t\\t\\n        // now sort in ascending order by indices\\n        sub.sort((a,b)->a.idx-b.idx);\\n        \\n\\t\\t// put the values in the answer array and return\\n        int []ans = new int[k];\\n        \\n        for(int i=0;i<k;i++){\\n            ans[i]=sub.get(i).val;\\n        }\\n        \\n        return ans;\\n    \\n    }\\n    \\n    static class Pair{\\n        int val;\\n        int idx;\\n        \\n        public Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxSubsequence(int[] nums, int k) {\\n        \\n        List<Pair>ls = new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            ls.add(new Pair(nums[i],i));\\n        }\\n        \\n\\t\\t// sort in descending order by values\\n        ls.sort((a,b)->b.val-a.val);\\n        \\n\\t\\t//take the first k values in another list\\n        var sub = ls.subList(0,k);\\n\\t\\t\\n        // now sort in ascending order by indices\\n        sub.sort((a,b)->a.idx-b.idx);\\n        \\n\\t\\t// put the values in the answer array and return\\n        int []ans = new int[k];\\n        \\n        for(int i=0;i<k;i++){\\n            ans[i]=sub.get(i).val;\\n        }\\n        \\n        return ans;\\n    \\n    }\\n    \\n    static class Pair{\\n        int val;\\n        int idx;\\n        \\n        public Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623625,
                "title": "c-hashmap-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans, tmp = nums;\\n        \\n        sort(nums.begin(), nums.end(),greater<int> ());\\n        \\n        int i=0;\\n        while(k--){\\n            mp[nums[i]]++;\\n            i++;\\n        }\\n        \\n        for(auto i: tmp){\\n            if(mp[i]-- > 0)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans, tmp = nums;\\n        \\n        sort(nums.begin(), nums.end(),greater<int> ());\\n        \\n        int i=0;\\n        while(k--){\\n            mp[nums[i]]++;\\n            i++;\\n        }\\n        \\n        for(auto i: tmp){\\n            if(mp[i]-- > 0)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623620,
                "title": "c-simple-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n              int n=nums.size();\\n\\n      vector<pair<int,int>>v(n);\\n      for(int i=0;i<n;i++){\\n        v[i]={nums[i],i};\\n      }\\n      \\n      sort(v.rbegin(),v.rend());\\n      \\n      vector<int>ans(k);\\n      vector<pair<int,int>>temp(k);\\n      \\n      for(int i=0;i<k;i++){\\n        temp[i]={v[i].second,v[i].first};\\n      }\\n      \\n      sort(temp.begin(),temp.end());\\n      \\n      for(int i=0;i<k;i++)\\n        ans[i]=temp[i].second;\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n              int n=nums.size();\\n\\n      vector<pair<int,int>>v(n);\\n      for(int i=0;i<n;i++){\\n        v[i]={nums[i],i};\\n      }\\n      \\n      sort(v.rbegin(),v.rend());\\n      \\n      vector<int>ans(k);\\n      vector<pair<int,int>>temp(k);\\n      \\n      for(int i=0;i<k;i++){\\n        temp[i]={v[i].second,v[i].first};\\n      }\\n      \\n      sort(temp.begin(),temp.end());\\n      \\n      for(int i=0;i<k;i++)\\n        ans[i]=temp[i].second;\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623602,
                "title": "100-fast-c-solution-using-hashmap",
                "content": "```\\n vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        vector<int>array=nums;\\n        sort(array.begin(),array.end(),greater<int>());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<k;i++){\\n            mp[array[i]]++;\\n        }\\n        for(auto &i:nums){\\n            if(mp[i]!=0){\\n                ans.push_back(i);\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        vector<int>array=nums;\\n        sort(array.begin(),array.end(),greater<int>());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<k;i++){\\n            mp[array[i]]++;\\n        }\\n        for(auto &i:nums){\\n            if(mp[i]!=0){\\n                ans.push_back(i);\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623460,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>arr=nums;\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(), nums.end(),greater());\\n        for(int i=0;i<k;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:arr){\\n            if(mp[x]!=0){\\n                ans.push_back(x);\\n                mp[x]--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int>arr=nums;\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(), nums.end(),greater());\\n        for(int i=0;i<k;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:arr){\\n            if(mp[x]!=0){\\n                ans.push_back(x);\\n                mp[x]--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623432,
                "title": "code-with-explanation-c-sorting-and-hashmap-solution",
                "content": "Explanation:\\n1. Duplicate the array\\n2. Sort the original array\\n3. Store the last k elements in a map as they will give us the largest sum\\n4. for every element in the duplicate array, if it is present in the answer map, place it in the answer. (for correct ordering in the subsequence)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        map<int,int>ans; //stores the elements in the answer array with their final index\\n        vector<int>prob; //stores the answer to be returned\\n        vector<int>dup; //duplicate of original array\\n        dup=nums;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-k;i<n;i++){\\n            ans[nums[i]]++; //stores last k elements\\n        }\\n        for(int i=0;i<n;i++){\\n            if(ans[dup[i]]>0){\\n                prob.push_back(dup[i]);  //places them at the required position\\n                ans[dup[i]]--;\\n            }\\n        }\\n        return prob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        map<int,int>ans; //stores the elements in the answer array with their final index\\n        vector<int>prob; //stores the answer to be returned\\n        vector<int>dup; //duplicate of original array\\n        dup=nums;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-k;i<n;i++){\\n            ans[nums[i]]++; //stores last k elements\\n        }\\n        for(int i=0;i<n;i++){\\n            if(ans[dup[i]]>0){\\n                prob.push_back(dup[i]);  //places them at the required position\\n                ans[dup[i]]--;\\n            }\\n        }\\n        return prob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623395,
                "title": "c-2099-find-subsequence-of-length-k-with-the-largest-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> tmp = nums;\\n        nth_element(tmp.begin(), tmp.end()-k, tmp.end()); \\n        \\n        int n = nums.size(), threshold = tmp[n-k], larger = 0; \\n        for (auto& x : nums) \\n            if (x > threshold) ++larger; \\n        int equal = k - larger; \\n        vector<int> ans; \\n        for (auto& x : nums) \\n            if (x > threshold || (x == threshold && equal-- > 0)) ans.push_back(x); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector<int> tmp = nums;\\n        nth_element(tmp.begin(), tmp.end()-k, tmp.end()); \\n        \\n        int n = nums.size(), threshold = tmp[n-k], larger = 0; \\n        for (auto& x : nums) \\n            if (x > threshold) ++larger; \\n        int equal = k - larger; \\n        vector<int> ans; \\n        for (auto& x : nums) \\n            if (x > threshold || (x == threshold && equal-- > 0)) ans.push_back(x); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623356,
                "title": "a-few-solutions",
                "content": "Sort an ephemeral copy `B` of the input array `A` to find the `K` maximal values, then iterate through each value `x` of the input array `A` (in its original non-sorted order) to find the corresponding subsequence we can `take` based upon a map `m` which represents the frequency of each value `x` within the `K` maximal values of `A`.\\n\\nNote: we can optimize the extraction of the maximal `K` elements of `A` via a heap, thus improving the asymptotic runtime bound from `O(N * logN)` to `O(N)`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxSubsequence(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        var B = A.copyOf(); B.sort()\\n        var m = mutableMapOf<Int, Int>()\\n        for (i in N - 1 downTo N - K)\\n            m[B[i]] = 1 + m.getOrDefault(B[i], 0)\\n        var take = mutableListOf<Int>()\\n        for (x in A) {\\n            if (m.contains(x) && 0 < m[x]!!) {\\n                take.add(x); m[x] = m[x]!! - 1\\n            }\\n        }\\n        return take.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxSubsequence = (A, K, m = new Map(), take = []) => {\\n    let B = [...A];\\n    B.sort((a, b) => b - a);\\n    for (let i = 0; i < K; ++i)\\n        m.set(B[i], 1 + (m.get(B[i]) || 0));\\n    for (let x of A)\\n        if (m.get(x))\\n            take.push(x), m.set(x, -1 + m.get(x));\\n    return take;\\n};\\n```\\n\\n*Python3: O(N * logN) with sort*\\n```\\nclass Solution:\\n    def maxSubsequence(self, A: List[int], K: int) -> List[int]:\\n        m = Counter(sorted(A)[-K:])\\n        take = []\\n        for x in A:\\n            if x in m and m[x]:\\n                take.append(x); m[x] -= 1\\n        return take\\n```\\n\\n*Python3: O(N) with heap*\\n```\\nclass Solution:\\n    def maxSubsequence(self, A: List[int], K: int) -> List[int]:\\n        m = Counter(nlargest(K, A))\\n        take = []\\n        for x in A:\\n            if x in m and m[x]:\\n                take.append(x); m[x] -= 1\\n        return take\\n```\\n\\n*C++: O(N * logN) with sort*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI maxSubsequence(VI& A, int K, Map m = {}, VI take = {}) {\\n        VI B{ A };\\n        sort(B.rbegin(), B.rend());\\n        for (auto i{ 0 }; i < K; ++i)\\n            ++m[B[i]];\\n        for (auto x: A)\\n            if (m[x])\\n                take.push_back(x), --m[x];\\n        return take;\\n    }\\n};\\n```\\n\\n*C++: O(N) with heap*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI maxSubsequence(VI& A, int K, Map m = {}, VI take = {}) {\\n        auto B{ A };\\n        nth_element(B.begin(), B.begin() + K, B.end(), std::greater<int>());\\n        for (auto i{ 0 }; i < K; ++i)\\n            ++m[B[i]];\\n        for (auto x: A)\\n            if (m[x])\\n                take.push_back(x), --m[x];\\n        return take;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxSubsequence(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        var B = A.copyOf(); B.sort()\\n        var m = mutableMapOf<Int, Int>()\\n        for (i in N - 1 downTo N - K)\\n            m[B[i]] = 1 + m.getOrDefault(B[i], 0)\\n        var take = mutableListOf<Int>()\\n        for (x in A) {\\n            if (m.contains(x) && 0 < m[x]!!) {\\n                take.add(x); m[x] = m[x]!! - 1\\n            }\\n        }\\n        return take.toIntArray()\\n    }\\n}\\n```\n```\\nlet maxSubsequence = (A, K, m = new Map(), take = []) => {\\n    let B = [...A];\\n    B.sort((a, b) => b - a);\\n    for (let i = 0; i < K; ++i)\\n        m.set(B[i], 1 + (m.get(B[i]) || 0));\\n    for (let x of A)\\n        if (m.get(x))\\n            take.push(x), m.set(x, -1 + m.get(x));\\n    return take;\\n};\\n```\n```\\nclass Solution:\\n    def maxSubsequence(self, A: List[int], K: int) -> List[int]:\\n        m = Counter(sorted(A)[-K:])\\n        take = []\\n        for x in A:\\n            if x in m and m[x]:\\n                take.append(x); m[x] -= 1\\n        return take\\n```\n```\\nclass Solution:\\n    def maxSubsequence(self, A: List[int], K: int) -> List[int]:\\n        m = Counter(nlargest(K, A))\\n        take = []\\n        for x in A:\\n            if x in m and m[x]:\\n                take.append(x); m[x] -= 1\\n        return take\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI maxSubsequence(VI& A, int K, Map m = {}, VI take = {}) {\\n        VI B{ A };\\n        sort(B.rbegin(), B.rend());\\n        for (auto i{ 0 }; i < K; ++i)\\n            ++m[B[i]];\\n        for (auto x: A)\\n            if (m[x])\\n                take.push_back(x), --m[x];\\n        return take;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI maxSubsequence(VI& A, int K, Map m = {}, VI take = {}) {\\n        auto B{ A };\\n        nth_element(B.begin(), B.begin() + K, B.end(), std::greater<int>());\\n        for (auto i{ 0 }; i < K; ++i)\\n            ++m[B[i]];\\n        for (auto x: A)\\n            if (m[x])\\n                take.push_back(x), --m[x];\\n        return take;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623339,
                "title": "runtime-12-ms-faster-than-69-23-memory-usage-9-4-mb-less-than-92-31",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int> &nums, int k) {\\n        vector<int> a=nums, res, ans;\\n        sort(a.begin(), a.end()); // O(nlogn)\\n        for(int i=a.size()-1; ; i--) // O(k)\\n        {\\n            if(k==0)\\n                break;\\n            res.push_back(a[i]); // forming subsequence of largest sum\\n            k--;\\n        } // we have res but its not ordered as it should be like in nums\\n        for(int i=0; i<nums.size(); i++) // O(n) - at worst case res\\'s element can be at the end of nums\\n        {\\n            if(res.size()==0)\\n                break;\\n            vector<int>::iterator it = std::find(res.begin(), res.end(), nums[i]); // O(k) - linear search in res\\n            if(it != res.end())\\n            {\\n                ans.push_back(nums[i]); // form actual answer according to ordering in nums \\n                int x=it-res.begin();\\n                res.erase(res.begin()+x); // dont want to add same element again \\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int> &nums, int k) {\\n        vector<int> a=nums, res, ans;\\n        sort(a.begin(), a.end()); // O(nlogn)\\n        for(int i=a.size()-1; ; i--) // O(k)\\n        {\\n            if(k==0)\\n                break;\\n            res.push_back(a[i]); // forming subsequence of largest sum\\n            k--;\\n        } // we have res but its not ordered as it should be like in nums\\n        for(int i=0; i<nums.size(); i++) // O(n) - at worst case res\\'s element can be at the end of nums\\n        {\\n            if(res.size()==0)\\n                break;\\n            vector<int>::iterator it = std::find(res.begin(), res.end(), nums[i]); // O(k) - linear search in res\\n            if(it != res.end())\\n            {\\n                ans.push_back(nums[i]); // form actual answer according to ordering in nums \\n                int x=it-res.begin();\\n                res.erase(res.begin()+x); // dont want to add same element again \\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623326,
                "title": "python-sorting-solution",
                "content": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        x = sorted(nums, reverse=True)\\n        s = Counter(x[:k]) #get largest k num\\n        \\n        res = []\\n\\t\\t# To be in order so the extra step is needed\\n        for num in nums:\\n            if s[num] > 0:\\n                res.append(num)\\n                s[num] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        x = sorted(nums, reverse=True)\\n        s = Counter(x[:k]) #get largest k num\\n        \\n        res = []\\n\\t\\t# To be in order so the extra step is needed\\n        for num in nums:\\n            if s[num] > 0:\\n                res.append(num)\\n                s[num] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623318,
                "title": "python-simple-using-window",
                "content": "If `A[i]` is greater than the minimum element in the window, just replace it with `A[i]`.\\n\\n```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        window = nums[:k]\\n\\n        for i in range(k,n):\\n            curr_min = min(window)\\n            \\n            if nums[i] > curr_min:\\n                window.remove(curr_min)\\n                window.append(nums[i])\\n\\n        return window\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        window = nums[:k]\\n\\n        for i in range(k,n):\\n            curr_min = min(window)\\n            \\n            if nums[i] > curr_min:\\n                window.remove(curr_min)\\n                window.append(nums[i])\\n\\n        return window\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623315,
                "title": "python3-o-n-quick-select",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b553623546e2799477b8bca6b5c89f22c83a4d08) for solutions of weekly 67. \\n\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        temp = nums[:]\\n        shuffle(temp)\\n        \\n        def part(lo, hi): \\n            \"\"\"Return partition of nums[lo:hi].\"\"\"\\n            i, j = lo+1, hi-1\\n            while i <= j: \\n                if temp[i] < temp[lo]: i += 1\\n                elif temp[j] > temp[lo]: j -= 1\\n                else: \\n                    temp[i], temp[j] = temp[j], temp[i]\\n                    i += 1\\n                    j -= 1\\n            temp[lo], temp[j] = temp[j], temp[lo]\\n            return j \\n        \\n        lo, hi = 0, len(temp)\\n        while lo <= hi: \\n            mid = part(lo, hi)\\n            if mid < len(temp)-k: lo += 1\\n            elif mid == len(temp)-k: break \\n            else: hi = mid \\n        threshold = temp[mid]\\n        \\n        larger = sum(x > threshold for x in nums)\\n        equal = k - larger\\n        \\n        ans = []\\n        for x in nums: \\n            if x > threshold: ans.append(x)\\n            elif x == threshold: \\n                if equal: \\n                    equal -= 1\\n                    ans.append(x)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        temp = nums[:]\\n        shuffle(temp)\\n        \\n        def part(lo, hi): \\n            \"\"\"Return partition of nums[lo:hi].\"\"\"\\n            i, j = lo+1, hi-1\\n            while i <= j: \\n                if temp[i] < temp[lo]: i += 1\\n                elif temp[j] > temp[lo]: j -= 1\\n                else: \\n                    temp[i], temp[j] = temp[j], temp[i]\\n                    i += 1\\n                    j -= 1\\n            temp[lo], temp[j] = temp[j], temp[lo]\\n            return j \\n        \\n        lo, hi = 0, len(temp)\\n        while lo <= hi: \\n            mid = part(lo, hi)\\n            if mid < len(temp)-k: lo += 1\\n            elif mid == len(temp)-k: break \\n            else: hi = mid \\n        threshold = temp[mid]\\n        \\n        larger = sum(x > threshold for x in nums)\\n        equal = k - larger\\n        \\n        ans = []\\n        for x in nums: \\n            if x > threshold: ans.append(x)\\n            elif x == threshold: \\n                if equal: \\n                    equal -= 1\\n                    ans.append(x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623308,
                "title": "c-easy-to-understtand-using-vector-of-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static comp2(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.first>b.first;\\n    }\\n    bool static comp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector< pair<int,int> > v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[i].first=nums[i];\\n            v[i].second=i;\\n        }\\n        sort(v.begin(),v.end(),comp2);\\n        vector< pair<int,int> > ans;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(v[i]);\\n            c++;\\n            if(c==k)\\n            break;\\n        }\\n        vector<int> res;\\n        sort(ans.begin(),ans.end(),comp);\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            res.push_back(ans[i].first);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp2(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.first>b.first;\\n    }\\n    bool static comp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        vector< pair<int,int> > v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[i].first=nums[i];\\n            v[i].second=i;\\n        }\\n        sort(v.begin(),v.end(),comp2);\\n        vector< pair<int,int> > ans;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(v[i]);\\n            c++;\\n            if(c==k)\\n            break;\\n        }\\n        vector<int> res;\\n        sort(ans.begin(),ans.end(),comp);\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            res.push_back(ans[i].first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068244,
                "title": "simple-solution-using-map-and-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push({nums[i],i});\\n        }\\n       vector<int> ans;\\n       map<int,int> mp;\\n        while(k>0){\\n            auto it = pq.top();\\n            mp[it.second]=it.first;\\n            pq.pop();\\n            k--;\\n        }\\n        for(auto it:mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push({nums[i],i});\\n        }\\n       vector<int> ans;\\n       map<int,int> mp;\\n        while(k>0){\\n            auto it = pq.top();\\n            mp[it.second]=it.first;\\n            pq.pop();\\n            k--;\\n        }\\n        for(auto it:mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063913,
                "title": "c-heap-priority-queue-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int n= nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             pq.push(nums[i]);\\n            \\n             if(pq.size()>k)\\n                 pq.pop();\\n        }\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> umap;\\n        while(!pq.empty())\\n        {\\n            umap[pq.top()]++;\\n            pq.pop();\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(nums[i])!=umap.end())\\n            {ans.push_back(nums[i]);\\n              umap[nums[i]]--;\\n             if(umap[nums[i]]==0)\\n                 umap.erase(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int n= nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             pq.push(nums[i]);\\n            \\n             if(pq.size()>k)\\n                 pq.pop();\\n        }\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> umap;\\n        while(!pq.empty())\\n        {\\n            umap[pq.top()]++;\\n            pq.pop();\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(nums[i])!=umap.end())\\n            {ans.push_back(nums[i]);\\n              umap[nums[i]]--;\\n             if(umap[nums[i]]==0)\\n                 umap.erase(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063462,
                "title": "80-runtime-85-memory-heapq-counting-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/c34fb78d-397d-471c-90d4-47e31787ab28_1695111992.6563704.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        d, res = {}, []; d_get = d.get\\n\\n        for n in heapq.nlargest(k,nums):\\n            d[n] = d_get(n,0) + 1\\n\\n        for n in nums:\\n            if d_get(n,0):\\n                d[n] -= 1; res.append(n)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\\n        d, res = {}, []; d_get = d.get\\n\\n        for n in heapq.nlargest(k,nums):\\n            d[n] = d_get(n,0) + 1\\n\\n        for n in nums:\\n            if d_get(n,0):\\n                d[n] -= 1; res.append(n)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056335,
                "title": "beats-90-simple-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        a=[]\\n        b=[]\\n        c=[]\\n        j=0\\n        for i in nums:\\n            a.append([j,i])\\n            j+=1\\n        a.sort(key=lambda x:x[1],reverse=True)\\n        for i in range(k):\\n            b.append(a[i])\\n        b.sort(key=lambda x:x[0])\\n        for i in b:\\n            c.append(i[1])\\n        return (c)\\n        \\n            \\n    \\n        \\n        \\n\\n\\n    \\n    \\n\\n        \\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        a=[]\\n        b=[]\\n        c=[]\\n        j=0\\n        for i in nums:\\n            a.append([j,i])\\n            j+=1\\n        a.sort(key=lambda x:x[1],reverse=True)\\n        for i in range(k):\\n            b.append(a[i])\\n        b.sort(key=lambda x:x[0])\\n        for i in b:\\n            c.append(i[1])\\n        return (c)\\n        \\n            \\n    \\n        \\n        \\n\\n\\n    \\n    \\n\\n        \\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043902,
                "title": "easy-pq-vector-pairing-cpp",
                "content": "# Intuition\\nThe intuition behind this solution is to use a priority queue (max heap) to keep track of the elements in the input array `nums` along with their indices. By repeatedly extracting the maximum element from the priority queue `k` times, we can build a subsequence of length `k` with the largest sum.\\n\\n# Approach\\n1. Create a priority queue `pq` to store pairs of values from `nums` along with their indices. Each element in `pq` will be represented as `{nums[i], i}` where `nums[i]` is the value from the input array, and `i` is its index.\\n\\n2. Iterate through the `nums` array and insert each element along with its index into the priority queue `pq`.\\n\\n3. Initialize an empty vector `vec` to store pairs `{index, value}` from the priority queue. We will use this vector to keep track of the `k` largest elements.\\n\\n4. While the priority queue `pq` is not empty and `k` is greater than 0, do the following:\\n   - Pop the top element from the priority queue, which is the maximum element based on its value.\\n   - Add the pair `{index, value}` to the `vec` vector.\\n   - Decrement `k` by 1.\\n\\n5. Sort the `vec` vector based on the indices to ensure that the subsequence elements are in their original order.\\n\\n6. Create an empty vector `ans` to store the final subsequence.\\n\\n7. Iterate through the sorted `vec` vector and add the values to the `ans` vector.\\n\\n8. Return the `ans` vector as the subsequence of length `k` with the largest sum.\\n\\n# Complexity\\n- Time complexity: O(n*log(n)), where n is the length of the input array `nums`. The most time-consuming part of the algorithm is sorting the `vec` vector, which takes O(n*log(n)) time.\\n- Space complexity: O(n), as we use additional space to store the `pq` priority queue and the `vec` vector, both of which can have a maximum of `n` elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<vector<int>>vec;\\n        while(!pq.empty() and k>0){\\n            vec.push_back({pq.top().second,pq.top().first});\\n            k--;\\n            pq.pop();\\n        }\\n        sort(vec.begin(),vec.end());\\n        vector<int>ans;\\n        for(auto i:vec) ans.push_back(i[1]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<vector<int>>vec;\\n        while(!pq.empty() and k>0){\\n            vec.push_back({pq.top().second,pq.top().first});\\n            k--;\\n            pq.pop();\\n        }\\n        sort(vec.begin(),vec.end());\\n        vector<int>ans;\\n        for(auto i:vec) ans.push_back(i[1]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006948,
                "title": "c-priority-queue-heap-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  static bool comp(pair<int,int>&p1,pair<int,int>&p2)\\n    {\\n      return p1.second<p2.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n          int sz=nums.size();\\n          \\n          for(int i=0;i<sz;i++)\\n           {\\n             if(pq.size()<k)\\n                 pq.push({nums[i],i});\\n             else if(pq.top().first<nums[i])\\n                pq.pop(),pq.push({nums[i],i});    \\n           }\\n           vector<pair<int,int>>v;\\n            while(!pq.empty())\\n              {\\n                v.push_back(pq.top());\\n                pq.pop();\\n              }\\n             sort(begin(v),end(v),comp);\\n             vector<int>res;\\n             for(auto it:v)\\n              res.push_back(it.first);\\n              return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(pair<int,int>&p1,pair<int,int>&p2)\\n    {\\n      return p1.second<p2.second;\\n    }\\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n          int sz=nums.size();\\n          \\n          for(int i=0;i<sz;i++)\\n           {\\n             if(pq.size()<k)\\n                 pq.push({nums[i],i});\\n             else if(pq.top().first<nums[i])\\n                pq.pop(),pq.push({nums[i],i});    \\n           }\\n           vector<pair<int,int>>v;\\n            while(!pq.empty())\\n              {\\n                v.push_back(pq.top());\\n                pq.pop();\\n              }\\n             sort(begin(v),end(v),comp);\\n             vector<int>res;\\n             for(auto it:v)\\n              res.push_back(it.first);\\n              return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567088,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1735728,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1576862,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1977030,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1965517,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1841725,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1793602,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1576076,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1948295,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1816898,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1567088,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1735728,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1576862,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1977030,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1965517,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1841725,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1793602,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1576076,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1948295,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            },
            {
                "id": 1816898,
                "content": [
                    {
                        "username": "santu6575",
                        "content": "![image](https://assets.leetcode.com/users/images/27d154a5-1d66-477d-875b-97eb24859ba0_1639238809.814456.png)\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: a boolean array to keep track of elements you\\'ve picked."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "can you explain that?\\n"
                    },
                    {
                        "username": "mohdabidaliusa",
                        "content": "Please Help. Can this question be done with sliding window?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "No. This problem is about subsequence (which can be NOT contiguous), not subarray."
                    },
                    {
                        "username": "nikhiln92",
                        "content": "no sliding window we cannot use as we have to find the subsequence, means there will be gap between the selected elements. So, no fixed or variable window is possible"
                    },
                    {
                        "username": "yashvi_sharma",
                        "content": "Hi, I am issue with the order of the output.\\nin case3 : \\nmy output: [4,3]\\nexpected :  [3,4]\\nit is accepted, but in case 2 :\\nmy output: [4,3,-1]\\nexpected :  [-1,3,4]\\nit is wrong.\\nCan anyone explain, what i am missing?"
                    },
                    {
                        "username": "ANANAzZz",
                        "content": "A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. You can't make [4, 3, -1] from [-1,-2,3,4] by deleting elements (order of elements should be similar with input array). That's why [-1, 3, 4] is the only right answer in this test case."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "# Tip\\n1. Sort the array maintaining their index.\\n `sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])`\\n2. Take the last k elements and sort on basis of index.\\n3. Append the elements to the result array.\\n`res = [x for i, x in sorted(sorted_nums[-k:])]`\\n4. Return the result array."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man it was hard for mee "
                    },
                    {
                        "username": "taid15604",
                        "content": "Hi, I am having testcase issue where my output numbers are the same as the expected but just not in the right order. I thought the order did not matter. Can anyone provide some insight on what I might be missing.\nCase output:     [-65,-60,-59,-55,-17,-10,2,61,63]\nCase expected: [63,61,-17,-55,-59,-10,2,-60,-65]"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "[@kos2kos](/kos2kos)  Could you please explain it again.. I am stuck on the same test case\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "You have to maintain the ordering it was provided in. It is not a matter of returning only max k elements but also the order they are in the array. Think about how to preserve the index ordering."
                    },
                    {
                        "username": "exf271828",
                        "content": "The only idea I had during contest is to iterate over possible combinations of k from n. There is standard algorithm to enumerate these, but I do not consider this to be easy solution! Reviewing discussions I did not find any easy solution yet. It might be of \"Medium\" difficulty, but by no means \"Easy\".\\n\\nNow I see 2 hints from leetcode (which were not available during contest):\\nHint1: From a greedy perspective, what k elements should you pick?\\nHint2: Could you sort the array while maintaining the index?\\n\\nTo be onest, these hints do not help me at all. But \"Hint2\" I just do not understand! This confirms that this problem needs special knowledge of algorithms. Not easy at all.\\n\\nI was writing code for living for years...  Years ago I studied some advanced math...  With all my experience I can repeat again: This is NOT an EASY problem! \\nThis is actually confirmed by fact: Accepted 3.4K from 9.4K Submissions\\n\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Actually its a very very easy question, if you got your fundamentals of stack and multiset(or stack and map) on point."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Since you need to preserve the ordering of elements too, think about using a stack."
                    },
                    {
                        "username": "kos2kos",
                        "content": "\\n       public int[] maxSubsequence(int[] nums, int k) {\\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        public int[] maxSubsequence(int[] nums, int k) {\\n        int[] indices = new int[k];\\n        //Value to Index \\n        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<>();\\n        HashMap<Integer, Integer> indexHash = new HashMap<>();\\n\\n        if (nums.length == k){\\n            return nums;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            LinkedList<Integer> list = \\n                hash.getOrDefault(nums[i], new LinkedList<>());\\n            list.add(i);\\n            hash.put(nums[i], list);\\n            indexHash.put(i, nums[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for (int i = 0; i < k; i++){\\n            // for the largest numbers up to k get me the index for them\\n            indices[i] = hash.get(nums[nums.length - 1 -i]).pop();\\n         }\\n        \\n        Arrays.sort(indices);\\n\\n        for (int index = 0; index < k ; index++){\\n            indices[index] = indexHash.get(indices[index]);\\n        }\\n\\n        return indices;\\n    }"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Definitely feels like a medium problem because you have to preserve the ordering. There is space to clean up this code, this is my first attempt."
                    }
                ]
            }
        ]
    }
]