[
    {
        "title": "Shift 2D Grid",
        "question_content": "Given a 2D grid of size m x n&nbsp;and an integer k. You need to shift the grid&nbsp;k times.\nIn one shift operation:\n\n\tElement at grid[i][j] moves to grid[i][j + 1].\n\tElement at grid[i][n - 1] moves to grid[i + 1][0].\n\tElement at grid[m&nbsp;- 1][n - 1] moves to grid[0][0].\n\nReturn the 2D grid after applying shift operation k times.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[9,1,2],[3,4,5],[6,7,8]]\n\nExample 2:\n\nInput: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\nOutput: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\nExample 3:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\n\n&nbsp;\nConstraints:\n\n\tm ==&nbsp;grid.length\n\tn ==&nbsp;grid[i].length\n\t1 <= m <= 50\n\t1 <= n <= 50\n\t-1000 <= grid[i][j] <= 1000\n\t0 <= k <= 100",
        "solutions": [
            {
                "id": 1934961,
                "title": "c-simple-clean-code-with-explanation",
                "content": "***It is a observation based question.***\\n\\nIf **k** is **1** then new column is **(j+1)** and if **k** is **k** then new column is **(j+k)** and new column should in range **[0,m-1]**. So new column is **(j+k)%m**.\\n\\nFor row, we have to first **find the number of rows added to previous row** which is equal to the **number of times (j+k) exceeds m**. So, number of rows added is **(j+k)/m**.\\n\\nSo, new row is **(i + (j+k)/m)** and new row should in range **[0,n-1]**. So new row is **(i + (j+k)/m)%n**.\\n\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934848,
                "title": "easy-java-code-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N+N)=O(2N)=O(N)\\nSpace Complexity=O(N)***\\n\\n<hr>\\n<hr>\\n\\n***UPVOTE if you like the post(^///^)***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431225,
                "title": "python-functional-programming-3-lines",
                "content": "shift all the numbers `k` steps, is the same idea as, moving last `k` numbers to head of the list: `nums = nums[-k:] + nums[:-k]`\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\\n# Functional Programming, 3 lines:\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458848,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere are some similar matrix(2D Grid) problems.\\n* 498 [Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)\\n* 566 [Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/)\\n* 867 [Transpose Matrix](https://leetcode.com/problems/transpose-matrix/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934852,
                "title": "python-3-lines-3-steps-clean-and-simple-solution",
                "content": "\\n**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060180,
                "title": "java-100-1ms-o-m-n-matrix-to-matrix-copy-optimized-for-speed-explanation",
                "content": "This code is optimized for speed.  It usually runs in 1ms, although sometimes 2ms, as of Feb 10, 2021.  May be slower in future years if more test cases are added or running on different server.\\n\\nThis algorithm first creates a result matrix the same size as `grid[][]`, then uses two loops to copy-and-shift from `grid[][]` to the result matrix.  The result matrix is converted to a `List<List<Integer>>` in the return statement, by using the `Arrays.asList()` method.\\n\\nFor copying from the input matrix `grid[][]` to the output `result[][]` matrix, first calculate the row and column of the `grid[][]` value that will be copied to `result[0][0]` in the output result matrix.  The start row and column to copy from `grid[][]` with be the `k`th value from the rottom right end of the `grid[][]` matrix.  This start row and column are the variables `kRow` and `kCol`.  The start row and column to the output `result[][]` matrix, are `r=0` and `c=0`.  While copying, `kCol` will advance along the columns in a row, until the end of the row, then start copying from column 0 in the next row.\\n![image](https://assets.leetcode.com/users/images/16a7cd10-62f3-4410-b697-bbe760e4bbd3_1614849399.1848493.png)\\n\\nTo make the copying of each numeric value faster, the current rows of `grid` and `result` are referenced by one-dimensional array variables.  The one-dimensional array variables `innRow[]` and `outRow` are references to a single row of the matrix `grid[][]` and `result[][]` respectively.  So changing a value in `outRow[]` also changes the corresponding value in a row of `result[][]` because the changed value is actually the same memory location within both variables.  The one-dimensional arrays `innRow[]` and `outRow[]` are simply short-cuts to a single row of `grid[][]` or `result[][]`.   These one-dimensional array variables for the current rows are changed when advancing to a new row in either `grid` or `result`.  The one-dimensional array variables make the copying faster because each time a single numeric value is copied from `grid` to `result`, the compiled code only has to calculate one-dimensional references within the rows (i.e. `innRow[kCol]` or `outRow[r]`), instead repeatedly calculating two-dimensional references within a matrix (i.e. `grid[kRow][kCol]` or `result[r][c]`).\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\\n--- Update ---:\\nAfter a question about the `\"return (List)Arrays.asList(result);\"` statement in the above code, asking how this statement works, I decided to explain this further.  The `Arrays.asList(result)` is used to supposedly create a List from `result`, by creating a `List<List<Integer>>` from the `int[][] result`.  But the `List<List<Integer>>` is **not** a copy of the `result` array, but instead is a `List` that contains **references into** the `result` array.  Changing a value in the `result` array will change the corresponding value in the `List`, and changing a value in the `List` will change the corresponding value in `result`, because both of these are the same value stored in a single memory location, with two different paths to access that value.  The `List` created by `Arrays.asList(...)` is also a **fixed** size `List` which cannot be added to and cannot be removed from.  In other words, the `List` resulting from `Arrays.asList(...)` is not a normal simple `List`.\\n\\nI am not completely sure why the cast `(List)` is needed before the `Arrays.asList`, but the compiler is unhappy without this cast.\\n\\nI used `(List)Arrays.asList(result)` because I assumed `Arrays.asList` could create the List of Lists faster than writing my own code to create the Lists one value at a time.  I have not tested to see if this method is faster than writing my own code to create the List of Lists.\\n\\nAnother curious thing is inserting the following lines before the `return` statement in the code above:\\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```\\nThese inserted lines of code will print the following output:\\n\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.ArrayList`\\n\\nWhich shows that the `List` created by `Arrays.asList` is not quite the same as a `List` created in the more normal way.  I do not yet understand enough of the internal details of Java to explain this difference, and I cannot explain why the cast of `(List)` is needed to make the compiler happy.  If someone knows why the cast `(List)` is needed, or how Lists created by `Arrays.asList(...)` are different than normal Lists, please inform us in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734727,
                "title": "javascript-es6-simple-solution",
                "content": "Brief explanation: \\n1. Convert the matrix to an array \\n2. Move the array bottom to the start K times\\n3. Convert the array back to a matrix and return \\n\\n```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434335,
                "title": "python3-2-simple-approaches-with-explanations-by-creating-a-vector",
                "content": "# **Algorithm:**\\n1)  put the matrix row by row to a vector.\\n2)  rotate the vector k times.\\n3)  put the vector to the matrix back the same way.\\n\\nThe **second step** is the same as problem [#189 (Rotate an Array)](https://leetcode.com/problems/rotate-array/), and can be solved in many ways, but here we consider **two approaches** that are simple and have reasonable time and space complexities: \\n**(a) direct shift approach**\\n**(b) reverse approach**\\n\\nAs an example of **Approach (a)**, imagine we want to rotate the vector [1, 2, 3, 4, 5, 6, 7] for k = 3 times. We just need to add these two subsets of the vector, respectively: last k elements and first len(vec)-k elements:\\n[5, 6, 7] +  [1, 2, 3, 4] = [5, 6, 7, 1, 2, 3, 4]\\n\\nAn example of **Approach (b)**:\\nreverse all elements     : [7, 6, 5, 4, 3, 2, 1]\\nreverse first k elements : [5, 6, 7, 4, 3, 2, 1]\\nreverse last len(vec)-k elements : [5, 6, 7, 1, 2, 3, 4]\\n\\nAlthough approach (a) seems simpler, it take additional space (needs an extra vector in addition to the vector created in step 1). Approach (b) might need extra code lines, but does not take additional space.\\n\\n# **Python3 codes:**\\n\\n**Approach (a), direct shift:**\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\\n\\n\\n**Approach (b), reverse method**: (Note that only step 2 has changed):\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1934644,
                "title": "c-flatten-array-then-convert-back-to-2d-struggled-live-on-stream",
                "content": "This one was tricky for me, had to get lots of help from chat.\\n\\nWe stream everyday 6PM PT.  There are dozens of us.  Link in profile.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937723,
                "title": "python-2-solutions-clean-concise-easy-o-1-in-space-complexity",
                "content": "- If we treat grid as an array, we can solve this problem as the same idea with **[189. Rotate Array](https://leetcode.com/problems/rotate-array/discuss/258789/)** problem.\\n- That is, the index of the array `idx`, will be map with the grid cell at `grid[idx // nCols][idx % nCols]`.\\n\\n**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(nRows * nCols)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse in splace**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934795,
                "title": "c-two-approaches-with-intuition",
                "content": "# Shift 2D Grid\\nThe problem at hand requires us to shift a 2D grid to the right cyclically k times. It is the equivalent of applying right shift operation k times.\\nOne right shift operation does the following:\\n(i,j) becomes (i, j+1)\\nif j == n-1, then it becomes (i+1, 0)\\nif j == n-1 and i == m-1, then it becomes (0, 0)\\n\\n## Approach 1 Calculate Indices for each element\\nIn this approach, we make a copy of the entire matrix, and then fill it with the corresponding elements according to the shifted coordinates.\\n```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\\nThe above function gives the shifted coordinates given the original coordinates and the shifted amount. We could call this function at every (i,j) in the matrix and fill the corresponding place.\\n\\nBut this approach would be slow, as we would have to make O(m*n) calls just to this function.\\nA better way to do this is to just call it once for the starting point, and then keep right shifting once for every subsequent element.\\n\\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\\n\\nThis code calculates the next position given the new position of the previous point (ni, nj)\\n\\nSo the full code for this approach is as follows:\\n### Code (C++)\\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(m * n) (for returning the new matrix)\\n\\n## Approach 2: Treat Matrix as Array and Right Shift k Times\\nWe already have a good approach for right shifting an array k times;\\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\\nIf we can treat the whole matrix as a flat array, we can apply the same algorithm and solve this question very easily.\\nTo do this, we can\\'t use the normal reverse function, as it warrants flattening the matrix, which we actually don\\'t need. We just need to *pretend* that the matrix is flattened..\\nThis is accomplished by taking the array coordinates and mapping them to row and column indices underneath.\\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\\nOnce this modification is made, the whole problem reduces to just three more statements\\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\\n\\n### Code (C++) \\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```\\n\\n### Caution!\\nThis code modifies the input matrix itself.\\nI regard this as a *hacky* way of achieving O(1) extra space, since one is bound to require some space for storing the output of the program. Plus this approach can lead to loss of information if implemented incorrectly. So take care while using it, or just make a copy of the input matrix and apply this algorithm on it instead.\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(1) (see above Caution)\\n\\n\\n**Upvote** if you liked this post and would like to see more of these in the future. Leave any doubts or suggestions in the comments.\\nDo you agree with the notion of modifying the input itself in order to get O(1) space?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708897,
                "title": "java-simple-one-loop",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935498,
                "title": "c-intuitive-approach-clean-solution-with-comments",
                "content": "Make a 1-D vector and push all element in that\\nNow calculate the index from which the modified grid will be started and then update the grid\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934690,
                "title": "very-simple-solution",
                "content": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516488,
                "title": "c-clean-code-98-runtime-100-space",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934572,
                "title": "java-simple-solution-time-o-n-space-o-1-faster-than-95-74",
                "content": "If the return ArrayList does not count space then its space complexity is O(1).\\nThe time complexity is O(n) where n is the count of all grid items.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936908,
                "title": "conceptually-straightforward-javascript-solution-nested-unshift-pop-76ms",
                "content": "My first concrete idea was a map adding each element by k % n or some sort of length but then the pop push shift came to mind and was more straight forward for me to implement. \\n\\nIt works the way I visualize the matrix to shift in the example. The element at the end of each row is popped off and unshifted to the beginning of the next. The last row wraps around to the first row with the modulo. \\n\\nMy fastest submission was 68ms - 100% \\n```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```\\n\\nMy fastest submission was 78ms -- 100% as of 4/11\\n\\n![image](https://assets.leetcode.com/users/images/794f6eed-1983-4020-8bd8-68d7cb788a37_1649695793.5833466.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934734,
                "title": "python-in-place-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven a 2D array `grid`, we want to return the array after its elements have been shifted to the right (wrapped by rows) by `k` positions.\\n\\nMany solutions involve initialising the resultant array and mapping each element in the original array to its final position in the resultant array. However, these solutions require O(mn) space (note: O(1) auxiliary space, but O(mn) space), where `m` is the number of rows in `grid` and `n` is the number of columns in `grid`.\\n\\nThis post presents an in-place solution; we are able to get the resultant array by modifying the original array. And yes, this will be done in the most optimal way possible; the time complexity for this solution is O(mn), which is comparable to many other solutions.\\n\\n---\\n\\n### Explanation\\n\\nThe main logic behind how the code operates is as follows: Upon mapping an element from its original index to its resultant index, **we will swap the element at the current index with the resultant element, and continue by finding the resultant index for the new element**. We do this until either 1) all the elements have been swapped; or 2) we reaxh the initial index. To illustrate, the following sequence is for one shift operation, i.e., `k = 1`:\\n\\n```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\\n\\nSometimes, we will end up on the initial index before all the elements have been successfully swapped. Take for example:\\n\\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\\n\\nIn such instances, **we would need to increment the initial index by 1 and continue with the next element**. Note that if we know that some elements have not yet been swapped, then we know that the element after the index has incremented by 1 has not been swapped, since if `k = 1`, all the elements would have been swapped before the initial index has been reached.\\n\\n---\\n\\n### Approach 1: GCD\\n\\nHow then do we know if the loop will reach the initial index before all elements are swapped, and how many times do we need to increment the initial index? **One way is to use the greatest common divisor (GCD) between the number of elements in `grid` and `k`, which gives us the number of times we need to increment the initial index**.\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\\n \\n **TC: O(mn)**, since each index is looped through only once.\\n Note: for time complexity of `math.gcd()`, you can read more [here](https://codility.com/media/train/10-Gcd.pdf).\\n **SC: O(1)**, as discussed previously.\\n \\n ---\\n \\n ### Approach 2: Counter\\n \\n A simpler way to determine if all elements have been swapped is to **have a counter for the number of elements that have been swapped so far**. If there are elements left to swap, increment the initial index; otherwise, return the resultant array.\\n \\n ```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```\\n\\n**TC: O(mn)**, as discussed previously.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [],
                "code": "```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\n```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431311,
                "title": "easy-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934602,
                "title": "4-liner-code-of-c-without-k-times-rotation",
                "content": "**C++ Easy Solution Without Actually Rotating Matrix K times \\n4 Liner Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n**Please Upvote and Like**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935964,
                "title": "python-o-mn-solution-explained",
                "content": "Let us create `ans` with zeroes. Then for each element we calculate where it should go and fill this element.\\n\\n#### Complexity\\nIt is `O(mn)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935910,
                "title": "just-flatten-and-rotate-the-array",
                "content": "**OBSERVATION:**\\nIf we trace the path of any number/index as we do the operation multiple times we find that the number is merely traversing the matrix row-wise. Take 1 for example and look at its path.\\n\\n1. This gives us an idea to flatten out the array and rotate it k times to get the final matrix in Row Major Order. \\n2. One other thing to notice is that after M X N number of operations, the resulting matrix is the original matrix. Hence we can update k as **`k = k % ( m * n )`.** \\n3. The rotation algorithm can be practiced from [Leetcode 189. Rotate Array](https://leetcode.com/problems/rotate-array/).\\n\\n![image](https://assets.leetcode.com/users/images/9d02625d-10dc-4598-88d5-0ae7d26efc96_1649671829.3801272.png)\\n\\n**STEPS:**\\n1. Flatten out the array.\\n2. Rotate the array k times.\\n3. Resulting list is a Row Major representation of our answer array. So convert this 1d Array to 2d Matrix.\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\\n**NOTE:** \\n**`grid = [[arr[i*n+j] for j in range(n)] for i in range(m)]`** is just a shorter way for doing the following:\\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598647,
                "title": "c-neat-easily-understandable-indented-code",
                "content": "I have used deque from the STL library.\\n\\n```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 488404,
                "title": "python-simple-o-m-n-95-100-extra-space-used",
                "content": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 433298,
                "title": "javascript-solution-with-comments",
                "content": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "solutionTags": [],
                "code": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1937275,
                "title": "c-very-easy-to-logic",
                "content": "I would suggest just dry run the code and you will get the intution.\\n\\n```class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n            for(int i=row-1;i>=1;i--)\\n            {\\n                swap(grid[i][0],grid[i-1][0]);\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1934777,
                "title": "java-easy-to-understand-explanation-iterate-and-add-as-though-a-1d-array",
                "content": "**Understanding the fundamentals**\\n\\nConsider a single dimensional array of size n :\\na[[1,2,3,4,5,6,7,8,9]. Here n = 9\\nFor instance, we have k=2 which means that the array should rotate clockwise twice,\\nthen array would become\\n[8,9,1,2,3,4,5,6,7]\\nyou would notice that there is a pattern while rotating.\\na[0] will be a[7] which can also be written as a[9 - 2 + 0]\\na[1] will be a[8], which can also be written as a[9 - 2 + 1]\\na[2] will be a[0] , which can also be written as a[9 - 2 + 2] - but a[9] is not there, so we need to do a modulus on 9 to get a[0]\\n... and so on,\\n\\nWe need to concentrate on the pivot position to arrive at the generalized formula to find the value at given index after rotation\\nIn a nutshell, if you need to rotate an array k elements in clockwise direction, you need to apply the formula\\n*a[i] = a[(n - k + i) % n] ---- > formula 1*\\n\\nSimilarly, if you need to rotate the array in anticlockwise direction, that is left shift twice in the above example, \\n\\nthe array [1,2,3,4,5,6,7,8,9] would become [3,4,5,6,7,8,9,1,2]\\nHere a[0] = a[2] which can also be written as a[(9 + 2 + 0) % 9]\\na[1] = a[3], which can also be written as a[(9 + 2 + 1)% 9]...\\nand so on,\\na[7] = a[0] which can also be written as a[(9 + 2 + 7) % 9]\\nthus, general formula in this case can be written as \\n*a[i] = a[(n + k + i ) % n]*\\n\\n**Applying 1D array rotation  logic to 2D array**\\nNow that you have understood how the array rotation in 1D array works, lets apply the logic on 2D array of size m*n;\\nHere, total number of elements would be m * n\\neach row will contain n elements\\nSo, to find out where the xth element in the 1D representation would fit in,\\n*m = x/n; --- > formula 2*\\n*n = x%n; ---- > formula 3*\\n\\nNow in the given question, you are expecting an arraylist which in turn contains arraylist representing each row,\\n\\nSo, first we create the arraylist for each row.\\n\\nNow we apply formula 1 to get the index variable value.\\n\\nThen we use formula for getting the mth arraylist to add the grid item calculated using formula 2 and formula 3.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934646,
                "title": "java-brute-froce-slow-but-intuitive",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462152,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506983,
                "title": "easy-to-follow-go-solution",
                "content": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639737,
                "title": "99-time-99-21-memory-flatten-the-matrix-and-then-use-rotate-c",
                "content": "Space and time-complexity: O(N)\\nThis algorithm is significantly fast due to fewer cache misses/crimes. \\n\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462852,
                "title": "java-99-100-17-lines-solution",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431111,
                "title": "simple-to-understand-java",
                "content": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937480,
                "title": "c-matrix-o-mxn-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936023,
                "title": "cpp-easy-manipulation-without-mod-with-intuition",
                "content": "```\\n step 1:  for k=1, store the last column in vector.\\n step 2:  take temp variable to store bottom right corner element \\n step 3:  simply right rotate every row of the \\n\\t\\t\\t matrix by 1.\\n step 4: copy temp variable to top left element.\\n step 5: copy the elements stored in vector in the first column\\n step 6: repeat the above steps k times.\\n\\t\\t\\t \\nclass Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }\\n            int temp = grid[n-1][m-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>0;j--){\\n                grid[i][j] = grid[i][j-1];\\n            }\\n        }\\n        grid[0][0] = temp;\\n        for(int r=1;r<n;r++){\\n            grid[r][0] = v[r-1];\\n        }\\n        }  \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1934599,
                "title": "python-easy-to-understand",
                "content": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "solutionTags": [],
                "code": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1934598,
                "title": "python-2-approach-with-example-shown",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660025,
                "title": "c-linear-2-pointer-in-place-solution-explained-99-time-16ms-100-space-13-7mb",
                "content": "Really funny problem; and a bit more challenge can be given to us if we try to do it in linear time and in place - is it possible to do both at once?\\n\\nI would say so; let\\'s consider the problem with a 1D array for simplicity first, assuming we have `{1,2,3,4,5,6,7}` as an array to shift by `4` positions. In order to do it linearly and in constant space, we can keep writing a value in its future place, keeping track of the previous value of the target slot and then repeat the operation over and over again with the value we stored.\\n\\nIn our example, we would have (the commented number is the one we store somewhere and write at the next round):\\n\\n```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\\n\\nA tricky part here is to notice that once the length of our array and `k` are not co-primes, we will have some loop that will NOT include all the elements as it happened before (try for example with `k` still equal to `4`, but with `8` elements to shift); we can easily fix it running our main shifting algorithm `gcd(nums.size(), k)` times, with a starting value of `0` and it will just work fine :)\\n\\nAnother optimisation trick might be to reduce `k` by the total of all the elements (shifting a grid of `100` elements by `100` will just give us the starting grid!) and, of course, to return the base grid itself for `k == 0`.\\n\\nNow, time to put all of this into code, first of all with a few support variables to help us:\\n* `w` and `h` will store the width (number of columns) and height (numbers of rows) of the grid, respectively;\\n* `tot`, computed as the product of the above variables, to store the overall number of elements;\\n* `target`, of type `div_t` (an object that will store `quot`ient and `rem`inder of a division with `div`), which will help us move later in our shifting/juggling logic.\\n\\nWe will then potentially reduce `k` to be the modulo of `tot`, and, in case it is `0`, directly `return` `grid`, as explained above.\\n\\nTime for our main loop, that will go with `i` as our starting point from `0` to `gcd(tot, k)` (excluded), using also `tmp` and `j` as loop variables; we will then:\\n* assign `i` as initial value to `j`;\\n* the result of `div(j, w)` to target, since we will have to convert our 1D example above to a 2D scenario, where each index will be converted to be the row number (`target.quot`) and the column number (`target.rem`) - in a grid of `3` rows and `4` columns, for example, the index `7` would give us `1` as a row number (the quotient) and `3` as column number (the reminder);\\n* get the initial value of `tmp`, taken as the `j`th element in our grid, using `target.quot` and `target.rem` as explained in the bullet point above;\\n* loop while`j != i` (but it is a do...while, so we will ignore the condition at the first run) and:\\n\\t* increase `j` by `k`;\\n\\t* check if `j` went over `tot`, in which case we will subtract it from `j` (which is basically equivalent of doing `j &= tot`, just way cheaper);\\n\\t* update `target` to be the current result of `div(j, w)`;\\n\\t* `swap` `tmp` and `grid[target.quot][target.rem]`.\\n\\nOnce done, we can just `return` `grid` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\nAnd since I forgot about having solved this problem already, I came up with a slightly different solution today, that I prefer somehow a bit more; also, not using modulo boosted the speed significantly:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491883,
                "title": "python-3-in-one-line",
                "content": "# Explanation\\n\\nThere is a clear one-to-one mapping for every element in the grid to its new location. We just need to figure out that mapping.. it\\'s a bit of math involving modulo and division.\\n\\nFrom grid -> shifted location:\\n```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\\nIn reverse, from shifted location -> original location:\\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\\nNote that in Python, `-1 % 3` is `2` and not `-1` like in Java / C / etc.\\n\\n# Two lines\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\\n\\n# One line\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "solutionTags": [],
                "code": "```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452350,
                "title": "straight-forward-c-with-linq",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432357,
                "title": "fast-java-with-reverse-function",
                "content": "Shift by k is equivalent with the following:\\n1. reverse whole array\\n2. reverse first subarray of k elements\\n3. reverse the remaining subarray\\n\\nCheck out similar question: https://leetcode.com/problems/rotate-array/\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516657,
                "title": "c-no-extra-memory-solution",
                "content": "This is slow, but if you want in-place (no extra memory), then this is viable solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099596,
                "title": "best-o-m-n-time-complexity-o-m-n-space-complexity-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeemed Truly Easy At First, Turned Out To Be Easier.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach Taken Is Explained Below :-\\n\\n(1) Initialise A Single Dimensional Array Of Size m*n and Pass Each Value Of The Matrix Sequentially Into The Single Dimensional Array.\\n\\n(2) Rotate The Array K Times Using The Following Algorithm :-\\n\\nStep (i) - Reverse The Entire Array\\nStep (ii) - Reverse The First K Elements (From Indexes 0 To K-1)\\nStep (iii) - Reverse The Rest of The Elements (From Indexes K To arr.length-1)\\n\\n(3) Store Each Element Of The Rotated Array In an ArrayList Of Size Equal To Number of Columns In Each Row. After Each Row, Pass The ArrayList Into an ArrayList<ArrayList<Integer>> Which Will Hold The Values Of All Rows Respectively.\\n\\n(4) Return The ArrayList<ArrayList<Integer>>.\\n\\nGood Luck!\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937545,
                "title": "python-solution-using-simple-methods-just-8-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720118,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937662,
                "title": "c-1-liner-just-for-fun",
                "content": "This is actually pretty efficient due to lazy evaluation, but admittingly not the most intuitive solution. Commented for readability.\\n\\n```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936825,
                "title": "kotlin-beats-98-april-2022",
                "content": "\\n\\tclass Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 } } \\n\\t\\t\\n        for (i in grid.indices) { \\n            for (j in grid[0].indices) {\\n                val n = (i + (j + k) / grid[0].size) % grid.size\\n                val m = (j + k) % grid[0].size\\n\\n                result[n][m] = grid[i][j]\\n            }\\n        }\\n        \\n        return result\\n    }\\n\\t}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 1936818,
                "title": "c-29ms-faster-than-80-easy-solution",
                "content": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1936444,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/924e5ed5-c56a-4f93-bfd3-5cad4ddedd6a_1649685169.9793317.png)\\n\\n```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936378,
                "title": "c-solution-runtime-160-ms-faster-than-96-00-of-c-online-submissions",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936052,
                "title": "c-time-o-n-space-o-1-explanation",
                "content": "The final solution is here. \\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\\nspace complexity O (1), time complexity O(N).  \\nN is mean rows * cols  here. \\n\\n# Explanation\\n\\nThe above solution is optimized from following code\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\\nThis code using time O(N) and space O(N). \\nAnd the idea of this code is to represent two dimension into one dimension array. \\nProcess it in. one dimension array and problem become easy. \\n\\nAnd this is a rorate array problem now. \\nThen we need to optimize this solution from this article\\nhttps://leetcode.com/problems/rotate-array/discuss/1729976/C%2B%2B-or-O(N)-or-GCD\\nIn this article, it solve rorate array problem by this way. \\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\nThen I adjust this code to become our solution.  \\nThat\\'s how I solve this problem in Time O(N) & Space O(1) in the final solution.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935848,
                "title": "convert-grid-into-1d-list-and-then-make-it-simpler",
                "content": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        Collections.rotate(temp,k);\\n        \\n        for(int j=0;j<m*n;j+=n){\\n            List<Integer> my=new ArrayList<>();\\n            for(int p=j;p<j+n;p++){\\n                my.add(temp.get(p));\\n            }\\n            ans.add(my);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935176,
                "title": "c-easy-understanding",
                "content": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1934883,
                "title": "javascript",
                "content": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756166,
                "title": "python3-simple-solution-linear-index-to-array-index",
                "content": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "codeTag": "Java"
            },
            {
                "id": 529823,
                "title": "1260-javascript-solution-with-comments",
                "content": "I tried *other* ways of doing it, but none of them seemed really *better*.\\n\\nThis isn\\'t a 1-line solution, but each operation in the solution is only 1 line.\\n\\n> Runtime: **92 ms**, faster than *100.00%* of JavaScript online submissions\\n> Memory Usage: **45.3 MB**, less than *35.62%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437060,
                "title": "python-o-1-space-rotate-virtual-1d-array",
                "content": "Assuming you already know how to rotate a 1D array by \"k\" steps in O(1) space:\\n1. Swap all elements on the left side: arr[:k], \\n2. Swap all element on the right side: arr[k:]\\n3. Swap all element in the whole array: arr[::]\\n\\nThis problem is 2D array, not 1D array. But we can solve it the same way as 1D array, just by presenting the 2D array as a \"virtual\" 1D array.\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431163,
                "title": "c-brute-force-o-k-m-n-by-storing-prev",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848373,
                "title": "easiest-solution-c-plusplus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658087,
                "title": "js-very-easy-solution",
                "content": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937545,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1937314,
                "title": "c-simple-solution",
                "content": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937282,
                "title": "python-super-simple-solution",
                "content": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "codeTag": "Java"
            },
            {
                "id": 1937050,
                "title": "two-js-solutions",
                "content": "1. Flatten the matrix and move k elements from the back to the front\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\\n2. Flatten and reverse the array, reverse the first k elements, and then reverse the rest\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936979,
                "title": "extremely-easy-and-clean-code-c-recursive",
                "content": "[](http://)\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936822,
                "title": "c-with-diagram-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8ac1f774-8ece-41ea-be5b-7f6ddfa9a71a_1649693338.3010826.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936721,
                "title": "c-simple-clean-code-with-explanation",
                "content": "\\n1. Convert (row,col) into 1d array. `index =  (currRow * number of elements in each column + currentColum)`\\n2. Now add k to index and mod it by number of elements in matrix to avoid going out of bounds. `index = (index + k) % (no of rows * no of cols)`\\n3. now we have calculated the index, we just have to convert this index to (row,col) format. `newRow = (index / no of columns)`\\nand `newCol = (index %  no of columns)`\\n4. now copy (row,col) to (newRow,newCol).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity = O(n * m)\\nSpace Complexity = O(n * m)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936433,
                "title": "c-easy-solution-explaining-similar-to-1-d-shifting-clean-code-with-explanation",
                "content": "**Solution using 1-D array Rotation Tricks in the 2-D Like we Did in *Search in 2-D Matrix* (Binary Search Solution)**\\n\\n**TC :** ***O(n x m)***\\n**SC :** ***O(1)***\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```\\n\\n**Please UPVOTE If you Like the Clear Solution With Simple Explained Intuition**\\n\\n***Thank You***\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935977,
                "title": "python-fastest-solution-using-simple-mathematical-formulation-o-n-m-time",
                "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1935716,
                "title": "c-vector-push-pop-simple-solution-explained",
                "content": "1. `` First of all I just convert the matrix into a linear vector``\\n2. `` Then the last element have inserted into the first position of the vector and poped out the last element from it``\\n3. `` Then again have made the matrix from the vector and returned it``\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1935669,
                "title": "c-simple-observation-based-solution-with-explanation",
                "content": "To solve this question we required two observations.\\n**Observation 1:-** If k is linear multiple of row(r in code) and column(c in code) than we get initial grid after shifting.Means answer after k shift=answer after k%(r*c).\\n**Observation 2:-**  At every n * c shifting(linear multiple of length of column) , we are shifting  whole row with other row.\\n\\nAfter these two observations only column shifting is remain.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935303,
                "title": "easy-c-solution-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935270,
                "title": "easy-to-understand-cpp-solution-same-concept-as-rotate-array-problem",
                "content": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935255,
                "title": "most-simplest-and-easiest-solution-c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL , PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935247,
                "title": "c-brute-force-approach-dlc-april-11",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1934978,
                "title": "simple-self-understanding-c-solution",
                "content": "If we linearly arrange all the elements of each row of a matrix , we will have an array. \\nAdd k to the current index of the array and convert that index to represent grid indices.\\n\\nA m*n matrix can be converted into an array or matrix can be represented in the form of a long array\\n\\t\\t\\tmatrix[ i ][ j ] = arr[ i*n + j ]\\nAn element in the long array of size m*n , can be taken into the form of matrix or into matrices indices using\\n\\t\\t\\tarr[ i ] = matrix[ i / n ][ i % n ];\\nTime Complexity of below code: O( m * n )\\nSpace Complexity of below code : O( m * n )\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```\\nPlease upvote if u find it helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934975,
                "title": "c-time-o-n-and-space-o-1-in-place-solution",
                "content": "It\\'s same idea as 189.rotate array, just convert to grid type!\\n\\nif we want to take the k last to the begin, we have to do 3 steps:\\n(1) rotate  whole list\\n(2) rotate the first k elements\\n(3) rotate else elements\\n\\nWe can change the position in list to grid by simply divide column number and module column number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```\\n\\nIf this solution is helpful, please upvote!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934967,
                "title": "c-simple-approach-beginner-friendly-neat-and-clean-code",
                "content": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "codeTag": "Unknown"
            },
            {
                "id": 1934551,
                "title": "python",
                "content": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934534,
                "title": "easy-to-comprehend-js-solution",
                "content": "Going backwards column wise shift one time over.\\nThen going backwards row wise move one up.\\nThats one rotation.\\nThen increment down k, do that however many times.\\nThere can be probably be a check for k where it would return the same solutions if its a a certian mod of a the size of the \\ngrid.\\n```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615647,
                "title": "java-easy-to-understand-using-modulo-arithmetic",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451785,
                "title": "c-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419979,
                "title": "ez-solution-c-single-loop-sanyam-shah",
                "content": "# EZ Solution C++\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269002,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/81a94899-35d9-4f72-abdf-cc0d37ae83e6_1623567794.6917243.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144081,
                "title": "c-solution",
                "content": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015725,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008659,
                "title": "using-k-rotations-on-1d-vector-o-m-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910356,
                "title": "python-deque-rotate",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883235,
                "title": "simple-python-solution-which-beats-99-84-of-submissions-by-using-the-deque-object",
                "content": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594791,
                "title": "easy-java-solution",
                "content": "This problem has horrible return type for java! I guess in-place way would be simpler than returning List<List<>>.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552572,
                "title": "c-one-pass-solution-2-d-array-to-1-d-array",
                "content": "**1-dimensional array index to 2-dimensional array index**\\nFor a given 1-dimensional array element **array[i]**, the corresponding row and column in 2-dimensional array will be **(i / n)** and **(i % n)**, where n is the number of columns of the 2-dimensional array. \\n\\n**2-dimensional array index to 1-dimensional array index**\\nFor a given  2-dimensional array element **array[i][j]**, the corresponding index of 1-dimensional array will be **(i * n + j)** , where n is the number of columns of the 2-dimensional array. \\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\nApproach 2: Reverse\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466350,
                "title": "concise-o-m-n-rust-solution",
                "content": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437034,
                "title": "three-solutions-in-python-3-two-lines-beats-98",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 433799,
                "title": "java-100-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431470,
                "title": "python-4-lines-beat-100-speed-and-space-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/koten0224/image_1573995656.png)\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918501,
                "title": "easy-c-solution-easy-to-understand-simple-clean-code-with-explanationeasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the last column into a vector\\n2. Move the values of (i-1) th column to i th column\\n3. Move the element at grid[m - 1][n - 1] to grid[0][0] from \"tmp\"\\n4. Replace the rest of the column-1 with the stored values from \"tmp\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3075497,
                "title": "beats-99-43-python3",
                "content": "# Approach\\nFirst of all accessing each list of grid through index, popping the last element and inserting it to the starting of next list. \\n\\nFinally, accessing the last list popping the last element and inserting it to the first list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689101,
                "title": "o-1-space-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446323,
                "title": "no-extra-space-taken-in-place-time-k-o-n-m-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444389,
                "title": "js-two-solutions-offset-in-place-runtime-83-58-memory-98-51",
                "content": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\\n\\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440236,
                "title": "c-solution-beats-96-21-of-cpp-submissions",
                "content": "The problem is similar to right rotating a 1d array k times. We can implement the same in this problem. Reverse the last k elements of the flattened version of the input array, and reverse the first n-k elements of the input array.  Then Reverse the whole 2d array. This solution does the job in-place.\\n\\n```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023525,
                "title": "c-flatten-rotate-locate",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941495,
                "title": "c-clean-code-simple-concise-easy",
                "content": "**Runtime: 16 ms**\\n***Faster than 90% solution in c++***\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937791,
                "title": "python-pop-insert-in-next-row",
                "content": "Remove the last element in each row and insert it at the beggining of the next row. \\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937731,
                "title": "c-simple-solution-with-explanation-o-n-m-100-faster",
                "content": "The idea is to map the two dimensional array position to a postion in an imaginary one dimensional array from (0 to m*n -1).\\nIt can be done with i * n + j. \\nThen sum k to get the 1d array new position and get module to avoid having a number greater than the max length of the imaginary 1d array.\\nLast, convert the 1d new position to the 2d array postions with the x = newPosition/n and y = newPosition%n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/236a29de-fbe5-48ac-847c-01a10f7994fa_1649719535.5562575.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937678,
                "title": "python-3-inplace-triple-reverse-doug-mcilroy-and-gcd-solutions",
                "content": "Straightforward solution is very boring, how could we do that inplace?\\n\\nAnother boring thing is Programming Pearls solution (page 33) aka triple reverse (by Doug Mcilroy). Even if it\\'s 1D you can easlily remap it to 2D grid:\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\\n\\nIt\\'s very suboptimal though, because you have to address every element at least twice not counting the swaps. There\\'s an optimal solution that works in O(n) for 1D, or O(n x m) for 2D grid mentioned here: https://stackoverflow.com/questions/876293/fastest-algorithm-for-circle-shift-n-sized-array-for-m-position\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937599,
                "title": "javascript-neat-3-methods-flat-flat-in-place-in-place",
                "content": "## 1. Flat\\nComplexity: time **O(3mn)**, extra space **O(2mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 2. Flat In Place\\nComplexity: time **O(4mn)**, extra space **O(mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 3. In Place\\nComplexity: time **O(2mn)**, extra space **O(1)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937582,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1937552,
                "title": "kotlin-100-time-and-space-easy-solution-with-explanation",
                "content": "At first, I was trying an approach where I calculate a toRow and toCol, but had difficulty getting them right without a paper and pencil.  Then I realized it\\'s much easier to just have a one-dimensional array for the elements, start at the kth position (called \"to\"), and just copy the items from the beginning of the grid to \"to\" and keep incrementing \"to\" by 1.\\n\\n\"to\" starts at k % size (# of rows * # of columns), which automatically makes is zero-based.  To save time, the first check is to see if k % size is 0, in which case nothing needs to be shifted, just turn the rows into lists and add them to the output list, and return.\\n\\nThe second speed saving is if the size of each row is 1.  In that case, still create an output array the size of the grid and copy the items in, starting at to, always column 0 in th grid.  Then, each item is its own list, so go through the array and add each one as a list, and return.\\n\\nWhenever \"to\" reaches the end of the list ( == size), reset to 0.\\n\\nFinally, starting at the begining of the output grid (to = 0), create a new list for each row, and add column number of items to the list, and then add that list to the out list.\\n\\n```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937526,
                "title": "golang-o-1-space",
                "content": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937511,
                "title": "python-short-functional-programming-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937476,
                "title": "rust-rotate-in-place-same-as-189-rotate-array",
                "content": "The \"shift\" steps describe how to \"rotate\" a 1-D array by 1 element to the right by using its 2-d representation. Take the first example - if we convert the 2D matrix to 1D array:`[[1,2,3],[4,5,6],[7,8,9]] => [1,2,3,4,5,6,7,8,9]` and then rotate the 1D array by 1 element to the right we will get `[9, 1,2,3,4,5,6,7,8]` and then in order to get the answer we have to convert it back to a 2D representation: `[[9,1,2],[3,4,5],[6,7,8]]` \\n\\nIf we execute the steps of the \"shift\" algorithm we find out that it actually shifts all cells by 1 to the right. So doing the \"shift\" operation K times is equivalient to shiftingk by K positons only once. \\n\\nFrom  [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md) we have already learned how to rorate (shift) a 1D array. We just have to apply that knowledge by extending it to a 2D array. This can be done by finding out how to go from 1D index, to a 2D index and vice cersa:\\n\\n* The formula to convert from 2D index to 1D index is `row * columns + column`\\n* The formula to convert from 1D index to 2D index is:\\n    * `row = index / columns`\\n    * `col = index % columns`\\n\\n\\n\\nNow we know that we can go from 2D to 1D matrix, rotate it, and then go back to 2D matrix.This means that we can use the same approach as in [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md):\\n\\n```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937433,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937377,
                "title": "c-easy-solution-using-extra-and-without-extra-space",
                "content": "**Method 1:**\\nTime Complexity : O(n*m)\\nSpace Complexity : O(m*n)\\n\\n\\n```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\\n\\n**Method 2:\\nTime Complexity: O(n*m*k)**\\n**Space Complexity : O(k)**\\n\\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937351,
                "title": "c-2-approach-with-extra-space-without-extra-space",
                "content": "**First Approach :** Without extra space (Optimal Solution)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\\n\\n**Second Approach :** Here extra space used and call the recursion for k-1 steps.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\\n\\nIf anyone didn\\'t understand how  the recursion works they can understand the concept by the below code.\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937324,
                "title": "c-clean",
                "content": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937312,
                "title": "c-solution-no-extra-space-hard-solution",
                "content": "Maybe the hardest solution but I found this approach a little intresting....\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                    else{\\n\\t\\t\\t\\t\\t\\n                        prev=grid[i][j];\\n                        grid[i][j]=temp;\\n                        temp=prev;\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n\\t\\t\\t\\t\\n                else{\\n\\t\\t\\t\\t\\n                    prev=grid[i][j];\\n                    grid[i][j]=temp;\\n                    temp=prev;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n           \\t}\\n\\t\\t\\t\\n            k--;\\n\\t\\t\\t\\n        }\\n\\t\\t\\n        return grid;      \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1937310,
                "title": "simple-code-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }\\n        }\\n        int k1=k;\\n      \\n        k=k%(m*n);\\n           for(int j=v.size()-1; j>=v.size()-k; j--)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n        reverse(ans.begin(),ans.end());\\n        for(int j=0; j<v.size()-k; j++)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n         \\n        int j=1;\\n        vector<int>v3;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(j%m==0)\\n            {   v3.push_back(ans[i]);\\n                res.push_back(v3);\\n                v3.clear();\\n            }\\n            else\\n                v3.push_back(ans[i]);\\n            j++;\\n            \\n            \\n        }\\n              \\n     return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1937228,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic static void shift(int[][] grid) {\\n\\t\\tList<Integer> lastElements = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tlastElements.add(grid[i][grid[i].length - 1]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\n\\t\\t\\tfor (int j = grid[i].length - 1; j > 0; j--) {\\n\\t\\t\\t\\tgrid[i][j] = grid[i][j - 1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tif (i != grid.length - 1)\\n\\t\\t\\t\\tgrid[i + 1][0] = lastElements.get(i);\\n\\n\\t\\tgrid[0][0] = lastElements.get(lastElements.size() - 1);\\n\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1937118,
                "title": "c-easy-understanding-algorithm-explanation",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* **Store all the values** in a **vector** temporary\\n\\n* Then maintain the **order that vector** \\n* Put **k values at the start from behind**\\n* Then after maintaining the order **make the pairs** according to the **size of column** \\n* after storing just **return** that \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937111,
                "title": "clean-code-c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937107,
                "title": "c-simple-solution-single-traversal-m-n-extra-to-make-new-matrix",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937009,
                "title": "java-easy-beginner-less-complexity-based-on-o-1-space-solution",
                "content": "If you are familiar with [RotateArray](https://leetcode.com/problems/rotate-array/submissions/) and  [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) this is using concept of both .\\n\\njust assuming matrix as 1D array using arr[i/lenOfRow][i%lenOfRow] and reverse the array and fill the matrix into arraylist and return \\nTC:O(N*M)    SC:O(1)\\nComment if needed improvements ;)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936874,
                "title": "java-faster-than-98-right-rotation-of-array",
                "content": "**Flatten 2D Array to 1D Array and apply right rotation. Then convert back to 2D Array.**\\n\\n```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936841,
                "title": "c-90-faster-41-space-8-lines",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936727,
                "title": "js-modulo-arithmetic-no-stdlib-methods-faster-than-98",
                "content": "This solution is based on a circular list approach, where we \"connect\" the end to the beginning. Knowing dimensions of a matrix, we can work with it as a 1-dimensional array, where iterating all elements looks like `rowIndex * rowSize + columnIndex`. This also means that given an element index `i`, we can find row and column indices - `rowIndex = i / rowSize` (as an integer), `columnIndex = i mod rowSize`.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```\\n\\nI\\'m new to Leetcode and I don\\'t understand how performance measurement works but the best run was **80ms with 47MB** of memory used, which is **faster than 98.7% and takes less memory than 93.51%** of solutions at the time of submission.",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936571,
                "title": "js-time-o-mn-space-o-1-in-place-operations",
                "content": "The main idea of the solution is to count greatest common divisor between number of shifts we need to make and the total amount of elements. gcd here will show us the number of operations, before our algorithm starts to cycle. After each cycle we will start to proceed the remaining elements. And so on.\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(1)\\nFeature: In-place",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936568,
                "title": "a-in-place-solution",
                "content": "It consists of two concepts:\\n1. In-place array shifting/rotating can be decomposed into 3 reverse operations.\\n\\te.x.\\n\\t\\t[1, 2, 3, 4, 5] right rotate 2  => [4, 5, 1, 2, 3]\\n\\tequals to \\n\\t\\t[1, 2, 3, 4, 5] reverse  =>  [5, 4, 3, 2, 1] reverse first 2  => [<u>4, 5</u>, 3, 2, 1] reverse rest of the elements  =>  [4, 5, <u>1, 2, 3</u>]\\n2. The coordinate conversion between 1D and 2D can be achieved by \\'/\\' and \\'%\\' operators with the width n of the 2D matrix.\\n```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936555,
                "title": "c-3-approaches-in-decreasing-order-of-intuitiveness",
                "content": "### **Approach 1:** Brute Force Shifting using temp matrix\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 2:** Convert Matrix to 1-D Array (Brute Force)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 3:** Calculate New Position of each element(Better Version of Approach 2)\\nFor an M*N matrix \\\\-\\n- 1-D index for [i, j] = `i*N + j`\\n- Shift 1-D index : `index = (index+k)%(M*N)`\\n- Calculate shifted 2-D coordinates : `[index/N, index%N]`\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936534,
                "title": "simple-python-using-deque",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936475,
                "title": "python3-shifting-in-2d-simple",
                "content": "Here I have shifted in 2D List in an extended manner (without using any list comprehension or one liner). It can also be done in shorter and more efficient manner.\\n**Logic:** Pop the last element from each sub list and insert it at 0 index in another sub list and for last sub list pop the last element and insert it at 0 index in first sub list.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```\\n**Please upvote if the solution helps**\\n**Feel free to ask any question**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936463,
                "title": "c-solution-basic-optimized",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++)temp[i+1][0]=grid[i][n-1];\\n            temp[0][0]=grid[m-1][n-1];\\n            grid=temp;\\n        }\\n        return temp;\\n    }\\n};\\n(Optimized)\\nClass Solution {\\npublic:\\n    \\n\\tvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n\\t          {   \\n\\t        int m=grid.size();\\n            int n=grid[0].size();\\n           vector<vector<int>>temp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                temp[(i+(j+k)/n)%m][(j+k)%n]=grid[i][j];\\n        }\\n        return temp;\\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1936392,
                "title": "python-flatten-array-and-convert-back-2d",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936366,
                "title": "python-simple-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936342,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936218,
                "title": "python-very-easy-o-1-space",
                "content": "**Solution 1**\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(N*M)```\\n***\\n\\n\\n**Solution 2**\\nSame approach as this question  [Click](https://leetcode.com/problems/rotate-array/)\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(N*M)```\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1936191,
                "title": "c-o-1-space-solution",
                "content": "# **Non Constant Space Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n# **O(1) Space Solution**\\nThe Testcase: \\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\\n**The Explanation:**\\nThe idea is simple, let\\'s assume that the given array grid is 1D array, to rotate it, we will just need to do 3 reverse operations:\\n1. reverse the whole array:\\n2. reverse the values before k [0, k - 1]\\n3. reverse the values from k to the end [k, n * m - 1]\\n\\nAfter the first reverse operation (reverse the whole array):\\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAfter the second reverse operation (reverse the values before k):\\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAnd finally, after the third operation (reverse the values from k to the end) we get:\\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\\nWhich is the right answer!\\n\\nHere is the **implementation**: \\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```\\n\\n**Hope it helped! Your Upvote can make my day :D**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936181,
                "title": "daily-leetcoding-challenge-april-day-11-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n            for(int i=0;i<k;i++){\\n                a = v[m*n - 1];\\n                v.pop_back();\\n                v.insert (v.begin(), a);\\n            }\\n            int x = 0;\\n            for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j] = v[x];\\n                x++;\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936143,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936041,
                "title": "c-100-faster-than-all-bruteforce-single-pass-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1936035,
                "title": "daily-challenge-11-04-2022-faster-than-99-solution",
                "content": "The trick is to make a function for shifting grid by 1 position.\\nAfter that is done, just run a loop K times calling that function and return the answer!\\n\\n```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935927,
                "title": "c-o-m-n",
                "content": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935923,
                "title": "171ms-solution-easiest-explanation-python",
                "content": "The trickiest part in this problem is to handle the edge elements. If the value is at the last column of a row, then we have to shift it to the first column of the next row. Interestingly using this approach is the key to this problem.\\n\\n---\\nLet\\'s only focus on a matrix of two rows for now.\\n\\nWhat we need to do is \\'pop\\' the element from the second row and \\'insert\\' it at the first index of the first row.\\nNow if `m` is the number of elements in a row(or columns in the matrix), then after this operation the first row has `m+1` elements and the second row has `m-1` elements.\\nBut we still have to `pop` the last element of the first row and insert it the `0`<sup>th</sup> index of the second one to complete the iteration.\\nOn doing this operation, both our rows have the same number of elements, `m`, and our matrix is successfully shifted by one.\\n\\nWe need to repeat this cycle `k` times to arrive at the expected output.\\nFor a generalized solution for matrices with more than 2 rows, check out the well-documented python code below.\\n\\n---\\n**Time Complexity: O(kmn)** where **k** is the number of elements, **m** is the number of columns and **n** is the number of rows\\n\\n**Space Complexity: O(1)** as no extra space is required\\n\\n*Do upvote if you found the explanation deserving enough. Thanks for reading!*\\n\\n---\\nPython code:\\n```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1935919,
                "title": "simple-solution-c",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935728,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935704,
                "title": "c-simplest-solution-convert-to-1d-array",
                "content": "**Time Complexity :** ```O(m*n)```\\n\\n**Space Complexity :** ```O(m*n)```\\n\\n\\n**APPROACH :**\\n\\n* Convert the array into a 1D array ```v```.\\n\\n* Reverse the array from index ```0``` to index ```v.size() - k - 1```.\\n\\n* Then reverse the array from index ```v.size() - k``` to ```v.size() - 1```.\\n\\n* Then reverse the whole array.\\n\\n** ( Do a dry run on 1 of the examples to understand)\\n\\n**Code :**\\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**Do upvote if you like my solution :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```O(m*n)```\n```O(m*n)```\n```v```\n```0```\n```v.size() - k - 1```\n```v.size() - k```\n```v.size() - 1```\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935646,
                "title": "easy-c-o-k-m-n-solution",
                "content": "**Algorithm**\\n\\n* Preserve the last index element.\\n* copy all index to their next\\n* Copy the saved last element to first\\n* Apply a set of if-else blocks for boundary conditions\\n* Repeat the above 3 steps k times.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935613,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }\\n        }\\n        \\n        List<Integer> a = new ArrayList();\\n        for(int i=0;i<total;i++){\\n            a.add(ans[i]);\\n            if(a.size() == n){         \\n                System.out.println(a);\\n                list.add(a);\\n                a = new ArrayList();\\n            } \\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935549,
                "title": "c-reversal-algorithm-to-rotate-an-array",
                "content": "**Optimal Approach (Reversal Algorithm)**\\n```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```\\n**Time - O(M.N)\\nSpace - O(1)**\\n\\n`As we are changing our input matrix loss of information happens, to prevent that we can make another \\'ans\\' matrix and in this case the space complexity would be O(M.N)`\\n\\n*NB: If I could help you a little consider upvoting the solution and comment your doubts and thoughts for this problem*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566057,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2012899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753271,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739733,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Elements in a Contaminated Binary Tree",
        "question_content": "<p>Given a binary tree with the following rules:</p>\n\n<ol>\n\t<li><code>root.val == 0</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.left != null</code>, then <code>treeNode.left.val == 2 * x + 1</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.right != null</code>, then <code>treeNode.right.val == 2 * x + 2</code></li>\n</ol>\n\n<p>Now the binary tree is contaminated, which means all <code>treeNode.val</code> have been changed to <code>-1</code>.</p>\n\n<p>Implement the <code>FindElements</code> class:</p>\n\n<ul>\n\t<li><code>FindElements(TreeNode* root)</code> Initializes the object with a contaminated binary tree and recovers it.</li>\n\t<li><code>bool find(int target)</code> Returns <code>true</code> if the <code>target</code> value exists in the recovered binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg\" style=\"width: 320px; height: 119px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1]],[1],[2]]\n<strong>Output</strong>\n[null,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True </pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg\" style=\"width: 400px; height: 198px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n<strong>Output</strong>\n[null,true,true,false]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg\" style=\"width: 306px; height: 274px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n<strong>Output</strong>\n[null,true,false,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>TreeNode.val == -1</code></li>\n\t<li>The height of the binary tree is less than or equal to <code>20</code></li>\n\t<li>The total number of nodes is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li>Total calls of <code>find()</code> is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 431229,
                "title": "python-special-way-for-find-without-hashset-o-1-space-o-logn-time",
                "content": "It\\'s obvious to use `BFS` for the initial part. However, a lot of people use HashSet(`set()` in python) to pre-store all the values in the initial part, which may cause MLE when the values are huge. There is a special way to implement `find()` that  costs O(1) in space and O(logn) in time. \\n\\nFirstly, let\\'s see what a complete tree will look like in this problem: \\n\\n\\nIt\\'s very easy to find that numbers in each layer range from `[2^i-1,2^(i+1)-2]`\\nwhat if we add 1 to each number? Then it should range from `[2^i, 2^(i+1)-1]`\\nSee?  the binary of all numbers in each layer should be: `100..00` to `111...11`\\n\\nHence we could discover that maybe we could use the `binary number` of `target+1` to find a path:\\n\\n![image](https://assets.leetcode.com/users/qingdu_river/image_1573968285.png)\\n\\nI\\'m not proficient in English, so I would prefer to show my code here to explain my idea:\\n\\n```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431107,
                "title": "java-python-3-dfs-and-bfs-clean-codes-w-analysis",
                "content": "**DFS**\\n\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\\n\\n----\\n\\n**BFS** - inspired by **@MichaelZ**.\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```\\n\\n**Analysis:**\\nHashSet cost space `O(N)`, *dfs()* cost space ((H) and time `O(N)`, *bfs()* cost time and space O(N), therefore\\n\\n*FindElements() (dfs() and bfs()) cost*\\ntime & space: `O(N)`.\\n\\n*find() cost*\\ntime & space: `O(1)` excluding the space of HashSet.\\n\\nWhere `N` is the total number of nodes in the tree.",
                "solutionTags": [],
                "code": "```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431362,
                "title": "java-bit-path-time-o-logn",
                "content": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "solutionTags": [],
                "code": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 434127,
                "title": "c-simple-and-easy-to-understand",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431462,
                "title": "intuitive-c-code-beats-100-in-memory",
                "content": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431283,
                "title": "python-binary-path-without-set",
                "content": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "solutionTags": [],
                "code": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3172058,
                "title": "c-simple-solution-tc-o-log-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(log(N))\\n\\n- Space complexity:\\nO(log(N))\\n# Code\\n```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466109,
                "title": "java-bit-representation-of-target-1-solution-with-explanation",
                "content": "if the root.val is 1 instead of 0, then the values of tree node are:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\\n\\nThe bits starting from index 1(ignore the most significant bit) of binary representation of a val decide the path to reach it:\\n0 -> go to left\\n1 -> go the right;\\n\\nFor example:  \\n2  = 10 => ignore the most significant bit, the representation is \"0\" => 2 is the left child of root.\\n4 = 100 => ignore the most significant bit, the representation is \"00\" => go 2 lefts;\\n11 =1011 => ignore the most significant bit, the represenation is \"011\" => go one left, then 2 rights.\\n\\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449680,
                "title": "simple-java-dsf-solution-use-bitset-double-100",
                "content": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202354,
                "title": "easy-java-solution-easy-peasy-lemon-squeezy-simple",
                "content": "\\n# Code\\n```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797703,
                "title": "easy-python-o-1-find-recursion-queue",
                "content": "**Easy Python | O(1) Find | Recursion + Queue**\\n\\n**A) Standard Code**\\n\\nIn this problem, we can recover the values of the original Binary Tree, and store them in a \"set\" directly. (There\\'s no need to keep the Binary Tree itself)\\n\\nThis way, we can \"find\" any element with O(1) time/space complexity. The initialization method still runs with O(n) time/space complexity though.\\n\\n```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**B) 4 Lines of Code**\\n\\nOne-Liner version of the \"Recover\" function :)\\n\\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**C) Queue Method**\\n\\nThe previous code versions work fine. However, recursion consumes a lot of system resources, due to the initialization, namespace, and environment variables of each function call. Besides, many compilers have a hardcoded limit for Max. Recursion Depth, and there can be complicaitons by constantly needing to edit global settings.\\n\\nThere\\'s still hope in the galaxy though. We can use \"Queues\" to traverse the original Binary Tree without applying recursion.\\n\\nHere\\'s the code:\\n\\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\nI hope the code was helpful. Cheers,\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645499,
                "title": "java-18ms-92-faster",
                "content": "The speed is obtained by not modifiying the tree and using bitwise operator\\nleftshift by 1 == multiplication by 2 and it is much faster than multiplication operator\\n\\nFor the fast lookup use hashmap, because the lookup time is O(1) (avg)\\n```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906458,
                "title": "java-easiest-cosise-beginer-friendly-slow",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530059,
                "title": "c-code-using-bfs-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439249,
                "title": "clean-easy-understand-python",
                "content": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "solutionTags": [],
                "code": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "codeTag": "Python3"
            },
            {
                "id": 438239,
                "title": "python-hacks",
                "content": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\\n\\nAnother, based on [this one](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/discuss/431229/Python-Special-Way-for-find()-without-HashSet-O(1)-Space-O(logn)-Time/394342):\\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543983,
                "title": "python-explained-tree-traversal",
                "content": "* We can use any tree traversal method to make the tree contaminated, here we are using preorder traversal it is more favorable here since value of child nodes are dependent on the value of thier parent node.\\n* For efficient target searching we will maintain a set and keep adding the values in it whenever we modify node value.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n-----------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176160,
                "title": "simple-and-clean-c-solution-using-dfs-and-a-hashset",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921735,
                "title": "c-o-n-to-build-o-1-query",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750532,
                "title": "easy-c-solution-using-hashmap",
                "content": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708923,
                "title": "java-simple-dfs-and-set",
                "content": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509767,
                "title": "c-c-solution-the-find-is-o-1-uses-a-bitset-instead-of-a-set-saves-memory",
                "content": "If the tree is not too sparse, using a bitset uses less memory than an unordered_set. I think it amounts to only 8KiB, given the problem\\'s upper node limit, enough to fit entirely in the CPU\\'s cache. I also expect element access to compare favorably with an unordered_set\\'s.\\nIf lots of small trees are to be expected, preallocating a full-size bitset may be a pessimization, but replacing it with a (dynamic-sized) vector is fairly straightforward.\\n\\n```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758852,
                "title": "bfs-level-order-traversal-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **BFS (Level Order Traversal Format)** to assign values to the nodes and store them in an **unordered map** to return the answer in **O(1) time** in the **find() function**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/64c6c860-2b36-4c39-bf33-7b4a44813c67_1689243388.5248017.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086295,
                "title": "simple-dfs-solution-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076480,
                "title": "easy-understading-and-memory-efficient-solution-in-js",
                "content": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2998771,
                "title": "c-array-and-tree-easiest-approach",
                "content": "\\n# Approach\\nForming a array to store binary tree. The values that is asked to store is similar to index that we use to store element of tree in array. Only storing a tree will take O(n). Otherwise find function will take O(1) time as it is only checking whether at target value, i.e., same as index of array is -1 or not.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ---- where n is the number of nodes in tree.\\n\\n# Code\\n```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816045,
                "title": "java-easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSave all the nodes value in HashSet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025906,
                "title": "easy-python-solution-faster-than-99-76-ms-comments",
                "content": "# Easy Python Solution | Faster than 99% (76 ms) | With Comments\\n\\n**Runtime: 76 ms, faster than 99.13% of Python3 online submissions for Find Elements in a Contaminated Binary Tree.\\nMemory Usage: 17.9 MB**\\n\\n```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```\\n![image](https://assets.leetcode.com/users/images/378c2109-1b90-48a2-829e-fab65cc6abbc_1652190280.408396.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772130,
                "title": "beginner-friendly-python-soluiton",
                "content": "**Time Complexity : O(N)**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702451,
                "title": "c-easy-and-concise",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628594,
                "title": "c-easy-to-implementation",
                "content": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1626666,
                "title": "c-easy-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1514524,
                "title": "c-easy-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1363748,
                "title": "c-99-faster-simple-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431461,
                "title": "c-simple-easy-brute-force",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063151,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026035,
                "title": "easy-friendly-c-solution-based-on-precomputation-o-1-query-runtime",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses preorder DFS to recover all the nodes recursively, while also maintaining a hashmap for the found values so that we can easily hunt for the target value in the query.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in recovering the tree, $$O(1)$$ for queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the recursive stack and the hashmap.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019065,
                "title": "simple-solution-with-depth-first-search-hashset-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a **Binary Tree**, all of its values equal to `-1`\\n- our goal is to **recover** all nodes by changing values according to the schema\\n\\n```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\\n\\n# Approach \\n1. define a `set`, that\\'ll store all of the traversed values from `root` to quick search inside `find` method\\n2. define `recover` function to recover the values of a tree\\n3. if there\\'s no `node` return `None`\\n4. if the `left` or `right` children exist, change the values according to the schema and store the values inside `self.set`\\n5. implement the `find` method with checking value in `self.set`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over `root`\\n\\n- Space complexity: **O(n)**, because of recursive call stack and storing all the values inside `self.set`\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637883,
                "title": "easy-solution-using-set-and-traversal-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589532,
                "title": "c-solution-using-preorder-traversal-and-hashmap",
                "content": "# Intuition\\nWe simply need to store the appropriate values for non-empty nodes and update their values as required. As the values for the left or right child depend on the root value, so we update that first.\\n\\n# Approach\\nWe apply pre-order traversal where we first visit the root, then the left child and right child respectively. Map is used to store the node values accordingly. \\n\\n# Complexity\\n- Time complexity:\\nFor FindElements:- O(N)\\nFor find:- O(1)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```\\nPlease upvote if you understod the solution!\\nHave a great day :)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576674,
                "title": "map-post-order",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394657,
                "title": "easy-c",
                "content": "# Intuition :\\nDeclare global variable head in which we will store root and then pass it to find function and inside findelement function intialize root.val 0 and make new function help and pass root.\\n\\n# Approach : \\nBinary Tree\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394585,
                "title": "easy-using-unordered-map",
                "content": "# Intuition\\nThe intuition behind this code is to leverage the properties of a binary tree to efficiently check whether a particular value exists in it or not.\\n\\nThe constructor sets up a map that will keep track of all the integer values that exist in the binary tree. It uses a pre-order traversal to assign integer values to each node of the binary tree. The integer value of a node is calculated based on its position in the binary tree, where the root node has a value of 0, the left child of a node with value x has a value of 2x+1, and the right child of a node with value x has a value of 2x+2. This ensures that all nodes in the binary tree have a unique integer value.\\n\\nOnce all the integer values have been assigned to each node in the binary tree, the \"sexy\" map is updated to indicate that the integer value of each node exists in the binary tree.\\n\\nThe \"find\" method simply checks if the target value is present in the \"sexy\" map. Since the \"sexy\" map only contains integer values that exist in the binary tree, this allows for a quick check to determine if the target value exists in the binary tree or not.\\n\\nOverall, the intuition behind this code is to trade off additional memory usage for faster lookup times for checking whether a value exists in a binary tree.\\n\\n# Approach\\nThis code defines a class called \"FindElements\" which provides a way to find whether a target value exists in a binary tree. The binary tree is represented by a TreeNode* pointer to its root node.\\n\\nThe class has two public methods: \"FindElements\" (constructor) and \"find\". The constructor takes in a TreeNode* pointer to the root of the binary tree and sets up a map called \"sexy\" (not a very appropriate name) which maps integer values to boolean flags. The \"setting\" method is called recursively to traverse the binary tree in a pre-order manner and set the values of each node with an increasing integer value starting from 0, which represents the root node. As each node\\'s value is set, the \"sexy\" map is updated to mark that value as present in the binary tree.\\n\\nThe \"find\" method takes in a target integer value and returns whether that value is present in the binary tree by looking it up in the \"sexy\" map. If the target value exists in the binary tree, the method returns true, otherwise false.\\n\\nOverall, this code provides a simple way to check whether a particular value exists in a binary tree without having to traverse the entire tree each time. The downside is that it requires additional memory to maintain the \"sexy\" map.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118073,
                "title": "c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921408,
                "title": "easy-to-understand-c-solution-using-recursion-and-bt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720120,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672559,
                "title": "recursive-approach",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2553191,
                "title": "simple-dfs-solution-c",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469299,
                "title": "c-easy-fully-commented-logic",
                "content": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2421082,
                "title": "c-simple-and-very-easy-to-understand",
                "content": "Do upvote , if you find this helpful.\\n```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323971,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dfs-hashset",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2317652,
                "title": "c-binarytree-traversal-simple-logic",
                "content": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2307892,
                "title": "c-dfs-hash-set-time-o-n-space-o-n",
                "content": "DFS solution\\n* the constructor, perform DFS traversal on the tree and insert values into a hash set if the nodes exist\\n* find() searchs the target from the hash set in O(1) time\\n```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290791,
                "title": "go-with-map",
                "content": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2099200,
                "title": "golang",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Design",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060336,
                "title": "c-solution-bfs",
                "content": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2038820,
                "title": "java-dfs-binartysearch-log-n-space-time-easy-to-understand-with-comments",
                "content": "The key idea in search for any value X if (X-1)%2==0 it would be on left branch of a node else it would be on a right branch of a node. Now we are storing directions in a stack to find if node value exists or not in the tree. \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1872558,
                "title": "c-short-and-simple-hashtable",
                "content": "\\nfirst try to recover the tree using preorder traversal \\nduring the traversal, store the values in hash table for fast searching\\n\\n```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846192,
                "title": "java-code-2-ways-to-solve",
                "content": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\\n\\n\\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780860,
                "title": "bfs-based-solution-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777486,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```\\n \\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1736298,
                "title": "c-easy-recursive-solution",
                "content": "Solution is straight forword we only recursively check current node value greater than target value if we find target value we will return true otherwise false.\\n```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```\\n\\t\\nIf you have any suggestion comment.Thank you for your suggestion.",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690280,
                "title": "c-easy-to-understand-simple-implementation",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660470,
                "title": "c-solution-using-set-to-find-element-in-o-1",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1628305,
                "title": "c-easy-logical-solution-o-log-n-space-pruning-no-hashmap-or-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease upvote if it helped. Happy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482832,
                "title": "c-dfs-using-hash-inorder",
                "content": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "solutionTags": [],
                "code": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 1424594,
                "title": "ac-java-solution-find-elements-in-a-contaminated-binary-tree-beats-84",
                "content": "Strictly by the definition, I contaminate and reconstruct the tree, all the while adding the keys to a set. \\n\\nThe latter makes the initial tree building O(n), but the find operation O(1), since we can look the keys up directly from the set.\\n\\nI\\'m sure I can make this faster by combining \\'contaminate\\' and \\'reconstruct\\', but It\\'s late now and I\\'m tired :)\\n\\n```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338182,
                "title": "java-dfs-hashset-beats-98",
                "content": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "solutionTags": [],
                "code": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "codeTag": "Java"
            },
            {
                "id": 1272382,
                "title": "c-simple-easy-to-understand-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244162,
                "title": "c-hashmap",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233405,
                "title": "c-98-8-faster-very-simple-and-easy-to-understand-using-dfs",
                "content": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```\\n**if you find it helpful plz upvote**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229967,
                "title": "simple-recursive-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228884,
                "title": "c-simple-solution-using-bfs-and-unordered-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174605,
                "title": "python3-simple-solution",
                "content": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137333,
                "title": "java-clean-and-easy-solution",
                "content": "**If you want to do this in O(1) space than you have to write the O(n) code for searching the target in Binary tree which is pretty slow**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\\n**But if you use Map to store the values as key in map you will be doing the search operation in O(1) which will be fast**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129234,
                "title": "java-solution-99-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129172,
                "title": "java-solution-99-faster",
                "content": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085663,
                "title": "python-iterative-dfs",
                "content": "I think we can use any traversal order to update the node values?\\n```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046251,
                "title": "i-am-not-sure-if-it-s-allowed-to-use-static-but-that-s-how-i-implemented",
                "content": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1018682,
                "title": "java-better-than-98-of-runtime",
                "content": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012706,
                "title": "java-hashset",
                "content": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 984755,
                "title": "java-easty-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961877,
                "title": "python-simple-dfs-dict-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887582,
                "title": "java-dfs-96-faster",
                "content": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "solutionTags": [],
                "code": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 884358,
                "title": "java-simple-one-pass-solution",
                "content": "We don\\'t need to technically recover the tree. Just collect all the values the tree is supposed to have and perform a O(1) lookup.\\n\\n```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812443,
                "title": "c-easy-set-recursion",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "solutionTags": [
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 750284,
                "title": "recursive-python-solution",
                "content": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741098,
                "title": "easy-recursive-c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 722900,
                "title": "java-recursion-and-set",
                "content": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681495,
                "title": "iterative-o-logn",
                "content": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 587897,
                "title": "java-iterative-traversal-using-queue-and-find-using-hashset",
                "content": "1. Traversed iteratively using queue and set the values for the left and right child. Additionally added the same values to the HashSet, since with the given conditions (2*x+1 and 2*x+2 with root initialized to zero) there can be no nodes with the same values.\\n2. find will check the hashset and return the value\\n\\n```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```\\nNote: Updated the code after the comment from @stanislav8",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523255,
                "title": "java-solution-stick-with-tree",
                "content": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "solutionTags": [],
                "code": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "codeTag": "Java"
            },
            {
                "id": 501417,
                "title": "python-o-n-sol-by-correction-in-dfs-approach-90-with-comment",
                "content": "Python O(n) sol. by correction in DFS approach.\\n\\nHint:\\nTake advantage of **average O(1) looking-up** in hashset(i.e., **set()** in **python**),\\nrecording node value during binary tree correction, in order to **speed-up find()** operation later on\\n\\n---\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n\\n[Leetcode #114 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n---\\n\\nReference:\\n[1] [Python official docs about built-in data structure: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486479,
                "title": "c-no-hashmap-bit-path",
                "content": "idea: Use a stack to store the bit path and then reversely find.\\n```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479099,
                "title": "python-100-less-space",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "codeTag": "Java"
            },
            {
                "id": 448692,
                "title": "python3-clean-solution-beats-80",
                "content": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 437281,
                "title": "100-space-java-easy-understandable",
                "content": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437115,
                "title": "python-no-need-to-initialize-tree-top-down-search-by-binary",
                "content": "Look at the binary presentation of \"num+1\", you will find that binary value will append \"1\" when the tree go right, append \"0\" when the tree go left. With this feature, we can do a top down search without initialization.\\n\\nWe can also do it without using binary feature. We notice that even number is always on the right branch, odd number is always on the left branch, using this feature, we can reversely find the path of the number in the tree. Reversing this path and we will have the top-down path.\\n\\n```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 435179,
                "title": "python-easy-to-understand-solution",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434356,
                "title": "python-java-easy-bitwise-trick-with-explanation",
                "content": "Given a number X, what\\'s the path to the corresponding node of X?\\nExample:\\nX = 1, path = left --> 0\\nX = 3, path = left, left --> 00\\nX = 9, path = left, right, left --> 010\\nX = 16, path = left, left, left, right --> 0001\\n......\\nCan you see the trick?\\npath = binary(X+1).substring(1)\\n\\nThen everything be quite easy:\\nPython:\\n```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\\nJava:\\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433461,
                "title": "c-super-simple-and-straight-forward-solution-with-o-1-find-can-be-easily-implemented-in-5-mins",
                "content": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "solutionTags": [],
                "code": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 432956,
                "title": "easy-preorder-traversal-hash-table-c-solution-t-o-n-s-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431344,
                "title": "c-solution",
                "content": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431058,
                "title": "java-simple-pre-order-traversal",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088287,
                "title": "java-solution-using-bits-manipulation-without-tree-recovery-tc-o-logn-sc-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083799,
                "title": "python-easy-solution-for-beginner-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing and add value into our hashset.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075263,
                "title": "dfs-recover-method-and-hashset",
                "content": "## Result\\n![image.png](https://assets.leetcode.com/users/images/6f702887-d68d-4273-b7d0-cf4a3c8e5c5b_1695363557.7931392.png)\\n\\n## Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029028,
                "title": "recursion-dfs",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010939,
                "title": "solution-using-hashmap-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will recover the tree initially and then we will store all the values from recovery to a hashmap and then return the query result referring the hashmap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Steps :**\\n1. First we create a function to traverse the tree that is provided and recover it.\\n2. While recovering, we put all the values recovered in a hashtable.\\n3. Lastly we will check if the target is present in the hashtable and return values accordingly. \\n\\n# Complexity\\n- Time complexity: O(n + q) where **n** = number of nodes present in the tree and **q** is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000237,
                "title": "c-simple-solution",
                "content": "# Approach\\n1. Recover the root first by setting it to 0 and store in map\\n2. Traverse to other nodes and recover them too\\n3. After recovering each node store that in map to search later\\n4. To find target find the value in the map and return true if found\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956071,
                "title": "easy-java-solution",
                "content": "# Intuition\\nWhen we read about the rules of the binary tree, we can understand that given any node value, we can determine the values of its left and right children. Therefore, if the tree\\'s values are changed to -1, we can still recover the tree\\'s original values by traversing it from the root and assigning the correct values according to the rules provided.\\n\\n# Approach\\n\\n1. Initialization:\\n\\n* Start by setting the root\\'s value to 0.\\n* Use a queue to traverse the tree in a BFS manner. This choice ensures that we visit nodes level by level, which is beneficial because child node values depend on parent node values.\\n* While there are nodes in the queue, pop a node.\\n* If it has a left child, set the left child\\'s value using the formula 2\\xD7node.val+1 and add the left child to the queue.\\n* Similarly, if it has a right child, set the right child\\'s value using the formula  2\\xD7node.val+2\\n* Additionally, for each node we visit, we add its value to a hash set. This set allows for O(1) look-up time when checking if a value exists in the tree.\\n\\n3. 2. Finding a Value:\\n\\n* To check if a value exists in the recovered tree, simply check if it exists in the hash set.\\n\\n\\n# Complexity\\n- Time complexity: O(N), O(1)\\n\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953690,
                "title": "level-order-traversal-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953465,
                "title": "python-easy-clean-solution",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```\\n![catty.png](https://assets.leetcode.com/users/images/5888e488-44f4-4c24-9b81-552eac175cfc_1692866410.1003535.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931318,
                "title": "python3-beats-99",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929431,
                "title": "python3-clean-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918921,
                "title": "python-solution-using-map-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the tree and assign the right set of values, also store these values in map or set which can be used later to determine whether the value exists in the tree or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the tree, and assign the correct set of values i.e. $$(2 * value  + 1)$$ for left and $$(2 * value + 2)$$ for the right. As you assign the value to the tree, store that value in order to determine whether that value exists or not when you will query the tree later.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/95e6bf36-04b7-4288-b8ea-f8bfcf1da870_1692204361.671172.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902473,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895129,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890896,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875732,
                "title": "python-easy-and-short-dfs-find-0-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ for init\\n$$O(1)$$ for find\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837024,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825912,
                "title": "c-solution-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819886,
                "title": "find-elements-in-a-contaminated-binary-tree-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788198,
                "title": "easy-c-solution-dfs-map-efficient-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn= number of nodes\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753464,
                "title": "easy-solution-with-dfs-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750362,
                "title": "cpp-using-hash-map-clean-code",
                "content": "\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746686,
                "title": "easy-c-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731771,
                "title": "depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contaminated binary tree has some of its node values modified. The modification rule is that for any node with value v, its left child\\'s value is 2 * v + 1, and its right child\\'s value is 2 * v + 2.\\nThe goal is to create a data structure that allows us to efficiently determine whether a given value exists in the contaminated tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1\\uFE0F\\u20E3 Contaminate Tree: Starting from the root, recursively traverse the tree and modify each node\\'s value based on the contamination rule.\\n2\\uFE0F\\u20E3 Find Operation: Implement a depth-first search (DFS) to traverse the tree and check if the target value is found.\\n\\nIf the current node\\'s value matches the target, mark it as found.\\nIf not found, recursively search in the left and right subtrees.\\n3\\uFE0F\\u20E3 Initialization: Initialize the root node with a value of 0 and call the ContaminateTree function.\\n4\\uFE0F\\u20E3 Construction: Create an instance of the FindElements class with the root of the contaminated tree.\\n5\\uFE0F\\u20E3 Query: Use the find method on the FindElements object to check if a target value exists in the contaminated tree. The find method performs a DFS search and returns true if the target is found, and false otherwise.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709999,
                "title": "c-implementation-using-set-data-structure",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708836,
                "title": "a-new-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA particular value could be reached from a particular path only. So instead of saving the entire list of nodes in hashset, just save the leaves.\\n\\n# Complexity\\n- Time complexity:\\nFindElements = O(N)\\nfind = O(H); H --> max height;\\nTotal = O(H+N) = O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H + 2^H); \\nO(H) --> for stack of recursion\\nO(2^H) --> max no. of leaf node that can be saved in the set.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708205,
                "title": "recursive-inorder-solution-c",
                "content": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "codeTag": "Java"
            },
            {
                "id": 3705988,
                "title": "easy-to-understand-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702949,
                "title": "c-bfs-binary-search-99-1-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693644,
                "title": "java-not-restoring-the-tree-just-deriving-and-following-the-path-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe don\\'t need to compute the values at all, given the formula we can trace back if, at each level in the tree, we have to go through the left or right subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGiven the formula, we know that odd values are in left subtree w.r.t. their parent, even values to the right.\\n\\nReworking the formula backward, we can derive the immediate predecessor in the path from root to target (e.g., (value - 1) / 2 for odd values, (value - 2) / 2 for even), in this way we can compute an array with the path root (index 0) to the target value (index equivalent to the depth at which the value lies).\\n\\nWith this array, we can, at each step, decide if we need to go left (odd value), or right (even value), and we just need to follow the right child of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N) for computing the target level, O(log N) for computing the array, O(log N) to traverse, still summing up to O(log N) in total.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe array for each requests is as long as the path, which is O(log N).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687184,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687083,
                "title": "java-dfs-preorder",
                "content": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679723,
                "title": "c-easy-fast-dfs-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672040,
                "title": "c-set-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662753,
                "title": "recursive-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660362,
                "title": "dfs-set-beats-100",
                "content": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3654585,
                "title": "dfs-hashset-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***There are two approaches in which this can be solved.***\\n\\n- We can avoid \\'Recover\\' of the tree. But everytime we want to Find a value, we would need to traverse the contaminated tree via BFS to find possibility of existance of the target element.\\n- We can recover the contaminated tree and everytime we recover a node, we\\'ll add it\\'s value to a HashSet. With this the Find can work in O(1).\\n-*<b>If we wish not to use a HashSet, then we can \"Find\" via BFS efficiently compared to DFS</b>. Because, since the elements will be ordered at each level (top-to-bottom + left-to-right), we can conclude that the target element is not present if we encounter any element whose value is greater than our target. The same cannot be concluded via DFS.*\\n\\n![Screenshot 2023-06-19 084844.png](https://assets.leetcode.com/users/images/28d70aee-77ce-4759-9af4-fb451bcf67ad_1687144782.9810998.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - Recover - as we need to visit every node of the contaminated tree.\\nO(1) - Find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we use a HashSet\\n*if we wish not use a hashset, we can search via DFS with O(1) space complexity and O(N) runtime complexity*\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641333,
                "title": "very-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605244,
                "title": "c-solution-with-back-traverse",
                "content": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "C#"
                ],
                "code": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3587328,
                "title": "c-simple-and-interesting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->To implement this, I chose to use a depth-first traversal of the binary tree. Starting from the root node, I assign the value 0 to the root and recursively recover the values of the left and right subtrees based on the parent node\\'s value.\\n\\n->During the recovery process, I store the recovered values in an unordered set (values) to enable efficient lookup in the find method.\\n\\n->The expression values.count(target) > 0 compares the result of values.count(target) with 0. If the count is greater than 0, it means that the target value was found in the set, which gives us true. Otherwise, if the count is 0, it means that the target value is not present in the set, and we can return false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS and Unordered_set\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585307,
                "title": "c-searching-in-tree",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584270,
                "title": "solution",
                "content": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\\n\\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580493,
                "title": "easiest-sol-c-recursion-binary-tree",
                "content": "# Intuition\\ni stored all the recovered elements in a map and then checked whether they are present or not and returned the bool value\\n\\n# Approach\\nmade a build function with index and TreeNode and if its value was -1 then i stored the node with its real value else ignored it and later in the find function just checked whether element was present or not \\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)re\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575305,
                "title": "c-2-different-approaches-with-code-explanation-1-runtime-efficient-2-space-efficient",
                "content": "# Intuition\\nI tried to explain both the basic approaches that I did + codes are below, please upvote if you find this helpful : )\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nFirst approach is having better runtime (better than 90%) as it uses set and we dont have to search in the tree to find hence it saves recursion stack calling, but uses  extra space.\\n\\n# Approach 2 \\n\\nThis approach is having better memory control (better than 90% ), it uses basic methods which saves extra space but the runtime is slower, so have a loook at both\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Approach 1\\nO(N) in both cases\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nrecursive internal stack and set in approach 1\\n\\n# Code\\n```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566938,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566522,
                "title": "c-easiest-solution-recursive",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574006,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 1573193,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 2020758,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            }
        ]
    },
    {
        "title": "Greatest Sum Divisible by Three",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the <strong>maximum possible sum </strong>of elements of the array such that it is divisible by three</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,5,1,8]\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Since 4 is not divisible by 3, do not pick any number.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,4]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 431077,
                "title": "java-c-python-one-pass-o-1-space",
                "content": "# **Explanation**\\ndp[0] = largest sum which is divisible by 3\\ndp[1] = largest sum when divided by 3, remainder = 1\\ndp[2] = largest sum when divided by 3, remainder = 2\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java\\n```java\\n    public int maxSumDivThree(int[] A) {\\n        int[] dp = new int[3];\\n        for (int a : A)\\n            for (int i: Arrays.copyOf(dp, dp.length))\\n                dp[(i + a) % 3] = Math.max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxSumDivThree(vector<int>& A) {\\n        vector<int> dp(3);\\n        for (int a : A)\\n            for (int i : vector<int>(dp))\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\\n**Python:**\\n```python\\n    def maxSumDivThree(self, A):\\n        dp = [0, 0, 0]\\n        for a in A:\\n            for i in dp[:]:\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a)\\n        return dp[0]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumDivThree(int[] A) {\\n        int[] dp = new int[3];\\n        for (int a : A)\\n            for (int i: Arrays.copyOf(dp, dp.length))\\n                dp[(i + a) % 3] = Math.max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\n```cpp\\n    int maxSumDivThree(vector<int>& A) {\\n        vector<int> dp(3);\\n        for (int a : A)\\n            for (int i : vector<int>(dp))\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\n```python\\n    def maxSumDivThree(self, A):\\n        dp = [0, 0, 0]\\n        for a in A:\\n            for i in dp[:]:\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a)\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431108,
                "title": "java-o-n-solution-simple-math-o-1-space",
                "content": "Add all together, if sum%3==0, return sum. \\nif sum%3==1, remove the smallest number which has n%3==1.\\nif sum%3==2, remove the smallest number which has n%3==2.\\n\\none pass, and we need to keep the smallest two numbers that have n1%3==1 and n2%3==2.\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int res = 0, leftOne = 20000, leftTwo = 20000;\\n        for(int n:nums){\\n            res+=n;\\n            if(n%3==1){\\n                leftTwo = Math.min(leftTwo,leftOne+n);\\n                leftOne = Math.min(leftOne,n);\\n            }\\n            if(n%3==2) {\\n                leftOne = Math.min(leftOne,leftTwo+n);\\n                leftTwo = Math.min(leftTwo,n);\\n            }\\n        }\\n        if(res%3==0) return res;\\n        if(res%3==1) return res-leftOne;\\n        return res - leftTwo;\\n        \\n    }\\n}\\n```\\nDp solution for K problem:\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivK(nums,3);\\n    }\\n    public int maxSumDivK(int[] nums, int k){\\n        if(k==0) return -1;\\n        int[] dp = new int[k];\\n        for(int num : nums){\\n            int tmp[] = Arrays.copyOf(dp,k);\\n            for(int i=0;i<k;i++){\\n                dp[(num+tmp[i])%k] = Math.max(dp[(num+tmp[i])%k],num+tmp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int res = 0, leftOne = 20000, leftTwo = 20000;\\n        for(int n:nums){\\n            res+=n;\\n            if(n%3==1){\\n                leftTwo = Math.min(leftTwo,leftOne+n);\\n                leftOne = Math.min(leftOne,n);\\n            }\\n            if(n%3==2) {\\n                leftOne = Math.min(leftOne,leftTwo+n);\\n                leftTwo = Math.min(leftTwo,n);\\n            }\\n        }\\n        if(res%3==0) return res;\\n        if(res%3==1) return res-leftOne;\\n        return res - leftTwo;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivK(nums,3);\\n    }\\n    public int maxSumDivK(int[] nums, int k){\\n        if(k==0) return -1;\\n        int[] dp = new int[k];\\n        for(int num : nums){\\n            int tmp[] = Arrays.copyOf(dp,k);\\n            for(int i=0;i<k;i++){\\n                dp[(num+tmp[i])%k] = Math.max(dp[(num+tmp[i])%k],num+tmp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559999,
                "title": "come-here-if-you-can-t-seem-to-get-it-full-explanation-uncondensed-code",
                "content": "I originally couldn\\'t understand the logic because many of the solutions combine handling the transitioning between states cleverly using math. I\\'ll attempt to explain exactly whats happening and how we\\'re going to track this state. \\n\\nSo the state here is `dp[i][m]`. `dp[i][m]` = largest sum from a subset of `nums[:i]` such that the sum % 3 equals m. After defining this we loop thru each number in `nums`. At each number we mod it by 3 and see what the result is. \\n\\nFor example, lets say the current number (`nums[i]`) we\\'re looking at is 4. 4 % 3 = 1. So what does this mean? For each of the states we\\'re tracking (`dp[i][0]`, `dp[i][1]`, `dp[i][2]`) how can we use this? If we add a number with remainder 1 to a sum with remainder 1 what do we get? We get a number with remainder 2. So we can use this info to construct the answer!\\n\\n**Example: If nums[i] % 3 == 1. We have remainder 1. How can we use this?:**\\n* For `dp[i][0]` we want a remainder of 0. How do we get this given we currently have a remainder of 1? We can add this number with remainder 1 to a sum with remainder 2. This creates an overall remainder of 0 as 2 + 1 = 3\\n* For `dp[i][1]` we want a remainder of 1. This means we can add this number to `dp[i-1][0]`. This will give an overall remainder of 1 (num_with_remainder_0 + num_with_remainder_1) % 3 = 1.\\n* For `dp[i][2]` we do the same thing. We can add the number to `dp[i][1]`. Why? If you\\'ve been following you can probably answer now.\\n\\nWe do this for each of the three cases:\\n1. if num % 3 == 0\\n2. if num % 3 == 1\\n3. if num % 3 == 2\\n\\nAnd we\\'re done.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tdp = [[0]*3 for _ in range(n+1)]\\n\\tdp[0][1] = float(\\'-inf\\')\\n\\tdp[0][2] = float(\\'-inf\\')\\n\\tfor i in range(1, n+1):\\n\\t\\tif nums[i-1] % 3 == 0: # Current remainder == 0\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\\n\\t\\telif nums[i-1] % 3 == 1: # Current remainder == 1\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\\n\\t\\telse: # Current remainder == 2\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\\n\\n\\treturn dp[-1][0]\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tdp = [[0]*3 for _ in range(n+1)]\\n\\tdp[0][1] = float(\\'-inf\\')\\n\\tdp[0][2] = float(\\'-inf\\')\\n\\tfor i in range(1, n+1):\\n\\t\\tif nums[i-1] % 3 == 0: # Current remainder == 0\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\\n\\t\\telif nums[i-1] % 3 == 1: # Current remainder == 1\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\\n\\t\\telse: # Current remainder == 2\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\\n\\n\\treturn dp[-1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927253,
                "title": "step-by-step-top-down-bottom-up-optimised-dp-u-should-do-a-recursive-solution-first",
                "content": "To solve this problem, **we find the subsets of the given array and check if the `subset sum` is divisible by 3, if so pick the largest `subset sum`**\\n\\nFinding subsets sum is not hard,  just tweak the solution of [78. Subsets](https://leetcode.com/problems/subsets/).\\n\\nCreate a basic form of the recurisve solution, build the solution on top of this\\n\\n```javascript\\nfunction rc (nums, index = 0, currentSum = 0) { // O(2^n)\\n    if (index >= nums.length) return currentSum % 3 ? -Infinity : currentSum; // if not divisible by 3, ignore its value by returning the smallest possible number\\n    return Math.max( // return subset sum\\n        rc(nums, index + 1, currentSum + nums[index]), // use current number\\n        rc(nums, index + 1, currentSum) // skip current number\\n    )\\n}\\n```\\n\\n**The problem now is \"find a way to cache the results at each index\". `dp[index][currentSum]` is not going to help as there are too many `currentSum` values**\\n\\n**Let\\'s find another way to get `subset sum` and keep only the those divisible by 3. Instead of passing `currentSum` to the function, we can pass the `reminder`. If the final reminder is not zero, we ignore the `subset sum`.**\\n\\n```javascript\\nfunction rc (nums, index = 0, remainder = 0) { // O(2^n)\\n    if (index >= nums.length) return remainder ? -Infinity : 0; // \\n    return Math.max( // subset sum = current number + max subset sum from next index OR skip the current number\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3), // calculate the new reminder after using the current number\\n        rc(nums, index + 1, remainder) // skip the current number\\n    )\\n}\\n```\\n\\n**Results now look cachable, there are only 3 possible reminders at each index, we will get O(3n) complexity if we cache/memoise them**\\n\\n```javascript\\nfunction rc (nums, index = 0, remainder = 0, memo = {}) { \\n    if (index >= nums.length) return remainder ? -Infinity : 0;\\n\\n    const memoKey = `${index},${remainder}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey] ;\\n    \\n    return memo[memoKey] = Math.max(\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3, memo),\\n        rc(nums, index + 1, remainder , memo)\\n    )\\n}\\n```\\n\\n**You have a DP solution already, now you want the fancy iterative DP arrays. All you need to do is just translate the recursive solution.**\\n\\n```javascript\\nfunction dp (nums) {\\n    const dp = Array(nums.length + 1).fill(0).map(\\n        () => Array(3).fill(0).map(\\n            (_, remainder) => remainder ? -Infinity : 0\\n        )\\n    );\\n   \\n    for (let i = 1; i <= nums.length; i++) {\\n        for (let r = 0; r < 3; r++) {\\n            dp[i][r] = Math.max( // who cares about what dp[i][r] means, this is a direct translation from the recursive solution which is far easier to understand. \\n                nums[i - 1] + dp[i - 1][(r + nums[i - 1]) % 3],\\n                dp[i - 1][r]\\n            )\\n        }\\n    }\\n    \\n    return dp[nums.length][0]\\n}\\n```\\n\\n**now, you can create the optimised O(n) O(1) dp**\\n\\n```javascript\\nfunction dp2 (nums) { \\n\\t// only dp[i - 1] is needed for calculatiing the next result, we just need two variables instead of an array\\n    const current = Array(3).fill(0).map((_, remainder) => remainder ? -Infinity : 0);\\n   \\n    for (let i = 0; i < nums.length; i++) {\\n        const previous = current.slice();\\n        for (let r = 0; r < 3; r++) {\\n            current[r] = Math.max(nums[i] + previous[(r + nums[i]) % 3], previous[r]);\\n        }\\n    }\\n    \\n    return current[0]\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```javascript\\nfunction rc (nums, index = 0, currentSum = 0) { // O(2^n)\\n    if (index >= nums.length) return currentSum % 3 ? -Infinity : currentSum; // if not divisible by 3, ignore its value by returning the smallest possible number\\n    return Math.max( // return subset sum\\n        rc(nums, index + 1, currentSum + nums[index]), // use current number\\n        rc(nums, index + 1, currentSum) // skip current number\\n    )\\n}\\n```\n```javascript\\nfunction rc (nums, index = 0, remainder = 0) { // O(2^n)\\n    if (index >= nums.length) return remainder ? -Infinity : 0; // \\n    return Math.max( // subset sum = current number + max subset sum from next index OR skip the current number\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3), // calculate the new reminder after using the current number\\n        rc(nums, index + 1, remainder) // skip the current number\\n    )\\n}\\n```\n```javascript\\nfunction rc (nums, index = 0, remainder = 0, memo = {}) { \\n    if (index >= nums.length) return remainder ? -Infinity : 0;\\n\\n    const memoKey = `${index},${remainder}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey] ;\\n    \\n    return memo[memoKey] = Math.max(\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3, memo),\\n        rc(nums, index + 1, remainder , memo)\\n    )\\n}\\n```\n```javascript\\nfunction dp (nums) {\\n    const dp = Array(nums.length + 1).fill(0).map(\\n        () => Array(3).fill(0).map(\\n            (_, remainder) => remainder ? -Infinity : 0\\n        )\\n    );\\n   \\n    for (let i = 1; i <= nums.length; i++) {\\n        for (let r = 0; r < 3; r++) {\\n            dp[i][r] = Math.max( // who cares about what dp[i][r] means, this is a direct translation from the recursive solution which is far easier to understand. \\n                nums[i - 1] + dp[i - 1][(r + nums[i - 1]) % 3],\\n                dp[i - 1][r]\\n            )\\n        }\\n    }\\n    \\n    return dp[nums.length][0]\\n}\\n```\n```javascript\\nfunction dp2 (nums) { \\n\\t// only dp[i - 1] is needed for calculatiing the next result, we just need two variables instead of an array\\n    const current = Array(3).fill(0).map((_, remainder) => remainder ? -Infinity : 0);\\n   \\n    for (let i = 0; i < nums.length; i++) {\\n        const previous = current.slice();\\n        for (let r = 0; r < 3; r++) {\\n            current[r] = Math.max(nums[i] + previous[(r + nums[i]) % 3], previous[r]);\\n        }\\n    }\\n    \\n    return current[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431057,
                "title": "python-math-solution",
                "content": "Divide the whole list into three parts: mod_0, mod_1, mod_2.\\nThink about the sum of the original list, if it mods 3 == 0, then we can just return the sum.\\nIf tot_sum % 3 == 1, then we should remove one smallest element from mod_1 or two smallest ones from mod_2.\\nIf tot_sum % 3 == 2, then we should remove one smallest element from mod_2 or two smallest ones from mod_1.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod_1, mod_2,res,remove = [], [], 0, float(\\'inf\\')\\n        for i in nums:\\n            if i%3 == 0: res += i\\n            if i%3 == 1: mod_1 += [i]\\n            if i %3 == 2: mod_2 += [i]\\n        mod_1.sort(reverse = True)\\n        mod_2.sort(reverse = True)\\n        tmp = sum(mod_1) +sum(mod_2)\\n        if tmp % 3 == 0:\\n            return res + tmp\\n        elif tmp% 3 == 1:\\n            if len(mod_1): remove = min(remove,mod_1[-1])\\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\\n        elif tmp % 3 == 2:\\n            if len(mod_2): remove = min(remove,mod_2[-1])\\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\\n        return res + tmp - remove\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod_1, mod_2,res,remove = [], [], 0, float(\\'inf\\')\\n        for i in nums:\\n            if i%3 == 0: res += i\\n            if i%3 == 1: mod_1 += [i]\\n            if i %3 == 2: mod_2 += [i]\\n        mod_1.sort(reverse = True)\\n        mod_2.sort(reverse = True)\\n        tmp = sum(mod_1) +sum(mod_2)\\n        if tmp % 3 == 0:\\n            return res + tmp\\n        elif tmp% 3 == 1:\\n            if len(mod_1): remove = min(remove,mod_1[-1])\\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\\n        elif tmp % 3 == 2:\\n            if len(mod_2): remove = min(remove,mod_2[-1])\\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\\n        return res + tmp - remove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431785,
                "title": "c-commented-dp-solution-that-actually-makes-sense",
                "content": "Well, at least hopefully this explanation makes sense.\\nI had to reverse-engineer the solution from a lot of solutions that didn\\'t explain anything. lol\\n\\nIf you want to optimize the solution for space like many other solutions did, you can choose to just keep the latest calculated sum. You don\\'t need all the information up to `n`.\\n\\n```\\n    int maxSumDivThree(vector<int>& vec) {\\n       vector<vector<int>> dp(vec.size() + 1, vector<int>(3));\\n   \\n       /* What does the first index mean? (i)\\n        *  It means we\\'re currently looking at the subarray from 0 to i (exclusive).\\n        *\\n        * What does the second index mean? (j)\\n        *  It represents the remainder that we currently have.\\n        *\\n        * We want to find dp[N][0]. In other words, we want to find the greatest sum of the whole array, given that we have no remainder left to add, that is still divisible by 3.\\n        */\\n   \\n       dp[0][0] = 0; // our sum at this point is 0, and we have no remainder left to add. that gives us 0, which is divisible by 3, so 0 is a valid answer!\\n       dp[0][1] = INT_MIN; // our sum at this point is 0, and we have 1 remainder left to add. that gives us 1, which is not divisible by 3, and is invalid.\\n       dp[0][2] = INT_MIN; // same as above. 2 is not divisible by 3, which is invalid.\\n\\n        \\n       for (unsigned int i = 1; i <= vec.size(); i++)\\n       {\\n           int ind = i-1;\\n           /* At every i, we have a choice.\\n            *\\n            *  1. Skip the element. So our answer is just our previous answer.\\n            *\\n            *  2. Add the element to our sum. If we add this element, that means our remainder will now be (num % 3).\\n            *  This won\\'t give us a number that\\'s fully divisible by 3 by itself, well, unless (num % 3) is 0.\\n            *\\n            *  The only way we can get one, is if we look at a state which is dependent on adding the remainder (num % 3) to get a number divisible by 3.\\n            *  Luckily, we can find one for the step right before us using dp[i-1][(vec[ind] % 3)]!\\n            */\\n           dp[i][0] = max(dp[i-1][0], dp[i-1][(vec[ind]) % 3] + vec[ind]);\\n   \\n           /* The same logic applies for 1 and 2.\\n            * We add 1 or 2 because we still need to count our outstanding remainder.\\n            *\\n            * In other words:\\n            *\\n            * If we\\'re at dp[i][1], we\\'re at the state where we have +1 remainder.\\n            * If we\\'re at dp[i][2], we\\'re at the state where we have +2 remainder.\\n            *\\n            * We combine that with the remainder we\\'ll get when we add our element.\\n            */\\n           dp[i][1] = max(dp[i-1][1], dp[i-1][(vec[ind]+1) % 3] + vec[ind]);\\n           dp[i][2] = max(dp[i-1][2], dp[i-1][(vec[ind]+2) % 3] + vec[ind]);\\n       }\\n        \\n       return dp[vec.size()][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Well, at least hopefully this explanation makes sense.\\nI had to reverse-engineer the solution from a lot of solutions that didn\\'t explain anything. lol\\n\\nIf you want to optimize the solution for space like many other solutions did, you can choose to just keep the latest calculated sum. You don\\'t need all the information up to `n`.\\n\\n```\\n    int maxSumDivThree(vector<int>& vec) {\\n       vector<vector<int>> dp(vec.size() + 1, vector<int>(3));\\n   \\n       /* What does the first index mean? (i)\\n        *  It means we\\'re currently looking at the subarray from 0 to i (exclusive).\\n        *\\n        * What does the second index mean? (j)\\n        *  It represents the remainder that we currently have.\\n        *\\n        * We want to find dp[N][0]. In other words, we want to find the greatest sum of the whole array, given that we have no remainder left to add, that is still divisible by 3.\\n        */\\n   \\n       dp[0][0] = 0; // our sum at this point is 0, and we have no remainder left to add. that gives us 0, which is divisible by 3, so 0 is a valid answer!\\n       dp[0][1] = INT_MIN; // our sum at this point is 0, and we have 1 remainder left to add. that gives us 1, which is not divisible by 3, and is invalid.\\n       dp[0][2] = INT_MIN; // same as above. 2 is not divisible by 3, which is invalid.\\n\\n        \\n       for (unsigned int i = 1; i <= vec.size(); i++)\\n       {\\n           int ind = i-1;\\n           /* At every i, we have a choice.\\n            *\\n            *  1. Skip the element. So our answer is just our previous answer.\\n            *\\n            *  2. Add the element to our sum. If we add this element, that means our remainder will now be (num % 3).\\n            *  This won\\'t give us a number that\\'s fully divisible by 3 by itself, well, unless (num % 3) is 0.\\n            *\\n            *  The only way we can get one, is if we look at a state which is dependent on adding the remainder (num % 3) to get a number divisible by 3.\\n            *  Luckily, we can find one for the step right before us using dp[i-1][(vec[ind] % 3)]!\\n            */\\n           dp[i][0] = max(dp[i-1][0], dp[i-1][(vec[ind]) % 3] + vec[ind]);\\n   \\n           /* The same logic applies for 1 and 2.\\n            * We add 1 or 2 because we still need to count our outstanding remainder.\\n            *\\n            * In other words:\\n            *\\n            * If we\\'re at dp[i][1], we\\'re at the state where we have +1 remainder.\\n            * If we\\'re at dp[i][2], we\\'re at the state where we have +2 remainder.\\n            *\\n            * We combine that with the remainder we\\'ll get when we add our element.\\n            */\\n           dp[i][1] = max(dp[i-1][1], dp[i-1][(vec[ind]+1) % 3] + vec[ind]);\\n           dp[i][2] = max(dp[i-1][2], dp[i-1][(vec[ind]+2) % 3] + vec[ind]);\\n       }\\n        \\n       return dp[vec.size()][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1777839,
                "title": "all-4-dp-approaches-o-1-space-c",
                "content": "**Approach 1 - Recursion**\\n```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n```\\n**Approach 2 -  Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\\n\\n**Approach 3 - Tabulation**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\\n\\n**Approach 4 - Space Optimized Tabulation**\\n```\\nclass Solution {\\npublic:\\nint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(1,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[0][0] + nums[i];\\n            int y = dp[0][1] + nums[i];\\n            int z = dp[0][2] + nums[i];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[0][x%3] = max({dp[0][x%3],x});\\n            dp[0][y%3] = max({dp[0][y%3],y});\\n            dp[0][z%3] = max({dp[0][z%3],z});\\n            \\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(1,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[0][0] + nums[i];\\n            int y = dp[0][1] + nums[i];\\n            int z = dp[0][2] + nums[i];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[0][x%3] = max({dp[0][x%3],x});\\n            dp[0][y%3] = max({dp[0][y%3],y});\\n            dp[0][z%3] = max({dp[0][z%3],z});\\n            \\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 439097,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nFormulate a dynamic programming solution from the bottom-up by tracking the maximum sum mod 3 in buckets 0, 1, 2.\\n\\n1. Initially buckets 0, 1, 2 are set to 0... `{ 0, 0, 0 }`\\n2. For each `num` in `A`\\n    a. let `sum` be `num` plus each ongoing maximum `sum` in buckets `0, 1, 2`\\n    b. update the bucket corresponding to `sum % 3` to be the maximum of its current value and this current sum\\n3. Return the value in bucket 0 (ie. the maximum sum of elements in A which is evenly divisible by 3)\\n\\n**Notes:**\\n* If the above explanation does *not* make sense, the 3 examples below show step-by-step how this algorithm works.\\n* The solutions below begin with commented verbosity to help understand the algorithm\\'s general concept.  Then each solution is incrementally refactored for memory optimization and conciseness (just for fun!).\\n\\n**Runtime:** O(N)\\n\\n*Example 1:*\\n\\n```\\nA = [3,6,5,1,8]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n     ^\\nbuckets { 3, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n       ^\\nbuckets { 9, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n         ^\\nbuckets { 9, 0, 14 }\\n          0  1   2\\n\\nA = [3,6,5,1,8]\\n           ^\\nbuckets { 15, 10, 14 }\\n           0   1   2\\n\\nA = [3,6,5,1,8]\\n             ^\\nbuckets { 18, 22, 23 }\\n           0   1   2\\n           \\nthe answer in buckets[0] is 18\\n```\\n\\n*Example 2:*\\n```\\nA = [4]\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [4]\\n     ^\\nbuckets { 0, 4, 0 }\\n          0  1  2\\n          \\nthe answer in buckets[0] is 0\\n```\\n\\n*Example 3:*\\n```\\nA = [1,2,3,4,4]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n     ^\\nbuckets { 0, 1, 0 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n       ^\\nbuckets { 3, 1, 2 } \\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n         ^\\nbuckets { 6, 4, 5 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n           ^\\nbuckets { 9, 10, 8 }\\n          0   1  2\\n\\nA = [1,2,3,4,4]\\n             ^\\nbuckets { 12, 13, 14 } \\n           0   1   2\\n\\nthe answer in buckets[0] is 12\\n```\\n\\n---\\n**Javascript Solutions:**\\n\\n*Javascript (verbose)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let buckets = [...Array(N + 1)].map(_ => Array(3).fill(0));\\n    for (let i = 1; i <= N; ++i) {\\n        buckets[i] = [...buckets[i - 1]]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            buckets[i][sum % 3] = Math.max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let i = 1; i <= N; ++i) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization + more concise code)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre) {\\n            let sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization + most concise code)*\\n```\\nlet maxSumDivThree = (A, cur = [0, 0, 0]) => {\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre)\\n            cur[(x + y) % 3] = Math.max(cur[(x + y) % 3], x + y); // add A[i] (ie. x) onto each previous bucket and update each current bucket to max of itself and the current sum (x + y)\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*C++ (verbose)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI buckets(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            buckets[i] = buckets[i - 1]; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                buckets[i][sum % 3] = max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI cur(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization + more concise code)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre) {\\n                auto sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization + most concise code)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y); // update each (current sum % 3) bucket to max of itself and the current sum (x + y)\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n---\\n\\n**Update 2021-01-15:** I just solved this one from scratch in C++ to document my thought process as follows: let `N` be the cardinality of `A` which is at most `40,000`, so I know I need to create a near-linear algorithm to avoid TLE which we know will occur from a quadratic asymptotic bound O(`N`<sup>2</sup>), ie. `40,000 * 40,000 == 1,600,000,000` (since we expect anything over one million or so operations to TLE).  Using this deductive reasoning, I thought `120,000` works to create \"buckets\" `0`,`1`,`2` of each maximum sum so far mod `3` from the bottom-up.  Based on this overall game plan, I came up with the recurrence relation and then wrote the corresponding code as follows...\\n\\n**Recurrence Relation:**\\n\\nLet `dp[i][j]` denote the maximum possible sum ending at `i` non-inclusive who\\'s value mod `3` is `j`\\nThen `dp[N][0]` is the maximum possible sum ending at `N` non-inclusive who\\'s value mod `3` is `0` (ie. evenly divisible by `3`)\\n\\n**C++ Code:**\\n\\nIn the code below `x` is the maximum sum so far and `k` is the mod `3` \"bucket\":\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j]; // init current row from previous row\\n            }\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + dp[i - 1][j];\\n                auto k = x % 3;\\n                dp[i][k] = max(dp[i][k], x);\\n            }\\n        }\\n        return dp[N][0];\\n    }\\n};\\n```\\n\\nAnd then from here, I just iteratively refactored...\\n\\n1. since the current row `dp[i]` is only dependent upon the previous row `dp[i - 1]` we can optimize memory from O(N<sup>2</sup>), ie. storing the entire `dp` matrix, to O(N) by only storing the current and previous rows, ie. `cur` and `pre` correspondingly.\\n2. the index `i` isn\\'t needed, so use `x` in place of `A[i]`\\n3. likewise the index `j` isn\\'t needed, so use `y` in place of `pre[j]`, then notice the previous use of `y` and `k` were ephemeral, intermediary values\\n4. instead of continually swapping `cur` and `pre`, we can create copies of `cur` as `pre` upon demand\\n\\n```\\n// refactor 1\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI pre(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + pre[j];\\n                auto k = x % 3;\\n                cur[k] = max(cur[k], x);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 2\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto y = x + pre[j];\\n                auto k = y % 3;\\n                cur[k] = max(cur[k], y);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 3\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 4\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            VI pre{ cur };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nA = [3,6,5,1,8]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n     ^\\nbuckets { 3, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n       ^\\nbuckets { 9, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n         ^\\nbuckets { 9, 0, 14 }\\n          0  1   2\\n\\nA = [3,6,5,1,8]\\n           ^\\nbuckets { 15, 10, 14 }\\n           0   1   2\\n\\nA = [3,6,5,1,8]\\n             ^\\nbuckets { 18, 22, 23 }\\n           0   1   2\\n           \\nthe answer in buckets[0] is 18\\n```\n```\\nA = [4]\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [4]\\n     ^\\nbuckets { 0, 4, 0 }\\n          0  1  2\\n          \\nthe answer in buckets[0] is 0\\n```\n```\\nA = [1,2,3,4,4]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n     ^\\nbuckets { 0, 1, 0 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n       ^\\nbuckets { 3, 1, 2 } \\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n         ^\\nbuckets { 6, 4, 5 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n           ^\\nbuckets { 9, 10, 8 }\\n          0   1  2\\n\\nA = [1,2,3,4,4]\\n             ^\\nbuckets { 12, 13, 14 } \\n           0   1   2\\n\\nthe answer in buckets[0] is 12\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let buckets = [...Array(N + 1)].map(_ => Array(3).fill(0));\\n    for (let i = 1; i <= N; ++i) {\\n        buckets[i] = [...buckets[i - 1]]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            buckets[i][sum % 3] = Math.max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let i = 1; i <= N; ++i) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre) {\\n            let sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = (A, cur = [0, 0, 0]) => {\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre)\\n            cur[(x + y) % 3] = Math.max(cur[(x + y) % 3], x + y); // add A[i] (ie. x) onto each previous bucket and update each current bucket to max of itself and the current sum (x + y)\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI buckets(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            buckets[i] = buckets[i - 1]; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                buckets[i][sum % 3] = max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI cur(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre) {\\n                auto sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y); // update each (current sum % 3) bucket to max of itself and the current sum (x + y)\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j]; // init current row from previous row\\n            }\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + dp[i - 1][j];\\n                auto k = x % 3;\\n                dp[i][k] = max(dp[i][k], x);\\n            }\\n        }\\n        return dp[N][0];\\n    }\\n};\\n```\n```\\n// refactor 1\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI pre(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + pre[j];\\n                auto k = x % 3;\\n                cur[k] = max(cur[k], x);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 2\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto y = x + pre[j];\\n                auto k = y % 3;\\n                cur[k] = max(cur[k], y);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 3\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 4\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            VI pre{ cur };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524408,
                "title": "c-o-n-time-complexity-with-explanation",
                "content": "The idea is to sum up every ```nums[i]```, and then substract the smallest one or two numbers to make the sum divisible by 3.\\nWe record the most 2 smallest ```nums[i]``` for each ```% 3 = 1``` and ```% 3 = 2```. The name of ```m1fir```stands for \"mod  = 1 first\" (smallest), and```m2sec``` stands for \"mod = 2 second\" (second smallest).\\nAt last, in case of ```sum % 3 == 1```, we substract the smallest \"mod 3 = 1\" (which is m1fir) OR the sum of the two smallest \"mod 3 = 2\" (which is m2fir + m2sec) whichever is smaller because (2 + 2) % 3 = 1. Case of ```sum % 3 == 2``` can be dealed with similar method.\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int m1fir = 10001, m1sec = 10001, m2fir = 10001, m2sec = 10001;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if (nums[i] % 3 == 1)\\n            {\\n                if (nums[i] < m1fir)\\n                {\\n                    m1sec = m1fir;\\n                    m1fir = nums[i];\\n                }\\n                else if (nums[i] < m1sec) m1sec = nums[i];\\n            }\\n            else if (nums[i] % 3 == 2)\\n            {\\n                if (nums[i] < m2fir)\\n                {\\n                    m2sec = m2fir;\\n                    m2fir = nums[i];\\n                }\\n                else if (nums[i] < m2sec) m2sec = nums[i];\\n            }\\n        }\\n        if (sum % 3 == 0) return sum;\\n        if (sum % 3 == 1) return sum - min(m1fir, m2fir + m2sec);\\n        return sum - min(m2fir, m1fir + m1sec);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```nums[i]```\n```nums[i]```\n```% 3 = 1```\n```% 3 = 2```\n```m1fir```\n```m2sec```\n```sum % 3 == 1```\n```sum % 3 == 2```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int m1fir = 10001, m1sec = 10001, m2fir = 10001, m2sec = 10001;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if (nums[i] % 3 == 1)\\n            {\\n                if (nums[i] < m1fir)\\n                {\\n                    m1sec = m1fir;\\n                    m1fir = nums[i];\\n                }\\n                else if (nums[i] < m1sec) m1sec = nums[i];\\n            }\\n            else if (nums[i] % 3 == 2)\\n            {\\n                if (nums[i] < m2fir)\\n                {\\n                    m2sec = m2fir;\\n                    m2fir = nums[i];\\n                }\\n                else if (nums[i] < m2sec) m2sec = nums[i];\\n            }\\n        }\\n        if (sum % 3 == 0) return sum;\\n        if (sum % 3 == 1) return sum - min(m1fir, m2fir + m2sec);\\n        return sum - min(m2fir, m1fir + m1sec);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432201,
                "title": "java-o-n-time-o-1-space-one-pass-with-explanation",
                "content": "In this problem we find the sum of all the elements in the array.\\nLet it be sum.\\nNow there can be 3 cases:\\n1. sum % 3 == 0\\n2. sum % 3 == 1\\n3. sum % 3 == 2\\nIf sum % 3 == 0, we can return sum.\\nNow there was an observation in this problem. \\n\\n\\n**When we have the sum % 3 == 1**, **we can remove either one element with nums[i] % 3 == 1**(if there exists one such element) to get the remaining-sum of the elements divisible by 3 **OR** **we could remove two elements form the nums array which when divided by 3 gave 2 as remainder**(if they exist). It is quite obvious that if you would want to remove a single element with mod 3 == 1, you would want to remove the minimum element out of all those which when when divided by 3 gave remainder as 1. Similarly if you were to remove two elements which gave remainder 2 on division by 3, you would want to remove the minimum two elements out of all the elements which gave a remainder of 2 when divided by 3.\\n\\nThe case when sum % 3 == 2 is analogous to the case when sum % 3 == 1.\\nWe will either remove the minimum element which when divided by 3 gave remainder as 2, OR we will remove two elements which when divided by 3 gave a remainder 1.\\n\\nFor both the cases, we would choose the removal which would maximize the sum.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        \\n        int n = nums.length;\\n        int sum = 0;\\n        int min1 = Integer.MAX_VALUE; /* 1st min element with % 3 = 1 */\\n        int min2 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 1 */\\n        int min3 = Integer.MAX_VALUE; /* 1st min element with % 3 = 2 */\\n        int min4 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 2 */\\n        \\n        for(int i = 0; i < n; i++){\\n            int curr = nums[i];\\n            sum += nums[i];\\n            if(curr % 3 == 1){\\n                if(curr <= min1){\\n                    min2 = min1;\\n                    min1 = curr;\\n                }\\n                else if(curr < min2){\\n                    min2 = curr;\\n                }\\n            }\\n            else if(curr % 3 == 2){\\n                if(curr <= min3){\\n                    min4 = min3;\\n                    min3 = curr;\\n                }\\n                else if(curr < min4){\\n                    min4 = curr;\\n                }\\n            }\\n        }\\n        \\n        if(sum % 3 == 0) return sum;\\n        \\n        if(sum % 3 == 1){\\n            int min = Integer.MAX_VALUE;\\n            if(min1 != Integer.MAX_VALUE) min = Math.min(min, min1);\\n            if(min3 != Integer.MAX_VALUE && min4 != Integer.MAX_VALUE) min = Math.min(min, min3  + min4);\\n            return sum - min;\\n        }\\n        \\n        else{\\n            int min = Integer.MAX_VALUE;\\n            if(min3 != Integer.MAX_VALUE) min = Math.min(min, min3);\\n            if(min1 != Integer.MAX_VALUE && min2 != Integer.MAX_VALUE) min = Math.min(min, min1  + min2);\\n            return sum - min;\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        \\n        int n = nums.length;\\n        int sum = 0;\\n        int min1 = Integer.MAX_VALUE; /* 1st min element with % 3 = 1 */\\n        int min2 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 1 */\\n        int min3 = Integer.MAX_VALUE; /* 1st min element with % 3 = 2 */\\n        int min4 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 2 */\\n        \\n        for(int i = 0; i < n; i++){\\n            int curr = nums[i];\\n            sum += nums[i];\\n            if(curr % 3 == 1){\\n                if(curr <= min1){\\n                    min2 = min1;\\n                    min1 = curr;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 857968,
                "title": "c-o-n-solution-with-comment",
                "content": "Runtime: 88 ms, faster than 84.15% of C++ online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 25.2 MB, less than 74.19% of C++ online submissions for Greatest Sum Divisible by Three.\\n\\n**Math Solution:**\\n.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        // If we want to find greatest sum divisible by 3 then\\n        // total_sum can be of 3 type total_sum mod 3 = 0 or 1 or 2\\n        // If total_sum mod 3 is 0 then it is the result\\n        // If total_sum mod 3 is 1 then we need to remove the least_sum which has least_sum mod 3 = 1 \\n        // If total_sum mod 3 is 2 then we need to remove the least_sum which has least_sum mod 3 = 2\\n        \\n        // least_sum mod 3 = 1 value \\n        int rem1 = 10001;\\n        \\n        // least_sum mod 3 = 2 value\\n        int rem2 = 10001;\\n        \\n        // total_sum\\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // cumulative sum\\n            sum+=nums[i];\\n            \\n            // if current number nums[i] is 3 mod 1 then update the reminder1 value with min between num[i] and reminder1\\n            // Also we update the reminder2 value cause 2 reminder1 value can make 1 reminder2 value EX => 1 + 1 = 2\\n            if(nums[i]%3==1)rem2 = min(rem1+nums[i],rem2),rem1= min(rem1,nums[i]);\\n            \\n            // if current number nums[i] is 3 mod 2 then update the reminder2 value with min between num[i] and reminder2 \\n            // Also we update the reminder1 value cause 2 reminder2 value can make 1 reminder1 value EX => 2 + 2 = 4\\n            if(nums[i]%3==2)rem1 = min(rem2+nums[i],rem1),rem2= min(rem2,nums[i]);\\n        }\\n        \\n        // If total_sum %3 == 0 return total_sum\\n        // Otherwise return total_sum - reminder[total_sum%3]\\n        \\n        return (sum%3==0)?sum:((sum%3==1)?(sum-rem1):(sum-rem2));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        // If we want to find greatest sum divisible by 3 then\\n        // total_sum can be of 3 type total_sum mod 3 = 0 or 1 or 2\\n        // If total_sum mod 3 is 0 then it is the result\\n        // If total_sum mod 3 is 1 then we need to remove the least_sum which has least_sum mod 3 = 1 \\n        // If total_sum mod 3 is 2 then we need to remove the least_sum which has least_sum mod 3 = 2\\n        \\n        // least_sum mod 3 = 1 value \\n        int rem1 = 10001;\\n        \\n        // least_sum mod 3 = 2 value\\n        int rem2 = 10001;\\n        \\n        // total_sum\\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // cumulative sum\\n            sum+=nums[i];\\n            \\n            // if current number nums[i] is 3 mod 1 then update the reminder1 value with min between num[i] and reminder1\\n            // Also we update the reminder2 value cause 2 reminder1 value can make 1 reminder2 value EX => 1 + 1 = 2\\n            if(nums[i]%3==1)rem2 = min(rem1+nums[i],rem2),rem1= min(rem1,nums[i]);\\n            \\n            // if current number nums[i] is 3 mod 2 then update the reminder2 value with min between num[i] and reminder2 \\n            // Also we update the reminder1 value cause 2 reminder2 value can make 1 reminder1 value EX => 2 + 2 = 4\\n            if(nums[i]%3==2)rem1 = min(rem2+nums[i],rem1),rem2= min(rem2,nums[i]);\\n        }\\n        \\n        // If total_sum %3 == 0 return total_sum\\n        // Otherwise return total_sum - reminder[total_sum%3]\\n        \\n        return (sum%3==0)?sum:((sum%3==1)?(sum-rem1):(sum-rem2));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657894,
                "title": "java-clear-easy-solution",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nSince we need the greatest sum divisible by 3, we just need to get the sum of the entire array and subtract the smaller number that would remove the remainder if it is not divisible by 3. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int oneRemainder = 20000;\\n        int twoRemainder = 20000;\\n        \\n        for(int num : nums)\\n        {\\n            sum += num;\\n            \\n            if(num % 3 == 1)\\n            {\\n                twoRemainder = Math.min(twoRemainder, oneRemainder + num);\\n                oneRemainder = Math.min(oneRemainder, num); \\n            }\\n            \\n            if(num % 3 == 2)\\n            {\\n                oneRemainder = Math.min(oneRemainder, twoRemainder + num);\\n                twoRemainder = Math.min(twoRemainder, num);\\n                 \\n            }\\n        }\\n        \\n        if(sum % 3 == 0)\\n            return sum;\\n        \\n        if(sum % 3 == 1)\\n            return sum - oneRemainder;\\n        \\n        if(sum % 3 == 2)\\n            return sum - twoRemainder;\\n        \\n        return 0;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int oneRemainder = 20000;\\n        int twoRemainder = 20000;\\n        \\n        for(int num : nums)\\n        {\\n            sum += num;\\n            \\n            if(num % 3 == 1)\\n            {\\n                twoRemainder = Math.min(twoRemainder, oneRemainder + num);\\n                oneRemainder = Math.min(oneRemainder, num); \\n            }\\n            \\n            if(num % 3 == 2)\\n            {\\n                oneRemainder = Math.min(oneRemainder, twoRemainder + num);\\n                twoRemainder = Math.min(twoRemainder, num);\\n                 \\n            }\\n        }\\n        \\n        if(sum % 3 == 0)\\n            return sum;\\n        \\n        if(sum % 3 == 1)\\n            return sum - oneRemainder;\\n        \\n        if(sum % 3 == 2)\\n            return sum - twoRemainder;\\n        \\n        return 0;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431198,
                "title": "python-dp-solution-beast-100-time-and-100-space",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        f = [[0] * 3 for i in range(len(nums))]\\n        f[0][nums[0] % 3] = nums[0]\\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                include = f[i-1][(j + 3 - nums[i] %3) % 3] + nums[i]\\n                if include % 3 == j:\\n                    f[i][j] = max(f[i-1][j], include)\\n                else:\\n                    f[i][j] = f[i-1][j]\\n        return f[-1][0]\\n            \\n```\\n\\nf[i] is the biggest value can possibly have after ith iteration, with remainder 0,1,2.\\nFor example, the input is 3,6,5,1,8. The initial f would be \\n[[3,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0]].\\n After the first iteration, which the ith value is 6. The f would become\\n [[3,0,0],\\n [9,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0]].\\n After 2nd iteration, when ith value is 5, f becomes\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14], (14 is from 9 + 5)\\n [0,0,0],\\n [0,0,0]].\\n Then, ith value is 1\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14],\\n [15,10,14], (15 is from 14 + 1, 10 is from 9 + 1)\\n [0,0,0]].\\nAnd finally, ith value is 8\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14],\\n [15,10,14],\\n [18,22,23]]. (18 is from 10 + 8, 22 is from 14 + 8, 23 is from 15 + 8)\\n \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        f = [[0] * 3 for i in range(len(nums))]\\n        f[0][nums[0] % 3] = nums[0]\\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                include = f[i-1][(j + 3 - nums[i] %3) % 3] + nums[i]\\n                if include % 3 == j:\\n                    f[i][j] = max(f[i-1][j], include)\\n                else:\\n                    f[i][j] = f[i-1][j]\\n        return f[-1][0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431105,
                "title": "python-dp-solution",
                "content": "dp[r][i] = the maximal subset sum selected from nums[:i+1] which modulos 3 equals to r\\n```\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0 for _ in range(n)] for _ in range(3)]\\n        dp[nums[0] % 3][0] = nums[0]\\n        for i in range(1, n):\\n            for r in range(3):\\n                include = dp[(r - nums[i]) % 3][i-1] + nums[i]\\n                if include % 3 == r:\\n                    dp[r][i] = max(dp[r][i-1], include)\\n                else:\\n                    dp[r][i] = dp[r][i-1]\\n        return dp[0][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0 for _ in range(n)] for _ in range(3)]\\n        dp[nums[0] % 3][0] = nums[0]\\n        for i in range(1, n):\\n            for r in range(3):\\n                include = dp[(r - nums[i]) % 3][i-1] + nums[i]\\n                if include % 3 == r:\\n                    dp[r][i] = max(dp[r][i-1], include)\\n                else:\\n                    dp[r][i] = dp[r][i-1]\\n        return dp[0][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431073,
                "title": "java-two-o-n-solution-dp-one-pass-non-dp",
                "content": "**DP**\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] sum = new int[3];\\n        sum[1] = -1;\\n        sum[2] = -1;\\n        for (int num : nums) {\\n            int[] temp = new int[3];\\n            temp[0] = sum[0];\\n            temp[1] = sum[1];\\n            temp[2] = sum[2];\\n            \\n            if (temp[(3 - num%3)%3] != -1)\\n                sum[0] = Math.max(sum[0], temp[(3 - num%3)%3] + num);\\n            \\n            if (temp[(4 - num%3)%3] != -1)\\n                sum[1] = Math.max(sum[1], temp[(4 - num%3)%3] + num);\\n            \\n            if (temp[(5 - num%3)%3] != -1)\\n                sum[2] = Math.max(sum[2], temp[(5 - num%3)%3] + num);\\n        }\\n        return sum[0];\\n    }\\n}\\n```\\n\\n\\n**Non DP**\\nCalculate the sum of all numbers. During that iterate, find:\\n- smallest number that % 3 == 1\\n- second smallest number that % 3 == 1\\n- smallest number that % 3 == 2\\n- second smallest number that % 3 == 2\\n\\nif `sum % 3 == 0`, return it.\\n\\nif `sum % 3 == 1`, either subtract it by `smallest1` or `smallest2 + second_smallest2`, to get a number that % 3 == 0. Return number after subtraction.\\n\\nif `sum % 3 == 2`, either subtract it by `smallest2` or `smallest1 + second_smallest1`, to get a number that % 3 == 0. Return number after subtraction.\\n\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int f1 = 1_000_0000, s1 = 1_000_0000, f2 = 1_000_0000, s2 = 1_000_0000;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num < f1) {\\n                    s1 = f1;\\n                    f1 = num;\\n                } else if (num < s1) {\\n                    s1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num < f2) {\\n                    s2 = f2;\\n                    f2 = num;\\n                } else if (num < s2) {\\n                    s2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) return sum;\\n        \\n        if (sum % 3 == 1) {\\n            return sum - Math.min(f1, f2+s2);\\n        } else {\\n            return sum - Math.min(f2, f1+s1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] sum = new int[3];\\n        sum[1] = -1;\\n        sum[2] = -1;\\n        for (int num : nums) {\\n            int[] temp = new int[3];\\n            temp[0] = sum[0];\\n            temp[1] = sum[1];\\n            temp[2] = sum[2];\\n            \\n            if (temp[(3 - num%3)%3] != -1)\\n                sum[0] = Math.max(sum[0], temp[(3 - num%3)%3] + num);\\n            \\n            if (temp[(4 - num%3)%3] != -1)\\n                sum[1] = Math.max(sum[1], temp[(4 - num%3)%3] + num);\\n            \\n            if (temp[(5 - num%3)%3] != -1)\\n                sum[2] = Math.max(sum[2], temp[(5 - num%3)%3] + num);\\n        }\\n        return sum[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int f1 = 1_000_0000, s1 = 1_000_0000, f2 = 1_000_0000, s2 = 1_000_0000;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num < f1) {\\n                    s1 = f1;\\n                    f1 = num;\\n                } else if (num < s1) {\\n                    s1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num < f2) {\\n                    s2 = f2;\\n                    f2 = num;\\n                } else if (num < s2) {\\n                    s2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) return sum;\\n        \\n        if (sum % 3 == 1) {\\n            return sum - Math.min(f1, f2+s2);\\n        } else {\\n            return sum - Math.min(f2, f1+s1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322946,
                "title": "my-dp-solution-with-explaination",
                "content": "dp[i][j] -> what is the maximum sum that we can get using first i elements of nums and has remainder j\\n                        here we need sums divisible by 3 so j will be 0, 1, and 2\\nwhy do we need all 3 values ?\\nLets say we have the number 8 at ith index. 8 % 3 = 2\\n8 is not divisible by 3 and has remainder 2. so if we add 8 to the sum which has remainder 1\\nand these 2 will make a new sum which will be divisible by 3.\\nTo handle cases like this, we need all three states in our DP\\n\\nBasic idea is as follows:\\n\\nIf lets say we are at index i, and nums[i] % 3 = 2, then we do following things,\\n\\nthis number can be added with the dp[i-1][0] and this new sum will have remainder 2, so we will update dp[i][2]\\nthis number can be added with the dp[i-1][1] and this new sum will have remainder 0, so we will update dp[i][0]\\nthis number can be added with the dp[i-1][2] and this new sum will have remainder 1, so we will update dp[i][1]\\n\\nsame logic will apply when nums[i] % 3 = 0 and 1\\nif dp[i-1][j] is zero than the other two sums will be considered only if they are greater than 0\\n\\n```\\npublic int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0] % 3] = nums[0];\\n//        System.out.println(Arrays.toString(dp[0]));\\n        for (int i = 1; i < n; i++) {\\n            int num = nums[i];\\n            int mod = num % 3;\\n            if (mod == 0) {\\n                dp[i][0] = dp[i - 1][0] + num;\\n                dp[i][1] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n                dp[i][2] = dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0;\\n            } else if (mod == 1) {\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + num); // if we add this num with the sum(with mod 0) new sum will be mod 1\\n                dp[i][2] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n            } else {\\n                // mod 2\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + num);\\n            }\\n\\n//            System.out.println(Arrays.toString(dp[i]));\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0] % 3] = nums[0];\\n//        System.out.println(Arrays.toString(dp[0]));\\n        for (int i = 1; i < n; i++) {\\n            int num = nums[i];\\n            int mod = num % 3;\\n            if (mod == 0) {\\n                dp[i][0] = dp[i - 1][0] + num;\\n                dp[i][1] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n                dp[i][2] = dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0;\\n            } else if (mod == 1) {\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + num); // if we add this num with the sum(with mod 0) new sum will be mod 1\\n                dp[i][2] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n            } else {\\n                // mod 2\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + num);\\n            }\\n\\n//            System.out.println(Arrays.toString(dp[i]));\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520718,
                "title": "c-dp-approach-pick-or-not-pick-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n     int solve(int i, int curr_sum_rem,vector<int>& nums,vector<vector<int>>&dp){\\n    if(i>=nums.size()){\\n        if(curr_sum_rem==0){\\n            return 0;\\n        }\\n        return INT_MIN;\\n    }\\n    if(dp[i][curr_sum_rem]!=-1)\\n        return dp[i][curr_sum_rem];\\n    int pick =nums[i]+ solve(i+1,(curr_sum_rem+nums[i])%3,nums,dp);    \\n    int notpick =0+ solve(i+1,curr_sum_rem,nums,dp);  \\n    return dp[i][curr_sum_rem]=max(pick,notpick);\\n    \\n}\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,-1)); \\n        return solve(0,0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(int i, int curr_sum_rem,vector<int>& nums,vector<vector<int>>&dp){\\n    if(i>=nums.size()){\\n        if(curr_sum_rem==0){\\n            return 0;\\n        }\\n        return INT_MIN;\\n    }\\n    if(dp[i][curr_sum_rem]!=-1)\\n        return dp[i][curr_sum_rem];\\n    int pick =nums[i]+ solve(i+1,(curr_sum_rem+nums[i])%3,nums,dp);    \\n    int notpick =0+ solve(i+1,curr_sum_rem,nums,dp);  \\n    return dp[i][curr_sum_rem]=max(pick,notpick);\\n    \\n}\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,-1)); \\n        return solve(0,0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055939,
                "title": "java-simple-one-pass-easy-solution-with-explanation",
                "content": "1.First Sum all the elements\\n\\n2.If sum % 3 == 0 it is maximum;\\n\\n3.if sum % 3 == 1 we can delete smallest element which has mod1 or we can delete 2 smallest elements of mod 2.We delete which ever is smallest.\\n\\n4.eg -> [2,6,2,2,7] we can delete [7] beacuse it is smallest elemnt with mod 1 or [2,2] because mod = 4 % 3 = 1.We delele[2,2]\\n\\n5.Similarly if sum % 3 == 2 we can delete smallest element which has mod 2 or we can delete 2 smallest elements of mod 1 because .We delete which ever is smallest.\\n\\nUnoptimised code(runtime 26 ms)\\n_____________________________________\\n```\\nclass Solution {\\npublic int maxSumDivThree(int[] nums) {\\nint sum = 0;\\nList ones = new ArrayList<>();\\nList twos = new ArrayList<>();\\nfor(int i:nums){\\nsum+=i;\\nif(i % 3 == 1) {\\nones.add(i);\\n}\\nif(i % 3 == 2) twos.add(i);\\n}\\nCollections.sort(ones);\\nCollections.sort(twos);\\nif(sum % 3 == 0) return sum;\\n\\n    else if(sum % 3 == 2) {\\n        int min = 0;\\n        if(ones.size() >= 2){\\n           min = Math.min(twos.get(0),ones.get(0)+ones.get(1));\\n            return sum-min;\\n        }else{\\n            min = twos.get(0);\\n        }\\n        return sum - min;\\n    }else if( sum % 3 == 1){\\n        int min = 0;\\n        if(twos.size() >= 2){\\n            min = Math.min(ones.get(0),twos.get(0)+twos.get(1));\\n        }else{\\n            min = ones.get(0);\\n        }\\n        return sum - min;\\n    }\\n    return sum;\\n}\\n}\\n```\\n\\n\\nOptimised with variable for tracking smallest elemnts\\n------------------------------------\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int smallest_num_with_mod_1 = 10001;\\n        int second_smallest_num_with_mod_1 = 10002;\\n        int smallest_num_with_mod_2 = 10001;\\n        int second_smallest_num_with_mod_2 = 10002;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i % 3 == 1) {\\n                if(i<= smallest_num_with_mod_1){\\n                    int temp = smallest_num_with_mod_1;\\n                    smallest_num_with_mod_1 = i;\\n                    second_smallest_num_with_mod_1 = temp;\\n                }else if(i< second_smallest_num_with_mod_1){\\n                    second_smallest_num_with_mod_1 = i;\\n                }\\n            }\\n            if(i % 3 == 2) {\\n                if(i<= smallest_num_with_mod_2){\\n                    int temp = smallest_num_with_mod_2;\\n                    smallest_num_with_mod_2 = i;\\n                    second_smallest_num_with_mod_2 = temp;\\n                }else if(i< second_smallest_num_with_mod_2){\\n                    second_smallest_num_with_mod_2 = i;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        \\n        else if(sum % 3 == 2) {\\n            int min = Math.min(smallest_num_with_mod_2,smallest_num_with_mod_1+second_smallest_num_with_mod_1);\\n            return sum-min;\\n        }else if( sum % 3 == 1){\\n            int min = Math.min(smallest_num_with_mod_1,smallest_num_with_mod_2+second_smallest_num_with_mod_2);\\n            return sum - min;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic int maxSumDivThree(int[] nums) {\\nint sum = 0;\\nList ones = new ArrayList<>();\\nList twos = new ArrayList<>();\\nfor(int i:nums){\\nsum+=i;\\nif(i % 3 == 1) {\\nones.add(i);\\n}\\nif(i % 3 == 2) twos.add(i);\\n}\\nCollections.sort(ones);\\nCollections.sort(twos);\\nif(sum % 3 == 0) return sum;\\n\\n    else if(sum % 3 == 2) {\\n        int min = 0;\\n        if(ones.size() >= 2){\\n           min = Math.min(twos.get(0),ones.get(0)+ones.get(1));\\n            return sum-min;\\n        }else{\\n            min = twos.get(0);\\n        }\\n        return sum - min;\\n    }else if( sum % 3 == 1){\\n        int min = 0;\\n        if(twos.size() >= 2){\\n            min = Math.min(ones.get(0),twos.get(0)+twos.get(1));\\n        }else{\\n            min = ones.get(0);\\n        }\\n        return sum - min;\\n    }\\n    return sum;\\n}\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int smallest_num_with_mod_1 = 10001;\\n        int second_smallest_num_with_mod_1 = 10002;\\n        int smallest_num_with_mod_2 = 10001;\\n        int second_smallest_num_with_mod_2 = 10002;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i % 3 == 1) {\\n                if(i<= smallest_num_with_mod_1){\\n                    int temp = smallest_num_with_mod_1;\\n                    smallest_num_with_mod_1 = i;\\n                    second_smallest_num_with_mod_1 = temp;\\n                }else if(i< second_smallest_num_with_mod_1){\\n                    second_smallest_num_with_mod_1 = i;\\n                }\\n            }\\n            if(i % 3 == 2) {\\n                if(i<= smallest_num_with_mod_2){\\n                    int temp = smallest_num_with_mod_2;\\n                    smallest_num_with_mod_2 = i;\\n                    second_smallest_num_with_mod_2 = temp;\\n                }else if(i< second_smallest_num_with_mod_2){\\n                    second_smallest_num_with_mod_2 = i;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        \\n        else if(sum % 3 == 2) {\\n            int min = Math.min(smallest_num_with_mod_2,smallest_num_with_mod_1+second_smallest_num_with_mod_1);\\n            return sum-min;\\n        }else if( sum % 3 == 1){\\n            int min = Math.min(smallest_num_with_mod_1,smallest_num_with_mod_2+second_smallest_num_with_mod_2);\\n            return sum - min;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473354,
                "title": "c-o-1-space-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tvector<int> dp{0,0,0};\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\ttemp=dp;\\n\\t\\t\\t\\tfor(auto x:dp){\\n\\t\\t\\t\\t\\tint cur=x+nums[i];\\n\\t\\t\\t\\t\\ttemp[cur%3]=max(temp[cur%3],cur);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp=temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tvector<int> dp{0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 431070,
                "title": "python-dp-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [0, 0, 0]\\n        \\n        for n in nums:\\n            tmp_dp = dp[:]\\n            for i in range(len(dp)):\\n                c_sum = tmp_dp[i] + n\\n                dp[c_sum % 3] = max(dp[c_sum % 3], c_sum)\\n\\n\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [0, 0, 0]\\n        \\n        for n in nums:\\n            tmp_dp = dp[:]\\n            for i in range(len(dp)):\\n                c_sum = tmp_dp[i] + n\\n                dp[c_sum % 3] = max(dp[c_sum % 3], c_sum)\\n\\n\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246922,
                "title": "greatest-sum-divisible-by-three-cpp-o-n-greedy-100-fast-100-space",
                "content": "# ***Explaination***\\n\\n**f1**  stores the minimum possible value of a number whose mod to 3 is **1**.\\n**s1** stores the second minimum possible value of a number whose mod to 3 is **1**.\\n**ct1** stores the count of numbers whose mod to 3 is **1**.\\n\\nSimilarly,\\n\\n**f2**  stores the minimum possible value of a number whose mod to 3 is **2**.\\n**s2** stores the second minimum possible value of a number whose mod to 3 is **2**.\\n**ct2** stores the count of numbers whose mod to 3 is **2**.\\n\\n**res** stores the sum of the whole input array.\\n\\nNow, while traversing the loop, we will keep on updating the values for all the variables.\\n\\n***Now, the main logic starts here!***\\n\\nThere can be three possible values for this ***(ct1+ct2*2)%3*** which are clearly **0, 1, and 2**\\n\\n***CASE I: 0***\\nWe will simply return the **res** value because all the values sum upto such a value which is divisible by three.\\n\\n***CASE II: 1***\\nWe need to remove either **1 element** with ***value % 3 == 1*** or we can remove **2 elements** (if possible) with ***value % 3 == 2***  as this will lead to maximum valid sum possible. So, here ***f1, f2, s2*** comes into the picture.\\n\\n***CASE III: 2***\\nWe need to remove either **1 element** with ***value % 3 == 2*** or we can remove **2 elements** (if possible) with ***value % 3 == 1***  as this will lead to maximum valid sum possible. So, here ***f2, f1, s1*** comes into the picture.\\n\\nThis is how, I have solved the question. If you liked the solution, do upvote it.\\n\\n# ***Code***\\n\\n```\\nint maxSumDivThree(vector<int>& nums) {\\n\\tint f1=-1;\\n\\tint s1=-1;\\n\\tint f2=-1;\\n\\tint s2=-1;\\n\\tint ct1=0, ct2=0;\\n\\tint res = 0;\\n\\tint n = nums.size();\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint mod = nums[i]%3;\\n\\t\\tif(mod == 1) {\\n\\t\\t\\tif(f1 == -1 || nums[i] < nums[f1]) {\\n\\t\\t\\t\\ts1 = f1;\\n\\t\\t\\t\\tf1 = i;\\n\\t\\t\\t} else if(s1 == -1 || nums[i] < nums[s1]) {\\n\\t\\t\\t\\ts1 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct1 += 1;\\n\\t\\t} else if(mod == 2) {\\n\\t\\t\\tif(f2 == -1 || nums[i] < nums[f2]) {\\n\\t\\t\\t\\ts2 = f2;\\n\\t\\t\\t\\tf2 = i;\\n\\t\\t\\t} else if(s2 == -1 || nums[i] < nums[s2]) {\\n\\t\\t\\t\\ts2 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct2 += 1;\\n\\t\\t}\\n\\t\\tres += nums[i];\\n\\t}\\n\\n\\tint mod = (ct1+ct2*2)%3;\\n\\n\\tif(mod==1) {\\n\\t\\tint val2 = INT_MAX;\\n\\t\\tint val1 = nums[f1];\\n\\t\\tif(f2 != -1 && s2 != -1) val2 = nums[f2]+nums[s2];\\n\\t\\tif(val1>val2) res-=val2;\\n\\t\\telse res-=val1;\\n\\t} else if(mod==2) {\\n\\t\\tint val1 = INT_MAX, val2 = INT_MAX;\\n\\t\\tif(f1!=-1 and s1!=-1) {\\n\\t\\t\\tval1 = nums[f1]+nums[s1];\\n\\t\\t}\\n\\t\\tif(f2!=-1) val2 = nums[f2];\\n\\n\\t\\tif(val1<val2) res-=val1;\\n\\t\\telse res-=val2;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maxSumDivThree(vector<int>& nums) {\\n\\tint f1=-1;\\n\\tint s1=-1;\\n\\tint f2=-1;\\n\\tint s2=-1;\\n\\tint ct1=0, ct2=0;\\n\\tint res = 0;\\n\\tint n = nums.size();\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint mod = nums[i]%3;\\n\\t\\tif(mod == 1) {\\n\\t\\t\\tif(f1 == -1 || nums[i] < nums[f1]) {\\n\\t\\t\\t\\ts1 = f1;\\n\\t\\t\\t\\tf1 = i;\\n\\t\\t\\t} else if(s1 == -1 || nums[i] < nums[s1]) {\\n\\t\\t\\t\\ts1 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct1 += 1;\\n\\t\\t} else if(mod == 2) {\\n\\t\\t\\tif(f2 == -1 || nums[i] < nums[f2]) {\\n\\t\\t\\t\\ts2 = f2;\\n\\t\\t\\t\\tf2 = i;\\n\\t\\t\\t} else if(s2 == -1 || nums[i] < nums[s2]) {\\n\\t\\t\\t\\ts2 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct2 += 1;\\n\\t\\t}\\n\\t\\tres += nums[i];\\n\\t}\\n\\n\\tint mod = (ct1+ct2*2)%3;\\n\\n\\tif(mod==1) {\\n\\t\\tint val2 = INT_MAX;\\n\\t\\tint val1 = nums[f1];\\n\\t\\tif(f2 != -1 && s2 != -1) val2 = nums[f2]+nums[s2];\\n\\t\\tif(val1>val2) res-=val2;\\n\\t\\telse res-=val1;\\n\\t} else if(mod==2) {\\n\\t\\tint val1 = INT_MAX, val2 = INT_MAX;\\n\\t\\tif(f1!=-1 and s1!=-1) {\\n\\t\\t\\tval1 = nums[f1]+nums[s1];\\n\\t\\t}\\n\\t\\tif(f2!=-1) val2 = nums[f2];\\n\\n\\t\\tif(val1<val2) res-=val1;\\n\\t\\telse res-=val2;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065983,
                "title": "c-dp-general-approach-for-given-k-o-n-time-o-k-space",
                "content": "This is a general case for given K of a lineartime complexity and only K additional memory.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        return maxSumDivK(nums, 3);\\n    }\\n    \\n    int maxSumDivK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(k, INT_MIN);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int num = nums[i - 1], mod = nums[i - 1] % k;\\n            vector<int> newDp(k);\\n            \\n            for (int j = 0; j < k; j++) {\\n                newDp[j] = max(dp[j], dp[(j + mod) % k] + num);\\n            }\\n            \\n            dp = newDp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        return maxSumDivK(nums, 3);\\n    }\\n    \\n    int maxSumDivK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(k, INT_MIN);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int num = nums[i - 1], mod = nums[i - 1] % k;\\n            vector<int> newDp(k);\\n            \\n            for (int j = 0; j < k; j++) {\\n                newDp[j] = max(dp[j], dp[(j + mod) % k] + num);\\n            }\\n            \\n            dp = newDp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897819,
                "title": "python-no-trick-only-case-discussion-o-2n-99-9",
                "content": "The code looks long but actually very simple to read; just if/else discusions.\\n\\n- **get sum**\\n- **get residue**\\n- **find numbers to eliminate**\\n\\t- if residue==0:  no need to eliminate\\n\\t- if residue==1:  means there are either 1 One or 2 Two need to be eliminated\\n\\t- if residue==2:  means therea re either 1 Two or 2 One need to be eliminated\\n\\t- Terms explanation: \\n\\t\\t- \\'One\\': num,  s.t. num%3==1 \\n\\t\\t- \\'Two\\': num, s.t. num%3==2\\n\\t- find smallest number(s) to eliminate\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        residue = summ % 3\\n        \\n        if residue == 0: return summ\\n        \\n        elif residue == 1:   # one, two+two\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 2:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 1:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'): return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)     \\n            \\n        elif residue == 2:   # two, one+one\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 1:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 2:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'):return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)        \\n```\\n\\n**Upvote!** Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        residue = summ % 3\\n        \\n        if residue == 0: return summ\\n        \\n        elif residue == 1:   # one, two+two\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 2:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 1:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'): return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)     \\n            \\n        elif residue == 2:   # two, one+one\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 1:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 2:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'):return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 725974,
                "title": "easy-c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, 0));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i==0)\\n            {\\n                dp[0][nums[0]%3] = nums[0];\\n                continue;\\n            }\\n            for(int j=0; j<3; j++) dp[i][j] = dp[i-1][j];            \\n            for(int j=0; j<3; j++)\\n            {\\n                int t=nums[i]+dp[i-1][j];\\n                dp[i][t%3] = max(dp[i][t%3], t);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, 0));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i==0)\\n            {\\n                dp[0][nums[0]%3] = nums[0];\\n                continue;\\n            }\\n            for(int j=0; j<3; j++) dp[i][j] = dp[i-1][j];            \\n            for(int j=0; j<3; j++)\\n            {\\n                int t=nums[i]+dp[i-1][j];\\n                dp[i][t%3] = max(dp[i][t%3], t);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497058,
                "title": "python-3-four-lines-math-solution-no-dp-beats-92",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, N: List[int]) -> int:\\n        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)\\n        if S % 3 == 0: return S\\n        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)\\n        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, N: List[int]) -> int:\\n        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)\\n        if S % 3 == 0: return S\\n        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)\\n        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 2316748,
                "title": "c-easy-to-understand-memoization-iterative-dp",
                "content": "**Memoization (Top-Down DP)**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int fun(vector<int> &nums,int i,int sum,int rem,vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            if(sum%3==0)\\n            return 0;\\n            else\\n            return INT_MIN;\\n        }\\n        \\n        if(dp[i][rem]!=-1)\\n        return dp[i][rem];\\n        \\n        int ans=0;\\n        ans=nums[i]+fun(nums,i+1,sum+nums[i],(rem+nums[i]%3)%3,dp);\\n        ans=max(ans,fun(nums,i+1,sum,rem,dp));\\n        \\n        return dp[i][rem]=ans;\\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return fun(nums,0,0,0,dp);\\n    }\\n};\\n```\\n**Iterative DP(Bottom-Up DP)**\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum1,sum2,sum3;\\n            sum1=nums[i-1]+dp[i-1][0];\\n            sum2=nums[i-1]+dp[i-1][1];\\n            sum3=nums[i-1]+dp[i-1][2];\\n            dp[i]=dp[i-1];\\n            dp[i][sum1%3]=max(dp[i][sum1%3],sum1);\\n            dp[i][sum2%3]=max(dp[i][sum2%3],sum2);\\n            dp[i][sum3%3]=max(dp[i][sum3%3],sum3);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int fun(vector<int> &nums,int i,int sum,int rem,vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            if(sum%3==0)\\n            return 0;\\n            else\\n            return INT_MIN;\\n        }\\n        \\n        if(dp[i][rem]!=-1)\\n        return dp[i][rem];\\n        \\n        int ans=0;\\n        ans=nums[i]+fun(nums,i+1,sum+nums[i],(rem+nums[i]%3)%3,dp);\\n        ans=max(ans,fun(nums,i+1,sum,rem,dp));\\n        \\n        return dp[i][rem]=ans;\\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return fun(nums,0,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum1,sum2,sum3;\\n            sum1=nums[i-1]+dp[i-1][0];\\n            sum2=nums[i-1]+dp[i-1][1];\\n            sum3=nums[i-1]+dp[i-1][2];\\n            dp[i]=dp[i-1];\\n            dp[i][sum1%3]=max(dp[i][sum1%3],sum1);\\n            dp[i][sum2%3]=max(dp[i][sum2%3],sum2);\\n            dp[i][sum3%3]=max(dp[i][sum3%3],sum3);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995032,
                "title": "python3-math-sol-no-dp-or-recursion-t-m-97-84",
                "content": "```class Solution:\\n    def maxSumDivThree(self, nums: list[int]) -> int:\\n                    # Determine the list sum mod 3. if sum is \\n                    # is 0 mod 3, we are done\\n        n = sum(nums)               \\n        nDiv3 = n%3\\n        if nDiv3 == 0: return n\\n\\n                    # all terms 0 mod 3 can be ignored\\n                    # the remaining terms are 1 mod 3 and 2 mod 3\\n                    # the task reduces to finding the smallest term\\n                    # or sum of two terms that is equal to nDiv3 mod 3,\\n                    # so we find the least two terms each (if they exist)\\n                    # from those terms that are 1 mod 3 and 2 mod 3.\\n                    # We pad this list with zeros so len(terms) == 5\\n        nums1 = sorted([x for x in nums if x%3 == 1])[:2]\\n        nums2 = sorted([x for x in nums if x%3 == 2])[:2]\\n        terms = nums1 + nums2\\n        terms+= [0]*(5-len(terms))\\n                                    \\n                    # We iterate for the sums of all pairs in terms.\\n                    # Because there is at least one zero in terms, the  \\n                    # individual terms also will be in the collection of \\n                    # sums. Finding the least sum from the collection of  \\n                    # sums with the appropriate mod 3 and subtracting it \\n                    # from n gives us the answer.\\n        ans = []                    \\n        for i in range(5):\\n            for j in range(i+1,5):\\n                if (terms[i]+terms[j])%3 == nDiv3:\\n                    ans.append(terms[i]+terms[j])\\n          \\n        return n - min(ans)",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maxSumDivThree(self, nums: list[int]) -> int:\\n                    # Determine the list sum mod 3. if sum is \\n                    # is 0 mod 3, we are done\\n        n = sum(nums)               \\n        nDiv3 = n%3\\n        if nDiv3 == 0: return n\\n\\n                    # all terms 0 mod 3 can be ignored\\n                    # the remaining terms are 1 mod 3 and 2 mod 3\\n                    # the task reduces to finding the smallest term\\n                    # or sum of two terms that is equal to nDiv3 mod 3,\\n                    # so we find the least two terms each (if they exist)\\n                    # from those terms that are 1 mod 3 and 2 mod 3.\\n                    # We pad this list with zeros so len(terms) == 5\\n        nums1 = sorted([x for x in nums if x%3 == 1])[:2]\\n        nums2 = sorted([x for x in nums if x%3 == 2])[:2]\\n        terms = nums1 + nums2\\n        terms+= [0]*(5-len(terms))\\n                                    \\n                    # We iterate for the sums of all pairs in terms.\\n                    # Because there is at least one zero in terms, the  \\n                    # individual terms also will be in the collection of \\n                    # sums. Finding the least sum from the collection of  \\n                    # sums with the appropriate mod 3 and subtracting it \\n                    # from n gives us the answer.\\n        ans = []                    \\n        for i in range(5):\\n            for j in range(i+1,5):\\n                if (terms[i]+terms[j])%3 == nDiv3:\\n                    ans.append(terms[i]+terms[j])\\n          \\n        return n - min(ans)",
                "codeTag": "Java"
            },
            {
                "id": 1369213,
                "title": "c-dp-constant-space",
                "content": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>v(3);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i]+v[0],y=nums[i]+v[1],z=nums[i]+v[2];\\n            v[x%3]=max(x, v[x%3]); \\n            v[y%3]=max(y, v[y%3]); \\n            v[z%3]=max(z, v[z%3]); \\n        }\\n        return v[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>v(3);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i]+v[0],y=nums[i]+v[1],z=nums[i]+v[2];\\n            v[x%3]=max(x, v[x%3]); \\n            v[y%3]=max(y, v[y%3]); \\n            v[z%3]=max(z, v[z%3]); \\n        }\\n        return v[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028889,
                "title": "java-detailed-summary-of-3-one-pass-o-n-solutions-math-and-two-dp",
                "content": "## Solution 1: Math\\n\\n### Algorithm\\n\\nWe can divide all elements into 3 groups based on `nums[i]%3,` and if:\\n\\n- `totalSum % 3 == 1`: we need to either take out the smallest number from group 1 (`nums[i] % 3 == 1`) , or the two smallest numbers from group 2 (`nums[i] % 3 == 2`), whichever have a smaller total amount.\\n- `totalSum % 3 == 2`: take out the smallest number from group2, or the two smallest numbers from group 1.\\n\\n### Complexity\\n\\nTime: O(n), space O(1)\\n\\n### Caveat\\n\\nCan\\'t generalize 3 to k\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        long min1 = Integer.MAX_VALUE; // smallest of num with num % 3 == 1\\n        long secMin1 = Integer.MAX_VALUE; // second smallest num % 3 == 1\\n        long min2 = Integer.MAX_VALUE; // smallest num with num % 3 == 2\\n        long secMin2 = Integer.MAX_VALUE; // second smallest num % 3 == 2\\n        \\n        long sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num <= min1) {\\n                    secMin1 = min1;\\n                    min1 = num;\\n                } else if (num <= secMin1) {\\n                    secMin1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num <= min2) {\\n                    secMin2 = min2;\\n                    min2 = num;\\n                } else if (num <= secMin2) {\\n                    secMin2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) {\\n            return (int) sum;\\n        } \\n        long takeout = sum % 3 == 1 ? Math.min(min1, min2 + secMin2) : Math.min(min2, min1 + secMin1);\\n        return takeout < Integer.MAX_VALUE ? (int) (sum - takeout) : 0;\\n        \\n    }\\n}\\n```\\n\\n## Solution 2: DP\\n\\n### Intuition\\n\\nFor `nums[i]`, to get max possible subset sum in `nums[0...i]` with `sum % 3 == 0`, we can choose to:\\n\\n- include `nums[i]` in the subset, then we need to find max subset sum in `nums[0...i-1]` with `(sum + nums[i]) % 3 == 0`, i.e. `sum % 3 == (3 - nums[i] % 3) % 3`\\n- not include `nums[i]`, then we need to find max subset sum in `nums[0...i-1]` with `sum % 3 == 0`\\n\\nSo problem with size `i` depends on problem with size `i-1` with other remainder `1` or `2` as well.\\n\\n### State\\n\\n`dp[i][j]` = max possible subset sum in first `i` elements of nums with `sum % 3 == j`\\n\\n### State transition\\n\\n`dp[i][j] = max(dp[i-1][j], dp[i-1][x] + nums[i-1])`, \\n\\nwhere `x = (j - nums[i-1] % 3 + 3) % 3` is actually  `Math.floorMod(j - nums[i-1] % 3, 3)`, e.g. `x = 0, 2, 1` for `nums[i-1] = 0, 1, 2`. Note `floorMod` preserves the sign of the divisor.\\n\\n### Base state\\n\\n`dp[0][0] = 0`, `dp[0][1] = -Inf`, `dp[0][2] = -Inf`, where `-Inf` represents impossible states.\\n\\n### Answer\\n\\n`dp[n][0]`\\n\\n### Complexity\\n\\nTime `O(n)`, space `O(n)`, can be optimized to `O(1)`\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[1] = Integer.MIN_VALUE;\\n        dp[2] = Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int k = 0; k < 3; k++) {\\n                int x = (k - num % 3 + 3) % 3;\\n                dp[k] = Math.max(prev[k], num + prev[x]);\\n            }\\n        }\\n        return dp[0] < 0 ? 0 : dp[0];\\n    }\\n}\\n```\\n\\n## Solution 3: Another DP\\n\\n\\u26A0\\uFE0F  This DP approach is harder to reason about, since when updating the states, the second index is NOT directly specified in the for-loop, instead, it depends on the previous state\\'s value. As a result, for a given outer loop index `i` the state `dp[i][j]` may get updated multiple times for some `j`, and not updated at all for some other `j`.\\n\\n### State\\n\\n`dp[i][j]` is the max possible subset sum of the first `i` elements in `nums` with `sum % 3 == j`. **If not possible, `dp[i][j] = 0`. (previously we use `dp[i][j] = -Inf` for impossible state).** \\n\\n### State transition\\n\\nFor each previous max subset sum with modulus `j`, try to add current number `num = nums[i-1]` to it and compare with not adding it, i.e.\\n\\n```java\\ndp[i][(s + num) % 3] = \\n\\tmax{dp[i-1][(s + num) % 3], s + num | s = dp[i-1][j],  0 <= j < 3}\\n```\\n\\n\\uD83D\\uDD25\\uFE0F Why the left side can\\'t be `dp[i][j + num) % 3`?\\n\\nIt is true that `(s + num) % 3 = (dp[i-1][j] + num) % 3` should be equivalent to `(j + num) % 3`, **if we assume `dp[i-1][j] % 3 == j`.** \\n\\nHowever, that assumption does NOT hold given that `dp[i-1][j]` could be 0.\\n\\n\\uD83D\\uDD25\\uFE0F `s = dp[i-1][j], 0 <= j < 3` can be the SAME for multiple `j`, i.e. we may update the same `dp[i][x]` multiple times.  This is very important in the implementation.\\n\\n### Base states\\n\\n`dp[0][j] = 0`\\n\\n### Answer\\n\\n`dp[n][0]`\\n\\n### Complexity\\n\\nTime `O(n)`, space `O(n)`, can be optimized to `O(1)`\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n    \\n        for (int num: nums) {\\n            // why can\\'t iterate over remainder k=0,1,2? It\\'s because prevSum[k] % 3 == k is not always true, e.g. prevSum[1] can be 0!!!\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int s: prev) { \\n                // why not dp[(s + num) % 3] = max(prev[(s + num) % 3], s + num) ? \\n                // This is because dp[x] can be updated multiple times!\\n                // e.g. prev = [3 0 0], num = 5, then dp[2] will be updated 3 times with 8, 5, 5\\n                dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num); \\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        long min1 = Integer.MAX_VALUE; // smallest of num with num % 3 == 1\\n        long secMin1 = Integer.MAX_VALUE; // second smallest num % 3 == 1\\n        long min2 = Integer.MAX_VALUE; // smallest num with num % 3 == 2\\n        long secMin2 = Integer.MAX_VALUE; // second smallest num % 3 == 2\\n        \\n        long sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num <= min1) {\\n                    secMin1 = min1;\\n                    min1 = num;\\n                } else if (num <= secMin1) {\\n                    secMin1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num <= min2) {\\n                    secMin2 = min2;\\n                    min2 = num;\\n                } else if (num <= secMin2) {\\n                    secMin2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) {\\n            return (int) sum;\\n        } \\n        long takeout = sum % 3 == 1 ? Math.min(min1, min2 + secMin2) : Math.min(min2, min1 + secMin1);\\n        return takeout < Integer.MAX_VALUE ? (int) (sum - takeout) : 0;\\n        \\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[1] = Integer.MIN_VALUE;\\n        dp[2] = Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int k = 0; k < 3; k++) {\\n                int x = (k - num % 3 + 3) % 3;\\n                dp[k] = Math.max(prev[k], num + prev[x]);\\n            }\\n        }\\n        return dp[0] < 0 ? 0 : dp[0];\\n    }\\n}\\n```\n```java\\ndp[i][(s + num) % 3] = \\n\\tmax{dp[i-1][(s + num) % 3], s + num | s = dp[i-1][j],  0 <= j < 3}\\n```\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n    \\n        for (int num: nums) {\\n            // why can\\'t iterate over remainder k=0,1,2? It\\'s because prevSum[k] % 3 == k is not always true, e.g. prevSum[1] can be 0!!!\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int s: prev) { \\n                // why not dp[(s + num) % 3] = max(prev[(s + num) % 3], s + num) ? \\n                // This is because dp[x] can be updated multiple times!\\n                // e.g. prev = [3 0 0], num = 5, then dp[2] will be updated 3 times with 8, 5, 5\\n                dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num); \\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957683,
                "title": "c-dp",
                "content": "### [\\u53C2\\u8003](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/559999/Come-here-if-you-can\\'t-seem-to-get-it-(Full-Explanation-%2B-uncondensed-code))\\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        vector<vector<int>> dp(N+1, vector<int>(3, 0));\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = INT_MIN;\\n        \\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (nums[i-1] % 3 == 0)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }\\n            else if (nums[i-1] % 3 == 1)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            }\\n            else\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[N][0];\\n    }\\n};\\n```\\n\\n### [\\u53C2\\u8003](https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1262-greatest-sum-divisible-by-three/)\\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (const auto& num : nums)\\n        {\\n            vector<int> tmp (dp);\\n            \\n            for (const auto & s : tmp)\\n            {\\n                dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        vector<vector<int>> dp(N+1, vector<int>(3, 0));\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = INT_MIN;\\n        \\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (nums[i-1] % 3 == 0)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }\\n            else if (nums[i-1] % 3 == 1)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            }\\n            else\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[N][0];\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (const auto& num : nums)\\n        {\\n            vector<int> tmp (dp);\\n            \\n            for (const auto & s : tmp)\\n            {\\n                dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699057,
                "title": "very-easy-to-understand-python-code-time-o-n-space-o-1",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0,0,0]\\n        for i in nums:\\n            v0 = dp[0]+i\\n            v1 = dp[1]+i\\n            v2 = dp[2]+i\\n            dp[v0%3] = max(dp[v0%3],v0)\\n            dp[v1%3] = max(dp[v1%3],v1)\\n            dp[v2%3] = max(dp[v2%3],v2)\\n        return dp[0]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0,0,0]\\n        for i in nums:\\n            v0 = dp[0]+i\\n            v1 = dp[1]+i\\n            v2 = dp[2]+i\\n            dp[v0%3] = max(dp[v0%3],v0)\\n            dp[v1%3] = max(dp[v1%3],v1)\\n            dp[v2%3] = max(dp[v2%3],v2)\\n        return dp[0]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 686960,
                "title": "simple-c-solution-with-explanation",
                "content": "Sum array stores the max Sum that give remainder 0,1,2 respectively when divided by 3.\\nInitially sum is (0,0,0).\\nAt any point when a new number is processed, add it to all individual elements of Sum array(stored in the temp 2D array) and then check whether the new generated numbers have greater sum than the previous elements in Sum array.\\ne.g - Suppose Sum array is (3,16,11) an the next number to process is 7. The new temporary sums are (10,23,18). Thus Sum now becomes (max(3,18),max(16,10),max(11,23)) = (18,16,23).\\nFinally sum[0] has the max sum which we need.\\n```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> sum(3,0);\\n        vector<vector<int>> temp;\\n        vector<int> row;\\n        //Sum is a an array storing max sums  mod3 = 0,1,2\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<3;j++){\\n                row.push_back((sum[j] + nums[i])%3);\\n                row.push_back(sum[j] + nums[i]);\\n                temp.push_back(row);\\n                row.clear();\\n            }\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\t//If we get 2 or more numbers with same remainder mod 3, then we take the highest among the two. \\n\\t\\t\\t//Thus sort temp and traverse from end in temp.\\n            for(int j=2;j>=0;j--){\\n                sum[temp[j][0]] = max(sum[temp[j][0]],temp[j][1]);    \\n            }\\n            temp.clear();\\n        }\\n        return sum[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> sum(3,0);\\n        vector<vector<int>> temp;\\n        vector<int> row;\\n        //Sum is a an array storing max sums  mod3 = 0,1,2\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<3;j++){\\n                row.push_back((sum[j] + nums[i])%3);\\n                row.push_back(sum[j] + nums[i]);\\n                temp.push_back(row);\\n                row.clear();\\n            }\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\t//If we get 2 or more numbers with same remainder mod 3, then we take the highest among the two. \\n\\t\\t\\t//Thus sort temp and traverse from end in temp.\\n            for(int j=2;j>=0;j--){\\n                sum[temp[j][0]] = max(sum[temp[j][0]],temp[j][1]);    \\n            }\\n            temp.clear();\\n        }\\n        return sum[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575977,
                "title": "c-dp",
                "content": "Use dp to store max sum\\'s with remainder 0, 1 and 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int>dp = {0, 0, 0};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int>ndp = dp;\\n            for (int j =  0; j < 3; j++) {\\n                int x = dp[j] + nums[i];\\n                ndp[x%3] = max(ndp[x%3], x);\\n            }\\n            dp = ndp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int>dp = {0, 0, 0};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int>ndp = dp;\\n            for (int j =  0; j < 3; j++) {\\n                int x = dp[j] + nums[i];\\n                ndp[x%3] = max(ndp[x%3], x);\\n            }\\n            dp = ndp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435540,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[40001][3];\\n    int f(int i,int sum,vector<int> &v){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        int ans=0;\\n        if((sum+f(i+1,sum,v))%3==0){\\n            ans=f(i+1,sum,v);\\n        }\\n        if((sum+v[i]+f(i+1,(sum+v[i])%3,v))%3==0){\\n            ans=max(ans,v[i]+f(i+1,(sum+v[i])%3,v));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n        \\n    }\\n    \\n    int maxSumDivThree(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[40001][3];\\n    int f(int i,int sum,vector<int> &v){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        int ans=0;\\n        if((sum+f(i+1,sum,v))%3==0){\\n            ans=f(i+1,sum,v);\\n        }\\n        if((sum+v[i]+f(i+1,(sum+v[i])%3,v))%3==0){\\n            ans=max(ans,v[i]+f(i+1,(sum+v[i])%3,v));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n        \\n    }\\n    \\n    int maxSumDivThree(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431633,
                "title": "state-machine-java-o-n-o-1",
                "content": "There are 3 states in this problem. \\n1. sum%3 == 0\\n2. sum%3 == 1\\n3. sum%3 == 2\\nAnd the relationship and transfer method of these three states can be shown as follows:\\n![image](https://assets.leetcode.com/users/luyeyun/image_1574017216.png)\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int zero = 0, one = -1, two = -1;\\n        for(int n:nums){\\n            if(n%3==0){\\n                zero += n;\\n                if(one!=-1) one += n;\\n                if(two!=-1) two += n;\\n            }\\n            else if(n%3==1){\\n                int tmp_zero = zero;\\n                if(two!=-1)\\n                    zero = Math.max(zero,two+n);\\n                if(one!=-1)\\n                    two = Math.max(two,one+n);\\n                one = Math.max(one,tmp_zero+n);\\n            }\\n            else{ // n%3==2\\n                int tmp_zero = zero;\\n                if(one!=-1)\\n                    zero = Math.max(zero,one+n);\\n                if(two!=-1)\\n                    one = Math.max(one,two+n);\\n                two = Math.max(two,tmp_zero+n);\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int zero = 0, one = -1, two = -1;\\n        for(int n:nums){\\n            if(n%3==0){\\n                zero += n;\\n                if(one!=-1) one += n;\\n                if(two!=-1) two += n;\\n            }\\n            else if(n%3==1){\\n                int tmp_zero = zero;\\n                if(two!=-1)\\n                    zero = Math.max(zero,two+n);\\n                if(one!=-1)\\n                    two = Math.max(two,one+n);\\n                one = Math.max(one,tmp_zero+n);\\n            }\\n            else{ // n%3==2\\n                int tmp_zero = zero;\\n                if(one!=-1)\\n                    zero = Math.max(zero,one+n);\\n                if(two!=-1)\\n                    one = Math.max(one,two+n);\\n                two = Math.max(two,tmp_zero+n);\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431088,
                "title": "c-dp-solution",
                "content": "```f[i][j]``` denotes the maximum subset sum select from nums[0] - nums[i] which modulos 3 equal to j.\\n\\nObviously, at each step, we can choose whether to pick up the current number or not. So, ```f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j])```\\n\\n```C++\\nclass Solution {\\npublic:\\n  int maxSumDivThree(vector<int>& nums) {\\n    vector<vector<int>> f(nums.size() + 1, vector<int>(3, 0));\\n    int k = 3;\\n    for (int i = 1; i <= nums.size(); i++)\\n      for (int j = 0; j < k; j++) {\\n        int x = (j + k - (nums[i - 1] % k)) % k;\\n        f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j]);\\n      }\\n    return f[nums.size()][0];\\n  }\\n};\\n```\\n\\nreference: https://stackoverflow.com/questions/13511885/finding-greatest-sum-of-elements-of-array-which-is-divisible-by-a-given-number",
                "solutionTags": [],
                "code": "```f[i][j]```\n```f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j])```\n```C++\\nclass Solution {\\npublic:\\n  int maxSumDivThree(vector<int>& nums) {\\n    vector<vector<int>> f(nums.size() + 1, vector<int>(3, 0));\\n    int k = 3;\\n    for (int i = 1; i <= nums.size(); i++)\\n      for (int j = 0; j < k; j++) {\\n        int x = (j + k - (nums[i - 1] % k)) % k;\\n        f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j]);\\n      }\\n    return f[nums.size()][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675863,
                "title": "time-o-n-spaceo-1-most-optimezed-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a = INT_MAX,b = INT_MAX,c=INT_MAX,d=INT_MAX,s=0;\\n        for(auto &i: nums){\\n            s += i;\\n            if(i%3==1){\\n                if(i<a){\\n                    b= a;\\n                    a = i;\\n                }else if(i<b){\\n                    b = i;\\n                }\\n            }else if(i%3==2){\\n                if(i<c){\\n                    d = c;\\n                    c = i;\\n                }else if(i<d){\\n                    d = i;\\n                }\\n            }\\n        }\\n        if(s%3==0)return s;\\n        if(s%3 == 1){\\n            int ans = 0;\\n            if(a != INT_MAX){\\n                ans = s-a;\\n            }\\n            if(d != INT_MAX && c != INT_MAX)ans = max(ans,s-d-c);\\n            return ans;\\n        }\\n        int ans = 0;\\n        if(c != INT_MAX)ans =  s-c;\\n        if(a != INT_MAX && b != INT_MAX)ans = max(ans, s-a-b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a = INT_MAX,b = INT_MAX,c=INT_MAX,d=INT_MAX,s=0;\\n        for(auto &i: nums){\\n            s += i;\\n            if(i%3==1){\\n                if(i<a){\\n                    b= a;\\n                    a = i;\\n                }else if(i<b){\\n                    b = i;\\n                }\\n            }else if(i%3==2){\\n                if(i<c){\\n                    d = c;\\n                    c = i;\\n                }else if(i<d){\\n                    d = i;\\n                }\\n            }\\n        }\\n        if(s%3==0)return s;\\n        if(s%3 == 1){\\n            int ans = 0;\\n            if(a != INT_MAX){\\n                ans = s-a;\\n            }\\n            if(d != INT_MAX && c != INT_MAX)ans = max(ans,s-d-c);\\n            return ans;\\n        }\\n        int ans = 0;\\n        if(c != INT_MAX)ans =  s-c;\\n        if(a != INT_MAX && b != INT_MAX)ans = max(ans, s-a-b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461570,
                "title": "o-n-math-based-c-solution-with-constant-space-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the total sum of the array. \\n\\n### If sum % 3 == 0: \\nreturn the sum\\n\\n### If sum % 3 == 1:\\nThe answer will be\\n* (sum - smallest number whose remainder is 1 when divided by 3)\\n\\n* (sum - first smallest number whose remainder is 2 - second smallest number whose remainder is 2)\\n\\n* Return the maximum of these two\\n\\n### If sum % 3 == 2:\\nThe answer will be\\n\\n* (sum - smallest number whose remainder is 2 when divided by 3)\\n\\n* (sum - first smallest number whose remainder is 1 - second smallest number whose remainder is 1)\\n\\n* Return the maximum of these two\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through the array to find the total sum. When iterating through the array also find the first and second smallest numbers whose remainder is 1 and 2.\\n\\nFor sum % 3 == 1 and sum % 3 == 2 before returning check if the necessary first and second min are set\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n            \\n        int num11 = INT_MAX;\\n        int num12 = INT_MAX;\\n        int num21 = INT_MAX;\\n        int num22 = INT_MAX;\\n\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 3 == 1)\\n            {\\n                if(nums[i] < num11)\\n                {\\n                    num12 = num11;\\n                    num11 = nums[i];\\n                }\\n                else if(nums[i] < num12)\\n                {\\n                    num12 = nums[i];\\n                }\\n            }\\n            else if(nums[i] % 3 == 2)\\n            {\\n                if(nums[i] < num21)\\n                {\\n                    num22 = num21;\\n                    num21 = nums[i];\\n                }\\n                else if(nums[i] < num22)\\n                {\\n                    num22 = nums[i];\\n                }\\n\\n            }\\n            sum += nums[i];\\n        }\\n\\n        if(sum % 3 == 0)\\n        {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1)\\n        {   \\n            if(num11 == INT_MAX) // If num11 is not set\\n            {\\n                return sum - num21 - num22;\\n            }\\n            else if(num21 == INT_MAX || num22 == INT_MAX)\\n            {\\n                return sum - num11;\\n            }\\n\\n            return max(sum - num11, sum - num21 - num22); \\n        }\\n        \\n        if(num21 == INT_MAX) // If num21 is not set\\n        {\\n            return sum - num11 - num12;\\n        }\\n        else if(num11 == INT_MAX || num12 == INT_MAX)\\n        {\\n            return sum - num21;\\n        }\\n        return max(sum - num21, sum - num11 - num12);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n            \\n        int num11 = INT_MAX;\\n        int num12 = INT_MAX;\\n        int num21 = INT_MAX;\\n        int num22 = INT_MAX;\\n\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 3 == 1)\\n            {\\n                if(nums[i] < num11)\\n                {\\n                    num12 = num11;\\n                    num11 = nums[i];\\n                }\\n                else if(nums[i] < num12)\\n                {\\n                    num12 = nums[i];\\n                }\\n            }\\n            else if(nums[i] % 3 == 2)\\n            {\\n                if(nums[i] < num21)\\n                {\\n                    num22 = num21;\\n                    num21 = nums[i];\\n                }\\n                else if(nums[i] < num22)\\n                {\\n                    num22 = nums[i];\\n                }\\n\\n            }\\n            sum += nums[i];\\n        }\\n\\n        if(sum % 3 == 0)\\n        {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1)\\n        {   \\n            if(num11 == INT_MAX) // If num11 is not set\\n            {\\n                return sum - num21 - num22;\\n            }\\n            else if(num21 == INT_MAX || num22 == INT_MAX)\\n            {\\n                return sum - num11;\\n            }\\n\\n            return max(sum - num11, sum - num21 - num22); \\n        }\\n        \\n        if(num21 == INT_MAX) // If num21 is not set\\n        {\\n            return sum - num11 - num12;\\n        }\\n        else if(num11 == INT_MAX || num12 == INT_MAX)\\n        {\\n            return sum - num21;\\n        }\\n        return max(sum - num21, sum - num11 - num12);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340843,
                "title": "c-dp-memoization-tabulation",
                "content": "# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n        return max(0, solve(nums, dp, n-1, 0));\\n    }\\n\\n    int solve(vector<int>& nums, vector<vector<int>>& dp, int ind, int rem){\\n        if(ind < 0){\\n            if(rem == 0)    return 0;\\n            return -1e9;\\n        }\\n\\n        if(dp[ind][rem] != -1)   return dp[ind][rem];\\n\\n        int pick = nums[ind] + solve(nums, dp, ind-1, (rem + nums[ind])%3);\\n        int notPick = solve(nums, dp, ind-1, rem);\\n\\n        return dp[ind][rem] = max(pick, notPick);\\n    }\\n};\\n```\\n\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(3, 0));\\n        dp[0][1] = -1e9;\\n        dp[0][2] = -1e9;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int rem = 2 ; rem >= 0 ; rem--){\\n                int pick = nums[i-1] + dp[i-1][(rem+nums[i-1])%3];\\n                int notPick = dp[i-1][rem];\\n                dp[i][rem] = max(pick, notPick);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n        return max(0, solve(nums, dp, n-1, 0));\\n    }\\n\\n    int solve(vector<int>& nums, vector<vector<int>>& dp, int ind, int rem){\\n        if(ind < 0){\\n            if(rem == 0)    return 0;\\n            return -1e9;\\n        }\\n\\n        if(dp[ind][rem] != -1)   return dp[ind][rem];\\n\\n        int pick = nums[ind] + solve(nums, dp, ind-1, (rem + nums[ind])%3);\\n        int notPick = solve(nums, dp, ind-1, rem);\\n\\n        return dp[ind][rem] = max(pick, notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(3, 0));\\n        dp[0][1] = -1e9;\\n        dp[0][2] = -1e9;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int rem = 2 ; rem >= 0 ; rem--){\\n                int pick = nums[i-1] + dp[i-1][(rem+nums[i-1])%3];\\n                int notPick = dp[i-1][rem];\\n                dp[i][rem] = max(pick, notPick);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140595,
                "title": "java-easy-solution-memoization",
                "content": "```\\nclass Solution {\\n    public static int [][] t;\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        t=new int[n+1][3];\\n        for(int [] i:t) Arrays.fill(i,-1);\\n        return solve(nums,0,0);\\n    }\\n    public static int solve(int [] nums,int i,int curr){\\n        if(i>=nums.length){\\n            if(curr==0) return 0;\\n            return -10000;\\n        }\\n        if(t[i][curr]!=-1) return t[i][curr];\\n        int take=nums[i]+solve(nums,i+1,(curr+nums[i])%3);\\n        int left=solve(nums,i+1,curr);\\n        return t[i][curr]=Math.max(take,left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public static int [][] t;\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        t=new int[n+1][3];\\n        for(int [] i:t) Arrays.fill(i,-1);\\n        return solve(nums,0,0);\\n    }\\n    public static int solve(int [] nums,int i,int curr){\\n        if(i>=nums.length){\\n            if(curr==0) return 0;\\n            return -10000;\\n        }\\n        if(t[i][curr]!=-1) return t[i][curr];\\n        int take=nums[i]+solve(nums,i+1,(curr+nums[i])%3);\\n        int left=solve(nums,i+1,curr);\\n        return t[i][curr]=Math.max(take,left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562337,
                "title": "c-most-clean-code-greedy-priority-queue",
                "content": "Hello Guys, After First Reading the question I tried to solve it by using greedy approach though dynamic programming can also be applied but that would result in higher time complexity I felt...\\nInitially my greedy solution was able to pass 39/41 test cases....\\nThen I tried to analyse where my solution was going wrong. So after analysis I came to conclusion that if total sum that you get by adding all numbers in the given vector gives you a remainder 1 let say then in that case you can either remove 1 element from the vector that gives the remainder as 1 or you can remove 2 element from vector that gives remainder as 2.\\nSimilarly if the total sum % 3 == 2 then in that case either you need to remove a number from the vector that gives remainder as 2 or you need to remove 2 numbers that gives remainder as 1.\\nSo then we need to find out removing elements in which case leaves you with maximum sum.\\nSince sum will always be more when small number is removed from it. Therefore i used priority queue to get minimum values to store numbers with remiander 1 and 2 respectively.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        priority_queue<int,vector<int>,greater<int>>pq1;\\n        priority_queue<int,vector<int>,greater<int>>pq2;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            \\n            sum+=nums[i];\\n            if(nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            if(nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n        if(sum%3 == 1)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq1.size() > 0)\\n            {\\n                sum1 = sum - pq1.top();\\n            }\\n            if(pq2.size() >= 2)\\n            {\\n                sum2 = sum - pq2.top();\\n                pq2.pop();\\n                sum2 = sum2 - pq2.top();\\n            }\\n            return(max(sum1,sum2));\\n        }\\n        else if(sum%3 == 2)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq2.size() > 0)\\n            {\\n                sum1 = sum - pq2.top();\\n            }\\n            if(pq1.size() >= 2)\\n            {\\n                sum2 = sum - pq1.top();\\n                pq1.pop();\\n                sum2 = sum2 - pq1.top();\\n                \\n            }\\n            return(max(sum1,sum2));\\n        }\\n        return(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        priority_queue<int,vector<int>,greater<int>>pq1;\\n        priority_queue<int,vector<int>,greater<int>>pq2;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            \\n            sum+=nums[i];\\n            if(nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            if(nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n        if(sum%3 == 1)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq1.size() > 0)\\n            {\\n                sum1 = sum - pq1.top();\\n            }\\n            if(pq2.size() >= 2)\\n            {\\n                sum2 = sum - pq2.top();\\n                pq2.pop();\\n                sum2 = sum2 - pq2.top();\\n            }\\n            return(max(sum1,sum2));\\n        }\\n        else if(sum%3 == 2)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq2.size() > 0)\\n            {\\n                sum1 = sum - pq2.top();\\n            }\\n            if(pq1.size() >= 2)\\n            {\\n                sum2 = sum - pq1.top();\\n                pq1.pop();\\n                sum2 = sum2 - pq1.top();\\n                \\n            }\\n            return(max(sum1,sum2));\\n        }\\n        return(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626586,
                "title": "simple-c-o-n-solution-using-constant-space",
                "content": "/*\\nHere I have used a simple concepts of division, if remainder is subtracted from the dividend the divisor will completely divide the dividend.\\neg:\\n4%3=1\\n4-1=3\\n3%3=0\\nlikewise,\\n5%3=2\\n5-2=3\\n3%3=0\\n\\nAccording to the above mentioned approach, we traverse the array and find the sum of all the elements of the array, along with keeping the track of, minimum element that gives 1 and minimum number that gives 2 as remainder.\\n\\nAt the end, if;\\n\\nsum%3=0;  return sum\\nsum%3=1; return (sum-minimum element minimum element that gives 1 as remainder).\\nsum%3=2; return (sum-minimum element minimum element that gives 1 as remainder).\\n\\nThus maximum sum divisible by 3 is returned.\\n\\n*/\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum=0,sum1=20000,sum2=20000;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]%3==1){\\n                sum2=min(sum2,nums[i]+sum1);\\n                sum1=min(sum1,nums[i]);\\n                \\n            }\\n            else if(nums[i]%3==2){\\n                sum1=min(sum1,sum2+nums[i]);\\n                sum2=min(sum2,nums[i]);\\n            }\\n        }\\n        \\n        switch(sum%3){\\n            case 0:{\\n                break;\\n            }\\n            case 1:{\\n                return (sum-sum1);\\n                //break;\\n                }\\n            case 2:{\\n                return (sum-sum2);\\n                //break;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum=0,sum1=20000,sum2=20000;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]%3==1){\\n                sum2=min(sum2,nums[i]+sum1);\\n                sum1=min(sum1,nums[i]);\\n                \\n            }\\n            else if(nums[i]%3==2){\\n                sum1=min(sum1,sum2+nums[i]);\\n                sum2=min(sum2,nums[i]);\\n            }\\n        }\\n        \\n        switch(sum%3){\\n            case 0:{\\n                break;\\n            }\\n            case 1:{\\n                return (sum-sum1);\\n                //break;\\n                }\\n            case 2:{\\n                return (sum-sum2);\\n                //break;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382710,
                "title": "python-heap-solution",
                "content": "That\\'s how I solved it. I didn\\'t find anything like that at least on top of the Discuss sectios. Seems like unique one and wanted to share it.\\n\\nThe idea is let\\'s sum all the elements in the array and put it in a heap and then let\\'s start subtracting all the elements from the smallest to largest untill we find the sum that can be devided by 3.\\n\\nIn heap we keep the mask of subtracted elements.\\n\\n```python\\nclass Solution:\\n    def maxSumDivThree(self, A: List[int]) -> int:\\n        B = []\\n        ans = S = 0\\n        for a in A:\\n            if a %3:\\n                S += a\\n                B.append(a)\\n            else:\\n                ans += a\\n        B.sort()\\n        \\n        q = []\\n        heappush(q,(-S,0))\\n        N = len(B)\\n        while q:\\n            L = len(q)\\n            s, mask = heappop(q)\\n            if s % 3 == 0:\\n                return ans-s\\n\\n            for i in range(N):\\n                if mask & (1 << i) == 0:\\n                    heappush(q,(s + B[i], mask | (1 << i)))\\n```\\n\\n`O(2^N)`  worst case. somehow getting 61% of speed\\n`O(heap size)` space\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumDivThree(self, A: List[int]) -> int:\\n        B = []\\n        ans = S = 0\\n        for a in A:\\n            if a %3:\\n                S += a\\n                B.append(a)\\n            else:\\n                ans += a\\n        B.sort()\\n        \\n        q = []\\n        heappush(q,(-S,0))\\n        N = len(B)\\n        while q:\\n            L = len(q)\\n            s, mask = heappop(q)\\n            if s % 3 == 0:\\n                return ans-s\\n\\n            for i in range(N):\\n                if mask & (1 << i) == 0:\\n                    heappush(q,(s + B[i], mask | (1 << i)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903071,
                "title": "java-recursive-recursive-simplified-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n    - If we are currently at index \\'i\\' with \\'num\\'\\n        - If \\'num % 3\\' is equal to 0\\n            - We will want to add \\'num\\' to the largest \\'sum\\', where \\'sum % 3\\' is also equal to 0\\n            - This allows \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 1\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 2\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 2\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 1\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n    - Using the approach\\n        - We can see that we are trying to find the maximum \\'sum\\' that has the remainders \\'0, 1, 2\\'\\n            - But our main target is finding the maximum \\'sum\\' that has a remainder of 0\\n```\\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        if (nums[i] % 3 == 0) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 1) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 2) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        return -1; // should not get here\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproachSimplified {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        int difference = target - (nums[i] % 3);\\n        int nextTarget = (difference >= 0) ? difference : difference + 3;\\n        return Math.max(maxSumDivThree(i + 1, nextTarget, nums) + nums[i], maxSumDivThree(i + 1, target, nums));\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeMemoizationApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums, new int[nums.length][3]);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums, int[][] memo) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n        if (memo[i][target] != 0) return memo[i][target];\\n\\n        int difference = target - (nums[i] % 3);\\n\\n        return memo[i][target] = Math.max(\\n                maxSumDivThree(i + 1, (difference >= 0) ? difference : difference + 3, nums, memo) + nums[i],\\n                maxSumDivThree(i + 1, target, nums, memo)\\n        );\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeBottomUp2DApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] maxSum = new int[nums.length + 1][3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    maxSum[i][target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                maxSum[i][target] = Math.max(\\n                        maxSum[i + 1][(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[i + 1][target]\\n                );\\n            }\\n        }\\n\\n        return maxSum[0][0];\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeBottomUpConstantSpaceApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] maxSum = new int[3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            int[] current = new int[3];\\n\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    current[target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                current[target] = Math.max(\\n                        maxSum[(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[target]\\n                );\\n            }\\n\\n            maxSum = current;\\n        }\\n\\n        return maxSum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    - If we are currently at index \\'i\\' with \\'num\\'\\n        - If \\'num % 3\\' is equal to 0\\n            - We will want to add \\'num\\' to the largest \\'sum\\', where \\'sum % 3\\' is also equal to 0\\n            - This allows \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 1\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 2\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 2\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 1\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n    - Using the approach\\n        - We can see that we are trying to find the maximum \\'sum\\' that has the remainders \\'0, 1, 2\\'\\n            - But our main target is finding the maximum \\'sum\\' that has a remainder of 0\\n```\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        if (nums[i] % 3 == 0) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 1) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 2) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        return -1; // should not get here\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproachSimplified {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        int difference = target - (nums[i] % 3);\\n        int nextTarget = (difference >= 0) ? difference : difference + 3;\\n        return Math.max(maxSumDivThree(i + 1, nextTarget, nums) + nums[i], maxSumDivThree(i + 1, target, nums));\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeMemoizationApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums, new int[nums.length][3]);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums, int[][] memo) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n        if (memo[i][target] != 0) return memo[i][target];\\n\\n        int difference = target - (nums[i] % 3);\\n\\n        return memo[i][target] = Math.max(\\n                maxSumDivThree(i + 1, (difference >= 0) ? difference : difference + 3, nums, memo) + nums[i],\\n                maxSumDivThree(i + 1, target, nums, memo)\\n        );\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeBottomUp2DApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] maxSum = new int[nums.length + 1][3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    maxSum[i][target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                maxSum[i][target] = Math.max(\\n                        maxSum[i + 1][(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[i + 1][target]\\n                );\\n            }\\n        }\\n\\n        return maxSum[0][0];\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeBottomUpConstantSpaceApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] maxSum = new int[3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            int[] current = new int[3];\\n\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    current[target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                current[target] = Math.max(\\n                        maxSum[(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[target]\\n                );\\n            }\\n\\n            maxSum = current;\\n        }\\n\\n        return maxSum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820598,
                "title": "python-heaps-dp-top-down-and-dp-bottom-up",
                "content": "### 1. Heaps\\nWhat differentiates this problem from other 0/1 knapsack problem is that\\u2014to get the best results, we can simply remove 1 or 2 smallest numbers meeting certain requirement.\\n\\nWe can simply keep track of how many have num % 3 == 1 and num % 3 == 2. Once we finish iterating the array, we can calculate the sum of the array % 3. \\n\\nIf this is 0, the sum of the array is the answer. \\n\\nIf this is 1, we need to remove 1 or 2 numbers. We can either remove the smallest number that mod 3 == 1 or the two smallest numbers that mod 3 == 2. \\n\\nIf this is 2, we need to remove 1 or 2 numbers. We can either remove the smallest number that mod 3 == 2 or the two smallest numbers that mod 3 == 1. \\n\\nWe can also leverage heaps to maintain the smallest 2 numbers that mod 3 == 1 and do the same for those that mod 3 == 2.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mods = [0, 0, 0]\\n        heaps = [[], [], []]\\n        total = 0\\n        \\n        for n in nums:\\n            total += n\\n            m = n%3\\n            mods[m] += 1\\n            if len(heaps[m]) < 2:\\n                heapq.heappush(heaps[m], -n)\\n            else:\\n                heapq.heappushpop(heaps[m], -n)\\n        \\n        total_mod = (mods[1] * 1 + mods[2] * 2) % 3\\n        ret = -float(\"inf\")\\n        if total_mod == 0:\\n            ret = total\\n        elif total_mod == 1:\\n            if len(heaps[1]) > 0:\\n                ret = max(ret, total + heaps[1][-1])\\n            if len(heaps[2]) == 2:\\n                ret = max(ret, total + sum(heaps[2]))\\n        else:\\n            if len(heaps[1]) == 2:\\n                ret = max(ret, total + sum(heaps[1]))\\n            if len(heaps[2]) > 0:\\n                ret = max(ret, total + heaps[2][-1])\\n        return ret\\n        \\n```\\n\\n### 2. Top-down DP\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        L= len(nums)\\n        \\n        @functools.lru_cache(None)\\n        def dp(index, remainder):\\n            if index == L:\\n                if remainder == 0:\\n                    return 0\\n                else:\\n                    return -float(\"inf\")\\n            \\n            new_remainder = (remainder + nums[index] % 3) % 3\\n            return max(dp(index+1, remainder), nums[index] + dp(index+1, new_remainder))\\n        \\n        return dp(0, 0)\\n```\\n\\n### 3. Bottom-up DP\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        L = len(nums)\\n        dp = [-float(\"inf\")] * 3\\n        dp[0] = 0\\n        for i in range(L):\\n            dp2 = [i for i in dp]\\n            r = nums[i] % 3 \\n            \\n            for r_old, cumsum_old in enumerate(dp):\\n                r_new = (r + r_old) % 3\\n                dp2[r_new] = max(dp2[r_new], cumsum_old+nums[i])\\n            dp = dp2\\n        return dp[0]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mods = [0, 0, 0]\\n        heaps = [[], [], []]\\n        total = 0\\n        \\n        for n in nums:\\n            total += n\\n            m = n%3\\n            mods[m] += 1\\n            if len(heaps[m]) < 2:\\n                heapq.heappush(heaps[m], -n)\\n            else:\\n                heapq.heappushpop(heaps[m], -n)\\n        \\n        total_mod = (mods[1] * 1 + mods[2] * 2) % 3\\n        ret = -float(\"inf\")\\n        if total_mod == 0:\\n            ret = total\\n        elif total_mod == 1:\\n            if len(heaps[1]) > 0:\\n                ret = max(ret, total + heaps[1][-1])\\n            if len(heaps[2]) == 2:\\n                ret = max(ret, total + sum(heaps[2]))\\n        else:\\n            if len(heaps[1]) == 2:\\n                ret = max(ret, total + sum(heaps[1]))\\n            if len(heaps[2]) > 0:\\n                ret = max(ret, total + heaps[2][-1])\\n        return ret\\n        \\n```\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        L= len(nums)\\n        \\n        @functools.lru_cache(None)\\n        def dp(index, remainder):\\n            if index == L:\\n                if remainder == 0:\\n                    return 0\\n                else:\\n                    return -float(\"inf\")\\n            \\n            new_remainder = (remainder + nums[index] % 3) % 3\\n            return max(dp(index+1, remainder), nums[index] + dp(index+1, new_remainder))\\n        \\n        return dp(0, 0)\\n```\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        L = len(nums)\\n        dp = [-float(\"inf\")] * 3\\n        dp[0] = 0\\n        for i in range(L):\\n            dp2 = [i for i in dp]\\n            r = nums[i] % 3 \\n            \\n            for r_old, cumsum_old in enumerate(dp):\\n                r_new = (r + r_old) % 3\\n                dp2[r_new] = max(dp2[r_new], cumsum_old+nums[i])\\n            dp = dp2\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783107,
                "title": "easy-clean-java-solution-using-min-heap",
                "content": "Explanation :-\\n========\\nis if sum % 3 == 1 then you can either sutract lowest number which is num % 3 == 1 from sum to obtain sum%3==0 or two lowest number having mod of 2\\n\\nSame is for sum % 2 == 1. You can either subtract lowest number having mod 2 or two lowest number having mod 1 to make it sum % 3 == 0\\n\\nTime Complexity O ( N log N ), Space complexity O ( N )\\n\\n```\\nclass Solution {\\n    \\n    public int maxSumDivThree(int[] nums) {\\n\\n        int sum = 0, sum1 = Integer.MIN_VALUE, sum2 = Integer.MIN_VALUE;\\n\\n        PriorityQueue<Integer> dp[] = new PriorityQueue[] { \\n            new PriorityQueue<>(), new PriorityQueue<>(), new PriorityQueue<>()\\n        };\\n        \\n        for (int num: nums) {\\n            // Num goes to bucket num % 3\\n            dp[num % 3].add(num);\\n            sum+=num;\\n        }\\n        \\n        int k = sum % 3;\\n        switch (k) {\\n            case 0:\\n                return sum;\\n            case 1:\\n            case 2:\\n                if (dp[k].size() > 0)\\n                    sum1 = sum - dp[k].poll();\\n                \\n                if (dp[3-k].size() > 1)\\n                    sum2 = sum - dp[3-k].poll() - dp[3-k].poll();\\n                return Math.max(sum1, sum2);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maxSumDivThree(int[] nums) {\\n\\n        int sum = 0, sum1 = Integer.MIN_VALUE, sum2 = Integer.MIN_VALUE;\\n\\n        PriorityQueue<Integer> dp[] = new PriorityQueue[] { \\n            new PriorityQueue<>(), new PriorityQueue<>(), new PriorityQueue<>()\\n        };\\n        \\n        for (int num: nums) {\\n            // Num goes to bucket num % 3\\n            dp[num % 3].add(num);\\n            sum+=num;\\n        }\\n        \\n        int k = sum % 3;\\n        switch (k) {\\n            case 0:\\n                return sum;\\n            case 1:\\n            case 2:\\n                if (dp[k].size() > 0)\\n                    sum1 = sum - dp[k].poll();\\n                \\n                if (dp[3-k].size() > 1)\\n                    sum2 = sum - dp[3-k].poll() - dp[3-k].poll();\\n                return Math.max(sum1, sum2);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708944,
                "title": "java-using-remainder",
                "content": "A little bit long but easy to understand:\\n1, find the smallest 2 nums that num % 3 == 1, 2 respectively; \\n2, calculate sum of array, sum\\n3, find smallest num that num % 3 == sum % 3, if exists, note as a;\\n4, find 2 smallest num that num % 3 == 3 - sum % 3, if exists, say, c and d, b = c + d;\\n5, return sum - Math.min(a, b);\\n\\n```\\n    public int maxSumDivThree(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        int m = 3, sum = 0;\\n        for (int i = 1; i < m; i++) map.put(i, new PriorityQueue<>((a, b) -> b - a));\\n        for (int n : nums) {\\n            sum += n;\\n            if (n % m != 0) {\\n                PriorityQueue pq = map.get(n % m);\\n                pq.offer(n);\\n                if (pq.size() > 2) pq.poll();\\n            }\\n        }\\n        int rem = sum % m;\\n        if (rem == 0) return sum;\\n        int b = 0;\\n        if (map.get(m - rem).size() == 2) {\\n            while (map.get(m - rem).size() > 0) b += map.get(m - rem).poll();\\n        }\\n        if (map.get(rem).size() == 0) return sum - b; // another method to get rem; size must be 2 or 0;\\n        while (map.get(rem).size() > 1) map.get(rem).poll();\\n        int a = map.get(rem).poll();\\n        if (b > 0) a = Math.min(a, b);\\n        return sum - a;   // min num with rem == num % 3;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        int m = 3, sum = 0;\\n        for (int i = 1; i < m; i++) map.put(i, new PriorityQueue<>((a, b) -> b - a));\\n        for (int n : nums) {\\n            sum += n;\\n            if (n % m != 0) {\\n                PriorityQueue pq = map.get(n % m);\\n                pq.offer(n);\\n                if (pq.size() > 2) pq.poll();\\n            }\\n        }\\n        int rem = sum % m;\\n        if (rem == 0) return sum;\\n        int b = 0;\\n        if (map.get(m - rem).size() == 2) {\\n            while (map.get(m - rem).size() > 0) b += map.get(m - rem).poll();\\n        }\\n        if (map.get(rem).size() == 0) return sum - b; // another method to get rem; size must be 2 or 0;\\n        while (map.get(rem).size() > 1) map.get(rem).poll();\\n        int a = map.get(rem).poll();\\n        if (b > 0) a = Math.min(a, b);\\n        return sum - a;   // min num with rem == num % 3;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612793,
                "title": "c-o-n-detailed-explanation",
                "content": "```\\nThis is a really tricky problem.\\nOne thing u have to note is that when i divide any number by 3 my maximum number would be 2.\\nOne way to solve this method is to ste the maximum sum with remainders 0,1,2\\n[3,6,5,1,8]        [0,0,0] <----auxiliary array storing the maimum sum int the remainders position\\n ^\\n |\\n i\\nsum = 3            [3,0,0] <---3%3=0\\n\\n\\n[3,6,5,1,8]        [9,0,0] <----9%3=0\\n   ^\\n   |\\n   i\\nsum = 3+6 = 9\\n\\n[3,6,5,1,8]        [9,0,14] <----14%3=2\\n   ^\\n   |\\n   i\\nsum = 9+5=14\\n\\n[3,6,5,1,8]        [15,0,14] <----15%3=0\\n   ^\\n   |\\n   i\\nsum = 14+1=15\\n\\n[3,6,5,1,8]        [15,0,23] <----23%3=2\\n   ^\\n   |\\n   i\\nsum = 15+8=23\\n\\nThis approach gives me a max sum of remainder 0 as 15 but that isnt an answer\\nOur approach here finds the maximum sum of a subarray that is divisible by 3\\nBut we need to find a subsequence(not necesaaruly have to by contiguos elements).\\n\\nJust look at our auxiliary array carefully.\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,0,14]           [3,6,5,1,]\\n[15,0,23]           [3,6,5,1,8]\\n\\nIf i were to add every new number to the sums present in the auxiliary array and mod it and check if it beats any of the sum would that work?\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,10,14]           [3,6,5,1,] 1 is added to 9 0 and 14 = 10, 1 and 15\\n[18,22,23]           [3,6,5,1,8]  8 is added to 15,10 and 14 which gives 23,18,22 where 18 beats 15 \\n\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> dp={0,0,0};\\n        for(int x:nums)\\n        {\\n            vector<int> dp1=dp;\\n            for(int a:dp1)\\n            {\\n                dp[(x+a)%3]=max(dp[(x+a)%3],x+a);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThis is a really tricky problem.\\nOne thing u have to note is that when i divide any number by 3 my maximum number would be 2.\\nOne way to solve this method is to ste the maximum sum with remainders 0,1,2\\n[3,6,5,1,8]        [0,0,0] <----auxiliary array storing the maimum sum int the remainders position\\n ^\\n |\\n i\\nsum = 3            [3,0,0] <---3%3=0\\n\\n\\n[3,6,5,1,8]        [9,0,0] <----9%3=0\\n   ^\\n   |\\n   i\\nsum = 3+6 = 9\\n\\n[3,6,5,1,8]        [9,0,14] <----14%3=2\\n   ^\\n   |\\n   i\\nsum = 9+5=14\\n\\n[3,6,5,1,8]        [15,0,14] <----15%3=0\\n   ^\\n   |\\n   i\\nsum = 14+1=15\\n\\n[3,6,5,1,8]        [15,0,23] <----23%3=2\\n   ^\\n   |\\n   i\\nsum = 15+8=23\\n\\nThis approach gives me a max sum of remainder 0 as 15 but that isnt an answer\\nOur approach here finds the maximum sum of a subarray that is divisible by 3\\nBut we need to find a subsequence(not necesaaruly have to by contiguos elements).\\n\\nJust look at our auxiliary array carefully.\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,0,14]           [3,6,5,1,]\\n[15,0,23]           [3,6,5,1,8]\\n\\nIf i were to add every new number to the sums present in the auxiliary array and mod it and check if it beats any of the sum would that work?\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,10,14]           [3,6,5,1,] 1 is added to 9 0 and 14 = 10, 1 and 15\\n[18,22,23]           [3,6,5,1,8]  8 is added to 15,10 and 14 which gives 23,18,22 where 18 beats 15 \\n\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> dp={0,0,0};\\n        for(int x:nums)\\n        {\\n            vector<int> dp1=dp;\\n            for(int a:dp1)\\n            {\\n                dp[(x+a)%3]=max(dp[(x+a)%3],x+a);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 592982,
                "title": "java-solution-recursion-memo",
                "content": "```\\nclass Solution {\\n     public int maxSumDivThree(int[] nums) {\\n      int dp[][]=new int[nums.length][4];\\n         for(int i=0;i<nums.length;i++)\\n             for(int j=0;j<4;j++)\\n                 dp[i][j]=-1;\\n          int x= function(nums,0,0,dp);\\n         if(x==-1)\\n             return 0;\\n         else\\n             return x;\\n    }\\n\\n    private int function(int[] nums, int sum, int i,int dp[][]) {\\n        \\n        if (i == nums.length) \\n        {\\n            if(sum==0)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n       int a=function(nums,(sum+nums[i])%3,i+1,dp);\\n        if(a!=-1)\\n            a=a+nums[i];\\n        int b=function(nums,sum%3,i+1,dp);\\n        return dp[i][sum]=Math.max(a,b);\\n        \\n     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int maxSumDivThree(int[] nums) {\\n      int dp[][]=new int[nums.length][4];\\n         for(int i=0;i<nums.length;i++)\\n             for(int j=0;j<4;j++)\\n                 dp[i][j]=-1;\\n          int x= function(nums,0,0,dp);\\n         if(x==-1)\\n             return 0;\\n         else\\n             return x;\\n    }\\n\\n    private int function(int[] nums, int sum, int i,int dp[][]) {\\n        \\n        if (i == nums.length) \\n        {\\n            if(sum==0)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n       int a=function(nums,(sum+nums[i])%3,i+1,dp);\\n        if(a!=-1)\\n            a=a+nums[i];\\n        int b=function(nums,sum%3,i+1,dp);\\n        return dp[i][sum]=Math.max(a,b);\\n        \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431180,
                "title": "java-o-nlogn-easy-to-understand-solution-with-comments",
                "content": "1. Take the sum of complete array and see by how much does it exceed from the nearest multiple of  3 (take mod of this sum with 3 and see what is the remainder)\\n2. Select a set of numbers which can offset this value and bring sum to a multiple of 3 by ejecting these numbers. In other words find shortest set of values whose sum gives same remainder as the total sum on taking mod with 3. To find these shortest values we need to sort the array,\\n3. If sum%3==0 just return this sum.\\n4. If sum%3==1:  Either eject the smallest number with num%3==1 or two numbers with num%3==2 (since (2+2)%3 is also 1) so that we lose this extra 1 as remainder from total sum. We need to consider both of these possibilities as there might be two very small numbers with mod 2 in the array and the first number with mod 1 might be bigger than combined sum of such small numbers.\\n5. Similarly if sum%3==2 either remove smallest number with num%3==2 or two numbers with num%3==1 whichever does less damage to out sum. Below is my code:\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic int maxSumDivThree(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tint rem= sum%3;\\n        \\n\\t\\t\\t//if sum is already divisible by 3 return this sum\\n\\t\\t\\tif(rem==0)\\n\\t\\t\\t\\treturn sum;\\n        \\n\\t\\t\\t//sum of numbers we want to throw out so total sum becomes a multiple of 3. \\n\\t\\t\\t//This should be as low as possible\\n\\t\\t\\tint eject=0;\\n \\n\\t\\t\\t//if remainder exceeds by 1 either eject one number with mod=1 or two numbers with mod=2 so that (2+2)%3=1 \\n\\t\\t\\tif(rem==1) eject=Math.min(one1(nums),two2(nums));\\n        \\n\\t\\t\\t//same logic as above but we either need to throw 2 numbers with mod 1 each or one number with mod 2\\n\\t\\t\\telse       eject=Math.min(one2(nums),two1(nums));\\n        \\n\\t\\t\\treturn sum-eject;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tprivate int one1(int[] nums){\\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\t\\t\\tif(nums[i]%3==1)\\n\\t\\t\\t\\t\\t\\treturn nums[i];\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int two2(int[] nums){\\n\\t\\t\\tint first=0,second=0;\\n        \\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(nums[i]%3==2 && first==0)\\n\\t\\t\\t\\t\\tfirst=nums[i];\\n\\t\\t\\t\\telse if(nums[i]%3==2){\\n\\t\\t\\t\\t\\tsecond=nums[i]; break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(first==0 || second==0)\\n\\t\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\treturn first+second;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int one2(int[] nums){\\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\t\\t\\tif(nums[i]%3==2)\\n\\t\\t\\t\\t\\t\\treturn nums[i];\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int two1(int[] nums){\\n\\t\\t\\t\\tint first=0,second=0;\\n        \\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\tif(nums[i]%3==1 && first==0)\\n\\t\\t\\t\\t\\t\\tfirst=nums[i];\\n\\t\\t\\t\\t\\telse if(nums[i]%3==1){\\n\\t\\t\\t\\t\\t\\tsecond=nums[i]; break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(first==0 || second==0)\\n\\t\\t\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t\\treturn first+second;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic int maxSumDivThree(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3918116,
                "title": "100-faster-java-code-dp-simplest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c7d0bb97-d250-4053-ae1e-7cdbe3b5cd08_1692192623.3204708.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int k = 3; // Number of possible remainders\\n        long[][] dp = new long[n + 1][k];\\n        \\n        // Initialize the dp array with negative infinity values\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\\n        }\\n        \\n        // Base case: maximum sum with remainder 0 is 0\\n        dp[0][0] = 0;\\n        \\n        // Iterate through the numbers in the array\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                // Calculate the new remainder after including the current number\\n                int newRemainder = (j + nums[i]) % k;\\n                \\n                // Update the maximum sum for the current remainder\\n                dp[i + 1][newRemainder] = Math.max(dp[i][newRemainder], dp[i][j] + nums[i]);\\n            }\\n        }\\n        \\n        // The maximum sum with remainder 0 after considering all elements\\n        return (int) dp[n][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int k = 3; // Number of possible remainders\\n        long[][] dp = new long[n + 1][k];\\n        \\n        // Initialize the dp array with negative infinity values\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\\n        }\\n        \\n        // Base case: maximum sum with remainder 0 is 0\\n        dp[0][0] = 0;\\n        \\n        // Iterate through the numbers in the array\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                // Calculate the new remainder after including the current number\\n                int newRemainder = (j + nums[i]) % k;\\n                \\n                // Update the maximum sum for the current remainder\\n                dp[i + 1][newRemainder] = Math.max(dp[i][newRemainder], dp[i][j] + nums[i]);\\n            }\\n        }\\n        \\n        // The maximum sum with remainder 0 after considering all elements\\n        return (int) dp[n][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735402,
                "title": "most-efficient-greedy-approach-beats-97-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size(), sum = 0;\\n\\n        for(auto i : nums) sum += i;\\n        if(sum % 3 == 0) return sum;\\n\\n        vector<int>v;\\n        for(auto i : nums){\\n            if(i%3) v.push_back(i);\\n        }\\n\\n        sort(v.begin(),v.end());\\n        v.push_back(1e9+7);\\n\\n        int curr = 0 , l = 0;\\n\\n        for(int i=0; i<v.size(); i++){\\n            while(curr < v[i]){\\n                if(sum % 3 == curr % 3) return sum - curr;\\n                curr += v[l];\\n                l++;\\n            }\\n\\n            if(sum % 3 == v[i] % 3) return sum - v[i];\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size(), sum = 0;\\n\\n        for(auto i : nums) sum += i;\\n        if(sum % 3 == 0) return sum;\\n\\n        vector<int>v;\\n        for(auto i : nums){\\n            if(i%3) v.push_back(i);\\n        }\\n\\n        sort(v.begin(),v.end());\\n        v.push_back(1e9+7);\\n\\n        int curr = 0 , l = 0;\\n\\n        for(int i=0; i<v.size(); i++){\\n            while(curr < v[i]){\\n                if(sum % 3 == curr % 3) return sum - curr;\\n                curr += v[l];\\n                l++;\\n            }\\n\\n            if(sum % 3 == v[i] % 3) return sum - v[i];\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259873,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "# Approach\\n1. We just have to keep track of the following three things for the sub-problem till index i.\\n-Maximum subset sum that gives **reminder 0** when divided by 3.\\n-Maximum subset sum that gives **reminder 1** when divided by 3.\\n-Maximum subset sum that gives **reminder 2** when divided by 3.\\nI have used an array of size 3 for the sake of simplicity.\\n\\n2. At every iteration we have to compute and update the sums and remainders considering the current element.\\n\\n3. Return maximum sum that gives **reminder 0** when divided by 3.\\n \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        int[] sums=new int [3];\\n\\n        for(int i=0; i<n; i++){\\n            int s0=sums[0]+nums[i];\\n            int s1=sums[1]+nums[i];\\n            int s2=sums[2]+nums[i];\\n\\n            int r0=s0 % 3;\\n            int r1=s1 % 3;\\n            int r2=s2 % 3;\\n\\n            sums[r0]=Math.max(sums[r0], s0);\\n            sums[r1]=Math.max(sums[r1], s1);\\n            sums[r2]=Math.max(sums[r2], s2);\\n        } \\n\\n        return sums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        int[] sums=new int [3];\\n\\n        for(int i=0; i<n; i++){\\n            int s0=sums[0]+nums[i];\\n            int s1=sums[1]+nums[i];\\n            int s2=sums[2]+nums[i];\\n\\n            int r0=s0 % 3;\\n            int r1=s1 % 3;\\n            int r2=s2 % 3;\\n\\n            sums[r0]=Math.max(sums[r0], s0);\\n            sums[r1]=Math.max(sums[r1], s1);\\n            sums[r2]=Math.max(sums[r2], s2);\\n        } \\n\\n        return sums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244290,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>dp(3);\\n        for(auto a:nums){\\n            for(int i:vector<int>(dp)){\\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\\n            }\\n        }\\n       return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>dp(3);\\n        for(auto a:nums){\\n            for(int i:vector<int>(dp)){\\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\\n            }\\n        }\\n       return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579063,
                "title": "1262-python",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [0]*3\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tnewdp = dp.copy()\\n\\t\\t\\t\\tfor i in range(3):\\n\\t\\t\\t\\t\\tnewdp[(num+dp[i])%3] = max(newdp[(num+dp[i])%3], num+dp[i])\\n\\t\\t\\t\\tdp = newdp\\n\\t\\t\\treturn dp[0]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [0]*3\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tnewdp = dp.copy()\\n\\t\\t\\t\\tfor i in range(3):\\n\\t\\t\\t\\t\\tnewdp[(num+dp[i])%3] = max(newdp[(num+dp[i])%3], num+dp[i])\\n\\t\\t\\t\\tdp = newdp\\n\\t\\t\\treturn dp[0]",
                "codeTag": "Java"
            },
            {
                "id": 2454461,
                "title": "weeb-does-python-dp",
                "content": "dp[j][i] represents the current max sum divisible by 3\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(3, vector<int>(n+1, 0));\\n\\n\\t\\t\\tfor(int i=1; i<n+1; i++){\\n\\t\\t\\t\\tfor(int j=0; j<3; j++){\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i]);\\n\\t\\t\\t\\t\\tint curSum = nums[i-1] + dp[j][i-1];\\n\\t\\t\\t\\t\\tint idx = curSum % 3;\\n\\t\\t\\t\\t\\tdp[idx][i] = max(max(dp[idx][i-1], curSum), dp[idx][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][n];\\n\\t\\t}\\n\\t};\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [[0 for i in range(len(nums)+1)] for j in range(3)]\\n\\n\\t\\t\\tfor i in range(1,len(nums)+1):\\n\\t\\t\\t\\tfor j in range(3):\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i])\\n\\t\\t\\t\\t\\tcurSum = nums[i-1] + dp[j][i-1]\\n\\t\\t\\t\\t\\tidx = curSum % 3\\n\\t\\t\\t\\t\\tdp[idx][i] = max(dp[idx][i-1], curSum, dp[idx][i])\\n\\n\\t\\t\\treturn dp[0][-1]\\n\\nTake a break, watch some anime instead\\nCheck out **\\u963F\\u6CE2\\u9023\\u3055\\u3093\\u306F\\u306F\\u304B\\u308C\\u306A\\u3044 (Aharen-san wa Hakarenai)**\\n\\n# Episodes: 12\\n# Genre: Comedy\\n# Themes: Iyashikei, School\\n# Demographic: Shounen\\n\\nA really wholesome anime, so pls watch it!!",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(3, vector<int>(n+1, 0));\\n\\n\\t\\t\\tfor(int i=1; i<n+1; i++){\\n\\t\\t\\t\\tfor(int j=0; j<3; j++){\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i]);\\n\\t\\t\\t\\t\\tint curSum = nums[i-1] + dp[j][i-1];\\n\\t\\t\\t\\t\\tint idx = curSum % 3;\\n\\t\\t\\t\\t\\tdp[idx][i] = max(max(dp[idx][i-1], curSum), dp[idx][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2419612,
                "title": "python-recursion-memo-explained-mod-clear-concise",
                "content": "# EXPLAINATION\\nThe idea is to use recursion first \\n\\nNow we have two choices at each step : \\n1. choose the element at index i and continue to i + 1\\n2. do not choose the element at index i and continue to i +1\\n\\nWe need to keep track of index and current_sum ( sum of all nums[i] we have choosen so far)\\n\\nNow the recursion will terminate when index i will be equals to len(nums) -> base case\\n\\nNow we have two choices ( recursion ) at every step so this gives us the idea to do memoization \\n\\nIn memoization we memoize those variables which changes in each recursive call\\nHere current _ sum and index will change so we will memoize them\\n\\nBut this will give us TLE\\n\\nNow the solution to the TLE is using mod\\n\\nThe idea is 7 + 5 = 12 can also be written as\\n       3 + 3 + 1 + 5 = 12\\n\\t = 2(3) +1 + 5 = 12\\n\\t \\n\\t Now if we remove this 2(3) we will get sum 1 + 5 = 6 \\n\\t Now 6 % 3 is same as 12 % 3 \\n\\t \\n\\tSo if we reach index = 3 with sum = 22 in way (1)\\n\\t     and again reach index = 3 with sum = 16 in way(2)\\n\\t\\t \\nWhat is common between them is I am reaching index = 3 and mod(sum) = 1 in both.......\\n\\nNow dp[index][mod(sum)] can  store the best we can do after index when our mod = mod(sum) \\n\\nIn case of 3 the mod(sum) can be 0 / 1 / 2\\n\\nSo our dp is acting as a 2D dp having rows = 3 and columns = index \\n\\n\\t\\t \\n\\t\\n\\n# CODE\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp,n = {} , len(nums)\\n        \\n        def recursion(index,mod):\\n            if index == n: \\n                return 0 if mod == 0 else -inf\\n            if (index,mod) in dp: return dp[(index,mod)]\\n            a = recursion(index + 1, (mod + nums[index]) % 3) + nums[index]\\n            b = recursion(index + 1 , mod)\\n            ans = max(a,b)\\n            dp[(index,mod)] = ans\\n            return ans\\n        return recursion(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp,n = {} , len(nums)\\n        \\n        def recursion(index,mod):\\n            if index == n: \\n                return 0 if mod == 0 else -inf\\n            if (index,mod) in dp: return dp[(index,mod)]\\n            a = recursion(index + 1, (mod + nums[index]) % 3) + nums[index]\\n            b = recursion(index + 1 , mod)\\n            ans = max(a,b)\\n            dp[(index,mod)] = ans\\n            return ans\\n        return recursion(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237262,
                "title": "o-n-time-o-1-space-greedy-c",
                "content": "The mod of any value by 3 could only give **0**, **1** or **2**, which means we only have to worry about the values which give **1 or 2** with mod3. \\n**If the total sum is not divisible by, we only have to subtract the smallest value such that it does become divisible.**\\nFor eg, if **res** gives **1** when mod with 3, we have to subtract the **smallest of (smallest value from input array which gives 1 when mod by 3, sum of two smallest values which give 2 when mod by 3, since (2%3 + 2%3)%3 = 1)**, and **vice versa** if res gives **2** when mod with 3.\\n\\n***Note: If a%3 gives 2, then, a%3 = 2%3, and (a+b)%m = (a%m + b%m)%m.***\\n\\nDo comment down in case of any queries or remarks.\\n**Please upvote if you find the solution insightful.\\n*Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> twos = {(int)1e4+1, (int)1e4+1}, ones = {(int)1e4+1, (int)1e4+1};\\n        int res = 0;\\n        for(int i: nums) {\\n            if(i%3 == 2) {\\n                if(i <= twos[0]) {\\n                    twos[1] = twos[0], twos[0] = i;\\n                }\\n                else if(i < twos[1]) twos[1] = i;\\n            }\\n            else if(i%3 == 1) {\\n                if(i <= ones[0]) {\\n                    ones[1] = ones[0], ones[0] = i;\\n                }\\n                else if(i < ones[1]) ones[1] = i;\\n            }\\n            res += i;\\n        }\\n        if(res%3 == 2)\\n            return max(res - twos[0], res - ones[0] - ones[1]);\\n        else if(res%3 == 1)\\n            return max(res - ones[0], res - twos[0] - twos[1]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> twos = {(int)1e4+1, (int)1e4+1}, ones = {(int)1e4+1, (int)1e4+1};\\n        int res = 0;\\n        for(int i: nums) {\\n            if(i%3 == 2) {\\n                if(i <= twos[0]) {\\n                    twos[1] = twos[0], twos[0] = i;\\n                }\\n                else if(i < twos[1]) twos[1] = i;\\n            }\\n            else if(i%3 == 1) {\\n                if(i <= ones[0]) {\\n                    ones[1] = ones[0], ones[0] = i;\\n                }\\n                else if(i < ones[1]) ones[1] = i;\\n            }\\n            res += i;\\n        }\\n        if(res%3 == 2)\\n            return max(res - twos[0], res - ones[0] - ones[1]);\\n        else if(res%3 == 1)\\n            return max(res - ones[0], res - twos[0] - twos[1]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966725,
                "title": "greatest-sum-divisible-by-three",
                "content": "# Approach 1-recursion\\n```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n\\n```\\n# Approach 2- recursion + memoization\\n\\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\\n# Approach 3 - Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1813430,
                "title": "python3-greedy-linear-time",
                "content": "In this approach, the goal will be to sum up the entire list, and subtract only what needs to be subtracted to make the sum divisible by 3.\\n\\nThere are 3 situations regarding the sum:\\n**It is divisible by 3:** We are done already, just return the sum\\n**Leaves a remainder of 1:** Subtract the smallest number that leaves a remainder of 1, or the 2 smallest numbers which leave a remainder of 2- whichever one leaves the larger sum.\\n**Leaves a remainder of 2:** Subtract the smallest number that leaves a remainder of 2, or the 2 smallest numbers which leave a remainder of 1- whichever one leaves the larger sum.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\ttotal = sum(nums)\\n\\tif total%3 == 0:\\n\\t\\treturn total\\n\\n\\trem1_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 1\\n\\trem2_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 2\\n\\tfor num in nums:\\n\\t\\tif num % 3 == 1:\\n\\t\\t\\tif num < rem1_min[0]:\\n\\t\\t\\t\\trem1_min[0], rem1_min[1] = num, rem1_min[0]\\n\\t\\t\\telif num < rem1_min[1]:\\n\\t\\t\\t\\trem1_min[1] = num\\n\\t\\telif num % 3 == 2:\\n\\t\\t\\tif num < rem2_min[0]:\\n\\t\\t\\t\\trem2_min[0], rem2_min[1] = num, rem2_min[0]\\n\\t\\t\\telif num < rem2_min[1]:\\n\\t\\t\\t\\trem2_min[1] = num\\n\\n\\tif total%3 == 1:\\n\\t\\treturn total - min(rem1_min[0], sum(rem2_min))\\n\\tif total%3 == 2:\\n\\t\\treturn total - min(rem2_min[0], sum(rem1_min))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "In this approach, the goal will be to sum up the entire list, and subtract only what needs to be subtracted to make the sum divisible by 3.\\n\\nThere are 3 situations regarding the sum:\\n**It is divisible by 3:** We are done already, just return the sum\\n**Leaves a remainder of 1:** Subtract the smallest number that leaves a remainder of 1, or the 2 smallest numbers which leave a remainder of 2- whichever one leaves the larger sum.\\n**Leaves a remainder of 2:** Subtract the smallest number that leaves a remainder of 2, or the 2 smallest numbers which leave a remainder of 1- whichever one leaves the larger sum.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\ttotal = sum(nums)\\n\\tif total%3 == 0:\\n\\t\\treturn total\\n\\n\\trem1_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 1\\n\\trem2_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 2\\n\\tfor num in nums:\\n\\t\\tif num % 3 == 1:\\n\\t\\t\\tif num < rem1_min[0]:\\n\\t\\t\\t\\trem1_min[0], rem1_min[1] = num, rem1_min[0]\\n\\t\\t\\telif num < rem1_min[1]:\\n\\t\\t\\t\\trem1_min[1] = num\\n\\t\\telif num % 3 == 2:\\n\\t\\t\\tif num < rem2_min[0]:\\n\\t\\t\\t\\trem2_min[0], rem2_min[1] = num, rem2_min[0]\\n\\t\\t\\telif num < rem2_min[1]:\\n\\t\\t\\t\\trem2_min[1] = num\\n\\n\\tif total%3 == 1:\\n\\t\\treturn total - min(rem1_min[0], sum(rem2_min))\\n\\tif total%3 == 2:\\n\\t\\treturn total - min(rem2_min[0], sum(rem1_min))",
                "codeTag": "Python3"
            },
            {
                "id": 1646188,
                "title": "python-o-n-without-dp-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # strategy:\\n        # we sum everything, and then remove the smallest\\n        # number(s) possible to make the number divisble by 3\\n        \\n\\t\\t# if sum % 3 == 2, we just remove a number that \\n\\t\\t# is also % 3 == 2, call it mod2, same for mod1.\\n\\t\\t# key: removing 2 mod2\\'s is the same as removing 1 mod1 number\\n\\t\\t# and vice versa\\n\\t\\t\\n        # if sum % 3 == 0, then we are good\\n        # if sum % 3 == 2, we either remove 2 mod1\\'s or 1 mod2\\n\\t\\t# if sum % 3 == 1, we remove 2 mod2\\'s or 1 mod1\\n        # which ever smaller\\n\\t\\t\\n\\t\\t# you notice we only need to keep track of the 2 smallest\\n\\t\\t# nums for mod1 and mod2, so only O(1) space is needed\\n        \\n        total = 0\\n        mod1 = [math.inf, math.inf]\\n        mod2 = [math.inf, math.inf]\\n        \\n        for num in nums:\\n            if num % 3 == 1:\\n                if num < mod1[0]:\\n                    mod1[0], mod1[1] = num, mod1[0]\\n                elif num < mod1[1]:\\n                    mod1[1] = num\\n            elif num % 3 == 2:\\n                if num < mod2[0]:\\n                    mod2[0], mod2[1] = num, mod2[0]\\n                elif num < mod2[1]:\\n                    mod2[1] = num\\n            total += num\\n            \\n        if total % 3 == 1:\\n\\t\\t\\t# if less than 2 nums in mod2, then we can only take from mod1\\n            if math.inf in mod2:\\n                return total - mod1[0]\\n            total -= min(sum(mod2), mod1[0])\\n        elif total % 3 == 2:\\n            if math.inf in mod1:\\n                return total - mod2[0]\\n            total -= min(sum(mod1), mod2[0])\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # strategy:\\n        # we sum everything, and then remove the smallest\\n        # number(s) possible to make the number divisble by 3\\n        \\n\\t\\t# if sum % 3 == 2, we just remove a number that \\n\\t\\t# is also % 3 == 2, call it mod2, same for mod1.\\n\\t\\t# key: removing 2 mod2\\'s is the same as removing 1 mod1 number\\n\\t\\t# and vice versa\\n\\t\\t\\n        # if sum % 3 == 0, then we are good\\n        # if sum % 3 == 2, we either remove 2 mod1\\'s or 1 mod2\\n\\t\\t# if sum % 3 == 1, we remove 2 mod2\\'s or 1 mod1\\n        # which ever smaller\\n\\t\\t\\n\\t\\t# you notice we only need to keep track of the 2 smallest\\n\\t\\t# nums for mod1 and mod2, so only O(1) space is needed\\n        \\n        total = 0\\n        mod1 = [math.inf, math.inf]\\n        mod2 = [math.inf, math.inf]\\n        \\n        for num in nums:\\n            if num % 3 == 1:\\n                if num < mod1[0]:\\n                    mod1[0], mod1[1] = num, mod1[0]\\n                elif num < mod1[1]:\\n                    mod1[1] = num\\n            elif num % 3 == 2:\\n                if num < mod2[0]:\\n                    mod2[0], mod2[1] = num, mod2[0]\\n                elif num < mod2[1]:\\n                    mod2[1] = num\\n            total += num\\n            \\n        if total % 3 == 1:\\n\\t\\t\\t# if less than 2 nums in mod2, then we can only take from mod1\\n            if math.inf in mod2:\\n                return total - mod1[0]\\n            total -= min(sum(mod2), mod1[0])\\n        elif total % 3 == 2:\\n            if math.inf in mod1:\\n                return total - mod2[0]\\n            total -= min(sum(mod1), mod2[0])\\n            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514206,
                "title": "o-n-time-o-1-space-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r0 = r1 = r2 = 0\\n        # r0: maximum sum so far that % 3 == 0\\n        # r1: maximum sum so far that % 3 == 1\\n        # r2: maximum sum so far that % 3 == 2\\n        for num in nums:\\n            candidates = num + r0, num + r1, num + r2\\n            for candidate in candidates:\\n                if candidate % 3 == 0:\\n                    r0 = max(r0, candidate)\\n                elif candidate % 3 == 1:\\n                    r1 = max(r1, candidate)\\n                elif candidate % 3 == 2:\\n                    r2 = max(r2, candidate)\\n        return r0",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r0 = r1 = r2 = 0\\n        # r0: maximum sum so far that % 3 == 0\\n        # r1: maximum sum so far that % 3 == 1\\n        # r2: maximum sum so far that % 3 == 2\\n        for num in nums:\\n            candidates = num + r0, num + r1, num + r2\\n            for candidate in candidates:\\n                if candidate % 3 == 0:\\n                    r0 = max(r0, candidate)\\n                elif candidate % 3 == 1:\\n                    r1 = max(r1, candidate)\\n                elif candidate % 3 == 2:\\n                    r2 = max(r2, candidate)\\n        return r0",
                "codeTag": "Java"
            },
            {
                "id": 1395720,
                "title": "python-dp-solution-simple-code",
                "content": "Using a DP array that considers 3 conditions:\\nmod3 == 0\\nmod3 == 1\\nmod3 == 2\\n\\nThe trick is the initial value of first DP instance.\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [[0]*3 for _ in range(len(nums)+1)]\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            remainder = nums[i] % 3\\n            dp[i+1][0] = max(dp[i][0], dp[i][(3 - remainder)%3] + nums[i])\\n            dp[i+1][1] = max(dp[i][1], dp[i][(3-remainder+1)%3] + nums[i])\\n            dp[i+1][2] = max(dp[i][2], dp[i][(3-remainder+2)%3] + nums[i])\\n        return dp[-1][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [[0]*3 for _ in range(len(nums)+1)]\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            remainder = nums[i] % 3\\n            dp[i+1][0] = max(dp[i][0], dp[i][(3 - remainder)%3] + nums[i])\\n            dp[i+1][1] = max(dp[i][1], dp[i][(3-remainder+1)%3] + nums[i])\\n            dp[i+1][2] = max(dp[i][2], dp[i][(3-remainder+2)%3] + nums[i])\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357841,
                "title": "java-clean-dp-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[3][nums.length + 1];\\n        for(int i = 1; i <= nums.length; i++) {\\n            int curNum = nums[i - 1];\\n            for(int k = 0; k <= 2; k++) { // for 3 remainders possible i.e. 0, 1, 2\\n                int sum = dp[k][i - 1] + curNum; // add cur number with previous sum for all remainders each.\\n                int newRemainder = sum % 3;\\n                dp[newRemainder][i] = Math.max(dp[newRemainder][i], sum); // hold sum for new remainder \\n                dp[k][i] = Math.max(dp[k][i - 1], dp[k][i]); // check if we can pick max sum from previous location\\n            }\\n            \\n        }\\n        \\n        return dp[0][nums.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[3][nums.length + 1];\\n        for(int i = 1; i <= nums.length; i++) {\\n            int curNum = nums[i - 1];\\n            for(int k = 0; k <= 2; k++) { // for 3 remainders possible i.e. 0, 1, 2\\n                int sum = dp[k][i - 1] + curNum; // add cur number with previous sum for all remainders each.\\n                int newRemainder = sum % 3;\\n                dp[newRemainder][i] = Math.max(dp[newRemainder][i], sum); // hold sum for new remainder \\n                dp[k][i] = Math.max(dp[k][i - 1], dp[k][i]); // check if we can pick max sum from previous location\\n            }\\n            \\n        }\\n        \\n        return dp[0][nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297334,
                "title": "98-faster-c-standard-dp-approach-with-explanation",
                "content": "dp[i][0] = maximum sum till i-th index which have remainder 0\\n        dp[i][1] = maximum sum till i-th index which have remainder 1\\n        dp[i][2] = maximum sum till i-th index which have remainder 2      \\n\\t\\t\\n\\tint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][3];memset(dp,0,sizeof(dp));\\n\\t\\tfor(int i=0;i<n;i++){\\n            for(int j=0;j<3;j++){\\n                // every time we will update all the three columns with the maximum possible sum at that index\\n                if(i==0){ // trivial case i.e.when first element is encountered\\n                    int pos = nums[i]%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos],nums[i]); // compare either this possible answer or our previous answer\\n                }\\n                else{\\n                    // this time we have some numbers behind us so we have to consider them for index\\n                    int pos = (dp[i-1][j]+nums[i])%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos], dp[i-1][j]+nums[i]);\\n                    dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][0]; //   at last return the maximum sum with 0 remainder \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "dp[i][0] = maximum sum till i-th index which have remainder 0\\n        dp[i][1] = maximum sum till i-th index which have remainder 1\\n        dp[i][2] = maximum sum till i-th index which have remainder 2      \\n\\t\\t\\n\\tint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][3];memset(dp,0,sizeof(dp));\\n\\t\\tfor(int i=0;i<n;i++){\\n            for(int j=0;j<3;j++){\\n                // every time we will update all the three columns with the maximum possible sum at that index\\n                if(i==0){ // trivial case i.e.when first element is encountered\\n                    int pos = nums[i]%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos],nums[i]); // compare either this possible answer or our previous answer\\n                }\\n                else{\\n                    // this time we have some numbers behind us so we have to consider them for index\\n                    int pos = (dp[i-1][j]+nums[i])%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos], dp[i-1][j]+nums[i]);\\n                    dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][0]; //   at last return the maximum sum with 0 remainder \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1223831,
                "title": "python-greedy-nlogn-easy-to-understand-faster-than-86-with-mathematical-explanation",
                "content": "Let\\'s understand this first. For any integer n, if n mod 3 = 1, then if we subtract n by any integer (smaller than n) m1, m1 mod 3 = 1, then (n-m1) mod 3 = 0. And if we have 2 integer s1 and s2 (s1 and s2 smaller than n), s1 mod 3 = 1 , s2 mod 3 = 1, then (n - s1 - s2) mod 3 = 0. It\\'s the same for n mod 3 = 2\\nSo lets set n as the sum of the input array.\\nif n%3=1\\nans = n - min(m1,s1+ s2)    m1 is the smallest integer that m%3=1 in the list , s1 and s2 are the smallest integers that s or t mod 3 is 2 in the list.\\n\\nif n%3=2\\nans = n - min(m1+m2,s1)     s1 is the smallest integer that m%3=2 in the list , m1 and m2 are the smallest integers that s or t % 3 = 1 in the list.\\n\\nelse\\nans = n\\n\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        rem1 = [float(\\'inf\\')]\\n        rem2 = [float(\\'inf\\')]\\n        \\n        \\n        ans = sum(nums)\\n        \\n        for item in nums:\\n            if item%3 == 1:\\n                rem1.append(item)\\n                \\n            elif item%3 == 2:\\n                rem2.append(item)\\n                \\n        rem1.sort()\\n        rem2.sort()\\n        if ans%3==1:\\n            return ans-min(rem1[0],sum(rem2[:2]))\\n            \\n        \\n        elif ans%3==2:\\n            \\n            return ans-min(rem2[0],sum(rem1[:2]))\\n            \\n        \\n        else:\\n            return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        rem1 = [float(\\'inf\\')]\\n        rem2 = [float(\\'inf\\')]\\n        \\n        \\n        ans = sum(nums)\\n        \\n        for item in nums:\\n            if item%3 == 1:\\n                rem1.append(item)\\n                \\n            elif item%3 == 2:\\n                rem2.append(item)\\n                \\n        rem1.sort()\\n        rem2.sort()\\n        if ans%3==1:\\n            return ans-min(rem1[0],sum(rem2[:2]))\\n            \\n        \\n        elif ans%3==2:\\n            \\n            return ans-min(rem2[0],sum(rem1[:2]))\\n            \\n        \\n        else:\\n            return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137590,
                "title": "c-recursive-memoization",
                "content": "class Solution {\\npublic:\\n    int dp[40001][3]={};\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        return solve(nums,n,0,0);\\n        \\n    }\\n    int solve(vector<int>& nums,int n,int i,int r) { // O(2^n)\\n    if (i >= n) return r % 3 ? INT_MIN : 0;\\n        if(dp[i][r]!=0)\\n            return dp[i][r];\\n        \\n     return dp[i][r]=max(nums[i] + solve(nums,n, i + 1, (r + nums[i]) % 3), solve(nums,n, i+ 1, r));\\n            }      \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[40001][3]={}",
                "codeTag": "Java"
            },
            {
                "id": 948167,
                "title": "c-very-simple-and-short-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a[3] = {0};\\n        for(int x : nums) {\\n            int b[3];\\n            memcpy(b,a,sizeof(a));\\n            for(int i = 0;i<3;i++) {\\n                int y = b[i] + x;\\n                a[y%3] = max(y,a[y%3]);\\n            }\\n        }\\n        return a[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a[3] = {0};\\n        for(int x : nums) {\\n            int b[3];\\n            memcpy(b,a,sizeof(a));\\n            for(int i = 0;i<3;i++) {\\n                int y = b[i] + x;\\n                a[y%3] = max(y,a[y%3]);\\n            }\\n        }\\n        return a[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855429,
                "title": "java-single-pass-o-n",
                "content": "Any number will be a sum of 3 if (sum%3 == 0)\\n\\nLet\\'s say x = (sum % 3) and x != 0.\\nthen to make the sum divisble by 3, we have to subtract x from sum (i.e. alpha = sum-x) and hence alpha will be divisble by 3.\\n\\nThus our task is to find greatest value of alpha, which in  turn implies we have to find smallest value of x.\\n\\n-> x can have two values either 1 or 2. (sum%3)/\\nThus our task is to find smalles number in the whole array having remainder as 1 or 2. And subtract that number from the total sum of the array.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int rem1=10001;\\n        int rem2=10001;\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++) {\\n            sum+=nums[i];\\n            if(nums[i]%3==1) {\\n                rem2 = Math.min(rem1+nums[i], rem2);\\n                rem1 = Math.min(rem1, nums[i]);\\n            }\\n            if(nums[i]%3==2) {\\n                rem1 = Math.min(rem2+nums[i], rem1);\\n                rem2 = Math.min(rem2, nums[i]);\\n            }\\n            \\n        }\\n        if (sum % 3 == 0) {\\n            return sum;\\n        }\\n        return sum%3==1 ? (sum-rem1) : (sum-rem2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int rem1=10001;\\n        int rem2=10001;\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++) {\\n            sum+=nums[i];\\n            if(nums[i]%3==1) {\\n                rem2 = Math.min(rem1+nums[i], rem2);\\n                rem1 = Math.min(rem1, nums[i]);\\n            }\\n            if(nums[i]%3==2) {\\n                rem1 = Math.min(rem2+nums[i], rem1);\\n                rem2 = Math.min(rem2, nums[i]);\\n            }\\n            \\n        }\\n        if (sum % 3 == 0) {\\n            return sum;\\n        }\\n        return sum%3==1 ? (sum-rem1) : (sum-rem2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827184,
                "title": "python-faster-than-99-math-solution",
                "content": "**Explanation:** you can get a modulo-3 number from a sequence, (that\\'s not already mod3) by removing:\\n  -  at most two numbers nums\\n  -  as little as one number num.\\n\\nDon\\'t remove anymore than you have to, so find the minimum sum of these removals and subtract it from the total sequence\\'s sum.\\n\\nRemoving one or two depends on the full-sequence\\'s-sum modulo and the the sum of the two-num-removal vs the value of the one num removal. \\n\\nNote: no need to sort the nums, only remove the minimum iteratively which is what the helper `min_n()` does.\\n \\n```\\ndef maxSumDivThree(nums):\\n    \\n    total =     sum(nums)\\n    mod_total = total % 3 \\n\\n    if mod_total == 0:\\n        return total\\n    \\n    else:\\n        \\n        def min_n(nums, n):\\n            if len(nums) < n: return 10**6\\n            sum_n = 0\\n            for i in range(n):\\n                min_current = min(nums)\\n                min_current_ind = nums.index(min_current)\\n                sum_n += nums.pop(min_current_ind)\\n            return sum_n\\n        \\n        mod_1 = [e for e in nums if e % 3 == 1]\\n        mod_2 = [e for e in nums if e % 3 == 2]\\n        \\n        if mod_total == 1:\\n            \\n            one_mod_1 =   min_n(mod_1, 1)\\n            two_mod_2 =   min_n(mod_2, 2)\\n            \\n            return total - min(one_mod_1, two_mod_2)\\n            \\n        elif mod_total == 2:\\n            \\n            two_mod_1 =   min_n(mod_1, 2)\\n            one_mod_2 =   min_n(mod_2, 1)\\n            \\n            return total - min(two_mod_1, one_mod_2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(nums):\\n    \\n    total =     sum(nums)\\n    mod_total = total % 3 \\n\\n    if mod_total == 0:\\n        return total\\n    \\n    else:\\n        \\n        def min_n(nums, n):\\n            if len(nums) < n: return 10**6\\n            sum_n = 0\\n            for i in range(n):\\n                min_current = min(nums)\\n                min_current_ind = nums.index(min_current)\\n                sum_n += nums.pop(min_current_ind)\\n            return sum_n\\n        \\n        mod_1 = [e for e in nums if e % 3 == 1]\\n        mod_2 = [e for e in nums if e % 3 == 2]\\n        \\n        if mod_total == 1:\\n            \\n            one_mod_1 =   min_n(mod_1, 1)\\n            two_mod_2 =   min_n(mod_2, 2)\\n            \\n            return total - min(one_mod_1, two_mod_2)\\n            \\n        elif mod_total == 2:\\n            \\n            two_mod_1 =   min_n(mod_1, 2)\\n            one_mod_2 =   min_n(mod_2, 1)\\n            \\n            return total - min(two_mod_1, one_mod_2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 758399,
                "title": "c-solution-with-comments-if-doubts-arrise-please-ping-the-comments",
                "content": "class Solution {\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n     \\t\\n     \\tint n = nums.size() ; \\n\\n        //store the numbers which give remainder 1 , 2 when div by 3 : \\n     \\tpriority_queue<int, vector<int> , greater<int> > one ; \\n     \\tpriority_queue<int, vector<int> , greater<int> > two ; \\n\\n        \\n        \\n     \\tint  tsum = 0 ; \\n\\n/*\\n    what i am doing in the below loop : \\n    basically tsum will store the total sum of the nums \\n    \\n    3 cases arrive : either the tsum % 3 == 0 or 1 or 2 ! \\n    so the pq -> one and two will have the nums with remainder 1 and 2 respectively \\n    \\n*/\\n        \\n     \\tfor(int i =0 ; i < n ; i++){\\n     \\t\\ttsum += nums[i] ; \\n     \\t\\tif(nums[i] % 3 == 1){\\n     \\t\\t\\tone.push(nums[i]) ; \\n     \\t\\t}\\n     \\t\\tif(nums[i] % 3 == 2){\\n     \\t\\t\\ttwo.push(nums[i]) ; \\n     \\t\\t}\\n     \\t}\\n    \\n        // best answer \\n     \\tif(tsum % 3 == 0){\\n     \\t\\treturn tsum ; \\n     \\t}\\n\\n        \\n        // here i have 2 choices : \\n        // either subtract 1 num with remainder 1 or 2 numbers with remainder two : \\n     \\tif(tsum % 3 == 1 ){\\n     \\t\\tint first = tsum - one.top() , second = 0  ; \\n\\n     \\t\\tif(two.size() >= 2){\\n     \\t\\t\\tsecond += two.top() ;\\n     \\t\\t\\tint temp = two.top() ; \\n     \\t\\t\\ttwo.pop() ; \\n     \\t\\t\\tsecond += two.top() ; \\n     \\t\\t\\ttwo.push(temp) ; \\n     \\t\\t}\\n\\n     \\t\\tif(second == 0){\\n     \\t\\t\\treturn first ; \\n     \\t\\t}\\n\\n     \\t\\treturn max(first , tsum - second ) ; \\n     \\t}\\n\\n        \\n        // here again i have 2 choices : \\n        // subtract 1 num with remainder 2 or subtract 2 num with remainder 2 : \\n     \\tif(tsum % 3 == 2 ){\\n     \\t\\tint first = tsum - two.top() , second = 0  ; \\n\\n     \\t\\tif(one.size() >= 2){\\n     \\t\\t\\tsecond += one.top() ;\\n     \\t\\t\\tint temp = one.top() ; \\n     \\t\\t\\tone.pop() ; \\n     \\t\\t\\tsecond += one.top() ; \\n     \\t\\t\\tone.push(temp) ; \\n     \\t\\t}\\n\\n     \\t\\tif(second == 0){\\n     \\t\\t\\treturn first ; \\n     \\t\\t}\\n\\n     \\t\\treturn max(first , tsum - second ) ; \\n     \\t}\\n     \\treturn 0 ; \\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n     \\t\\n     \\tint n = nums.size() ; \\n\\n        //store the numbers which give remainder 1 , 2 when div by 3 : \\n     \\tpriority_queue<int, vector<int> , greater<int> > one ; \\n     \\tpriority_queue<int, vector<int> , greater<int> > two ; \\n\\n        \\n        \\n     \\tint  tsum = 0 ; \\n\\n/*\\n    what i am doing in the below loop : \\n    basically tsum will store the total sum of the nums \\n    \\n    3 cases arrive : either the tsum % 3 == 0 or 1 or 2 ! \\n    so the pq -> one and two will have the nums with remainder 1 and 2 respectively \\n    \\n*/\\n        \\n     \\tfor(int i =0 ; i < n ; i++){\\n     \\t\\ttsum += nums[i] ; \\n     \\t\\tif(nums[i] % 3 == 1){\\n     \\t\\t\\tone.push(nums[i]) ; \\n     \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 725484,
                "title": "c-just-math-without-dp",
                "content": "In this solution I just used math to accomplish the solution, but the problem is tagged with dp So I will try to solve it by dp too. In the given solution what I have done is I have consider three cases.\\n**1.** If whole `sum%3==0` then return sum\\n**2.** If `sum%3==1` then to have `sum%3==0` you can remove either one smallest number having mod 1 with 3 or two number having mod 2.\\n**3.** This is similar to point 2 but here removal of number is changed\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v[4];\\n        int sum=0;\\n        for(auto it:nums)\\n        {\\n            int k=it%3;\\n            v[k].push_back(it);\\n            sum+=it;\\n        }\\n        if(sum%3==0)return sum;\\n        for(int i=0;i<4;i++)\\n            sort(v[i].begin(),v[i].end());\\n        if(sum%3==1)\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>0)\\n                t1=sum-v[1][0];\\n            if(v[2].size()>1)\\n                t2=sum-v[2][0]-v[2][1];\\n            return max(t1,t2);\\n        }\\n        else\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>1)\\n                t1=sum-v[1][0]-v[1][1];\\n            if(v[2].size()>0)\\n                t2=sum-v[2][0];\\n            return max(t1,t2);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v[4];\\n        int sum=0;\\n        for(auto it:nums)\\n        {\\n            int k=it%3;\\n            v[k].push_back(it);\\n            sum+=it;\\n        }\\n        if(sum%3==0)return sum;\\n        for(int i=0;i<4;i++)\\n            sort(v[i].begin(),v[i].end());\\n        if(sum%3==1)\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>0)\\n                t1=sum-v[1][0];\\n            if(v[2].size()>1)\\n                t2=sum-v[2][0]-v[2][1];\\n            return max(t1,t2);\\n        }\\n        else\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>1)\\n                t1=sum-v[1][0]-v[1][1];\\n            if(v[2].size()>0)\\n                t2=sum-v[2][0];\\n            return max(t1,t2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650621,
                "title": "java-math-solution-o-n-time-o-1-space",
                "content": "Execution Plan :\\nWe first calculate the total sum of array . \\nif sum % 3 == 1\\nThen we can remove two elements with remainder 2 or we can remove one element with remainder 1\\nif sum % 3 == 2\\nThen we can remove two elements with remainder 1 or we can remove one element with remainder 2 \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int m1_min1 = Integer.MAX_VALUE;\\n        int m1_min2 = Integer.MAX_VALUE;\\n        int m2_min1 = Integer.MAX_VALUE;\\n        int m2_min2 = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum = sum + n;\\n            if(n % 3 == 1){\\n                if(n < m1_min1){\\n                    m1_min2 = m1_min1;\\n                    m1_min1 = n;\\n                } else if(n < m1_min2){\\n                    m1_min2 = n;\\n                }\\n            } else if(n % 3 == 2){\\n                if(n < m2_min1){\\n                    m2_min2 = m2_min1;\\n                    m2_min1 = n;\\n                } else if(n < m2_min2){\\n                    m2_min2 = n;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        int ans = 0;\\n        if(sum % 3 == 1){\\n            if(m1_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m1_min1);\\n            }\\n            if(m2_min1 < Integer.MAX_VALUE && m2_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m2_min1 - m2_min2);\\n            }\\n        }\\n        if(sum % 3 == 2){\\n            if(m2_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m2_min1);\\n            }\\n            if(m1_min1 < Integer.MAX_VALUE && m1_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m1_min1 - m1_min2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int m1_min1 = Integer.MAX_VALUE;\\n        int m1_min2 = Integer.MAX_VALUE;\\n        int m2_min1 = Integer.MAX_VALUE;\\n        int m2_min2 = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum = sum + n;\\n            if(n % 3 == 1){\\n                if(n < m1_min1){\\n                    m1_min2 = m1_min1;\\n                    m1_min1 = n;\\n                } else if(n < m1_min2){\\n                    m1_min2 = n;\\n                }\\n            } else if(n % 3 == 2){\\n                if(n < m2_min1){\\n                    m2_min2 = m2_min1;\\n                    m2_min1 = n;\\n                } else if(n < m2_min2){\\n                    m2_min2 = n;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        int ans = 0;\\n        if(sum % 3 == 1){\\n            if(m1_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m1_min1);\\n            }\\n            if(m2_min1 < Integer.MAX_VALUE && m2_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m2_min1 - m2_min2);\\n            }\\n        }\\n        if(sum % 3 == 2){\\n            if(m2_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m2_min1);\\n            }\\n            if(m1_min1 < Integer.MAX_VALUE && m1_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m1_min1 - m1_min2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601387,
                "title": "golang-short-dp-solution",
                "content": "```go\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxSumDivThree(nums []int) int {\\n    dp := [3]int{}\\n    temp := [3]int{}\\n    \\n    for _, n := range nums {\\n        temp = dp\\n        for _, sum := range temp {\\n            key := (sum+n) % 3 // reminder as key, key is index based\\n            dp[key] = max(sum+n, dp[key])\\n        }\\n    }\\n    \\n    return dp[0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxSumDivThree(nums []int) int {\\n    dp := [3]int{}\\n    temp := [3]int{}\\n    \\n    for _, n := range nums {\\n        temp = dp\\n        for _, sum := range temp {\\n            key := (sum+n) % 3 // reminder as key, key is index based\\n            dp[key] = max(sum+n, dp[key])\\n        }\\n    }\\n    \\n    return dp[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548456,
                "title": "10-lines-dp-in-python-if-you-know-what-you-are-doing",
                "content": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # key: remainder - 0, 1, or 2\\n        # value: maximum sum that can be divide by 3 with the remainer\\n        max_dict = {0: 0}\\n\\n        for n in nums:\\n            previous_max = list(max_dict.values())\\n            for p in previous_max:\\n                new_sum = p + n\\n                remainder = new_sum % 3\\n                max_dict[remainder] = max(max_dict.get(remainder, new_sum), new_sum)\\n\\n        return max_dict[0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # key: remainder - 0, 1, or 2\\n        # value: maximum sum that can be divide by 3 with the remainer\\n        max_dict = {0: 0}\\n\\n        for n in nums:\\n            previous_max = list(max_dict.values())\\n            for p in previous_max:\\n                new_sum = p + n\\n                remainder = new_sum % 3\\n                max_dict[remainder] = max(max_dict.get(remainder, new_sum), new_sum)\\n\\n        return max_dict[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520617,
                "title": "java-o-n-solution",
                "content": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[]{0, -1, -1};\\n\\n        for(int num : nums){\\n            int folds = num / 3;\\n            int remain = num % 3;\\n\\n            int[] tmp = Arrays.copyOf(dp, 3);\\n            for(int i=0; i<3; i++){\\n                if(tmp[i]!=-1){\\n                    int newKey = remain + i;\\n                    int newFolds = folds + tmp[i];\\n                    if(newKey>=3){\\n                        newKey %= 3;\\n                        newFolds++;\\n                    }\\n\\n                    dp[newKey] = Math.max(tmp[newKey], newFolds);\\n                }\\n            }\\n        }\\n\\n        return dp[0] * 3;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[]{0, -1, -1};\\n\\n        for(int num : nums){\\n            int folds = num / 3;\\n            int remain = num % 3;\\n\\n            int[] tmp = Arrays.copyOf(dp, 3);\\n            for(int i=0; i<3; i++){\\n                if(tmp[i]!=-1){\\n                    int newKey = remain + i;\\n                    int newFolds = folds + tmp[i];\\n                    if(newKey>=3){\\n                        newKey %= 3;\\n                        newFolds++;\\n                    }\\n\\n                    dp[newKey] = Math.max(tmp[newKey], newFolds);\\n                }\\n            }\\n        }\\n\\n        return dp[0] * 3;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 511448,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 32 ms, faster than 94.12% of Go online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 6.3 MB, less than 100.00% of Go online submissions for Greatest Sum Divisible by Three.\\n\\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    res := 0\\n    one := 10000\\n    two := 10000\\n    for i := 0; i < len(nums); i++ {\\n        res += nums[i]\\n        if nums[i] % 3 == 1 {\\n            two = min(two, one + nums[i])\\n            one = min(one, nums[i])\\n        }\\n        if nums[i] % 3 == 2 {\\n            one = min(one, two + nums[i])\\n            two = min(two, nums[i])\\n        }\\n    }\\n    if res % 3 == 0 { return res }\\n    if res % 3 == 1 { return res - one }\\n    return res - two\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\\n\\n>Runtime: 32 ms, faster than 94.12% of Go online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 6.3 MB, less than 100.00% of Go online submissions for Greatest Sum Divisible by Three.\\n\\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    dp := make([]int, 3)\\n    for _, v := range nums {\\n        tmp := make([]int, 3)\\n        copy(tmp, dp)\\n        for i := 0; i < 3; i++ {\\n            dp[(v + tmp[i]) % 3] = max(dp[(v + tmp[i]) % 3], v + tmp[i])\\n        }\\n    }\\n    return dp[0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxSumDivThree(nums []int) int {\\n    res := 0\\n    one := 10000\\n    two := 10000\\n    for i := 0; i < len(nums); i++ {\\n        res += nums[i]\\n        if nums[i] % 3 == 1 {\\n            two = min(two, one + nums[i])\\n            one = min(one, nums[i])\\n        }\\n        if nums[i] % 3 == 2 {\\n            one = min(one, two + nums[i])\\n            two = min(two, nums[i])\\n        }\\n    }\\n    if res % 3 == 0 { return res }\\n    if res % 3 == 1 { return res - one }\\n    return res - two\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    dp := make([]int, 3)\\n    for _, v := range nums {\\n        tmp := make([]int, 3)\\n        copy(tmp, dp)\\n        for i := 0; i < 3; i++ {\\n            dp[(v + tmp[i]) % 3] = max(dp[(v + tmp[i]) % 3], v + tmp[i])\\n        }\\n    }\\n    return dp[0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458559,
                "title": "o-n-math-solution-no-dp",
                "content": "Get the sum of all numbers in the array first. Then we have 3 cases:\\n1. If sum % 3 == 0\\n    return sum directly.\\n2. If sum % 3 == 1\\n    What we want to do is to find out the smallest sub array in the origin array whose sum mod 3 is also 1.\\n\\tSo that we can get the final answer: sum - sub_sum.\\n\\tThe only 2 cases for the sub_sum which mod 3 is 1:\\n    * \\tThe smallest number which mod 3 is 1.\\n    * \\tThe smallest 2 numbers which mod 3 is 2. (if a % 3 == 2 and b % 3 == 2, (a + b) % 3 will be 1)\\n    \\n\\tOnce we get above 2 sub sums, just need to compare which one is smaller and minus this sub sum.\\n3. If sum % 3 == 2\\n    The same idea as #2.\\n\\n\\nAdd an example here.\\n\\nIf we have an array like: 7, 5, 4, 2, 9, 10, 6, 3, 1.\\nThe solution here is to sum up all the numbers together, which is 47.\\nAnd also get the smallest 2 numbers who mod 3 is 1 and 2, which are `min_remain_one`= 1, `min_remain_one_2`= 4 and `min_remain_two`= 2, `min_remain_two_2`= 5.\\nAs 47 mod 3 is 2, then we compare `min_remain_two`= 2 with `min_remain_one` + `min_remain_one_2` = 5, get `min_remain_two` is smaller. So that the final result is 47 - 2 = 45.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int min_remain_one = INT_MAX;\\n        int min_remain_two = INT_MAX;\\n        int min_remain_one_2 = INT_MAX;\\n        int min_remain_two_2 = INT_MAX;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            int remain = num % 3;\\n            \\n            switch (remain) {\\n                case 1:\\n                    if (num <= min_remain_one) {\\n                        min_remain_one_2 = min_remain_one;\\n                        min_remain_one = num;\\n                    } else if (num <= min_remain_one_2) {\\n                        min_remain_one_2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num <= min_remain_two) {\\n                        min_remain_two_2 = min_remain_two;\\n                        min_remain_two = num;\\n                    } else if (num <= min_remain_two_2) {\\n                        min_remain_two_2 = num;\\n                    }\\n                    break;\\n            }\\n            \\n            sum += num;\\n        }\\n        \\n        if (sum % 3 == 1) {\\n            if (min_remain_two == INT_MAX || min_remain_two_2 == INT_MAX)\\n                sum -= min_remain_one;\\n            else\\n                sum -= min(min_remain_one, min_remain_two + min_remain_two_2);\\n        } else if (sum % 3 == 2) {\\n            if (min_remain_one == INT_MAX || min_remain_one_2 == INT_MAX)\\n                sum -= min_remain_two;\\n            else\\n                sum -= min(min_remain_two, min_remain_one + min_remain_one_2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int min_remain_one = INT_MAX;\\n        int min_remain_two = INT_MAX;\\n        int min_remain_one_2 = INT_MAX;\\n        int min_remain_two_2 = INT_MAX;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            int remain = num % 3;\\n            \\n            switch (remain) {\\n                case 1:\\n                    if (num <= min_remain_one) {\\n                        min_remain_one_2 = min_remain_one;\\n                        min_remain_one = num;\\n                    } else if (num <= min_remain_one_2) {\\n                        min_remain_one_2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num <= min_remain_two) {\\n                        min_remain_two_2 = min_remain_two;\\n                        min_remain_two = num;\\n                    } else if (num <= min_remain_two_2) {\\n                        min_remain_two_2 = num;\\n                    }\\n                    break;\\n            }\\n            \\n            sum += num;\\n        }\\n        \\n        if (sum % 3 == 1) {\\n            if (min_remain_two == INT_MAX || min_remain_two_2 == INT_MAX)\\n                sum -= min_remain_one;\\n            else\\n                sum -= min(min_remain_one, min_remain_two + min_remain_two_2);\\n        } else if (sum % 3 == 2) {\\n            if (min_remain_one == INT_MAX || min_remain_one_2 == INT_MAX)\\n                sum -= min_remain_two;\\n            else\\n                sum -= min(min_remain_two, min_remain_one + min_remain_one_2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433078,
                "title": "java-dp-explained",
                "content": "Problem can be solved with DP. The parameter we can use is the modulo of the sum. 3 possible values, and for each element of the array (from j to N - 1). Optimize by max sum for each modulo.\\nO(n) time - need to check every element of the array 3 times. O(n) space - dp array proportional to number of elements \\n\\n```\\n    public int maxSumDivThree(int[] nums) {\\n        int N = nums.length;\\n        //create array i,j will be max sum from i to end with modulo 3 == j\\n        int[][] dp = new int[N][3];\\n        //init with the last array element\\n        dp[N - 1][nums[N - 1] % 3] = nums[N - 1];\\n        //starting from the second from the end element do the dp loop\\n        for (int i = N - 2; i >= 0; i--) {\\n            //copy max sums from the previous step\\n            for (int j =0; j < 3; j++)\\n                dp[i][j] = dp[i +1][j];\\n            //for each modulo 3 value\\n            for (int j = 0; j < 3; j++) {\\n                //get previous sum for modulo j and add nums[i]\\n                int s = dp[i + 1][j] + nums[i];\\n                //then put to the s % 3 element max between s and the sum for the same modulo\\n                //from the previous step\\n                dp[i][s % 3] = Math.max(s, dp[i][s % 3]);\\n            }\\n        }\\n        //result always be in 0,0 - max sum with modulo 3\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int N = nums.length;\\n        //create array i,j will be max sum from i to end with modulo 3 == j\\n        int[][] dp = new int[N][3];\\n        //init with the last array element\\n        dp[N - 1][nums[N - 1] % 3] = nums[N - 1];\\n        //starting from the second from the end element do the dp loop\\n        for (int i = N - 2; i >= 0; i--) {\\n            //copy max sums from the previous step\\n            for (int j =0; j < 3; j++)\\n                dp[i][j] = dp[i +1][j];\\n            //for each modulo 3 value\\n            for (int j = 0; j < 3; j++) {\\n                //get previous sum for modulo j and add nums[i]\\n                int s = dp[i + 1][j] + nums[i];\\n                //then put to the s % 3 element max between s and the sum for the same modulo\\n                //from the previous step\\n                dp[i][s % 3] = Math.max(s, dp[i][s % 3]);\\n            }\\n        }\\n        //result always be in 0,0 - max sum with modulo 3\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431189,
                "title": "java-easy-to-understand-o-n-solution-with-o-1-space-3ms",
                "content": "Idea is to maintain 2 minimum numbers having mod%3 == 1 and 2 minimum numbers having mod%3 == 2. Then after calculating total sum, answer would be - \\n\\t-> totalSum, if divisible by 3\\n\\t-> totalSum - min{min num having mod%3 == 1, sum of min two nums having mod%3 == 2}, if totalSum%3 == 1\\n\\t-> totalSum - min{min num having mod%3 == 2, sum of min two nums having mod%3 == 1}, if totalSum%3 == 2\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) \\n            return 0;\\n        \\n        int maxSum = 0;\\n        int mod1Min1 = Integer.MAX_VALUE, mod1Min2 = Integer.MAX_VALUE;\\n        int mod2Min1 = Integer.MAX_VALUE, mod2Min2 = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            maxSum += num;\\n\\n            switch (num%3) {\\n                case 1:\\n                    if (num < mod1Min1) {\\n                        mod1Min2 = mod1Min1;\\n                        mod1Min1 = num;\\n                    } else if (num < mod1Min2) {\\n                        mod1Min2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num < mod2Min1) {\\n                        mod2Min2 = mod2Min1;\\n                        mod2Min1 = num;\\n                    } else if (num < mod2Min2) {\\n                        mod2Min2 = num;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        if (maxSum%3 == 1) {\\n            return maxSum - Math.min(mod1Min1, mod2Min2 != Integer.MAX_VALUE? mod2Min1+mod2Min2 : Integer.MAX_VALUE);\\n        }\\n        if (maxSum%3 == 2) {\\n            return maxSum - Math.min(mod1Min2 != Integer.MAX_VALUE? mod1Min1+mod1Min2 : Integer.MAX_VALUE, mod2Min1);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) \\n            return 0;\\n        \\n        int maxSum = 0;\\n        int mod1Min1 = Integer.MAX_VALUE, mod1Min2 = Integer.MAX_VALUE;\\n        int mod2Min1 = Integer.MAX_VALUE, mod2Min2 = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            maxSum += num;\\n\\n            switch (num%3) {\\n                case 1:\\n                    if (num < mod1Min1) {\\n                        mod1Min2 = mod1Min1;\\n                        mod1Min1 = num;\\n                    } else if (num < mod1Min2) {\\n                        mod1Min2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num < mod2Min1) {\\n                        mod2Min2 = mod2Min1;\\n                        mod2Min1 = num;\\n                    } else if (num < mod2Min2) {\\n                        mod2Min2 = num;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        if (maxSum%3 == 1) {\\n            return maxSum - Math.min(mod1Min1, mod2Min2 != Integer.MAX_VALUE? mod2Min1+mod2Min2 : Integer.MAX_VALUE);\\n        }\\n        if (maxSum%3 == 2) {\\n            return maxSum - Math.min(mod1Min2 != Integer.MAX_VALUE? mod1Min1+mod1Min2 : Integer.MAX_VALUE, mod2Min1);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431175,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        List<Integer> oneList = new ArrayList<>();\\n        List<Integer> twoList = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num % 3 == 1) oneList.add(num);\\n            if (num % 3 == 2) twoList.add(num);\\n            sum += num;\\n        }\\n        if (sum % 3 == 0) return sum;\\n        else {\\n            Collections.sort(oneList);\\n            Collections.sort(twoList);\\n            \\n            if (sum % 3 == 1) {\\n                if (oneList.size() < 1 && twoList.size() < 2) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 1) minSubtract = Math.min(minSubtract, oneList.get(0));\\n                if (twoList.size() >= 2) minSubtract = Math.min(minSubtract, twoList.get(0) + twoList.get(1));\\n                return sum - minSubtract;\\n            } else { // %3 == 2\\n                if (oneList.size() < 2 && twoList.size() < 1) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 2) minSubtract = Math.min(minSubtract, oneList.get(0) + oneList.get(1));\\n                if (twoList.size() >= 1) minSubtract = Math.min(minSubtract, twoList.get(0));\\n                return sum - minSubtract;\\n            }            \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        List<Integer> oneList = new ArrayList<>();\\n        List<Integer> twoList = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num % 3 == 1) oneList.add(num);\\n            if (num % 3 == 2) twoList.add(num);\\n            sum += num;\\n        }\\n        if (sum % 3 == 0) return sum;\\n        else {\\n            Collections.sort(oneList);\\n            Collections.sort(twoList);\\n            \\n            if (sum % 3 == 1) {\\n                if (oneList.size() < 1 && twoList.size() < 2) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 1) minSubtract = Math.min(minSubtract, oneList.get(0));\\n                if (twoList.size() >= 2) minSubtract = Math.min(minSubtract, twoList.get(0) + twoList.get(1));\\n                return sum - minSubtract;\\n            } else { // %3 == 2\\n                if (oneList.size() < 2 && twoList.size() < 1) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 2) minSubtract = Math.min(minSubtract, oneList.get(0) + oneList.get(1));\\n                if (twoList.size() >= 1) minSubtract = Math.min(minSubtract, twoList.get(0));\\n                return sum - minSubtract;\\n            }            \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431153,
                "title": "java-one-pass-o-n-time-o-1-space-solution",
                "content": "Use 2 PriorityQueue with size of 2. Space is O(1). The priority queue insertion is O(pq.size()) for time complexity, namely O(1).\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> ones = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 1\\n        PriorityQueue<Integer> twos = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 2\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                updatePQ(ones, num);\\n            } else if (num % 3 == 2) {\\n                updatePQ(twos, num);\\n            }\\n        }\\n        int sum1 = 0, sum2 = 0;\\n        if (sum % 3 == 0) {\\n            return sum;\\n        } else if (sum % 3 == 1) {\\n            if (twos.size() == 2) {\\n                sum2 = sum - twos.poll() - twos.poll();\\n            }\\n            if (!ones.isEmpty()) {\\n                if (ones.size() == 2) {\\n                    ones.poll();\\n                }\\n                sum1 = sum - ones.poll();\\n            }\\n        } else {\\n            if (ones.size() == 2) {\\n                sum1 = sum - ones.poll() - ones.poll();\\n            }\\n            if (!twos.isEmpty()) {\\n                if (twos.size() == 2) {\\n                    twos.poll();\\n                }\\n                sum2 = sum - twos.poll();\\n            }\\n        }\\n        return Math.max(sum1, sum2);\\n    }\\n    \\n    private void updatePQ(PriorityQueue<Integer> pq, int num) {\\n        pq.offer(num);\\n        if (pq.size() > 2) {\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> ones = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 1\\n        PriorityQueue<Integer> twos = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 2\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                updatePQ(ones, num);\\n            } else if (num % 3 == 2) {\\n                updatePQ(twos, num);\\n            }\\n        }\\n        int sum1 = 0, sum2 = 0;\\n        if (sum % 3 == 0) {\\n            return sum;\\n        } else if (sum % 3 == 1) {\\n            if (twos.size() == 2) {\\n                sum2 = sum - twos.poll() - twos.poll();\\n            }\\n            if (!ones.isEmpty()) {\\n                if (ones.size() == 2) {\\n                    ones.poll();\\n                }\\n                sum1 = sum - ones.poll();\\n            }\\n        } else {\\n            if (ones.size() == 2) {\\n                sum1 = sum - ones.poll() - ones.poll();\\n            }\\n            if (!twos.isEmpty()) {\\n                if (twos.size() == 2) {\\n                    twos.poll();\\n                }\\n                sum2 = sum - twos.poll();\\n            }\\n        }\\n        return Math.max(sum1, sum2);\\n    }\\n    \\n    private void updatePQ(PriorityQueue<Integer> pq, int num) {\\n        pq.offer(num);\\n        if (pq.size() > 2) {\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431085,
                "title": "c-greedy-solution-with-explaination",
                "content": "1) By seeing the constraints, it is clear that a dp approach of the order of N ^ 2 cannot be applied(just like coin change or subset sum(N ^ 2)). By the way, others have done it using dp in linear time complexity.\\n2) Therefore, we have to think greedily. \\n3) If total sum is divisible by 3, then we do not need to remove any element and the entire sum is our answer.\\n4) On the other hand, if sum is either 1 or 2, then we need to remove the smallest possible sum from the total.\\n5) For total % 3 = 1, we have two options, either to remove two smallest number with % 3 = 2 or the smallest number with % 3  = 1.\\n6) Similarily, for total % 3 = 2, we have two options, either to remove two smallest number with % 3 = 1 or the smallest number with % 3  = 2.\\n\\nWe can do it without sorting as well. Finding smallest and second smallest element in O(N) is also quite easy.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int sum = 0;\\n        mp[0] = 0;\\n        int mx = 0;\\n        vector<int> v1, v2;\\n        int sm1 = INT_MAX, sm2 = INT_MAX;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(nums[i] % 3 == 1) {\\n                v1.push_back(nums[i]);\\n            }\\n            if(nums[i] % 3 == 2) {\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int mn11, mn12, mn21, mn22;\\n        mn11 = mn21 = mn12 = mn22 = INT_MAX;\\n        if(v1.size()) {\\n            mn11 = v1[0];\\n        }\\n        if(v1.size() > 1) {\\n            mn12 = v1[1];\\n        }\\n        if(v2.size()) {\\n            mn21 = v2[0];\\n        }\\n        if(v2.size() > 1) {\\n            mn22 = v2[1];\\n        }\\n        if(sum % 3 == 0) {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1) {\\n            int ans = 0;\\n            if(mn11 != INT_MAX) {\\n                ans = sum - mn11;\\n            }\\n            if(mn21 != INT_MAX && mn22 != INT_MAX) {\\n                ans = max(ans, sum - mn21 - mn22);\\n            }\\n            return ans;\\n        }\\n        else if(sum % 3 == 2) {\\n            int ans = 0;\\n            if(mn21 !=INT_MAX) {\\n                ans = sum - mn21;\\n            }\\n            if(mn11 != INT_MAX && mn12 != INT_MAX) {\\n                ans = max(ans, sum - mn11 - mn12);\\n            }\\n            return ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int sum = 0;\\n        mp[0] = 0;\\n        int mx = 0;\\n        vector<int> v1, v2;\\n        int sm1 = INT_MAX, sm2 = INT_MAX;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(nums[i] % 3 == 1) {\\n                v1.push_back(nums[i]);\\n            }\\n            if(nums[i] % 3 == 2) {\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int mn11, mn12, mn21, mn22;\\n        mn11 = mn21 = mn12 = mn22 = INT_MAX;\\n        if(v1.size()) {\\n            mn11 = v1[0];\\n        }\\n        if(v1.size() > 1) {\\n            mn12 = v1[1];\\n        }\\n        if(v2.size()) {\\n            mn21 = v2[0];\\n        }\\n        if(v2.size() > 1) {\\n            mn22 = v2[1];\\n        }\\n        if(sum % 3 == 0) {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1) {\\n            int ans = 0;\\n            if(mn11 != INT_MAX) {\\n                ans = sum - mn11;\\n            }\\n            if(mn21 != INT_MAX && mn22 != INT_MAX) {\\n                ans = max(ans, sum - mn21 - mn22);\\n            }\\n            return ans;\\n        }\\n        else if(sum % 3 == 2) {\\n            int ans = 0;\\n            if(mn21 !=INT_MAX) {\\n                ans = sum - mn21;\\n            }\\n            if(mn11 != INT_MAX && mn12 != INT_MAX) {\\n                ans = max(ans, sum - mn11 - mn12);\\n            }\\n            return ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567033,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103419,
                "title": "python-greedy-heap",
                "content": "# Intuition\\nIn order to maximize sum divisible by 3, we need to minimize sum of items, which give the same remainder as the whole array sum.\\n\\n# Approach\\n1. Check whole array sum remainder.\\n- If it is ``0`` then return whole array sum\\n- Otherwise check the remainder - either ``1`` or ``2``\\n2. Build two min-heaps for each of the remainders of size ``2``\\n3. Check different cases for each remainder:\\n- ``1`` is either smallest remainder-1 value or sum of two smallest remainder-2 values\\n- ``2`` is either smallest remainder-2 value or sum of two smallest remainder-1 values\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        r = s % 3\\n        if r == 0:\\n            return s\\n        h1, h2 = [], []\\n        for v in nums:\\n            if v % 3 == 1:\\n                if len(h1) < 2:\\n                    heapq.heappush(h1, -v)\\n                elif v < -h1[0]:\\n                    heapq.heappop(h1)\\n                    heapq.heappush(h1, -v)\\n            elif v % 3 == 2:\\n                if len(h2) < 2:\\n                    heapq.heappush(h2, -v)\\n                elif v < -h2[0]:\\n                    heapq.heappop(h2)\\n                    heapq.heappush(h2, -v)\\n\\n        r11, r12 = -heapq.heappop(h1) if h1 else s, -heapq.heappop(h1) if h1 else s\\n        r21, r22 = -heapq.heappop(h2) if h2 else s, -heapq.heappop(h2) if h2 else s\\n\\n        if r == 1:\\n            return s - min(r12, r11, r21+r22)\\n\\n        return s - min(r11 + r12, r22, r21)",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "# Intuition\\nIn order to maximize sum divisible by 3, we need to minimize sum of items, which give the same remainder as the whole array sum.\\n\\n# Approach\\n1. Check whole array sum remainder.\\n- If it is ``0`` then return whole array sum\\n- Otherwise check the remainder - either ``1`` or ``2``\\n2. Build two min-heaps for each of the remainders of size ``2``\\n3. Check different cases for each remainder:\\n- ``1`` is either smallest remainder-1 value or sum of two smallest remainder-2 values\\n- ``2`` is either smallest remainder-2 value or sum of two smallest remainder-1 values\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        r = s % 3\\n        if r == 0:\\n            return s\\n        h1, h2 = [], []\\n        for v in nums:\\n            if v % 3 == 1:\\n                if len(h1) < 2:\\n                    heapq.heappush(h1, -v)\\n                elif v < -h1[0]:\\n                    heapq.heappop(h1)\\n                    heapq.heappush(h1, -v)\\n            elif v % 3 == 2:\\n                if len(h2) < 2:\\n                    heapq.heappush(h2, -v)\\n                elif v < -h2[0]:\\n                    heapq.heappop(h2)\\n                    heapq.heappush(h2, -v)\\n\\n        r11, r12 = -heapq.heappop(h1) if h1 else s, -heapq.heappop(h1) if h1 else s\\n        r21, r22 = -heapq.heappop(h2) if h2 else s, -heapq.heappop(h2) if h2 else s\\n\\n        if r == 1:\\n            return s - min(r12, r11, r21+r22)\\n\\n        return s - min(r11 + r12, r22, r21)",
                "codeTag": "Java"
            },
            {
                "id": 2971208,
                "title": "python-very-easy-solution",
                "content": "# Complexity\\n- Time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0] * 3\\n        for v in nums:\\n            a, b, c = dp[0] + v, dp[1] + v, dp[2] + v\\n            dp[a % 3] = max(dp[a % 3], a)\\n            dp[b % 3] = max(dp[b % 3], b)\\n            dp[c % 3] = max(dp[c % 3], c)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0] * 3\\n        for v in nums:\\n            a, b, c = dp[0] + v, dp[1] + v, dp[2] + v\\n            dp[a % 3] = max(dp[a % 3], a)\\n            dp[b % 3] = max(dp[b % 3], b)\\n            dp[c % 3] = max(dp[c % 3], c)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500253,
                "title": "c-o-n-dp-tabulation-easy-to-understand",
                "content": "**Dynamic Programming Approach!!**\\n**(Tabulation)**\\nTime Complexity:- O(N)\\nSpace Complexity:- O(N) \\n    \\nclass Solution {\\npublic:\\n   \\n    int maxSumDivThree(vector<int>& nums) {\\n\\t\\n        // dp vector for storing number with remainder {0,1,2}\\n        vector<int> dp={0,INT_MIN,INT_MIN};\\n        \\n        for(auto i: nums){\\n            vector<int> tmp(3);\\n            \\n            for(int j=0;j<3;j++){\\n                tmp[(j+i)%3]=max(dp[(j+i)%3],dp[j]+i);\\n            }\\n            \\n            dp=tmp;\\n        }\\n        \\n        // Returning the Greatest sum\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int maxSumDivThree(vector<int>& nums) {\\n\\t\\n        // dp vector for storing number with remainder {0,1,2}",
                "codeTag": "Java"
            },
            {
                "id": 2335142,
                "title": "o-n-o-1-solution",
                "content": "**SC: O(1) TC: O(N)**\\nFor any number if we divide it by 3 there will be 3 case ->1. a%3== 0,1,2.\\nnow if you want to get any sum that divisable by 3, then its sum%3=0;\\nnow if .\\na+b+c%3==0\\n&& a+b%3=2 then c%3=1 is certain ie the reminder sum should be 0 or 3.. 3%3=0\\n\\n```\\nclass Solution {\\n\\n    public int maxSumDivThree(int[] nums) {\\n        int r0 = 0;\\n        int r1 = 0;\\n        int r2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int nr0 = r0;\\n            int nr1 = r1;\\n            int nr2 = r2;\\n            int a = r0 + nums[i];\\n            int b = r1 + nums[i];\\n            int c = r2 + nums[i];\\n            if (a % 3 == 0) {\\n                nr0 = Math.max(nr0, a);\\n            } else if (a % 3 == 1) {\\n                nr1 = Math.max(nr1, a);\\n            } else if (a % 3 == 2) {\\n                nr2 = Math.max(nr2, a);\\n            }\\n\\n            if (b % 3 == 0) {\\n                nr0 = Math.max(nr0, b);\\n            } else if (b % 3 == 1) {\\n                nr1 = Math.max(nr1, b);\\n            } else if (b % 3 == 2) {\\n                nr2 = Math.max(nr2, b);\\n            }\\n            \\n            if (c % 3 == 0) {\\n                nr0 = Math.max(nr0, c);\\n            } else if (c % 3 == 1) {\\n                nr1 = Math.max(nr1, c);\\n            } else if (c % 3 == 2) {\\n                nr2 = Math.max(nr2, c);\\n            }\\n            r0=nr0;\\n            r1=nr1;\\n            r2=nr2;\\n        }\\n        \\n        return r0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxSumDivThree(int[] nums) {\\n        int r0 = 0;\\n        int r1 = 0;\\n        int r2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int nr0 = r0;\\n            int nr1 = r1;\\n            int nr2 = r2;\\n            int a = r0 + nums[i];\\n            int b = r1 + nums[i];\\n            int c = r2 + nums[i];\\n            if (a % 3 == 0) {\\n                nr0 = Math.max(nr0, a);\\n            } else if (a % 3 == 1) {\\n                nr1 = Math.max(nr1, a);\\n            } else if (a % 3 == 2) {\\n                nr2 = Math.max(nr2, a);\\n            }\\n\\n            if (b % 3 == 0) {\\n                nr0 = Math.max(nr0, b);\\n            } else if (b % 3 == 1) {\\n                nr1 = Math.max(nr1, b);\\n            } else if (b % 3 == 2) {\\n                nr2 = Math.max(nr2, b);\\n            }\\n            \\n            if (c % 3 == 0) {\\n                nr0 = Math.max(nr0, c);\\n            } else if (c % 3 == 1) {\\n                nr1 = Math.max(nr1, c);\\n            } else if (c % 3 == 2) {\\n                nr2 = Math.max(nr2, c);\\n            }\\n            r0=nr0;\\n            r1=nr1;\\n            r2=nr2;\\n        }\\n        \\n        return r0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327947,
                "title": "python-dp",
                "content": "dp[0]: max sum which mods 3 = 0\\ndp[1]: max sum which mods 3 = 1\\ndp[2]: max sum which mods 3 = 2\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0, float(\\'-inf\\'), float(\\'-inf\\')] \\n        for x in nums:\\n            dp_cp = dp[:]\\n            for left in range(3):\\n                right = (left + x) % 3\\n                dp[right] = max(dp_cp[right], dp_cp[left] + x)\\n            \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0, float(\\'-inf\\'), float(\\'-inf\\')] \\n        for x in nums:\\n            dp_cp = dp[:]\\n            for left in range(3):\\n                right = (left + x) % 3\\n                dp[right] = max(dp_cp[right], dp_cp[left] + x)\\n            \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175452,
                "title": "tabulation-memo-c",
                "content": "```class Solution {\\npublic:\\n    #define ll long long\\n//     ll rec(int i,int k,vector<int>&nums){\\n//         if(i<0){\\n//             if(k==0)return 0;\\n//             else return INT_MIN;\\n//         }\\n//         if(dp[i][k]!=-1)return dp[i][k];\\n//         ll a=nums[i]+rec(i-1,(k+nums[i])%3,nums);\\n//         ll b=rec(i-1,k,nums);\\n        \\n//         return dp[i][k]=max(a,b);\\n//     }\\n    int maxSumDivThree(vector<int>&nums){\\n        ll n=nums.size();\\n        vector<vector<ll>>dp(n+1,vector<ll>(3,INT_MIN));\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=2;j++){\\n                ll a=nums[i-1]+dp[i-1][(j+nums[i-1])%3];\\n                ll b=dp[i-1][j];\\n                dp[i][j]=max(a,b);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n//     ll rec(int i,int k,vector<int>&nums){\\n//         if(i<0){\\n//             if(k==0)return 0;\\n//             else return INT_MIN;\\n//         }",
                "codeTag": "Java"
            },
            {
                "id": 2104456,
                "title": "dp-but-less-confusing-essentially-using-just-3-variables",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int[] dp = new int[3]; // index for each of the type of remainder we can get when divide a number by 3\\n        for (int i = 0; i < nums.length;i++) {\\n            \\n            //3 possible remainders are 0,1,2\\n            // array indices indicate the remainders\\n            // add the current number to each of the value in dp[index]\\n            // take the remainder of the new sum against those 3 numbers \\n            int threes = dp[0] + nums[i];\\n            int ones = dp[1] + nums[i];\\n            int twos = dp[2] + nums[i];\\n            // if the existing value against sum%3 is lesser then copy that number.\\n            if(threes > dp[threes%3]) dp[threes%3] = threes;\\n            if(ones > dp[ones%3]) dp[ones%3] = ones;\\n            if(twos > dp[twos%3]) dp[twos%3] = twos;\\n        }\\n        //finally we are asked to produce the max sum divisible by 3.\\n        return dp[0];\\n        //if we were asked to produce max sum with remainder 1 then dp[1] or \\n        //if we are asked about 2 remainder than dp[2] will be the values to be returned.\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int[] dp = new int[3]; // index for each of the type of remainder we can get when divide a number by 3\\n        for (int i = 0; i < nums.length;i++) {\\n            \\n            //3 possible remainders are 0,1,2\\n            // array indices indicate the remainders\\n            // add the current number to each of the value in dp[index]\\n            // take the remainder of the new sum against those 3 numbers \\n            int threes = dp[0] + nums[i];\\n            int ones = dp[1] + nums[i];\\n            int twos = dp[2] + nums[i];\\n            // if the existing value against sum%3 is lesser then copy that number.\\n            if(threes > dp[threes%3]) dp[threes%3] = threes;\\n            if(ones > dp[ones%3]) dp[ones%3] = ones;\\n            if(twos > dp[twos%3]) dp[twos%3] = twos;\\n        }\\n        //finally we are asked to produce the max sum divisible by 3.\\n        return dp[0];\\n        //if we were asked to produce max sum with remainder 1 then dp[1] or \\n        //if we are asked about 2 remainder than dp[2] will be the values to be returned.\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966731,
                "title": "python",
                "content": "\\n    def maxSumDivThree(self, nums):\\n        n = len(nums)\\n        \\n        dp = [[0]*3 for _ in range(n)]\\n        \\n        if nums[0]%3 == 0:\\n            dp[0][0] = nums[0]\\n        elif nums[0]%3 == 1:\\n            dp[0][1] = nums[0]\\n        else:\\n            dp[0][2] = nums[0]\\n            \\n        for i in range(1,n):\\n            x = dp[i-1][0] + nums[i]\\n            y = dp[i-1][1] + nums[i]\\n            z = dp[i-1][2] + nums[i]\\n            \\n            dp[i] = dp[i-1]\\n            \\n            dp[i][x%3] = max(x, dp[i][x%3])\\n            dp[i][y%3] = max(y, dp[i][y%3])\\n            dp[i][z%3] = max(z, dp[i][z%3])\\n            \\n        return dp[n-1][0]",
                "solutionTags": [],
                "code": "\\n    def maxSumDivThree(self, nums):\\n        n = len(nums)\\n        \\n        dp = [[0]*3 for _ in range(n)]\\n        \\n        if nums[0]%3 == 0:\\n            dp[0][0] = nums[0]\\n        elif nums[0]%3 == 1:\\n            dp[0][1] = nums[0]\\n        else:\\n            dp[0][2] = nums[0]\\n            \\n        for i in range(1,n):\\n            x = dp[i-1][0] + nums[i]\\n            y = dp[i-1][1] + nums[i]\\n            z = dp[i-1][2] + nums[i]\\n            \\n            dp[i] = dp[i-1]\\n            \\n            dp[i][x%3] = max(x, dp[i][x%3])\\n            dp[i][y%3] = max(y, dp[i][y%3])\\n            dp[i][z%3] = max(z, dp[i][z%3])\\n            \\n        return dp[n-1][0]",
                "codeTag": "Python3"
            },
            {
                "id": 1756168,
                "title": "o-n-time-begineer-friendly-solution-c-solution",
                "content": "````\\nint maxSumDivThree(vector<int>& nums) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum%3==0)\\n        return sum;\\n        else\\n        {\\n          vector<int> p,q,r;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n            if(nums[i]%3==0) r.push_back(nums[i]);\\n            else if(nums[i]%3==1) p.push_back(nums[i]);\\n            else q.push_back(nums[i]);\\n          }\\n          sort(p.begin(),p.end());\\n          sort(q.begin(),q.end());\\n          sort(r.begin(),r.end());\\n          if(sum%3==1)\\n          {\\n            if(p.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              int res=sum;\\n              if(q.size()>=2) res-=(q[0]+q[1]);\\n              else res=0;\\n              return max({temp,sum-p[0],res});\\n            }\\n          }\\n          else\\n          {\\n            if(q.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              int res=sum;\\n              if(p.size()>=2) res-=(p[0]+p[1]);\\n              else res=0;\\n              return max({temp,sum-q[0],res});\\n            }\\n          }\\n        }\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "````\\nint maxSumDivThree(vector<int>& nums) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum%3==0)\\n        return sum;\\n        else\\n        {\\n          vector<int> p,q,r;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n            if(nums[i]%3==0) r.push_back(nums[i]);\\n            else if(nums[i]%3==1) p.push_back(nums[i]);\\n            else q.push_back(nums[i]);\\n          }\\n          sort(p.begin(),p.end());\\n          sort(q.begin(),q.end());\\n          sort(r.begin(),r.end());\\n          if(sum%3==1)\\n          {\\n            if(p.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              int res=sum;\\n              if(q.size()>=2) res-=(q[0]+q[1]);\\n              else res=0;\\n              return max({temp,sum-p[0],res});\\n            }\\n          }\\n          else\\n          {\\n            if(q.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              int res=sum;\\n              if(p.size()>=2) res-=(p[0]+p[1]);\\n              else res=0;\\n              return max({temp,sum-q[0],res});\\n            }\\n          }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1744087,
                "title": "c-dynamic-programming-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    int recurr(vector<int>&nums, int i, int len, int sum, vector<vector<int>>&dp,int mod)\\n    {\\n        \\n        if(i >= len)\\n        {\\n          \\n           if(mod%3 == 0)\\n           {\\n               return 0;\\n           }\\n            return INT_MIN;\\n        }\\n       if(dp[i][mod] != 0)\\n        {\\n         \\n           return dp[i][mod];\\n       }\\n    \\n       int a = nums[i] + recurr(nums, i+1, len, sum+nums[i], dp, (mod+nums[i])%3);\\n       int b = recurr(nums, i+1, len, sum,dp,mod);\\n       return dp[i][mod] = max(a,b);\\n        \\n    }\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(), vector<int>(3,0));\\n       int a = recurr(nums,0,nums.size(),0,dp,0);\\n        return a;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int recurr(vector<int>&nums, int i, int len, int sum, vector<vector<int>>&dp,int mod)\\n    {\\n        \\n        if(i >= len)\\n        {\\n          \\n           if(mod%3 == 0)\\n           {\\n               return 0;\\n           }\\n            return INT_MIN;\\n        }\\n       if(dp[i][mod] != 0)\\n        {\\n         \\n           return dp[i][mod];\\n       }\\n    \\n       int a = nums[i] + recurr(nums, i+1, len, sum+nums[i], dp, (mod+nums[i])%3);\\n       int b = recurr(nums, i+1, len, sum,dp,mod);\\n       return dp[i][mod] = max(a,b);\\n        \\n    }\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(), vector<int>(3,0));\\n       int a = recurr(nums,0,nums.size(),0,dp,0);\\n        return a;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620607,
                "title": "java-o-1-space-one-pass-10-lines-comments",
                "content": "Let `dp[0]` be the largest sum up to a given index that is divisible by 3, `dp[1]` be largest sum up to a given index that has the form of `3n + 1`, and `dp[2]` be the largest sum up to a given index that has the form of `3n + 2`, then we have the following reocurring relationship `dp[i] = Math.max(dp[i], dp[complement] + nums[i]`. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[nums[0] % 3] = nums[0]; //base case\\n\\n        for (int i = 1; i < nums.length; i++){\\n            int complement = nums[i] % 3 == 0? 0 : 3 - nums[i] % 3; //complement idx \\n            int zero = Math.max(dp[0], dp[complement] + nums[i]); // reoccuring relationship\\n            int one  = Math.max(dp[1], dp[++complement % 3] + nums[i]);\\n            int two  = Math.max(dp[2], dp[++complement % 3] + nums[i]);\\n            dp[0] = zero;\\n\\t\\t\\t//dp[1] and dp[2] initializtion may not be %3 == 1 and %3 == 2 respectively, so we need to check.\\n            dp[1] = one % 3 == 1? one : dp[1]; \\n            dp[2] = two % 3 == 2? two : dp[2];\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[nums[0] % 3] = nums[0]; //base case\\n\\n        for (int i = 1; i < nums.length; i++){\\n            int complement = nums[i] % 3 == 0? 0 : 3 - nums[i] % 3; //complement idx \\n            int zero = Math.max(dp[0], dp[complement] + nums[i]); // reoccuring relationship\\n            int one  = Math.max(dp[1], dp[++complement % 3] + nums[i]);\\n            int two  = Math.max(dp[2], dp[++complement % 3] + nums[i]);\\n            dp[0] = zero;\\n\\t\\t\\t//dp[1] and dp[2] initializtion may not be %3 == 1 and %3 == 2 respectively, so we need to check.\\n            dp[1] = one % 3 == 1? one : dp[1]; \\n            dp[2] = two % 3 == 2? two : dp[2];\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606617,
                "title": "dp-or-not-dp-that-is-the-question",
                "content": "**Iterative**\\n**time:** `O(N)`; **space:** `O(1)`\\n\\nIn this solution I maintain two least numbers in an array that have remainder `1` modulo `3` and two least numbers that have remainder `2` modulo `3`.\\nActually this is done using `dp`\\'ish algo (as it is done step by step using previously obtained two least numbers) but this algo is different from [lee215](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space)\\'s `dp` solution.\\n```\\nint maxSumDivThree(vector<int>& n)\\n{\\n\\tint out{}, m1{10000}, mm1{10001}, m2{10000}, mm2{10001};\\n\\tfor(const auto & i : n)\\n\\t{\\n\\t\\tout += i;\\n\\t\\tif(i%3==1)\\n\\t\\t\\tmm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;\\n\\t\\telse if(i%3==2)\\n\\t\\t\\tmm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;\\n\\t}\\n\\treturn out -= out%3==1 ? min(m1, mm2+m2) : out%3==2 ? min(m2, mm1+m1) : 0;\\n}\\n```\\n\\n**Explanation**\\n\\nSum up all the numbers and determine two least numbers equal `1 mod 3` and two least numbers equal `2 mod 3`. If the total sum is `1 mod 3` you should substract either the least `1 mod 3` number or two least `2 mod 3` numbers. If the total sum is `1 mod 3` you should substract either the least `2 mod 3` number or two least `1 mod 3` numbers.\\nNote, that\\n```mm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;```\\nand \\n```mm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;```\\ncalculate the aforementioned two least numbers using `exchange` magic.\\n\\n**Notation**\\n\\n`m1` - least number that is `1 mod 3`;\\n`mm1` - second to least number that is `1 mod 3`;\\n`m2` - least number that is `2 mod 3`;\\n`mm2` - second to least number that is `2 mod 3`.\\n\\n**[lee215](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space)\\'s solution**\\n**time:** `O(N)`; **space:** `O(1)`\\n```\\nint maxSumDivThree(vector<int>& A)\\n{\\n\\tint dp[3]{}, t[3]{};\\n\\tfor(const int & a : A)\\n\\t\\tfor(copy(begin(dp), end(dp), begin(t)); const int & i : t)\\n\\t\\t\\tdp[(i+a)%3] = max(dp[(i+a)%3], i+a);\\n\\treturn dp[0];\\n}\\n```\\n**Notation**\\n\\n`dp[0]` - largest sum that is `0 mod 3`;\\n`dp[1]` - largest sum that is `1 mod 3`;\\n`dp[2]` - largest sum  that is `2 mod 3`.\\n\\nIn order to find the best `0 mod 3` sum at the end we need to track the best sums of three  `modulo 3` categories\\n* best `0 mod 3` sum (naturally);\\n* best `1 mod 3` sum;\\n* best `2 mod 3` sum.\\n\\nWe should consider new element \"added\" to each of the \"best sums\".\\n\\n![image](https://assets.leetcode.com/users/images/54b3d9bd-a2b9-4ed1-a50a-90ae31c08d02_1638444975.8460197.png)\\n\\nAnd each of them *can* become the best sum of another (or the same) `modulo 3` category.\\n\\n![image](https://assets.leetcode.com/users/images/cf735d65-3e8d-4c88-905a-20914f9c66a7_1638444811.8744032.png)\\n\\nSo we should find out which of this possibilities happens to maintain the best sums.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumDivThree(vector<int>& n)\\n{\\n\\tint out{}, m1{10000}, mm1{10001}, m2{10000}, mm2{10001};\\n\\tfor(const auto & i : n)\\n\\t{\\n\\t\\tout += i;\\n\\t\\tif(i%3==1)\\n\\t\\t\\tmm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;\\n\\t\\telse if(i%3==2)\\n\\t\\t\\tmm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;\\n\\t}\\n\\treturn out -= out%3==1 ? min(m1, mm2+m2) : out%3==2 ? min(m2, mm1+m1) : 0;\\n}\\n```\n```mm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;```\n```mm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;```\n```\\nint maxSumDivThree(vector<int>& A)\\n{\\n\\tint dp[3]{}, t[3]{};\\n\\tfor(const int & a : A)\\n\\t\\tfor(copy(begin(dp), end(dp), begin(t)); const int & i : t)\\n\\t\\t\\tdp[(i+a)%3] = max(dp[(i+a)%3], i+a);\\n\\treturn dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582424,
                "title": "simple-c-recursive-memoization",
                "content": "**Plz upvote if u liked it**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[40001][3];\\n    int helper(vector<int>& nums,int ind,int rem){\\n        if(ind>=nums.size()){\\n            return rem?INT_MIN:0;\\n        }\\n        if(dp[ind][rem]!=-1){\\n            return dp[ind][rem];\\n        }\\n        return dp[ind][rem]= max(nums[ind]+helper(nums,ind+1,(rem+nums[ind])%3),helper(nums,ind+1,rem));\\n        \\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,0);\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[40001][3];\\n    int helper(vector<int>& nums,int ind,int rem){\\n        if(ind>=nums.size()){\\n            return rem?INT_MIN:0;\\n        }\\n        if(dp[ind][rem]!=-1){\\n            return dp[ind][rem];\\n        }\\n        return dp[ind][rem]= max(nums[ind]+helper(nums,ind+1,(rem+nums[ind])%3),helper(nums,ind+1,rem));\\n        \\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,0);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579311,
                "title": "java-dp-approach",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[nums.length+1][3];\\n        dp[0][1] = Integer.MIN_VALUE;\\n        dp[0][2] = Integer.MIN_VALUE;\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            int mod = nums[i-1] % 3;\\n            if(mod == 0) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            } else if(mod == 1) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            } else {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[nums.length][0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[nums.length+1][3];\\n        dp[0][1] = Integer.MIN_VALUE;\\n        dp[0][2] = Integer.MIN_VALUE;\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            int mod = nums[i-1] % 3;\\n            if(mod == 0) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1566374,
                "title": "c-one-pass-solution-maths-100-runtime-maths-easy-to-understand",
                "content": "\\nSimply calculating the sum of array and checking if sum%3==0.If it is not it is would be either 1 or 2.\\nSo if it is 1 we remove min(min number with n%3==1,sum of 2 min number with n%3==2)\\nSo if it is 2 we remove min(min number with n%3==2,sum of 2 min number with n%3==1)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n\\t{\\n        long int sum=0,min11=INT_MAX,min12=INT_MAX,min21=INT_MAX,min22=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(nums[i]%3==1)\\n            {\\n                if(min11>nums[i])\\n                {\\n                    min12=min11;\\n                    min11=nums[i];\\n                }\\n                else if(min12>nums[i])\\n                    min12=nums[i];\\n            }\\n            else if(nums[i]%3==2)\\n            {\\n                if(min21>nums[i])\\n                {\\n                    min22=min21;\\n                    min21=nums[i];\\n                }\\n                else if(min22>nums[i])\\n                    min22=nums[i];\\n            }\\n        }\\n        if(sum%3==0)\\n            return sum;\\n         else if(sum%3==1)\\n            return sum-min(min11,min21+min22)\\n         else\\n            return sum-min(min21,min11+min12);\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n\\t{\\n        long int sum=0,min11=INT_MAX,min12=INT_MAX,min21=INT_MAX,min22=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(nums[i]%3==1)\\n            {\\n                if(min11>nums[i])\\n                {\\n                    min12=min11;\\n                    min11=nums[i];\\n                }\\n                else if(min12>nums[i])\\n                    min12=nums[i];\\n            }\\n            else if(nums[i]%3==2)\\n            {\\n                if(min21>nums[i])\\n                {\\n                    min22=min21;\\n                    min21=nums[i];\\n                }\\n                else if(min22>nums[i])\\n                    min22=nums[i];\\n            }\\n        }\\n        if(sum%3==0)\\n            return sum;\\n         else if(sum%3==1)\\n            return sum-min(min11,min21+min22)\\n         else\\n            return sum-min(min21,min11+min12);\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486029,
                "title": "c-solution-time-o-n-space-o-k-where-the-sum-needs-to-be-divisible-by-k-here-k-is-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dpp[3] = {0,-1,-1}, dp[3] = {0,-1,-1};\\n\\n        for (int i = 0; i <  nums.size(); ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (dp[j] >= 0) {\\n                    int sum = dp[j]+nums[i];\\n                    dpp[sum%3] = max(dpp[sum%3], sum);\\n                }\\n            }\\n            memcpy(dp, dpp, 3*sizeof(int));\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dpp[3] = {0,-1,-1}, dp[3] = {0,-1,-1};\\n\\n        for (int i = 0; i <  nums.size(); ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (dp[j] >= 0) {\\n                    int sum = dp[j]+nums[i];\\n                    dpp[sum%3] = max(dpp[sum%3], sum);\\n                }\\n            }\\n            memcpy(dp, dpp, 3*sizeof(int));\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472330,
                "title": "every-positive-number-increases-sum-of-either-modulo-0-1-or-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(3,0);\\n        int x,y,z;\\n        for(int i=0; i<n; i++) {\\n            x = dp[0] + arr[i];\\n            y = dp[1] + arr[i];\\n            z = dp[2] + arr[i];\\n            dp[x%3] = max(dp[x%3], x);\\n            dp[y%3] = max(dp[y%3], y);\\n            dp[z%3] = max(dp[z%3], z);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(3,0);\\n        int x,y,z;\\n        for(int i=0; i<n; i++) {\\n            x = dp[0] + arr[i];\\n            y = dp[1] + arr[i];\\n            z = dp[2] + arr[i];\\n            dp[x%3] = max(dp[x%3], x);\\n            dp[y%3] = max(dp[y%3], y);\\n            dp[z%3] = max(dp[z%3], z);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469858,
                "title": "math-sort",
                "content": "Divisibility rule of 3: sum of digits should be divisible by 3\\n\\nIf sum of digits gives a remainder of 1: We need to remove the smallest number which gives the remainder of 1\\n\\nIf sum of digits gives a remainder of 2: We need to remove the smallest number which gives the remainder of 2\\n\\nEdge case: [2,6,2,2,7]\\nIn this case, the smallest number which gives remainder of 1 is 7\\nBut, there is sum of numbers lesser than 7 which gives remainder 1\\n(2+2 = 4, 4%3=1) \\n\\nSo, we need to look for the min value\\n\\n\\t\\ta.sort()\\n        total = sum(a)\\n        ones = [i for i in a if i%3==1]\\n        twos = [i for i in a if i%3==2]\\n        \\n        if total%3==1:\\n            one,two = math.inf,math.inf\\n            if ones: \\n                one = ones[0] \\n            if len(twos) > 1: \\n                two = twos[0] + twos[1] \\n            return total-min(one,two)\\n                \\n        elif total%3==2:\\n            one,two = math.inf,math.inf\\n            if twos: \\n                two = twos[0] \\n            if len(ones) > 1: \\n                one = ones[0] + ones[1] \\n            return total-min(one,two)  \\n        \\n        else:\\n            return sum(a)",
                "solutionTags": [],
                "code": "Divisibility rule of 3: sum of digits should be divisible by 3\\n\\nIf sum of digits gives a remainder of 1: We need to remove the smallest number which gives the remainder of 1\\n\\nIf sum of digits gives a remainder of 2: We need to remove the smallest number which gives the remainder of 2\\n\\nEdge case: [2,6,2,2,7]\\nIn this case, the smallest number which gives remainder of 1 is 7\\nBut, there is sum of numbers lesser than 7 which gives remainder 1\\n(2+2 = 4, 4%3=1) \\n\\nSo, we need to look for the min value\\n\\n\\t\\ta.sort()\\n        total = sum(a)\\n        ones = [i for i in a if i%3==1]\\n        twos = [i for i in a if i%3==2]\\n        \\n        if total%3==1:\\n            one,two = math.inf,math.inf\\n            if ones: \\n                one = ones[0] \\n            if len(twos) > 1: \\n                two = twos[0] + twos[1] \\n            return total-min(one,two)\\n                \\n        elif total%3==2:\\n            one,two = math.inf,math.inf\\n            if twos: \\n                two = twos[0] \\n            if len(ones) > 1: \\n                one = ones[0] + ones[1] \\n            return total-min(one,two)  \\n        \\n        else:\\n            return sum(a)",
                "codeTag": "Unknown"
            },
            {
                "id": 1326520,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        vector<int>ta;\\n        vector<int>pc;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i%3 == 1){\\n                ta.push_back(i);\\n            }\\n            else if(i%3 == 2){\\n                pc.push_back(i);\\n            }\\n        }\\n        sort(ta.begin(),ta.end());\\n        sort(pc.begin(),pc.end());\\n        if(sum%3 == 0){\\n            return sum;\\n        }\\n        else if(sum%3 == 1){\\n            if(pc.size()>=2)\\n                return max(sum-ta[0],sum-pc[0]-pc[1]);\\n            return sum-ta[0];\\n        }\\n        if(ta.size()>=2)\\n            return max(sum-pc[0],sum-ta[0]-ta[1]);\\n        return sum-pc[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        vector<int>ta;\\n        vector<int>pc;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i%3 == 1){\\n                ta.push_back(i);\\n            }\\n            else if(i%3 == 2){\\n                pc.push_back(i);\\n            }\\n        }\\n        sort(ta.begin(),ta.end());\\n        sort(pc.begin(),pc.end());\\n        if(sum%3 == 0){\\n            return sum;\\n        }\\n        else if(sum%3 == 1){\\n            if(pc.size()>=2)\\n                return max(sum-ta[0],sum-pc[0]-pc[1]);\\n            return sum-ta[0];\\n        }\\n        if(ta.size()>=2)\\n            return max(sum-pc[0],sum-ta[0]-ta[1]);\\n        return sum-pc[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318421,
                "title": "o-n-time-complexity-and-o-1-auxiliary-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi = 99999999;\\n    int maxSumDivThree(vector<int>& nums) {\\n        int one1=maxi, one2=maxi, two1=maxi, two2=maxi; //Variables to track two smallest 3k+1, 3k+2 numbers; \\n        int ans = 0;\\n        if(nums.size()==1 && nums[0]%3) return 0;\\n        for(int i=0;i<nums.size(); i++){\\n            ans+= nums[i];\\n            switch(nums[i]%3){   \\n                case 1:\\n                one2 = min(one2, nums[i]);\\n                if(one2 < one1) swap(one1, one2);\\n                break;\\n            \\n                case 2:\\n                two2 = min(two2, nums[i]);\\n                if(two2 < two1) swap(two1, two2);\\n                break;  \\n            }\\n        }\\n        \\n        if(ans%3==0) return ans;\\n        \\n        if(ans%3 == 1) ans-=min(one1, two1+two2);\\n        \\n        else ans-=min(two1, one1+one2);\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi = 99999999;\\n    int maxSumDivThree(vector<int>& nums) {\\n        int one1=maxi, one2=maxi, two1=maxi, two2=maxi; //Variables to track two smallest 3k+1, 3k+2 numbers; \\n        int ans = 0;\\n        if(nums.size()==1 && nums[0]%3) return 0;\\n        for(int i=0;i<nums.size(); i++){\\n            ans+= nums[i];\\n            switch(nums[i]%3){   \\n                case 1:\\n                one2 = min(one2, nums[i]);\\n                if(one2 < one1) swap(one1, one2);\\n                break;\\n            \\n                case 2:\\n                two2 = min(two2, nums[i]);\\n                if(two2 < two1) swap(two1, two2);\\n                break;  \\n            }\\n        }\\n        \\n        if(ans%3==0) return ans;\\n        \\n        if(ans%3 == 1) ans-=min(one1, two1+two2);\\n        \\n        else ans-=min(two1, one1+one2);\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305234,
                "title": "recursion-and-tabulation-knapsack-subsequence-dp-template-suffix-dp",
                "content": "```\\nclass Solution:\\n    def maxSumDivThreeTopDown(self, nums: List[int]) -> int:\\n        # normal knapsack/subsequence dp\\n        # at each position, pick OR don\\'t pick...\\n        # also keep 3 different states for each remainder\\n        @functools.cache\\n        def dp(i, remainder): \\n            if i == len(nums):\\n                if remainder:\\n                    return -math.inf \\n                else: \\n                    return 0\\n            \\n            # don\\'t pick me\\n            skip = dp(i+1, remainder)\\n            \\n            # pick me\\n            pick = nums[i] + dp(i+1, (remainder + nums[i])%3)\\n            \\n            return max(pick, skip)\\n        return dp(0,0)\\n    # how to convert it into bottom up?\\n    \\n    # just convert brackets into square brackets ;)\\n    \\n    # and loop backwards since all `i` depends on `i+1`\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        # base case is 0, -inf, -inf\\n        dp = [[0,-math.inf, -math.inf] for i in range(len(nums)+1)]\\n        \\n        for i in range(len(nums)-1,-1,-1): # i = , i != , +=\\n            for rem in range(3):\\n                val = nums[i]\\n                \\n                # don\\'t pick  \\n                skip = dp[i+1][rem]\\n                \\n                # pick me...\\n                pick = val + dp[i+1][(rem+val)%3]\\n\\n                dp[i][rem] = max(pick, skip)\\n        \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThreeTopDown(self, nums: List[int]) -> int:\\n        # normal knapsack/subsequence dp\\n        # at each position, pick OR don\\'t pick...\\n        # also keep 3 different states for each remainder\\n        @functools.cache\\n        def dp(i, remainder): \\n            if i == len(nums):\\n                if remainder:\\n                    return -math.inf \\n                else: \\n                    return 0\\n            \\n            # don\\'t pick me\\n            skip = dp(i+1, remainder)\\n            \\n            # pick me\\n            pick = nums[i] + dp(i+1, (remainder + nums[i])%3)\\n            \\n            return max(pick, skip)\\n        return dp(0,0)\\n    # how to convert it into bottom up?\\n    \\n    # just convert brackets into square brackets ;)\\n    \\n    # and loop backwards since all `i` depends on `i+1`\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        # base case is 0, -inf, -inf\\n        dp = [[0,-math.inf, -math.inf] for i in range(len(nums)+1)]\\n        \\n        for i in range(len(nums)-1,-1,-1): # i = , i != , +=\\n            for rem in range(3):\\n                val = nums[i]\\n                \\n                # don\\'t pick  \\n                skip = dp[i+1][rem]\\n                \\n                # pick me...\\n                pick = val + dp[i+1][(rem+val)%3]\\n\\n                dp[i][rem] = max(pick, skip)\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304538,
                "title": "java-min-heap-greedy",
                "content": "```\\n\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> minHeap1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> minHeap2 = new PriorityQueue<>();\\n\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 1).forEach(minHeap1::add);\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 2).forEach(minHeap2::add);\\n\\n        int sum = Arrays.stream(nums).boxed().reduce(Integer::sum).get();\\n        int sum0 = Arrays.stream(nums).boxed().filter(t -> t % 3 == 0).reduce(Integer::sum).orElse(0);\\n\\n        while (sum % 3 != 0) {\\n            if (sum % 3 == 1) {\\n                if (!minHeap1.isEmpty()) {\\n                    if (minHeap2.size() > 1) {\\n                        int t1 = minHeap2.poll();\\n                        int t2 = minHeap2.poll();\\n                        if (t1 + t2 < minHeap1.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap1.poll();\\n                            minHeap2.add(t1);\\n                            minHeap2.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap1.poll();\\n                    }\\n                } else if (minHeap1.isEmpty() && minHeap2.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap2.poll() - minHeap2.poll();\\n                }\\n            } else if (sum % 3 == 2) {\\n                if (!minHeap2.isEmpty()) {\\n                    if (minHeap1.size() > 1) {\\n                        int t1 = minHeap1.poll();\\n                        int t2 = minHeap1.poll();\\n                        if (t1 + t2 < minHeap2.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap2.poll();\\n                            minHeap1.add(t1);\\n                            minHeap1.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap2.poll();\\n                    }\\n                } else if (minHeap2.isEmpty() && minHeap1.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap1.poll() - minHeap1.poll();\\n                }\\n            }\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> minHeap1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> minHeap2 = new PriorityQueue<>();\\n\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 1).forEach(minHeap1::add);\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 2).forEach(minHeap2::add);\\n\\n        int sum = Arrays.stream(nums).boxed().reduce(Integer::sum).get();\\n        int sum0 = Arrays.stream(nums).boxed().filter(t -> t % 3 == 0).reduce(Integer::sum).orElse(0);\\n\\n        while (sum % 3 != 0) {\\n            if (sum % 3 == 1) {\\n                if (!minHeap1.isEmpty()) {\\n                    if (minHeap2.size() > 1) {\\n                        int t1 = minHeap2.poll();\\n                        int t2 = minHeap2.poll();\\n                        if (t1 + t2 < minHeap1.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap1.poll();\\n                            minHeap2.add(t1);\\n                            minHeap2.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap1.poll();\\n                    }\\n                } else if (minHeap1.isEmpty() && minHeap2.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap2.poll() - minHeap2.poll();\\n                }\\n            } else if (sum % 3 == 2) {\\n                if (!minHeap2.isEmpty()) {\\n                    if (minHeap1.size() > 1) {\\n                        int t1 = minHeap1.poll();\\n                        int t2 = minHeap1.poll();\\n                        if (t1 + t2 < minHeap2.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap2.poll();\\n                            minHeap1.add(t1);\\n                            minHeap1.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap2.poll();\\n                    }\\n                } else if (minHeap2.isEmpty() && minHeap1.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap1.poll() - minHeap1.poll();\\n                }\\n            }\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291204,
                "title": "c-clean-and-concise-dp-solution-easy-to-understand",
                "content": "Please upvote if it helps you!\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        dp[0][a[0]%3] = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int x = dp[i-1][0]+a[i];\\n            int y = dp[i-1][1]+a[i];\\n            int z = dp[i-1][2]+a[i];\\n            dp[i]=dp[i-1];\\n            dp[i][x%3] = max(x,dp[i][x%3]);\\n            dp[i][y%3] = max(y,dp[i][y%3]);\\n            dp[i][z%3] = max(z,dp[i][z%3]);\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        dp[0][a[0]%3] = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int x = dp[i-1][0]+a[i];\\n            int y = dp[i-1][1]+a[i];\\n            int z = dp[i-1][2]+a[i];\\n            dp[i]=dp[i-1];\\n            dp[i][x%3] = max(x,dp[i][x%3]);\\n            dp[i][y%3] = max(y,dp[i][y%3]);\\n            dp[i][z%3] = max(z,dp[i][z%3]);\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266267,
                "title": "python3-solution-using-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = []\\n        for i in range(3):\\n            z = []\\n            for j in range(len(nums)):\\n                z.append(0)\\n            dp.append(z)\\n        dp[nums[0]%3][0] = nums[0]\\n        for i in range(1,len(nums)):\\n            for j in range(3):\\n                x = dp[j][i-1] + nums[i]\\n                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])\\n                dp[j][i] = max(dp[j][i-1],dp[j][i])\\n        return dp[0][-1]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = []\\n        for i in range(3):\\n            z = []\\n            for j in range(len(nums)):\\n                z.append(0)\\n            dp.append(z)\\n        dp[nums[0]%3][0] = nums[0]\\n        for i in range(1,len(nums)):\\n            for j in range(3):\\n                x = dp[j][i-1] + nums[i]\\n                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])\\n                dp[j][i] = max(dp[j][i-1],dp[j][i])\\n        return dp[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246664,
                "title": "c-98-easiest-and-pretty-solution-with-explanation",
                "content": "* Here dp[i] stores the minimum value of integer giving mod3 = i.\\n* if current number nums[i] is 3 mod 1 then update the dp[1] value with min between num[i] and dp[1]\\n* Also we update the dp[2] value cause 2 dp[1] value can make 1 dp[2] value EX => 1 + 1 = 2.\\n* if current number nums[i] is 3 mod 2 then update the dp[2] value with min between num[i] and dp[2]\\n* Also we update the dp[1] value cause 2 dp[2] value can make 1 dp[1] value EX => 2 + 2 = 4%3 = 1.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dp[3];\\n        int sum=0;\\n        \\n        dp[1]=10000;\\n        dp[2]=10000;\\n        \\n        for(int i:nums){\\n            if(i%3)\\n            {\\n                if(i%3==1) dp[2]=min(dp[2],dp[1]+i), dp[1]=min(dp[1],i);\\n                else       dp[1]=min(dp[1],dp[2]+i), dp[2]=min(dp[2],i);\\n            }\\n            sum+=i;\\n        }\\n        \\n        return sum-dp[sum%3];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dp[3];\\n        int sum=0;\\n        \\n        dp[1]=10000;\\n        dp[2]=10000;\\n        \\n        for(int i:nums){\\n            if(i%3)\\n            {\\n                if(i%3==1) dp[2]=min(dp[2],dp[1]+i), dp[1]=min(dp[1],i);\\n                else       dp[1]=min(dp[1],dp[2]+i), dp[2]=min(dp[2],i);\\n            }\\n            sum+=i;\\n        }\\n        \\n        return sum-dp[sum%3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189916,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (int i : nums){\\n            for (int j : vector<int>(dp)) {\\n                dp[(i+j)%3] = max(dp[(i+j)%3], i+j);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (int i : nums){\\n            for (int j : vector<int>(dp)) {\\n                dp[(i+j)%3] = max(dp[(i+j)%3], i+j);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119637,
                "title": "c-dp-o-n-with-short-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        // DP: define size == nums.size() and array dp[3][size + 1] where dp[i][j + 1]\\n        // denotes the max sum modulo 3 equals i in subarray nums[0:j]. We calculate dp[i][j] accordingly\\n        // and return the final result of dp[0][size].\\n        int size = nums.size();\\n        vector<vector<int>> dp(3, vector<int>(size + 1));\\n        \\n        for (int j = 1; j <= size; ++j)\\n        {\\n            int mod = nums[j - 1] % 3;\\n            if (mod == 0) // nums[j - 1] modulo 3 == 0\\n            {\\n                dp[0][j] = nums[j - 1] + dp[0][j - 1];\\n                dp[1][j] = dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1];\\n                dp[2][j] = dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1];\\n            }\\n            else if (mod == 1) // nums[j - 1] modulo 3 == 1\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n            }\\n            else // nums[j - 1] modulo 3 == 2\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[0][j - 1] + nums[j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][size];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        // DP: define size == nums.size() and array dp[3][size + 1] where dp[i][j + 1]\\n        // denotes the max sum modulo 3 equals i in subarray nums[0:j]. We calculate dp[i][j] accordingly\\n        // and return the final result of dp[0][size].\\n        int size = nums.size();\\n        vector<vector<int>> dp(3, vector<int>(size + 1));\\n        \\n        for (int j = 1; j <= size; ++j)\\n        {\\n            int mod = nums[j - 1] % 3;\\n            if (mod == 0) // nums[j - 1] modulo 3 == 0\\n            {\\n                dp[0][j] = nums[j - 1] + dp[0][j - 1];\\n                dp[1][j] = dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1];\\n                dp[2][j] = dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1];\\n            }\\n            else if (mod == 1) // nums[j - 1] modulo 3 == 1\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n            }\\n            else // nums[j - 1] modulo 3 == 2\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[0][j - 1] + nums[j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096108,
                "title": "easy-to-understand-python-dp",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0]*3 for _ in range(n+1)]\\n        dp[0][0] = 0\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n        \\n        for i in range(1,n+1):\\n            if nums[i-1]%3 ==0:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][0]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][1]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][2]+nums[i-1] )\\n            if nums[i-1]%3 ==1:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][1]+nums[i-1] )\\n            if nums[i-1]%3 ==2:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+nums[i-1] )\\n        print(dp)\\n        \\n        return dp[n][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0]*3 for _ in range(n+1)]\\n        dp[0][0] = 0\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n        \\n        for i in range(1,n+1):\\n            if nums[i-1]%3 ==0:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][0]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][1]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][2]+nums[i-1] )\\n            if nums[i-1]%3 ==1:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][1]+nums[i-1] )\\n            if nums[i-1]%3 ==2:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+nums[i-1] )\\n        print(dp)\\n        \\n        return dp[n][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096013,
                "title": "python-solution-beats-99-67-with-explanation",
                "content": "* core idea is that if n%3 == 1(or 2), then for any number ni%3 == 1(or 2), (n-ni)%3 == 0\\n* Now we this question is asking us to find the minimum sum S, that S%3 == sum(nums)%3\\n* it\\'s not hard to figure out if n1%3 == n2%3 == 1, then (n1+n2)%3 == 2\\n* if n1%3 == n2%3 == 2, then (n1+n2)%3 == 1\\n\\nclass Solution:\\n\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        remainder = s%3\\n        if not remainder:\\n            return s\\n\\n        remainder1 = [float(\"inf\"),float(\"inf\")]\\n        remainder2 = [float(\"inf\"),float(\"inf\")]\\n        for n in nums: # find the remainder of the largest and second largest number that are equal to 1 and 2\\n            if n%3 == 1:\\n                if n<=remainder1[0]:\\n                    remainder1[1] = remainder1[0]\\n                    remainder1[0] = n\\n                elif n<remainder1[1]:\\n                    remainder1[1] = n\\n            if n%3 == 2:\\n                if n<=remainder2[0]:\\n                    remainder2[1] = remainder2[0]\\n                    remainder2[0] = n\\n                elif n<remainder2[1]:\\n                    remainder2[1] = n\\n\\n        if remainder == 1: # sum(remainder1)%3 == 2 and sum(remainder2)%3 == 1\\n            ans = s - min(sum(remainder2),remainder1[0])\\n        elif remainder == 2:\\n            ans = s - min(sum(remainder1),remainder2[0])\\n        return ans if ans!=float(\"inf\") else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "* core idea is that if n%3 == 1(or 2), then for any number ni%3 == 1(or 2), (n-ni)%3 == 0\\n* Now we this question is asking us to find the minimum sum S, that S%3 == sum(nums)%3\\n* it\\'s not hard to figure out if n1%3 == n2%3 == 1, then (n1+n2)%3 == 2\\n* if n1%3 == n2%3 == 2, then (n1+n2)%3 == 1\\n\\nclass Solution:\\n\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        remainder = s%3\\n        if not remainder:\\n            return s\\n\\n        remainder1 = [float(\"inf\"),float(\"inf\")]\\n        remainder2 = [float(\"inf\"),float(\"inf\")]\\n        for n in nums: # find the remainder of the largest and second largest number that are equal to 1 and 2\\n            if n%3 == 1:\\n                if n<=remainder1[0]:\\n                    remainder1[1] = remainder1[0]\\n                    remainder1[0] = n\\n                elif n<remainder1[1]:\\n                    remainder1[1] = n\\n            if n%3 == 2:\\n                if n<=remainder2[0]:\\n                    remainder2[1] = remainder2[0]\\n                    remainder2[0] = n\\n                elif n<remainder2[1]:\\n                    remainder2[1] = n\\n\\n        if remainder == 1: # sum(remainder1)%3 == 2 and sum(remainder2)%3 == 1\\n            ans = s - min(sum(remainder2),remainder1[0])\\n        elif remainder == 2:\\n            ans = s - min(sum(remainder1),remainder2[0])\\n        return ans if ans!=float(\"inf\") else 0",
                "codeTag": "Java"
            },
            {
                "id": 1071991,
                "title": "best-java-dp-solution-and-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] a) {\\n        int n=a.length;\\n        int dp[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                dp[i][a[i]%3]=a[i];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    int sum=dp[i-1][j]+a[i];\\n                    dp[i][sum%3]=Math.max(dp[i][sum%3],sum);\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<3;j++){\\n        //         System.out.print(dp[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] a) {\\n        int n=a.length;\\n        int dp[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                dp[i][a[i]%3]=a[i];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    int sum=dp[i-1][j]+a[i];\\n                    dp[i][sum%3]=Math.max(dp[i][sum%3],sum);\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<3;j++){\\n        //         System.out.print(dp[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994280,
                "title": "simply-python-runtime-100-memory-90-48",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = sum(nums)\\n        \\n        if s % 3 == 0:\\n            return s\\n        \\n        r11 = 10000\\n        r12 = 10000\\n        r21 = 10000\\n        r22 = 10000\\n        \\n        for num in nums:\\n            if num % 3 == 1 and num < r12:\\n                if num < r11:\\n                    r12 = r11\\n                    r11 = num\\n                else:\\n                    r12 = num\\n            if num % 3 == 2 and num < r22:\\n                if num < r21:\\n                    r22 = r21\\n                    r21 = num\\n                else: \\n                    r22 = num\\n        if s % 3 == 1:\\n            return s - min(r11, r21+r22)\\n        if s % 3 == 2:\\n            return s - min(r21, r11+r12)  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = sum(nums)\\n        \\n        if s % 3 == 0:\\n            return s\\n        \\n        r11 = 10000\\n        r12 = 10000\\n        r21 = 10000\\n        r22 = 10000\\n        \\n        for num in nums:\\n            if num % 3 == 1 and num < r12:\\n                if num < r11:\\n                    r12 = r11\\n                    r11 = num\\n                else:\\n                    r12 = num\\n            if num % 3 == 2 and num < r22:\\n                if num < r21:\\n                    r22 = r21\\n                    r21 = num\\n                else: \\n                    r22 = num\\n        if s % 3 == 1:\\n            return s - min(r11, r21+r22)\\n        if s % 3 == 2:\\n            return s - min(r21, r11+r12)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 914120,
                "title": "python-o-n-time-o-1-space-fast-beats-98",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        sums = sum(nums)\\n        if sums%3==0:\\n            return sums\\n        mods = {1:[],2:[]}\\n        for n in nums:\\n            a = n%3\\n            if a:\\n                if len(mods[a])<2:\\n                    mods[a].append(n)\\n                    mods[a].sort()\\n                elif n<mods[a][0]:\\n                    mods[a] = [n,mods[a][0]]\\n                elif n<mods[a][1]:\\n                    mods[a][1] = n\\n\\n        if sums%3 == 1:\\n            a = sum(mods[2]) if len(mods[2])==2 else 10**5\\n            b = mods[1][0] if mods[1] else 10**5\\n            return sums - min(a,b)\\n        if sums%3 == 2:\\n            a = sum(mods[1]) if len(mods[1])==2 else 10**5\\n            b = mods[2][0] if mods[2] else 10**5\\n            return sums - min(a,b)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        sums = sum(nums)\\n        if sums%3==0:\\n            return sums\\n        mods = {1:[],2:[]}\\n        for n in nums:\\n            a = n%3\\n            if a:\\n                if len(mods[a])<2:\\n                    mods[a].append(n)\\n                    mods[a].sort()\\n                elif n<mods[a][0]:\\n                    mods[a] = [n,mods[a][0]]\\n                elif n<mods[a][1]:\\n                    mods[a][1] = n\\n\\n        if sums%3 == 1:\\n            a = sum(mods[2]) if len(mods[2])==2 else 10**5\\n            b = mods[1][0] if mods[1] else 10**5\\n            return sums - min(a,b)\\n        if sums%3 == 2:\\n            a = sum(mods[1]) if len(mods[1])==2 else 10**5\\n            b = mods[2][0] if mods[2] else 10**5\\n            return sums - min(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899423,
                "title": "python-o-nlogn-but-has-good-readability-and-comments",
                "content": "```\\nbased on the @TwerpApple solution\\n# O(nlogn) because of sorting in the very beginning\\n# possible to do the same without sorting in O(n) but it\\'ll probably become less readable\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total_sum = sum(nums)\\n        reminder = total_sum % 3\\n        if reminder == 0:\\n            return total_sum\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 1\\n        # and\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 2\\n        num_mods = [x % 3 for x in nums]\\n        nums_with_reminder_of_one = [x[1] for x in zip(num_mods, nums) if x[0] == 1][0:2]\\n        nums_with_reminder_of_two = [x[1] for x in zip(num_mods, nums) if x[0] == 2][0:2]\\n\\n        # if the reminder of modulo  the  sum of the while nums arr is 2\\n        # we calculate two numbers:\\n        # total sum minus sum of two smallest numbers with the reminder of 1\\n        #   and the total sum minus the smallest number with the reminder of 2\\n        # Return the largest of them\\n        # Same for the case when modulo of total sum has a reminder of 1\\n        if reminder == 1:\\n            sum_1 = (total_sum - nums_with_reminder_of_one[0]) if nums_with_reminder_of_one else 0\\n            sum_2 = total_sum - sum(nums_with_reminder_of_two) if len(nums_with_reminder_of_two) == 2 else 0\\n        else:\\n            sum_1 = (total_sum - sum(nums_with_reminder_of_one)) if len(nums_with_reminder_of_one) == 2 else 0\\n            sum_2 = (total_sum - nums_with_reminder_of_two[0]) if nums_with_reminder_of_two else 0\\n\\n        return max(sum_1, sum_2)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nbased on the @TwerpApple solution\\n# O(nlogn) because of sorting in the very beginning\\n# possible to do the same without sorting in O(n) but it\\'ll probably become less readable\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total_sum = sum(nums)\\n        reminder = total_sum % 3\\n        if reminder == 0:\\n            return total_sum\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 1\\n        # and\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 2\\n        num_mods = [x % 3 for x in nums]\\n        nums_with_reminder_of_one = [x[1] for x in zip(num_mods, nums) if x[0] == 1][0:2]\\n        nums_with_reminder_of_two = [x[1] for x in zip(num_mods, nums) if x[0] == 2][0:2]\\n\\n        # if the reminder of modulo  the  sum of the while nums arr is 2\\n        # we calculate two numbers:\\n        # total sum minus sum of two smallest numbers with the reminder of 1\\n        #   and the total sum minus the smallest number with the reminder of 2\\n        # Return the largest of them\\n        # Same for the case when modulo of total sum has a reminder of 1\\n        if reminder == 1:\\n            sum_1 = (total_sum - nums_with_reminder_of_one[0]) if nums_with_reminder_of_one else 0\\n            sum_2 = total_sum - sum(nums_with_reminder_of_two) if len(nums_with_reminder_of_two) == 2 else 0\\n        else:\\n            sum_1 = (total_sum - sum(nums_with_reminder_of_one)) if len(nums_with_reminder_of_one) == 2 else 0\\n            sum_2 = (total_sum - nums_with_reminder_of_two[0]) if nums_with_reminder_of_two else 0\\n\\n        return max(sum_1, sum_2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781625,
                "title": "java-98-remainder-with-comments",
                "content": "Every number is positive, we\\'ll want to use as many numbers as we can.\\n\\nSince we can choose any subsequence in the array, we\\'ll remove minimum possible numbers from `sum` to a number % by 3.\\n\\nThere are several intuitions to look out for:\\n- Any numbers `num % 3 == 0` are always included.\\n- Sums not divisible by 3 can be turned to a number divisible by 3 by minusing the remainder from `sum % 3`. We\\'ll look for a minimum number to fulfill this condition to fulfill maxSum.\\n- Two numbers with `num % 3 == 1` combined together will always equal `num % 3 == 2`. \\n\\t- These combined numbers can be less than a single number `num % 3 == 2`. \\n\\t- **Note**: We don\\'t use three `num % 3 == 1` as combining them will equal `num % 3 == 0`.\\n- Two numbers with `num % 3 == 2` combined together will always equal `num % 3 == 1`. \\n\\t- These combined numbers can be less than a single number `num % 3 == 1`. \\n\\t- **Note**: We don\\'t use three `num % 3 == 2` as combining them will equal `num % 3 == 0`.\\n\\n```java\\npublic int maxSumDivThree(int[] nums) {\\n\\tint sum = 0;\\n\\n\\tint minOne = Integer.MAX_VALUE;\\n\\tint minTwo = Integer.MAX_VALUE;\\n\\tfor (int num: nums) {\\n\\t\\tsum += num;\\n\\n\\t\\tswitch (num % 3) {\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t// 1+1=2%3=2. 4+4=8%3=2. 1+4=5%3=2.\\n\\t\\t\\t\\tif (minOne != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminTwo = Math.min(minTwo, num + minOne);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminOne = Math.min(minOne, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t// 2+2=4%3=1. 5+5=10%3=1. 2+5=7%3=1.\\n\\t\\t\\t\\tif (minTwo != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminOne = Math.min(minOne, num + minTwo);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminTwo = Math.min(minTwo, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tswitch (sum % 3) {\\n\\t\\tcase 1:\\n\\t\\t\\tif (minOne == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minOne;\\n\\t\\tcase 2:\\n\\t\\t\\tif (minTwo == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minTwo;\\n\\t\\tdefault:\\n\\t\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maxSumDivThree(int[] nums) {\\n\\tint sum = 0;\\n\\n\\tint minOne = Integer.MAX_VALUE;\\n\\tint minTwo = Integer.MAX_VALUE;\\n\\tfor (int num: nums) {\\n\\t\\tsum += num;\\n\\n\\t\\tswitch (num % 3) {\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t// 1+1=2%3=2. 4+4=8%3=2. 1+4=5%3=2.\\n\\t\\t\\t\\tif (minOne != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminTwo = Math.min(minTwo, num + minOne);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminOne = Math.min(minOne, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t// 2+2=4%3=1. 5+5=10%3=1. 2+5=7%3=1.\\n\\t\\t\\t\\tif (minTwo != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminOne = Math.min(minOne, num + minTwo);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminTwo = Math.min(minTwo, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tswitch (sum % 3) {\\n\\t\\tcase 1:\\n\\t\\t\\tif (minOne == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minOne;\\n\\t\\tcase 2:\\n\\t\\t\\tif (minTwo == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minTwo;\\n\\t\\tdefault:\\n\\t\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757173,
                "title": "python-3-98-speed-250ms-maths",
                "content": "Key idea:\\nSum all values,and set this to sum_, then the problem is simply taking out the remainder mod 3 if possible.\\nIf the remainder is 0, sum_ is the solution\\nElse without loss of generality, we can say sum_ has remainder 1 when divided by 3..\\nTake the smallest pair of values (a,b) in our list congruent to 2 mod 3, and the smallest value \\'x\\' congruent to 1 mod 3\\nEither x < sum(a,b), and we can return sum_ - x\\nelse return sum - a - b\\n\\nThe only edge case is when there are no values congruent to 1 mod 3, or there are fewer than 2 congruent to 2 mod 3.\\nThese are dealt with in the below code.\\n\\nRather than returning the smallest two in min_two below, one could instead return the sum and handle cases that way.\\n\\nThis should be O(N)\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n                 \\n        if not nums:\\n            return 0\\n        if len(nums) == 1 and nums[0] % 3:\\n            return 0\\n        \\n        sum_ = sum(nums)\\n        mod_ = sum_ % 3\\n        if not mod_:\\n            return sum_\\n                \\n        vals = {False: self.min_two([n for n in nums if n % 3 == 3 - mod_]),\\n                True: [min([n for n in nums if n % 3 == mod_])]}\\n        \\n        if vals[True] and len(vals[False]) <= 1:\\n            return sum_ - vals[True][0]\\n        \\n        elif vals[True] and vals[True][0] < sum(vals[False]):\\n            return sum_ - vals[True][0]\\n        \\n        elif len(vals[False]) == 2:\\n            return sum_ - sum(vals[False])\\n        return 0\\n        \\n            \\n    \\n    def min_two(self, l):\\n        if not l:\\n            return []\\n        idx = [i for i in range(len(l))]\\n        out = [min(idx, key = lambda i: l[i])]\\n        idx.pop(out[0])\\n        if idx:\\n            out.append(min(idx, key = lambda i: l[i]))\\n        \\n        return [l[i] for i in out]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n                 \\n        if not nums:\\n            return 0\\n        if len(nums) == 1 and nums[0] % 3:\\n            return 0\\n        \\n        sum_ = sum(nums)\\n        mod_ = sum_ % 3\\n        if not mod_:\\n            return sum_\\n                \\n        vals = {False: self.min_two([n for n in nums if n % 3 == 3 - mod_]),\\n                True: [min([n for n in nums if n % 3 == mod_])]}\\n        \\n        if vals[True] and len(vals[False]) <= 1:\\n            return sum_ - vals[True][0]\\n        \\n        elif vals[True] and vals[True][0] < sum(vals[False]):\\n            return sum_ - vals[True][0]\\n        \\n        elif len(vals[False]) == 2:\\n            return sum_ - sum(vals[False])\\n        return 0\\n        \\n            \\n    \\n    def min_two(self, l):\\n        if not l:\\n            return []\\n        idx = [i for i in range(len(l))]\\n        out = [min(idx, key = lambda i: l[i])]\\n        idx.pop(out[0])\\n        if idx:\\n            out.append(min(idx, key = lambda i: l[i]))\\n        \\n        return [l[i] for i in out]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688937,
                "title": "simple-o-n-dp-c-solution-with-dp-table-by-farouk",
                "content": "![image](https://assets.leetcode.com/users/alfarouksaleh/image_1592243114.png)\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int sz=nums.size();\\n       // if(!sz)return \\n        int dp[sz+1][3];\\n        int temp1,temp2;\\n        for (int i=0;i<3;i++)dp[0][i]=0;\\n        for (int i=1;i<=sz;i++){\\n            for (int j=0;j<3;j++){dp[i][j]=dp[i-1][j];}\\n            \\n            for (int j=0;j<3;j++){\\n                temp1=nums[i-1]+dp[i-1][j];\\n                temp2=temp1%3;//the mod3 of the current number\\n                dp[i][temp2]=max(dp[i][temp2],temp1);\\n                \\n            }\\n            \\n            \\n            \\n        }\\n       return dp[sz][0];\\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int sz=nums.size();\\n       // if(!sz)return \\n        int dp[sz+1][3];\\n        int temp1,temp2;\\n        for (int i=0;i<3;i++)dp[0][i]=0;\\n        for (int i=1;i<=sz;i++){\\n            for (int j=0;j<3;j++){dp[i][j]=dp[i-1][j];}",
                "codeTag": "Java"
            },
            {
                "id": 665706,
                "title": "python-99-87-of-time-and-100-00-of-memory-subtract-minimum-with-the-sum-remainder",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        max_sum = sum(nums)\\n        if max_sum % 3:\\n            # if the total sum has a remainder the remainder can be neutralized by subtracting the smallest number\\n            # with the same remainder or the sum of two smallest numbers with a different remainder\\n            if max_sum % 3 == 1:\\n                # search for x % 3 == 1 or two minimum numbers such that x % 3 == 2\\n                min_mod1   = math.inf\\n                min_mod2   = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < min_mod1:\\n                        min_mod1 = num\\n                    elif mod == 2 and num < max(min_mod2):\\n                        min_mod2[min_mod2[0] < min_mod2[1]] = num\\n                        \\n                max_sum -= min(min_mod1, sum(min_mod2))\\n            else:\\n                min_mod2 = math.inf\\n                min_mod1 = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < max(min_mod1):\\n                        min_mod1[min_mod1[0] < min_mod1[1]] = num\\n                    elif mod == 2 and num < min_mod2:\\n                        min_mod2 = num\\n                max_sum -= min(min_mod2, sum(min_mod1))\\n                        \\n        return max_sum\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        max_sum = sum(nums)\\n        if max_sum % 3:\\n            # if the total sum has a remainder the remainder can be neutralized by subtracting the smallest number\\n            # with the same remainder or the sum of two smallest numbers with a different remainder\\n            if max_sum % 3 == 1:\\n                # search for x % 3 == 1 or two minimum numbers such that x % 3 == 2\\n                min_mod1   = math.inf\\n                min_mod2   = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < min_mod1:\\n                        min_mod1 = num\\n                    elif mod == 2 and num < max(min_mod2):\\n                        min_mod2[min_mod2[0] < min_mod2[1]] = num\\n                        \\n                max_sum -= min(min_mod1, sum(min_mod2))\\n            else:\\n                min_mod2 = math.inf\\n                min_mod1 = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < max(min_mod1):\\n                        min_mod1[min_mod1[0] < min_mod1[1]] = num\\n                    elif mod == 2 and num < min_mod2:\\n                        min_mod2 = num\\n                max_sum -= min(min_mod2, sum(min_mod1))\\n                        \\n        return max_sum\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 661492,
                "title": "c-o-n-dp-solution-o-1-for-space-finished-after-10-mins-very-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int v[]={0,0,0};\\n        //v[0] ~ mod3==0\\n        //v[1] ~ mod3==1\\n        //v[2] ~ mod3==2\\n        int n=nums.size();\\n        for (int i=n-1; i>=0; i--){\\n            int tmp[3];\\n            for (int i=0; i<3; i++)\\n                tmp[i]=v[i];\\n            for (int j=0; j<3; j++){\\n                int mod=(tmp[j]+nums[i])%3;\\n                v[mod]=max(v[mod],tmp[j]+nums[i]);                \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int v[]={0,0,0};\\n        //v[0] ~ mod3==0\\n        //v[1] ~ mod3==1\\n        //v[2] ~ mod3==2\\n        int n=nums.size();\\n        for (int i=n-1; i>=0; i--){\\n            int tmp[3];\\n            for (int i=0; i<3; i++)\\n                tmp[i]=v[i];\\n            for (int j=0; j<3; j++){\\n                int mod=(tmp[j]+nums[i])%3;\\n                v[mod]=max(v[mod],tmp[j]+nums[i]);                \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654344,
                "title": "easy-java-solution-o-n-time-o-1-space",
                "content": "Create a dp array with size of 3. Indicating max value that have remainder equals with the index.\\ni.e. dp[1] = 7 means the maximum value can sum up which has a remainer =1 after mod 3 is 7.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int [] dp = new int[3];\\n        for (int i = 0; i < nums.length; i++) {\\n            int [] n = new int[3];\\n            if (nums[i] % 3 == 0) {\\n                n[0] = dp[0] + nums[i];\\n                n[1] = dp[1] + nums[i];\\n                n[2] = dp[2] + nums[i];\\n            } else if (nums[i] % 3 == 1) {\\n                n[0] = dp[2] % 3 == 2 ?  Math.max(dp[2] + nums[i], dp[0]) : dp[0];\\n                n[1] = Math.max(dp[0] + nums[i], dp[1]);\\n                n[2] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[2]) : dp[2];\\n            } else {\\n                n[0] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[0]) : dp[0];\\n                n[1] = dp[2] % 3 == 2 ? Math.max(dp[2] + nums[i], dp[1]) : dp[1];\\n                n[2] = Math.max(dp[0] + nums[i], dp[2]);\\n            }\\n            dp = n;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int [] dp = new int[3];\\n        for (int i = 0; i < nums.length; i++) {\\n            int [] n = new int[3];\\n            if (nums[i] % 3 == 0) {\\n                n[0] = dp[0] + nums[i];\\n                n[1] = dp[1] + nums[i];\\n                n[2] = dp[2] + nums[i];\\n            } else if (nums[i] % 3 == 1) {\\n                n[0] = dp[2] % 3 == 2 ?  Math.max(dp[2] + nums[i], dp[0]) : dp[0];\\n                n[1] = Math.max(dp[0] + nums[i], dp[1]);\\n                n[2] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[2]) : dp[2];\\n            } else {\\n                n[0] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[0]) : dp[0];\\n                n[1] = dp[2] % 3 == 2 ? Math.max(dp[2] + nums[i], dp[1]) : dp[1];\\n                n[2] = Math.max(dp[0] + nums[i], dp[2]);\\n            }\\n            dp = n;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641510,
                "title": "easy-peasy-c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if(sum%3==0)\\n            return sum;\\n        if(sum%3==1){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            \\n            \\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        if(sum%3==2){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if(sum%3==0)\\n            return sum;\\n        if(sum%3==1){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            \\n            \\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        if(sum%3==2){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639335,
                "title": "simple-python-logic-based-solution-explained-beats-97-time-100-memory",
                "content": "There aren\\'t that many possibilities for the numbers we could exclude to get the max sum divisible by 3. Either the sum of `nums` is divisible by 3 to begin with, (in which case, great!), or we need to remove numbers that aren\\'t divisible by 3 to get there. You can\\'t exclude both a mod3=1 and a mod3=2 number, because together they\\'d be divisible by 3. And you\\'d only want to exclude the lowest possible mod3=1 or mod3=2 numbers, so there\\'s only 4 different possible solutions:\\n* Remove the smallest mod3=1 element\\n* Remove the smallest 2 mod3=1 elements\\n* Remove the smallest mod3=2 element\\n* Remove the smallest 2 mod3=2 elements\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        if sum(nums) % 3 == 0:\\n            return sum(nums)\\n        \\n        mod1 = [num for num in nums if num % 3 == 1]\\n        mod2 = [num for num in nums if num % 3 == 2]\\n        mod1_min = min(mod1 or [float(\\'inf\\')])\\n        mod2_min = min(mod2 or [float(\\'inf\\')])\\n        mod1.remove(mod1_min)\\n        mod2.remove(mod2_min)\\n        \\n        possibilities = [ \\n            sum(nums) - mod1_min,\\n            sum(nums) - mod2_min,\\n            sum(nums) - mod1_min - min(mod1 or [float(\\'inf\\')]),\\n            sum(nums) - mod2_min - min(mod2 or [float(\\'inf\\')]),\\n        ]\\n        \\n        return max([\\n            pos for pos in possibilities if pos % 3 == 0\\n        ] or [0])\\n```\\n\\nA DP solution would make more sense for something like \"greatest sum divisible by 7\", where there would be many cominations of numbers you\\'d have to exclude, but it\\'s overengineering for something that only has a few possible outcomes :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        if sum(nums) % 3 == 0:\\n            return sum(nums)\\n        \\n        mod1 = [num for num in nums if num % 3 == 1]\\n        mod2 = [num for num in nums if num % 3 == 2]\\n        mod1_min = min(mod1 or [float(\\'inf\\')])\\n        mod2_min = min(mod2 or [float(\\'inf\\')])\\n        mod1.remove(mod1_min)\\n        mod2.remove(mod2_min)\\n        \\n        possibilities = [ \\n            sum(nums) - mod1_min,\\n            sum(nums) - mod2_min,\\n            sum(nums) - mod1_min - min(mod1 or [float(\\'inf\\')]),\\n            sum(nums) - mod2_min - min(mod2 or [float(\\'inf\\')]),\\n        ]\\n        \\n        return max([\\n            pos for pos in possibilities if pos % 3 == 0\\n        ] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592532,
                "title": "1262-greatest-sum-divisible-by-three-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Set**\\n| O(T): O() | O(S): O() | Rt: ms | TLE\\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = {0}\\n        for i in nums:\\n            s |= {i+j for j in s}\\n        return max(i for i in s if i % 3 == 0)\\n```\\nComment: easy to guess the backtracking solution is TLE as well.\\n\\n\\n**II). Bucket DP**\\n| O(T): O(n) | O(S): O(1) | Rt: 424ms | \\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        m = [0, 0, 0]\\n        for i in nums:\\n            for j in m[:]:\\n                m[(i+j) % 3] = max(m[(i+j) % 3], i+j)\\n        return m[0]\\n```\\nReferrence: https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space",
                "solutionTags": [],
                "code": "```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = {0}\\n        for i in nums:\\n            s |= {i+j for j in s}\\n        return max(i for i in s if i % 3 == 0)\\n```\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        m = [0, 0, 0]\\n        for i in nums:\\n            for j in m[:]:\\n                m[(i+j) % 3] = max(m[(i+j) % 3], i+j)\\n        return m[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 589195,
                "title": "python-memory-100",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D={0:[],1:[],2:[]}\\n        for n in nums:\\n            D[n%3].append(n)\\n        for k in range(3):\\n            D[k].sort()\\n        S=sum(nums)\\n        if S%3==0:\\n            return S\\n        elif S%3==1:\\n            a=0\\n            b=0\\n            if len(D[1])>=1:\\n                a=S-D[1][0]\\n            if len(D[2])>=2:\\n                b=S-D[2][0]-D[2][1]\\n            return(max(a,b))\\n        elif S%3==2:\\n            a=0\\n            b=0\\n            if len(D[2])>=1:\\n                a=S-D[2][0]\\n            if len(D[1])>=2:\\n                b=S-D[1][0]-D[1][1]\\n            return(max(a,b))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D={0:[],1:[],2:[]}\\n        for n in nums:\\n            D[n%3].append(n)\\n        for k in range(3):\\n            D[k].sort()\\n        S=sum(nums)\\n        if S%3==0:\\n            return S\\n        elif S%3==1:\\n            a=0\\n            b=0\\n            if len(D[1])>=1:\\n                a=S-D[1][0]\\n            if len(D[2])>=2:\\n                b=S-D[2][0]-D[2][1]\\n            return(max(a,b))\\n        elif S%3==2:\\n            a=0\\n            b=0\\n            if len(D[2])>=1:\\n                a=S-D[2][0]\\n            if len(D[1])>=2:\\n                b=S-D[1][0]-D[1][1]\\n            return(max(a,b))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580822,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int dp[][]=new int[nums.length][3];\\n        dp[0][nums[0]%3]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int index1=(nums[i]+dp[i-1][0])%3;\\n            int index2=(nums[i]+dp[i-1][1])%3;\\n            int index3=(nums[i]+dp[i-1][2])%3;\\n            dp[i][index1]=Math.max(dp[i][index1],nums[i]+dp[i-1][0]);\\n            dp[i][index2]=Math.max(dp[i][index2],nums[i]+dp[i-1][1]);\\n            dp[i][index3]=Math.max(dp[i][index3],nums[i]+dp[i-1][2]);\\n            dp[i][0]=Math.max(dp[i][0],dp[i-1][0]);\\n            dp[i][1]=Math.max(dp[i][1],dp[i-1][1]);\\n            dp[i][2]=Math.max(dp[i][2],dp[i-1][2]);\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int dp[][]=new int[nums.length][3];\\n        dp[0][nums[0]%3]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int index1=(nums[i]+dp[i-1][0])%3;\\n            int index2=(nums[i]+dp[i-1][1])%3;\\n            int index3=(nums[i]+dp[i-1][2])%3;\\n            dp[i][index1]=Math.max(dp[i][index1],nums[i]+dp[i-1][0]);\\n            dp[i][index2]=Math.max(dp[i][index2],nums[i]+dp[i-1][1]);\\n            dp[i][index3]=Math.max(dp[i][index3],nums[i]+dp[i-1][2]);\\n            dp[i][0]=Math.max(dp[i][0],dp[i-1][0]);\\n            dp[i][1]=Math.max(dp[i][1],dp[i-1][1]);\\n            dp[i][2]=Math.max(dp[i][2],dp[i-1][2]);\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538722,
                "title": "python-simple-solution-o-n",
                "content": "```class Solution(object):\\n    def maxSumDivThree(self, nums):\\n        seen = {\\n            0: [],\\n            1: [],\\n            2: []\\n        }\\n        \\n        for num in nums:\\n            seen[num % 3].append(num)\\n        \\n        s = sum(seen[0] + seen[1] + seen[2])\\n        remainderOne = sorted(seen[1])[:2]\\n        remainderTwo = sorted(seen[2])[:2]\\n        \\n        if s % 3 == 2:\\n            if len(remainderOne) < 2 and len(remainderTwo) < 1:\\n                return 0\\n            elif len(remainderOne) < 2:\\n                return s - remainderTwo[0]\\n            elif len(remainderTwo) < 1:\\n                return s - sum(remainderOne)\\n            return s - min(sum(remainderOne), remainderTwo[0])\\n        \\n        elif s % 3 == 1:\\n            if len(remainderOne) < 1 and len(remainderTwo) < 2:\\n                return 0\\n            elif len(remainderOne) < 1:\\n                return s - sum(remainderTwo)\\n            elif len(remainderTwo) < 2:\\n                return s - remainderOne[0]\\n            return s - min(remainderOne[0], sum(remainderTwo))\\n        \\n        return s\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxSumDivThree(self, nums):\\n        seen = {\\n            0: [],\\n            1: [],\\n            2: []\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 535819,
                "title": "simple-python3-solution-using-dp-with-examples",
                "content": "Easy-understandable solution.\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n            3  6  5  1   8  \\n        0   3  9  9  15  18 \\n        1   0  0  0  10  10 \\n        2   0  0  14 0   23\\n        \\n            1  2  3  4  4\\n        0   0  3  6  9  12\\n        1   1  1  4 10  13\\n        2   0  2  5  8  14\\n        \\n        \\'\\'\\'\\n        \\n        m = [[0 for n in range(len(nums))] for n in range(3)]\\n        m[nums[0] % 3][0] = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                m[j][i] = m [j][i-1]\\n        \\n            for j in range(3):\\n                n = m[j][i-1] + nums[i]\\n                mod = n % 3\\n                if m[mod][i] < n:\\n                    m[mod][i] = n\\n                    \\n        \\n        return m[0][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n            3  6  5  1   8  \\n        0   3  9  9  15  18 \\n        1   0  0  0  10  10 \\n        2   0  0  14 0   23\\n        \\n            1  2  3  4  4\\n        0   0  3  6  9  12\\n        1   1  1  4 10  13\\n        2   0  2  5  8  14\\n        \\n        \\'\\'\\'\\n        \\n        m = [[0 for n in range(len(nums))] for n in range(3)]\\n        m[nums[0] % 3][0] = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                m[j][i] = m [j][i-1]\\n        \\n            for j in range(3):\\n                n = m[j][i-1] + nums[i]\\n                mod = n % 3\\n                if m[mod][i] < n:\\n                    m[mod][i] = n\\n                    \\n        \\n        return m[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521926,
                "title": "straightforward-24ms-o-n-dp-even-handles-negative-elements",
                "content": "```\\nclass Solution {\\n    \\nint sub(int k, int i) {\\n    int tmp = k - ((i%3+3)%3);\\n    if (tmp < 0) {\\n        return tmp + 3;\\n    }\\n    return tmp;\\n}\\n    \\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        int oo = INT_MIN;\\n        int n = nums.size();\\n        int dp[n][3];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (!i) {\\n                    if (!j) {\\n                        dp[i][j] = (nums[i]%3 == 0 ? max(nums[i],0) : 0);\\n                    }\\n                    else {\\n                        dp[i][j] = (nums[i]%3 == j ? nums[i] : oo);\\n                    }\\n                }\\n                else {\\n                    int excl = dp[i-1][j];\\n                    int incl = dp[i-1][sub(j,nums[i])];\\n                    if (excl == oo) {\\n                        if (incl == oo) {\\n                            dp[i][j] = oo;\\n                        }\\n                        else {\\n                            dp[i][j] = incl + nums[i];\\n                        }\\n                    }\\n                    else {\\n                        if (incl == oo) {\\n                            dp[i][j] = excl;\\n                        }\\n                        else {\\n                            dp[i][j] = max(excl, incl+nums[i]);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return dp[n-1][0]; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nint sub(int k, int i) {\\n    int tmp = k - ((i%3+3)%3);\\n    if (tmp < 0) {\\n        return tmp + 3;\\n    }\\n    return tmp;\\n}\\n    \\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        int oo = INT_MIN;\\n        int n = nums.size();\\n        int dp[n][3];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (!i) {\\n                    if (!j) {\\n                        dp[i][j] = (nums[i]%3 == 0 ? max(nums[i],0) : 0);\\n                    }\\n                    else {\\n                        dp[i][j] = (nums[i]%3 == j ? nums[i] : oo);\\n                    }\\n                }\\n                else {\\n                    int excl = dp[i-1][j];\\n                    int incl = dp[i-1][sub(j,nums[i])];\\n                    if (excl == oo) {\\n                        if (incl == oo) {\\n                            dp[i][j] = oo;\\n                        }\\n                        else {\\n                            dp[i][j] = incl + nums[i];\\n                        }\\n                    }\\n                    else {\\n                        if (incl == oo) {\\n                            dp[i][j] = excl;\\n                        }\\n                        else {\\n                            dp[i][j] = max(excl, incl+nums[i]);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return dp[n-1][0]; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 514523,
                "title": "python3-o-n-time-o-1-space",
                "content": "```class Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D, Max = {}, 0\\n        Max1, Max2, Max3 =  0, 0 , 0\\n        for i in range(len(nums)):\\n            D[0], D[1], D[2] = 0, 0, 0\\n            D[nums[i]%3] = nums[i]\\n            if not Max1 == 0:\\n                D[(Max1 + nums[i])%3] = Max1 + nums[i]\\n            if not Max2 == 0:\\n                D[(Max2 + nums[i])%3] = Max2 + nums[i]\\n            if not Max3 == 0:\\n                D[(Max3 + nums[i])%3] = Max3 + nums[i]\\n            Max1, Max2, Max3 = max(Max1, D[0]), max(Max2, D[1]), max(D[2], Max3)\\n            \\n            Max = max(Max, D[0])\\n            \\n        return Max",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D, Max = {}",
                "codeTag": "Java"
            },
            {
                "id": 506895,
                "title": "python-dp-o-n-solution-with-simple-explanations",
                "content": "While passing through the list, update the array \"sums\", where sums[0] is the maximum sum of elements passed so far which is divisible by 3, sums[1] is the max sum of encountered elements which is divisible by 3 with remainder 1, and sums[2] is ... divisible by 3 with remainder 2. It is easy to see how these values have to be updated. For instance, if we encounter element n of the given array such that n % 3 == 1, then we know that adding that element to nums[2] (provided nums[2] is non-zero, which we check for) will give the sum which is divisible by 3. So we will have to see if nums[0] needs to be updated, i.e., whether the resulting sum, divisible by 3, is larger than what we already had in nums[0].\\n\\n```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        sums = [0, 0, 0]\\n        for n in nums:\\n            if n % 3 == 0:\\n                sums[0] += n\\n                if sums[1] > 0:\\n                    sums[1] += n\\n                if sums[2] > 0:\\n                    sums[2] += n\\n            elif n % 3 == 1:\\n                [n0, n1, n2] = sums\\n                if sums[2] > 0:\\n                    n0 = max(n0, sums[2]+n)\\n                n1 = max(n1, sums[0]+n)\\n                if sums[1] > 0:\\n                    n2 = max(n2, sums[1]+n)\\n                sums = [n0, n1, n2]\\n            else:\\n                [n0, n1, n2] = sums\\n                if sums[1] > 0:\\n                    n0 = max(n0, sums[1]+n)\\n                if sums[2] > 0:\\n                    n1 = max(n1, sums[2]+n)\\n                n2 = max(n2, sums[0]+n)\\n                sums = [n0, n1, n2]\\n        return sums[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        sums = [0, 0, 0]\\n        for n in nums:\\n            if n % 3 == 0:\\n                sums[0] += n\\n                if sums[1] > 0:\\n                    sums[1] += n\\n                if sums[2] > 0:\\n                    sums[2] += n\\n            elif n % 3 == 1:\\n                [n0, n1, n2] = sums\\n                if sums[2] > 0:\\n                    n0 = max(n0, sums[2]+n)\\n                n1 = max(n1, sums[0]+n)\\n                if sums[1] > 0:\\n                    n2 = max(n2, sums[1]+n)\\n                sums = [n0, n1, n2]\\n            else:\\n                [n0, n1, n2] = sums\\n                if sums[1] > 0:\\n                    n0 = max(n0, sums[1]+n)\\n                if sums[2] > 0:\\n                    n1 = max(n1, sums[2]+n)\\n                n2 = max(n2, sums[0]+n)\\n                sums = [n0, n1, n2]\\n        return sums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499454,
                "title": "easy-well-explained-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>> dp(3,vector<int>(nums.size(),0));\\n        int state = nums[0]%3;\\n        for(int i=0;i<3;i++){\\n            if(i == state){\\n                dp[i][0] = nums[0];\\n            }\\n            else{\\n                dp[i][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=1;j<nums.size();j++){\\n            for(int i=0;i<3;i++){\\n                dp[(nums[j] + dp[i][j-1])%3][j] = max(dp[(nums[j] + dp[i][j-1])%3][j], nums[j] + dp[i][j-1]);\\n            }\\n            dp[nums[j]%3][j] = max(dp[nums[j]%3][j],nums[j]);\\n            for(int i=0;i<3;i++){\\n                dp[i][j] = max(dp[i][j-1],dp[i][j]);\\n            }\\n        }\\n\\t    return dp[0][nums.size()-1];\\n}\\n};\\n```\\nIn the main loop The following information is stored in dp:\\n1.There are 3 possibilites for each state `dp[i][j]` where i is the state number and j is the jth index in nums array\\n2.We take **max** of : a) current nums and each of previous state value and then find the new state into which this whole value will be inserted\\nb) Exclude current nums and calculate max of a) and previous dp state(`dp[i][j-1]` for my code)\\nc) Also check if nums[j] itself can go to a state with value higher than a) or b).",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>> dp(3,vector<int>(nums.size(),0));\\n        int state = nums[0]%3;\\n        for(int i=0;i<3;i++){\\n            if(i == state){\\n                dp[i][0] = nums[0];\\n            }\\n            else{\\n                dp[i][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=1;j<nums.size();j++){\\n            for(int i=0;i<3;i++){\\n                dp[(nums[j] + dp[i][j-1])%3][j] = max(dp[(nums[j] + dp[i][j-1])%3][j], nums[j] + dp[i][j-1]);\\n            }\\n            dp[nums[j]%3][j] = max(dp[nums[j]%3][j],nums[j]);\\n            for(int i=0;i<3;i++){\\n                dp[i][j] = max(dp[i][j-1],dp[i][j]);\\n            }\\n        }\\n\\t    return dp[0][nums.size()-1];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476653,
                "title": "python-one-pass-o-n-time-o-1-space-no-dp",
                "content": "We don\\'t need to use DP for this problem.\\n\\nThere can only be 3 cases for the sum of the whole array:\\nsum % 3 = 0: directly return the result.\\n\\nsum % 3 = 1: we can subtract the smallest number x that (x % 3) = 1, or substract two smallest numbers that has remainder 2.\\n\\nsum % 3 = 2: roughly the same.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod1 = [float(\\'inf\\'), float(\\'inf\\')]\\n        mod2 = [float(\\'inf\\'), float(\\'inf\\')]\\n        sums = 0\\n        \\n        for number in nums:\\n            sums += number\\n            \\n            r = number % 3\\n            if r == 2:\\n                mod2.append(number)\\n                mod2.sort()\\n                mod2.pop()\\n            elif r == 1:\\n                mod1.append(number)\\n                mod1.sort()\\n                mod1.pop()\\n        \\n        r = sums % 3\\n        if not r:\\n            return sums\\n        elif r == 1:\\n            return max(sums - sum(mod2), sums - mod1[0])\\n        else:\\n            return max(sums - sum(mod1), sums - mod2[0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod1 = [float(\\'inf\\'), float(\\'inf\\')]\\n        mod2 = [float(\\'inf\\'), float(\\'inf\\')]\\n        sums = 0\\n        \\n        for number in nums:\\n            sums += number\\n            \\n            r = number % 3\\n            if r == 2:\\n                mod2.append(number)\\n                mod2.sort()\\n                mod2.pop()\\n            elif r == 1:\\n                mod1.append(number)\\n                mod1.sort()\\n                mod1.pop()\\n        \\n        r = sums % 3\\n        if not r:\\n            return sums\\n        elif r == 1:\\n            return max(sums - sum(mod2), sums - mod1[0])\\n        else:\\n            return max(sums - sum(mod1), sums - mod2[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457247,
                "title": "greedy-approach-is-working",
                "content": "```\\nclass Solution { \\n    public int maxSumDivThree(int[] nums) {\\n        ArrayList<Integer>mod1 = new ArrayList();\\n        ArrayList<Integer>mod2 = new ArrayList();\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum +=nums[i];\\n            if(nums[i]%3==1){\\n                mod1.add(nums[i]);\\n            }\\n            if(nums[i]%3==2){\\n                mod2.add(nums[i]);\\n            }\\n        }\\n        Collections.sort(mod1);\\n        Collections.sort(mod2);\\n        if(sum%3==0){\\n            return sum;\\n        }\\n        else if(sum%3==1){\\n            int x = 0,y=0;\\n            if(mod1.size()>=1){\\n                x = sum - mod1.get(0);\\n            }\\n            if(mod2.size()>=2){\\n                y = sum - mod2.get(0) - mod2.get(1);\\n                }\\n            return Math.max(x,y);\\n        }\\n        else if(sum%3==2){\\n            int x = 0,y = 0;\\n            if(mod2.size()>=1){\\n                x = sum - mod2.get(0);\\n            }\\n            if(mod1.size()>=2){\\n                y = sum - mod1.get(0) - mod1.get(1);\\n            }\\n            return Math.max(x,y);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int maxSumDivThree(int[] nums) {\\n        ArrayList<Integer>mod1 = new ArrayList();\\n        ArrayList<Integer>mod2 = new ArrayList();\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum +=nums[i];\\n            if(nums[i]%3==1){\\n                mod1.add(nums[i]);\\n            }\\n            if(nums[i]%3==2){\\n                mod2.add(nums[i]);\\n            }\\n        }\\n        Collections.sort(mod1);\\n        Collections.sort(mod2);\\n        if(sum%3==0){\\n            return sum;\\n        }\\n        else if(sum%3==1){\\n            int x = 0,y=0;\\n            if(mod1.size()>=1){\\n                x = sum - mod1.get(0);\\n            }\\n            if(mod2.size()>=2){\\n                y = sum - mod2.get(0) - mod2.get(1);\\n                }\\n            return Math.max(x,y);\\n        }\\n        else if(sum%3==2){\\n            int x = 0,y = 0;\\n            if(mod2.size()>=1){\\n                x = sum - mod2.get(0);\\n            }\\n            if(mod1.size()>=2){\\n                y = sum - mod1.get(0) - mod1.get(1);\\n            }\\n            return Math.max(x,y);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449653,
                "title": "a-more-generalised-code-can-work-on-divisibilty-with-any-number",
                "content": "DP[i,j] = represents largest sum we can get till i whose sum modulo k(here k=3) is j. Each time we\\'ll have to options, either include the sum or not:- Hence, DP[i,j]=max(DP[i-1,x] + nums[i], DP[i-1,j] where x + nums[i] == j mod k The result will be DP[n,0]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int i,j,n=nums.size();\\n        int k=3;\\n        \\n        int dp[n+1][k];\\n        memset(dp,0,sizeof dp);\\n        \\n        for (j = 0; j < k; j++) dp[0][j] = 0;\\n\\n         for (i = 1; i <= n; i++)\\n          for (j = 0; j < k; j++)\\n          {\\n           int x = (j + k - nums[i-1]%k) % k;\\n\\t\\t   //This is to check if the sum fulfills the condition or not because initially we\\'re considering sum as zero for every column and  any column other than zeroth col will have  0 mod j==0 which is wrong \\n            if((dp[i-1][x]+nums[i-1])%3==j)\\n             dp[i][j] = max(dp[i-1][x]+nums[i-1], dp[i-1][j]);\\n            else\\n             dp[i][j] = dp[i-1][j];\\n          }\\n        \\n        return dp[n][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int i,j,n=nums.size();\\n        int k=3;\\n        \\n        int dp[n+1][k];\\n        memset(dp,0,sizeof dp);\\n        \\n        for (j = 0; j < k; j++) dp[0][j] = 0;\\n\\n         for (i = 1; i <= n; i++)\\n          for (j = 0; j < k; j++)\\n          {\\n           int x = (j + k - nums[i-1]%k) % k;\\n\\t\\t   //This is to check if the sum fulfills the condition or not because initially we\\'re considering sum as zero for every column and  any column other than zeroth col will have  0 mod j==0 which is wrong \\n            if((dp[i-1][x]+nums[i-1])%3==j)\\n             dp[i][j] = max(dp[i-1][x]+nums[i-1], dp[i-1][j]);\\n            else\\n             dp[i][j] = dp[i-1][j];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 440372,
                "title": "c-24ms-beat-98-81-python-256ms-beat-96-55",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res += nums[i];\\n            \\n            if (nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            else if (nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n\\n        int var11 = 100000;\\n        int var12 = 100000;\\n        int var21 = 100000;\\n        int var22 = 100000;\\n        if (pq1.size() > 0) { var11 = pq1.top(); pq1.pop(); }\\n        if (pq1.size() > 0) { var12 = pq1.top(); }\\n        if (pq2.size() > 0) { var21 = pq2.top(); pq2.pop(); }\\n        if (pq2.size() > 0) { var22 = pq2.top(); }\\n\\n        if (res % 3 == 1)\\n            res -= min(var11,var21+var22);\\n        else if (res % 3 == 2)\\n            res -= min(var21,var11+var12);\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums):\\n        pq1, pq2 = [], []\\n\\n        res = 0\\n        for i in nums:\\n            res += i\\n            \\n            if i % 3 == 1:\\n                heapq.heappush(pq1,i)\\n            elif i % 3 == 2:\\n                heapq.heappush(pq2,i)\\n\\n        var11, var12, var21, var22 = 100000, 100000, 100000, 100000\\n        if len(pq1) > 0: var11 = pq1[0]\\n        if len(pq2) > 0: var21 = pq2[0]\\n\\n        if len(pq1) > 1: \\n            heapq.heappop(pq1)\\n            var12 = pq1[0]\\n        \\n        if len(pq2) > 1: \\n            heapq.heappop(pq2)\\n            var22 = pq2[0]\\n\\n        if res % 3 == 1:\\n            res -= min(var11,var21+var22)\\n        elif res % 3 == 2:\\n            res -= min(var21,var11+var12)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res += nums[i];\\n            \\n            if (nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            else if (nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n\\n        int var11 = 100000;\\n        int var12 = 100000;\\n        int var21 = 100000;\\n        int var22 = 100000;\\n        if (pq1.size() > 0) { var11 = pq1.top(); pq1.pop(); }\\n        if (pq1.size() > 0) { var12 = pq1.top(); }\\n        if (pq2.size() > 0) { var21 = pq2.top(); pq2.pop(); }\\n        if (pq2.size() > 0) { var22 = pq2.top(); }\\n\\n        if (res % 3 == 1)\\n            res -= min(var11,var21+var22);\\n        else if (res % 3 == 2)\\n            res -= min(var21,var11+var12);\\n\\n        return res;\\n    }\\n};\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums):\\n        pq1, pq2 = [], []\\n\\n        res = 0\\n        for i in nums:\\n            res += i\\n            \\n            if i % 3 == 1:\\n                heapq.heappush(pq1,i)\\n            elif i % 3 == 2:\\n                heapq.heappush(pq2,i)\\n\\n        var11, var12, var21, var22 = 100000, 100000, 100000, 100000\\n        if len(pq1) > 0: var11 = pq1[0]\\n        if len(pq2) > 0: var21 = pq2[0]\\n\\n        if len(pq1) > 1: \\n            heapq.heappop(pq1)\\n            var12 = pq1[0]\\n        \\n        if len(pq2) > 1: \\n            heapq.heappop(pq2)\\n            var22 = pq2[0]\\n\\n        if res % 3 == 1:\\n            res -= min(var11,var21+var22)\\n        elif res % 3 == 2:\\n            res -= min(var21,var11+var12)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433793,
                "title": "python-dp-solution",
                "content": "Explaination:\\n        m0: the maximum possible sum of elements of the array such that it is divisible by three.\\n        m1: the maximum possible sum of elements of the array such that it is divisible by three mod 1.\\n        m2: the maximum possible sum of elements of the array such that it is divisible by three mod 2.\\n        then given number n, we can get new m0/m1/m2\\n\\t\\t\\n```python\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n       \\n        \"\"\"\\n        m0 = 0\\n        m1 = 0\\n        m2 = 0\\n        for n in nums:\\n            m = n % 3\\n            m0n, m1n, m2n = m0, m1, m2\\n            \\n            if m == 0:\\n                m0n = m0 + n\\n                m1n = m1 + n\\n                m2n = m2 + n\\n            elif m == 1:\\n                if m2 % 3 == 2:\\n                    m0n = max(m0, m2 + n)\\n                m1n = max(m1, m0 + n)\\n                if m1 % 3 == 1:\\n                    m2n = max(m2, m1 + n)\\n            elif m == 2:\\n                if m1 % 3 == 1:\\n                    m0n = max(m0, m1 + n)\\n                if m2 % 3 == 2:\\n                    m1n = max(m1, m2 + n)\\n                m2n = max(m2, m0 + n)\\n            m0, m1, m2 = m0n, m1n, m2n\\n            \\n        return m0\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n       \\n        \"\"\"\\n        m0 = 0\\n        m1 = 0\\n        m2 = 0\\n        for n in nums:\\n            m = n % 3\\n            m0n, m1n, m2n = m0, m1, m2\\n            \\n            if m == 0:\\n                m0n = m0 + n\\n                m1n = m1 + n\\n                m2n = m2 + n\\n            elif m == 1:\\n                if m2 % 3 == 2:\\n                    m0n = max(m0, m2 + n)\\n                m1n = max(m1, m0 + n)\\n                if m1 % 3 == 1:\\n                    m2n = max(m2, m1 + n)\\n            elif m == 2:\\n                if m1 % 3 == 1:\\n                    m0n = max(m0, m1 + n)\\n                if m2 % 3 == 2:\\n                    m1n = max(m1, m2 + n)\\n                m2n = max(m2, m0 + n)\\n            m0, m1, m2 = m0n, m1n, m2n\\n            \\n        return m0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431312,
                "title": "java-dp-solution-beats-100-o-n-time-and-o-n-space",
                "content": "The idea is to store the maximum sum at each position with each mod 0, 1 and 2;\\ndp[pos][mod] stores the max sum possible till position pos with mod. \\nThe sum at ith position can be derived by the maximum sum available at i-1th position. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0]%3] = nums[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<3; j++) \\n                dp[i][j] = dp[i-1][j];\\n            for(int j=0; j<3; j++) {\\n                int res = dp[i-1][j]+nums[i];\\n                dp[i][res%3] = Math.max(dp[i][res%3], res);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0]%3] = nums[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<3; j++) \\n                dp[i][j] = dp[i-1][j];\\n            for(int j=0; j<3; j++) {\\n                int res = dp[i-1][j]+nums[i];\\n                dp[i][res%3] = Math.max(dp[i][res%3], res);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431186,
                "title": "java-dp-0-1-knapsack",
                "content": "```\\nclass Solution {\\n    static int max=0;\\n    public int maxSumDivThree(int[] nums) {\\n        int[][]dp=new int[nums.length][3];\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0){\\n                dp[0][nums[0]%3]=nums[0];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                for(int j=0;j<3;j++){\\n                    int res=dp[i-1][j]+nums[i];\\n                    dp[i][res%3]=Math.max(dp[i][res%3],res);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int max=0;\\n    public int maxSumDivThree(int[] nums) {\\n        int[][]dp=new int[nums.length][3];\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0){\\n                dp[0][nums[0]%3]=nums[0];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                for(int j=0;j<3;j++){\\n                    int res=dp[i-1][j]+nums[i];\\n                    dp[i][res%3]=Math.max(dp[i][res%3],res);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431116,
                "title": "java-solution-with-detailed-explanation",
                "content": "The key idea to solving this problem is that if we add all of the numbers in the array up then the sum mod three can only be 3 values: 0, 1, and 2.\\n\\nIf ```sum % 3 = 0``` then we\\'re done.\\n\\nIf ```sum % 3 == 1``` then sum is of the form ```n % 3 + 1``` therefore to make it divisible by 3 with the smallest subtractions the possibilities are:\\n\\n```n * 3 + 1 - mod1_min[0] = n * 3 + 1 - (m * 3 + 1) = (n - m) * 3 => Divisible by 3```\\nor\\n```n * 3 + 1 - mod2_min[0] - mod2_min[1] = n * 3 + 1 - (m * 3 + 2) - (l * 3 + 2) = (n - m - l) * 3 - 3 = (n - m - l - 1) * 3 => Divisible by 3```\\n\\nThere are other possibilities to make the sum divisible by 3 however note that they will all be smaller than the results obtained by these options.\\n\\nif ```sum % 3 == 2``` then similar expressions as for ```sum % 3 == 1``` can be found.\\n\\nSolution:\\n\\n```Java\\npublic int maxSumDivThree(int[] nums)\\n{\\n    int sum = 0;\\n    int[] mod1_mins = new int[2];\\n    int[] mod2_mins = new int[2];\\n    \\n    Arrays.fill(mod1_mins, Integer.MAX_VALUE);\\n    Arrays.fill(mod2_mins, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int tmpMod = nums[i] % 3;\\n        \\n        sum += nums[i];\\n        \\n        if (tmpMod == 1)\\n        {\\n            if (nums[i] < mod1_mins[0])\\n            {\\n                mod1_mins[1] = mod1_mins[0];\\n                mod1_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod1_mins[1])\\n                mod1_mins[1] = nums[i];\\n        }\\n        else if (tmpMod == 2)\\n        {\\n            if (nums[i] < mod2_mins[0])\\n            {\\n                mod2_mins[1] = mod2_mins[0];\\n                mod2_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod2_mins[1])\\n                mod2_mins[1] = nums[i];\\n        }\\n    }\\n    \\n    int sumMod = sum % 3;\\n    int rem;\\n    \\n    if (sumMod == 1)\\n    {\\n        rem = mod1_mins[0];\\n        \\n        //Check for potential overflow...\\n        if (mod2_mins[0] != Integer.MAX_VALUE && mod2_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod2_mins[0] + mod2_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    else if (sumMod == 2)\\n    {\\n        rem = mod2_mins[0];\\n        \\n        if (mod1_mins[0] != Integer.MAX_VALUE && mod1_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod1_mins[0] + mod1_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    \\n    return sum;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```sum % 3 = 0```\n```sum % 3 == 1```\n```n % 3 + 1```\n```n * 3 + 1 - mod1_min[0] = n * 3 + 1 - (m * 3 + 1) = (n - m) * 3 => Divisible by 3```\n```n * 3 + 1 - mod2_min[0] - mod2_min[1] = n * 3 + 1 - (m * 3 + 2) - (l * 3 + 2) = (n - m - l) * 3 - 3 = (n - m - l - 1) * 3 => Divisible by 3```\n```sum % 3 == 2```\n```sum % 3 == 1```\n```Java\\npublic int maxSumDivThree(int[] nums)\\n{\\n    int sum = 0;\\n    int[] mod1_mins = new int[2];\\n    int[] mod2_mins = new int[2];\\n    \\n    Arrays.fill(mod1_mins, Integer.MAX_VALUE);\\n    Arrays.fill(mod2_mins, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int tmpMod = nums[i] % 3;\\n        \\n        sum += nums[i];\\n        \\n        if (tmpMod == 1)\\n        {\\n            if (nums[i] < mod1_mins[0])\\n            {\\n                mod1_mins[1] = mod1_mins[0];\\n                mod1_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod1_mins[1])\\n                mod1_mins[1] = nums[i];\\n        }\\n        else if (tmpMod == 2)\\n        {\\n            if (nums[i] < mod2_mins[0])\\n            {\\n                mod2_mins[1] = mod2_mins[0];\\n                mod2_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod2_mins[1])\\n                mod2_mins[1] = nums[i];\\n        }\\n    }\\n    \\n    int sumMod = sum % 3;\\n    int rem;\\n    \\n    if (sumMod == 1)\\n    {\\n        rem = mod1_mins[0];\\n        \\n        //Check for potential overflow...\\n        if (mod2_mins[0] != Integer.MAX_VALUE && mod2_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod2_mins[0] + mod2_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    else if (sumMod == 2)\\n    {\\n        rem = mod2_mins[0];\\n        \\n        if (mod1_mins[0] != Integer.MAX_VALUE && mod1_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod1_mins[0] + mod1_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    \\n    return sum;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431075,
                "title": "python-solution-without-dp",
                "content": "```\\ndef maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = {}\\n        c[1] = []\\n        c[2] = []\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 3 == 0:\\n                res += nums[i]\\n            elif nums[i] % 3 == 1:\\n                c[1].append(nums[i])\\n            else:\\n                c[2].append(nums[i])\\n        c[1] = sorted(c[1])\\n        c[2] = sorted(c[2])\\n        print(c[2])\\n        k = sum(c[1]) + sum(c[2])\\n        res += k\\n        if k % 3 == 0:\\n            return res\\n        elif k % 3 == 1:\\n            if not c[1]:\\n                res -= (c[2][0] + c[2][1])\\n            if len(c[2]) < 2:\\n                res -= c[1][0]\\n            else:\\n                res -= min(c[1][0], c[2][0] + c[2][1])\\n        else:\\n            if not c[2]:\\n                res -= (c[1][0] + c[1][1])\\n            if len(c[1]) < 2:\\n                res -= c[2][0]\\n            else:\\n                res -= min(c[2][0], c[1][0] + c[1][1])\\n        return res",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = {}\\n        c[1] = []\\n        c[2] = []\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 3 == 0:\\n                res += nums[i]\\n            elif nums[i] % 3 == 1:\\n                c[1].append(nums[i])\\n            else:\\n                c[2].append(nums[i])\\n        c[1] = sorted(c[1])\\n        c[2] = sorted(c[2])\\n        print(c[2])\\n        k = sum(c[1]) + sum(c[2])\\n        res += k\\n        if k % 3 == 0:\\n            return res\\n        elif k % 3 == 1:\\n            if not c[1]:\\n                res -= (c[2][0] + c[2][1])\\n            if len(c[2]) < 2:\\n                res -= c[1][0]\\n            else:\\n                res -= min(c[1][0], c[2][0] + c[2][1])\\n        else:\\n            if not c[2]:\\n                res -= (c[1][0] + c[1][1])\\n            if len(c[1]) < 2:\\n                res -= c[2][0]\\n            else:\\n                res -= min(c[2][0], c[1][0] + c[1][1])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 4069129,
                "title": "easy-way-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif a%b=c%b so (a-c)%b==0\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we need to find 2 smallest elements that %3==1 and %3==2;\\neasy sort the vector\\ncompare sum of 2 smallest %3==2 with the smallest %3==1 to find the smallest sum %3==1;\\ndo the same way to find smallest sum %3==2;\\nuse this recipe to solve\\nif  (a%b=c%b)   so  ((a-c)%b==0)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))+O(n);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int s=0;\\n        int m11=10000,m12=10000,m21=10001,m22=10001;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0;i<nums.size();i++)\\n            {\\n            s=s+nums[i];\\n            if (nums[i]%3==1)\\n                if (m11==10000)\\n                    m11=nums[i];\\n                    else if (m12==10000)\\n                    m12=nums[i];\\n            if (nums[i]%3==2)\\n                if (m21==10001)\\n                    m21=nums[i];\\n                    else if (m22==10001)\\n                    m22=nums[i];\\n        }\\n    if (s%3==1)\\n    return s-(min(m11,m21+m22));\\n    else if (s%3==2)\\n    return s-(min(m21,m12+m11));\\n    else return s;\\n    ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int s=0;\\n        int m11=10000,m12=10000,m21=10001,m22=10001;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0;i<nums.size();i++)\\n            {\\n            s=s+nums[i];\\n            if (nums[i]%3==1)\\n                if (m11==10000)\\n                    m11=nums[i];\\n                    else if (m12==10000)\\n                    m12=nums[i];\\n            if (nums[i]%3==2)\\n                if (m21==10001)\\n                    m21=nums[i];\\n                    else if (m22==10001)\\n                    m22=nums[i];\\n        }\\n    if (s%3==1)\\n    return s-(min(m11,m21+m22));\\n    else if (s%3==2)\\n    return s-(min(m21,m12+m11));\\n    else return s;\\n    ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056521,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3, INT_MIN));\\n\\n        // Initialize the base case\\n        dp[0][0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            int remainder = nums[i - 1] % 3;\\n\\n            for (int j = 0; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j];  // Initialize with the previous state\\n\\n                // Update dp[i][j] using the current element\\n                int prev_remainder = (j - remainder + 3) % 3;\\n                dp[i][j] = max(dp[i][j], dp[i - 1][prev_remainder] + nums[i - 1]);\\n            }\\n        }\\n\\n        return dp[n][0];\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3, INT_MIN));\\n\\n        // Initialize the base case\\n        dp[0][0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            int remainder = nums[i - 1] % 3;\\n\\n            for (int j = 0; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j];  // Initialize with the previous state\\n\\n                // Update dp[i][j] using the current element\\n                int prev_remainder = (j - remainder + 3) % 3;\\n                dp[i][j] = max(dp[i][j], dp[i - 1][prev_remainder] + nums[i - 1]);\\n            }\\n        }\\n\\n        return dp[n][0];\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046405,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> next(3, 0), curr(3, 0);\\n        int res{};\\n\\n        next[nums.back() % 3] = nums.back();\\n\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            int mod = nums[i] % 3;\\n\\n            for(int j = 0; j < 3; j++) {\\n                if(next[j] or (mod+j)%3 == mod)\\n                    curr[(mod+j)%3] = std::max(curr[(mod+j)%3], next[j] + nums[i]);\\n                curr[j] = std::max(curr[j], next[j]);\\n            }\\n            std::swap(curr, next);\\n        } return next[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> next(3, 0), curr(3, 0);\\n        int res{};\\n\\n        next[nums.back() % 3] = nums.back();\\n\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            int mod = nums[i] % 3;\\n\\n            for(int j = 0; j < 3; j++) {\\n                if(next[j] or (mod+j)%3 == mod)\\n                    curr[(mod+j)%3] = std::max(curr[(mod+j)%3], next[j] + nums[i]);\\n                curr[j] = std::max(curr[j], next[j]);\\n            }\\n            std::swap(curr, next);\\n        } return next[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936537,
                "title": "simple-javascript",
                "content": "\\n```\\n\\nconst maxSumDivThree = function (nums) {\\n  const sum = nums.reduce((a, c) => a + c);\\n\\n  if (sum % 3 === 0) return sum;\\n\\n  nums.sort((a, b) => a - b)\\n\\n  let numsSum = 0;\\n  let singleNumDiff = 0;\\n  let multiNumSumDiff = 0;\\n\\n  for (const num of nums) {\\n    if ((sum - num) % 3 === 0) {\\n      singleNumDiff = sum - num;\\n      break;\\n    }\\n  }\\n\\n  for (const num of nums) {\\n    if (num % 3) numsSum += num;\\n    if ((sum - numsSum) % 3 === 0) {\\n      multiNumSumDiff = sum - numsSum;\\n      break;\\n    }\\n  }\\n\\n  return Math.max(singleNumDiff, multiNumSumDiff);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst maxSumDivThree = function (nums) {\\n  const sum = nums.reduce((a, c) => a + c);\\n\\n  if (sum % 3 === 0) return sum;\\n\\n  nums.sort((a, b) => a - b)\\n\\n  let numsSum = 0;\\n  let singleNumDiff = 0;\\n  let multiNumSumDiff = 0;\\n\\n  for (const num of nums) {\\n    if ((sum - num) % 3 === 0) {\\n      singleNumDiff = sum - num;\\n      break;\\n    }\\n  }\\n\\n  for (const num of nums) {\\n    if (num % 3) numsSum += num;\\n    if ((sum - numsSum) % 3 === 0) {\\n      multiNumSumDiff = sum - numsSum;\\n      break;\\n    }\\n  }\\n\\n  return Math.max(singleNumDiff, multiNumSumDiff);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929509,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        \\n        total=sum(nums)\\n        q,r=divmod(total,3)\\n        \\n        if r==0:\\n            return total\\n        \\n        r1=[]\\n        r2=[]\\n        \\n        for val in nums:\\n            if val%3==1:\\n                r1.append(val)\\n            elif val%3==2:\\n                r2.append(val)\\n        \\n        r1.sort()\\n        r2.sort()\\n        \\n        if r==1:\\n            if not r1:\\n                return total-(r2[0]+r2[1])\\n            elif len(r2)<=1:\\n                return total-(r1[0])\\n            else:\\n                pos1=r1[0]\\n                pos2=r2[0]+r2[1]\\n                return total-min(pos1,pos2)\\n            \\n        elif r==2:\\n            if not r2:\\n                return total-(r1[0]+r1[1])\\n            elif len(r1)<=1:\\n                return total-(r2[0])\\n            else:\\n                pos1=r2[0]\\n                pos2=r1[0]+r1[1]\\n                return total-min(pos1,pos2)\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        \\n        total=sum(nums)\\n        q,r=divmod(total,3)\\n        \\n        if r==0:\\n            return total\\n        \\n        r1=[]\\n        r2=[]\\n        \\n        for val in nums:\\n            if val%3==1:\\n                r1.append(val)\\n            elif val%3==2:\\n                r2.append(val)\\n        \\n        r1.sort()\\n        r2.sort()\\n        \\n        if r==1:\\n            if not r1:\\n                return total-(r2[0]+r2[1])\\n            elif len(r2)<=1:\\n                return total-(r1[0])\\n            else:\\n                pos1=r1[0]\\n                pos2=r2[0]+r2[1]\\n                return total-min(pos1,pos2)\\n            \\n        elif r==2:\\n            if not r2:\\n                return total-(r1[0]+r1[1])\\n            elif len(r1)<=1:\\n                return total-(r2[0])\\n            else:\\n                pos1=r2[0]\\n                pos2=r1[0]+r1[1]\\n                return total-min(pos1,pos2)\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918754,
                "title": "a-very-intuitive-c-solution-based-on-knapsack-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI converted this problem into a knapsack problem\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    vector<int> b;\\n    // pair<int, int> dp[100001][5];\\n    // t/f, sum\\n    pair<int, int> f(int i, int s, vector<int> &a, vector<vector<pair<int, int>>> &dp)\\n    {\\n        if (i == n)\\n            return {s % 3 == 0, 0};\\n\\n        if (dp[i][s] != make_pair(-1, -1))\\n            return dp[i][s];\\n\\n        bool take = f(i + 1, (s + b[i]) % 3, a, dp).first;\\n        int nottake = f(i + 1, s, a, dp).first;\\n        if (take)\\n            return dp[i][s] = {take, max(a[i] + f(i + 1, (s + b[i]) % 3, a, dp).second, f(i + 1, s, a, dp).second)};\\n        else\\n            return dp[i][s] = {nottake, f(i + 1, s, a, dp).second};\\n    }\\n    int maxSumDivThree(vector<int> &a)\\n    {\\n        n = a.size();\\n        b.resize(n);\\n        // pair<int, int> p;\\n        // memset(dp, make_pair(-1, -1), sizeof(dp));\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(5, {-1, -1}));\\n\\n        for (int i = 0; i < n; i++)\\n            b[i] = a[i] % 3;\\n\\n        return f(0, 0, a, dp).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    vector<int> b;\\n    // pair<int, int> dp[100001][5];\\n    // t/f, sum\\n    pair<int, int> f(int i, int s, vector<int> &a, vector<vector<pair<int, int>>> &dp)\\n    {\\n        if (i == n)\\n            return {s % 3 == 0, 0};\\n\\n        if (dp[i][s] != make_pair(-1, -1))\\n            return dp[i][s];\\n\\n        bool take = f(i + 1, (s + b[i]) % 3, a, dp).first;\\n        int nottake = f(i + 1, s, a, dp).first;\\n        if (take)\\n            return dp[i][s] = {take, max(a[i] + f(i + 1, (s + b[i]) % 3, a, dp).second, f(i + 1, s, a, dp).second)};\\n        else\\n            return dp[i][s] = {nottake, f(i + 1, s, a, dp).second};\\n    }\\n    int maxSumDivThree(vector<int> &a)\\n    {\\n        n = a.size();\\n        b.resize(n);\\n        // pair<int, int> p;\\n        // memset(dp, make_pair(-1, -1), sizeof(dp));\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(5, {-1, -1}));\\n\\n        for (int i = 0; i < n; i++)\\n            b[i] = a[i] % 3;\\n\\n        return f(0, 0, a, dp).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911317,
                "title": "python-solution-in-o-n-and-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)):\\n            val=[0,0,0]\\n            for j in range(3):\\n                s=(nums[i]+arr[j])\\n                val[s%3]=max(val[s%3],s)\\n                val[j]=max(arr[j],val[j])\\n            arr=val\\n        return arr[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)):\\n            val=[0,0,0]\\n            for j in range(3):\\n                s=(nums[i]+arr[j])\\n                val[s%3]=max(val[s%3],s)\\n                val[j]=max(arr[j],val[j])\\n            arr=val\\n        return arr[0]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573843,
                "content": [
                    {
                        "username": "satish8060",
                        "content": "![image](https://assets.leetcode.com/users/satish8060/image_1590931842.png)\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "question_content": "<p>A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.</p>\n\n<p>The game is represented by an <code>m x n</code> grid of characters <code>grid</code> where each element is a wall, floor, or box.</p>\n\n<p>Your task is to move the box <code>&#39;B&#39;</code> to the target position <code>&#39;T&#39;</code> under the following rules:</p>\n\n<ul>\n\t<li>The character <code>&#39;S&#39;</code> represents the player. The player can move up, down, left, right in <code>grid</code> if it is a floor (empty cell).</li>\n\t<li>The character <code>&#39;.&#39;</code> represents the floor which means a free cell to walk.</li>\n\t<li>The character<font face=\"monospace\">&nbsp;</font><code>&#39;#&#39;</code><font face=\"monospace\">&nbsp;</font>represents the wall which means an obstacle (impossible to walk there).</li>\n\t<li>There is only one box <code>&#39;B&#39;</code> and one target cell <code>&#39;T&#39;</code> in the <code>grid</code>.</li>\n\t<li>The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a <strong>push</strong>.</li>\n\t<li>The player cannot walk through the box.</li>\n</ul>\n\n<p>Return <em>the minimum number of <strong>pushes</strong> to move the box to the target</em>. If there is no way to reach the target, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/sample_1_1620.png\" style=\"width: 500px; height: 335px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We return only the number of times the box is pushed.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],\n               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> push the box down, left, left, up and up.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid</code> contains only characters <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>, <code>&#39;S&#39;</code>, <code>&#39;T&#39;</code>, or <code>&#39;B&#39;</code>.</li>\n\t<li>There is only one character <code>&#39;S&#39;</code>, <code>&#39;B&#39;</code>, and <code>&#39;T&#39;</code> in the <code>grid</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 693918,
                "title": "python-bfs-bfs-130ms-beats-95-explained-commented",
                "content": "Lets break the question into simple parts:\\n\\n1. Lets think that we have no person and we have to find the minimum path between box and the target. Easy right? Simple BFS.\\n\\n2. If you know how to solve the first part, what I actually do is modify first part with few constraints. \\n\\t* \\tI just check whether the box can be shifted to the new position(up, down, left, right)\\n\\t* \\tFor it to be shifted to the new position the person has to be in a corresponding position right?\\n\\t* \\tSo we check if the person can travel from his old position to his corresponding new position(using another BFS). \\n\\t* \\tIf the person can travel to his new position than the box can be shifted, otherwise the box cannot be shifted.\\n\\n3. We keep repeating step 2 until we reach the target or it is not possible to move the box anymore.\\n\\nNOTE :  If you know A* algorithm, you can use Euclidean distance as heuristic and use a priority queue instead of normal queue, the worst case time might increase but average case will get better.\\n\\n\\n```\\nclass Solution:\\ndef minPushBox(self, grid: List[List[str]]) -> int:\\n\\n    # this loop is to get the coordinates of target, box and person. Nothing else is gained here\\n    for i in range(len(grid)):\\n        for j in range(len(grid[0])):\\n            if grid[i][j] == \"T\":\\n                target = (i,j)\\n            if grid[i][j] == \"B\":\\n                box = (i,j)\\n            if grid[i][j] == \"S\":\\n                person = (i,j)\\n\\n    # this function checks whether the given coordinates/indices are valid to go\\n    def valid(x,y):\\n        return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!=\\'#\\'\\n\\n    # this function checks whether the person can travel from current position to the destination position.\\n    # used simple bfs(dfs can also be used here), should be self explainatory if you know BFS.\\n    def check(curr,dest,box):\\n        que = deque([curr])\\n        v = set()\\n        while que:\\n            pos = que.popleft()\\n            if pos == dest: return True\\n            new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\\n            for x,y in new_pos:\\n                if valid(x,y) and (x,y) not in v and (x,y)!=box:\\n                    v.add((x,y))\\n                    que.append((x,y))\\n        return False\\n\\n    q = deque([(0,box,person)])\\n    vis = {box+person}\\n    # this is the main bfs which gives us the answer\\n    while q :\\n        dist, box, person = q.popleft()\\n        if box == target: # return the distance if box is at the target\\n            return dist\\n\\n        #these are the new possible coordinates/indices box can be placed in (up, down, right, left).\\n        b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\\n        #these are the corresponding coordinates the person has to be in to push .. the box into the new coordinates\\n        p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\\n\\n        for new_box,new_person in zip(b_coord,p_coord): \\n            # we check if the new box coordinates are valid and our current state is not in vis\\n            if valid(*new_box) and new_box+box not in vis:\\n                # we check corresponding person coordinates are valid and if it is possible for the person to reach the new coordinates\\n                if valid(*new_person) and check(person,new_person,box):\\n                    vis.add(new_box+box)\\n                    q.append((dist+1,new_box,box))\\n\\n    return -1\\n```\\n\\nTime = Space = O((rows*cols)^2)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\ndef minPushBox(self, grid: List[List[str]]) -> int:\\n\\n    # this loop is to get the coordinates of target, box and person. Nothing else is gained here\\n    for i in range(len(grid)):\\n        for j in range(len(grid[0])):\\n            if grid[i][j] == \"T\":\\n                target = (i,j)\\n            if grid[i][j] == \"B\":\\n                box = (i,j)\\n            if grid[i][j] == \"S\":\\n                person = (i,j)\\n\\n    # this function checks whether the given coordinates/indices are valid to go\\n    def valid(x,y):\\n        return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!=\\'#\\'\\n\\n    # this function checks whether the person can travel from current position to the destination position.\\n    # used simple bfs(dfs can also be used here), should be self explainatory if you know BFS.\\n    def check(curr,dest,box):\\n        que = deque([curr])\\n        v = set()\\n        while que:\\n            pos = que.popleft()\\n            if pos == dest: return True\\n            new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\\n            for x,y in new_pos:\\n                if valid(x,y) and (x,y) not in v and (x,y)!=box:\\n                    v.add((x,y))\\n                    que.append((x,y))\\n        return False\\n\\n    q = deque([(0,box,person)])\\n    vis = {box+person}\\n    # this is the main bfs which gives us the answer\\n    while q :\\n        dist, box, person = q.popleft()\\n        if box == target: # return the distance if box is at the target\\n            return dist\\n\\n        #these are the new possible coordinates/indices box can be placed in (up, down, right, left).\\n        b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\\n        #these are the corresponding coordinates the person has to be in to push .. the box into the new coordinates\\n        p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\\n\\n        for new_box,new_person in zip(b_coord,p_coord): \\n            # we check if the new box coordinates are valid and our current state is not in vis\\n            if valid(*new_box) and new_box+box not in vis:\\n                # we check corresponding person coordinates are valid and if it is possible for the person to reach the new coordinates\\n                if valid(*new_person) and check(person,new_person,box):\\n                    vis.add(new_box+box)\\n                    q.append((dist+1,new_box,box))\\n\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431061,
                "title": "a-star-search",
                "content": "Heuristic (an under-estimate of the remaining moves required) is the Manhattan distance between box and target.\\nA state consist of box and person locations together.\\n\\nRepeatedly pop the state with the lowest heuristic + previous moves off the heap.\\nAttempt to move the person in all 4 directions.\\nIf any direction moves the person to the box, check if the box can move to the nex position in the grid.\\n\\n```\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \"T\":\\n                    target = (r, c)\\n                if grid[r][c] == \"B\":\\n                    start_box = (r, c)\\n                if grid[r][c] == \"S\":\\n                    start_person = (r, c)\\n                    \\n        def heuristic(box):\\n            return abs(target[0] - box[0]) + abs(target[1] - box[1])\\n        \\n        def out_bounds(location):  # return whether the location is in the grid and not a wall\\n            r, c = location\\n            if r < 0 or r >= rows:\\n                return True\\n            if c < 0 or c >= cols:\\n                return True\\n            return grid[r][c] == \"#\"\\n                        \\n        heap = [[heuristic(start_box), 0, start_person, start_box]]\\n        visited = set()\\n        \\n        while heap:\\n            _, moves, person, box = heapq.heappop(heap)\\n            if box == target:\\n                return moves\\n            if (person, box) in visited: # do not visit same state again\\n                continue\\n            visited.add((person, box))\\n            \\n            for dr, dc in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                new_person = (person[0] + dr, person[1] + dc)\\n                if out_bounds(new_person):\\n                    continue\\n                    \\n                if new_person == box:\\n                    new_box = (box[0] + dr, box[1] + dc)\\n                    if out_bounds(new_box):\\n                        continue\\n                    heapq.heappush(heap, [heuristic(new_box) + moves + 1, moves + 1, new_person, new_box])\\n                else:\\n                    heapq.heappush(heap, [heuristic(box) + moves, moves, new_person, box]) # box remains same\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \"T\":\\n                    target = (r, c)\\n                if grid[r][c] == \"B\":\\n                    start_box = (r, c)\\n                if grid[r][c] == \"S\":\\n                    start_person = (r, c)\\n                    \\n        def heuristic(box):\\n            return abs(target[0] - box[0]) + abs(target[1] - box[1])\\n        \\n        def out_bounds(location):  # return whether the location is in the grid and not a wall\\n            r, c = location\\n            if r < 0 or r >= rows:\\n                return True\\n            if c < 0 or c >= cols:\\n                return True\\n            return grid[r][c] == \"#\"\\n                        \\n        heap = [[heuristic(start_box), 0, start_person, start_box]]\\n        visited = set()\\n        \\n        while heap:\\n            _, moves, person, box = heapq.heappop(heap)\\n            if box == target:\\n                return moves\\n            if (person, box) in visited: # do not visit same state again\\n                continue\\n            visited.add((person, box))\\n            \\n            for dr, dc in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                new_person = (person[0] + dr, person[1] + dc)\\n                if out_bounds(new_person):\\n                    continue\\n                    \\n                if new_person == box:\\n                    new_box = (box[0] + dr, box[1] + dc)\\n                    if out_bounds(new_box):\\n                        continue\\n                    heapq.heappush(heap, [heuristic(new_box) + moves + 1, moves + 1, new_person, new_box])\\n                else:\\n                    heapq.heappush(heap, [heuristic(box) + moves, moves, new_person, box]) # box remains same\\n        \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431431,
                "title": "java-straightforward-bfs-solution",
                "content": "For me, this is a typical bfs question to find the minimum step, so the key point is to find out the state. For this problem, I choose the coordinates of box and storekeeper as the state. Because the grid length is from 1 to 20, we can use one 32 bit integer to present all the coordinates.\\nEvery step, move storekeeper 1 step, if it meet the box, then the box move 1 step in the same direction. Because it want to know the minimum step the box move, so when the first time box on the target pocision, it may not be the minimum anwser. So we compare every one and find the minimum step.\\n\\n```java\\nclass Solution {\\n    int[][] moves = new int[][]{{0,-1}, {0,1}, {-1,0}, {1,0}};\\n    public int minPushBox(char[][] grid) {\\n        int[] box = null, target = null, storekeeper = null;\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == \\'B\\') box = new int[]{i, j};\\n            else if (grid[i][j] == \\'T\\') target = new int[]{i, j};\\n            else if (grid[i][j] == \\'S\\') storekeeper = new int[]{i, j};\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Map<Integer, Integer> dis = new HashMap<>();\\n        int start = encode(box[0], box[1], storekeeper[0], storekeeper[1]);\\n        dis.put(start, 0);\\n        q.offer(start);\\n        int ret = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            int[] du = decode(u);\\n            if (dis.get(u) >= ret) continue;\\n            if (du[0] == target[0] && du[1] == target[1]) {\\n                ret = Math.min(ret, dis.get(u));\\n                continue;\\n            }\\n            int[] b = new int[]{du[0], du[1]};\\n            int[] s = new int[]{du[2], du[3]};\\n\\t\\t\\t// move the storekeeper for 1 step\\n            for (int[] move : moves) {\\n                int nsx = s[0] + move[0];\\n                int nsy = s[1] + move[1];\\n                if (nsx < 0 || nsx >= n || nsy < 0 || nsy >= m || grid[nsx][nsy] == \\'#\\') continue;\\n\\t\\t\\t\\t// if it meet the box, then the box move in the same direction\\n                if (nsx == b[0] && nsy == b[1]) {\\n                    int nbx = b[0] + move[0];\\n                    int nby = b[1] + move[1];\\n                    if (nbx < 0 || nbx >= n || nby < 0 || nby >= m || grid[nbx][nby] == \\'#\\') continue;\\n                    int v = encode(nbx, nby, nsx, nsy);\\n                    if (dis.containsKey(v) && dis.get(v) <= dis.get(u) + 1) continue;\\n                    dis.put(v, dis.get(u) + 1);\\n                    q.offer(v);\\n                } else { // if the storekeeper doesn\\'t meet the box, the position of the box do not change\\n                    int v = encode(b[0], b[1], nsx, nsy);\\n                    if (dis.containsKey(v) && dis.get(v) <= dis.get(u)) continue;\\n                    dis.put(v, dis.get(u));\\n                    q.offer(v);\\n                }\\n            }\\n        }\\n        return ret == Integer.MAX_VALUE ? -1 : ret;\\n    }\\n    int encode(int bx, int by, int sx, int sy) {\\n        return (bx << 24) | (by << 16) | (sx << 8) | sy;\\n    }\\n    int[] decode(int num) {\\n        int[] ret = new int[4];\\n        ret[0] = (num >>> 24) & 0xff;\\n        ret[1] = (num >>> 16) & 0xff;\\n        ret[2] = (num >>> 8) & 0xff;\\n        ret[3] = num & 0xff;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int[][] moves = new int[][]{{0,-1}, {0,1}, {-1,0}, {1,0}};\\n    public int minPushBox(char[][] grid) {\\n        int[] box = null, target = null, storekeeper = null;\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == \\'B\\') box = new int[]{i, j};\\n            else if (grid[i][j] == \\'T\\') target = new int[]{i, j};\\n            else if (grid[i][j] == \\'S\\') storekeeper = new int[]{i, j};\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Map<Integer, Integer> dis = new HashMap<>();\\n        int start = encode(box[0], box[1], storekeeper[0], storekeeper[1]);\\n        dis.put(start, 0);\\n        q.offer(start);\\n        int ret = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            int[] du = decode(u);\\n            if (dis.get(u) >= ret) continue;\\n            if (du[0] == target[0] && du[1] == target[1]) {\\n                ret = Math.min(ret, dis.get(u));\\n                continue;\\n            }\\n            int[] b = new int[]{du[0], du[1]};\\n            int[] s = new int[]{du[2], du[3]};\\n\\t\\t\\t// move the storekeeper for 1 step\\n            for (int[] move : moves) {\\n                int nsx = s[0] + move[0];\\n                int nsy = s[1] + move[1];\\n                if (nsx < 0 || nsx >= n || nsy < 0 || nsy >= m || grid[nsx][nsy] == \\'#\\') continue;\\n\\t\\t\\t\\t// if it meet the box, then the box move in the same direction\\n                if (nsx == b[0] && nsy == b[1]) {\\n                    int nbx = b[0] + move[0];\\n                    int nby = b[1] + move[1];\\n                    if (nbx < 0 || nbx >= n || nby < 0 || nby >= m || grid[nbx][nby] == \\'#\\') continue;\\n                    int v = encode(nbx, nby, nsx, nsy);\\n                    if (dis.containsKey(v) && dis.get(v) <= dis.get(u) + 1) continue;\\n                    dis.put(v, dis.get(u) + 1);\\n                    q.offer(v);\\n                } else { // if the storekeeper doesn\\'t meet the box, the position of the box do not change\\n                    int v = encode(b[0], b[1], nsx, nsy);\\n                    if (dis.containsKey(v) && dis.get(v) <= dis.get(u)) continue;\\n                    dis.put(v, dis.get(u));\\n                    q.offer(v);\\n                }\\n            }\\n        }\\n        return ret == Integer.MAX_VALUE ? -1 : ret;\\n    }\\n    int encode(int bx, int by, int sx, int sy) {\\n        return (bx << 24) | (by << 16) | (sx << 8) | sy;\\n    }\\n    int[] decode(int num) {\\n        int[] ret = new int[4];\\n        ret[0] = (num >>> 24) & 0xff;\\n        ret[1] = (num >>> 16) & 0xff;\\n        ret[2] = (num >>> 8) & 0xff;\\n        ret[3] = num & 0xff;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709355,
                "title": "java-use-2-level-bfs-beat-99",
                "content": "It will be easy coming up with BFS. But some key point:\\n1, you need to make sure Storekeeper:\\na has room to push the box;\\nb has a way to go to the room to push the box. \\nTherefore you need another bfs to find if the path exist;\\n\\n2 Make sure to set box as a blocker during bfs;\\n\\n3, Visited boolean array is tricky:\\n2-d is not enough, some corner case:\\nSenario 1, some push room is reachable if Storekeeper stands right, where another Senario 2, push room not reachable if Storekeeper stands right, though the postion of box are the same;\\ntherefore, you need a 3-d array to mark box\\' postion and another num to represents Storekeeper\\'s postion compared to box(left, right, up, down);\\n\\n```\\nclass Solution {\\n    char[][] g;\\n    int m, n;\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minPushBox(char[][] grid) {\\n        g = grid;\\n        m = g.length; \\n        n = g[0].length;\\n        int step = 0;\\n        boolean[][][] vs = new boolean[m][n][4];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        int[] st = new int[]{-1, -1}, ed = new int[]{-1, -1}, pl = new int[]{-1, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == \\'B\\') st = new int[]{i, j};\\n                if (g[i][j] == \\'T\\') ed = new int[]{i, j};\\n                if (g[i][j] == \\'S\\') pl = new int[]{i, j};\\n            }\\n        }\\n        q.offer(new int[]{st[0], st[1], pl[0], pl[1]});\\n        while (!q.isEmpty()) {\\n            for (int i = 0, l = q.size(); i < l; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == ed[0] && curr[1] == ed[1]) return step;\\n                for (int j = 0; j < dir.length; j++) {\\n                    if (vs[curr[0]][curr[1]][j]) continue;\\n                    int[] d = dir[j];\\n                    int r0 = curr[0] + d[0], c0 = curr[1] + d[1];  // where pl stands, have room to push;\\n                    if (r0 < 0 || r0 >= m || c0 < 0 || c0 >= n || g[r0][c0] == \\'#\\') continue;\\n                    int r = curr[0] - d[0], c = curr[1] - d[1];  // box next spots;\\n                    if (r < 0 || r >= m || c < 0 || c >= n || g[r][c] == \\'#\\') continue;\\n                    if (!reachable(r0, c0, curr)) continue;\\n                    vs[curr[0]][curr[1]][j] = true;\\n                    q.offer(new int[]{r, c, curr[0], curr[1]});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean reachable(int i, int j, int[] curr) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{curr[2], curr[3]});\\n        boolean[][] vs = new boolean[m][n];\\n        vs[curr[0]][curr[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (cur[0] == i && cur[1] == j) return true;\\n            for (int[] d : dir) {\\n                int r = cur[0] - d[0], c = cur[1] - d[1];  // box next spots;\\n                if (r < 0 || r >= m || c < 0 || c >= n || vs[r][c] || g[r][c] == \\'#\\') continue;\\n                vs[r][c] = true;\\n                q.offer(new int[]{r, c});\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] g;\\n    int m, n;\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minPushBox(char[][] grid) {\\n        g = grid;\\n        m = g.length; \\n        n = g[0].length;\\n        int step = 0;\\n        boolean[][][] vs = new boolean[m][n][4];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        int[] st = new int[]{-1, -1}, ed = new int[]{-1, -1}, pl = new int[]{-1, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == \\'B\\') st = new int[]{i, j};\\n                if (g[i][j] == \\'T\\') ed = new int[]{i, j};\\n                if (g[i][j] == \\'S\\') pl = new int[]{i, j};\\n            }\\n        }\\n        q.offer(new int[]{st[0], st[1], pl[0], pl[1]});\\n        while (!q.isEmpty()) {\\n            for (int i = 0, l = q.size(); i < l; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == ed[0] && curr[1] == ed[1]) return step;\\n                for (int j = 0; j < dir.length; j++) {\\n                    if (vs[curr[0]][curr[1]][j]) continue;\\n                    int[] d = dir[j];\\n                    int r0 = curr[0] + d[0], c0 = curr[1] + d[1];  // where pl stands, have room to push;\\n                    if (r0 < 0 || r0 >= m || c0 < 0 || c0 >= n || g[r0][c0] == \\'#\\') continue;\\n                    int r = curr[0] - d[0], c = curr[1] - d[1];  // box next spots;\\n                    if (r < 0 || r >= m || c < 0 || c >= n || g[r][c] == \\'#\\') continue;\\n                    if (!reachable(r0, c0, curr)) continue;\\n                    vs[curr[0]][curr[1]][j] = true;\\n                    q.offer(new int[]{r, c, curr[0], curr[1]});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean reachable(int i, int j, int[] curr) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{curr[2], curr[3]});\\n        boolean[][] vs = new boolean[m][n];\\n        vs[curr[0]][curr[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (cur[0] == i && cur[1] == j) return true;\\n            for (int[] d : dir) {\\n                int r = cur[0] - d[0], c = cur[1] - d[1];  // box next spots;\\n                if (r < 0 || r >= m || c < 0 || c >= n || vs[r][c] || g[r][c] == \\'#\\') continue;\\n                vs[r][c] = true;\\n                q.offer(new int[]{r, c});\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432593,
                "title": "cpp-two-bfs-solution-8ms-beat-100",
                "content": "typical bfs problem for shortest distance.\\nThe person shall be able to move to the location behind the box to make a move.\\nwe can use dfs/bfs to check if person can move to desired location.\\nhowever dfs will get TLE since dfs is one direction forward until failure, hence dfs will use more time in average.\\n\\ncheck if person can move a position is a conventional bfs.\\ncheck box can be moved to a position is a bit tricky, it needs both the person and box position, so we use a pair of position in the queue\\nand the visited shall also use combined information, I used the string combination of the two positions.\\n\\n```cpp\\n    int minPushBox(vector<vector<char>>& grid) {\\n        //bfs with person and box, the person can move in the free cells\\n        //person must be able to walk to the box.\\n        int m=grid.size(),n=grid[0].size();\\n        queue<pair<int,int>> q; //store the next valid box position: it shall store: player,box,\\n        unordered_set<string> v;\\n        int src=0,dst=0,player=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'S\\') {player=i*n+j;grid[i][j]=\\'.\\';}\\n                if(grid[i][j]==\\'B\\') {src=i*n+j;grid[i][j]=\\'.\\';}\\n                if(grid[i][j]==\\'T\\') {dst=i*n+j;grid[i][j]=\\'.\\';}\\n            }\\n        }\\n        if(src==dst) return 0;\\n        q.push({src,player});\\n        int step=0;\\n        int dir[][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto pos=q.front();\\n                q.pop();\\n                int box=pos.first,player=pos.second;\\n                if(box==dst) return step;\\n                int xb=box/n,yb=box%n;\\n                for(auto d: dir){\\n                    int x=xb+d[0],y=yb+d[1]; //new box position\\n                    int xp=xb-d[0],yp=yb-d[1];\\n                    if(x<0||y<0||x>=m||y>=n||grid[x][y]==\\'#\\') continue;\\n                    if(xp<0||yp<0||xp>=m||yp>=n||grid[xp][yp]==\\'#\\') continue;\\n                    string s=to_string(box)+\",\"+to_string(xp*n+yp);//box pos+person pos\\n                    if(v.count(s)) continue;\\n                    if(can_access(grid,player,xp*n+yp,box)){\\n                        q.push({x*n+y,box});//make a push, box move to new, p moves to box\\n                        v.insert(s);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    bool can_access(vector<vector<char>>& g,int src,int dst,int box){\\n        int m=g.size(),n=g[0].size();\\n        //bfs shall be better than dfs\\n        queue<int> q;\\n        vector<bool> v(m*n);\\n        q.push(src);\\n        v[src]=1;\\n        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n        g[box/n][box%n]=\\'#\\';\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int p=q.front();\\n                q.pop();\\n                if(p==dst) {g[box/n][box%n]=\\'.\\';return 1;}\\n                int x0=p/n,y0=p%n;\\n                for(auto d: dir){\\n                    int x=x0+d[0],y=y0+d[1];\\n                    if(x<0||y<0||x>=m||y>=n||g[x][y]!=\\'.\\'||v[x*n+y]) continue;\\n                    v[x*n+y]=1;\\n                    q.push(x*n+y);\\n                }\\n            }\\n        }\\n        g[box/n][box%n]=\\'.\\';\\n        return 0;\\n    }\\n```\\n\\t\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int minPushBox(vector<vector<char>>& grid) {\\n        //bfs with person and box, the person can move in the free cells\\n        //person must be able to walk to the box.\\n        int m=grid.size(),n=grid[0].size();\\n        queue<pair<int,int>> q; //store the next valid box position: it shall store: player,box,\\n        unordered_set<string> v;\\n        int src=0,dst=0,player=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'S\\') {player=i*n+j;grid[i][j]=\\'.\\';}\\n                if(grid[i][j]==\\'B\\') {src=i*n+j;grid[i][j]=\\'.\\';}\\n                if(grid[i][j]==\\'T\\') {dst=i*n+j;grid[i][j]=\\'.\\';}\\n            }\\n        }\\n        if(src==dst) return 0;\\n        q.push({src,player});\\n        int step=0;\\n        int dir[][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto pos=q.front();\\n                q.pop();\\n                int box=pos.first,player=pos.second;\\n                if(box==dst) return step;\\n                int xb=box/n,yb=box%n;\\n                for(auto d: dir){\\n                    int x=xb+d[0],y=yb+d[1]; //new box position\\n                    int xp=xb-d[0],yp=yb-d[1];\\n                    if(x<0||y<0||x>=m||y>=n||grid[x][y]==\\'#\\') continue;\\n                    if(xp<0||yp<0||xp>=m||yp>=n||grid[xp][yp]==\\'#\\') continue;\\n                    string s=to_string(box)+\",\"+to_string(xp*n+yp);//box pos+person pos\\n                    if(v.count(s)) continue;\\n                    if(can_access(grid,player,xp*n+yp,box)){\\n                        q.push({x*n+y,box});//make a push, box move to new, p moves to box\\n                        v.insert(s);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    bool can_access(vector<vector<char>>& g,int src,int dst,int box){\\n        int m=g.size(),n=g[0].size();\\n        //bfs shall be better than dfs\\n        queue<int> q;\\n        vector<bool> v(m*n);\\n        q.push(src);\\n        v[src]=1;\\n        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n        g[box/n][box%n]=\\'#\\';\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int p=q.front();\\n                q.pop();\\n                if(p==dst) {g[box/n][box%n]=\\'.\\';return 1;}\\n                int x0=p/n,y0=p%n;\\n                for(auto d: dir){\\n                    int x=x0+d[0],y=y0+d[1];\\n                    if(x<0||y<0||x>=m||y>=n||g[x][y]!=\\'.\\'||v[x*n+y]) continue;\\n                    v[x*n+y]=1;\\n                    q.push(x*n+y);\\n                }\\n            }\\n        }\\n        g[box/n][box%n]=\\'.\\';\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431528,
                "title": "python-dijkstra-short",
                "content": "edit: added an explanation below\\nedit2: fixed a bug found by StefanPochmann@\\n\\n```\\ndef minPushBox(self, grid: List[List[str]]) -> int:\\n    free = set((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell != \\'#\\')\\n    target = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'T\\')\\n    boxi, boxj = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'B\\')\\n    si, sj = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'S\\')\\n    visited = set()\\n    heap = [(0, si, sj, boxi, boxj)]\\n    while heap:\\n        moves, si, sj, boxi, boxj = heapq.heappop(heap)\\n        if (boxi, boxj) == target:\\n            return moves\\n        if (si, sj, boxi, boxj) in visited:\\n            continue\\n        visited.add((si, sj, boxi, boxj))\\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n            ni, nj = si + dx, dy + sj\\n            if (ni, nj) == (boxi, boxj) and (boxi + dx, boxj + dy) in free and (ni, nj, boxi + dx, boxj + dy) not in visited:\\n                heapq.heappush(heap, (moves + 1, ni, nj, boxi + dx, boxj + dy))\\n            elif (ni, nj) in free and (ni, nj) != (boxi, boxj) and (ni, nj, boxi, boxj) not in visited:\\n                heapq.heappush(heap, (moves, ni, nj, boxi, boxj))\\n    return -1\\n```\\n\\nIn this solution, a Node is represented by the position of the box, and the position of the person i.e. ```(si, sj, boxi, boxj)```.\\n\\nTo find a Node\\'s neighbors we add ```UP/DOWN/LEFT/RIGHT``` to the person\\'s position and if the persons position ```==``` the boxes position, we also add this direction to the boxes position. The weight of the edge is ```1``` if the box moved,```0``` if not.\\n\\nWe could explicitly define ```Node, Edge, and Graph``` in the code, and even construct the whole graph prior to running Dijkstra, but it\\'s easier and quicker to determine edge weights / neighbors by doing calculations on the ```(si, sj, boxi, boxj)``` tuple.\\n\\nNow we have our representations in place, just run Dijkstra in the normal way. I don\\'t want to explain Dijkstra here, there are already really good explanations elsewhere.",
                "solutionTags": [],
                "code": "```\\ndef minPushBox(self, grid: List[List[str]]) -> int:\\n    free = set((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell != \\'#\\')\\n    target = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'T\\')\\n    boxi, boxj = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'B\\')\\n    si, sj = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == \\'S\\')\\n    visited = set()\\n    heap = [(0, si, sj, boxi, boxj)]\\n    while heap:\\n        moves, si, sj, boxi, boxj = heapq.heappop(heap)\\n        if (boxi, boxj) == target:\\n            return moves\\n        if (si, sj, boxi, boxj) in visited:\\n            continue\\n        visited.add((si, sj, boxi, boxj))\\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n            ni, nj = si + dx, dy + sj\\n            if (ni, nj) == (boxi, boxj) and (boxi + dx, boxj + dy) in free and (ni, nj, boxi + dx, boxj + dy) not in visited:\\n                heapq.heappush(heap, (moves + 1, ni, nj, boxi + dx, boxj + dy))\\n            elif (ni, nj) in free and (ni, nj) != (boxi, boxj) and (ni, nj, boxi, boxj) not in visited:\\n                heapq.heappush(heap, (moves, ni, nj, boxi, boxj))\\n    return -1\\n```\n```(si, sj, boxi, boxj)```\n```UP/DOWN/LEFT/RIGHT```\n```==```\n```1```\n```0```\n```Node, Edge, and Graph```\n```(si, sj, boxi, boxj)```",
                "codeTag": "Python3"
            },
            {
                "id": 1265127,
                "title": "c-accepted-clear-solution-to-understand-for-this-long-problem-with-proper-variable-names",
                "content": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n\\t\\n    bool inside(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n\\n    bool canWalk(int srcX, int srcY, int destX, int destY, vector<vector<char>>&grid, vector<vector<int>>&visited)\\n    {\\n        if(srcX == destX && srcY == destY) return true;\\n        visited[srcX][srcY] = 1;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int x = srcX + dx[i];\\n            int y = srcY + dy[i];\\n            if(inside(x, y) && grid[x][y] != \\'#\\' && !visited[x][y])\\n            {\\n                if(canWalk(x, y, destX, destY, grid, visited))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n         n = grid.size();\\n         m = grid[0].size();\\n         int boxX, boxY, targetX, targetY, personX, personY; \\n         for(int i = 0; i < n; i++)\\n         {\\n             for(int j = 0; j < m; j++)\\n             {\\n                 if(grid[i][j] == \\'S\\')\\n                 {\\n                     personX = i;\\n                     personY = j;\\n                 }\\n                 else if(grid[i][j] == \\'T\\')\\n                 {\\n                     targetX = i;\\n                     targetY = j;\\n                 }\\n                 else if(grid[i][j] == \\'B\\')\\n                 {\\n                     boxX = i;\\n                     boxY = j;\\n                 }\\n             }\\n         }\\n\\t\\t \\n         queue<vector<int>>q;\\n         set<vector<int>> seen;\\n         q.push({boxX, boxY,personX, personY});\\n         int ans = 0;\\n\\t\\t \\n         while(!q.empty())\\n         {\\n             int sz = q.size();\\n             while(sz--)\\n             {\\n                auto p = q.front();\\n                q.pop();\\n                boxX = p[0]; boxY = p[1];\\n                personX = p[2]; personY = p[3];\\n\\t\\t\\t\\t\\n                if(boxX == targetX && boxY == targetY)\\n                    return ans;\\n\\t\\t\\t\\t\\t\\n                grid[boxX][boxY] = \\'#\\';\\n\\t\\t\\t\\t\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int new_boxX = boxX + dx[i];\\n                    int new_boxY = boxY + dy[i];\\n                    int new_personX = boxX - dx[i];\\n                    int new_personY = boxY - dy[i];\\n                    vector<int>curPos({new_boxX,new_boxY,new_personX,new_personY});\\n                    vector<vector<int>> visited(n, vector<int>(m, 0));\\n                    if(inside(new_boxX, new_boxY) && grid[new_boxX][new_boxY]!=\\'#\\'  && !seen.count(curPos) && canWalk(personX, personY, new_personX, new_personY, grid, visited))\\n                    {\\n                        seen.insert(curPos);\\n                        q.push(curPos);\\n                    }\\n                }\\n                grid[boxX][boxY] = \\'.\\';\\n              }\\n             ans++;\\n          }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n\\t\\n    bool inside(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n\\n    bool canWalk(int srcX, int srcY, int destX, int destY, vector<vector<char>>&grid, vector<vector<int>>&visited)\\n    {\\n        if(srcX == destX && srcY == destY) return true;\\n        visited[srcX][srcY] = 1;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int x = srcX + dx[i];\\n            int y = srcY + dy[i];\\n            if(inside(x, y) && grid[x][y] != \\'#\\' && !visited[x][y])\\n            {\\n                if(canWalk(x, y, destX, destY, grid, visited))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n         n = grid.size();\\n         m = grid[0].size();\\n         int boxX, boxY, targetX, targetY, personX, personY; \\n         for(int i = 0; i < n; i++)\\n         {\\n             for(int j = 0; j < m; j++)\\n             {\\n                 if(grid[i][j] == \\'S\\')\\n                 {\\n                     personX = i;\\n                     personY = j;\\n                 }\\n                 else if(grid[i][j] == \\'T\\')\\n                 {\\n                     targetX = i;\\n                     targetY = j;\\n                 }\\n                 else if(grid[i][j] == \\'B\\')\\n                 {\\n                     boxX = i;\\n                     boxY = j;\\n                 }\\n             }\\n         }\\n\\t\\t \\n         queue<vector<int>>q;\\n         set<vector<int>> seen;\\n         q.push({boxX, boxY,personX, personY});\\n         int ans = 0;\\n\\t\\t \\n         while(!q.empty())\\n         {\\n             int sz = q.size();\\n             while(sz--)\\n             {\\n                auto p = q.front();\\n                q.pop();\\n                boxX = p[0]; boxY = p[1];\\n                personX = p[2]; personY = p[3];\\n\\t\\t\\t\\t\\n                if(boxX == targetX && boxY == targetY)\\n                    return ans;\\n\\t\\t\\t\\t\\t\\n                grid[boxX][boxY] = \\'#\\';\\n\\t\\t\\t\\t\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int new_boxX = boxX + dx[i];\\n                    int new_boxY = boxY + dy[i];\\n                    int new_personX = boxX - dx[i];\\n                    int new_personY = boxY - dy[i];\\n                    vector<int>curPos({new_boxX,new_boxY,new_personX,new_personY});\\n                    vector<vector<int>> visited(n, vector<int>(m, 0));\\n                    if(inside(new_boxX, new_boxY) && grid[new_boxX][new_boxY]!=\\'#\\'  && !seen.count(curPos) && canWalk(personX, personY, new_personX, new_personY, grid, visited))\\n                    {\\n                        seen.insert(curPos);\\n                        q.push(curPos);\\n                    }\\n                }\\n                grid[boxX][boxY] = \\'.\\';\\n              }\\n             ans++;\\n          }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431071,
                "title": "python-straightforward-2-stage-bfs-explained",
                "content": "First define a function to check from current state, what are the possible neighbouring states (use BFS to check if we can move the player to required location). Notice that the state includes both the location of the box and the player.\\nSecond BFS to see if we can reach the target location.\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        dire = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\t\\t\\n        def can_get(cur_b,cur_p,tar):\\n            seen,cur = set([cur_p]),set([cur_p])\\n            while cur:\\n                tmp = []\\n                for loc in cur:\\n                    for x,y in dire:\\n                        if 0<= loc[0]+x < len(grid) and 0 <= loc[1] + y < len(grid[0]) and (loc[0]+x,loc[1] +y) != cur_b and grid[loc[0] +x][loc[1] +y] != \\'#\\' and (loc[0]+x,loc[1] +y) not in seen:\\n                            tmp += [(loc[0]+x,loc[1] +y)]\\n                cur = set(tmp)\\n                seen |= cur\\n                if tar in seen:\\n                    return True\\n            return False\\n\\t\\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'B\\': box = (i,j)\\n                if grid[i][j] == \\'S\\': player = (i,j)\\n                if grid[i][j] == \\'T\\': target = (i,j)\\n\\t\\t\\t\\t\\n        seen,cur,res = set([(box,player)]), set([(box,player)]), 0\\n        while cur:\\n            tmp = []\\n            res += 1\\n            for b,p in cur:\\n                for x,y in dire:\\n                    if 0<= b[0]+x < len(grid) and 0 <= b[1] + y < len(grid[0]) and grid[b[0]+x][b[1]+y] != \\'#\\' and can_get(b,p,(b[0]-x,b[1]-y)) and ((b[0]+x,b[1]+y),b) not in seen:\\n                        tmp += [((b[0]+x,b[1]+y),b)]\\n            cur = set(tmp)\\n            seen |= cur\\n            for x,y in dire:\\n                if (target,(target[0]+x,target[1]+y)) in seen:\\n                    return res\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        dire = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\t\\t\\n        def can_get(cur_b,cur_p,tar):\\n            seen,cur = set([cur_p]),set([cur_p])\\n            while cur:\\n                tmp = []\\n                for loc in cur:\\n                    for x,y in dire:\\n                        if 0<= loc[0]+x < len(grid) and 0 <= loc[1] + y < len(grid[0]) and (loc[0]+x,loc[1] +y) != cur_b and grid[loc[0] +x][loc[1] +y] != \\'#\\' and (loc[0]+x,loc[1] +y) not in seen:\\n                            tmp += [(loc[0]+x,loc[1] +y)]\\n                cur = set(tmp)\\n                seen |= cur\\n                if tar in seen:\\n                    return True\\n            return False\\n\\t\\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'B\\': box = (i,j)\\n                if grid[i][j] == \\'S\\': player = (i,j)\\n                if grid[i][j] == \\'T\\': target = (i,j)\\n\\t\\t\\t\\t\\n        seen,cur,res = set([(box,player)]), set([(box,player)]), 0\\n        while cur:\\n            tmp = []\\n            res += 1\\n            for b,p in cur:\\n                for x,y in dire:\\n                    if 0<= b[0]+x < len(grid) and 0 <= b[1] + y < len(grid[0]) and grid[b[0]+x][b[1]+y] != \\'#\\' and can_get(b,p,(b[0]-x,b[1]-y)) and ((b[0]+x,b[1]+y),b) not in seen:\\n                        tmp += [((b[0]+x,b[1]+y),b)]\\n            cur = set(tmp)\\n            seen |= cur\\n            for x,y in dire:\\n                if (target,(target[0]+x,target[1]+y)) in seen:\\n                    return res\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471512,
                "title": "fast-easy-to-understand-solution-using-2-bfss-intuition-diagram-explanation",
                "content": "Little improvisation of the solution provided by [sguo-lq](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/432593/cpp-two-bfs-solution-8ms-beat-100), and also explaining every step and the intuition for the approach.\\n\\n**Don\\'t panic by seeing the length of the solution it is actually the implementation of 2 BFSs that makes it long.**\\nP.S - You know the no. of lines required for implementing a single BFS \\uD83D\\uDE1C.\\n\\nOur goal is that the box reaches the target and for that we need a BFS to get the shortest distance between the source and destination of it.\\nNow the twist is we need to use the storekeeper to push it to the destination and thus here our goal is to bring him to the position adjacent to the box from where he can push the box towards the direction that would led the box\\'s travelling in the shortest path given by the box\\'s BFS.\\n\\nTo achieve the above objective we need to maintain a BFS of the box and also for each step taken by the box we need to align the storekeeper to the required adjacent cell so that the box can be pushed in the required direction provided by the box\\'s BFS. \\nFrom above we can infer that the storekeeper needs to be just behind the box w.r.t the direction in which it is to be pushed.\\n\\nLet\\'s Understand pictorially:\\nInitial condition (the empty cells are marked by there coresponding cell numbers): \\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tB\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\tS\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nFrom above the shortest route for the box would be B -> 29 -> 28 -> 27 -> 19 -> T,\\nbut the storekeeper needs to push the block to T, for the above path when the box is at 27 the person cannot be anywhere but in the right part of the maze with the only opening being at 28. So for pushing the box the storekeeper must be at 35 which isn\\'t possible, thus to accomodate this the shortest route for the box is modified\\nB -> 29 -> 28 -> 27 -> 26 -> 18 -> 10 -> T\\nTo achieve this intuitive behaviour just need to make the storekeeper to reach the correct oriented position to push the box in its shortest path.\\n\\nFor 1st iteration B available options are 29, 22, 13 (according to box\\'s BFS, here 20 is not suitable next stop for the box as it is a wall), thus we need to check if S ```canAccess()``` 13, 20, 29 respectively, for this a second BFS is done(can use DFS too but that would check each route individually thus increasing the search time) for the storekeeper with ```src=S(i.e. 38)``` and ```dest=13```, ```dest=20```, ```dest=29```, from the 3 dests 20 isn\\'t accessable as it is a wall, thus only 2 options are left 13 or 29 this ```canAccesss```.\\n\\nHope you got the idea how the 2 BFS traversals are done for box and storekeeper, the basic idea is very simple get the possible next stops for the box from the box\\'s BFS and for each of this stops check whether the accordingly oriented cells where the storekeeper must be present to push it forward is accessible by the storekeeper from his current location using the storekeeper\\'s BFS.\\nTo simplify further explanation we follow the answer path of the box.\\n\\n13 is to be the dest of the storekeeper,\\nThus now the scenario is :\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\tS\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tB\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow push box to new location and storekeeper occupies the boxes old position\\nPushes = 1\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tS\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\tB\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow check S ```canAccess``` 30 as box is to be pushed to 28\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\tB\\tS\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow push box to new location and storekeeper occupies the boxes old position\\nPushes = 2\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\t27\\tB\\tS\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow check S ```canAccess``` 29 as box is to be pushed to 27, push box to new location\\nPushes = 3\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\tB\\tS\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow for B possible next choices are 35, 19, 26. For these the storekeeper should be at 19, 35, 28 respectively. Using the ```canAccess``` the only option is to shift box to 26 as storekeeper can only access 28\\nPushes = 4\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\tB\\tS\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nNow box has choice 34, 27, 18, 25 correspondingly  the respective locations for the storekeeper to be present are 18, 25, 34, 27, we take the shortest path for the box (notice here choosing either 27 or 18 as next stop for box would lead to shortest answer we continue with 18)\\nPushes = 5\\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\tB\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\tS\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\\nSkipping the last 2 steps as these are visible from the above state.\\nThus Pushes = 7 (answer)\\n\\nHope the dry run helped understand the complete logic.\\n\\nSee through the inline comments to understand the reason for line\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    bool isValid(vector<vector<char>>&grid, int x, int y){\\n        int m = grid.size(), n = grid[0].size();\\n        return (x>=0 and y>=0 and x<m and y<n and grid[x][y]!=\\'#\\');\\n    }\\n    \\n    bool canAccess(vector<vector<char>>&grid, int dest, int src, int box){\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<bool> visited(m*n,false);\\n        visited[src] = true;\\n        \\n        // mark the location of box as blocked as stkp can\\'t travel there\\n        grid[box/n][box%n] = \\'#\\';\\n        \\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int cp = q.front();\\n            q.pop();\\n            if(dest==cp){grid[box/n][box%n] = \\'.\\';return true;}\\n            for(auto e:dir){\\n                int nx = cp/n+e[0], ny = cp%n+e[1];\\n                int np = nx*n+ny;\\n                if(np>=0 and np<m*n){\\n                    if(visited[np]) continue;\\n                    visited[np] = true;\\n                    if(!isValid(grid,nx,ny)) continue;\\n                    q.push(np);\\n                }\\n            }\\n        }\\n        grid[box/n][box%n] = \\'.\\';\\n        return false;\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        // get position of storekeeper, box and target\\n        // and mark those points as open path, i.e. \\'.\\'\\n        int stkp, box, tar;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'S\\') {stkp = i*n+j;grid[i][j]=\\'.\\';}\\n                else if(grid[i][j]==\\'B\\') {box = i*n+j;grid[i][j]=\\'.\\';}\\n                else if(grid[i][j]==\\'T\\') {tar = i*n+j;;grid[i][j]=\\'.\\';}\\n            }\\n        }\\n        if(box==tar) return 0;\\n        \\n        // BFSing for box to target\\n        \\n        // queue stores the stkp and the box locations\\n        // as both needs to be kept track of while traversing\\n        // for each location of the box\\n        queue<pair<int,int>> q;\\n        q.push({box,stkp});\\n        \\n        // keeping track of visited nodes for the stkp and \\n        // the box simultaneously using a string\\n        unordered_set<string> visited;\\n        visited.insert(to_string(stkp)+\" \"+to_string(box));\\n        \\n        int pushes = 0;\\n        while(!q.empty()){\\n            int len = q.size();\\n            while(len--){\\n                auto [bo,stkpo] = q.front();\\n                q.pop();\\n                if(bo==tar) return pushes;\\n                for(auto e:dir){\\n                    int nbx = bo/n+e[0], nby = bo%n+e[1];\\n                    int nstkpx = bo/n-e[0], nstkpy = bo%n-e[1];\\n                    int nstkp = nstkpx*n+nstkpy, nb = nbx*n+nby;\\n                    if(nstkp>=0 and nb>=0 and nstkp<m*n and nb<m*n){\\n                        string key = to_string(nstkp)+\" \"+to_string(nb);\\n                        if(visited.find(key)!=visited.end()) continue;\\n                        if(!isValid(grid,nbx,nby) or !isValid(grid,nstkpx,nstkpy)) continue;\\n                    \\n                        // if stkp can get to the position from where he can push the box\\n                        // push new position of box and new position of stkp (old position of box)\\n                        // into the queue\\n                        if(canAccess(grid,nstkp,stkpo,bo)){\\n                            visited.insert(key);\\n                            q.push({nb,bo});\\n                        }\\n                    }\\n                }\\n            }\\n            // if reached this point means 1 push has been performed\\n            // and the box is 1 step closer to the target\\n            pushes++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nUpvote please if understood my explantion, devoted quite a bit of effort to put up this explanation, as I found it necessary as there\\'s no proper explanation along with the intution behind the logic anywhere.\\nThanks\\nCheers\\nHappy Coding",
                "solutionTags": [],
                "code": "```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tB\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\tS\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```canAccess()```\n```src=S(i.e. 38)```\n```dest=13```\n```dest=20```\n```dest=29```\n```canAccesss```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\tS\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tB\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\tS\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\tB\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```canAccess```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\t27\\t28\\tB\\tS\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\t27\\tB\\tS\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```canAccess```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\t26\\tB\\tS\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```canAccess```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\t18\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\tB\\tS\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```\\n#\\t1\\t2\\t#\\t#\\t#\\t#\\t#\\t\\n#\\t9\\t10\\tT\\t#\\t13\\t14\\t#\\t\\n#\\t17\\tB\\t19\\t#\\t21\\t22\\t#\\t\\n#\\t25\\tS\\t27\\t28\\t29\\t30\\t#\\t\\n#\\t33\\t34\\t35\\t#\\t37\\t38\\t#\\t\\n#\\t41\\t42\\t#\\t#\\t#\\t#\\t#\\t\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    bool isValid(vector<vector<char>>&grid, int x, int y){\\n        int m = grid.size(), n = grid[0].size();\\n        return (x>=0 and y>=0 and x<m and y<n and grid[x][y]!=\\'#\\');\\n    }\\n    \\n    bool canAccess(vector<vector<char>>&grid, int dest, int src, int box){\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<bool> visited(m*n,false);\\n        visited[src] = true;\\n        \\n        // mark the location of box as blocked as stkp can\\'t travel there\\n        grid[box/n][box%n] = \\'#\\';\\n        \\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int cp = q.front();\\n            q.pop();\\n            if(dest==cp){grid[box/n][box%n] = \\'.\\';return true;}\\n            for(auto e:dir){\\n                int nx = cp/n+e[0], ny = cp%n+e[1];\\n                int np = nx*n+ny;\\n                if(np>=0 and np<m*n){\\n                    if(visited[np]) continue;\\n                    visited[np] = true;\\n                    if(!isValid(grid,nx,ny)) continue;\\n                    q.push(np);\\n                }\\n            }\\n        }\\n        grid[box/n][box%n] = \\'.\\';\\n        return false;\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        // get position of storekeeper, box and target\\n        // and mark those points as open path, i.e. \\'.\\'\\n        int stkp, box, tar;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'S\\') {stkp = i*n+j;grid[i][j]=\\'.\\';}\\n                else if(grid[i][j]==\\'B\\') {box = i*n+j;grid[i][j]=\\'.\\';}\\n                else if(grid[i][j]==\\'T\\') {tar = i*n+j;;grid[i][j]=\\'.\\';}\\n            }\\n        }\\n        if(box==tar) return 0;\\n        \\n        // BFSing for box to target\\n        \\n        // queue stores the stkp and the box locations\\n        // as both needs to be kept track of while traversing\\n        // for each location of the box\\n        queue<pair<int,int>> q;\\n        q.push({box,stkp});\\n        \\n        // keeping track of visited nodes for the stkp and \\n        // the box simultaneously using a string\\n        unordered_set<string> visited;\\n        visited.insert(to_string(stkp)+\" \"+to_string(box));\\n        \\n        int pushes = 0;\\n        while(!q.empty()){\\n            int len = q.size();\\n            while(len--){\\n                auto [bo,stkpo] = q.front();\\n                q.pop();\\n                if(bo==tar) return pushes;\\n                for(auto e:dir){\\n                    int nbx = bo/n+e[0], nby = bo%n+e[1];\\n                    int nstkpx = bo/n-e[0], nstkpy = bo%n-e[1];\\n                    int nstkp = nstkpx*n+nstkpy, nb = nbx*n+nby;\\n                    if(nstkp>=0 and nb>=0 and nstkp<m*n and nb<m*n){\\n                        string key = to_string(nstkp)+\" \"+to_string(nb);\\n                        if(visited.find(key)!=visited.end()) continue;\\n                        if(!isValid(grid,nbx,nby) or !isValid(grid,nstkpx,nstkpy)) continue;\\n                    \\n                        // if stkp can get to the position from where he can push the box\\n                        // push new position of box and new position of stkp (old position of box)\\n                        // into the queue\\n                        if(canAccess(grid,nstkp,stkpo,bo)){\\n                            visited.insert(key);\\n                            q.push({nb,bo});\\n                        }\\n                    }\\n                }\\n            }\\n            // if reached this point means 1 push has been performed\\n            // and the box is 1 step closer to the target\\n            pushes++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431850,
                "title": "java-bfs-17ms-explained-with-comments",
                "content": "Two things need to pay attention:\\n* While trying to recorded to **visited position of Box**, we need to include an additional dimension to record which direction the Player pushed the box from. For example, there are 4 previous positions that the Box can arrive position (x, y). We have to treat those 4 states separately.\\n* While checking if the Player is able to reach the correct position to make a valid push, we need to **set the Box position as an obstacle(#)** since the Player cannot walk pass Box. Also, we need to keep track of **the previous position of the Player** after making the push.\\n\\nI have included comments in my code. Hope this helps.\\n\\n```\\nclass Solution {\\n    private char[][] G;\\n    private int rows;\\n    private int cols;\\n    private int[] dir = new int[]{-1,0,1,0,-1};\\n    public int minPushBox(char[][] grid) {\\n        // Sanity check\\n        if(grid == null || grid.length == 0 || grid[0].length == 0)     \\n            return-1;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        G = grid;\\n        \\n        // Find the location of the Target, the Box and the Player.\\n        int[] tLoc = new int[2];\\n        int[] pLoc = new int[2];\\n        int[] bLoc = new int[2];\\n        for(int r = 0; r < rows; r++) {\\n            for(int c = 0; c < cols; c++) {\\n                if(G[r][c] == \\'S\\')\\n                    pLoc = new int[]{r,c};\\n                \\n                if(G[r][c] == \\'T\\') \\n                    tLoc = new int[]{r,c};\\n                \\n                if(G[r][c] == \\'B\\')  \\n                    bLoc = new int[]{r,c};\\n                \\n                // Set those location to be Floor so we can BFS easier\\n                if(G[r][c] != \\'#\\')  \\n                    G[r][c] = \\'.\\';\\n            }\\n        }\\n        \\n        // BFS on Box\\n        return bfs(pLoc, bLoc, tLoc);\\n    }\\n    \\n    // BFS for Box\\n    private int bfs(int[] p, int[] b, int[] t) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        // Keep a record of the Player position along with the Box positon\\n        int[] L = new int[]{b[0],b[1],p[0],p[1]};\\n        \\n        // An extra dimension to keep track of where the Box is pushed from\\n        boolean[][][] visited = new boolean[rows][cols][4];\\n        queue.offer(L);\\n        int step = 0;\\n        \\n        // Standard BFS\\n        while(!queue.isEmpty()) {\\n            int len = queue.size();\\n            while(len > 0) {\\n                int[] loc = queue.poll();\\n                // Mark the current Box position as an obstacle\\n                G[loc[0]][loc[1]] = \\'#\\';\\n                \\n                // Use directional array to check 4 directions\\n                for(int i = 0; i < 4; i++) {\\n                    int deltaR = dir[i];\\n                    int deltaC = dir[i+1];\\n                    int newR = loc[0] + deltaR;\\n                    int newC = loc[1] + deltaC;\\n                    \\n                    // If the new Box position is in bound \\n                    // && the Play can reach that position\\n                    // && that position is a Floor\\n                    // && that position is visited with the current push direction \"i\"\\n                    if(inBound(newR,newC) \\n                            && reachable(loc[2],loc[3],loc[0]-deltaR,loc[1]-deltaC)\\n                            && G[newR][newC] != \\'#\\' \\n                            && !visited[newR][newC][i]) {\\n                        \\n                        // If the Target is reached\\n                        if(t[0] == newR && t[1] == newC)  return step+1;\\n                        \\n                        // Put the new Box position into the queue along with the Player position\\n                        queue.offer(new int[]{newR, newC,loc[0],loc[1]});\\n                        visited[newR][newC][i] = true;\\n                    }\\n                }\\n                \\n                // Mark the Box position back to Floor\\n                G[loc[0]][loc[1]] = \\'.\\';\\n                \\n                len--;\\n            }\\n            step++;\\n        }\\n        \\n        // If the program reaches here, it means no solution.\\n        return -1;\\n    }\\n    \\n    // BFS for Plahyer\\n    // This is just standard BFS, return true if Player can reach that position\\n    private boolean reachable(int pR, int pC, int r, int c) {\\n        // If the Play is on that position to start with, return true\\n        if(pR == r && pC == c)  \\n            return true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        queue.offer(new int[]{pR, pC});\\n        \\n        while(!queue.isEmpty()) {\\n            int len = queue.size();\\n            while(len > 0) {\\n                int[] loc = queue.poll();\\n                if(!visited[loc[0]][loc[1]]) {\\n                    visited[loc[0]][loc[1]] = true;\\n                    for(int i = 0; i < 4; i++) {\\n                        int newR = loc[0] + dir[i];\\n                        int newC = loc[1] + dir[i+1];\\n                        if(inBound(newR,newC) \\n                           && G[newR][newC] != \\'#\\' \\n                           && !visited[newR][newC]) {\\n                            if(r == newR && c == newC)  return true;\\n                            queue.offer(new int[]{newR, newC});\\n                        }\\n                    }\\n                }\\n                len--;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // Check if the coordinate is out of bound\\n    private boolean inBound(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n}\\n```\\n\\nTime complexity: O((nm)^2)\\nIn worse case, the Box has to traverse through the entire matrix which has nm vertices. We also need to do the same thing for the Play with each vertice. That makes the total iteration to be (nm)^2. But, in practice, it will be way lower than that.\\n\\nSpace complexity: O(nm)\\nMemory needed for Queue in BFS.\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private char[][] G;\\n    private int rows;\\n    private int cols;\\n    private int[] dir = new int[]{-1,0,1,0,-1};\\n    public int minPushBox(char[][] grid) {\\n        // Sanity check\\n        if(grid == null || grid.length == 0 || grid[0].length == 0)     \\n            return-1;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        G = grid;\\n        \\n        // Find the location of the Target, the Box and the Player.\\n        int[] tLoc = new int[2];\\n        int[] pLoc = new int[2];\\n        int[] bLoc = new int[2];\\n        for(int r = 0; r < rows; r++) {\\n            for(int c = 0; c < cols; c++) {\\n                if(G[r][c] == \\'S\\')\\n                    pLoc = new int[]{r,c};\\n                \\n                if(G[r][c] == \\'T\\') \\n                    tLoc = new int[]{r,c};\\n                \\n                if(G[r][c] == \\'B\\')  \\n                    bLoc = new int[]{r,c};\\n                \\n                // Set those location to be Floor so we can BFS easier\\n                if(G[r][c] != \\'#\\')  \\n                    G[r][c] = \\'.\\';\\n            }\\n        }\\n        \\n        // BFS on Box\\n        return bfs(pLoc, bLoc, tLoc);\\n    }\\n    \\n    // BFS for Box\\n    private int bfs(int[] p, int[] b, int[] t) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        // Keep a record of the Player position along with the Box positon\\n        int[] L = new int[]{b[0],b[1],p[0],p[1]};\\n        \\n        // An extra dimension to keep track of where the Box is pushed from\\n        boolean[][][] visited = new boolean[rows][cols][4];\\n        queue.offer(L);\\n        int step = 0;\\n        \\n        // Standard BFS\\n        while(!queue.isEmpty()) {\\n            int len = queue.size();\\n            while(len > 0) {\\n                int[] loc = queue.poll();\\n                // Mark the current Box position as an obstacle\\n                G[loc[0]][loc[1]] = \\'#\\';\\n                \\n                // Use directional array to check 4 directions\\n                for(int i = 0; i < 4; i++) {\\n                    int deltaR = dir[i];\\n                    int deltaC = dir[i+1];\\n                    int newR = loc[0] + deltaR;\\n                    int newC = loc[1] + deltaC;\\n                    \\n                    // If the new Box position is in bound \\n                    // && the Play can reach that position\\n                    // && that position is a Floor\\n                    // && that position is visited with the current push direction \"i\"\\n                    if(inBound(newR,newC) \\n                            && reachable(loc[2],loc[3],loc[0]-deltaR,loc[1]-deltaC)\\n                            && G[newR][newC] != \\'#\\' \\n                            && !visited[newR][newC][i]) {\\n                        \\n                        // If the Target is reached\\n                        if(t[0] == newR && t[1] == newC)  return step+1;\\n                        \\n                        // Put the new Box position into the queue along with the Player position\\n                        queue.offer(new int[]{newR, newC,loc[0],loc[1]});\\n                        visited[newR][newC][i] = true;\\n                    }\\n                }\\n                \\n                // Mark the Box position back to Floor\\n                G[loc[0]][loc[1]] = \\'.\\';\\n                \\n                len--;\\n            }\\n            step++;\\n        }\\n        \\n        // If the program reaches here, it means no solution.\\n        return -1;\\n    }\\n    \\n    // BFS for Plahyer\\n    // This is just standard BFS, return true if Player can reach that position\\n    private boolean reachable(int pR, int pC, int r, int c) {\\n        // If the Play is on that position to start with, return true\\n        if(pR == r && pC == c)  \\n            return true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        queue.offer(new int[]{pR, pC});\\n        \\n        while(!queue.isEmpty()) {\\n            int len = queue.size();\\n            while(len > 0) {\\n                int[] loc = queue.poll();\\n                if(!visited[loc[0]][loc[1]]) {\\n                    visited[loc[0]][loc[1]] = true;\\n                    for(int i = 0; i < 4; i++) {\\n                        int newR = loc[0] + dir[i];\\n                        int newC = loc[1] + dir[i+1];\\n                        if(inBound(newR,newC) \\n                           && G[newR][newC] != \\'#\\' \\n                           && !visited[newR][newC]) {\\n                            if(r == newR && c == newC)  return true;\\n                            queue.offer(new int[]{newR, newC});\\n                        }\\n                    }\\n                }\\n                len--;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // Check if the coordinate is out of bound\\n    private boolean inBound(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431144,
                "title": "cpp-bfs-dfs-solution",
                "content": "Use BFS to solve the problem:\\nFor each state  `[person, box]`,  use dfs to find if the person can walk to the \\'back\\' of the box and push the box. Once the box reaches the destination, bfs guarantees to find the optimal solution.\\nBe careful with the box position since we may be obstructed by the box after we push it.\\n\\n(grid size `M` x `N`)\\n**Time Complexity**:  `O((MN)^2)` \\nIt may look like `O((MN)^3)` at the first glance, we have `O((MN)^2)` person-box states and each canReach() takes `O(MN)` time. However, for each box location, the person must be adjacent to him, so there\\'re total `O(MN)` state for this bfs solution and the all time is `O((MN)^2)`.\\n\\n**Space complexity**: `O(M*N)`\\n\\nUpdate 09/05/2020: code refactored for a better view.\\n```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    bool valid(vector<vector<char>>& g, int x, int y) {\\n        if(x < 0 || x >= m || y < 0 || y >= n || g[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool canReach(vector<vector<char>>& g, vector<vector<bool>>& pplLoc, int x, int y, int bx, int by) {\\n        if(!valid(g, x, y) || pplLoc[x][y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x][y] = true;\\n        for(auto& d : dir) {\\n            if(canReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\npublic:\\n    typedef pair<int, int> PI;\\n    typedef pair<PI, PI> PII;\\n    \\n    int minPushBox(vector<vector<char>>& g) {\\n        m = g.size(), n = g[0].size();\\n        int px, py, bx, by, gx, gy;\\n        for(int x = 0; x < m; ++x) {\\n            for(int y = 0; y < n; ++y) {\\n                if(g[x][y] == \\'S\\') {\\n                    px = x, py = y;\\n                }else if(g[x][y] == \\'B\\') {\\n                    bx = x, by = y;\\n                }else if(g[x][y] == \\'T\\') {\\n                    gx = x, gy = y;\\n                }\\n            }\\n        }\\n        queue<PII> q;\\n        set<PII> visited;\\n        q.push({{px, py}, {bx, by}});\\n        visited.insert({{px, py}, {bx, by}});\\n        int ans = 0;\\n        while(q.size()) {\\n            ans++;\\n            for(int l = q.size(); l > 0; --l) {\\n                auto f = q.front();\\n                q.pop();\\n                auto [px, py] = f.first;\\n                auto [bx, by] = f.second;\\n                g[bx][by] = \\'#\\';\\n                for(auto& d : dir) {\\n                    vector<vector<bool>> pplLoc(m, vector<bool>(n, false));\\n                    if(canReach(g, pplLoc, px, py, bx - d[0], by - d[1])) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if(nbx == gx && nby == gy) {\\n                            return ans;\\n                        }\\n                        if(valid(g, nbx, nby)) {\\n                            PII newState = {{bx, by}, {nbx, nby}};\\n                            if(!visited.count(newState)) {\\n                                visited.insert(newState);\\n                                q.push(newState);\\n                            }\\n                        }\\n                    }\\n                }\\n                g[bx][by] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    bool valid(vector<vector<char>>& g, int x, int y) {\\n        if(x < 0 || x >= m || y < 0 || y >= n || g[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool canReach(vector<vector<char>>& g, vector<vector<bool>>& pplLoc, int x, int y, int bx, int by) {\\n        if(!valid(g, x, y) || pplLoc[x][y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x][y] = true;\\n        for(auto& d : dir) {\\n            if(canReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\npublic:\\n    typedef pair<int, int> PI;\\n    typedef pair<PI, PI> PII;\\n    \\n    int minPushBox(vector<vector<char>>& g) {\\n        m = g.size(), n = g[0].size();\\n        int px, py, bx, by, gx, gy;\\n        for(int x = 0; x < m; ++x) {\\n            for(int y = 0; y < n; ++y) {\\n                if(g[x][y] == \\'S\\') {\\n                    px = x, py = y;\\n                }else if(g[x][y] == \\'B\\') {\\n                    bx = x, by = y;\\n                }else if(g[x][y] == \\'T\\') {\\n                    gx = x, gy = y;\\n                }\\n            }\\n        }\\n        queue<PII> q;\\n        set<PII> visited;\\n        q.push({{px, py}, {bx, by}});\\n        visited.insert({{px, py}, {bx, by}});\\n        int ans = 0;\\n        while(q.size()) {\\n            ans++;\\n            for(int l = q.size(); l > 0; --l) {\\n                auto f = q.front();\\n                q.pop();\\n                auto [px, py] = f.first;\\n                auto [bx, by] = f.second;\\n                g[bx][by] = \\'#\\';\\n                for(auto& d : dir) {\\n                    vector<vector<bool>> pplLoc(m, vector<bool>(n, false));\\n                    if(canReach(g, pplLoc, px, py, bx - d[0], by - d[1])) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if(nbx == gx && nby == gy) {\\n                            return ans;\\n                        }\\n                        if(valid(g, nbx, nby)) {\\n                            PII newState = {{bx, by}, {nbx, nby}};\\n                            if(!visited.count(newState)) {\\n                                visited.insert(newState);\\n                                q.push(newState);\\n                            }\\n                        }\\n                    }\\n                }\\n                g[bx][by] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493053,
                "title": "c-16ms-12mb-pictures-to-show-step-by-step-problem-solving",
                "content": "At the first sight of this problem, I was trying to use backtracking or recursion to solve until I reread the question and examples: even there is a valid path from box position to target position the player could still be not able to make it. Then I gave up recursion also considering it can end up with O(4^(mn)) in worst cases.\\n\\nBacktracking or recursion is actually depth-first-search, though breadth-first-search seems to be more suitable for this problem (we can know the number of moves easier).\\n\\nThen I know at least I need two queues to do breadth-first-search, one is for box, another is for player.\\n\\nThen the problem comes to be how to record the path, one thing off the top of my head is using \"**visit[row][col]**\" to keep a record of the positions that has been visited.\\n\\nI started to write code based on the analysis above until failed at this test case: \\n\\nwhere the player has to revisit a cell to get through when the box is blocking the way to the target.\\n\\n![image](https://assets.leetcode.com/users/images/2f8ac61a-c699-4b4d-aeb7-4cd3a8ba4627_1632904494.8413801.png)\\n\\nApparently just using **visit[row][col]** cannot cover this type of cases, we need to take player\\'s position into account, maybe **visit[box_row][box_col][player_row][player_col]**. \\n\\nWhat does it mean? **It represents the minimal moves that the player needs to do when the box is at (box_row, box_col) and the player is at (player_row, player_col).**\\n\\nThe box can be anywhere in the grid, but do we need to know all the doable position of the player for each positon of the box?\\n\\nThe answer is NO, because we only care the position that is next to the box, which is up/right/down/left. For example, when the player is up the box, the box will be pushed down by the player,  when the player is on the right side of the box, the box will be pushed towards the left by the player.\\n\\nThis suggests us to simplify from **visit[box_row][box_col][player_row][player_col]** to **visit[box_row][box_col][direction]** to bring the space complexity from n^4 down to 4*(n^2).  0<= box_row < n,  0<= box_col < n,  direction = 4 (up/right/down/left).\\n \\n**visit[box_row][box_col][direction]** means the minimal moves when the player pushes the box from that direction.\\n\\nYou can walk through an example in the picture below, if you can understand how the numbers get calculated, it will be easy to understand the code at the end of this post.\\n\\n![image](https://assets.leetcode.com/users/images/8c205009-a27b-4c8a-8c40-5cba4d469f6a_1632900631.8579888.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n// check if the player can get to (pi1, pj1) from (pi2, pj2) when the box is in (bi, bj)\\n    bool canPlayerDoIt(vector<vector<char>>& grid, vector<vector<int>>& directions, int bi, int bj, int pi1, int pj1, int pi2, int pj2) {\\n        if (pi1 == pi2 && pj1 == pj2)\\n            return true;\\n\\n        vector<vector<int>> visit(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, int>> qp;\\n        qp.push(pair<int, int>(pi1, pj1));\\n        visit[pi1][pj1] = 1;\\n\\n        while (!qp.empty()) {\\n            int row = qp.front().first, col = qp.front().second;\\n            for (int idx = 0; idx < directions.size(); idx++) {\\n                int r = row + directions[idx][0], c = col + directions[idx][1];\\n                if (r<0 || c<0 || r>grid.size() - 1 || c>grid[0].size() - 1 || visit[r][c] != 0) continue;\\n                if (r == pi2 && c == pj2)  return true;\\n                else if (grid[r][c] != \\'#\\' && (r != bi || c != bj))\\n                    qp.push(pair<int, int>(r, c)), visit[r][c] = 1;\\n            }\\n            qp.pop();\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int dp[20][20][4] = { 0 }; // (box_row, box_col, up/right/down/left)\\n        vector<vector<int>> directions = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} }; // up, right, down, left\\n        queue<pair<int, int>> qb; // queue for box\\n        int ti = 0, tj = 0, pi = 0, pj = 0, bi = 0, bj = 0; //target, player, box\\n\\n        // find target, player, box\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == \\'T\\')\\n                    ti = i, tj = j;\\n                else if (grid[i][j] == \\'S\\')\\n                    pi = i, pj = j;\\n                else if (grid[i][j] == \\'B\\')\\n                    bi = i, bj = j;\\n\\n        // Trying to get the minimum pushes \\n        qb.push(pair<int, int>(ti, tj));\\n        for (int idx = 0; idx < directions.size(); idx++) {\\n            int pr = ti + 2 * directions[idx][0], pc = tj + 2 * directions[idx][1], br = ti + directions[idx][0], bc = tj + directions[idx][1];\\n            if (pr >= 0 && pr < m && pc >= 0 && pc < n && grid[pr][pc] != \\'#\\' && grid[br][bc] != \\'#\\'){\\n                dp[br][bc][idx] = 1;\\n                if (grid[br][bc] == \\'B\\'){ // find the box\\n                    if (canPlayerDoIt(grid, directions, br, bc, br + directions[idx][0], bc + directions[idx][1], pi, pj))\\n                        return dp[br][bc][idx];\\n                }\\n                qb.push(pair<int, int>(br, bc));\\n            }\\n        }\\n        qb.pop();\\n\\n        while (!qb.empty()){\\n            int row = qb.front().first, col = qb.front().second, current = 0, move = 0;\\n            for (int idx = 0; idx < directions.size(); idx++)\\n                if (dp[row][col][idx] > move)\\n                    move = dp[row][col][idx], current = idx;    // what if there are 1+ max values , 1+ current\\n\\n            for (int idx = 0; idx < directions.size(); idx++){\\n                int pr = row + 2 * directions[idx][0], pc = col + 2 * directions[idx][1], br = row + directions[idx][0], bc = col + directions[idx][1];\\n                if (pr >= 0 && pr < m && pc >= 0 && pc < n && grid[pr][pc] != \\'#\\' && grid[br][bc] != \\'#\\') { //&& grid[pr][pc] != \\'T\\' && grid[br][bc] != \\'T\\')\\n                    if (current == idx || (dp[br][bc][idx] == 0 &&\\n                            canPlayerDoIt(grid, directions, row, col, row + directions[idx][0], col + directions[idx][1], row + directions[current][0], col + directions[current][1])))\\n                    {\\n                        dp[br][bc][idx] = 1 + move;\\n                        if (grid[br][bc] == \\'B\\') // FIND THE BOX\\n                            if (canPlayerDoIt(grid, directions, br, bc, br + directions[idx][0], bc + directions[idx][1], pi, pj))\\n                                return dp[br][bc][idx];\\n                        if (dp[br][bc][idx] > dp[br][bc][(idx + 1) % 4] && dp[br][bc][idx] > dp[br][bc][(idx + 2) % 4] && dp[br][bc][idx] > dp[br][bc][(idx + 3) % 4])\\n                            qb.push(pair<int, int>(br, bc));\\n                    }\\n                }\\n            }\\n            qb.pop();\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n// check if the player can get to (pi1, pj1) from (pi2, pj2) when the box is in (bi, bj)\\n    bool canPlayerDoIt(vector<vector<char>>& grid, vector<vector<int>>& directions, int bi, int bj, int pi1, int pj1, int pi2, int pj2) {\\n        if (pi1 == pi2 && pj1 == pj2)\\n            return true;\\n\\n        vector<vector<int>> visit(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, int>> qp;\\n        qp.push(pair<int, int>(pi1, pj1));\\n        visit[pi1][pj1] = 1;\\n\\n        while (!qp.empty()) {\\n            int row = qp.front().first, col = qp.front().second;\\n            for (int idx = 0; idx < directions.size(); idx++) {\\n                int r = row + directions[idx][0], c = col + directions[idx][1];\\n                if (r<0 || c<0 || r>grid.size() - 1 || c>grid[0].size() - 1 || visit[r][c] != 0) continue;\\n                if (r == pi2 && c == pj2)  return true;\\n                else if (grid[r][c] != \\'#\\' && (r != bi || c != bj))\\n                    qp.push(pair<int, int>(r, c)), visit[r][c] = 1;\\n            }\\n            qp.pop();\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int dp[20][20][4] = { 0 }; // (box_row, box_col, up/right/down/left)\\n        vector<vector<int>> directions = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} }; // up, right, down, left\\n        queue<pair<int, int>> qb; // queue for box\\n        int ti = 0, tj = 0, pi = 0, pj = 0, bi = 0, bj = 0; //target, player, box\\n\\n        // find target, player, box\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == \\'T\\')\\n                    ti = i, tj = j;\\n                else if (grid[i][j] == \\'S\\')\\n                    pi = i, pj = j;\\n                else if (grid[i][j] == \\'B\\')\\n                    bi = i, bj = j;\\n\\n        // Trying to get the minimum pushes \\n        qb.push(pair<int, int>(ti, tj));\\n        for (int idx = 0; idx < directions.size(); idx++) {\\n            int pr = ti + 2 * directions[idx][0], pc = tj + 2 * directions[idx][1], br = ti + directions[idx][0], bc = tj + directions[idx][1];\\n            if (pr >= 0 && pr < m && pc >= 0 && pc < n && grid[pr][pc] != \\'#\\' && grid[br][bc] != \\'#\\'){\\n                dp[br][bc][idx] = 1;\\n                if (grid[br][bc] == \\'B\\'){ // find the box\\n                    if (canPlayerDoIt(grid, directions, br, bc, br + directions[idx][0], bc + directions[idx][1], pi, pj))\\n                        return dp[br][bc][idx];\\n                }\\n                qb.push(pair<int, int>(br, bc));\\n            }\\n        }\\n        qb.pop();\\n\\n        while (!qb.empty()){\\n            int row = qb.front().first, col = qb.front().second, current = 0, move = 0;\\n            for (int idx = 0; idx < directions.size(); idx++)\\n                if (dp[row][col][idx] > move)\\n                    move = dp[row][col][idx], current = idx;    // what if there are 1+ max values , 1+ current\\n\\n            for (int idx = 0; idx < directions.size(); idx++){\\n                int pr = row + 2 * directions[idx][0], pc = col + 2 * directions[idx][1], br = row + directions[idx][0], bc = col + directions[idx][1];\\n                if (pr >= 0 && pr < m && pc >= 0 && pc < n && grid[pr][pc] != \\'#\\' && grid[br][bc] != \\'#\\') { //&& grid[pr][pc] != \\'T\\' && grid[br][bc] != \\'T\\')\\n                    if (current == idx || (dp[br][bc][idx] == 0 &&\\n                            canPlayerDoIt(grid, directions, row, col, row + directions[idx][0], col + directions[idx][1], row + directions[current][0], col + directions[current][1])))\\n                    {\\n                        dp[br][bc][idx] = 1 + move;\\n                        if (grid[br][bc] == \\'B\\') // FIND THE BOX\\n                            if (canPlayerDoIt(grid, directions, br, bc, br + directions[idx][0], bc + directions[idx][1], pi, pj))\\n                                return dp[br][bc][idx];\\n                        if (dp[br][bc][idx] > dp[br][bc][(idx + 1) % 4] && dp[br][bc][idx] > dp[br][bc][(idx + 2) % 4] && dp[br][bc][idx] > dp[br][bc][(idx + 3) % 4])\\n                            qb.push(pair<int, int>(br, bc));\\n                    }\\n                }\\n            }\\n            qb.pop();\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438649,
                "title": "c-2-bfs-with-explanations",
                "content": "Intuition and observations:\\n* we need to count only the box moves, so let\\'s kick around the box and count the moves\\n* for the person we need to check if he can walk to the place in front of the box\\n* to move the box, the person have to stand in front of it:\\n```\\n[[\".\",\".\",\".\"],  [[\".\",\".\",\".\"],  [[\".\",\"S\",\".\"],  [[\".\",\"T\",\".\"],\\n [\"S\",\"B\",\"T\"],   [\"T\",\"B\",\"S\"],   [\".\",\"B\",\".\"],   [\".\",\"B\",\".\"],\\n [\".\",\".\",\".\"]]   [\".\",\".\",\".\"]]   [\".\",\"T\",\".\"]]   [\".\",\"S\",\".\"]]\\n```\\n* When the person moves the box, he will take the place of the box\\n* Usually the person will hang around the box so BFS is preferrable\\n* The box itself is an obstacle so we need to check if a person can walk separately for each box position. As a consequence, we need to track person+box positions as visited\\n* The same position of the person and the box can be walkable or not depending on where the person starts. So we should mark the person+box position as visited only when it is reachable.\\n* To navigate properly always use rows and cols (and never x and y) because it matches the intuition: ```grid[r][c]```. For x and y it would be ```grid[y][x]``` so don\\'t do that\\n\\nSteps:\\n* find the positions of person, box and target\\n* iterate all positions reachable with one more move (and add next moves to the same list)\\n* for each position try to move the box in all 4 directions (BFS #1)\\n* check if the person can walk to stand in front of the box (BFS #2)\\n\\n```\\nclass Solution {\\n    int rows, cols;\\n    vector<vector<int>> dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\t// positions: person, new_person, box\\n    bool isReachable(int pr, int pc, int npr, int npc, int br, int bc, vector<vector<char>>& grid)\\n    {\\n        vector<int> visited(rows*cols,0);\\n        visited[pr*cols+pc]=1;\\n        list<vector<int>> togo; togo.push_back({pr,pc});\\n        while(togo.size())\\n        {\\n            int r=togo.front()[0], c=togo.front()[1];\\n            togo.pop_front();\\n            if(r==npr && c==npc) return true;\\n            for(auto& d:dirs)\\n            {\\n                int nr=r+d[0], nc=c+d[1], key=nr*cols+nc;\\n                if(nr<0||nc<0||nr>=rows||nc>=cols||grid[nr][nc]==\\'#\\'||(nr==br&&nc==bc)) continue;\\n                if(visited[key]) continue;\\n                visited[key]=1;\\n                togo.push_back({nr,nc});\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        rows = grid.size(), cols=grid[0].size();\\n        int pr,pc,br,bc,tr,tc; // person, box, target\\n        for(int r=0;r<rows;r++)\\n            for(int c=0;c<cols;c++)\\n                if(     grid[r][c]==\\'S\\') pr=r, pc=c;\\n                else if(grid[r][c]==\\'B\\') br=r, bc=c;\\n                else if(grid[r][c]==\\'T\\') tr=r, tc=c;\\n        \\n        vector<vector<int>> visited(rows*cols,vector<int>(rows*cols,0));\\n        int pkey=pr*cols+pc, bkey=br*cols+bc;\\n        visited[pkey][bkey]=1;\\n        queue<vector<int>> q;\\n        q.push({pr,pc,br,bc});  // person.r, person.c, box.r, box.c\\n\\n        int moves=0;\\n        while(q.size())\\n        {\\n            int len = q.size();\\n            moves++;\\n            for(int i=0; i<len; i++) // iterate throuh all positions reachable within 1 move\\n            {\\n                vector<int>& pos = q.front();\\n                int pr=pos[0], pc=pos[1], br=pos[2], bc=pos[3];\\n                q.pop();\\n                for(auto& d:dirs) // try to move the box\\n                {\\n                    // person stands in front of the box to move it \\n                    int nbr=br+d[0], nbc=bc+d[1], npr=br-d[0], npc=bc-d[1];\\n                    if(nbr<0||nbc<0||nbr>=rows||nbc>=cols||grid[nbr][nbc]==\\'#\\') continue;\\n                    if(npr<0||npc<0||npr>=rows||npc>=cols||grid[npr][npc]==\\'#\\') continue;\\n\\n                    pkey=npr*cols+npc, bkey=br*cols+bc;\\n                    if(visited[pkey][bkey]==1) continue;\\n                    \\n                    // try to walk to the new position and consider where is the box now\\n                    if(!isReachable(pr,pc,npr,npc,br,bc,grid)) continue;\\n                    visited[pkey][bkey]=1; // trick: mark as visited only if we managed to get there\\n                    if(nbr==tr && nbc==tc) return moves;\\n                    \\n                    q.push({br,bc,nbr,nbc}); // the person takes the place of the box\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis test case is the most advanced since the same position of the box and person have to be checked twice (```grid[3][4]``` to move the box up):\\n```\\n[[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n\\n[\\n[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],   0\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],   1\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],   2\\n[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],   3\\n[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],   4\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]   5\\n  0   1   2   3   4   5   6   7   8\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n[[\".\",\".\",\".\"],  [[\".\",\".\",\".\"],  [[\".\",\"S\",\".\"],  [[\".\",\"T\",\".\"],\\n [\"S\",\"B\",\"T\"],   [\"T\",\"B\",\"S\"],   [\".\",\"B\",\".\"],   [\".\",\"B\",\".\"],\\n [\".\",\".\",\".\"]]   [\".\",\".\",\".\"]]   [\".\",\"T\",\".\"]]   [\".\",\"S\",\".\"]]\\n```\n```grid[r][c]```\n```grid[y][x]```\n```\\nclass Solution {\\n    int rows, cols;\\n    vector<vector<int>> dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\t// positions: person, new_person, box\\n    bool isReachable(int pr, int pc, int npr, int npc, int br, int bc, vector<vector<char>>& grid)\\n    {\\n        vector<int> visited(rows*cols,0);\\n        visited[pr*cols+pc]=1;\\n        list<vector<int>> togo; togo.push_back({pr,pc});\\n        while(togo.size())\\n        {\\n            int r=togo.front()[0], c=togo.front()[1];\\n            togo.pop_front();\\n            if(r==npr && c==npc) return true;\\n            for(auto& d:dirs)\\n            {\\n                int nr=r+d[0], nc=c+d[1], key=nr*cols+nc;\\n                if(nr<0||nc<0||nr>=rows||nc>=cols||grid[nr][nc]==\\'#\\'||(nr==br&&nc==bc)) continue;\\n                if(visited[key]) continue;\\n                visited[key]=1;\\n                togo.push_back({nr,nc});\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        rows = grid.size(), cols=grid[0].size();\\n        int pr,pc,br,bc,tr,tc; // person, box, target\\n        for(int r=0;r<rows;r++)\\n            for(int c=0;c<cols;c++)\\n                if(     grid[r][c]==\\'S\\') pr=r, pc=c;\\n                else if(grid[r][c]==\\'B\\') br=r, bc=c;\\n                else if(grid[r][c]==\\'T\\') tr=r, tc=c;\\n        \\n        vector<vector<int>> visited(rows*cols,vector<int>(rows*cols,0));\\n        int pkey=pr*cols+pc, bkey=br*cols+bc;\\n        visited[pkey][bkey]=1;\\n        queue<vector<int>> q;\\n        q.push({pr,pc,br,bc});  // person.r, person.c, box.r, box.c\\n\\n        int moves=0;\\n        while(q.size())\\n        {\\n            int len = q.size();\\n            moves++;\\n            for(int i=0; i<len; i++) // iterate throuh all positions reachable within 1 move\\n            {\\n                vector<int>& pos = q.front();\\n                int pr=pos[0], pc=pos[1], br=pos[2], bc=pos[3];\\n                q.pop();\\n                for(auto& d:dirs) // try to move the box\\n                {\\n                    // person stands in front of the box to move it \\n                    int nbr=br+d[0], nbc=bc+d[1], npr=br-d[0], npc=bc-d[1];\\n                    if(nbr<0||nbc<0||nbr>=rows||nbc>=cols||grid[nbr][nbc]==\\'#\\') continue;\\n                    if(npr<0||npc<0||npr>=rows||npc>=cols||grid[npr][npc]==\\'#\\') continue;\\n\\n                    pkey=npr*cols+npc, bkey=br*cols+bc;\\n                    if(visited[pkey][bkey]==1) continue;\\n                    \\n                    // try to walk to the new position and consider where is the box now\\n                    if(!isReachable(pr,pc,npr,npc,br,bc,grid)) continue;\\n                    visited[pkey][bkey]=1; // trick: mark as visited only if we managed to get there\\n                    if(nbr==tr && nbc==tc) return moves;\\n                    \\n                    q.push({br,bc,nbr,nbc}); // the person takes the place of the box\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```grid[3][4]```\n```\\n[[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n\\n[\\n[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],   0\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],   1\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],   2\\n[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],   3\\n[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],   4\\n[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]   5\\n  0   1   2   3   4   5   6   7   8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431138,
                "title": "python-level-by-level-bfs-solution-similar-problems-listed",
                "content": "Level-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n\\n\\n```\\nStraightforward BFS:\\n(1) find the positions of the box and player (x_B, y_B, x_S, y_S), reset the cells to be \\'.\\'\\n(2) use (x_B, y_B, x_S, y_S) to represent the state\\n      (i) find the valid next steps to move the box (x_B, y_B) to its possible neighbors: \\n\\t      one move is valid if one neighbor is empty and the opposite neighbor is connected to (x_S, y_S)\\n\\t  (ii) use BFS to to check the opposite neighbor is connected to (x_S, y_S) or not\\n(3) traverse all possible states level-by-level\\n```\\n    \\n\\n```\\n    def minPushBox(self, grid: List[List[str]]) -> int:        \\n        def bfs_to_reach_S(r, c, x_B, y_B, x_S, y_S):\\n            curr_level = {(r, c)}\\n            visited = set()\\n            while curr_level:\\n                next_level = set()\\n                for i, j in curr_level:\\n                    visited.add((i, j))\\n                    if i == x_S and j == y_S:\\n                        return True\\n                    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                        i1, j1 = i + di, j + dj\\n                        if 0 <= i1 < n and 0 <= j1 < m and (i1, j1) not in visited and (i1, j1) != (x_B, y_B) and grid[i1][j1] != \\'#\\':\\n                            next_level.add((i1, j1))\\n                curr_level = next_level\\n            return False\\n            \\n        def valid_moves(grid, x_B, y_B, x_S, y_S):\\n            next_moves = []\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\\n                r1, c1 = x_B + dx, y_B + dy\\n                r2, c2 = x_B - dx, y_B - dy\\n                if 0 <= r1 < n and 0 <= c1 < m and grid[r1][c1] != \\'#\\' and 0 <= r2 < n and 0 <= c2 < m and grid[r2][c2] != \\'#\\':\\n                    if bfs_to_reach_S(r1, c1, x_B, y_B, x_S, y_S):\\n                        next_moves.append((r2, c2, x_B, y_B))\\n            return next_moves\\n        \\n        n, m = len(grid), len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == \\'B\\':\\n                    x_B, y_B = i, j\\n                elif grid[i][j] == \\'S\\':\\n                    x_S, y_S = i, j\\n        grid[x_B][y_B], grid[x_S][y_S] = \\'.\\', \\'.\\'\\n        curr_level = {(x_B, y_B, x_S, y_S)}\\n        visited = set()\\n        moves = 0\\n        while curr_level:\\n            next_level = set()\\n            for i_B, j_B, i_S, j_S in curr_level:\\n                visited.add((i_B, j_B, i_S, j_S))\\n                if grid[i_B][j_B] == \\'T\\':\\n                    return moves\\n                for i_B1, j_B1, i_S1, j_S1 in valid_moves(grid, i_B, j_B, i_S, j_S):\\n                    if (i_B1, j_B1, i_S1, j_S1) not in visited:\\n                        next_level.add((i_B1, j_B1, i_S1, j_S1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nStraightforward BFS:\\n(1) find the positions of the box and player (x_B, y_B, x_S, y_S), reset the cells to be \\'.\\'\\n(2) use (x_B, y_B, x_S, y_S) to represent the state\\n      (i) find the valid next steps to move the box (x_B, y_B) to its possible neighbors: \\n\\t      one move is valid if one neighbor is empty and the opposite neighbor is connected to (x_S, y_S)\\n\\t  (ii) use BFS to to check the opposite neighbor is connected to (x_S, y_S) or not\\n(3) traverse all possible states level-by-level\\n```\n```\\n    def minPushBox(self, grid: List[List[str]]) -> int:        \\n        def bfs_to_reach_S(r, c, x_B, y_B, x_S, y_S):\\n            curr_level = {(r, c)}\\n            visited = set()\\n            while curr_level:\\n                next_level = set()\\n                for i, j in curr_level:\\n                    visited.add((i, j))\\n                    if i == x_S and j == y_S:\\n                        return True\\n                    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                        i1, j1 = i + di, j + dj\\n                        if 0 <= i1 < n and 0 <= j1 < m and (i1, j1) not in visited and (i1, j1) != (x_B, y_B) and grid[i1][j1] != \\'#\\':\\n                            next_level.add((i1, j1))\\n                curr_level = next_level\\n            return False\\n            \\n        def valid_moves(grid, x_B, y_B, x_S, y_S):\\n            next_moves = []\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\\n                r1, c1 = x_B + dx, y_B + dy\\n                r2, c2 = x_B - dx, y_B - dy\\n                if 0 <= r1 < n and 0 <= c1 < m and grid[r1][c1] != \\'#\\' and 0 <= r2 < n and 0 <= c2 < m and grid[r2][c2] != \\'#\\':\\n                    if bfs_to_reach_S(r1, c1, x_B, y_B, x_S, y_S):\\n                        next_moves.append((r2, c2, x_B, y_B))\\n            return next_moves\\n        \\n        n, m = len(grid), len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == \\'B\\':\\n                    x_B, y_B = i, j\\n                elif grid[i][j] == \\'S\\':\\n                    x_S, y_S = i, j\\n        grid[x_B][y_B], grid[x_S][y_S] = \\'.\\', \\'.\\'\\n        curr_level = {(x_B, y_B, x_S, y_S)}\\n        visited = set()\\n        moves = 0\\n        while curr_level:\\n            next_level = set()\\n            for i_B, j_B, i_S, j_S in curr_level:\\n                visited.add((i_B, j_B, i_S, j_S))\\n                if grid[i_B][j_B] == \\'T\\':\\n                    return moves\\n                for i_B1, j_B1, i_S1, j_S1 in valid_moves(grid, i_B, j_B, i_S, j_S):\\n                    if (i_B1, j_B1, i_S1, j_S1) not in visited:\\n                        next_level.add((i_B1, j_B1, i_S1, j_S1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 499572,
                "title": "two-bfs-for-player-and-box-beats-100",
                "content": "```\\npublic class Solution \\n{\\n    private int[] x = new int[4] { 0, 0, 1, -1 };\\n    private int[] y = new int[4] { 1, -1, 0, 0 };\\n    \\n    public int MinPushBox(char[][] grid) \\n    {\\n        int bx = 0, by = 0, px = 0, py = 0, tx = 0, ty = 0;\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        \\n        // Set to maintain the visited positions of the player and box\\n        HashSet<int> boxSet = new HashSet<int>();\\n        HashSet<int> playerSet = new HashSet<int>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == \\'B\\')\\n                {\\n                    bx = i;\\n                    by = j;\\n                }\\n                else if(grid[i][j] == \\'S\\')\\n                {\\n                    px = i;\\n                    py = j;\\n                }\\n                else if(grid[i][j] == \\'T\\')\\n                {\\n                    tx = i;\\n                    ty = j;\\n                }\\n            }\\n        }\\n        \\n        Queue<Position> queue = new Queue<Position>();\\n        \\n        Position pos = new Position(px, py, bx, by);\\n        \\n        queue.Enqueue(pos);\\n        \\n        boxSet.Add(bx * n + by);\\n        \\n        for(int step = 0; queue.Count > 0; step++)\\n        {\\n            for(int size = queue.Count; size > 0; size--)\\n            {\\n                pos = queue.Dequeue();\\n            \\n                // Box has reached the target location\\n                if(pos.bx == tx && pos.by == ty)\\n                    return step;\\n                \\n                for(int i = 0; i < 4; i++)\\n                {\\n                    // Compute box position\\n                    bx = pos.bx + x[i];\\n                    by = pos.by + y[i];\\n                    \\n                    // Compute player position to move the box\\n                    px = pos.bx - x[i];\\n                    py = pos.by - y[i];\\n                    \\n                    if(bx < 0 || bx > m - 1 || by < 0 || by > n - 1)\\n                        continue;\\n                    \\n                    if(px < 0 || px > m - 1 || py < 0 || py > n - 1)\\n                        continue;\\n                    \\n                    if(grid[px][py] != \\'#\\' && grid[bx][by] != \\'#\\'  && (boxSet.Add(bx * n + by) || playerSet.Add(px * n + py)) && CanReachThePosition(grid, pos.px, pos.py, px, py, pos.bx, pos.by, m, n))\\n                    {\\n                        queue.Enqueue(new Position(pos.bx, pos.by, bx, by));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Check whether the player can reach the required position to move the box in a particular direction\\n    private bool CanReachThePosition(char[][] grid, int x1, int y1, int x2, int y2, int bx, int by, int m, int n)\\n    {\\n        Queue<Position> queue = new Queue<Position>();\\n        queue.Enqueue(new Position(x1, y1, x2, y2));\\n        \\n        HashSet<int> set = new HashSet<int>();\\n        \\n        set.Add(x1 * n + y1);\\n        set.Add(bx * n + by);\\n        \\n        while(queue.Count > 0)\\n        {\\n            Position pos = queue.Dequeue();\\n            \\n            if(pos.px == x2 && pos.py == y2)\\n                return true;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int px = pos.px + x[i];\\n                int py = pos.py + y[i];\\n\\n                if(px < 0 || px > m - 1 || py < 0 || py > n - 1)\\n                    continue;\\n                \\n                if(grid[px][py] != \\'#\\' && set.Add(px * n + py))\\n                {\\n                    queue.Enqueue(new Position(px, py, x2, y2));\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\npublic class Position\\n{\\n    // Player\\'s position in the grid\\n    public int px;\\n    public int py;\\n    \\n    // Box position in the grid\\n    public int bx;\\n    public int by;\\n    \\n    public Position(int px, int py, int bx, int by)\\n    {\\n        this.px = px;\\n        this.py = py;\\n        this.bx = bx;\\n        this.by = by;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private int[] x = new int[4] { 0, 0, 1, -1 };\\n    private int[] y = new int[4] { 1, -1, 0, 0 };\\n    \\n    public int MinPushBox(char[][] grid) \\n    {\\n        int bx = 0, by = 0, px = 0, py = 0, tx = 0, ty = 0;\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        \\n        // Set to maintain the visited positions of the player and box\\n        HashSet<int> boxSet = new HashSet<int>();\\n        HashSet<int> playerSet = new HashSet<int>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == \\'B\\')\\n                {\\n                    bx = i;\\n                    by = j;\\n                }\\n                else if(grid[i][j] == \\'S\\')\\n                {\\n                    px = i;\\n                    py = j;\\n                }\\n                else if(grid[i][j] == \\'T\\')\\n                {\\n                    tx = i;\\n                    ty = j;\\n                }\\n            }\\n        }\\n        \\n        Queue<Position> queue = new Queue<Position>();\\n        \\n        Position pos = new Position(px, py, bx, by);\\n        \\n        queue.Enqueue(pos);\\n        \\n        boxSet.Add(bx * n + by);\\n        \\n        for(int step = 0; queue.Count > 0; step++)\\n        {\\n            for(int size = queue.Count; size > 0; size--)\\n            {\\n                pos = queue.Dequeue();\\n            \\n                // Box has reached the target location\\n                if(pos.bx == tx && pos.by == ty)\\n                    return step;\\n                \\n                for(int i = 0; i < 4; i++)\\n                {\\n                    // Compute box position\\n                    bx = pos.bx + x[i];\\n                    by = pos.by + y[i];\\n                    \\n                    // Compute player position to move the box\\n                    px = pos.bx - x[i];\\n                    py = pos.by - y[i];\\n                    \\n                    if(bx < 0 || bx > m - 1 || by < 0 || by > n - 1)\\n                        continue;\\n                    \\n                    if(px < 0 || px > m - 1 || py < 0 || py > n - 1)\\n                        continue;\\n                    \\n                    if(grid[px][py] != \\'#\\' && grid[bx][by] != \\'#\\'  && (boxSet.Add(bx * n + by) || playerSet.Add(px * n + py)) && CanReachThePosition(grid, pos.px, pos.py, px, py, pos.bx, pos.by, m, n))\\n                    {\\n                        queue.Enqueue(new Position(pos.bx, pos.by, bx, by));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Check whether the player can reach the required position to move the box in a particular direction\\n    private bool CanReachThePosition(char[][] grid, int x1, int y1, int x2, int y2, int bx, int by, int m, int n)\\n    {\\n        Queue<Position> queue = new Queue<Position>();\\n        queue.Enqueue(new Position(x1, y1, x2, y2));\\n        \\n        HashSet<int> set = new HashSet<int>();\\n        \\n        set.Add(x1 * n + y1);\\n        set.Add(bx * n + by);\\n        \\n        while(queue.Count > 0)\\n        {\\n            Position pos = queue.Dequeue();\\n            \\n            if(pos.px == x2 && pos.py == y2)\\n                return true;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int px = pos.px + x[i];\\n                int py = pos.py + y[i];\\n\\n                if(px < 0 || px > m - 1 || py < 0 || py > n - 1)\\n                    continue;\\n                \\n                if(grid[px][py] != \\'#\\' && set.Add(px * n + py))\\n                {\\n                    queue.Enqueue(new Position(px, py, x2, y2));\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\npublic class Position\\n{\\n    // Player\\'s position in the grid\\n    public int px;\\n    public int py;\\n    \\n    // Box position in the grid\\n    public int bx;\\n    public int by;\\n    \\n    public Position(int px, int py, int bx, int by)\\n    {\\n        this.px = px;\\n        this.py = py;\\n        this.bx = bx;\\n        this.by = by;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128884,
                "title": "python-3-2-bfs-clean-code",
                "content": "For each push, make sure the person can stand at the required location that is reachable from a previous standing location.\\n\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n\\n        def valid(x, y):\\n            return 0<=x<m and 0<=y<n and grid[x][y]!=\\'#\\'\\n        \\n        def get_neighbor(i, j):\\n            for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                x, y = i + dx, j + dy\\n                if valid(x, y):\\n                    yield x, y\\n        \\n        def get_box_neighbor(i, j):\\n            for dx,dy in [(-1,0),(0,-1)]:\\n                x, y = i + dx, j + dy\\n                px, py = i - dx, j - dy\\n                if valid(x, y) and valid(px, py):\\n                    yield (x, y), (px, py)\\n                    yield (px, py), (x, y)\\n\\n        def check(curr, dest, box):\\n            queue = deque([curr])\\n            v = set()\\n            while queue:\\n                i, j = queue.popleft()\\n                if (i, j) == dest: \\n                    return True\\n                for x, y in get_neighbor(i, j):\\n                    if (x,y) not in v and (x,y) != box:\\n                        v.add((x,y))\\n                        queue.append((x,y))\\n            return False\\n\\n        q = deque([(box, person)])\\n        seen = set()\\n        seen.add(box + person)\\n        steps = 0\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                box, person = q.popleft()\\n                if box == target:\\n                    return steps\\n                for new_box, new_person in get_box_neighbor(*box):\\n                    if new_box + box not in seen and \\\\\\n                            check(person, new_person, box):\\n                        seen.add(new_box + box)\\n                        q.append((new_box, box))\\n            steps += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n\\n        def valid(x, y):\\n            return 0<=x<m and 0<=y<n and grid[x][y]!=\\'#\\'\\n        \\n        def get_neighbor(i, j):\\n            for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                x, y = i + dx, j + dy\\n                if valid(x, y):\\n                    yield x, y\\n        \\n        def get_box_neighbor(i, j):\\n            for dx,dy in [(-1,0),(0,-1)]:\\n                x, y = i + dx, j + dy\\n                px, py = i - dx, j - dy\\n                if valid(x, y) and valid(px, py):\\n                    yield (x, y), (px, py)\\n                    yield (px, py), (x, y)\\n\\n        def check(curr, dest, box):\\n            queue = deque([curr])\\n            v = set()\\n            while queue:\\n                i, j = queue.popleft()\\n                if (i, j) == dest: \\n                    return True\\n                for x, y in get_neighbor(i, j):\\n                    if (x,y) not in v and (x,y) != box:\\n                        v.add((x,y))\\n                        queue.append((x,y))\\n            return False\\n\\n        q = deque([(box, person)])\\n        seen = set()\\n        seen.add(box + person)\\n        steps = 0\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                box, person = q.popleft()\\n                if box == target:\\n                    return steps\\n                for new_box, new_person in get_box_neighbor(*box):\\n                    if new_box + box not in seen and \\\\\\n                            check(person, new_person, box):\\n                        seen.add(new_box + box)\\n                        q.append((new_box, box))\\n            steps += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629660,
                "title": "55-lines-challenge-me-possible-shortest-c-solution",
                "content": "Python is always my envy to be able to write short code.\\nAfter I picked up some more knolwedge about C++, I can also write some code comparable with python in terms of length.\\nIf you can help me make it shorter, I will highly apprecitate. \\n\\nActually, in terms of space cost, this solution is also competitive. But I am sure there are always lots of people can do much better than me.\\nSo I will be waiting for the comments from you.\\n```\\nRuntime: 84 ms, faster than 59.21% of C++ online submissions for Minimum Moves to Move a Box to Their Target Location.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Minimum Moves to Move a Box to Their Target Location.\\n```\\n\\n```\\nstruct Node{\\n    pair<int, int> b, p;\\n    int key() const {return  ( (b.first*20 + b.second) << 16 ) | (p.first*20 + p.second); };\\n};\\n\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {        \\n        const int m = grid.size(), n = grid[0].size();        \\n        Node start, end;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == \\'B\\') start.b = {i, j};\\n                else if(grid[i][j] == \\'S\\') start.p = {i, j};\\n                else if(grid[i][j] == \\'T\\') end.b = {i, j};            \\n                         \\n        auto hasPath = [&](const Node& cur, int p_i, int p_j){ // hasPath: can move behind box      \\n            int seen[400]={};                    \\n            function <bool(int, int)> dfs = [&](int i, int j){\\n                if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'#\\') return false;\\n                if(i== cur.b.first && j == cur.b.second ) return false;                \\n                if(seen[i*m+j]++) return false;                \\n                if(i== p_i && j == p_j ) return true;\\n                return dfs(i-1, j) || dfs(i+1, j) || dfs(i, j-1) || dfs(i, j+1);\\n            };\\n            \\n            return dfs(cur.p.first, cur.p.second);          \\n        };       \\n        //canMove is true means 2 things: front cell is valid & free; back cell is accessible from mover\\'s current position\\n        auto canMove= [&](const Node& cur, int delta_i, int delta_j, Node& nxt){                              \\n            int i = cur.b.first + delta_i, j = cur.b.second + delta_j;\\n            if(i < 0 || i >= m || j <0 || j >= n || grid[i][j] == \\'#\\') return false;            \\n            if(!hasPath(cur, cur.b.first - delta_i,  cur.b.second - delta_j) ) return false;\\n            nxt.b={i,j};\\n            nxt.p = cur.b;\\n            return true;           \\n        };        \\n        \\n        queue<Node> q{{start}};                \\n        unordered_set<int> seen{start.key()}; \\n        int dirs[5]={0, -1, 0, 1, 0};\\n        for(int step = 0; !q.empty(); ++step)\\n            for(int sz = q.size(); sz > 0; sz--){\\n                auto cur = q.front(); q.pop();\\n                Node nxt;\\n                for(int i = 0; i < 4; i++){                    \\n                    if(!canMove(cur, dirs[i], dirs[i+1], nxt) || seen.count(nxt.key()) ) continue;                    \\n                    if(nxt.b == end.b) return step+1;\\n                    seen.insert(nxt.key());\\n                    q.emplace(nxt);\\n                }\\n            }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime: 84 ms, faster than 59.21% of C++ online submissions for Minimum Moves to Move a Box to Their Target Location.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Minimum Moves to Move a Box to Their Target Location.\\n```\n```\\nstruct Node{\\n    pair<int, int> b, p;\\n    int key() const {return  ( (b.first*20 + b.second) << 16 ) | (p.first*20 + p.second); };\\n};\\n\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {        \\n        const int m = grid.size(), n = grid[0].size();        \\n        Node start, end;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == \\'B\\') start.b = {i, j};\\n                else if(grid[i][j] == \\'S\\') start.p = {i, j};\\n                else if(grid[i][j] == \\'T\\') end.b = {i, j};            \\n                         \\n        auto hasPath = [&](const Node& cur, int p_i, int p_j){ // hasPath: can move behind box      \\n            int seen[400]={};                    \\n            function <bool(int, int)> dfs = [&](int i, int j){\\n                if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'#\\') return false;\\n                if(i== cur.b.first && j == cur.b.second ) return false;                \\n                if(seen[i*m+j]++) return false;                \\n                if(i== p_i && j == p_j ) return true;\\n                return dfs(i-1, j) || dfs(i+1, j) || dfs(i, j-1) || dfs(i, j+1);\\n            };\\n            \\n            return dfs(cur.p.first, cur.p.second);          \\n        };       \\n        //canMove is true means 2 things: front cell is valid & free; back cell is accessible from mover\\'s current position\\n        auto canMove= [&](const Node& cur, int delta_i, int delta_j, Node& nxt){                              \\n            int i = cur.b.first + delta_i, j = cur.b.second + delta_j;\\n            if(i < 0 || i >= m || j <0 || j >= n || grid[i][j] == \\'#\\') return false;            \\n            if(!hasPath(cur, cur.b.first - delta_i,  cur.b.second - delta_j) ) return false;\\n            nxt.b={i,j};\\n            nxt.p = cur.b;\\n            return true;           \\n        };        \\n        \\n        queue<Node> q{{start}};                \\n        unordered_set<int> seen{start.key()}; \\n        int dirs[5]={0, -1, 0, 1, 0};\\n        for(int step = 0; !q.empty(); ++step)\\n            for(int sz = q.size(); sz > 0; sz--){\\n                auto cur = q.front(); q.pop();\\n                Node nxt;\\n                for(int i = 0; i < 4; i++){                    \\n                    if(!canMove(cur, dirs[i], dirs[i+1], nxt) || seen.count(nxt.key()) ) continue;                    \\n                    if(nxt.b == end.b) return step+1;\\n                    seen.insert(nxt.key());\\n                    q.emplace(nxt);\\n                }\\n            }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436075,
                "title": "java-bfs-dfs-with-explanation",
                "content": "The idea is using BFS find the shortest path from the box location to the destination.\\nHowever, each time we check if the box can be moved we need to check 2 position\\n![image](https://assets.leetcode.com/users/lnbyk/image_1574563041.png)\\n\\nThe Box is just the box and the cycle is the position we need check\\nWhen we want to move box to left we need check if the position both the cell at the left of the box and right of the box is ok. And we need to do the same thing for four directions.\\n\\nDFS:\\n\\tThe reason use DFS is to check if the person can move to the position where he can move the box.\\n\\tSuch as below \\n\\t![image](https://assets.leetcode.com/users/lnbyk/image_1574563377.png)\\n\\tThe green arrow is just the one of the path we need to check if person can move.\\n\\n\\n```\\nclass Solution {\\n    private class Sugarcane{\\n        int box;\\n        int person;\\n        public Sugarcane(int box, int person){\\n            this.box = box;\\n            this.person = person;\\n        }\\n        public String toString(){\\n            return this.box + \" \" + this.person;\\n        }\\n    }\\n    \\n    Set<Integer> set = new HashSet<>();\\n    int[] dir = {0, 1, 0, -1, 0};\\n    int m, n;\\n    public int minPushBox(char[][] grid) {\\n        int res = -1;\\n        m = grid.length; n = grid[0].length;\\n        int d = 0, p = 0;\\n        Queue<Sugarcane> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    d = i * n + j;\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    p = i * n + j; \\n                }\\n            }\\n        }\\n        Sugarcane sugarcane = new Sugarcane(d, p);\\n        queue.offer(sugarcane);\\n        visited.add(sugarcane.toString());\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            res++;\\n            for(int i = 0; i < size; i++){\\n                Sugarcane sugar = queue.poll();\\n                int bp = sugar.box, pp = sugar.person;\\n                int x = bp / n, y = bp % n;\\n                if(grid[x][y] == \\'T\\')\\n                    return res;\\n                \\n                grid[x][y] = \\'#\\';\\n                for(int j = 0; j < 4; j++){\\n                    int bx = x + dir[j], by = y + dir[j + 1];\\n                    int px = x - dir[j], py = y - dir[j + 1];\\n                    Sugarcane nextSugar = new Sugarcane(bx * n + by, px * n + py);\\n                    String nV = nextSugar.toString();\\n                    set = new HashSet<>();\\n                    if(isVaild(bx, by, grid) && !visited.contains(nV) && dfs(pp / n, pp % n, grid, px, py)){\\n                        queue.offer(nextSugar);\\n                        visited.add(nV);\\n                    }\\n                }\\n                grid[x][y] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public boolean isVaild(int x, int y, char[][] grid){\\n        return x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != \\'#\\';\\n    }\\n    \\n    public boolean dfs(int x, int y, char[][] grid, int dx, int dy){\\n        if(x == dx && y == dy)\\n            return true;\\n        for(int i = 0; i < 4; i++){\\n            int nx = x + dir[i], ny = y + dir[i + 1];\\n            if(isVaild(nx, ny, grid) && set.add(nx * n + ny))\\n                if(dfs(nx, ny, grid, dx, dy))\\n                    return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Sugarcane{\\n        int box;\\n        int person;\\n        public Sugarcane(int box, int person){\\n            this.box = box;\\n            this.person = person;\\n        }\\n        public String toString(){\\n            return this.box + \" \" + this.person;\\n        }\\n    }\\n    \\n    Set<Integer> set = new HashSet<>();\\n    int[] dir = {0, 1, 0, -1, 0};\\n    int m, n;\\n    public int minPushBox(char[][] grid) {\\n        int res = -1;\\n        m = grid.length; n = grid[0].length;\\n        int d = 0, p = 0;\\n        Queue<Sugarcane> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    d = i * n + j;\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    p = i * n + j; \\n                }\\n            }\\n        }\\n        Sugarcane sugarcane = new Sugarcane(d, p);\\n        queue.offer(sugarcane);\\n        visited.add(sugarcane.toString());\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            res++;\\n            for(int i = 0; i < size; i++){\\n                Sugarcane sugar = queue.poll();\\n                int bp = sugar.box, pp = sugar.person;\\n                int x = bp / n, y = bp % n;\\n                if(grid[x][y] == \\'T\\')\\n                    return res;\\n                \\n                grid[x][y] = \\'#\\';\\n                for(int j = 0; j < 4; j++){\\n                    int bx = x + dir[j], by = y + dir[j + 1];\\n                    int px = x - dir[j], py = y - dir[j + 1];\\n                    Sugarcane nextSugar = new Sugarcane(bx * n + by, px * n + py);\\n                    String nV = nextSugar.toString();\\n                    set = new HashSet<>();\\n                    if(isVaild(bx, by, grid) && !visited.contains(nV) && dfs(pp / n, pp % n, grid, px, py)){\\n                        queue.offer(nextSugar);\\n                        visited.add(nV);\\n                    }\\n                }\\n                grid[x][y] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public boolean isVaild(int x, int y, char[][] grid){\\n        return x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != \\'#\\';\\n    }\\n    \\n    public boolean dfs(int x, int y, char[][] grid, int dx, int dy){\\n        if(x == dx && y == dy)\\n            return true;\\n        for(int i = 0; i < 4; i++){\\n            int nx = x + dir[i], ny = y + dir[i + 1];\\n            if(isVaild(nx, ny, grid) && set.add(nx * n + ny))\\n                if(dfs(nx, ny, grid, dx, dy))\\n                    return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418446,
                "title": "jave-intuitive-bfs-solution",
                "content": "Two BFS. \\n1st BFS to push box as regular BFS. \\n*2nd BFS to check if the person can reach the box inside 1st BFS\\n\\nBFS to push box. For each positon of box, check if player can push it.\\nBox can be pushed only when it has two opposite adajacent grids are empty\\n\\t1. traverse the grid to find the location of player, box, target, and set their grid value to \\'.\\'\\n\\t2. Use 4d boolean array visited (boolean[box_x][box_y][player_x][player_y]) to record visited box\\n\\t3. In the BFS Queue, it is an array of box_x, box_y, player_x, player_y, step\\n\\t4. During BFS, check the 2 adajcent grids for the box in x and y direction. \\nIf both they are within grid and have \\'.\\', do second BFS to see if the player can reach the position \\n\\nTime complexity: O(n^2*m^2)\\nSpace complexity: O(n*m)\\nn, m is the grid width and length\\n\\n```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] box = {-1, -1};\\n        int[] player = {-1, -1};\\n        int[] target = {-1, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    player = new int[]{i, j};\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = new int[]{i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = new int[]{i, j};\\n                }\\n            }\\n        }\\n        grid[player[0]][player[1]] = \\'.\\';\\n        grid[box[0]][box[1]] = \\'.\\';\\n        grid[target[0]][target[1]] = \\'.\\';\\n        boolean[][][][] visited = new boolean[m][n][m][n];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{box[0], box[1], player[0], player[1], 0});\\n        visited[box[0]][box[1]][player[0]][player[1]] = true;\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            for (int i = 0; i < 4; i += 2) {\\n                int x1 = cur[0] + dirs[i][0];\\n                int y1 = cur[1] + dirs[i][1];\\n                int x2 = cur[0] + dirs[i + 1][0];\\n                int y2 = cur[1] + dirs[i + 1][1];\\n                if (inGrid(m, n, x1, y1, grid) && inGrid(m, n, x2, y2, grid)) {\\n                    if (!visited[x1][y1][x2][y2] && canReach(grid, cur[2], cur[3], x2, y2, new int[]{cur[0], cur[1]})) {\\n                        if (x1 == target[0] && y1 == target[1]) {\\n                            return cur[4] + 1;\\n                        }\\n                        visited[x1][y1][x2][y2] = true;\\n                        queue.offer(new int[]{x1, y1, x2, y2, cur[4] + 1});\\n                    }\\n                    if (!visited[x2][y2][x1][y1] && canReach(grid, cur[2], cur[3], x1, y1, new int[]{cur[0], cur[1]})) {\\n                        if (x2 == target[0] && y2 == target[1]) {\\n                            return cur[4] + 1;\\n                        }\\n                        visited[x2][y2][x1][y1] = true;\\n                        queue.offer(new int[]{x2, y2, x1, y1, cur[4] + 1});\\n                    }\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n    private boolean canReach(char[][]grid, int px, int py, int tx, int ty, int[] box) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        queue.offer(new int[]{px, py});\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            if (cur[0] == tx && cur[1] == ty) {\\n                return true;\\n            }\\n            for (int[] dir : dirs) {\\n                int x = cur[0] + dir[0];\\n                int y = cur[1] + dir[1];\\n                if (inGrid(m, n, x, y, grid) && !visited[x][y]) {\\n                    if (x == tx && y == ty) {\\n                        return true;\\n                    }\\n                    if (x == box[0] && y == box[1]) {\\n                        continue;\\n                    }\\n                    queue.offer(new int[]{x, y});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n    private boolean inGrid(int m, int n, int x, int y, char[][]grid) {\\n        return x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != \\'#\\'; // can be target\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] box = {-1, -1};\\n        int[] player = {-1, -1};\\n        int[] target = {-1, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    player = new int[]{i, j};\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = new int[]{i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = new int[]{i, j};\\n                }\\n            }\\n        }\\n        grid[player[0]][player[1]] = \\'.\\';\\n        grid[box[0]][box[1]] = \\'.\\';\\n        grid[target[0]][target[1]] = \\'.\\';\\n        boolean[][][][] visited = new boolean[m][n][m][n];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{box[0], box[1], player[0], player[1], 0});\\n        visited[box[0]][box[1]][player[0]][player[1]] = true;\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            for (int i = 0; i < 4; i += 2) {\\n                int x1 = cur[0] + dirs[i][0];\\n                int y1 = cur[1] + dirs[i][1];\\n                int x2 = cur[0] + dirs[i + 1][0];\\n                int y2 = cur[1] + dirs[i + 1][1];\\n                if (inGrid(m, n, x1, y1, grid) && inGrid(m, n, x2, y2, grid)) {\\n                    if (!visited[x1][y1][x2][y2] && canReach(grid, cur[2], cur[3], x2, y2, new int[]{cur[0], cur[1]})) {\\n                        if (x1 == target[0] && y1 == target[1]) {\\n                            return cur[4] + 1;\\n                        }\\n                        visited[x1][y1][x2][y2] = true;\\n                        queue.offer(new int[]{x1, y1, x2, y2, cur[4] + 1});\\n                    }\\n                    if (!visited[x2][y2][x1][y1] && canReach(grid, cur[2], cur[3], x1, y1, new int[]{cur[0], cur[1]})) {\\n                        if (x2 == target[0] && y2 == target[1]) {\\n                            return cur[4] + 1;\\n                        }\\n                        visited[x2][y2][x1][y1] = true;\\n                        queue.offer(new int[]{x2, y2, x1, y1, cur[4] + 1});\\n                    }\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n    private boolean canReach(char[][]grid, int px, int py, int tx, int ty, int[] box) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        queue.offer(new int[]{px, py});\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            if (cur[0] == tx && cur[1] == ty) {\\n                return true;\\n            }\\n            for (int[] dir : dirs) {\\n                int x = cur[0] + dir[0];\\n                int y = cur[1] + dir[1];\\n                if (inGrid(m, n, x, y, grid) && !visited[x][y]) {\\n                    if (x == tx && y == ty) {\\n                        return true;\\n                    }\\n                    if (x == box[0] && y == box[1]) {\\n                        continue;\\n                    }\\n                    queue.offer(new int[]{x, y});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n    private boolean inGrid(int m, int n, int x, int y, char[][]grid) {\\n        return x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != \\'#\\'; // can be target\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302782,
                "title": "java-bfs-bfs",
                "content": "```\\nclass Solution {\\n                                    // Up,    Right,   Bottom  & Left\\n    private int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    public int minPushBox(char[][] grid) {\\n        int step = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] box,target,player;\\n        box = target = player = null;\\n        \\n        // TO Store Already Processed Node.\\n        // Box coordinates with respect to Player\\'s Moves\\n        boolean[][][] visited = new boolean[m][n][4];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'B\\') box = new int[]{i, j};\\n                else if (grid[i][j] == \\'T\\') target = new int[]{i, j};\\n                else if (grid[i][j] == \\'S\\') player = new int[]{i, j};\\n            }\\n        }\\n        \\n        q.offer(new int[]{box[0], box[1], player[0], player[1]});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            // Process Each Level Nodes of Queue\\n            while(size!=0) {\\n                int[] curr = q.poll();\\n                // Box reached Target Location Return steps...\\n                if (curr[0] == target[0] && curr[1] == target[1]) \\n                    return step;\\n                // Explore 4 directions at this point ...\\n                for (int j = 0; j < dir.length; j++) {\\n                    \\n                    if (visited[curr[0]][curr[1]][j]) \\n                        continue;\\n                    \\n                    int[] d = dir[j];\\n                    \\n                    int r0 = curr[0] + d[0];\\n                    int c0 = curr[1] + d[1];  \\n                    int r = curr[0] - d[0];\\n                    int c = curr[1] - d[1];\\n                    if (!isValid(r0,c0,grid) || !isValid(r,c,grid)) \\n                        continue;\\n                    if (!isReachable(r0, c0, curr, grid)) \\n                        continue;\\n                    \\n                    visited[curr[0]][curr[1]][j] = true;\\n                    q.offer(new int[]{r, c, curr[0], curr[1]});\\n                }\\n                size--;\\n            }\\n            step++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    // can player reach a position to push ?\\n    private boolean isReachable(int x, int y, int[] curr, char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int playerStartR = curr[2];\\n        int playerStartC = curr[3];\\n        q.offer(new int[]{playerStartR, playerStartC});\\n        boolean[][] visited = new boolean[m][n];\\n        // mark the box current position as visited // [0:1] ==> Box Pos\\n        visited[curr[0]][curr[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] temp = q.poll();\\n            if (temp[0] == x && temp[1] == y) \\n                return true;\\n            for (int[] d : dir) {\\n                int r = temp[0] + d[0];\\n                int c = temp[1] + d[1];  \\n                if (!isValid(r,c,grid) || visited[r][c]) \\n                    continue;\\n                visited[r][c] = true;\\n                q.offer(new int[]{r, c});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isValid(int x, int y,char[][] grid){\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        return x>=0 && x<r && y>=0 && y<c && grid[x][y] != \\'#\\';\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n                                    // Up,    Right,   Bottom  & Left\\n    private int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    public int minPushBox(char[][] grid) {\\n        int step = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] box,target,player;\\n        box = target = player = null;\\n        \\n        // TO Store Already Processed Node.\\n        // Box coordinates with respect to Player\\'s Moves\\n        boolean[][][] visited = new boolean[m][n][4];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'B\\') box = new int[]{i, j};\\n                else if (grid[i][j] == \\'T\\') target = new int[]{i, j};\\n                else if (grid[i][j] == \\'S\\') player = new int[]{i, j};\\n            }\\n        }\\n        \\n        q.offer(new int[]{box[0], box[1], player[0], player[1]});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            // Process Each Level Nodes of Queue\\n            while(size!=0) {\\n                int[] curr = q.poll();\\n                // Box reached Target Location Return steps...\\n                if (curr[0] == target[0] && curr[1] == target[1]) \\n                    return step;\\n                // Explore 4 directions at this point ...\\n                for (int j = 0; j < dir.length; j++) {\\n                    \\n                    if (visited[curr[0]][curr[1]][j]) \\n                        continue;\\n                    \\n                    int[] d = dir[j];\\n                    \\n                    int r0 = curr[0] + d[0];\\n                    int c0 = curr[1] + d[1];  \\n                    int r = curr[0] - d[0];\\n                    int c = curr[1] - d[1];\\n                    if (!isValid(r0,c0,grid) || !isValid(r,c,grid)) \\n                        continue;\\n                    if (!isReachable(r0, c0, curr, grid)) \\n                        continue;\\n                    \\n                    visited[curr[0]][curr[1]][j] = true;\\n                    q.offer(new int[]{r, c, curr[0], curr[1]});\\n                }\\n                size--;\\n            }\\n            step++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    // can player reach a position to push ?\\n    private boolean isReachable(int x, int y, int[] curr, char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int playerStartR = curr[2];\\n        int playerStartC = curr[3];\\n        q.offer(new int[]{playerStartR, playerStartC});\\n        boolean[][] visited = new boolean[m][n];\\n        // mark the box current position as visited // [0:1] ==> Box Pos\\n        visited[curr[0]][curr[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] temp = q.poll();\\n            if (temp[0] == x && temp[1] == y) \\n                return true;\\n            for (int[] d : dir) {\\n                int r = temp[0] + d[0];\\n                int c = temp[1] + d[1];  \\n                if (!isValid(r,c,grid) || visited[r][c]) \\n                    continue;\\n                visited[r][c] = true;\\n                q.offer(new int[]{r, c});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isValid(int x, int y,char[][] grid){\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        return x>=0 && x<r && y>=0 && y<c && grid[x][y] != \\'#\\';\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270946,
                "title": "java-deque-bfs",
                "content": "```\\nclass Solution {\\n    /**\\n     \\u8FD9\\u4E2A\\u9898\\u76EE\\u4E0D\\u540C\\u4E8E\\u4EE5\\u524D\\u7684bfs, \\u56E0\\u4E3A\\u4EBA\\u8981\\u63A8\\u7740\\u7BB1\\u5B50\\u8D70\\uFF0C\\u6240\\u6709\\u4EBA\\u548C\\u7BB1\\u5B50\\u7684\\u5750\\u6807\\u8054\\u5408\\u8D77\\u6765\\u4F5C\\u4E3Abfs\\u7684\\u5750\\u6807\\n     [bx][by][px][py]\\n\\n     \\u884D\\u751F\\u51FA\\u6765\\u7684\\u4E0B\\u4E00\\u4E2A\\u72B6\\u6001\\u5E94\\u8BE5\\u6709:\\n     1 \\u4EBA\\u52A8\\uFF0C\\u7BB1\\u5B50\\u4E0D\\u52A8\\uFF0C\\u6B64\\u65F6\\u63A8\\u52A8\\u7BB1\\u5B50\\u7684\\u6B21\\u6570\\u4E0D\\u53D8\\n     [bx][by][px-1][py] , [bx][by][px+1][py] , [bx][by][px][py-1] , [bx][by][px][py+1]\\n\\n     2 \\u4EBA\\u548C\\u7BB1\\u5B50\\u4E00\\u8D77\\u52A8\\uFF0C\\u6B64\\u65F6\\u63A8\\u52A8\\u7BB1\\u5B50\\u7684\\u6B21\\u6570\\u52A01\\n     [bx-1][by][px-1][py] , [bx+1][by][px+1][py] , [bx][by-1][px][py-1] , [bx][by+1][px][py+1]\\n\\n     \\u5BF9\\u4E8E\\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u8FDB\\u884Cbfs\\u904D\\u5386\\u7684\\u65F6\\u5019\\uFF0C\\u9700\\u8981\\u52A0\\u5165\\u961F\\u5217\\u7684\\u5934\\u90E8\\n\\n     \\u5BF9\\u4E8E\\u7B2C\\u4E8C\\u79CD\\u60C5\\u51B5\\uFF0C\\u8FDB\\u884Cbfs\\u904D\\u5386\\u7684\\u65F6\\u5019\\uFF0C\\u9700\\u8981\\u52A0\\u5165\\u961F\\u5217\\u7684\\u5C3E\\u90E8\\n     */\\n    int[][] dir ={{-1,0},{1,0},{0,1},{0,-1}};\\n    public int minPushBox(char[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int bx=-1, by=-1, px=-1, py=0, tx=-1, ty=-1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==\\'B\\'){\\n                    bx=i;\\n                    by=j;\\n                }\\n                if(grid[i][j]==\\'T\\'){\\n                    tx=i;\\n                    ty=j;\\n                }\\n                if(grid[i][j]==\\'S\\'){\\n                    px=i;\\n                    py=j;\\n                }\\n            }\\n        }\\n\\n        //\\u8BB0\\u5F55\\u79FB\\u52A8\\u5230\\u5F53\\u524D\\u72B6\\u6001\\u9700\\u8981\\u63A8\\u52A8\\u76D2\\u5B50\\u7684\\u6B65\\u9AA4\\n        int[][][][] memo = new int[m][n][m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                for(int k=0; k<m; k++){\\n                    Arrays.fill(memo[i][j][k], -1);\\n                }\\n            }\\n        }\\n        memo[bx][by][px][py] = 0;\\n\\n        //\\u53CC\\u7AEF\\u961F\\u5217\\u505ABFS\\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{bx, by, px, py});\\n\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            //\\u63A8\\u5230\\u4E86\\u6700\\u7EC8\\u4F4D\\u7F6E\\n            if(cur[0]==tx && cur[1]==ty){\\n                return memo[cur[0]][cur[1]][cur[2]][cur[3]];\\n            }\\n\\n            //\\u4EBA\\u5728\\u52A8\\uFF0C\\u76D2\\u5B50\\u4E0D\\u52A8\\u7684\\u60C5\\u51B5\\uFF0C\\u63A8\\u52A8\\u6B21\\u6570\\u4E0D\\u53D8\\uFF0C\\u5C06\\u65B0\\u7684\\u5750\\u6807\\u52A0\\u5165\\u52A0\\u5165\\u961F\\u9996\\n            for(int k=0; k<dir.length; k++){\\n                int npx = cur[2] + dir[k][0], npy = cur[3] + dir[k][1];\\n                if(npx<0 || npx>=m || npy<0 || npy>=n) continue; //\\u8D8A\\u754C\\n                if(grid[npx][npy]==\\'#\\') continue; //\\u649E\\u5899\\n                if(npx==cur[0] && npy==cur[1]) continue; //\\u4E0E\\u76D2\\u5B50\\u91CD\\u5408\\n                if(memo[cur[0]][cur[1]][npx][npy] >= 0) continue; //\\u5DF2\\u7ECF\\u8BBF\\u95EE\\u8FC7\\u4E86\\n                queue.addFirst(new int[]{cur[0], cur[1], npx,  npy});\\n                memo[cur[0]][cur[1]][npx][npy] = memo[cur[0]][cur[1]][cur[2]][cur[3]]; //\\u63A8\\u52A8\\u6B21\\u6570\\u4E0D\\u53D8\\n            }\\n\\n            //\\u4EBA\\u63A8\\u52A8\\u7BB1\\u5B50\\uFF0C\\u8981\\u6C42\\uFF1A1 \\u4EFB\\u4F55\\u7BB1\\u5B50\\u76F8\\u90BB 2 \\u63A8\\u52A8\\u7684\\u65B9\\u5411\\u4E0D\\u662F\\u5899\\n            if(Math.abs(cur[0]-cur[2]) + Math.abs(cur[1]-cur[3])==1){ //\\u76F8\\u90BB\\n                //\\u627E\\u5230\\u63A8\\u52A8\\u7684\\u65B9\\u5411,\\u4EBA\\u6309\\u7167\\u67D0\\u4E2A\\u65B9\\u5411\\u79FB\\u52A8\\u4E4B\\u540E\\uFF0C\\u5C31\\u662Fbox,\\u5219\\u5F53\\u524D\\u65B9\\u5411\\u5C31\\u662F\\u8981\\u627E\\u7684\\u65B9\\u5411\\n                for(int k=0; k<dir.length; k++){\\n                    int npx = cur[2] + dir[k][0], npy = cur[3] + dir[k][1];\\n                    if(npx==cur[0] && npy==cur[1]){ //\\u5F53\\u524Dk\\u6307\\u5411\\u7684\\u65B9\\u5411\\u5C31\\u662F\\u8981\\u627E\\u7684\\u65B9\\u5411\\n                        //\\u5224\\u65ADbox\\u662F\\u5426\\u80FD\\u671D\\u8FD9\\u4E2A\\u65B9\\u5411\\u79FB\\u52A8\\n                        int nbx = cur[0] + dir[k][0], nby = cur[1] + dir[k][1];\\n                        if(nbx<0 || nbx>=m || nby<0 || nby>=n) continue;\\n                        if(grid[nbx][nby] == \\'#\\') continue;//\\u5899\\n                        if(memo[nbx][nby][cur[2]][cur[3]] >= 0) continue; //\\u5DF2\\u7ECF\\u8BBF\\u95EE\\u8FC7\\u4E86\\n                        queue.addLast(new int[]{nbx, nby, cur[2],  cur[3]});\\n                        memo[nbx][nby][cur[2]][cur[3]] = memo[cur[0]][cur[1]][cur[2]][cur[3]]+1; //\\u63A8\\u52A8\\u6B21\\u6570\\u52A0\\u4E00\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     \\u8FD9\\u4E2A\\u9898\\u76EE\\u4E0D\\u540C\\u4E8E\\u4EE5\\u524D\\u7684bfs, \\u56E0\\u4E3A\\u4EBA\\u8981\\u63A8\\u7740\\u7BB1\\u5B50\\u8D70\\uFF0C\\u6240\\u6709\\u4EBA\\u548C\\u7BB1\\u5B50\\u7684\\u5750\\u6807\\u8054\\u5408\\u8D77\\u6765\\u4F5C\\u4E3Abfs\\u7684\\u5750\\u6807\\n     [bx][by][px][py]\\n\\n     \\u884D\\u751F\\u51FA\\u6765\\u7684\\u4E0B\\u4E00\\u4E2A\\u72B6\\u6001\\u5E94\\u8BE5\\u6709:\\n     1 \\u4EBA\\u52A8\\uFF0C\\u7BB1\\u5B50\\u4E0D\\u52A8\\uFF0C\\u6B64\\u65F6\\u63A8\\u52A8\\u7BB1\\u5B50\\u7684\\u6B21\\u6570\\u4E0D\\u53D8\\n     [bx][by][px-1][py] , [bx][by][px+1][py] , [bx][by][px][py-1] , [bx][by][px][py+1]\\n\\n     2 \\u4EBA\\u548C\\u7BB1\\u5B50\\u4E00\\u8D77\\u52A8\\uFF0C\\u6B64\\u65F6\\u63A8\\u52A8\\u7BB1\\u5B50\\u7684\\u6B21\\u6570\\u52A01\\n     [bx-1][by][px-1][py] , [bx+1][by][px+1][py] , [bx][by-1][px][py-1] , [bx][by+1][px][py+1]\\n\\n     \\u5BF9\\u4E8E\\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u8FDB\\u884Cbfs\\u904D\\u5386\\u7684\\u65F6\\u5019\\uFF0C\\u9700\\u8981\\u52A0\\u5165\\u961F\\u5217\\u7684\\u5934\\u90E8\\n\\n     \\u5BF9\\u4E8E\\u7B2C\\u4E8C\\u79CD\\u60C5\\u51B5\\uFF0C\\u8FDB\\u884Cbfs\\u904D\\u5386\\u7684\\u65F6\\u5019\\uFF0C\\u9700\\u8981\\u52A0\\u5165\\u961F\\u5217\\u7684\\u5C3E\\u90E8\\n     */\\n    int[][] dir ={{-1,0},{1,0},{0,1},{0,-1}};\\n    public int minPushBox(char[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int bx=-1, by=-1, px=-1, py=0, tx=-1, ty=-1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==\\'B\\'){\\n                    bx=i;\\n                    by=j;\\n                }\\n                if(grid[i][j]==\\'T\\'){\\n                    tx=i;\\n                    ty=j;\\n                }\\n                if(grid[i][j]==\\'S\\'){\\n                    px=i;\\n                    py=j;\\n                }\\n            }\\n        }\\n\\n        //\\u8BB0\\u5F55\\u79FB\\u52A8\\u5230\\u5F53\\u524D\\u72B6\\u6001\\u9700\\u8981\\u63A8\\u52A8\\u76D2\\u5B50\\u7684\\u6B65\\u9AA4\\n        int[][][][] memo = new int[m][n][m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                for(int k=0; k<m; k++){\\n                    Arrays.fill(memo[i][j][k], -1);\\n                }\\n            }\\n        }\\n        memo[bx][by][px][py] = 0;\\n\\n        //\\u53CC\\u7AEF\\u961F\\u5217\\u505ABFS\\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{bx, by, px, py});\\n\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            //\\u63A8\\u5230\\u4E86\\u6700\\u7EC8\\u4F4D\\u7F6E\\n            if(cur[0]==tx && cur[1]==ty){\\n                return memo[cur[0]][cur[1]][cur[2]][cur[3]];\\n            }\\n\\n            //\\u4EBA\\u5728\\u52A8\\uFF0C\\u76D2\\u5B50\\u4E0D\\u52A8\\u7684\\u60C5\\u51B5\\uFF0C\\u63A8\\u52A8\\u6B21\\u6570\\u4E0D\\u53D8\\uFF0C\\u5C06\\u65B0\\u7684\\u5750\\u6807\\u52A0\\u5165\\u52A0\\u5165\\u961F\\u9996\\n            for(int k=0; k<dir.length; k++){\\n                int npx = cur[2] + dir[k][0], npy = cur[3] + dir[k][1];\\n                if(npx<0 || npx>=m || npy<0 || npy>=n) continue; //\\u8D8A\\u754C\\n                if(grid[npx][npy]==\\'#\\') continue; //\\u649E\\u5899\\n                if(npx==cur[0] && npy==cur[1]) continue; //\\u4E0E\\u76D2\\u5B50\\u91CD\\u5408\\n                if(memo[cur[0]][cur[1]][npx][npy] >= 0) continue; //\\u5DF2\\u7ECF\\u8BBF\\u95EE\\u8FC7\\u4E86\\n                queue.addFirst(new int[]{cur[0], cur[1], npx,  npy});\\n                memo[cur[0]][cur[1]][npx][npy] = memo[cur[0]][cur[1]][cur[2]][cur[3]]; //\\u63A8\\u52A8\\u6B21\\u6570\\u4E0D\\u53D8\\n            }\\n\\n            //\\u4EBA\\u63A8\\u52A8\\u7BB1\\u5B50\\uFF0C\\u8981\\u6C42\\uFF1A1 \\u4EFB\\u4F55\\u7BB1\\u5B50\\u76F8\\u90BB 2 \\u63A8\\u52A8\\u7684\\u65B9\\u5411\\u4E0D\\u662F\\u5899\\n            if(Math.abs(cur[0]-cur[2]) + Math.abs(cur[1]-cur[3])==1){ //\\u76F8\\u90BB\\n                //\\u627E\\u5230\\u63A8\\u52A8\\u7684\\u65B9\\u5411,\\u4EBA\\u6309\\u7167\\u67D0\\u4E2A\\u65B9\\u5411\\u79FB\\u52A8\\u4E4B\\u540E\\uFF0C\\u5C31\\u662Fbox,\\u5219\\u5F53\\u524D\\u65B9\\u5411\\u5C31\\u662F\\u8981\\u627E\\u7684\\u65B9\\u5411\\n                for(int k=0; k<dir.length; k++){\\n                    int npx = cur[2] + dir[k][0], npy = cur[3] + dir[k][1];\\n                    if(npx==cur[0] && npy==cur[1]){ //\\u5F53\\u524Dk\\u6307\\u5411\\u7684\\u65B9\\u5411\\u5C31\\u662F\\u8981\\u627E\\u7684\\u65B9\\u5411\\n                        //\\u5224\\u65ADbox\\u662F\\u5426\\u80FD\\u671D\\u8FD9\\u4E2A\\u65B9\\u5411\\u79FB\\u52A8\\n                        int nbx = cur[0] + dir[k][0], nby = cur[1] + dir[k][1];\\n                        if(nbx<0 || nbx>=m || nby<0 || nby>=n) continue;\\n                        if(grid[nbx][nby] == \\'#\\') continue;//\\u5899\\n                        if(memo[nbx][nby][cur[2]][cur[3]] >= 0) continue; //\\u5DF2\\u7ECF\\u8BBF\\u95EE\\u8FC7\\u4E86\\n                        queue.addLast(new int[]{nbx, nby, cur[2],  cur[3]});\\n                        memo[nbx][nby][cur[2]][cur[3]] = memo[cur[0]][cur[1]][cur[2]][cur[3]]+1; //\\u63A8\\u52A8\\u6B21\\u6570\\u52A0\\u4E00\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265160,
                "title": "simple-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    /**\\n    \\n      1. Find the start , box and target cordinate .\\n      \\n      2. Then using Start Cordinate start BFS . Create Normal Visted set \\n      \\n      3. There will be  3 Possibilities :\\n          \\n           3.1 You find the Target , return whateevr No of Moves you have done till now .\\n           3.2 You find the Box , increase the Moves by 1, distance + moves +1  .\\n           3.2 You dont find Box , so move On without increasing Moves \\n           \\n           \\n   NOTE : Use PriotityQueue to sort Next value by Distance to get MIN diustnace         \\n    \\n    **/\\n    \\n    \\n    \\n    private static final int [][] DIRS = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    public int minPushBox(char[][] grid) {\\n        \\n        // STEP-1 Find the start , Box and Target Cordinate \\n        \\n        int start [] = new int[2];\\n        int box [] = new int[2];\\n        int target[] = new int[2];\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean startFound = false; \\n        boolean boxFound = false;\\n        boolean targetFound = false;\\n        boolean found =false;\\n        \\n        for( int row =0; row < rows ; row++){\\n            for( int col =0; col< cols ; col++){\\n                 char curValue = grid[row][col];\\n                 switch(curValue){\\n                     case \\'S\\':\\n                       startFound=true;\\n                        start[0] = row;\\n                        start[1] = col; \\n                      break;\\n                     case \\'B\\' :\\n                        boxFound = true;\\n                        box[0] = row;\\n                        box[1] = col;  \\n                       break;\\n                     case \\'T\\':\\n                        targetFound = true; \\n                        target[0] = row;\\n                        target[1] = col;\\n                        break;\\n                 }\\n                if(startFound && boxFound && targetFound){\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if( found){\\n                break;\\n            }\\n        }\\n        \\n       // STEP-2 STart BFS starting from start Cordinate\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((pq1,pq2)->new Integer(pq1[0]).compareTo(pq2[0]));\\n        pq.offer(new int[]{dist(box[0],box[1], target[0],target[1]) + 0,\\n                           0 ,\\n                          start[0],\\n                          start[1], \\n                          box[0],\\n                          box[1]});\\n        \\n        Set<String> visited = new HashSet<>();\\n        while(!pq.isEmpty()){\\n            int size = pq.size();\\n            for( int i=0; i < size ; i++){\\n                int [] node = pq.poll();\\n                int dist = node[0];\\n                int moves = node[1];\\n                int row = node[2];\\n                int col = node[3];\\n                int bxX = node[4];\\n                int bxY = node[5];\\n                \\n                // if box equals to target return \\n                if(bxX == target[0] && bxY== target[1]){\\n                    return moves;\\n                }\\n                String key = row + \"-\" + col +\"-\"+ bxX +\"-\"+ bxY;\\n                if(visited.contains(key)){\\n                    continue;\\n                }\\n                visited.add(key);\\n                // EXplore \\n                for(int dir []: DIRS){\\n                    int nRow = row + dir[0];\\n                    int nCol = col + dir[1];\\n                    if(!isValid(nRow,nCol, rows, cols, grid)){\\n                        continue;\\n                    }\\n                    // if its equal to Box \\n                    if(bxX == nRow &&  bxY == nCol) {\\n                        int nBxX = nRow + dir[0];\\n                        int nBxY = nCol + dir[1];\\n                        if(!isValid(nBxX,nBxY, rows, cols, grid)){\\n                            continue;\\n                        }\\n                      pq.offer( new int[]{dist(nBxX,nBxY,target[0],target[1]) + moves + 1 , moves +1 , nRow,nCol,nBxX,nBxY} );\\n                    }else {\\n                        // If the new cordinate not equal to Box \\n                        pq.offer( new int[]{dist,moves,nRow,nCol,bxX, bxY} );\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    private boolean isValid(int row , int col , int rows , int cols, char grid[][]){\\n        if(row < 0 || row > rows-1 || col < 0 || col > cols-1 || grid [row][col] == \\'#\\'){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int dist(int x, int y, int tx, int ty){\\n        return Math.abs(x-tx)+Math.abs(y-ty);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n    \\n      1. Find the start , box and target cordinate .\\n      \\n      2. Then using Start Cordinate start BFS . Create Normal Visted set \\n      \\n      3. There will be  3 Possibilities :\\n          \\n           3.1 You find the Target , return whateevr No of Moves you have done till now .\\n           3.2 You find the Box , increase the Moves by 1, distance + moves +1  .\\n           3.2 You dont find Box , so move On without increasing Moves \\n           \\n           \\n   NOTE : Use PriotityQueue to sort Next value by Distance to get MIN diustnace         \\n    \\n    **/\\n    \\n    \\n    \\n    private static final int [][] DIRS = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    public int minPushBox(char[][] grid) {\\n        \\n        // STEP-1 Find the start , Box and Target Cordinate \\n        \\n        int start [] = new int[2];\\n        int box [] = new int[2];\\n        int target[] = new int[2];\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean startFound = false; \\n        boolean boxFound = false;\\n        boolean targetFound = false;\\n        boolean found =false;\\n        \\n        for( int row =0; row < rows ; row++){\\n            for( int col =0; col< cols ; col++){\\n                 char curValue = grid[row][col];\\n                 switch(curValue){\\n                     case \\'S\\':\\n                       startFound=true;\\n                        start[0] = row;\\n                        start[1] = col; \\n                      break;\\n                     case \\'B\\' :\\n                        boxFound = true;\\n                        box[0] = row;\\n                        box[1] = col;  \\n                       break;\\n                     case \\'T\\':\\n                        targetFound = true; \\n                        target[0] = row;\\n                        target[1] = col;\\n                        break;\\n                 }\\n                if(startFound && boxFound && targetFound){\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if( found){\\n                break;\\n            }\\n        }\\n        \\n       // STEP-2 STart BFS starting from start Cordinate\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((pq1,pq2)->new Integer(pq1[0]).compareTo(pq2[0]));\\n        pq.offer(new int[]{dist(box[0],box[1], target[0],target[1]) + 0,\\n                           0 ,\\n                          start[0],\\n                          start[1], \\n                          box[0],\\n                          box[1]});\\n        \\n        Set<String> visited = new HashSet<>();\\n        while(!pq.isEmpty()){\\n            int size = pq.size();\\n            for( int i=0; i < size ; i++){\\n                int [] node = pq.poll();\\n                int dist = node[0];\\n                int moves = node[1];\\n                int row = node[2];\\n                int col = node[3];\\n                int bxX = node[4];\\n                int bxY = node[5];\\n                \\n                // if box equals to target return \\n                if(bxX == target[0] && bxY== target[1]){\\n                    return moves;\\n                }\\n                String key = row + \"-\" + col +\"-\"+ bxX +\"-\"+ bxY;\\n                if(visited.contains(key)){\\n                    continue;\\n                }\\n                visited.add(key);\\n                // EXplore \\n                for(int dir []: DIRS){\\n                    int nRow = row + dir[0];\\n                    int nCol = col + dir[1];\\n                    if(!isValid(nRow,nCol, rows, cols, grid)){\\n                        continue;\\n                    }\\n                    // if its equal to Box \\n                    if(bxX == nRow &&  bxY == nCol) {\\n                        int nBxX = nRow + dir[0];\\n                        int nBxY = nCol + dir[1];\\n                        if(!isValid(nBxX,nBxY, rows, cols, grid)){\\n                            continue;\\n                        }\\n                      pq.offer( new int[]{dist(nBxX,nBxY,target[0],target[1]) + moves + 1 , moves +1 , nRow,nCol,nBxX,nBxY} );\\n                    }else {\\n                        // If the new cordinate not equal to Box \\n                        pq.offer( new int[]{dist,moves,nRow,nCol,bxX, bxY} );\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    private boolean isValid(int row , int col , int rows , int cols, char grid[][]){\\n        if(row < 0 || row > rows-1 || col < 0 || col > cols-1 || grid [row][col] == \\'#\\'){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int dist(int x, int y, int tx, int ty){\\n        return Math.abs(x-tx)+Math.abs(y-ty);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526522,
                "title": "python-0-1-bfs-with-comments-and-explanation",
                "content": "- Each node in our graph will contain state of box, person and the minimum cost to reach it.\\n- We do a 0-1 BFS where 0 is the cost between vertices where a person can reach without having to move the box, and 1 is the cost between vertices where box moved.\\n- For more explanation on 0-1 BFS, watch [this video](https://www.youtube.com/watch?v=2RDQVW7RspM), or read [this article](https://cp-algorithms.com/graph/01_bfs.html)\\n- By nature of BFS we reach the target with minimum cost path first, or we return not possible.\\n- Time complexity is `O(M*N*M*N)` as we go through all the vertices in the worst case.\\n\\n```Python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        is_valid = lambda x, y: 0 <= x < m and 0 <= y < n and grid[x][y] != \\'#\\'\\n        reached = lambda x, y: (x, y) == target\\n\\t\\t# we use these to move to the neighboring states\\n        dist_row, dist_col = [0, 0, 1, -1], [1, -1, 0, 0]\\n\\n        def get_neighbors(state):\\n            bx, by, mx, my = state\\n            new_states = []\\n            \\n            # generate all possible states you can move to\\n            for i in range(4):\\n                X, Y = mx + dist_row[i], my + dist_col[i]\\n                # ignore out of bounds and walls\\n                if not is_valid(X, Y): continue\\n                if (X, Y) == (bx, by):\\n                    if is_valid(bx + dist_row[i], by + dist_col[i]):\\n                        # move box if current person state is neighbor of box and valid move exists\\n                        # the cost for move in this case would be 1\\n                        new_states.append((bx + dist_row[i], by + dist_col[i], X, Y, 1))\\n                else:\\n                    # move the person keeping box intact. Cost will be 0.\\n                    new_states.append((bx, by, X, Y, 0))\\n            return new_states\\n\\n        # go through the grid and take a note of starting positions of box, man and target\\n        for r, row in enumerate(grid):\\n            for c, col in enumerate(row):\\n                if grid[r][c] == \\'S\\':\\n                    start = (r, c)\\n                elif grid[r][c] == \\'B\\':\\n                    box_start = (r, c)\\n                elif grid[r][c] == \\'T\\':\\n                    target = (r, c)\\n\\n        # each node of our graph will contain (box_row, box_column, man_row, man_column, cost_so_far)\\n        start_state = (*box_start, *start, 0)\\n\\n        # we can use double ended queue for 0/1 BFS. Append to left if distance is 0, else to the right.\\n        queue = collections.deque([start_state])\\n\\n        # keep note of already visited (box_row, box_col, man_row, man_col) positions.\\n        # By nature of BFS, we visit them with lower cost path first,\\n        # so we can ignore if they appear again on our path as cost would be higher.\\n        visited = set()\\n        while queue:\\n            current = queue.popleft()\\n            bx, by, mx, my, d = current\\n            visited.add((bx, by, mx, my))\\n            if reached(bx, by): return d  # reached target return the distance\\n            for nb_details in get_neighbors((bx, by, mx, my)):\\n                *neigh, dist = nb_details\\n                if tuple(neigh) not in visited:\\n                    if dist:\\n                        queue.append((*neigh, dist + d))  # edge of weight 1\\n                    else:\\n                        queue.appendleft((*neigh, dist + d))  # edge of weight 0\\n\\n        # target can\\'t be reached\\n        return -1\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        is_valid = lambda x, y: 0 <= x < m and 0 <= y < n and grid[x][y] != \\'#\\'\\n        reached = lambda x, y: (x, y) == target\\n\\t\\t# we use these to move to the neighboring states\\n        dist_row, dist_col = [0, 0, 1, -1], [1, -1, 0, 0]\\n\\n        def get_neighbors(state):\\n            bx, by, mx, my = state\\n            new_states = []\\n            \\n            # generate all possible states you can move to\\n            for i in range(4):\\n                X, Y = mx + dist_row[i], my + dist_col[i]\\n                # ignore out of bounds and walls\\n                if not is_valid(X, Y): continue\\n                if (X, Y) == (bx, by):\\n                    if is_valid(bx + dist_row[i], by + dist_col[i]):\\n                        # move box if current person state is neighbor of box and valid move exists\\n                        # the cost for move in this case would be 1\\n                        new_states.append((bx + dist_row[i], by + dist_col[i], X, Y, 1))\\n                else:\\n                    # move the person keeping box intact. Cost will be 0.\\n                    new_states.append((bx, by, X, Y, 0))\\n            return new_states\\n\\n        # go through the grid and take a note of starting positions of box, man and target\\n        for r, row in enumerate(grid):\\n            for c, col in enumerate(row):\\n                if grid[r][c] == \\'S\\':\\n                    start = (r, c)\\n                elif grid[r][c] == \\'B\\':\\n                    box_start = (r, c)\\n                elif grid[r][c] == \\'T\\':\\n                    target = (r, c)\\n\\n        # each node of our graph will contain (box_row, box_column, man_row, man_column, cost_so_far)\\n        start_state = (*box_start, *start, 0)\\n\\n        # we can use double ended queue for 0/1 BFS. Append to left if distance is 0, else to the right.\\n        queue = collections.deque([start_state])\\n\\n        # keep note of already visited (box_row, box_col, man_row, man_col) positions.\\n        # By nature of BFS, we visit them with lower cost path first,\\n        # so we can ignore if they appear again on our path as cost would be higher.\\n        visited = set()\\n        while queue:\\n            current = queue.popleft()\\n            bx, by, mx, my, d = current\\n            visited.add((bx, by, mx, my))\\n            if reached(bx, by): return d  # reached target return the distance\\n            for nb_details in get_neighbors((bx, by, mx, my)):\\n                *neigh, dist = nb_details\\n                if tuple(neigh) not in visited:\\n                    if dist:\\n                        queue.append((*neigh, dist + d))  # edge of weight 1\\n                    else:\\n                        queue.appendleft((*neigh, dist + d))  # edge of weight 0\\n\\n        # target can\\'t be reached\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433647,
                "title": "python-bfs-code-with-explanation",
                "content": "To push a box, we need two steps\\n- Check whether we could go to the neighbor cell of the box. Also the opposite side of this neighbor cell should be empty. Otherwise there is no point moving there.\\n\\t- E.g. `.B.` has two neighbor cells which we could check whether we could move there\\n\\t- `#B.` won\\'t be checked. Although there is an empty cell, however there is wall on the other side of the box. Even if the player could move there, he couldn\\'t push the box\\n- Push the box by one step. Here, our player is moved to the place where the original box is.\\n\\nIn the above two steps, we both use breadth first search to implement.\\n\\n```\\ndef minPushBox(self, grid):\\n\\tplayer = None\\n\\tbox = None\\n\\ttarget = None\\n\\n\\tn = len(grid)\\n\\tif n == 0:\\n\\t\\treturn -1\\n\\tm = len(grid[0])\\n\\tif m == 0:\\n\\t\\treturn -1\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif grid[i][j] == \\'S\\':\\n\\t\\t\\t\\tplayer = (i, j)\\n\\t\\t\\tif grid[i][j] == \\'T\\':\\n\\t\\t\\t\\ttarget = (i, j)\\n\\t\\t\\tif grid[i][j] == \\'B\\':\\n\\t\\t\\t\\tbox = (i, j)\\n\\t\\t\\tif player != None and target != None and box != None:\\n\\t\\t\\t\\tbreak\\n\\t\\tif player != None and target != None and box != None:\\n\\t\\t\\tbreak\\n\\n\\tqueue = [(box, target, player, 0)]\\n\\tvisited = set([(box, player)])\\n\\twhile len(queue) > 0:\\n\\t\\tbox, target, player, steps = queue.pop()\\n\\t\\tif target == box:\\n\\t\\t\\treturn steps\\n\\t\\ti, j = box\\n\\t\\tif i > 0 and i < (n-1) and grid[i-1][j] != \\'#\\' and grid[i+1][j] != \\'#\\':\\n\\t\\t\\tif ((i+1, j), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i-1, j), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i+1, j), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i+1, j), (i, j)))\\n\\t\\t\\tif ((i-1, j), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i+1, j), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i-1, j), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i-1, j), (i, j)))\\n\\n\\t\\tif j > 0 and j < (m-1) and grid[i][j-1] != \\'#\\' and grid[i][j+1] != \\'#\\':\\n\\t\\t\\tif ((i, j-1), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i, j+1), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i, j-1), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i, j-1), (i, j)))\\n\\t\\t\\tif ((i, j+1), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i, j-1), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i, j+1), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i, j+1), (i, j)))\\n\\treturn -1\\n\\ndef canGoToBox(self, grid, loc, player, box):\\n\\tif loc == player:\\n\\t\\treturn True\\n\\trows = len(grid)\\n\\tcols = len(grid[0])\\n\\tqueue = [player]\\n\\tvisited = [player]\\n\\n\\twhile len(queue) != 0:\\n\\t\\ti, j = queue.pop()\\n\\t\\tif (i, j) == loc:\\n\\t\\t\\treturn True\\n\\t\\tneighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\\n\\t\\tfor x, y in neighbors:\\n\\t\\t\\tif x >= 0 and x < rows and y >= 0 and y < cols:\\n\\t\\t\\t\\tif (x, y) != box and grid[x][y] != \"#\" and (x, y) not in visited:\\n\\t\\t\\t\\t\\tqueue.append((x, y))\\n\\t\\t\\t\\t\\tvisited.append((x, y))\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef minPushBox(self, grid):\\n\\tplayer = None\\n\\tbox = None\\n\\ttarget = None\\n\\n\\tn = len(grid)\\n\\tif n == 0:\\n\\t\\treturn -1\\n\\tm = len(grid[0])\\n\\tif m == 0:\\n\\t\\treturn -1\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif grid[i][j] == \\'S\\':\\n\\t\\t\\t\\tplayer = (i, j)\\n\\t\\t\\tif grid[i][j] == \\'T\\':\\n\\t\\t\\t\\ttarget = (i, j)\\n\\t\\t\\tif grid[i][j] == \\'B\\':\\n\\t\\t\\t\\tbox = (i, j)\\n\\t\\t\\tif player != None and target != None and box != None:\\n\\t\\t\\t\\tbreak\\n\\t\\tif player != None and target != None and box != None:\\n\\t\\t\\tbreak\\n\\n\\tqueue = [(box, target, player, 0)]\\n\\tvisited = set([(box, player)])\\n\\twhile len(queue) > 0:\\n\\t\\tbox, target, player, steps = queue.pop()\\n\\t\\tif target == box:\\n\\t\\t\\treturn steps\\n\\t\\ti, j = box\\n\\t\\tif i > 0 and i < (n-1) and grid[i-1][j] != \\'#\\' and grid[i+1][j] != \\'#\\':\\n\\t\\t\\tif ((i+1, j), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i-1, j), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i+1, j), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i+1, j), (i, j)))\\n\\t\\t\\tif ((i-1, j), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i+1, j), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i-1, j), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i-1, j), (i, j)))\\n\\n\\t\\tif j > 0 and j < (m-1) and grid[i][j-1] != \\'#\\' and grid[i][j+1] != \\'#\\':\\n\\t\\t\\tif ((i, j-1), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i, j+1), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i, j-1), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i, j-1), (i, j)))\\n\\t\\t\\tif ((i, j+1), (i, j)) not in visited:\\n\\t\\t\\t\\tif self.canGoToBox(grid, (i, j-1), player, box):\\n\\t\\t\\t\\t\\tqueue.insert(0, ((i, j+1), target, (i, j), steps + 1))\\n\\t\\t\\t\\t\\tvisited.add(((i, j+1), (i, j)))\\n\\treturn -1\\n\\ndef canGoToBox(self, grid, loc, player, box):\\n\\tif loc == player:\\n\\t\\treturn True\\n\\trows = len(grid)\\n\\tcols = len(grid[0])\\n\\tqueue = [player]\\n\\tvisited = [player]\\n\\n\\twhile len(queue) != 0:\\n\\t\\ti, j = queue.pop()\\n\\t\\tif (i, j) == loc:\\n\\t\\t\\treturn True\\n\\t\\tneighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\\n\\t\\tfor x, y in neighbors:\\n\\t\\t\\tif x >= 0 and x < rows and y >= 0 and y < cols:\\n\\t\\t\\t\\tif (x, y) != box and grid[x][y] != \"#\" and (x, y) not in visited:\\n\\t\\t\\t\\t\\tqueue.append((x, y))\\n\\t\\t\\t\\t\\tvisited.append((x, y))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3853161,
                "title": "c-solution-using-dijkstra-s-algorithm",
                "content": "# Intuition\\nUse Dijkstra\\'s Algorithm\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 0 - distance\\n    // 1 - BoxX\\n    // 2 - BoxY\\n    // 3 - ManX\\n    // 4 - ManY\\n\\n    int dx[4] = {0, 0, -1, 1};\\n    int dy[4] = {-1, 1, 0, 0};\\n\\n    bool isValid(int x, int y, int n, int m, vector<vector<char>> &grid){\\n        if(x >= 0 && y >= 0 && x < n && y < m && grid[x][y] != \\'#\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<int> init(5, 0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    init[1] = i;\\n                    init[2] = j;\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    init[3] = i;\\n                    init[4] = j;\\n                }\\n            }\\n        }\\n\\n        pq.push(init);\\n        map<vector<int>, int> dist;\\n        dist[{init[1], init[2], init[3], init[4]}] = 0;\\n\\n        while(!pq.empty()) {\\n            int distance = pq.top()[0], boxX = pq.top()[1], boxY = pq.top()[2], manX = pq.top()[3], manY = pq.top()[4];\\n            pq.pop();\\n            // cout << \"MAN: \" << manX << \" \" << manY << \"   BOX: \" << boxX << \" \" << boxY << \"\\\\n\";\\n\\n            if(grid[boxX][boxY] == \\'T\\'){\\n                return distance;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                if(isValid(manX + dx[i], manY + dy[i], n, m, grid)){\\n                    if(manX + dx[i] == boxX && manY + dy[i] == boxY){\\n                        if(isValid(boxX + dx[i], boxY + dy[i], n, m, grid) && (dist.find({boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}) == dist.end()) || (dist[{boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}] > distance + 1)) {\\n                            if(manX + dx[i] == boxX + dx[i] && manY + dy[i] == boxY + dy[i]){\\n                                cout << \"hello\\\\n\";\\n                            }\\n                            pq.push({distance + 1, boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]});\\n                            dist[{boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}] = distance + 1;\\n                        }\\n                    }\\n                    else{\\n                        if((dist.find({boxX, boxY, manX + dx[i], manY + dy[i]}) == dist.end()) || (dist[{boxX, boxY, manX + dx[i], manY + dy[i]}] > distance)) {\\n                            pq.push({distance, boxX, boxY, manX + dx[i], manY + dy[i]});\\n                            dist[{boxX, boxY, manX + dx[i], manY + dy[i]}] = distance;\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 0 - distance\\n    // 1 - BoxX\\n    // 2 - BoxY\\n    // 3 - ManX\\n    // 4 - ManY\\n\\n    int dx[4] = {0, 0, -1, 1};\\n    int dy[4] = {-1, 1, 0, 0};\\n\\n    bool isValid(int x, int y, int n, int m, vector<vector<char>> &grid){\\n        if(x >= 0 && y >= 0 && x < n && y < m && grid[x][y] != \\'#\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<int> init(5, 0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    init[1] = i;\\n                    init[2] = j;\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    init[3] = i;\\n                    init[4] = j;\\n                }\\n            }\\n        }\\n\\n        pq.push(init);\\n        map<vector<int>, int> dist;\\n        dist[{init[1], init[2], init[3], init[4]}] = 0;\\n\\n        while(!pq.empty()) {\\n            int distance = pq.top()[0], boxX = pq.top()[1], boxY = pq.top()[2], manX = pq.top()[3], manY = pq.top()[4];\\n            pq.pop();\\n            // cout << \"MAN: \" << manX << \" \" << manY << \"   BOX: \" << boxX << \" \" << boxY << \"\\\\n\";\\n\\n            if(grid[boxX][boxY] == \\'T\\'){\\n                return distance;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                if(isValid(manX + dx[i], manY + dy[i], n, m, grid)){\\n                    if(manX + dx[i] == boxX && manY + dy[i] == boxY){\\n                        if(isValid(boxX + dx[i], boxY + dy[i], n, m, grid) && (dist.find({boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}) == dist.end()) || (dist[{boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}] > distance + 1)) {\\n                            if(manX + dx[i] == boxX + dx[i] && manY + dy[i] == boxY + dy[i]){\\n                                cout << \"hello\\\\n\";\\n                            }\\n                            pq.push({distance + 1, boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]});\\n                            dist[{boxX + dx[i], boxY + dy[i], manX + dx[i], manY + dy[i]}] = distance + 1;\\n                        }\\n                    }\\n                    else{\\n                        if((dist.find({boxX, boxY, manX + dx[i], manY + dy[i]}) == dist.end()) || (dist[{boxX, boxY, manX + dx[i], manY + dy[i]}] > distance)) {\\n                            pq.push({distance, boxX, boxY, manX + dx[i], manY + dy[i]});\\n                            dist[{boxX, boxY, manX + dx[i], manY + dy[i]}] = distance;\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2720124,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int n , m;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n\\t\\n    bool inside(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n\\n    bool canWalk(int srcX, int srcY, int destX, int destY, vector<vector<char>>&grid, vector<vector<int>>&visited)\\n    {\\n        if(srcX == destX && srcY == destY) return true;\\n        visited[srcX][srcY] = 1;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int x = srcX + dx[i];\\n            int y = srcY + dy[i];\\n            if(inside(x, y) && grid[x][y] != \\'#\\' && !visited[x][y])\\n            {\\n                if(canWalk(x, y, destX, destY, grid, visited))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n         n = grid.size();\\n         m = grid[0].size();\\n         int boxX, boxY, targetX, targetY, personX, personY; \\n         for(int i = 0; i < n; i++)\\n         {\\n             for(int j = 0; j < m; j++)\\n             {\\n                 if(grid[i][j] == \\'S\\')\\n                 {\\n                     personX = i;\\n                     personY = j;\\n                 }\\n                 else if(grid[i][j] == \\'T\\')\\n                 {\\n                     targetX = i;\\n                     targetY = j;\\n                 }\\n                 else if(grid[i][j] == \\'B\\')\\n                 {\\n                     boxX = i;\\n                     boxY = j;\\n                 }\\n             }\\n         }\\n\\t\\t \\n         queue<vector<int>>q;\\n         set<vector<int>> seen;\\n         q.push({boxX, boxY,personX, personY});\\n         int ans = 0;\\n\\t\\t \\n         while(!q.empty())\\n         {\\n             int sz = q.size();\\n             while(sz--)\\n             {\\n                auto p = q.front();\\n                q.pop();\\n                boxX = p[0]; boxY = p[1];\\n                personX = p[2]; personY = p[3];\\n\\t\\t\\t\\t\\n                if(boxX == targetX && boxY == targetY)\\n                    return ans;\\n\\t\\t\\t\\t\\t\\n                grid[boxX][boxY] = \\'#\\';\\n\\t\\t\\t\\t\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int new_boxX = boxX + dx[i];\\n                    int new_boxY = boxY + dy[i];\\n                    int new_personX = boxX - dx[i];\\n                    int new_personY = boxY - dy[i];\\n                    vector<int>curPos({new_boxX,new_boxY,new_personX,new_personY});\\n                    vector<vector<int>> visited(n, vector<int>(m, 0));\\n                    if(inside(new_boxX, new_boxY) && grid[new_boxX][new_boxY]!=\\'#\\'  && !seen.count(curPos) && canWalk(personX, personY, new_personX, new_personY, grid, visited))\\n                    {\\n                        seen.insert(curPos);\\n                        q.push(curPos);\\n                    }\\n                }\\n                grid[boxX][boxY] = \\'.\\';\\n              }\\n             ans++;\\n          }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int n , m;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n\\t\\n    bool inside(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n\\n    bool canWalk(int srcX, int srcY, int destX, int destY, vector<vector<char>>&grid, vector<vector<int>>&visited)\\n    {\\n        if(srcX == destX && srcY == destY) return true;\\n        visited[srcX][srcY] = 1;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int x = srcX + dx[i];\\n            int y = srcY + dy[i];\\n            if(inside(x, y) && grid[x][y] != \\'#\\' && !visited[x][y])\\n            {\\n                if(canWalk(x, y, destX, destY, grid, visited))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n         n = grid.size();\\n         m = grid[0].size();\\n         int boxX, boxY, targetX, targetY, personX, personY; \\n         for(int i = 0; i < n; i++)\\n         {\\n             for(int j = 0; j < m; j++)\\n             {\\n                 if(grid[i][j] == \\'S\\')\\n                 {\\n                     personX = i;\\n                     personY = j;\\n                 }\\n                 else if(grid[i][j] == \\'T\\')\\n                 {\\n                     targetX = i;\\n                     targetY = j;\\n                 }\\n                 else if(grid[i][j] == \\'B\\')\\n                 {\\n                     boxX = i;\\n                     boxY = j;\\n                 }\\n             }\\n         }\\n\\t\\t \\n         queue<vector<int>>q;\\n         set<vector<int>> seen;\\n         q.push({boxX, boxY,personX, personY});\\n         int ans = 0;\\n\\t\\t \\n         while(!q.empty())\\n         {\\n             int sz = q.size();\\n             while(sz--)\\n             {\\n                auto p = q.front();\\n                q.pop();\\n                boxX = p[0]; boxY = p[1];\\n                personX = p[2]; personY = p[3];\\n\\t\\t\\t\\t\\n                if(boxX == targetX && boxY == targetY)\\n                    return ans;\\n\\t\\t\\t\\t\\t\\n                grid[boxX][boxY] = \\'#\\';\\n\\t\\t\\t\\t\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int new_boxX = boxX + dx[i];\\n                    int new_boxY = boxY + dy[i];\\n                    int new_personX = boxX - dx[i];\\n                    int new_personY = boxY - dy[i];\\n                    vector<int>curPos({new_boxX,new_boxY,new_personX,new_personY});\\n                    vector<vector<int>> visited(n, vector<int>(m, 0));\\n                    if(inside(new_boxX, new_boxY) && grid[new_boxX][new_boxY]!=\\'#\\'  && !seen.count(curPos) && canWalk(personX, personY, new_personX, new_personY, grid, visited))\\n                    {\\n                        seen.insert(curPos);\\n                        q.push(curPos);\\n                    }\\n                }\\n                grid[boxX][boxY] = \\'.\\';\\n              }\\n             ans++;\\n          }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647970,
                "title": "golang-a-star",
                "content": "```\\ntype State struct {\\n    Box []int\\n    Person []int\\n    TotalDistanceToTarget int\\n    DistanceToBox int\\n    Moves int\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n    \\n    visited := make(map[string]bool)\\n    var target, box, person []int\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if grid[r][c] == \\'S\\' {\\n                person = []int{r, c}\\n            } else if grid[r][c] == \\'B\\' {\\n                box = []int{r, c}\\n            } else if grid[r][c] == \\'T\\' {\\n                target = []int{r, c}\\n            }\\n        }\\n    }\\n    \\n    minHeap := &MinHeap{}\\n    heap.Push(minHeap, State{box, person, calculateDistance(box, target), calculateDistance(box, person), 0})\\n    \\n    for minHeap.Len() > 0 {\\n        state := heap.Pop(minHeap).(State)\\n        currBox := state.Box\\n        currPerson := state.Person\\n        \\n        if currBox[0] == target[0] && currBox[1] == target[1] {\\n            return state.Moves\\n        }\\n        \\n        key := fmt.Sprintf(\"%d-%d-%d-%d\", currBox[0], currBox[1], currPerson[0], currPerson[1])\\n\\n        if visited[key] {\\n            continue\\n        }\\n        visited[key] = true\\n        \\n        for _, dir := range [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} {\\n            newPerson := []int{currPerson[0] + dir[0], currPerson[1] + dir[1]}\\n            if !ValidMove(newPerson, grid) {\\n                continue\\n            }\\n            \\n            // Now person may come on Box Cell, which is like pushing Box\\n            if currBox[0] == newPerson[0] && currBox[1] == newPerson[1] {\\n                newBox := []int{currBox[0] + dir[0], currBox[1] + dir[1]}\\n                if !ValidMove(newBox, grid) {\\n                    continue\\n                }\\n                heap.Push(minHeap, State{newBox, newPerson, calculateDistance(newBox, target)+state.Moves+1, calculateDistance(newBox, newPerson), state.Moves+1})\\n            } else {\\n                heap.Push(minHeap, State{currBox, newPerson, state.TotalDistanceToTarget, calculateDistance(currBox, newPerson), state.Moves})\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n\\nfunc calculateDistance(start, end []int) int {\\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\\n}\\n\\nfunc ValidMove(cell []int, grid [][]byte) bool {\\n    r := cell[0]\\n    c := cell[1]\\n    if r < 0 || r == len(grid) || c < 0 || c == len(grid[0]) || grid[r][c] == \\'#\\' {\\n        return false\\n    }\\n    return true\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n\\ntype MinHeap []State\\n\\nfunc (h MinHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h MinHeap) Less(i int, j int) bool {\\n    if h[i].TotalDistanceToTarget == h[j].TotalDistanceToTarget {\\n        return h[i].DistanceToBox < h[j].DistanceToBox\\n    }\\n    return h[i].TotalDistanceToTarget < h[j].TotalDistanceToTarget\\n}\\n                          \\nfunc (h MinHeap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n} \\n                          \\nfunc (h *MinHeap) Push(a interface{}) {\\n    *h = append(*h, a.(State))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype State struct {\\n    Box []int\\n    Person []int\\n    TotalDistanceToTarget int\\n    DistanceToBox int\\n    Moves int\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n    \\n    visited := make(map[string]bool)\\n    var target, box, person []int\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if grid[r][c] == \\'S\\' {\\n                person = []int{r, c}\\n            } else if grid[r][c] == \\'B\\' {\\n                box = []int{r, c}\\n            } else if grid[r][c] == \\'T\\' {\\n                target = []int{r, c}\\n            }\\n        }\\n    }\\n    \\n    minHeap := &MinHeap{}\\n    heap.Push(minHeap, State{box, person, calculateDistance(box, target), calculateDistance(box, person), 0})\\n    \\n    for minHeap.Len() > 0 {\\n        state := heap.Pop(minHeap).(State)\\n        currBox := state.Box\\n        currPerson := state.Person\\n        \\n        if currBox[0] == target[0] && currBox[1] == target[1] {\\n            return state.Moves\\n        }\\n        \\n        key := fmt.Sprintf(\"%d-%d-%d-%d\", currBox[0], currBox[1], currPerson[0], currPerson[1])\\n\\n        if visited[key] {\\n            continue\\n        }\\n        visited[key] = true\\n        \\n        for _, dir := range [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} {\\n            newPerson := []int{currPerson[0] + dir[0], currPerson[1] + dir[1]}\\n            if !ValidMove(newPerson, grid) {\\n                continue\\n            }\\n            \\n            // Now person may come on Box Cell, which is like pushing Box\\n            if currBox[0] == newPerson[0] && currBox[1] == newPerson[1] {\\n                newBox := []int{currBox[0] + dir[0], currBox[1] + dir[1]}\\n                if !ValidMove(newBox, grid) {\\n                    continue\\n                }\\n                heap.Push(minHeap, State{newBox, newPerson, calculateDistance(newBox, target)+state.Moves+1, calculateDistance(newBox, newPerson), state.Moves+1})\\n            } else {\\n                heap.Push(minHeap, State{currBox, newPerson, state.TotalDistanceToTarget, calculateDistance(currBox, newPerson), state.Moves})\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n\\nfunc calculateDistance(start, end []int) int {\\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\\n}\\n\\nfunc ValidMove(cell []int, grid [][]byte) bool {\\n    r := cell[0]\\n    c := cell[1]\\n    if r < 0 || r == len(grid) || c < 0 || c == len(grid[0]) || grid[r][c] == \\'#\\' {\\n        return false\\n    }\\n    return true\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n\\ntype MinHeap []State\\n\\nfunc (h MinHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h MinHeap) Less(i int, j int) bool {\\n    if h[i].TotalDistanceToTarget == h[j].TotalDistanceToTarget {\\n        return h[i].DistanceToBox < h[j].DistanceToBox\\n    }\\n    return h[i].TotalDistanceToTarget < h[j].TotalDistanceToTarget\\n}\\n                          \\nfunc (h MinHeap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n} \\n                          \\nfunc (h *MinHeap) Push(a interface{}) {\\n    *h = append(*h, a.(State))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939866,
                "title": "c-bfs-o-m-n-2",
                "content": "This problem, is not too Hard. Just Think of brute force solution and apply BFS.\\n**What are the conditions to move from one cell to Another?**\\nLet\\'s assume that current position of Box is **[i,j]**.\\n* If We want to move box to [i+1,j] then this cell should\\'nt contain any wall and player should be able to come to cell [i-1,j] from it\\'s curr position.\\n* If We want to move box to [i-1,j] then this cell should\\'nt contain any wall and player should be able to come to cell [i+1,j] from it\\'s curr position.\\n* If We want to move box to [i,j+1] then this cell should\\'nt contain any wall and player should be able to come to cell [i,j-1] from it\\'s curr position.\\n* If We want to move box to [i,j-1] then this cell should\\'nt contain any wall and player should be able to come to cell [i,j+1] from it\\'s curr position.\\n\\nChecking the Condition of player to move from one cell to another can be Done using BFS by applying the current position of Box and player. I have used BFS because of simpler implementation, you guys can use DSU also.\\nUsing These extra conditions, apply simple BFS.\\n```\\nclass Solution {\\npublic:\\n    string stringigy(int x,int t,int a,int b){\\n        return to_string(x)+\"_\"+to_string(t)+\"_\"+\\n            to_string(a)+\"_\"+to_string(b);\\n    }\\n    bool check(vector<vector<char>>& nums,int ni,int nj,int i,int j,int x,int y){\\n        vector<vector<bool>> vis(nums.size(),vector<bool>(nums[0].size(),0));\\n        vis[i][j] = 1;\\n        queue<pair<int,int>> q; \\n        q.push({i,j});\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n            auto [i,j] = q.front(); q.pop();\\n            if(i==ni && j==nj) continue;\\n            if(i==x && j==y) return 1;\\n            if(i+1<nums.size() && !vis[i+1][j] && nums[i+1][j]!=\\'#\\' ){\\n                q.push({i+1,j}); vis[i+1][j] = 1;\\n            }\\n            if(i-1>=0 && !vis[i-1][j] && nums[i-1][j]!=\\'#\\' ){\\n                q.push({i-1,j}); vis[i-1][j] = 1;\\n            }\\n            if(j+1<nums[0].size() && !vis[i][j+1] && nums[i][j+1]!=\\'#\\' ){\\n                q.push({i,j+1}); vis[i][j+1] = 1;\\n            }\\n            if(j-1>=0 && !vis[i][j-1] && nums[i][j-1]!=\\'#\\' ){\\n                q.push({i,j-1}); vis[i][j-1] = 1;\\n            }}\\n        }\\n        return 0;\\n    }\\n    int minPushBox(vector<vector<char>>& nums) {\\n        int bi,bj,si,sj,ti,tj;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0;j<nums[0].size();++j){\\n                if(nums[i][j]==\\'B\\'){ bi = i,bj = j; }\\n                if(nums[i][j]==\\'S\\'){ si = i,sj = j; }\\n                if(nums[i][j]==\\'T\\'){ ti = i,tj = j; }\\n            }\\n        }\\n        unordered_map<string,int> mp;\\n        queue<vector<int>> q;\\n        q.push({bi,bj,si,sj});\\n        mp[stringigy(bi,bj,si,sj)]++;\\n        int n = nums.size(),m=nums[0].size(),l=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> temp = q.front(); q.pop();\\n                int i=temp[0],j=temp[1],si=temp[2],sj=temp[3];\\n                if(i==ti && j==tj) return l;\\n                if(j-1>=0 && nums[i][j-1]!=\\'#\\'){\\n                   if(j+1<m && nums[i][j+1]!=\\'#\\' && mp.find(stringigy(i,j-1,i,j))==mp.end() &&\\n                      check(nums,i,j,si,sj,i,j+1)){\\n                       q.push({i,j-1,i,j});\\n                       mp[stringigy(i,j-1,i,j)]++;\\n                   }\\n                }\\n                if(j+1<m && nums[i][j+1]!=\\'#\\'){\\n                    if(j-1>=0 && nums[i][j-1]!=\\'#\\' && mp.find(stringigy(i,j+1,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i,j-1)){\\n                        q.push({i,j+1,i,j});\\n                        mp[stringigy(i,j+1,i,j)]++;\\n                    }\\n                }\\n                if(i+1<n && nums[i+1][j]!=\\'#\\'){\\n                    if(i-1>=0 && nums[i-1][j]!=\\'#\\' && mp.find(stringigy(i+1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i-1,j)){\\n                        q.push({i+1,j,i,j});\\n                        mp[stringigy(i+1,j,i,j)]++;\\n                    }\\n                }\\n                if(i-1>=0 && nums[i-1][j]!=\\'#\\'){\\n                     if(i+1<n && nums[i+1][j]!=\\'#\\' && mp.find(stringigy(i-1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i+1,j)){\\n                         q.push({i-1,j,i,j});\\n                         mp[stringigy(i-1,j,i,j)]++;\\n                     }\\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string stringigy(int x,int t,int a,int b){\\n        return to_string(x)+\"_\"+to_string(t)+\"_\"+\\n            to_string(a)+\"_\"+to_string(b);\\n    }\\n    bool check(vector<vector<char>>& nums,int ni,int nj,int i,int j,int x,int y){\\n        vector<vector<bool>> vis(nums.size(),vector<bool>(nums[0].size(),0));\\n        vis[i][j] = 1;\\n        queue<pair<int,int>> q; \\n        q.push({i,j});\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n            auto [i,j] = q.front(); q.pop();\\n            if(i==ni && j==nj) continue;\\n            if(i==x && j==y) return 1;\\n            if(i+1<nums.size() && !vis[i+1][j] && nums[i+1][j]!=\\'#\\' ){\\n                q.push({i+1,j}); vis[i+1][j] = 1;\\n            }\\n            if(i-1>=0 && !vis[i-1][j] && nums[i-1][j]!=\\'#\\' ){\\n                q.push({i-1,j}); vis[i-1][j] = 1;\\n            }\\n            if(j+1<nums[0].size() && !vis[i][j+1] && nums[i][j+1]!=\\'#\\' ){\\n                q.push({i,j+1}); vis[i][j+1] = 1;\\n            }\\n            if(j-1>=0 && !vis[i][j-1] && nums[i][j-1]!=\\'#\\' ){\\n                q.push({i,j-1}); vis[i][j-1] = 1;\\n            }}\\n        }\\n        return 0;\\n    }\\n    int minPushBox(vector<vector<char>>& nums) {\\n        int bi,bj,si,sj,ti,tj;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0;j<nums[0].size();++j){\\n                if(nums[i][j]==\\'B\\'){ bi = i,bj = j; }\\n                if(nums[i][j]==\\'S\\'){ si = i,sj = j; }\\n                if(nums[i][j]==\\'T\\'){ ti = i,tj = j; }\\n            }\\n        }\\n        unordered_map<string,int> mp;\\n        queue<vector<int>> q;\\n        q.push({bi,bj,si,sj});\\n        mp[stringigy(bi,bj,si,sj)]++;\\n        int n = nums.size(),m=nums[0].size(),l=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> temp = q.front(); q.pop();\\n                int i=temp[0],j=temp[1],si=temp[2],sj=temp[3];\\n                if(i==ti && j==tj) return l;\\n                if(j-1>=0 && nums[i][j-1]!=\\'#\\'){\\n                   if(j+1<m && nums[i][j+1]!=\\'#\\' && mp.find(stringigy(i,j-1,i,j))==mp.end() &&\\n                      check(nums,i,j,si,sj,i,j+1)){\\n                       q.push({i,j-1,i,j});\\n                       mp[stringigy(i,j-1,i,j)]++;\\n                   }\\n                }\\n                if(j+1<m && nums[i][j+1]!=\\'#\\'){\\n                    if(j-1>=0 && nums[i][j-1]!=\\'#\\' && mp.find(stringigy(i,j+1,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i,j-1)){\\n                        q.push({i,j+1,i,j});\\n                        mp[stringigy(i,j+1,i,j)]++;\\n                    }\\n                }\\n                if(i+1<n && nums[i+1][j]!=\\'#\\'){\\n                    if(i-1>=0 && nums[i-1][j]!=\\'#\\' && mp.find(stringigy(i+1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i-1,j)){\\n                        q.push({i+1,j,i,j});\\n                        mp[stringigy(i+1,j,i,j)]++;\\n                    }\\n                }\\n                if(i-1>=0 && nums[i-1][j]!=\\'#\\'){\\n                     if(i+1<n && nums[i+1][j]!=\\'#\\' && mp.find(stringigy(i-1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i+1,j)){\\n                         q.push({i-1,j,i,j});\\n                         mp[stringigy(i-1,j,i,j)]++;\\n                     }\\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570202,
                "title": "python-dijkstra-player-and-box-coordinates-state-space",
                "content": "If state space (vertices of a graph) represented as player and box coordinates, and the edges have value 1 if during state transition we pushed the box, 0 otherwise. Given this formulation we can run Dijkstra algorithm to find minimum number of pushes to get box to the target.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minPushBox(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        player, box, target = (0, 0), (0, 0), (0, 0)\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i, j)\\n                if grid[i][j] == \\'B\\':\\n                    box = (i, j)\\n\\n        def get_nbs(p):\\n            x, y = p\\n            return [(dx, dy) for dx, dy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\\n                    if 0 <= dx < n and 0 <= dy < m and grid[dx][dy] != \\'#\\']\\n\\n        def get_next_state(state):\\n            p, b = state\\n\\n            next_states = []\\n            for dp in get_nbs(p):\\n                if dp != b:\\n                    next_states.append((0, dp, b))\\n                else:\\n                    dx = dp[0] - p[0]\\n                    dy = dp[1] - p[1]\\n                    db = (b[0] + dx, b[1] + dy)\\n                    if 0 <= db[0] < n and 0 <= db[1] < m and grid[db[0]][db[1]] != \\'#\\':\\n                        next_states.append((1, dp, db))\\n            return next_states\\n\\n        start = (player, box)\\n        q = SortedList([(0, start)])\\n        attended = set()\\n\\n        while len(q):\\n            d, state = q.pop(0)\\n            if state in attended: continue\\n            attended.add(state)\\n            if state[1] == target:\\n                return d\\n\\n            for ns in get_next_state(state):\\n                if ns[1:] not in attended:\\n                    q.add((d + ns[0], ns[1:]))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minPushBox(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        player, box, target = (0, 0), (0, 0), (0, 0)\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i, j)\\n                if grid[i][j] == \\'B\\':\\n                    box = (i, j)\\n\\n        def get_nbs(p):\\n            x, y = p\\n            return [(dx, dy) for dx, dy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\\n                    if 0 <= dx < n and 0 <= dy < m and grid[dx][dy] != \\'#\\']\\n\\n        def get_next_state(state):\\n            p, b = state\\n\\n            next_states = []\\n            for dp in get_nbs(p):\\n                if dp != b:\\n                    next_states.append((0, dp, b))\\n                else:\\n                    dx = dp[0] - p[0]\\n                    dy = dp[1] - p[1]\\n                    db = (b[0] + dx, b[1] + dy)\\n                    if 0 <= db[0] < n and 0 <= db[1] < m and grid[db[0]][db[1]] != \\'#\\':\\n                        next_states.append((1, dp, db))\\n            return next_states\\n\\n        start = (player, box)\\n        q = SortedList([(0, start)])\\n        attended = set()\\n\\n        while len(q):\\n            d, state = q.pop(0)\\n            if state in attended: continue\\n            attended.add(state)\\n            if state[1] == target:\\n                return d\\n\\n            for ns in get_next_state(state):\\n                if ns[1:] not in attended:\\n                    q.add((d + ns[0], ns[1:]))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509858,
                "title": "10-ms-solution-bfs-with-some-comments",
                "content": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        if(grid == null)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[] target = null;\\n        int[] box = null;\\n        int[] player = null;\\n        \\n        for(int i=0; i < row; i++) {\\n            for(int j=0; j < col; j++) {\\n                if(grid[i][j] == \\'T\\')\\n                    target = new int[] {i, j};\\n                if(grid[i][j] == \\'S\\')\\n                    player = new int[] {i, j};\\n                if(grid[i][j] == \\'B\\')\\n                    box = new int[] {i, j};                \\n            }\\n        }\\n        \\n        Queue<int[]> q = new ArrayDeque<>();\\n        Set<List<Integer>> visited = new HashSet<>();\\n\\n        //Add player and box current location to queue as state\\n        q.offer(new int[] {player[0], player[1], box[0], box[1]});\\n        visited.add(new ArrayList<>(Arrays.asList(player[0], player[1], box[0], box[1])));        \\n        \\n        int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int push = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            for(int i=0; i < size; i++) {\\n                int[] state = q.poll();\\n                if(state[2] == target[0] && state[3] == target[1])\\n                    return push;\\n                \\n                for(int[] dir: dirs) {\\n                    //player need to be here\\n                    int pX = state[2] - dir[0];\\n                    int pY = state[3] - dir[1];\\n                    \\n                    //To push box in this direction\\n                    int bX = state[2] + dir[0];\\n                    int bY = state[3] + dir[1];\\n                    if(pX < 0 || pX >= row || pY < 0 || pY >= col || \\n                       bX < 0 || bX >= row || bY < 0 || bY >= col ||\\n                       grid[bX][bY] == \\'#\\' || grid[pX][pY] == \\'#\\' ||\\n                       visited.contains(new ArrayList<>(Arrays.asList(state[2], state[3], bX, bY))) || \\n                       //player can reach the push location given current box location\\n                       !canReach(state[0], state[1], grid, pX, pY, state[2], state[3])) \\n                        continue;\\n                    \\n                    //box location updated and player location updated to last box location                    \\n                    q.offer(new int[] {state[2], state[3], bX, bY}); \\n                    visited.add(new ArrayList<>(Arrays.asList(state[2], state[3], bX, bY)));                    \\n                }\\n            }\\n            push++;\\n            \\n        }\\n                \\n        return -1;\\n        \\n    }\\n    \\n    \\n    public boolean canReach(int x, int y, char[][] grid, int tX, int tY, int bX, int bY) {\\n        Queue<int[]> q = new ArrayDeque<>();\\n        \\n        q.offer(new int [] {x, y});\\n        int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            for(int i=0; i < size; i++){\\n                int[] state = q.poll();\\n                \\n                if(state[0] == tX && state[1] == tY)\\n                    return true;\\n                \\n                for(int[] dir: dirs) {\\n                    int newX = state[0] + dir[0];\\n                    int newY = state[1] + dir[1];\\n                    \\n                    if(newX < 0 || newY < 0 || \\n                       newX >= grid.length || newY >= grid[0].length || \\n                       visited[newX][newY] || grid[newX][newY] == \\'#\\' || \\n                       (newX == bX && newY == bY))\\n                        continue;\\n                    q.offer(new int[] {newX, newY});\\n                    visited[newX][newY] = true;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        if(grid == null)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[] target = null;\\n        int[] box = null;\\n        int[] player = null;\\n        \\n        for(int i=0; i < row; i++) {\\n            for(int j=0; j < col; j++) {\\n                if(grid[i][j] == \\'T\\')\\n                    target = new int[] {i, j};\\n                if(grid[i][j] == \\'S\\')\\n                    player = new int[] {i, j};\\n                if(grid[i][j] == \\'B\\')\\n                    box = new int[] {i, j};                \\n            }\\n        }\\n        \\n        Queue<int[]> q = new ArrayDeque<>();\\n        Set<List<Integer>> visited = new HashSet<>();\\n\\n        //Add player and box current location to queue as state\\n        q.offer(new int[] {player[0], player[1], box[0], box[1]});\\n        visited.add(new ArrayList<>(Arrays.asList(player[0], player[1], box[0], box[1])));        \\n        \\n        int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int push = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            for(int i=0; i < size; i++) {\\n                int[] state = q.poll();\\n                if(state[2] == target[0] && state[3] == target[1])\\n                    return push;\\n                \\n                for(int[] dir: dirs) {\\n                    //player need to be here\\n                    int pX = state[2] - dir[0];\\n                    int pY = state[3] - dir[1];\\n                    \\n                    //To push box in this direction\\n                    int bX = state[2] + dir[0];\\n                    int bY = state[3] + dir[1];\\n                    if(pX < 0 || pX >= row || pY < 0 || pY >= col || \\n                       bX < 0 || bX >= row || bY < 0 || bY >= col ||\\n                       grid[bX][bY] == \\'#\\' || grid[pX][pY] == \\'#\\' ||\\n                       visited.contains(new ArrayList<>(Arrays.asList(state[2], state[3], bX, bY))) || \\n                       //player can reach the push location given current box location\\n                       !canReach(state[0], state[1], grid, pX, pY, state[2], state[3])) \\n                        continue;\\n                    \\n                    //box location updated and player location updated to last box location                    \\n                    q.offer(new int[] {state[2], state[3], bX, bY}); \\n                    visited.add(new ArrayList<>(Arrays.asList(state[2], state[3], bX, bY)));                    \\n                }\\n            }\\n            push++;\\n            \\n        }\\n                \\n        return -1;\\n        \\n    }\\n    \\n    \\n    public boolean canReach(int x, int y, char[][] grid, int tX, int tY, int bX, int bY) {\\n        Queue<int[]> q = new ArrayDeque<>();\\n        \\n        q.offer(new int [] {x, y});\\n        int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            for(int i=0; i < size; i++){\\n                int[] state = q.poll();\\n                \\n                if(state[0] == tX && state[1] == tY)\\n                    return true;\\n                \\n                for(int[] dir: dirs) {\\n                    int newX = state[0] + dir[0];\\n                    int newY = state[1] + dir[1];\\n                    \\n                    if(newX < 0 || newY < 0 || \\n                       newX >= grid.length || newY >= grid[0].length || \\n                       visited[newX][newY] || grid[newX][newY] == \\'#\\' || \\n                       (newX == bX && newY == bY))\\n                        continue;\\n                    q.offer(new int[] {newX, newY});\\n                    visited[newX][newY] = true;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472529,
                "title": "super-clean-java-code",
                "content": "```\\nclass Solution {\\n    int n, m;\\n    char[][] grid;\\n    int[][] dirs = new int[][] {\\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n    };\\n    public int minPushBox(char[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        this.grid = grid;\\n        int[] box = new int[2], target = new int[2], player = new int[2];\\n        findLocations(box, target, player);\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{box[0], box[1], player[0], player[1]});\\n        boolean[][][] visited = new boolean[n][m][4]; // for 4 directions\\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size-- > 0) {\\n                int[] cur = q.poll();\\n                if(cur[0] == target[0] && cur[1] == target[1]) return steps;\\n                for(int i = 0; i < 4; i++) {\\n                    int[] newPlayerLoc = new int[]{cur[0] + dirs[i][0], cur[1] + dirs[i][1]};\\n                    int[] newBoxLoc = new int[]{cur[0] - dirs[i][0], cur[1] - dirs[i][1]};\\n                    if(visited[cur[0]][cur[1]][i] || isOutOfBounds(newPlayerLoc, newBoxLoc) || !isReachable(newPlayerLoc, cur)) continue;\\n                    visited[cur[0]][cur[1]][i] = true;\\n                    q.offer(new int[]{newBoxLoc[0], newBoxLoc[1], cur[0], cur[1]});\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    public boolean isReachable(int[] targetPlayerLoc, int[] cur) {\\n        boolean[][] visited = new boolean[n][m];\\n        visited[cur[0]][cur[1]] = true;\\n        visited[cur[2]][cur[3]] = true;\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{cur[2], cur[3]});\\n        while(!q.isEmpty()) {\\n            int[] playerLoc = q.poll();\\n            if(playerLoc[0] == targetPlayerLoc[0] && playerLoc[1] == targetPlayerLoc[1]) return true;\\n            for(int[] d: dirs) {\\n                int x = playerLoc[0] + d[0];\\n                int y = playerLoc[1] + d[1];\\n                if(isOutOfBounds(x, y) || visited[x][y]) continue;\\n                visited[x][y] = true;\\n                q.offer(new int[]{x, y});\\n            } \\n        }\\n        return false;\\n    }\\n    \\n    public boolean isOutOfBounds(int[] player, int[] box) {\\n        return isOutOfBounds(player[0], player[1]) || isOutOfBounds(box[0], box[1]);\\n    }\\n    \\n    public boolean isOutOfBounds(int x, int y) {\\n        return (x < 0 || y < 0 || x == n || y == m || grid[x][y] == \\'#\\');\\n    }\\n    \\n    public void findLocations(int[] box, int[] target, int[] player) {\\n        boolean p = false, t = false, b = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                    p = true;\\n                } else if(grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                    t = true;\\n                } else if(grid[i][j] == \\'B\\') {\\n                    box[0] = i;\\n                    box[1] = j;\\n                    b = true;\\n                }\\n                \\n                if(p && b && t) return; // found all\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    char[][] grid;\\n    int[][] dirs = new int[][] {\\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n    };\\n    public int minPushBox(char[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        this.grid = grid;\\n        int[] box = new int[2], target = new int[2], player = new int[2];\\n        findLocations(box, target, player);\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{box[0], box[1], player[0], player[1]});\\n        boolean[][][] visited = new boolean[n][m][4]; // for 4 directions\\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size-- > 0) {\\n                int[] cur = q.poll();\\n                if(cur[0] == target[0] && cur[1] == target[1]) return steps;\\n                for(int i = 0; i < 4; i++) {\\n                    int[] newPlayerLoc = new int[]{cur[0] + dirs[i][0], cur[1] + dirs[i][1]};\\n                    int[] newBoxLoc = new int[]{cur[0] - dirs[i][0], cur[1] - dirs[i][1]};\\n                    if(visited[cur[0]][cur[1]][i] || isOutOfBounds(newPlayerLoc, newBoxLoc) || !isReachable(newPlayerLoc, cur)) continue;\\n                    visited[cur[0]][cur[1]][i] = true;\\n                    q.offer(new int[]{newBoxLoc[0], newBoxLoc[1], cur[0], cur[1]});\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    public boolean isReachable(int[] targetPlayerLoc, int[] cur) {\\n        boolean[][] visited = new boolean[n][m];\\n        visited[cur[0]][cur[1]] = true;\\n        visited[cur[2]][cur[3]] = true;\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{cur[2], cur[3]});\\n        while(!q.isEmpty()) {\\n            int[] playerLoc = q.poll();\\n            if(playerLoc[0] == targetPlayerLoc[0] && playerLoc[1] == targetPlayerLoc[1]) return true;\\n            for(int[] d: dirs) {\\n                int x = playerLoc[0] + d[0];\\n                int y = playerLoc[1] + d[1];\\n                if(isOutOfBounds(x, y) || visited[x][y]) continue;\\n                visited[x][y] = true;\\n                q.offer(new int[]{x, y});\\n            } \\n        }\\n        return false;\\n    }\\n    \\n    public boolean isOutOfBounds(int[] player, int[] box) {\\n        return isOutOfBounds(player[0], player[1]) || isOutOfBounds(box[0], box[1]);\\n    }\\n    \\n    public boolean isOutOfBounds(int x, int y) {\\n        return (x < 0 || y < 0 || x == n || y == m || grid[x][y] == \\'#\\');\\n    }\\n    \\n    public void findLocations(int[] box, int[] target, int[] player) {\\n        boolean p = false, t = false, b = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                    p = true;\\n                } else if(grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                    t = true;\\n                } else if(grid[i][j] == \\'B\\') {\\n                    box[0] = i;\\n                    box[1] = j;\\n                    b = true;\\n                }\\n                \\n                if(p && b && t) return; // found all\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371624,
                "title": "c-clean-easy-to-understand",
                "content": "\\n    //{\\'#\\',\\'.\\',\\'.\\',\\'.\\'}\\n    //{\\'.\\',\\'.\\',\\'S\\',\\'.\\'}\\n    //{\\'.\\',\\'B\\',\\'.\\',\\'T\\'}\\n    //{\\'.\\',\\'.\\',\\'.\\',\\'#\\'}\\n    //We can start from the current Box location & do a BFS.\\n    //We don\\'t really need to move player, we can just simulate it.\\n    //In each level, we can try to find valid positions for box in all 4 directions around it\\n    //& if those positions have a valid position around it for player then,\\n    //we can push those positions to Q.\\n    //Box & player new positions valid if: valid boundary/no wall/player can move to the pos.\\n    //In each step, we can try finding all valid player positions in grid using DFS before hand.\\n    //The level where we reach the target will be our minimum moves.\\n    //*********Key is\\n    //if we want to push box to left, player must stand at right, to simulate this \\n    //we can just use box position & current direction & add current direction to box position\\n    //& subtract current direction from box position to get new box & player positions. \\n    //we can ignore the player position to simulate the player can move to any position\\n    //int bxNew = boxPos.X + d[0], byNew = boxPos.Y + d[1];\\n    //int pxNew = boxPos.X - d[0], pyNew = boxPos.Y - d[1];\\n    //D[1,0] B[1,1] P[0,1] =>move box left[0,-1]\\n    //=> D[1,0] B[1,0(1-1)] P[1(1+0),2(1-(-1)]\\n    public class MBM2\\n    {\\n        static readonly List<int[]> Dirs = new List<int[]>\\n        {new[] { -1, 0 }, new[] { 1, 0 }, new[] { 0, 1 }, new[] { 0, -1 }};\\n        public static int MinPushBox(char[][] grid)\\n        {\\n            Position box = null, target = null, player = null;\\n            #region Get the box, player & target positions\\n            int rows = grid.Length, cols = grid[0].Length;\\n            for (var row = 0; row < rows; row++)\\n            {\\n                for (var col = 0; col < cols; col++)\\n                {\\n                    if (grid[row][col] == \\'B\\')\\n                        box = new Position(row, col);\\n                    else if (grid[row][col] == \\'T\\')\\n                        target = new Position(row, col);\\n                    else if (grid[row][col] == \\'S\\')\\n                        player = new Position(row, col);\\n                }\\n            }\\n            #endregion\\n\\n            //Do BFS to find the min moves\\n            //we can save block & player encoded positions int the Q\\n            var startPos = Position.GetPositionsAsString(box, player);\\n            var q = new Queue<string>();\\n            q.Enqueue(startPos);\\n            //We use a set to record all the positions we have visited\\n            //(including the position of the player)\\n            var visitedSet = new HashSet<string>();\\n            visitedSet.Add(startPos);\\n\\n            var res = 0;\\n            while (q.Any())\\n            {\\n                res++;\\n                var size = q.Count();\\n                while (size > 0)\\n                {\\n                    size--;\\n                    var decodedPositions = Position.GetPositions(q.Dequeue());\\n                    var boxPos = decodedPositions.Key;\\n                    var playerPos = decodedPositions.Value;\\n                    var canVisit = new bool[rows, cols];\\n\\n                    //Use dfs to find all the positions that the player can reach at this moment. \\n                    UpdatePlayerReachablePositions(grid, canVisit, playerPos, boxPos);\\n\\n                    //Move the box and update the set\\n                    foreach (var d in Dirs)\\n                    {\\n                        //if we want to push box to right, storekeeper must stand at left\\n                        int bxNew = boxPos.X + d[0], byNew = boxPos.Y + d[1];\\n                        int pxNew = boxPos.X - d[0], pyNew = boxPos.Y - d[1];\\n                        var newBoxPos = new Position(bxNew, byNew);\\n                        var newPlayerPos = new Position(pxNew, pyNew);\\n\\n                        //Box cannot move to this direction in any of the following condition \\n                        if (!newPlayerPos.IsValid(grid) || !newBoxPos.IsValid(grid) ||\\n                            newBoxPos.IsWall(grid) || !canVisit[pxNew, pyNew])\\n                            continue;\\n\\n                        //If we have reached destination return\\n                        if (newBoxPos.Equals(target))\\n                            return res;\\n\\n                        //Now we can move the box, also record the new position(including the original position of the box)\\n                        var newPosition = Position.GetPositionsAsString(newBoxPos, newPlayerPos);\\n                        //Make sure the newPosition has never been visited before\\n                        if (visitedSet.Add(newPosition))\\n                        {\\n                            q.Enqueue(newPosition);\\n                        }\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        //DFS to find locations the player can reach\\n        public static void UpdatePlayerReachablePositions(char[][] grid, bool[,] canVisit, Position playerPosition, Position boxPosition)\\n        {\\n            if (!playerPosition.IsValid(grid) ||\\n                playerPosition.IsWall(grid) ||\\n                playerPosition.Equals(boxPosition) ||\\n                canVisit[playerPosition.X, playerPosition.Y])\\n                return;\\n            canVisit[playerPosition.X, playerPosition.Y] = true;\\n            foreach (var d in Dirs)\\n            {\\n                var newPlayerPos = new Position(playerPosition.X + d[0], playerPosition.Y + d[1]);\\n                UpdatePlayerReachablePositions(grid, canVisit, newPlayerPos, boxPosition);\\n            }\\n        }\\n\\n        public class Position\\n        {\\n            public int X { get; set; }\\n            public int Y { get; set; }\\n            public Position(int x, int y)\\n            {\\n                X = x;\\n                Y = y;\\n            }\\n            public static string GetPositionsAsString(Position box, Position storeKeeper)\\n            {\\n                return box.ToString() + \"|\" + storeKeeper.ToString();\\n            }\\n\\n            public static KeyValuePair<Position, Position> GetPositions(string num)\\n            {\\n                var pos = num.Split(\\'|\\');\\n                var res = new KeyValuePair<Position, Position>(new Position(pos[0], pos[1]), new Position(pos[2], pos[3]));\\n                return res;\\n            }\\n            public Position(string x, string y)\\n            {\\n                int.TryParse(x, out var x1);\\n                X = x1;\\n                int.TryParse(y, out var y1);\\n                Y = y1;\\n            }\\n            public override string ToString()\\n            {\\n                return X + \"|\" + Y;\\n            }\\n\\n            public bool IsValid(char[][] grid)\\n            {\\n                return X >= 0 && Y >= 0 && X < grid.Length && Y < grid[0].Length;\\n            }\\n\\n            public bool IsWall(char[][] grid)\\n            {\\n                return grid[X][Y] == \\'#\\';\\n            }\\n\\n            public bool Equals(Position position)\\n            {\\n                return X == position.X && Y == position.Y;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\n    //{\\'#\\',\\'.\\',\\'.\\',\\'.\\'}\\n    //{\\'.\\',\\'.\\',\\'S\\',\\'.\\'}\\n    //{\\'.\\',\\'B\\',\\'.\\',\\'T\\'}\\n    //{\\'.\\',\\'.\\',\\'.\\',\\'#\\'}\\n    //We can start from the current Box location & do a BFS.\\n    //We don\\'t really need to move player, we can just simulate it.\\n    //In each level, we can try to find valid positions for box in all 4 directions around it\\n    //& if those positions have a valid position around it for player then,\\n    //we can push those positions to Q.\\n    //Box & player new positions valid if: valid boundary/no wall/player can move to the pos.\\n    //In each step, we can try finding all valid player positions in grid using DFS before hand.\\n    //The level where we reach the target will be our minimum moves.\\n    //*********Key is\\n    //if we want to push box to left, player must stand at right, to simulate this \\n    //we can just use box position & current direction & add current direction to box position\\n    //& subtract current direction from box position to get new box & player positions. \\n    //we can ignore the player position to simulate the player can move to any position\\n    //int bxNew = boxPos.X + d[0], byNew = boxPos.Y + d[1];\\n    //int pxNew = boxPos.X - d[0], pyNew = boxPos.Y - d[1];\\n    //D[1,0] B[1,1] P[0,1] =>move box left[0,-1]\\n    //=> D[1,0] B[1,0(1-1)] P[1(1+0),2(1-(-1)]\\n    public class MBM2\\n    {\\n        static readonly List<int[]> Dirs = new List<int[]>\\n        {new[] { -1, 0 }, new[] { 1, 0 }, new[] { 0, 1 }, new[] { 0, -1 }};\\n        public static int MinPushBox(char[][] grid)\\n        {\\n            Position box = null, target = null, player = null;\\n            #region Get the box, player & target positions\\n            int rows = grid.Length, cols = grid[0].Length;\\n            for (var row = 0; row < rows; row++)\\n            {\\n                for (var col = 0; col < cols; col++)\\n                {\\n                    if (grid[row][col] == \\'B\\')\\n                        box = new Position(row, col);\\n                    else if (grid[row][col] == \\'T\\')\\n                        target = new Position(row, col);\\n                    else if (grid[row][col] == \\'S\\')\\n                        player = new Position(row, col);\\n                }\\n            }\\n            #endregion\\n\\n            //Do BFS to find the min moves\\n            //we can save block & player encoded positions int the Q\\n            var startPos = Position.GetPositionsAsString(box, player);\\n            var q = new Queue<string>();\\n            q.Enqueue(startPos);\\n            //We use a set to record all the positions we have visited\\n            //(including the position of the player)\\n            var visitedSet = new HashSet<string>();\\n            visitedSet.Add(startPos);\\n\\n            var res = 0;\\n            while (q.Any())\\n            {\\n                res++;\\n                var size = q.Count();\\n                while (size > 0)\\n                {\\n                    size--;\\n                    var decodedPositions = Position.GetPositions(q.Dequeue());\\n                    var boxPos = decodedPositions.Key;\\n                    var playerPos = decodedPositions.Value;\\n                    var canVisit = new bool[rows, cols];\\n\\n                    //Use dfs to find all the positions that the player can reach at this moment. \\n                    UpdatePlayerReachablePositions(grid, canVisit, playerPos, boxPos);\\n\\n                    //Move the box and update the set\\n                    foreach (var d in Dirs)\\n                    {\\n                        //if we want to push box to right, storekeeper must stand at left\\n                        int bxNew = boxPos.X + d[0], byNew = boxPos.Y + d[1];\\n                        int pxNew = boxPos.X - d[0], pyNew = boxPos.Y - d[1];\\n                        var newBoxPos = new Position(bxNew, byNew);\\n                        var newPlayerPos = new Position(pxNew, pyNew);\\n\\n                        //Box cannot move to this direction in any of the following condition \\n                        if (!newPlayerPos.IsValid(grid) || !newBoxPos.IsValid(grid) ||\\n                            newBoxPos.IsWall(grid) || !canVisit[pxNew, pyNew])\\n                            continue;\\n\\n                        //If we have reached destination return\\n                        if (newBoxPos.Equals(target))\\n                            return res;\\n\\n                        //Now we can move the box, also record the new position(including the original position of the box)\\n                        var newPosition = Position.GetPositionsAsString(newBoxPos, newPlayerPos);\\n                        //Make sure the newPosition has never been visited before\\n                        if (visitedSet.Add(newPosition))\\n                        {\\n                            q.Enqueue(newPosition);\\n                        }\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        //DFS to find locations the player can reach\\n        public static void UpdatePlayerReachablePositions(char[][] grid, bool[,] canVisit, Position playerPosition, Position boxPosition)\\n        {\\n            if (!playerPosition.IsValid(grid) ||\\n                playerPosition.IsWall(grid) ||\\n                playerPosition.Equals(boxPosition) ||\\n                canVisit[playerPosition.X, playerPosition.Y])\\n                return;\\n            canVisit[playerPosition.X, playerPosition.Y] = true;\\n            foreach (var d in Dirs)\\n            {\\n                var newPlayerPos = new Position(playerPosition.X + d[0], playerPosition.Y + d[1]);\\n                UpdatePlayerReachablePositions(grid, canVisit, newPlayerPos, boxPosition);\\n            }\\n        }\\n\\n        public class Position\\n        {\\n            public int X { get; set; }\\n            public int Y { get; set; }\\n            public Position(int x, int y)\\n            {\\n                X = x;\\n                Y = y;\\n            }\\n            public static string GetPositionsAsString(Position box, Position storeKeeper)\\n            {\\n                return box.ToString() + \"|\" + storeKeeper.ToString();\\n            }\\n\\n            public static KeyValuePair<Position, Position> GetPositions(string num)\\n            {\\n                var pos = num.Split(\\'|\\');\\n                var res = new KeyValuePair<Position, Position>(new Position(pos[0], pos[1]), new Position(pos[2], pos[3]));\\n                return res;\\n            }\\n            public Position(string x, string y)\\n            {\\n                int.TryParse(x, out var x1);\\n                X = x1;\\n                int.TryParse(y, out var y1);\\n                Y = y1;\\n            }\\n            public override string ToString()\\n            {\\n                return X + \"|\" + Y;\\n            }\\n\\n            public bool IsValid(char[][] grid)\\n            {\\n                return X >= 0 && Y >= 0 && X < grid.Length && Y < grid[0].Length;\\n            }\\n\\n            public bool IsWall(char[][] grid)\\n            {\\n                return grid[X][Y] == \\'#\\';\\n            }\\n\\n            public bool Equals(Position position)\\n            {\\n                return X == position.X && Y == position.Y;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1352721,
                "title": "can-player-walk-through-target-cell-because-its-an-empty-cell",
                "content": "The following is possible only if the player can walk through Target. Why doesn\\'t the problem mention this? Is this a test of *something* in an actual interview? \\n\\n```\\n\\nExample 3:\\n\\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput: 5\\nExplanation:  push the box down, left, left, up and up.\\n\\n````",
                "solutionTags": [],
                "code": "```\\n\\nExample 3:\\n\\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput: 5\\nExplanation:  push the box down, left, left, up and up.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843952,
                "title": "c-bfs-with-deque",
                "content": "0-1 BFS implemented by deque: when the new state pushes the box, push it to the back of the deque; otherwise push front. In this way, every node we pop from the deque has the smallest number of pushes in the deque.\\n\\nPriority queue can also be used instead of deque. My results for both methods:\\ndeque: 120ms 16MB\\npriority queue: 760ms 8MB\\n\\n```\\nclass Solution {\\n    typedef pair<int, pair<int, int>> PIII;\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int M = grid.size();\\n        int N = grid[0].size();\\n        deque<PIII> dq;\\n        int box = -1, start = -1;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == \\'B\\') box = i*N+j;\\n                if (grid[i][j] == \\'S\\') start = i*N+j;  \\n            }\\n        }\\n        dq.push_back({0, {box, start}});\\n        vector<vector<bool>> visited(M*N, vector<bool>(M*N, false));\\n        int dir1[] = {0, 0, -1, 1};\\n        int dir2[] = {-1, 1, 0, 0};\\n        while (!dq.empty()) {\\n            int push = dq.front().first;\\n            int b_pos = dq.front().second.first;\\n            int p_pos = dq.front().second.second;\\n            dq.pop_front();\\n            if (visited[b_pos][p_pos]) continue;\\n            visited[b_pos][p_pos] = true;\\n            int rb = b_pos/N, cb = b_pos%N;\\n            int rp = p_pos/N, cp = p_pos%N;\\n            for (int i = 0; i < 4; i++) {\\n                int nr = rp + dir1[i];\\n                int nc = cp + dir2[i];\\n                if (nr < 0 || nc < 0 || nr >= M || nc >= N || grid[nr][nc] == \\'#\\') continue;\\n                if (nr*N+nc != b_pos) {\\n                    dq.push_front({push, {b_pos, nr*N+nc}});\\n                }\\n                else { // move box\\n                    int nrb = rb + dir1[i], ncb = cb+dir2[i];\\n                    if (nrb < 0 || ncb < 0 || nrb >= M || ncb >= N || grid[nrb][ncb] == \\'#\\') continue;\\n                    if (grid[nrb][ncb] == \\'T\\') return push+1;\\n                    dq.push_back({push+1, {nrb*N+ncb, b_pos}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef pair<int, pair<int, int>> PIII;\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int M = grid.size();\\n        int N = grid[0].size();\\n        deque<PIII> dq;\\n        int box = -1, start = -1;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == \\'B\\') box = i*N+j;\\n                if (grid[i][j] == \\'S\\') start = i*N+j;  \\n            }\\n        }\\n        dq.push_back({0, {box, start}});\\n        vector<vector<bool>> visited(M*N, vector<bool>(M*N, false));\\n        int dir1[] = {0, 0, -1, 1};\\n        int dir2[] = {-1, 1, 0, 0};\\n        while (!dq.empty()) {\\n            int push = dq.front().first;\\n            int b_pos = dq.front().second.first;\\n            int p_pos = dq.front().second.second;\\n            dq.pop_front();\\n            if (visited[b_pos][p_pos]) continue;\\n            visited[b_pos][p_pos] = true;\\n            int rb = b_pos/N, cb = b_pos%N;\\n            int rp = p_pos/N, cp = p_pos%N;\\n            for (int i = 0; i < 4; i++) {\\n                int nr = rp + dir1[i];\\n                int nc = cp + dir2[i];\\n                if (nr < 0 || nc < 0 || nr >= M || nc >= N || grid[nr][nc] == \\'#\\') continue;\\n                if (nr*N+nc != b_pos) {\\n                    dq.push_front({push, {b_pos, nr*N+nc}});\\n                }\\n                else { // move box\\n                    int nrb = rb + dir1[i], ncb = cb+dir2[i];\\n                    if (nrb < 0 || ncb < 0 || nrb >= M || ncb >= N || grid[nrb][ncb] == \\'#\\') continue;\\n                    if (grid[nrb][ncb] == \\'T\\') return push+1;\\n                    dq.push_back({push+1, {nrb*N+ncb, b_pos}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793854,
                "title": "java-bfs-with-comments",
                "content": "1. visited array is 3 dimentional, box x,y index and last move direction.\\n2. as we have 4 direcitons, when ierate, just use index as direction.\\n3. for each next move, we need to check next box position and next player position is in bound.\\n4. an additional bfs function to check the player can mvoe the target player postion or not.\\n```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][4];\\n        final int[] target = new int[2];\\n        final int[] player = new int[2];\\n        final int[] box = new int[2];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if (grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if (grid[i][j] == \\'B\\') {\\n                    box[0] = i;\\n                    box[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        queue.offer(new int[]{\\n                box[0], box[1], player[0], player[1]\\n        });\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            // iterate by level\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == target[0] &&\\n                        current[1] == target[1]\\n                ) {\\n                    return level;\\n                }\\n                for (int index = 0; index < 4; index++) {\\n                    // next box position\\n                    final int nextX = current[0] + deltaX[index];\\n                    final int nextY = current[1] + deltaY[index];\\n                    // next player position is opposite to box\\n                    final int playerX = current[0] - deltaX[index];\\n                    final int playerY = current[1] - deltaY[index];\\n                    // next box player should be in bound, equals to \\'.\\'\\n                    // player can move from current player position to (playerX,playerY)\\n                    if (inBound(grid, nextX, nextY) &&\\n                            inBound(grid, playerX, playerY) &&\\n                            !visited[nextX][nextY][index] &&\\n                            grid[nextX][nextY] == \\'.\\' &&\\n                            grid[playerX][playerY] == \\'.\\' &&\\n                            canPush(grid, playerX, playerY, current[2], current[3], current[0], current[1])\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, playerX, playerY});\\n                        visited[nextX][nextY][index] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    // as we mark box as \\'.\\', so we need its position to block player\\'s moves\\n    private boolean canPush(\\n            char[][] grid,\\n            int targetX,\\n            int targetY,\\n            int x,\\n            int y,\\n            int boxX,\\n            int boxY) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][] visited =\\n                new boolean[grid.length][grid[0].length];\\n        queue.offer(new int[]{x, y});\\n        visited[x][y] = true;\\n        while (!queue.isEmpty()) {\\n            final int[] current = queue.poll();\\n            if (current[0] == targetX && current[1] == targetY) {\\n                return true;\\n            }\\n            for (int index = 0; index < 4; index++) {\\n                final int nextX = current[0] + deltaX[index];\\n                final int nextY = current[1] + deltaY[index];\\n                if (inBound(grid, nextX, nextY) &&\\n                        !visited[nextX][nextY] &&\\n                        grid[nextX][nextY] == \\'.\\' &&\\n                        (nextX != boxX || nextY != boxY)\\n                ) {\\n                    queue.offer(new int[]{nextX, nextY});\\n                    visited[nextX][nextY] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n    private final int[] deltaX = {0, 0, -1, 1};\\n    private final int[] deltaY = {-1, 1, 0, 0};\\n\\n    private boolean inBound(\\n            char[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][4];\\n        final int[] target = new int[2];\\n        final int[] player = new int[2];\\n        final int[] box = new int[2];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if (grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if (grid[i][j] == \\'B\\') {\\n                    box[0] = i;\\n                    box[1] = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        queue.offer(new int[]{\\n                box[0], box[1], player[0], player[1]\\n        });\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            // iterate by level\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == target[0] &&\\n                        current[1] == target[1]\\n                ) {\\n                    return level;\\n                }\\n                for (int index = 0; index < 4; index++) {\\n                    // next box position\\n                    final int nextX = current[0] + deltaX[index];\\n                    final int nextY = current[1] + deltaY[index];\\n                    // next player position is opposite to box\\n                    final int playerX = current[0] - deltaX[index];\\n                    final int playerY = current[1] - deltaY[index];\\n                    // next box player should be in bound, equals to \\'.\\'\\n                    // player can move from current player position to (playerX,playerY)\\n                    if (inBound(grid, nextX, nextY) &&\\n                            inBound(grid, playerX, playerY) &&\\n                            !visited[nextX][nextY][index] &&\\n                            grid[nextX][nextY] == \\'.\\' &&\\n                            grid[playerX][playerY] == \\'.\\' &&\\n                            canPush(grid, playerX, playerY, current[2], current[3], current[0], current[1])\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, playerX, playerY});\\n                        visited[nextX][nextY][index] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    // as we mark box as \\'.\\', so we need its position to block player\\'s moves\\n    private boolean canPush(\\n            char[][] grid,\\n            int targetX,\\n            int targetY,\\n            int x,\\n            int y,\\n            int boxX,\\n            int boxY) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][] visited =\\n                new boolean[grid.length][grid[0].length];\\n        queue.offer(new int[]{x, y});\\n        visited[x][y] = true;\\n        while (!queue.isEmpty()) {\\n            final int[] current = queue.poll();\\n            if (current[0] == targetX && current[1] == targetY) {\\n                return true;\\n            }\\n            for (int index = 0; index < 4; index++) {\\n                final int nextX = current[0] + deltaX[index];\\n                final int nextY = current[1] + deltaY[index];\\n                if (inBound(grid, nextX, nextY) &&\\n                        !visited[nextX][nextY] &&\\n                        grid[nextX][nextY] == \\'.\\' &&\\n                        (nextX != boxX || nextY != boxY)\\n                ) {\\n                    queue.offer(new int[]{nextX, nextY});\\n                    visited[nextX][nextY] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n    private final int[] deltaX = {0, 0, -1, 1};\\n    private final int[] deltaY = {-1, 1, 0, 0};\\n\\n    private boolean inBound(\\n            char[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488157,
                "title": "simple-java-solution-union-find-bfs",
                "content": "```\\nclass Solution {\\n    //1. \\u5E76\\u67E5\\u96C6\\u5224\\u65AD\\u80FD\\u5426\\u5230\\u8FBE\\n    //2. BFS \\u7BB1\\u5B50\\n    int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int minPushBox(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int px = 0, py = 0, tx = 0, ty = 0, bx = 0, by = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                } else if(grid[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                } else if(grid[i][j] == \\'T\\') {\\n                    tx = i;\\n                    ty = j;\\n                }\\n            }\\n        }\\n        int[] parent = buildSet(grid, m, n);\\n        int sp = find(parent, px * n + py);\\n        int st = find(parent, tx * n + ty);\\n        int sb = find(parent, bx * n + by);\\n        if(!(sp == st && st == sb)) return -1;\\n        \\n        Queue<int[]> que = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        que.offer(new int[]{bx * n + by, px * n + py});\\n        visited.add((bx * n + by) + \",\" + (px * n + py));\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] p = que.poll();\\n                if(p[0] == tx * n + ty) return res;\\n                int r = p[0] / n, c = p[0] % n;\\n                \\n                char ch = grid[r][c];\\n                grid[r][c] = \\'#\\';\\n                parent = buildSet(grid, m, n);\\n                for(int[] d : dir) {\\n                    int x = r + d[0], y = c + d[1];\\n                    int rx = r - d[0], ry = c - d[1];\\n                    \\n                    if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != \\'#\\' && rx >= 0 && rx < m && ry >= 0 && ry < n && grid[rx][ry] != \\'#\\') {\\n                        \\n                        if(find(parent, rx * n + ry) == find(parent, p[1]) && visited.add((x * n + y) + \",\" + p[0])) {\\n                            que.offer(new int[]{x * n + y, p[0]});\\n                        }\\n                    }\\n                }\\n                grid[r][c] = (char)(res + \\'0\\');\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private int[] buildSet(char[][] grid, int m, int n) {\\n        int[] parent = new int[m * n];\\n        for(int i = 0; i < m * n; i++) parent[i] = i;\\n        for(int i = 0; i < m; i ++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != \\'#\\') {\\n                    if(i > 0 && grid[i-1][j] != \\'#\\') union(parent, (i-1)*n+j, i*n+j);\\n                    if(i < m-1 && grid[i+1][j] != \\'#\\') union(parent, (i+1)*n+j, i*n+j);\\n                    if(j > 0 && grid[i][j-1] != \\'#\\') union(parent, i*n+j-1, i*n+j);\\n                    if(j < n-1 && grid[i][j+1] != \\'#\\') union(parent, i*n+j+1, i*n+j);\\n                }\\n            }\\n        }\\n        return parent;\\n    }\\n    \\n    private void union(int[] p, int a, int b) {\\n        int pa = find(p, a), pb = find(p, b);\\n        if(pa != pb) p[pa] = pb;\\n    }\\n    \\n    private int find(int[] p, int a) {\\n        return p[a] = p[a] == a ? a : find(p, p[a]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1. \\u5E76\\u67E5\\u96C6\\u5224\\u65AD\\u80FD\\u5426\\u5230\\u8FBE\\n    //2. BFS \\u7BB1\\u5B50\\n    int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int minPushBox(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int px = 0, py = 0, tx = 0, ty = 0, bx = 0, by = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                } else if(grid[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                } else if(grid[i][j] == \\'T\\') {\\n                    tx = i;\\n                    ty = j;\\n                }\\n            }\\n        }\\n        int[] parent = buildSet(grid, m, n);\\n        int sp = find(parent, px * n + py);\\n        int st = find(parent, tx * n + ty);\\n        int sb = find(parent, bx * n + by);\\n        if(!(sp == st && st == sb)) return -1;\\n        \\n        Queue<int[]> que = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        que.offer(new int[]{bx * n + by, px * n + py});\\n        visited.add((bx * n + by) + \",\" + (px * n + py));\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] p = que.poll();\\n                if(p[0] == tx * n + ty) return res;\\n                int r = p[0] / n, c = p[0] % n;\\n                \\n                char ch = grid[r][c];\\n                grid[r][c] = \\'#\\';\\n                parent = buildSet(grid, m, n);\\n                for(int[] d : dir) {\\n                    int x = r + d[0], y = c + d[1];\\n                    int rx = r - d[0], ry = c - d[1];\\n                    \\n                    if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != \\'#\\' && rx >= 0 && rx < m && ry >= 0 && ry < n && grid[rx][ry] != \\'#\\') {\\n                        \\n                        if(find(parent, rx * n + ry) == find(parent, p[1]) && visited.add((x * n + y) + \",\" + p[0])) {\\n                            que.offer(new int[]{x * n + y, p[0]});\\n                        }\\n                    }\\n                }\\n                grid[r][c] = (char)(res + \\'0\\');\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private int[] buildSet(char[][] grid, int m, int n) {\\n        int[] parent = new int[m * n];\\n        for(int i = 0; i < m * n; i++) parent[i] = i;\\n        for(int i = 0; i < m; i ++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != \\'#\\') {\\n                    if(i > 0 && grid[i-1][j] != \\'#\\') union(parent, (i-1)*n+j, i*n+j);\\n                    if(i < m-1 && grid[i+1][j] != \\'#\\') union(parent, (i+1)*n+j, i*n+j);\\n                    if(j > 0 && grid[i][j-1] != \\'#\\') union(parent, i*n+j-1, i*n+j);\\n                    if(j < n-1 && grid[i][j+1] != \\'#\\') union(parent, i*n+j+1, i*n+j);\\n                }\\n            }\\n        }\\n        return parent;\\n    }\\n    \\n    private void union(int[] p, int a, int b) {\\n        int pa = find(p, a), pb = find(p, b);\\n        if(pa != pb) p[pa] = pb;\\n    }\\n    \\n    private int find(int[] p, int a) {\\n        return p[a] = p[a] == a ? a : find(p, p[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437507,
                "title": "c-readable-bfs-bfs-with-inline-comments",
                "content": "```\\npublic class Solution {\\n    private char[][] grid;\\n    private Position boxPosition;\\n    private int[] directions = new int[] {0, 1, 0, -1, 0};\\n    \\n    // Represents coordinate with Equals() implemented by default for Queues\\n    public struct Position\\n    {\\n        public int X;\\n        public int Y;\\n        \\n        public Position(int x, int y)\\n        {\\n            X = x;\\n            Y = y;\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"[{Y},{X}]\";\\n        }\\n    }\\n    \\n    // State, what we will store in BFS for the box\\n    public struct BoxAndPlayerPosition\\n    {\\n        public Position boxPosition;\\n        public Position playerPosition;\\n        \\n        public BoxAndPlayerPosition(Position boxPosition, Position playerPosition)\\n        {\\n            this.boxPosition = boxPosition;\\n            this.playerPosition = playerPosition;\\n        }\\n        \\n        // where the box will be moved along with player. Player will fill in the box spot, box will be moved 1 cell in corresponding direction\\n        public BoxAndPlayerPosition NextPosition()\\n        {\\n            if (boxPosition.X == playerPosition.X)\\n            {\\n                if (playerPosition.Y < boxPosition.Y)\\n                    return new BoxAndPlayerPosition(new Position(boxPosition.X, boxPosition.Y + 1), new Position(playerPosition.X, playerPosition.Y + 1));\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X, boxPosition.Y - 1), new Position(playerPosition.X, playerPosition.Y - 1));\\n            }\\n            \\n            if (playerPosition.X < boxPosition.X)\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X + 1, boxPosition.Y), new Position(playerPosition.X + 1, playerPosition.Y));\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X - 1, boxPosition.Y), new Position(playerPosition.X - 1, playerPosition.Y));\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"b:{boxPosition};p:{playerPosition}\";\\n        }\\n    }\\n    \\n    // BFS for player, can player move to the position, assuming box is just another \\'wall\\' for the sake of this method\\n    private bool PlayerCanMove(BoxAndPlayerPosition current, Position target)\\n    {\\n        Queue<Position> queue = new Queue<Position>();\\n        boxPosition = current.boxPosition;\\n        \\n        queue.Enqueue(current.playerPosition);\\n        HashSet<Position> visited = new HashSet<Position>();\\n        visited.Add(current.playerPosition);\\n        \\n        while (queue.Count > 0)\\n        {\\n            Position currPos = queue.Dequeue();\\n            if (currPos.Equals(target))\\n            {\\n                return true;\\n            }\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int newX = currPos.X + directions[i];\\n                int newY = currPos.Y + directions[i+1];\\n                Position newPos = new Position(newX, newY);\\n                \\n                if (CanMoveTo(newPos, visited))\\n                {\\n                    visited.Add(newPos);\\n                    queue.Enqueue(newPos);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private bool CanMoveTo(Position pos, HashSet<Position> visited)\\n    {\\n        return (IsValidAndEmpty(pos) && !visited.Contains(pos) &&\\n               !pos.Equals(boxPosition));\\n    }\\n    \\n    private bool IsValidAndEmpty(Position pos)\\n    {\\n        int x = pos.X;\\n        int y = pos.Y;\\n        \\n        return x >= 0 && x < grid[0].Length && y >= 0 && y < grid.Length && grid[y][x] == \\'.\\';\\n    }\\n    \\n    public int MinPushBox(char[][] grid) {\\n        this.grid = grid;\\n        \\n        Position boxPosition = FindBox(grid);\\n        Position playerPosition = FindPlayer(grid);\\n        Position targetPosition = FindTarget(grid);\\n        \\n        // since we captured box, player, and target positions, we change it to \\'.\\' so it would be easier to check whether we can move in a cell\\n        grid[boxPosition.Y][boxPosition.X] = \\'.\\';\\n        grid[playerPosition.Y][playerPosition.X] = \\'.\\';\\n        grid[targetPosition.Y][targetPosition.X] = \\'.\\';\\n        \\n        int pushes = 0;\\n        Queue<BoxAndPlayerPosition> queue = new Queue<BoxAndPlayerPosition>();\\n        HashSet<BoxAndPlayerPosition> visited = new HashSet<BoxAndPlayerPosition>();\\n        \\n        BoxAndPlayerPosition initial = new BoxAndPlayerPosition(boxPosition, playerPosition);\\n        \\n        // adding all possible starting points: box and positions to the left, right, top, bottom to the box.\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int newX = boxPosition.X + directions[i];\\n            int newY = boxPosition.Y + directions[i+1];\\n            Position target = new Position(newX, newY);\\n            \\n            if (!IsValidAndEmpty(target) || !PlayerCanMove(initial, target))\\n                continue;\\n            \\n            var start = new BoxAndPlayerPosition(boxPosition, target);\\n            queue.Enqueue(start);\\n            visited.Add(start);\\n        }\\n        \\n        // BFS for player and the box\\n        while (queue.Count > 0)\\n        {\\n            var length = queue.Count;\\n            \\n            for (int j = 0; j < length; j++)\\n            {\\n                BoxAndPlayerPosition current = queue.Dequeue();\\n                if (current.boxPosition.Equals(targetPosition))\\n                    return pushes;\\n\\n                var next = current.NextPosition();\\n                var nextBox = next.boxPosition;\\n\\n                if (!visited.Contains(next) && IsValidAndEmpty(nextBox)) \\n                {\\n                    queue.Enqueue(next);\\n                    visited.Add(next);\\n\\n                    // when we add another position \\'next\\' for the player and the box, we need to try to add all possible positions for the player if the box is fixed. So whenever we move the box, always add all positions for the player as well around the box to the queue.\\n                    for (int i = 0; i < 4; i++)\\n                    {\\n                        int newX = nextBox.X + directions[i];\\n                        int newY = nextBox.Y + directions[i+1];\\n                        Position newPosition = new Position(newX, newY);\\n\\n                        if (!next.playerPosition.Equals(newPosition) && IsValidAndEmpty(newPosition) && PlayerCanMove(next, newPosition))\\n                        {\\n                            var start = new BoxAndPlayerPosition(nextBox, newPosition);\\n                            if (!visited.Contains(start))\\n                            {\\n                                queue.Enqueue(start);\\n                                visited.Add(start);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            pushes++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private Position FindBox(char[][] grid)\\n    {\\n        return Find(grid, \\'B\\');\\n    }\\n    private Position FindPlayer(char[][] grid)\\n    {\\n        return Find(grid, \\'S\\');\\n    }\\n    private Position FindTarget(char[][] grid)\\n    {\\n        return Find(grid, \\'T\\');\\n    }\\n    \\n    private Position Find(char[][] grid, char c)\\n    {\\n        for (int i = 0; i < grid.Length; i++)\\n            for (int j = 0; j < grid[0].Length; j++)\\n                if (grid[i][j] == c)\\n                    return new Position(j, i);\\n        \\n        throw new Exception();\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private char[][] grid;\\n    private Position boxPosition;\\n    private int[] directions = new int[] {0, 1, 0, -1, 0};\\n    \\n    // Represents coordinate with Equals() implemented by default for Queues\\n    public struct Position\\n    {\\n        public int X;\\n        public int Y;\\n        \\n        public Position(int x, int y)\\n        {\\n            X = x;\\n            Y = y;\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"[{Y},{X}]\";\\n        }\\n    }\\n    \\n    // State, what we will store in BFS for the box\\n    public struct BoxAndPlayerPosition\\n    {\\n        public Position boxPosition;\\n        public Position playerPosition;\\n        \\n        public BoxAndPlayerPosition(Position boxPosition, Position playerPosition)\\n        {\\n            this.boxPosition = boxPosition;\\n            this.playerPosition = playerPosition;\\n        }\\n        \\n        // where the box will be moved along with player. Player will fill in the box spot, box will be moved 1 cell in corresponding direction\\n        public BoxAndPlayerPosition NextPosition()\\n        {\\n            if (boxPosition.X == playerPosition.X)\\n            {\\n                if (playerPosition.Y < boxPosition.Y)\\n                    return new BoxAndPlayerPosition(new Position(boxPosition.X, boxPosition.Y + 1), new Position(playerPosition.X, playerPosition.Y + 1));\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X, boxPosition.Y - 1), new Position(playerPosition.X, playerPosition.Y - 1));\\n            }\\n            \\n            if (playerPosition.X < boxPosition.X)\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X + 1, boxPosition.Y), new Position(playerPosition.X + 1, playerPosition.Y));\\n                return new BoxAndPlayerPosition(new Position(boxPosition.X - 1, boxPosition.Y), new Position(playerPosition.X - 1, playerPosition.Y));\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"b:{boxPosition};p:{playerPosition}\";\\n        }\\n    }\\n    \\n    // BFS for player, can player move to the position, assuming box is just another \\'wall\\' for the sake of this method\\n    private bool PlayerCanMove(BoxAndPlayerPosition current, Position target)\\n    {\\n        Queue<Position> queue = new Queue<Position>();\\n        boxPosition = current.boxPosition;\\n        \\n        queue.Enqueue(current.playerPosition);\\n        HashSet<Position> visited = new HashSet<Position>();\\n        visited.Add(current.playerPosition);\\n        \\n        while (queue.Count > 0)\\n        {\\n            Position currPos = queue.Dequeue();\\n            if (currPos.Equals(target))\\n            {\\n                return true;\\n            }\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int newX = currPos.X + directions[i];\\n                int newY = currPos.Y + directions[i+1];\\n                Position newPos = new Position(newX, newY);\\n                \\n                if (CanMoveTo(newPos, visited))\\n                {\\n                    visited.Add(newPos);\\n                    queue.Enqueue(newPos);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private bool CanMoveTo(Position pos, HashSet<Position> visited)\\n    {\\n        return (IsValidAndEmpty(pos) && !visited.Contains(pos) &&\\n               !pos.Equals(boxPosition));\\n    }\\n    \\n    private bool IsValidAndEmpty(Position pos)\\n    {\\n        int x = pos.X;\\n        int y = pos.Y;\\n        \\n        return x >= 0 && x < grid[0].Length && y >= 0 && y < grid.Length && grid[y][x] == \\'.\\';\\n    }\\n    \\n    public int MinPushBox(char[][] grid) {\\n        this.grid = grid;\\n        \\n        Position boxPosition = FindBox(grid);\\n        Position playerPosition = FindPlayer(grid);\\n        Position targetPosition = FindTarget(grid);\\n        \\n        // since we captured box, player, and target positions, we change it to \\'.\\' so it would be easier to check whether we can move in a cell\\n        grid[boxPosition.Y][boxPosition.X] = \\'.\\';\\n        grid[playerPosition.Y][playerPosition.X] = \\'.\\';\\n        grid[targetPosition.Y][targetPosition.X] = \\'.\\';\\n        \\n        int pushes = 0;\\n        Queue<BoxAndPlayerPosition> queue = new Queue<BoxAndPlayerPosition>();\\n        HashSet<BoxAndPlayerPosition> visited = new HashSet<BoxAndPlayerPosition>();\\n        \\n        BoxAndPlayerPosition initial = new BoxAndPlayerPosition(boxPosition, playerPosition);\\n        \\n        // adding all possible starting points: box and positions to the left, right, top, bottom to the box.\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int newX = boxPosition.X + directions[i];\\n            int newY = boxPosition.Y + directions[i+1];\\n            Position target = new Position(newX, newY);\\n            \\n            if (!IsValidAndEmpty(target) || !PlayerCanMove(initial, target))\\n                continue;\\n            \\n            var start = new BoxAndPlayerPosition(boxPosition, target);\\n            queue.Enqueue(start);\\n            visited.Add(start);\\n        }\\n        \\n        // BFS for player and the box\\n        while (queue.Count > 0)\\n        {\\n            var length = queue.Count;\\n            \\n            for (int j = 0; j < length; j++)\\n            {\\n                BoxAndPlayerPosition current = queue.Dequeue();\\n                if (current.boxPosition.Equals(targetPosition))\\n                    return pushes;\\n\\n                var next = current.NextPosition();\\n                var nextBox = next.boxPosition;\\n\\n                if (!visited.Contains(next) && IsValidAndEmpty(nextBox)) \\n                {\\n                    queue.Enqueue(next);\\n                    visited.Add(next);\\n\\n                    // when we add another position \\'next\\' for the player and the box, we need to try to add all possible positions for the player if the box is fixed. So whenever we move the box, always add all positions for the player as well around the box to the queue.\\n                    for (int i = 0; i < 4; i++)\\n                    {\\n                        int newX = nextBox.X + directions[i];\\n                        int newY = nextBox.Y + directions[i+1];\\n                        Position newPosition = new Position(newX, newY);\\n\\n                        if (!next.playerPosition.Equals(newPosition) && IsValidAndEmpty(newPosition) && PlayerCanMove(next, newPosition))\\n                        {\\n                            var start = new BoxAndPlayerPosition(nextBox, newPosition);\\n                            if (!visited.Contains(start))\\n                            {\\n                                queue.Enqueue(start);\\n                                visited.Add(start);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            pushes++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private Position FindBox(char[][] grid)\\n    {\\n        return Find(grid, \\'B\\');\\n    }\\n    private Position FindPlayer(char[][] grid)\\n    {\\n        return Find(grid, \\'S\\');\\n    }\\n    private Position FindTarget(char[][] grid)\\n    {\\n        return Find(grid, \\'T\\');\\n    }\\n    \\n    private Position Find(char[][] grid, char c)\\n    {\\n        for (int i = 0; i < grid.Length; i++)\\n            for (int j = 0; j < grid[0].Length; j++)\\n                if (grid[i][j] == c)\\n                    return new Position(j, i);\\n        \\n        throw new Exception();\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433649,
                "title": "non-nested-bfs-with-o-1-connectivity-check",
                "content": "Up to now all these solutions here contain nested BFS/DFS/Union inside the outer BFS to check if the person can reach certain position. However, this can be done in O(1) time with some preprocessing.\\nNotice that after the first push, we only need to consider states with the person next to the box. In that case, we only check connnectivity between two cells both adjacent to the box with the box cell treated as a wall. Now we can see that under this circumstance the two cells are connected if and only if they are in a loop, or more generally, a 2-connected component. With a DFS we can get all the 2-connected components, and given that a cell can be in no more than 4 components, we can check connectivity in O(1) time.\\nFinally we get an algorithm of one-pass DFS and one-pass BFS, with complexity O(nm) rather than O((nm)^2) for nested algorithms. The result is python3 48ms, faster than 99.70%, and the rest 0.3% is a cheater. It should be able to deal with n,m~500 cases.\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        n,m=len(grid),len(grid[0])\\n        bcc=[[set() for j in range(m)] for i in range(n)]\\n        low=[[0]*m for i in range(n)]\\n        dfn=[[0]*m for i in range(n)]\\n        T,cnt,st=0,0,[]\\n        def dfs(i,j):\\n            nonlocal T,cnt\\n            if not (0<=i<n and 0<=j<m) or grid[i][j]==\\'#\\':\\n                return -1\\n            elif dfn[i][j]>0:\\n                return 0\\n            st.append((i,j))\\n            T+=1\\n            low[i][j]=dfn[i][j]=T\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                temp=dfs(x,y)\\n                if temp==-1:\\n                    continue\\n                elif temp==0:\\n                    low[i][j]=min(low[i][j],dfn[x][y])\\n                    continue\\n                if low[x][y]>=dfn[i][j]:\\n                    cnt+=1\\n                    while True:\\n                        a,b=st.pop()\\n                        bcc[a][b].add(cnt)\\n                        if (a,b)==(x,y):\\n                            break\\n                    bcc[i][j].add(cnt)\\n                low[i][j]=min(low[i][j],low[x][y])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]!=\\'#\\' and dfn[i][j]==0:\\n                    dfs(i,j)\\n                if grid[i][j]==\\'S\\':\\n                    sx,sy=i,j\\n                elif grid[i][j]==\\'T\\':\\n                    tx,ty=i,j\\n                elif grid[i][j]==\\'B\\':\\n                    bx,by=i,j\\n        q0,visited=[(sx,sy)],[[0]*m for i in range(n)]\\n        visited[sx][sy]=1\\n        while q0:\\n            temp=[]\\n            for x,y in q0:\\n                for px,py in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\\n                    if 0<=px<n and 0<=py<m and grid[px][py] in \\'.T\\' and visited[px][py]==0:\\n                        visited[px][py]=1\\n                        temp.append((px,py))\\n            q0=temp\\n        q=[(bx,by,x,y) for x,y in [(bx+1,by),(bx-1,by),(bx,by+1),(bx,by-1)] if visited[x][y]]\\n        visited,ans=set(q),0\\n        while q:\\n            temp=[]\\n            for x1,y1,x2,y2 in q:\\n                #print(x1,y1,x2,y2)\\n                if (x1,y1)==(tx,ty):\\n                    return ans\\n                x1,y1,x2,y2=x1*2-x2,y1*2-y2,x1,y1\\n                if not (0<=x1<n and 0<=y1<m) or grid[x1][y1]==\\'#\\':\\n                    continue\\n                for px,py in [(x1+1,y1),(x1-1,y1),(x1,y1+1),(x1,y1-1)]:\\n                    #print(px,py)\\n                    if (0<=px<n and 0<=py<m) and (grid[px][py]!=\\'#\\') and (bcc[px][py]&bcc[x2][y2]) and ((x1,y1,px,py) not in visited):\\n                        nxt=x1,y1,px,py\\n                        visited.add(nxt)\\n                        temp.append(nxt)\\n            q,ans=temp,ans+1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        n,m=len(grid),len(grid[0])\\n        bcc=[[set() for j in range(m)] for i in range(n)]\\n        low=[[0]*m for i in range(n)]\\n        dfn=[[0]*m for i in range(n)]\\n        T,cnt,st=0,0,[]\\n        def dfs(i,j):\\n            nonlocal T,cnt\\n            if not (0<=i<n and 0<=j<m) or grid[i][j]==\\'#\\':\\n                return -1\\n            elif dfn[i][j]>0:\\n                return 0\\n            st.append((i,j))\\n            T+=1\\n            low[i][j]=dfn[i][j]=T\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                temp=dfs(x,y)\\n                if temp==-1:\\n                    continue\\n                elif temp==0:\\n                    low[i][j]=min(low[i][j],dfn[x][y])\\n                    continue\\n                if low[x][y]>=dfn[i][j]:\\n                    cnt+=1\\n                    while True:\\n                        a,b=st.pop()\\n                        bcc[a][b].add(cnt)\\n                        if (a,b)==(x,y):\\n                            break\\n                    bcc[i][j].add(cnt)\\n                low[i][j]=min(low[i][j],low[x][y])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]!=\\'#\\' and dfn[i][j]==0:\\n                    dfs(i,j)\\n                if grid[i][j]==\\'S\\':\\n                    sx,sy=i,j\\n                elif grid[i][j]==\\'T\\':\\n                    tx,ty=i,j\\n                elif grid[i][j]==\\'B\\':\\n                    bx,by=i,j\\n        q0,visited=[(sx,sy)],[[0]*m for i in range(n)]\\n        visited[sx][sy]=1\\n        while q0:\\n            temp=[]\\n            for x,y in q0:\\n                for px,py in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\\n                    if 0<=px<n and 0<=py<m and grid[px][py] in \\'.T\\' and visited[px][py]==0:\\n                        visited[px][py]=1\\n                        temp.append((px,py))\\n            q0=temp\\n        q=[(bx,by,x,y) for x,y in [(bx+1,by),(bx-1,by),(bx,by+1),(bx,by-1)] if visited[x][y]]\\n        visited,ans=set(q),0\\n        while q:\\n            temp=[]\\n            for x1,y1,x2,y2 in q:\\n                #print(x1,y1,x2,y2)\\n                if (x1,y1)==(tx,ty):\\n                    return ans\\n                x1,y1,x2,y2=x1*2-x2,y1*2-y2,x1,y1\\n                if not (0<=x1<n and 0<=y1<m) or grid[x1][y1]==\\'#\\':\\n                    continue\\n                for px,py in [(x1+1,y1),(x1-1,y1),(x1,y1+1),(x1,y1-1)]:\\n                    #print(px,py)\\n                    if (0<=px<n and 0<=py<m) and (grid[px][py]!=\\'#\\') and (bcc[px][py]&bcc[x2][y2]) and ((x1,y1,px,py) not in visited):\\n                        nxt=x1,y1,px,py\\n                        visited.add(nxt)\\n                        temp.append(nxt)\\n            q,ans=temp,ans+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669132,
                "title": "o-n-m-solution-using-tarjan-to-precauculate-biconnected-component",
                "content": "# Approach\\nBefore we start, I need to mention, this is definately not an answer interviewer expects you to implement. Feel free to ignore this solution if you are just preparing for interview. They are not hiring you to paticipate coding competition.\\n\\nI shared this solution just want to give some inspiration to those people who have a little coding competition experience. O(n*m) is possible! Not just O(bfs*bfs).\\n\\nSteps:\\n1. we consider each cell as vertex, 4 direction as edge, build a graph.\\n2. calculate [biconnected component](https://en.wikipedia.org/wiki/Biconnected_component) for this graph.\\n3. When box is at any cell, it can be considered as: removing one vertex in graph, we know the removed vertex is a cut vertex or not, thus we can use O(1) time to know if 4 cells next to it can reach each other.\\n4. dp[i][j][k], mean the minimal push we need to use to reach a situation that box is at [i][j], and person is at direction[k] to the box.\\n5. BFS to calculate the dp to get dp[target_x][target_y][0-4].\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nstruct node\\n{\\n    int x,y;\\n    node(int xx,int yy)\\n    {\\n        x=xx;y=yy;\\n    }\\n};\\n\\nstruct node2\\n{\\n    int x,y,dir;\\n    node2(int xx,int yy,int dd)\\n    {\\n        x=xx;y=yy;dir=dd;\\n    }\\n};\\n\\nclass Solution {\\n    vector<vector<int>>dfn;\\n    vector<vector<vector<int>>>color;\\n    vector<vector<vector<bool>>>cover;\\n    vector<vector<int>>mi;\\n    vector<vector<char>>grid;\\n    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int id;\\n    int sid;\\n    vector<vector<bool>>ins;\\n    stack<node2>st;\\n    int n,m;\\n    \\n    void dfs(int x,int y,int last_dir)\\n    {\\n        dfn[x][y]=mi[x][y]=++id;\\n        int i;\\n\\n        for(i=0;i<4;i++)\\n        {\\n            if((last_dir^1)==i)\\n            {\\n                continue;\\n            }\\n            int nx,ny;\\n            nx=x+dir[i][0];\\n            ny=y+dir[i][1];\\n\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\')\\n            {\\n                if(cover[x][y][i]==0 && cover[nx][ny][i^1]==0)\\n                {\\n                    st.push(node2(x,y,i));\\n                    cover[x][y][i]=cover[nx][ny][i^1]=1;\\n                }\\n                if(dfn[nx][ny]==0)\\n                {\\n                    dfs(nx,ny,i);\\n                    if(dfn[x][y]<=mi[nx][ny])\\n                    {\\n                        node2 now(0,0,0);\\n                        do\\n                        {\\n                            now=st.top();\\n                            st.pop();\\n                            color[now.x][now.y][now.dir]=sid;\\n                            color[now.x+dir[now.dir][0]][now.y+dir[now.dir][1]][now.dir^1]=sid;\\n                        }while(now.x!=x || now.y!=y || now.dir!=i);\\n                        sid++;\\n                    }\\n                    mi[x][y]=min(mi[x][y],mi[nx][ny]);\\n                }\\n                else // if(ins[nx][ny]==1)\\n                {\\n                    mi[x][y]=min(mi[x][y],dfn[nx][ny]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        this->grid=grid;\\n        n=grid.size();\\n        m=grid[0].size();\\n        int i,j,k;\\n        dfn=vector<vector<int>>(n,vector<int>(m,0));\\n        color=vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(4,0)));\\n        cover=vector<vector<vector<bool>>>(n,vector<vector<bool>>(m,vector<bool>(4,0)));\\n        mi=vector<vector<int>>(n,vector<int>(m,INT_MAX));\\n        ins=vector<vector<bool>>(n,vector<bool>(m,0));\\n        id=0;\\n        sid=1;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(grid[i][j]!=\\'#\\' && dfn[i][j]==0)\\n                {\\n                    dfs(i,j,-1);\\n                }\\n            }\\n        }\\n\\n        int sx,sy,ex,ey,bx,by;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    sx=i;sy=j;\\n                }\\n\\n                if(grid[i][j]==\\'T\\')\\n                {\\n                    ex=i;ey=j;\\n                }\\n\\n                if(grid[i][j]==\\'B\\')\\n                {\\n                    bx=i;by=j;\\n                }\\n            }\\n        }\\n\\n        ins=vector<vector<bool>>(n,vector<bool>(m,0));\\n        queue<node>q;\\n        queue<node2>q2;\\n        q.push(node(sx,sy));\\n        ins[sx][sy]=1;\\n        int dp[n][m][4];\\n        memset(dp,-1,sizeof(dp));\\n\\n        while(!q.empty())\\n        {\\n            node now=q.front();\\n            q.pop();\\n            for(i=0;i<4;i++)\\n            {\\n                int nx,ny;\\n                nx=now.x+dir[i][0];\\n                ny=now.y+dir[i][1];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m)\\n                {\\n                    if(nx==bx && ny==by)\\n                    {\\n                        dp[bx][by][i^1]=0;\\n                        q2.push(node2(bx,by,i^1));\\n                    }\\n                    else if(grid[nx][ny]!=\\'#\\' && ins[nx][ny]==0)\\n                    {\\n                        ins[nx][ny]=1;\\n                        q.push(node(nx,ny));\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q2.empty())\\n        {\\n            node2 now=q2.front();\\n            q2.pop();\\n\\n            if(now.x==ex && now.y==ey)\\n            {\\n                return dp[now.x][now.y][now.dir];\\n            }\\n            \\n            int nx,ny;\\n            \\n\\n            for(i=0;i<4;i++)\\n            {\\n                if(i==now.dir)\\n                {\\n                    continue;\\n                }\\n\\n                nx=now.x+dir[i][0];\\n                ny=now.y+dir[i][1];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\' && dp[now.x][now.y][i]==-1 && color[now.x][now.y][now.dir]==color[now.x][now.y][i])\\n                {\\n                    dp[now.x][now.y][i]=dp[now.x][now.y][now.dir];\\n                    q2.push(node2(now.x,now.y,i));\\n                }\\n            }\\n\\n            int d=(now.dir^1);\\n            nx=now.x+dir[d][0];\\n            ny=now.y+dir[d][1];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\' && dp[nx][ny][now.dir]==-1)\\n            {\\n                dp[nx][ny][now.dir]=dp[now.x][now.y][now.dir]+1;\\n                q2.push(node2(nx,ny,now.dir));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Biconnected Component"
                ],
                "code": "```\\nstruct node\\n{\\n    int x,y;\\n    node(int xx,int yy)\\n    {\\n        x=xx;y=yy;\\n    }\\n};\\n\\nstruct node2\\n{\\n    int x,y,dir;\\n    node2(int xx,int yy,int dd)\\n    {\\n        x=xx;y=yy;dir=dd;\\n    }\\n};\\n\\nclass Solution {\\n    vector<vector<int>>dfn;\\n    vector<vector<vector<int>>>color;\\n    vector<vector<vector<bool>>>cover;\\n    vector<vector<int>>mi;\\n    vector<vector<char>>grid;\\n    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int id;\\n    int sid;\\n    vector<vector<bool>>ins;\\n    stack<node2>st;\\n    int n,m;\\n    \\n    void dfs(int x,int y,int last_dir)\\n    {\\n        dfn[x][y]=mi[x][y]=++id;\\n        int i;\\n\\n        for(i=0;i<4;i++)\\n        {\\n            if((last_dir^1)==i)\\n            {\\n                continue;\\n            }\\n            int nx,ny;\\n            nx=x+dir[i][0];\\n            ny=y+dir[i][1];\\n\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\')\\n            {\\n                if(cover[x][y][i]==0 && cover[nx][ny][i^1]==0)\\n                {\\n                    st.push(node2(x,y,i));\\n                    cover[x][y][i]=cover[nx][ny][i^1]=1;\\n                }\\n                if(dfn[nx][ny]==0)\\n                {\\n                    dfs(nx,ny,i);\\n                    if(dfn[x][y]<=mi[nx][ny])\\n                    {\\n                        node2 now(0,0,0);\\n                        do\\n                        {\\n                            now=st.top();\\n                            st.pop();\\n                            color[now.x][now.y][now.dir]=sid;\\n                            color[now.x+dir[now.dir][0]][now.y+dir[now.dir][1]][now.dir^1]=sid;\\n                        }while(now.x!=x || now.y!=y || now.dir!=i);\\n                        sid++;\\n                    }\\n                    mi[x][y]=min(mi[x][y],mi[nx][ny]);\\n                }\\n                else // if(ins[nx][ny]==1)\\n                {\\n                    mi[x][y]=min(mi[x][y],dfn[nx][ny]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        this->grid=grid;\\n        n=grid.size();\\n        m=grid[0].size();\\n        int i,j,k;\\n        dfn=vector<vector<int>>(n,vector<int>(m,0));\\n        color=vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(4,0)));\\n        cover=vector<vector<vector<bool>>>(n,vector<vector<bool>>(m,vector<bool>(4,0)));\\n        mi=vector<vector<int>>(n,vector<int>(m,INT_MAX));\\n        ins=vector<vector<bool>>(n,vector<bool>(m,0));\\n        id=0;\\n        sid=1;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(grid[i][j]!=\\'#\\' && dfn[i][j]==0)\\n                {\\n                    dfs(i,j,-1);\\n                }\\n            }\\n        }\\n\\n        int sx,sy,ex,ey,bx,by;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    sx=i;sy=j;\\n                }\\n\\n                if(grid[i][j]==\\'T\\')\\n                {\\n                    ex=i;ey=j;\\n                }\\n\\n                if(grid[i][j]==\\'B\\')\\n                {\\n                    bx=i;by=j;\\n                }\\n            }\\n        }\\n\\n        ins=vector<vector<bool>>(n,vector<bool>(m,0));\\n        queue<node>q;\\n        queue<node2>q2;\\n        q.push(node(sx,sy));\\n        ins[sx][sy]=1;\\n        int dp[n][m][4];\\n        memset(dp,-1,sizeof(dp));\\n\\n        while(!q.empty())\\n        {\\n            node now=q.front();\\n            q.pop();\\n            for(i=0;i<4;i++)\\n            {\\n                int nx,ny;\\n                nx=now.x+dir[i][0];\\n                ny=now.y+dir[i][1];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m)\\n                {\\n                    if(nx==bx && ny==by)\\n                    {\\n                        dp[bx][by][i^1]=0;\\n                        q2.push(node2(bx,by,i^1));\\n                    }\\n                    else if(grid[nx][ny]!=\\'#\\' && ins[nx][ny]==0)\\n                    {\\n                        ins[nx][ny]=1;\\n                        q.push(node(nx,ny));\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q2.empty())\\n        {\\n            node2 now=q2.front();\\n            q2.pop();\\n\\n            if(now.x==ex && now.y==ey)\\n            {\\n                return dp[now.x][now.y][now.dir];\\n            }\\n            \\n            int nx,ny;\\n            \\n\\n            for(i=0;i<4;i++)\\n            {\\n                if(i==now.dir)\\n                {\\n                    continue;\\n                }\\n\\n                nx=now.x+dir[i][0];\\n                ny=now.y+dir[i][1];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\' && dp[now.x][now.y][i]==-1 && color[now.x][now.y][now.dir]==color[now.x][now.y][i])\\n                {\\n                    dp[now.x][now.y][i]=dp[now.x][now.y][now.dir];\\n                    q2.push(node2(now.x,now.y,i));\\n                }\\n            }\\n\\n            int d=(now.dir^1);\\n            nx=now.x+dir[d][0];\\n            ny=now.y+dir[d][1];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]!=\\'#\\' && dp[nx][ny][now.dir]==-1)\\n            {\\n                dp[nx][ny][now.dir]=dp[now.x][now.y][now.dir]+1;\\n                q2.push(node2(nx,ny,now.dir));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871367,
                "title": "c-bfs-top-down-dp-explained",
                "content": "# Intuition\\nPorted from C++: [1] https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/solutions/431144/cpp-bfs-dfs-solution/\\n# BFS\\nFirst we sweep the given grid for finding and storing the locations of the person, the box and the target.\\nNext we initialize a queue and a hashSet with the locations of the person and of the box.\\n```\\nQueue<PII> q = new();\\nHashSet<PII> visited = new();\\nq.Enqueue(new PII(new PI(px, py), new PI(bx, by)));\\nvisited.Add(new PII(new PI(px, py), new PI(bx, by)))\\n```\\nNext, we use that queue to do BFS traversal of the 2d grid. \\nEach queue element will have new box and person locations. Once an element is dequeued, the box location is updated on the grid to be maked as #.\\n```\\nvar f = q.Dequeue();\\n(px, py) = f.Item1;\\n(bx, by) = f.Item2;\\ngrid[bx][by] = \\'#\\';\\n```\\nBFS will find the shortest distance simply because of its radial-search pattern which considers nodes in order of their distance from the starting point [2]. It can be shown that, for unweighted graphs, the BFS is equivalent to Dijkstra\\'s algorithm and thus finds the shortest path in this circumstance. Thus the first path found will be the shortest path.\\n```\\nif(nbx == gx && nby == gy) {\\n    return ans;\\n}\\n```\\nValid() is used for validating a person location or a box location.\\n\\nOne smart feature of this implementation is the use of a HashSet for keeping track of visited cells. The HashSet keeps track of \"states\", not of visits. The HashSet has the location of a box and of person by the time the an element got into the queue, not simply if the grid cell was visited. That allows us to re-visit a certain cell if the \"state\" is different. \\n```\\nif(Valid(grid, nbx, nby)) {\\n    PII newState = new PII(new PI(bx, by), new PI(nbx, nby));\\n    if(!visited.Contains(newState)) {\\n        visited.Add(newState);\\n        q.Enqueue(newState);\\n    }\\n}\\n```\\n# Top-Down DP\\nCanReach() is the DFS part of this solution. It will find if a person can get to the \"back\" of the box. pplLoc is our memoization array (turning this into top-down dp).\\n```\\n bool CanReach(char[][] g, bool[,] pplLoc, int x, int y, int bx, int by) {\\n        if(!Valid(g, x, y) || pplLoc[x,y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x,y] = true;\\n        foreach(var d in Dirs) {\\n            if(CanReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n# Code\\n```\\npublic class Solution {\\n    public record class PI(int Item1, int Item2);\\n    public record class PII(PI Item1, PI Item2);\\n    public static int[][] Dirs = new int[][]{new int[]{0,1},\\n        new int[]{1,0}, new int[]{-1,0}, new int[]{0,-1}};\\n    public static int m,n;\\n    public int MinPushBox(char[][] grid) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        int px=0, py=0, bx=0, by=0, gx=0, gy=0;\\n        for(int x = 0; x < m; ++x) \\n        {\\n            for(int y = 0; y < n; ++y) \\n            {\\n                if(grid[x][y] == \\'S\\') {\\n                    px = x; \\n                    py = y;\\n                }else if(grid[x][y] == \\'B\\') {\\n                    bx = x; \\n                    by = y;\\n                }else if(grid[x][y] == \\'T\\') {\\n                    gx = x; \\n                    gy = y;\\n                }\\n            }\\n        }\\n        Queue<PII> q = new();\\n        HashSet<PII> visited = new();\\n        q.Enqueue(new PII(new PI(px, py), new PI(bx, by)));\\n        visited.Add(new PII(new PI(px, py), new PI(bx, by)));\\n        int ans = 0;\\n        while(q.Count > 0) {\\n            ans++;\\n            for(int l = q.Count; l > 0; --l) {\\n                var f = q.Dequeue();\\n                (px, py) = f.Item1;\\n                (bx, by) = f.Item2;\\n                grid[bx][by] = \\'#\\';\\n                foreach(var d in Dirs) {\\n                    var pplLoc = new bool[m,n];\\n                    if(CanReach(grid, pplLoc, px, py, bx - d[0], by - d[1])) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if(nbx == gx && nby == gy) {\\n                            return ans;\\n                        }\\n                        if(Valid(grid, nbx, nby)) {\\n                            PII newState = new PII(new PI(bx, by), new PI(nbx, nby));\\n                            if(!visited.Contains(newState)) {\\n                                visited.Add(newState);\\n                                q.Enqueue(newState);\\n                            }\\n                        }\\n                    }\\n                }\\n                grid[bx][by] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n  bool CanReach(char[][] g, bool[,] pplLoc, int x, int y, int bx, int by) {\\n        if(!Valid(g, x, y) || pplLoc[x,y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x,y] = true;\\n        foreach(var d in Dirs) {\\n            if(CanReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n  bool Valid(char[][] g, int x, int y) {\\n        if(x < 0 || x >= m || y < 0 || y >= n || g[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# References\\n[1] https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/solutions/431144/cpp-bfs-dfs-solution/\\n[2] https://stackoverflow.com/questions/8379785/how-does-a-breadth-first-search-work-when-looking-for-shortest-path",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nQueue<PII> q = new();\\nHashSet<PII> visited = new();\\nq.Enqueue(new PII(new PI(px, py), new PI(bx, by)));\\nvisited.Add(new PII(new PI(px, py), new PI(bx, by)))\\n```\n```\\nvar f = q.Dequeue();\\n(px, py) = f.Item1;\\n(bx, by) = f.Item2;\\ngrid[bx][by] = \\'#\\';\\n```\n```\\nif(nbx == gx && nby == gy) {\\n    return ans;\\n}\\n```\n```\\nif(Valid(grid, nbx, nby)) {\\n    PII newState = new PII(new PI(bx, by), new PI(nbx, nby));\\n    if(!visited.Contains(newState)) {\\n        visited.Add(newState);\\n        q.Enqueue(newState);\\n    }\\n}\\n```\n```\\n bool CanReach(char[][] g, bool[,] pplLoc, int x, int y, int bx, int by) {\\n        if(!Valid(g, x, y) || pplLoc[x,y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x,y] = true;\\n        foreach(var d in Dirs) {\\n            if(CanReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic class Solution {\\n    public record class PI(int Item1, int Item2);\\n    public record class PII(PI Item1, PI Item2);\\n    public static int[][] Dirs = new int[][]{new int[]{0,1},\\n        new int[]{1,0}, new int[]{-1,0}, new int[]{0,-1}};\\n    public static int m,n;\\n    public int MinPushBox(char[][] grid) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        int px=0, py=0, bx=0, by=0, gx=0, gy=0;\\n        for(int x = 0; x < m; ++x) \\n        {\\n            for(int y = 0; y < n; ++y) \\n            {\\n                if(grid[x][y] == \\'S\\') {\\n                    px = x; \\n                    py = y;\\n                }else if(grid[x][y] == \\'B\\') {\\n                    bx = x; \\n                    by = y;\\n                }else if(grid[x][y] == \\'T\\') {\\n                    gx = x; \\n                    gy = y;\\n                }\\n            }\\n        }\\n        Queue<PII> q = new();\\n        HashSet<PII> visited = new();\\n        q.Enqueue(new PII(new PI(px, py), new PI(bx, by)));\\n        visited.Add(new PII(new PI(px, py), new PI(bx, by)));\\n        int ans = 0;\\n        while(q.Count > 0) {\\n            ans++;\\n            for(int l = q.Count; l > 0; --l) {\\n                var f = q.Dequeue();\\n                (px, py) = f.Item1;\\n                (bx, by) = f.Item2;\\n                grid[bx][by] = \\'#\\';\\n                foreach(var d in Dirs) {\\n                    var pplLoc = new bool[m,n];\\n                    if(CanReach(grid, pplLoc, px, py, bx - d[0], by - d[1])) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if(nbx == gx && nby == gy) {\\n                            return ans;\\n                        }\\n                        if(Valid(grid, nbx, nby)) {\\n                            PII newState = new PII(new PI(bx, by), new PI(nbx, nby));\\n                            if(!visited.Contains(newState)) {\\n                                visited.Add(newState);\\n                                q.Enqueue(newState);\\n                            }\\n                        }\\n                    }\\n                }\\n                grid[bx][by] = \\'.\\';\\n            }\\n        }\\n        return -1;\\n    }\\n  bool CanReach(char[][] g, bool[,] pplLoc, int x, int y, int bx, int by) {\\n        if(!Valid(g, x, y) || pplLoc[x,y]) {\\n            return false;\\n        }\\n        if(bx == x && by == y) {\\n            return true;\\n        }\\n        pplLoc[x,y] = true;\\n        foreach(var d in Dirs) {\\n            if(CanReach(g, pplLoc, x + d[0], y + d[1], bx, by)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n  bool Valid(char[][] g, int x, int y) {\\n        if(x < 0 || x >= m || y < 0 || y >= n || g[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542023,
                "title": "all-edge-cases",
                "content": "There are many great solutions available for this post, here I will only focus on the edge cases where your code may go wrong.\\n\\nI will highly suggest to give it a try first otherwise this will ruin your experience \\u2639\\uFE0F.\\n\\nImp edge cases:\\n\\n1. Check whether there exists a path from person till the pos from which we are pushing the box.\\nTC:\\n```\\n   [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n    [\"#\",\"S\",\"#\",\".\",\"B\",\"T\",\"#\"],\\n    [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n\\tans = -1\\n```\\nHere out person S in blocked by obstacles so he can\\'t reach the box only hence ans will be -1\\n\\n2. We can\\'t pass through the box so mark the box as wall before starting a path search to the pos from where you are going to push the box then unmark it after the path search.\\nTC:\\n```\\n    [[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n     [\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\"_\",\".\",\".\",\".\",\"#\"],  <-\\n     [\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n\\t               ^\\n\\tans = 7\\n```\\ne.g.: pushing box (pos = [row][col]) up so we need to reach below the box (pos = [row+1][col]) \\n```\\n\\t\\tchar prev = grid[box_i][box_j];\\n\\t\\tgrid[box_i][box_j] = \\'#\\';\\n\\t\\tbool path = checkPath(person_i, person_j, box_i+1, box_j, grid);\\n\\t\\tgrid[box_i][box_j] = prev;\\n```\\n\\nWhile pushing when the box reached the pos represented by \"_\" then we can\\'t directly go to left part without pushing the box again to left.\\n\\n3. We may have to do extra push (like above) so visited vector with only i, j is not sufficient so we also maintain dir from which it is pushed.\\nWhat this means is you might push a box to left and then push it back to right to reach target, we need to do this if there is a case when we want to go right but its not possible without pushing the box further and then back to its original start.\\nTC:\\n```\\n    [[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n\\t ans = 8\\n```\\nIf you use a visited array of i, j then you won\\'t be able to push it back to the same place it was before. So we also maintain one more parameter dir. vis with i, j, and dir where dir represents from which dir it was pushed.\\n```\\nbool vis[rows][cols][dir]; \\nor\\nbool vis[n][m][4] // 4 directions\\n```\\n\\nMy code:\\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(int box_i, int box_j, int person_i, int person_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (box_i >= 0 && person_i >= 0 && box_j >= 0 && person_j >= 0 && box_i < n && person_i < n && box_j < m && person_j < m && grid[box_i][box_j] != \\'#\\' && grid[person_i][person_j] != \\'#\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    class Node {\\n    public:\\n        int box_i;\\n        int box_j;\\n        int person_i;\\n        int person_j;\\n\\n        Node() {\\n\\n        }\\n\\n        Node(int boxi, int boxj, int personi, int personj) {\\n            box_i = boxi;\\n            box_j = boxj;\\n            person_i = personi;\\n            person_j = personj;\\n        }\\n    };\\n\\n    bool checkPath(int start_i, int start_j, int target_i, int target_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, false));\\n        vector<pair<int, int>> dir = { {-1,0},{1,0},{0,-1},{0,1} };\\n\\n        queue<pair<int, int>> q;\\n        q.push({ start_i, start_j });\\n        vis[start_i][start_j] = true;\\n\\n        while (q.empty() == false) {\\n            auto t = q.front();\\n            q.pop();\\n            start_i = t.first;\\n            start_j = t.second;\\n\\n            if (start_i == target_i && start_j == target_j) {\\n                return true;\\n            }\\n\\n            for (auto it : dir) {\\n                int ni = start_i + it.first;\\n                int nj = start_j + it.second;\\n\\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != \\'#\\' && vis[ni][nj] == false) {\\n                    q.push({ ni, nj });\\n                    vis[ni][nj] = true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int getPush(int box_i, int box_j, int person_i, int person_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<vector<int>>> vis(n, vector<vector<int>>(m, vector<int>(5, false)));\\n\\n        int count = 0;\\n        Node curr(box_i, box_j, person_i, person_j);\\n        queue<Node> q;\\n        q.push(curr);\\n        vis[box_i][box_j][0] = true;\\n\\n        bool reached = false;\\n        while (q.empty() == false) {\\n            int sz = q.size();\\n\\n            for (int r = 0; r < sz; r++) {\\n                curr = q.front();\\n                q.pop();\\n\\n                box_i = curr.box_i;\\n                box_j = curr.box_j;\\n                person_i = curr.person_i;\\n                person_j = curr.person_j;\\n\\n                if (grid[box_i][box_j] == \\'T\\') {\\n                    reached = true;\\n                    break;\\n                }\\n\\n                // boxi, boxj, personi, personj\\n\\n                // push box up\\n                if (isValid(box_i - 1, box_j, box_i + 1, box_j, grid) && vis[box_i - 1][box_j][1] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i + 1, box_j, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i - 1, box_j, box_i, box_j));\\n                        vis[box_i - 1][box_j][1] = true;\\n                    }\\n                }\\n                // push box left\\n                if (isValid(box_i, box_j - 1, box_i, box_j + 1, grid) && vis[box_i][box_j - 1][2] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i, box_j + 1, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i, box_j - 1, box_i, box_j));\\n                        vis[box_i][box_j - 1][2] = true;\\n                    }\\n                }\\n                // push box right\\n                if (isValid(box_i, box_j + 1, box_i, box_j - 1, grid) && vis[box_i][box_j + 1][3] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i, box_j - 1, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i, box_j + 1, box_i, box_j));\\n                        vis[box_i][box_j + 1][3] = true;\\n                    }\\n                }\\n                // push box down\\n                if (isValid(box_i + 1, box_j, box_i - 1, box_j, grid) && vis[box_i + 1][box_j][4] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i - 1, box_j, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i + 1, box_j, box_i, box_j));\\n                        vis[box_i + 1][box_j][4] = true;\\n                    }\\n                }\\n            }\\n            if (reached) {\\n                break;\\n            }\\n            count++;\\n        }\\n        if (reached == false) return -1;\\n        return count;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int person_i, person_j;\\n        int box_i, box_j;\\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == \\'S\\') {\\n                person_i = i;\\n                person_j = j;\\n            }\\n            if (grid[i][j] == \\'B\\') {\\n                box_i = i;\\n                box_j = j;\\n            }\\n        }\\n\\n        return getPush(box_i, box_j, person_i, person_j, grid);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n   [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n    [\"#\",\"S\",\"#\",\".\",\"B\",\"T\",\"#\"],\\n    [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n\\tans = -1\\n```\n```\\n    [[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n     [\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\"_\",\".\",\".\",\".\",\"#\"],  <-\\n     [\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n\\t               ^\\n\\tans = 7\\n```\n```\\n\\t\\tchar prev = grid[box_i][box_j];\\n\\t\\tgrid[box_i][box_j] = \\'#\\';\\n\\t\\tbool path = checkPath(person_i, person_j, box_i+1, box_j, grid);\\n\\t\\tgrid[box_i][box_j] = prev;\\n```\n```\\n    [[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],\\n     [\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],\\n     [\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n\\t ans = 8\\n```\n```\\nbool vis[rows][cols][dir]; \\nor\\nbool vis[n][m][4] // 4 directions\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(int box_i, int box_j, int person_i, int person_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (box_i >= 0 && person_i >= 0 && box_j >= 0 && person_j >= 0 && box_i < n && person_i < n && box_j < m && person_j < m && grid[box_i][box_j] != \\'#\\' && grid[person_i][person_j] != \\'#\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    class Node {\\n    public:\\n        int box_i;\\n        int box_j;\\n        int person_i;\\n        int person_j;\\n\\n        Node() {\\n\\n        }\\n\\n        Node(int boxi, int boxj, int personi, int personj) {\\n            box_i = boxi;\\n            box_j = boxj;\\n            person_i = personi;\\n            person_j = personj;\\n        }\\n    };\\n\\n    bool checkPath(int start_i, int start_j, int target_i, int target_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, false));\\n        vector<pair<int, int>> dir = { {-1,0},{1,0},{0,-1},{0,1} };\\n\\n        queue<pair<int, int>> q;\\n        q.push({ start_i, start_j });\\n        vis[start_i][start_j] = true;\\n\\n        while (q.empty() == false) {\\n            auto t = q.front();\\n            q.pop();\\n            start_i = t.first;\\n            start_j = t.second;\\n\\n            if (start_i == target_i && start_j == target_j) {\\n                return true;\\n            }\\n\\n            for (auto it : dir) {\\n                int ni = start_i + it.first;\\n                int nj = start_j + it.second;\\n\\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != \\'#\\' && vis[ni][nj] == false) {\\n                    q.push({ ni, nj });\\n                    vis[ni][nj] = true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int getPush(int box_i, int box_j, int person_i, int person_j, vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<vector<int>>> vis(n, vector<vector<int>>(m, vector<int>(5, false)));\\n\\n        int count = 0;\\n        Node curr(box_i, box_j, person_i, person_j);\\n        queue<Node> q;\\n        q.push(curr);\\n        vis[box_i][box_j][0] = true;\\n\\n        bool reached = false;\\n        while (q.empty() == false) {\\n            int sz = q.size();\\n\\n            for (int r = 0; r < sz; r++) {\\n                curr = q.front();\\n                q.pop();\\n\\n                box_i = curr.box_i;\\n                box_j = curr.box_j;\\n                person_i = curr.person_i;\\n                person_j = curr.person_j;\\n\\n                if (grid[box_i][box_j] == \\'T\\') {\\n                    reached = true;\\n                    break;\\n                }\\n\\n                // boxi, boxj, personi, personj\\n\\n                // push box up\\n                if (isValid(box_i - 1, box_j, box_i + 1, box_j, grid) && vis[box_i - 1][box_j][1] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i + 1, box_j, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i - 1, box_j, box_i, box_j));\\n                        vis[box_i - 1][box_j][1] = true;\\n                    }\\n                }\\n                // push box left\\n                if (isValid(box_i, box_j - 1, box_i, box_j + 1, grid) && vis[box_i][box_j - 1][2] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i, box_j + 1, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i, box_j - 1, box_i, box_j));\\n                        vis[box_i][box_j - 1][2] = true;\\n                    }\\n                }\\n                // push box right\\n                if (isValid(box_i, box_j + 1, box_i, box_j - 1, grid) && vis[box_i][box_j + 1][3] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i, box_j - 1, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i, box_j + 1, box_i, box_j));\\n                        vis[box_i][box_j + 1][3] = true;\\n                    }\\n                }\\n                // push box down\\n                if (isValid(box_i + 1, box_j, box_i - 1, box_j, grid) && vis[box_i + 1][box_j][4] == false) {\\n                    char prev = grid[box_i][box_j];\\n                    grid[box_i][box_j] = \\'#\\';\\n                    bool path = checkPath(person_i, person_j, box_i - 1, box_j, grid);\\n                    grid[box_i][box_j] = prev;\\n                    if (path) {\\n                        q.push(Node(box_i + 1, box_j, box_i, box_j));\\n                        vis[box_i + 1][box_j][4] = true;\\n                    }\\n                }\\n            }\\n            if (reached) {\\n                break;\\n            }\\n            count++;\\n        }\\n        if (reached == false) return -1;\\n        return count;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int person_i, person_j;\\n        int box_i, box_j;\\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == \\'S\\') {\\n                person_i = i;\\n                person_j = j;\\n            }\\n            if (grid[i][j] == \\'B\\') {\\n                box_i = i;\\n                box_j = j;\\n            }\\n        }\\n\\n        return getPush(box_i, box_j, person_i, person_j, grid);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397767,
                "title": "python-3-0-1-bfs-clean-code",
                "content": "\\tclass Solution:\\n\\t\\tdef minPushBox(self, grid: List[List[str]]) -> int:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif grid[i][j]==\\'S\\':\\n\\t\\t\\t\\t\\t\\tplayer=[i,j]\\n\\t\\t\\t\\t\\telif grid[i][j]==\\'T\\':\\n\\t\\t\\t\\t\\t\\ttarget=[i,j]\\n\\t\\t\\t\\t\\telif grid[i][j]==\\'B\\':\\n\\t\\t\\t\\t\\t\\tbox=[i,j]\\n\\t\\t\\tq=deque([[player[0],player[1],box[0],box[1],0]])\\n\\t\\t\\tvis=set([(player[0],player[1],box[0],box[1])])\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\ti,j,bi,bj,steps=q.pop()\\n\\t\\t\\t\\tif [bi,bj]==target:\\n\\t\\t\\t\\t\\treturn steps\\n\\t\\t\\t\\tfor dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:\\n\\t\\t\\t\\t\\tx,y=i+dx,j+dy\\n\\t\\t\\t\\t\\tif 0<=x<n and 0<=y<m and grid[x][y]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\tif (x,y)==(bi,bj):\\n\\t\\t\\t\\t\\t\\t\\tif 0<=bi+dx<n and 0<=bj+dy<m and grid[bi+dx][bj+dy]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\t\\t\\tif not (x,y,bi+dx,bj+dy) in vis:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi+dx,bj+dy))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tq.appendleft([x,y,bi+dx,bj+dy,steps+1])\\n\\t\\t\\t\\t\\t\\telif (x,y,bi,bj) not in vis:\\n\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi,bj))\\n\\t\\t\\t\\t\\t\\t\\tq.append([x,y,bi,bj,steps])\\n\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minPushBox(self, grid: List[List[str]]) -> int:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif grid[i][j]==\\'S\\':\\n\\t\\t\\t\\t\\t\\tplayer=[i,j]\\n\\t\\t\\t\\t\\telif grid[i][j]==\\'T\\':\\n\\t\\t\\t\\t\\t\\ttarget=[i,j]\\n\\t\\t\\t\\t\\telif grid[i][j]==\\'B\\':\\n\\t\\t\\t\\t\\t\\tbox=[i,j]\\n\\t\\t\\tq=deque([[player[0],player[1],box[0],box[1],0]])\\n\\t\\t\\tvis=set([(player[0],player[1],box[0],box[1])])\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\ti,j,bi,bj,steps=q.pop()\\n\\t\\t\\t\\tif [bi,bj]==target:\\n\\t\\t\\t\\t\\treturn steps\\n\\t\\t\\t\\tfor dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:\\n\\t\\t\\t\\t\\tx,y=i+dx,j+dy\\n\\t\\t\\t\\t\\tif 0<=x<n and 0<=y<m and grid[x][y]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\tif (x,y)==(bi,bj):\\n\\t\\t\\t\\t\\t\\t\\tif 0<=bi+dx<n and 0<=bj+dy<m and grid[bi+dx][bj+dy]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\t\\t\\tif not (x,y,bi+dx,bj+dy) in vis:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi+dx,bj+dy))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tq.appendleft([x,y,bi+dx,bj+dy,steps+1])\\n\\t\\t\\t\\t\\t\\telif (x,y,bi,bj) not in vis:\\n\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi,bj))\\n\\t\\t\\t\\t\\t\\t\\tq.append([x,y,bi,bj,steps])\\n\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 1965893,
                "title": "python-double-bfs",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        in_bounds = lambda grid, i, j : 0 <= i < len(grid) and 0 <= j < len(grid[0])\\n        \\n        dirs = [\\n            (1, 0),\\n            (-1, 0),\\n            (0, 1),\\n            (0, -1)\\n        ]\\n\\n        def mover_bfs(grid, mover, behind_box, box):\\n            \\n            queue = deque([mover])\\n            visited = set()\\n            \\n            while queue:\\n                move_pos = queue.popleft()\\n                \\n                if move_pos in visited:\\n                    continue\\n                    \\n                visited.add(move_pos)\\n                \\n                if move_pos == behind_box:\\n                    return True\\n                x, y = move_pos\\n                for d in dirs:\\n                    r, c = x + d[0], y + d[1]\\n                    \\n                    if not in_bounds(grid, r, c) or (r, c) == box or grid[r][c] == \\'#\\':\\n                        continue\\n                    \\n                    queue.append((r, c))\\n            return False\\n\\n        def box_bfs(grid, box, start, dest):\\n            queue = deque([ (box, start, 0) ])\\n            visited = set()\\n            while queue:\\n                box_pos, mover_pos, moves = queue.popleft()\\n                if box_pos == dest:\\n                    return moves\\n                \\n                if (box_pos, mover_pos) in visited:\\n                    continue\\n                \\n                visited.add((box_pos, mover_pos))\\n\\n                x, y = box_pos\\n                x1, y1 = mover_pos\\n\\n                for d in dirs:\\n                    r, c = x + d[0], y + d[1]\\n                    \\n                    if not in_bounds(grid, r, c) or grid[r][c] == \\'#\\' or (r, c) in visited:\\n                        continue\\n                    \\n                    next_mover_pos = x + (-1) * d[0], y + (-1) * d[1]\\n                    if not mover_bfs(grid, mover_pos, next_mover_pos, box_pos):\\n                        continue\\n                    queue.append(((r, c), next_mover_pos, moves + 1))\\n            return -1\\n\\n        start = None\\n        box = None\\n        target = None\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \\'S\\':\\n                    start = (r, c)\\n                elif grid[r][c] == \\'T\\':\\n                    target = (r, c)\\n                elif grid[r][c] == \\'B\\':\\n                    box = (r, c)\\n        \\n        return box_bfs(grid, box, start, target)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        in_bounds = lambda grid, i, j : 0 <= i < len(grid) and 0 <= j < len(grid[0])\\n        \\n        dirs = [\\n            (1, 0),\\n            (-1, 0),\\n            (0, 1),\\n            (0, -1)\\n        ]\\n\\n        def mover_bfs(grid, mover, behind_box, box):\\n            \\n            queue = deque([mover])\\n            visited = set()\\n            \\n            while queue:\\n                move_pos = queue.popleft()\\n                \\n                if move_pos in visited:\\n                    continue\\n                    \\n                visited.add(move_pos)\\n                \\n                if move_pos == behind_box:\\n                    return True\\n                x, y = move_pos\\n                for d in dirs:\\n                    r, c = x + d[0], y + d[1]\\n                    \\n                    if not in_bounds(grid, r, c) or (r, c) == box or grid[r][c] == \\'#\\':\\n                        continue\\n                    \\n                    queue.append((r, c))\\n            return False\\n\\n        def box_bfs(grid, box, start, dest):\\n            queue = deque([ (box, start, 0) ])\\n            visited = set()\\n            while queue:\\n                box_pos, mover_pos, moves = queue.popleft()\\n                if box_pos == dest:\\n                    return moves\\n                \\n                if (box_pos, mover_pos) in visited:\\n                    continue\\n                \\n                visited.add((box_pos, mover_pos))\\n\\n                x, y = box_pos\\n                x1, y1 = mover_pos\\n\\n                for d in dirs:\\n                    r, c = x + d[0], y + d[1]\\n                    \\n                    if not in_bounds(grid, r, c) or grid[r][c] == \\'#\\' or (r, c) in visited:\\n                        continue\\n                    \\n                    next_mover_pos = x + (-1) * d[0], y + (-1) * d[1]\\n                    if not mover_bfs(grid, mover_pos, next_mover_pos, box_pos):\\n                        continue\\n                    queue.append(((r, c), next_mover_pos, moves + 1))\\n            return -1\\n\\n        start = None\\n        box = None\\n        target = None\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \\'S\\':\\n                    start = (r, c)\\n                elif grid[r][c] == \\'T\\':\\n                    target = (r, c)\\n                elif grid[r][c] == \\'B\\':\\n                    box = (r, c)\\n        \\n        return box_bfs(grid, box, start, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737258,
                "title": "c-easy-implementation-bfs-bfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n     int arr[4]= {0,0,1,-1};\\n    int brr[4]={1,-1,0,0};\\n    bool chk (vector<vector<char>>& grid, int reachx,int reachy,int bx,int by,int sx,int sy)\\n    {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>>vis(r,vector<int>(c,-1));\\n        queue<pair<int,int>>qq;\\n        qq.push({sx,sy});\\n        vis[sx][sy] =1;\\n       \\n        while(qq.size()>0)\\n        {\\n            auto it = qq.front();\\n            qq.pop();\\n            int x = it.first;\\n            int y=  it.second;\\n            if(x==reachx && y==reachy)\\n            { \\n                return true;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y+brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && vis[xx][yy]==-1 && grid[xx][yy]!=\\'#\\'&& !(xx==bx&& yy==by))\\n                {\\n                    vis[xx][yy] = 1;\\n                    qq.push({xx,yy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) \\n    {\\n       int r = grid.size();\\n       int c  = grid[0].size();\\n        int box_x ;\\n        int box_y;\\n        int t_x;\\n        int t_y;\\n        int s_x;\\n        int s_y;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    s_x  = i;\\n                    s_y  = j;\\n                }\\n                else if(grid[i][j]==\\'B\\')\\n                {\\n                    box_x = i;\\n                    box_y=j;\\n                }\\n                else if(grid[i][j]==\\'T\\')\\n                {\\n                    t_x = i;\\n                    t_y = j;\\n                }\\n            }\\n        }\\n         grid[t_x][t_y]=\\'.\\';\\n        grid[s_x][s_y]=\\'.\\';\\n     \\n        queue<vector<int>>q;\\n        q.push({box_x,box_y,s_x,s_y});\\n        set<vector<int>>stt;\\n        int ans =  0;\\n        \\n        while(q.size()>0)\\n        {\\n            int si = q.size();\\n            while(si--)\\n            {\\n            auto it = q.front();\\n            q.pop();\\n            int x = it[0];\\n            int y = it[1];\\n            int ssx = it[2];\\n            int ssy = it[3];\\n            if(x==t_x && y==t_y)\\n            {\\n                return ans;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xx_new = x + arr[i];\\n                int yy_new = y +brr[i];\\n                int sx = x-arr[i];\\n                int sy = y-brr[i];\\n                if(xx_new>=0 && xx_new<r && sx>=0 && sx<r && yy_new>=0 && yy_new<c && sy>=0 && sy<c && grid[xx_new][yy_new]!=\\'#\\' && !stt.count({xx_new,yy_new,sx,sy}) )\\n                { \\n                    bool chkk = chk(grid,sx,sy,x,y,ssx,ssy);\\n                    if(chkk)\\n                    {\\n                        stt.insert({xx_new,yy_new,sx,sy});    \\n                        q.push({xx_new,yy_new,sx,sy});\\n                    }\\n                }\\n            }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int arr[4]= {0,0,1,-1};\\n    int brr[4]={1,-1,0,0};\\n    bool chk (vector<vector<char>>& grid, int reachx,int reachy,int bx,int by,int sx,int sy)\\n    {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>>vis(r,vector<int>(c,-1));\\n        queue<pair<int,int>>qq;\\n        qq.push({sx,sy});\\n        vis[sx][sy] =1;\\n       \\n        while(qq.size()>0)\\n        {\\n            auto it = qq.front();\\n            qq.pop();\\n            int x = it.first;\\n            int y=  it.second;\\n            if(x==reachx && y==reachy)\\n            { \\n                return true;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y+brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && vis[xx][yy]==-1 && grid[xx][yy]!=\\'#\\'&& !(xx==bx&& yy==by))\\n                {\\n                    vis[xx][yy] = 1;\\n                    qq.push({xx,yy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) \\n    {\\n       int r = grid.size();\\n       int c  = grid[0].size();\\n        int box_x ;\\n        int box_y;\\n        int t_x;\\n        int t_y;\\n        int s_x;\\n        int s_y;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    s_x  = i;\\n                    s_y  = j;\\n                }\\n                else if(grid[i][j]==\\'B\\')\\n                {\\n                    box_x = i;\\n                    box_y=j;\\n                }\\n                else if(grid[i][j]==\\'T\\')\\n                {\\n                    t_x = i;\\n                    t_y = j;\\n                }\\n            }\\n        }\\n         grid[t_x][t_y]=\\'.\\';\\n        grid[s_x][s_y]=\\'.\\';\\n     \\n        queue<vector<int>>q;\\n        q.push({box_x,box_y,s_x,s_y});\\n        set<vector<int>>stt;\\n        int ans =  0;\\n        \\n        while(q.size()>0)\\n        {\\n            int si = q.size();\\n            while(si--)\\n            {\\n            auto it = q.front();\\n            q.pop();\\n            int x = it[0];\\n            int y = it[1];\\n            int ssx = it[2];\\n            int ssy = it[3];\\n            if(x==t_x && y==t_y)\\n            {\\n                return ans;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xx_new = x + arr[i];\\n                int yy_new = y +brr[i];\\n                int sx = x-arr[i];\\n                int sy = y-brr[i];\\n                if(xx_new>=0 && xx_new<r && sx>=0 && sx<r && yy_new>=0 && yy_new<c && sy>=0 && sy<c && grid[xx_new][yy_new]!=\\'#\\' && !stt.count({xx_new,yy_new,sx,sy}) )\\n                { \\n                    bool chkk = chk(grid,sx,sy,x,y,ssx,ssy);\\n                    if(chkk)\\n                    {\\n                        stt.insert({xx_new,yy_new,sx,sy});    \\n                        q.push({xx_new,yy_new,sx,sy});\\n                    }\\n                }\\n            }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676266,
                "title": "python-solution-with-detailed-thinking",
                "content": "### Background\\nIn this problem, we are given a grid, there\\'re 4 types of element:\\n* player - \\'S\\'\\n* box - \\'B\\'\\n* obstacle - \\'#\\'\\n* floor - \\'.\\'\\n\\nplayer need to push the box to the final target position, our target is to find the mininum push.\\n\\nThis is a variant of finding the shortest path from start to the end in a 2-D grid.  In general, this is a unweighted graph search problem. \\n* We start from the begining\\n* at each position, we search at 4 direction\\n* before goes to each position, we need to check if the next position\\n\\t* out of boundary\\n\\t* is an obstacle or not\\n\\t* if visited or not\\n* we should stop when reaching to the target position\\n\\n#### BFS \\n\\n```\\ndirs = {(1,0), (0,1), (-1,0), (0,-1)}\\nqueue = collections.deque([(start, 0)])\\nvisited = {start}\\n\\nwhile queue:\\n\\t(i, j), step = queue.popleft()\\n\\tif (i,j) == target:\\n\\t\\treturn step\\n\\tfor dx, dy in dirs:\\n\\t\\tx, y = i+dx, j+dy\\n\\t\\tif isValid(x,y,visited) is False:\\n\\t\\t\\tcontinue\\n\\t\\tvisited.add((x,y))\\n\\t\\tqueue.append((x,y,step+1))\\nreturn -1\\n```\\n\\n#### DFS\\n* i, j the current position\\n* visited: from the start to the end, which position are visited\\n\\n```\\ndef dfs(i, j, visited):\\n\\tif (i,j) == target:\\n\\t\\treturn 0\\n\\tif isValid(i,j,visited) is False:\\n\\t\\treturn float(\\'inf\\')\\n\\tstep = float(\\'inf\\')\\n\\tfor dx, dy in dirs:\\n\\t\\tx, y = i+dx, j+dy\\n\\t\\tvisited.add((x,y))\\n\\t\\tstep = min(step, dfs(x,y,visited))\\n\\t\\tvisisted.remove((x,y))\\n\\treturn step\\n```\\n\\n#### helper function\\n```\\ndef isValid(i,j,visisted)\\n\\tif i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\\n\\t\\treturn False\\n\\tif (i,j) in visited:\\n\\t\\treturn False\\n\\tif grid[i][j] == \\'#\\':\\n\\t\\treturn False\\n\\treturn True\\n```\\n\\n### Analysis\\nThe difference of this problem is that\\n* there\\'s a player, if the player wants to move the box, he/she needs\\n\\t*  be able to be on another side of the box\\n\\nSo for the box, at each position, it can move to 4 directions, but for each directions, the player should be able to reach to another position, so our target is to find if the player can be able to reach to that position. How to do so? This is also a traditional graph search problem. But the only problem is player could not cross the box.That\\'s say, box is also an obstacle.\\n\\nSo the basic structure of the solution is two BFS/DFS. \\nThe status of the search be be described by \\n* player position\\n* box position\\n\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\'\\'\\'\\n            find start pos of box, start pos of player, and the pos of target \\n            for box start from the begining, do the graph search\\n                if reach to the target, return step\\n                else: for each 4 dires, also find the player\\'s next pos\\n                    check if next box and next player pos is valid or not\\n                    also check if next box and next player pos has been recorded before\\n                    then push the info for the next move\\n\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0])\\n        dirs = {(0,1), (1,0), (0,-1), (-1,0)}\\n        \\n        def get_initials():\\n            box, player, target = None, None, None\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == \\'S\\':\\n                        player = (i,j)\\n                    if grid[i][j] == \\'B\\':\\n                        box = (i,j)\\n                    if grid[i][j] == \\'T\\':\\n                        target = (i,j)\\n            \\n            return box, player, target\\n        \\n        def isReacheable(box_i, box_j, player_i, player_j, nxt_player_i, nxt_player_j):\\n            tmp = grid[box_i][box_j]\\n            grid[box_i][box_j] = \\'#\\'\\n            res = _isReacheable(player_i, player_j, nxt_player_i, nxt_player_j)\\n            grid[box_i][box_j] = tmp\\n            return res\\n        \\n        def _isReacheable(start_i, start_j, end_i, end_j):\\n            queue = collections.deque([(start_i, start_j)])\\n            visited = {(start_i, start_j)}\\n            while queue:\\n                i, j = queue.popleft()\\n                if (i,j) == (end_i, end_j):\\n                    return True\\n                for dx, dy in dirs:\\n                    x, y = i+dx, j+dy\\n                    if _isValidPos(x, y, visited):\\n                        queue.append((x,y))\\n                        visited.add((x,y))\\n            return False\\n        \\n        def _isValidPos(x,y,visited):\\n            return 0<=x<m and 0<=y<n and (x,y) not in visited and grid[x][y] != \\'#\\'\\n        \\n        def isValidPos(box_i, box_j, player_i, player_j, visited):\\n            def isInBoundary(i,j):\\n                return  0<=i<m and 0<=j<n\\n            \\n            return isInBoundary(box_i, box_j) and isInBoundary(player_i, player_j)\\\\\\n                    and (box_i, box_j, player_i, player_j) not in visited\\\\\\n                    and grid[box_i][box_j] != \\'#\\' and grid[player_i][player_j] != \\'#\\'\\n        \\n        \\n        (box_i, box_j), (player_i, player_j), target = get_initials()\\n        grid[box_i][box_j] = \\'.\\'\\n        grid[player_i][player_j] = \\'.\\'\\n        \\n        queue = collections.deque([(box_i, box_j, player_i, player_j, 0)])\\n        visited = {(box_i, box_j, player_i, player_j)}\\n        while queue:\\n            b_i, b_j, p_i, p_j, step = queue.popleft()\\n            if (b_i, b_j) == target:\\n                return step\\n            for dx, dy in dirs:\\n                nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j = b_i+dx, b_j+dy, b_i-dx, b_j-dy\\n                if isValidPos(nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j, visited) is False:\\n                    continue\\n                if isReacheable(b_i, b_j, p_i, p_j, nxt_p_i, nxt_p_j) is False:\\n                    continue\\n                queue.append((nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j, step+1))\\n                visited.add((nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ndirs = {(1,0), (0,1), (-1,0), (0,-1)}\\nqueue = collections.deque([(start, 0)])\\nvisited = {start}\\n\\nwhile queue:\\n\\t(i, j), step = queue.popleft()\\n\\tif (i,j) == target:\\n\\t\\treturn step\\n\\tfor dx, dy in dirs:\\n\\t\\tx, y = i+dx, j+dy\\n\\t\\tif isValid(x,y,visited) is False:\\n\\t\\t\\tcontinue\\n\\t\\tvisited.add((x,y))\\n\\t\\tqueue.append((x,y,step+1))\\nreturn -1\\n```\n```\\ndef dfs(i, j, visited):\\n\\tif (i,j) == target:\\n\\t\\treturn 0\\n\\tif isValid(i,j,visited) is False:\\n\\t\\treturn float(\\'inf\\')\\n\\tstep = float(\\'inf\\')\\n\\tfor dx, dy in dirs:\\n\\t\\tx, y = i+dx, j+dy\\n\\t\\tvisited.add((x,y))\\n\\t\\tstep = min(step, dfs(x,y,visited))\\n\\t\\tvisisted.remove((x,y))\\n\\treturn step\\n```\n```\\ndef isValid(i,j,visisted)\\n\\tif i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\\n\\t\\treturn False\\n\\tif (i,j) in visited:\\n\\t\\treturn False\\n\\tif grid[i][j] == \\'#\\':\\n\\t\\treturn False\\n\\treturn True\\n```\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\'\\'\\'\\n            find start pos of box, start pos of player, and the pos of target \\n            for box start from the begining, do the graph search\\n                if reach to the target, return step\\n                else: for each 4 dires, also find the player\\'s next pos\\n                    check if next box and next player pos is valid or not\\n                    also check if next box and next player pos has been recorded before\\n                    then push the info for the next move\\n\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0])\\n        dirs = {(0,1), (1,0), (0,-1), (-1,0)}\\n        \\n        def get_initials():\\n            box, player, target = None, None, None\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == \\'S\\':\\n                        player = (i,j)\\n                    if grid[i][j] == \\'B\\':\\n                        box = (i,j)\\n                    if grid[i][j] == \\'T\\':\\n                        target = (i,j)\\n            \\n            return box, player, target\\n        \\n        def isReacheable(box_i, box_j, player_i, player_j, nxt_player_i, nxt_player_j):\\n            tmp = grid[box_i][box_j]\\n            grid[box_i][box_j] = \\'#\\'\\n            res = _isReacheable(player_i, player_j, nxt_player_i, nxt_player_j)\\n            grid[box_i][box_j] = tmp\\n            return res\\n        \\n        def _isReacheable(start_i, start_j, end_i, end_j):\\n            queue = collections.deque([(start_i, start_j)])\\n            visited = {(start_i, start_j)}\\n            while queue:\\n                i, j = queue.popleft()\\n                if (i,j) == (end_i, end_j):\\n                    return True\\n                for dx, dy in dirs:\\n                    x, y = i+dx, j+dy\\n                    if _isValidPos(x, y, visited):\\n                        queue.append((x,y))\\n                        visited.add((x,y))\\n            return False\\n        \\n        def _isValidPos(x,y,visited):\\n            return 0<=x<m and 0<=y<n and (x,y) not in visited and grid[x][y] != \\'#\\'\\n        \\n        def isValidPos(box_i, box_j, player_i, player_j, visited):\\n            def isInBoundary(i,j):\\n                return  0<=i<m and 0<=j<n\\n            \\n            return isInBoundary(box_i, box_j) and isInBoundary(player_i, player_j)\\\\\\n                    and (box_i, box_j, player_i, player_j) not in visited\\\\\\n                    and grid[box_i][box_j] != \\'#\\' and grid[player_i][player_j] != \\'#\\'\\n        \\n        \\n        (box_i, box_j), (player_i, player_j), target = get_initials()\\n        grid[box_i][box_j] = \\'.\\'\\n        grid[player_i][player_j] = \\'.\\'\\n        \\n        queue = collections.deque([(box_i, box_j, player_i, player_j, 0)])\\n        visited = {(box_i, box_j, player_i, player_j)}\\n        while queue:\\n            b_i, b_j, p_i, p_j, step = queue.popleft()\\n            if (b_i, b_j) == target:\\n                return step\\n            for dx, dy in dirs:\\n                nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j = b_i+dx, b_j+dy, b_i-dx, b_j-dy\\n                if isValidPos(nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j, visited) is False:\\n                    continue\\n                if isReacheable(b_i, b_j, p_i, p_j, nxt_p_i, nxt_p_j) is False:\\n                    continue\\n                queue.append((nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j, step+1))\\n                visited.add((nxt_b_i, nxt_b_j, nxt_p_i, nxt_p_j))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575511,
                "title": "java-bfs-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n        int[] box = new int[2];\\n        int[] player = new int[2];\\n        int[] target = new int[2];\\n        Map<String, Integer> steps = new HashMap<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'B\\') {\\n                    box = new int[] {i, j};\\n                } else if (grid[i][j] == \\'S\\') {\\n                    player = new int[] {i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = new int[] {i, j};\\n                }\\n            }\\n        }\\n        int[] dx = new int[] {0, 0, 1, -1};\\n        int[] dy = new int[] {1, -1, 0, 0};\\n        // so in BFS, instead of save a single point, save both box and player together\\n        String start = encode(box[0], box[1], player[0], player[1]);\\n        int res = Integer.MAX_VALUE;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(start);\\n        steps.put(start, 0);\\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll();\\n            if (steps.getOrDefault(curr, 0) > res) {\\n                continue;\\n            }\\n            int[] currBox = new int[] {Integer.parseInt(curr.split(\":\")[0]), Integer.parseInt(curr.split(\":\")[1])};\\n            int[] currPlayer = new int[] {Integer.parseInt(curr.split(\":\")[2]), Integer.parseInt(curr.split(\":\")[3])};\\n            if (currBox[0] == target[0] && currBox[1] == target[1]) {\\n                res = Math.min(res, steps.get(curr));\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                // every step, move player, if player meet the box, push the box.\\n                int[] newP = new int[] {currPlayer[0] + dx[i], currPlayer[1] + dy[i]};\\n                if (newP[0] < 0 || newP[1] < 0 || newP[0] >= grid.length \\n                    || newP[1] >= grid[0].length || grid[newP[0]][newP[1]] == \\'#\\') {\\n                    continue;\\n                }\\n                if (newP[0] == currBox[0] && newP[1] == currBox[1]) {\\n                    int[] newB = new int[] {currBox[0] + dx[i], currBox[1] + dy[i]};\\n                    if (newB[0] < 0 || newB[1] < 0 || newB[0] >= grid.length \\n                        || newB[1] >= grid[0].length || grid[newB[0]][newB[1]] == \\'#\\') {\\n                        continue;\\n                    }\\n                    String temp = encode(newB[0], newB[1], newP[0], newP[1]);\\n                    if (steps.containsKey(temp) && steps.get(temp) <= steps.get(curr) + 1) {\\n                        continue;\\n                    }\\n                    steps.put(temp, steps.get(curr) + 1);\\n                    queue.offer(temp);\\n                } else {\\n                    // if not meet box, just save it to the queue.\\n                    String temp = encode(currBox[0], currBox[1], newP[0], newP[1]);\\n                    if (steps.containsKey(temp) && steps.get(temp) <= steps.get(curr) + 1) {\\n                        continue;\\n                    }\\n                    steps.put(temp, steps.get(curr));\\n                    queue.offer(temp);\\n                }\\n            }   \\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    private String encode(int i1, int i2, int i3, int i4) {\\n        return i1 + \":\" + i2 + \":\" + i3 + \":\" + i4;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n        int[] box = new int[2];\\n        int[] player = new int[2];\\n        int[] target = new int[2];\\n        Map<String, Integer> steps = new HashMap<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'B\\') {\\n                    box = new int[] {i, j};\\n                } else if (grid[i][j] == \\'S\\') {\\n                    player = new int[] {i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = new int[] {i, j};\\n                }\\n            }\\n        }\\n        int[] dx = new int[] {0, 0, 1, -1};\\n        int[] dy = new int[] {1, -1, 0, 0};\\n        // so in BFS, instead of save a single point, save both box and player together\\n        String start = encode(box[0], box[1], player[0], player[1]);\\n        int res = Integer.MAX_VALUE;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(start);\\n        steps.put(start, 0);\\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll();\\n            if (steps.getOrDefault(curr, 0) > res) {\\n                continue;\\n            }\\n            int[] currBox = new int[] {Integer.parseInt(curr.split(\":\")[0]), Integer.parseInt(curr.split(\":\")[1])};\\n            int[] currPlayer = new int[] {Integer.parseInt(curr.split(\":\")[2]), Integer.parseInt(curr.split(\":\")[3])};\\n            if (currBox[0] == target[0] && currBox[1] == target[1]) {\\n                res = Math.min(res, steps.get(curr));\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                // every step, move player, if player meet the box, push the box.\\n                int[] newP = new int[] {currPlayer[0] + dx[i], currPlayer[1] + dy[i]};\\n                if (newP[0] < 0 || newP[1] < 0 || newP[0] >= grid.length \\n                    || newP[1] >= grid[0].length || grid[newP[0]][newP[1]] == \\'#\\') {\\n                    continue;\\n                }\\n                if (newP[0] == currBox[0] && newP[1] == currBox[1]) {\\n                    int[] newB = new int[] {currBox[0] + dx[i], currBox[1] + dy[i]};\\n                    if (newB[0] < 0 || newB[1] < 0 || newB[0] >= grid.length \\n                        || newB[1] >= grid[0].length || grid[newB[0]][newB[1]] == \\'#\\') {\\n                        continue;\\n                    }\\n                    String temp = encode(newB[0], newB[1], newP[0], newP[1]);\\n                    if (steps.containsKey(temp) && steps.get(temp) <= steps.get(curr) + 1) {\\n                        continue;\\n                    }\\n                    steps.put(temp, steps.get(curr) + 1);\\n                    queue.offer(temp);\\n                } else {\\n                    // if not meet box, just save it to the queue.\\n                    String temp = encode(currBox[0], currBox[1], newP[0], newP[1]);\\n                    if (steps.containsKey(temp) && steps.get(temp) <= steps.get(curr) + 1) {\\n                        continue;\\n                    }\\n                    steps.put(temp, steps.get(curr));\\n                    queue.offer(temp);\\n                }\\n            }   \\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    private String encode(int i1, int i2, int i3, int i4) {\\n        return i1 + \":\" + i2 + \":\" + i3 + \":\" + i4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571312,
                "title": "why-the-output-is-5",
                "content": "grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput: 5\\n\\nFor the above testcase, why the output is 5, instead of 3?\\nThe player can go up to (2, 3) and then push the box Up, Left and Left to reach the target.\\n\\nWhat am I missing here?",
                "solutionTags": [],
                "code": "grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput: 5\\n\\nFor the above testcase, why the output is 5, instead of 3?\\nThe player can go up to (2, 3) and then push the box Up, Left and Left to reach the target.\\n\\nWhat am I missing here?",
                "codeTag": "Unknown"
            },
            {
                "id": 1552282,
                "title": "c-dijkstra-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& a, int i) {\\n        if(a[i] == i) {\\n            return i;\\n        }\\n        return a[i] = find(a, a[i]);\\n    }\\n    \\n    void merge(vector<int>& a, vector<int>& r, int i, int j) {\\n        int i_ = find(a,i);\\n        int j_ = find(a,j);\\n        if(i_ == j_) {\\n            return; \\n        }\\n        if(r[i_] > r[j_]) {\\n            a[j_] = i_;\\n        } else {\\n            a[i_] = j_; \\n            if(r[i_] == r[j_]) {\\n                r[j_]++;\\n            }\\n        }\\n    }\\n    \\n    bool same(vector<int>& a, int i, int j) {\\n        return find(a,i) == find(a,j);\\n    }\\n    \\n    typedef pair<int,pair<int,int>> pipii;\\n    const int INF = INT_MAX / 2; \\n    int minPushBox(vector<vector<char>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> dp(m*n,vector<int>(m*n, INF));\\n        int p = -1; \\n        int b = -1; \\n        int target = -1; \\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    p = i * n + j; \\n                    grid[i][j] = \\'.\\';\\n                } else if(grid[i][j] == \\'B\\') {\\n                    b = i * n + j;\\n                    grid[i][j] = \\'.\\';\\n                } else if(grid[i][j] == \\'T\\') {\\n                    target = i * n + j; \\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        priority_queue<pipii,vector<pipii>,greater<pipii>> q; \\n        q.push({0,{p,b}});\\n        while(q.size()) {\\n            auto value = q.top();\\n            q.pop();\\n            int w = value.first; \\n            p = value.second.first; \\n            b = value.second.second; \\n            if(b == target) {\\n                return w; \\n            }\\n            if(dp[b][p] <= w) {\\n                continue; \\n            }\\n            dp[b][p] = w;\\n            int x = b/n; \\n            int y = b%n; \\n            grid[x][y] = \\'#\\';\\n            vector<int> a(m*n);\\n            vector<int> rank(m*n);\\n            for(int i = 0;i<a.size();i++) {\\n                a[i] = i; \\n            }\\n            for(int i = 0;i<m;i++) {\\n                for(int j = 0;j<n;j++) {\\n                    if(grid[i][j] != \\'.\\') {\\n                        continue; \\n                    } \\n                    int t = i * n + j; \\n                    if(i+1<m && grid[i+1][j] == \\'.\\') {\\n                        merge(a,rank,t,t+n);\\n                    }\\n                    if(j+1<n && grid[i][j+1] == \\'.\\') {\\n                        merge(a,rank,t,t+1);\\n                    }\\n                }\\n            }\\n            int p_x = p / n; \\n            int p_y = p % n; \\n            if(x+1<m && x - 1>=0 && same(a,b-n,p) && grid[x+1][y] == \\'.\\') {\\n                q.push({w+1,{b,b+n}});\\n            }\\n            if(x-1>=0 && x + 1 < m && same(a,p,b+n) && grid[x-1][y] == \\'.\\') {\\n                q.push({w+1,{b,b-n}});\\n            }\\n            if(y+1<n && y-1>=0 && same(a,p,b-1) && grid[x][y+1] == \\'.\\') {\\n                q.push({w+1,{b,b+1}});\\n            }\\n            if(y-1>=0 && y + 1 < n && same(a,p,b+1) && grid[x][y-1] == \\'.\\') {\\n                q.push({w+1,{b,b-1}});\\n            }\\n            grid[x][y] = \\'.\\';\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& a, int i) {\\n        if(a[i] == i) {\\n            return i;\\n        }\\n        return a[i] = find(a, a[i]);\\n    }\\n    \\n    void merge(vector<int>& a, vector<int>& r, int i, int j) {\\n        int i_ = find(a,i);\\n        int j_ = find(a,j);\\n        if(i_ == j_) {\\n            return; \\n        }\\n        if(r[i_] > r[j_]) {\\n            a[j_] = i_;\\n        } else {\\n            a[i_] = j_; \\n            if(r[i_] == r[j_]) {\\n                r[j_]++;\\n            }\\n        }\\n    }\\n    \\n    bool same(vector<int>& a, int i, int j) {\\n        return find(a,i) == find(a,j);\\n    }\\n    \\n    typedef pair<int,pair<int,int>> pipii;\\n    const int INF = INT_MAX / 2; \\n    int minPushBox(vector<vector<char>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> dp(m*n,vector<int>(m*n, INF));\\n        int p = -1; \\n        int b = -1; \\n        int target = -1; \\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    p = i * n + j; \\n                    grid[i][j] = \\'.\\';\\n                } else if(grid[i][j] == \\'B\\') {\\n                    b = i * n + j;\\n                    grid[i][j] = \\'.\\';\\n                } else if(grid[i][j] == \\'T\\') {\\n                    target = i * n + j; \\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        priority_queue<pipii,vector<pipii>,greater<pipii>> q; \\n        q.push({0,{p,b}});\\n        while(q.size()) {\\n            auto value = q.top();\\n            q.pop();\\n            int w = value.first; \\n            p = value.second.first; \\n            b = value.second.second; \\n            if(b == target) {\\n                return w; \\n            }\\n            if(dp[b][p] <= w) {\\n                continue; \\n            }\\n            dp[b][p] = w;\\n            int x = b/n; \\n            int y = b%n; \\n            grid[x][y] = \\'#\\';\\n            vector<int> a(m*n);\\n            vector<int> rank(m*n);\\n            for(int i = 0;i<a.size();i++) {\\n                a[i] = i; \\n            }\\n            for(int i = 0;i<m;i++) {\\n                for(int j = 0;j<n;j++) {\\n                    if(grid[i][j] != \\'.\\') {\\n                        continue; \\n                    } \\n                    int t = i * n + j; \\n                    if(i+1<m && grid[i+1][j] == \\'.\\') {\\n                        merge(a,rank,t,t+n);\\n                    }\\n                    if(j+1<n && grid[i][j+1] == \\'.\\') {\\n                        merge(a,rank,t,t+1);\\n                    }\\n                }\\n            }\\n            int p_x = p / n; \\n            int p_y = p % n; \\n            if(x+1<m && x - 1>=0 && same(a,b-n,p) && grid[x+1][y] == \\'.\\') {\\n                q.push({w+1,{b,b+n}});\\n            }\\n            if(x-1>=0 && x + 1 < m && same(a,p,b+n) && grid[x-1][y] == \\'.\\') {\\n                q.push({w+1,{b,b-n}});\\n            }\\n            if(y+1<n && y-1>=0 && same(a,p,b-1) && grid[x][y+1] == \\'.\\') {\\n                q.push({w+1,{b,b+1}});\\n            }\\n            if(y-1>=0 && y + 1 < n && same(a,p,b+1) && grid[x][y-1] == \\'.\\') {\\n                q.push({w+1,{b,b-1}});\\n            }\\n            grid[x][y] = \\'.\\';\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499707,
                "title": "bfs-without-using-priority-queue-o-m-2n-2-clear-explaination-python",
                "content": "We could reduce this problem to a shortest distance problem in graph:\\n\\nConstruct graph G = (V, E) as follows:\\nLet vertice v denotes game state, a.k.a (player position, box position).\\nLet edge e denotes change from one game state to another, so there are at most 4 edges for a vertex: player has at most 4 choices to move right, left, up, down and if there\\'s box on the way while he could push it then he could push the box. If he doesn\\'t push the box to make change, the according edge weight is 0; If he pushes the box to make change, the according edge weight is 1.\\n\\nThen we need to calculate shortest distance from start vertex to a set of target vertices in this graph. The brute force is to use dijkstra directly; But we could do better: since edge weight can only be 0 or 1, we could use BFS with a tiny change: everytime we want to insert a neighbor we insert it at the front if the edge to the neighbor is 0 and insert it at the back if the edge to the neighbor is 1. (Think about why!) Thanks for my friend, zpt, who tells me this method when we are taking CS374 together.\\n\\nHere\\'s the actual code:\\n```\\n  # method to get start position of player, box and target position\\n  def get_pos(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        player, B, T = None, None, None\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                elif grid[i][j] == \\'B\\':\\n                    B = (i, j)\\n                elif grid[i][j] == \\'T\\':\\n                    T = (i, j)\\n        return player, B, T\\n    \\n\\t# return true if (i,j) is in range\\n    def valid(self, i, j, grid):\\n        m, n = len(grid), len(grid[0])\\n        return 0 <= i < m and 0 <= j < n\\n    \\n\\t# Given current vertex (playerPos, boxPos), get its neighbors who have not been visited yet\\n    def neighbors(self, playerPos, boxPos, grid, visited):\\n        res = []\\n        i, j = playerPos\\n        bi, bj = boxPos\\n        for di, dj in {(0, 1), (0, -1), (1, 0), (-1, 0)}:\\n            nextI, nextJ = i + di, j + dj\\n            if Solution.valid(self, nextI, nextJ, grid) and grid[nextI][nextJ] != \\'#\\':\\n                if (nextI, nextJ) != boxPos and ((nextI, nextJ), boxPos) not in visited:\\n                    res.append((0, (nextI, nextJ), boxPos))\\n                elif (nextI, nextJ) == boxPos:\\n                    box_nextI, box_nextJ = bi + di, bj + dj\\n                    if Solution.valid(self, box_nextI, box_nextJ, grid) and grid[box_nextI][box_nextJ] != \\'#\\' and ((nextI, nextJ), (box_nextI, box_nextJ)) not in visited:\\n                        res.append((1, (nextI, nextJ), (box_nextI, box_nextJ)))\\n        return res\\n    \\n\\t# the main method\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        player, B, T = Solution.get_pos(self, grid)\\n        visited = {(player, B)}\\n        queue = [(0, player, B)]\\n        while queue:\\n            currDis, playerPos, boxPos = queue.pop(0)\\n            if boxPos == T:\\n                return currDis\\n            for w, nextPos, nextBox in Solution.neighbors(self, playerPos, boxPos, grid, visited):\\n                if w == 0:\\n                    queue.insert(0, (currDis, nextPos, nextBox))\\n                else:\\n                    queue.append((1 + currDis, nextPos, nextBox))\\n                visited.add((nextPos, nextBox))\\n        return -1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n  # method to get start position of player, box and target position\\n  def get_pos(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        player, B, T = None, None, None\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                elif grid[i][j] == \\'B\\':\\n                    B = (i, j)\\n                elif grid[i][j] == \\'T\\':\\n                    T = (i, j)\\n        return player, B, T\\n    \\n\\t# return true if (i,j) is in range\\n    def valid(self, i, j, grid):\\n        m, n = len(grid), len(grid[0])\\n        return 0 <= i < m and 0 <= j < n\\n    \\n\\t# Given current vertex (playerPos, boxPos), get its neighbors who have not been visited yet\\n    def neighbors(self, playerPos, boxPos, grid, visited):\\n        res = []\\n        i, j = playerPos\\n        bi, bj = boxPos\\n        for di, dj in {(0, 1), (0, -1), (1, 0), (-1, 0)}:\\n            nextI, nextJ = i + di, j + dj\\n            if Solution.valid(self, nextI, nextJ, grid) and grid[nextI][nextJ] != \\'#\\':\\n                if (nextI, nextJ) != boxPos and ((nextI, nextJ), boxPos) not in visited:\\n                    res.append((0, (nextI, nextJ), boxPos))\\n                elif (nextI, nextJ) == boxPos:\\n                    box_nextI, box_nextJ = bi + di, bj + dj\\n                    if Solution.valid(self, box_nextI, box_nextJ, grid) and grid[box_nextI][box_nextJ] != \\'#\\' and ((nextI, nextJ), (box_nextI, box_nextJ)) not in visited:\\n                        res.append((1, (nextI, nextJ), (box_nextI, box_nextJ)))\\n        return res\\n    \\n\\t# the main method\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        player, B, T = Solution.get_pos(self, grid)\\n        visited = {(player, B)}\\n        queue = [(0, player, B)]\\n        while queue:\\n            currDis, playerPos, boxPos = queue.pop(0)\\n            if boxPos == T:\\n                return currDis\\n            for w, nextPos, nextBox in Solution.neighbors(self, playerPos, boxPos, grid, visited):\\n                if w == 0:\\n                    queue.insert(0, (currDis, nextPos, nextBox))\\n                else:\\n                    queue.append((1 + currDis, nextPos, nextBox))\\n                visited.add((nextPos, nextBox))\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1420019,
                "title": "apply-bfs-twice-with-some-helpful-hints",
                "content": "**Algorithm**:\\n1. Choose the location of the box, \\n2. Then, new person location should be opposite to that of the box.\\n3. Then ask the algorithm - (can_reach def) Can I reach to new_person from current person location? Only if the answer is \\'yes\\', consider that new box location.\\n\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.nRow, self.nCol = len(grid), len(grid[0])\\n        DIR = [-1,0,1,0,-1]\\n        \\n        # find out the location of box and the person and the target\\n        for i in range(self.nRow):\\n            for j in range(self.nCol):\\n                if grid[i][j] == \\'S\\':\\n                    person = (i,j)\\n                if grid[i][j] == \\'B\\':\\n                    box = (i,j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i,j)\\n        \\n        def is_valid(pos):\\n            pos_x, pos_y = pos\\n            if pos_x < 0 or pos_y < 0 or pos_x >= self.nRow or pos_y >= self.nCol or grid[pos_x][pos_y] == \\'#\\':\\n                return False\\n            return True\\n        \\n        def can_reach(curr_loc, new_loc, box_loc):\\n            \\'\\'\\'\\n            Can I reach to new location from the current location?\\n            \\'\\'\\'\\n            _q = deque()\\n            _v = set()\\n            _q.append(curr_loc)\\n            _v.add(curr_loc)\\n            \\n            while _q:\\n                curr_loc = _q.popleft()\\n                if curr_loc == new_loc:\\n                    return True\\n                curr_loc_x, curr_loc_y = curr_loc\\n                for d in range(4):\\n                    ncurr_loc_x, ncurr_loc_y = curr_loc_x + DIR[d], curr_loc_y + DIR[d+1]\\n                    ncurr_loc = (ncurr_loc_x, ncurr_loc_y)\\n                    if is_valid(ncurr_loc) and ncurr_loc != box_loc and ncurr_loc not in _v:\\n                        _q.append(ncurr_loc)\\n                        _v.add(ncurr_loc)\\n            return False\\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0, box, person)) # start location\\n        visited.add((box, person))\\n        \\n        while q:\\n            dist, box, person = q.popleft()\\n            box_x, box_y = box\\n            person_x, person_y = person\\n            \\n            if box == target:\\n                return dist\\n            \\n            for d in range(4):\\n                new_box_x, new_box_y = box_x + DIR[d] , box_y + DIR[d+1]\\n                # now new person location should be opposite to that of the box\\n                new_person_x, new_person_y = box_x - DIR[d] , box_y - DIR[d+1]\\n                \\n                new_box = (new_box_x, new_box_y)\\n                new_person = (new_person_x, new_person_y)\\n                \\n                if is_valid(new_box) and is_valid(new_person) and can_reach(person, new_person, box) and grid[new_box_x][new_box_y] != \\'#\\' and (new_box, new_person) not in visited:\\n                    q.append((dist+1, new_box, new_person)) \\n                    visited.add((new_box, new_person))\\n            \\n        return -1    \\n        \\n```\\n\\nComplexity O(M*N*M*N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.nRow, self.nCol = len(grid), len(grid[0])\\n        DIR = [-1,0,1,0,-1]\\n        \\n        # find out the location of box and the person and the target\\n        for i in range(self.nRow):\\n            for j in range(self.nCol):\\n                if grid[i][j] == \\'S\\':\\n                    person = (i,j)\\n                if grid[i][j] == \\'B\\':\\n                    box = (i,j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i,j)\\n        \\n        def is_valid(pos):\\n            pos_x, pos_y = pos\\n            if pos_x < 0 or pos_y < 0 or pos_x >= self.nRow or pos_y >= self.nCol or grid[pos_x][pos_y] == \\'#\\':\\n                return False\\n            return True\\n        \\n        def can_reach(curr_loc, new_loc, box_loc):\\n            \\'\\'\\'\\n            Can I reach to new location from the current location?\\n            \\'\\'\\'\\n            _q = deque()\\n            _v = set()\\n            _q.append(curr_loc)\\n            _v.add(curr_loc)\\n            \\n            while _q:\\n                curr_loc = _q.popleft()\\n                if curr_loc == new_loc:\\n                    return True\\n                curr_loc_x, curr_loc_y = curr_loc\\n                for d in range(4):\\n                    ncurr_loc_x, ncurr_loc_y = curr_loc_x + DIR[d], curr_loc_y + DIR[d+1]\\n                    ncurr_loc = (ncurr_loc_x, ncurr_loc_y)\\n                    if is_valid(ncurr_loc) and ncurr_loc != box_loc and ncurr_loc not in _v:\\n                        _q.append(ncurr_loc)\\n                        _v.add(ncurr_loc)\\n            return False\\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0, box, person)) # start location\\n        visited.add((box, person))\\n        \\n        while q:\\n            dist, box, person = q.popleft()\\n            box_x, box_y = box\\n            person_x, person_y = person\\n            \\n            if box == target:\\n                return dist\\n            \\n            for d in range(4):\\n                new_box_x, new_box_y = box_x + DIR[d] , box_y + DIR[d+1]\\n                # now new person location should be opposite to that of the box\\n                new_person_x, new_person_y = box_x - DIR[d] , box_y - DIR[d+1]\\n                \\n                new_box = (new_box_x, new_box_y)\\n                new_person = (new_person_x, new_person_y)\\n                \\n                if is_valid(new_box) and is_valid(new_person) and can_reach(person, new_person, box) and grid[new_box_x][new_box_y] != \\'#\\' and (new_box, new_person) not in visited:\\n                    q.append((dist+1, new_box, new_person)) \\n                    visited.add((new_box, new_person))\\n            \\n        return -1    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350966,
                "title": "bfs-with-box-player-as-state",
                "content": "This problem involves regular BFS with a few important distinctions.\\n1. We cannot just directly look for shortest path from box to target. An additional condition is that the player should be able to reach the push_spot from where the box can be pushed. This extra condition needs to be checked at each step before considering a box in our BFS traversal.\\n2. The way we consider visited set changes slightly. It is not just the posiiton of the box that matters but also the player. There are some cases where a box needs to be pushed past a position and then pushed back into it to allow the player to reach the push spots. \\n3. In terms of implementation, it is easier if we maintain the positions of box and player outside the grid, in two variables. This is because we evaluate several options, and maintaing the box and player within the grid can get messy\\n\\nSo overall, this problem can be solved by taking(box, player) as state and checking if player can reach the push_spot\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        box, player = None, None\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                if grid[r][c] == \"S\":\\n                    player = (r,c)\\n                    grid[r][c] = \".\"\\n                elif grid[r][c] == \"B\":\\n                    box = (r, c)\\n                    grid[r][c] = \".\"\\n        \\n        def get_neighbours_for_box(box, grid):\\n            moves = [(0,-1),(0,1),(-1,0),(1,0)]\\n            r,c = box[0], box[1]\\n            neighbours = []\\n            for m in moves:\\n                n_r, n_c = r + m[0], c + m[1]\\n                push_spot = r - m[0], c - m[1]\\n                if 0 <= n_r < len(grid) and 0 <= n_c < len(grid[0]) and grid[n_r][n_c] not in [\"#\"] and 0 <= push_spot[0] < len(grid) and 0 <= push_spot[1] < len(grid[0]) and grid[push_spot[0]][push_spot[1]] not in [\"#\"]:\\n                    neighbours.append(((n_r, n_c), push_spot))\\n            return neighbours\\n        \\n        def get_neighbours_for_player(player, box, grid):\\n            moves = [(0,-1),(0,1),(-1,0),(1,0)]\\n            r,c = player[0], player[1]\\n            neighbours = []\\n            for m in moves:\\n                n_r, n_c = r + m[0], c + m[1]\\n                if 0 <= n_r < len(grid) and 0 <= n_c < len(grid[0]) and grid[n_r][n_c] not in [\"#\"] and (n_r,n_c) != box:\\n                    neighbours.append((n_r, n_c))\\n            return neighbours\\n        \\n        def player_can_reach(player, push_spot, box, grid):\\n            queue = deque()\\n            queue.append(player)\\n            visited = set()\\n            visited.add(player)\\n            while queue:\\n                p = queue.popleft()\\n                if p == push_spot:\\n                    return True\\n                for n in get_neighbours_for_player(p, box, grid):\\n                    if n not in visited:\\n                        visited.add(n)\\n                        queue.append(n)\\n            return False\\n        \\n        queue = deque()\\n        visited = set()\\n        visited.add((box,player))\\n        queue.append((box, player, 0))\\n        while queue:\\n            box,player,d = queue.popleft()\\n            if grid[box[0]][box[1]] == \"T\":\\n                return d\\n            neighbours = get_neighbours_for_box(box, grid)\\n            for n, ps in neighbours:\\n                if (n,box) not in visited and player_can_reach(player, ps, box, grid):\\n                    visited.add((n,box))\\n                    queue.append((n,box,d+1))\\n        return -1\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        box, player = None, None\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                if grid[r][c] == \"S\":\\n                    player = (r,c)\\n                    grid[r][c] = \".\"\\n                elif grid[r][c] == \"B\":\\n                    box = (r, c)\\n                    grid[r][c] = \".\"\\n        \\n        def get_neighbours_for_box(box, grid):\\n            moves = [(0,-1),(0,1),(-1,0),(1,0)]\\n            r,c = box[0], box[1]\\n            neighbours = []\\n            for m in moves:\\n                n_r, n_c = r + m[0], c + m[1]\\n                push_spot = r - m[0], c - m[1]\\n                if 0 <= n_r < len(grid) and 0 <= n_c < len(grid[0]) and grid[n_r][n_c] not in [\"#\"] and 0 <= push_spot[0] < len(grid) and 0 <= push_spot[1] < len(grid[0]) and grid[push_spot[0]][push_spot[1]] not in [\"#\"]:\\n                    neighbours.append(((n_r, n_c), push_spot))\\n            return neighbours\\n        \\n        def get_neighbours_for_player(player, box, grid):\\n            moves = [(0,-1),(0,1),(-1,0),(1,0)]\\n            r,c = player[0], player[1]\\n            neighbours = []\\n            for m in moves:\\n                n_r, n_c = r + m[0], c + m[1]\\n                if 0 <= n_r < len(grid) and 0 <= n_c < len(grid[0]) and grid[n_r][n_c] not in [\"#\"] and (n_r,n_c) != box:\\n                    neighbours.append((n_r, n_c))\\n            return neighbours\\n        \\n        def player_can_reach(player, push_spot, box, grid):\\n            queue = deque()\\n            queue.append(player)\\n            visited = set()\\n            visited.add(player)\\n            while queue:\\n                p = queue.popleft()\\n                if p == push_spot:\\n                    return True\\n                for n in get_neighbours_for_player(p, box, grid):\\n                    if n not in visited:\\n                        visited.add(n)\\n                        queue.append(n)\\n            return False\\n        \\n        queue = deque()\\n        visited = set()\\n        visited.add((box,player))\\n        queue.append((box, player, 0))\\n        while queue:\\n            box,player,d = queue.popleft()\\n            if grid[box[0]][box[1]] == \"T\":\\n                return d\\n            neighbours = get_neighbours_for_box(box, grid)\\n            for n, ps in neighbours:\\n                if (n,box) not in visited and player_can_reach(player, ps, box, grid):\\n                    visited.add((n,box))\\n                    queue.append((n,box,d+1))\\n        return -1\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1340602,
                "title": "python-bfs-x-2",
                "content": "```py\\nclass Solution:\\n    \\n    offsets = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        # check if player can move from start to end given the ball\\'s position\\n        def can_move(start, end, ball):\\n            if not (0 <= end[0] < rows and 0 <= end[1] < cols):\\n                return False\\n            q = collections.deque([start])\\n            seen = {start}\\n            while q:\\n                row, col = q.popleft()\\n                if (row, col) == end:\\n                    return True\\n                for r_offset, c_offset in self.offsets:\\n                    r, c = row + r_offset, col + c_offset\\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] != \\'#\\' and (r, c) != ball and (r, c) not in seen:\\n                        seen.add((r, c))\\n                        q.append((r, c))\\n            return False\\n\\n        rows, cols = len(grid), len(grid[0])\\n\\n        # find source, target, ball\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \\'T\\':\\n                    target = (r, c)\\n                elif grid[r][c] == \\'S\\':\\n                    source = (r, c)\\n                elif grid[r][c] == \\'B\\':\\n                    ball = (r, c)\\n\\n        # dfs starting from source, ball\\n        seen = {(source, ball)}\\n        q = collections.deque([(0, source, ball)])\\n\\n        while q:\\n            dist, source, ball = q.popleft()\\n\\n            if ball == target:\\n                return dist\\n\\n            for r_offset, c_offset in self.offsets:\\n                r, c = ball[0] + r_offset, ball[1] + c_offset\\n\\n                if 0 <= r < rows and 0 <= c < cols and grid[r][c] != \\'#\\':\\n                    push_pos = (ball[0] - r_offset, ball[1] - c_offset)\\n\\n                    if (ball, (r, c)) not in seen and can_move(source, push_pos, ball):\\n                        seen.add((ball, (r, c)))\\n                        q.append((dist + 1, ball, (r, c)))\\n\\n        return -1\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n    offsets = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        # check if player can move from start to end given the ball\\'s position\\n        def can_move(start, end, ball):\\n            if not (0 <= end[0] < rows and 0 <= end[1] < cols):\\n                return False\\n            q = collections.deque([start])\\n            seen = {start}",
                "codeTag": "Java"
            },
            {
                "id": 1299308,
                "title": "java-a-search",
                "content": "```\\n /*\\n \\n  Idea:\\n    concern:\\n    1> how to avoid repeat or endless loop of person walking and box moving\\n     answer: S can repeat location when B is in different location,\\n             but for a given fix B location, S should not repeat  walking\\n             B should not repeat moving.\\n             need a visited variable to keep the visited status using box and person location\\n    2> if failed to move to any direction should restore the B to one of original location?\\n     answer: yeah, only when there is not any direction is possible to move on.\\n             the one of original location is decided by the priority value of heuristic\\n             So should keep Box and person location in status.\\n             heuristic decided by moved steps and manhattan distance.\\n             so the status include: manhattan distance, moved steps, Box and person location\\n\\n   Solution:\\n    find the initial location of B, S, T\\n    A * search: BFS + priority queue.\\n                a priority queue keeping status  and heuristic ( manhattan + steps)\\n                avoid repeating visited status: locations of person and box\\n      initial status in priority queue\\n      loop while queue is not empty\\n        1> if current B is T then return moved steps\\n        2> if current B is visited return, stop trying from this status\\n        3> make person + B location as visited\\n          try a step toward 4 direction of person.\\n            effective: try to move box a step toward 4 directions if box\\n                       have space to move & person can walk to the place to push\\n            details:\\n            from current status: person try walk a step toward 4 directions if\\n            person can walk: in grid and no # at next cell\\n            if the next cell for person to walk is box location and box\\'s next cell\\n            is allow it to move:\\n               it is move box\\n            else\\n               it is only person walk.\\n            update related status and add to priority queue.\\n\\n     out of loop return -1\\n     Variables:\\n      target T location [A,B],\\n      person S location [c,r] or [column, row]\\n      box B location [a,b]\\n  */\\n  int A = 0, B = 0;\\n  int[][] d4 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n  public int minPushBox(char[][] grid) {\\n    int R = grid.length, C = grid[0].length;\\n    // searching initial location T[A,B], B[ia,ib],S[ix,iy]\\n    int ia = 0, ib = 0, ix = 0, iy = 0;\\n    for (int i = 0; i < R; i++) {\\n      for (int j = 0; j < C; j++) {\\n        char c = grid[i][j];\\n        if (c == \\'T\\') {\\n          A = j;\\n          B = i;\\n        }\\n        if (c == \\'B\\') {\\n          ia = j;\\n          ib = i;\\n        }\\n        if (c == \\'S\\') {\\n          ix = j;\\n          iy = i;\\n        }\\n      }\\n    }\\n\\n    Set<String> v = new HashSet();\\n    Queue<int[]> q = new PriorityQueue<>((o, o2) -> o[0] + o[1] - o2[0] - o2[1]);\\n    q.offer(new int[] {Math.abs(ia - A) + Math.abs(ib - B), 0, ix, iy, ia, ib});\\n    while (!q.isEmpty()) {\\n      int[] c = q.poll();\\n      int a = c[4], b = c[5], steps = c[1];\\n      if (a == A && b == B) return steps;\\n\\n      int x = c[2], y = c[3];\\n      String k = x + \"\" + y + \"\" + a + \"\" + b;\\n      if (v.contains(k)) continue;\\n      v.add(k);\\n\\n      for (int[] d : d4) {\\n        int nx = x + d[0], ny = y + d[1];\\n        if (!canWalk(nx, ny, R, C, grid)) continue;\\n        if (nx == a && ny == b) {\\n          int na = a + d[0], nb = b + d[1];\\n          if (!canWalk(na, nb, R, C, grid)) continue;\\n          q.offer(new int[] {Math.abs(na - A) + Math.abs(nb - B), steps + 1, nx, ny, na, nb});\\n        } else q.offer(new int[] {c[0], steps, nx, ny, a, b});\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  private boolean canWalk(int x, int y, int R, int C, char[][] grid) {\\n    if (x < 0 || x >= C || y < 0 || y >= R || grid[y][x] == \\'#\\') return false;\\n    return true;\\n  } \\n```",
                "solutionTags": [],
                "code": "```\\n /*\\n \\n  Idea:\\n    concern:\\n    1> how to avoid repeat or endless loop of person walking and box moving\\n     answer: S can repeat location when B is in different location,\\n             but for a given fix B location, S should not repeat  walking\\n             B should not repeat moving.\\n             need a visited variable to keep the visited status using box and person location\\n    2> if failed to move to any direction should restore the B to one of original location?\\n     answer: yeah, only when there is not any direction is possible to move on.\\n             the one of original location is decided by the priority value of heuristic\\n             So should keep Box and person location in status.\\n             heuristic decided by moved steps and manhattan distance.\\n             so the status include: manhattan distance, moved steps, Box and person location\\n\\n   Solution:\\n    find the initial location of B, S, T\\n    A * search: BFS + priority queue.\\n                a priority queue keeping status  and heuristic ( manhattan + steps)\\n                avoid repeating visited status: locations of person and box\\n      initial status in priority queue\\n      loop while queue is not empty\\n        1> if current B is T then return moved steps\\n        2> if current B is visited return, stop trying from this status\\n        3> make person + B location as visited\\n          try a step toward 4 direction of person.\\n            effective: try to move box a step toward 4 directions if box\\n                       have space to move & person can walk to the place to push\\n            details:\\n            from current status: person try walk a step toward 4 directions if\\n            person can walk: in grid and no # at next cell\\n            if the next cell for person to walk is box location and box\\'s next cell\\n            is allow it to move:\\n               it is move box\\n            else\\n               it is only person walk.\\n            update related status and add to priority queue.\\n\\n     out of loop return -1\\n     Variables:\\n      target T location [A,B],\\n      person S location [c,r] or [column, row]\\n      box B location [a,b]\\n  */\\n  int A = 0, B = 0;\\n  int[][] d4 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n  public int minPushBox(char[][] grid) {\\n    int R = grid.length, C = grid[0].length;\\n    // searching initial location T[A,B], B[ia,ib],S[ix,iy]\\n    int ia = 0, ib = 0, ix = 0, iy = 0;\\n    for (int i = 0; i < R; i++) {\\n      for (int j = 0; j < C; j++) {\\n        char c = grid[i][j];\\n        if (c == \\'T\\') {\\n          A = j;\\n          B = i;\\n        }\\n        if (c == \\'B\\') {\\n          ia = j;\\n          ib = i;\\n        }\\n        if (c == \\'S\\') {\\n          ix = j;\\n          iy = i;\\n        }\\n      }\\n    }\\n\\n    Set<String> v = new HashSet();\\n    Queue<int[]> q = new PriorityQueue<>((o, o2) -> o[0] + o[1] - o2[0] - o2[1]);\\n    q.offer(new int[] {Math.abs(ia - A) + Math.abs(ib - B), 0, ix, iy, ia, ib});\\n    while (!q.isEmpty()) {\\n      int[] c = q.poll();\\n      int a = c[4], b = c[5], steps = c[1];\\n      if (a == A && b == B) return steps;\\n\\n      int x = c[2], y = c[3];\\n      String k = x + \"\" + y + \"\" + a + \"\" + b;\\n      if (v.contains(k)) continue;\\n      v.add(k);\\n\\n      for (int[] d : d4) {\\n        int nx = x + d[0], ny = y + d[1];\\n        if (!canWalk(nx, ny, R, C, grid)) continue;\\n        if (nx == a && ny == b) {\\n          int na = a + d[0], nb = b + d[1];\\n          if (!canWalk(na, nb, R, C, grid)) continue;\\n          q.offer(new int[] {Math.abs(na - A) + Math.abs(nb - B), steps + 1, nx, ny, na, nb});\\n        } else q.offer(new int[] {c[0], steps, nx, ny, a, b});\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  private boolean canWalk(int x, int y, int R, int C, char[][] grid) {\\n    if (x < 0 || x >= C || y < 0 || y >= R || grid[y][x] == \\'#\\') return false;\\n    return true;\\n  } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274466,
                "title": "don-t-step-on-the-box",
                "content": "```\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(row):\\n                if col == \\'S\\':\\n                    si,sj = i,j\\n                elif col == \\'B\\':\\n                    bi,bj = i,j\\n                elif col == \\'T\\':\\n                    ti,tj = i,j\\n                    \\n        H, W = len(grid), len(grid[0])\\n        dirs = [(-1,0), (0, -1), (1,0),(0,1)]\\n        def playerreach(standi, standj, pli, plj, nbi, nbj):\\n            q = deque([(pli, plj)])\\n            seenpr = set()\\n            while q:\\n                ppi, ppj = q.popleft()\\n                \\n                for di, dj in dirs:\\n                    newpi, newpj = di + ppi, dj + ppj\\n\\t\\t\\t\\t\\t#Don\\'t step on the Box!\\n                    if 0 <= newpi < H and 0 <= newpj < W and grid[newpi][newpj] != \\'#\\' and (newpi, newpj) != (nbi, nbj):\\n                        if (newpi, newpj) == (standi, standj):\\n                            return True\\n                        if (newpi, newpj) not in seenpr:\\n                            seenpr.add((newpi, newpj))\\n                            q.append((newpi, newpj))\\n                            \\n            return False\\n        \\n        seen = {(bi, bj, si, sj)}\\n        \\n        q = deque([(bi, bj, si, sj, 0)])\\n        best = float(\\'inf\\')\\n        while q:\\n            bxi, bxj, pli, plj, pushes = q.popleft()\\n            \\n            for di, dj in dirs:\\n                newi, newj = di + bxi, dj + bxj\\n                \\n                if 0 <= newi < H and 0 <= newj < W and grid[newi][newj] != \\'#\\':\\n                    \\n                    if (newi, newj, pli, plj) not in seen:\\n                        seen.add((newi, newj, pli, plj))\\n                        standi, standj = di*-1 + bxi, dj*-1 + bxj\\n                        \\n                        if playerreach(standi, standj, pli, plj, bxi, bxj):\\n                            \\n                            if (newi, newj) == (ti, tj):\\n                                best = min(best, pushes+1)\\n                            else:\\n                                q.append((newi, newj, standi+di, standj+dj, pushes+1))\\n                            \\n                            \\n        return -1 if best == float(\\'inf\\') else best",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(row):\\n                if col == \\'S\\':\\n                    si,sj = i,j\\n                elif col == \\'B\\':\\n                    bi,bj = i,j\\n                elif col == \\'T\\':\\n                    ti,tj = i,j\\n                    \\n        H, W = len(grid), len(grid[0])\\n        dirs = [(-1,0), (0, -1), (1,0),(0,1)]\\n        def playerreach(standi, standj, pli, plj, nbi, nbj):\\n            q = deque([(pli, plj)])\\n            seenpr = set()\\n            while q:\\n                ppi, ppj = q.popleft()\\n                \\n                for di, dj in dirs:\\n                    newpi, newpj = di + ppi, dj + ppj\\n\\t\\t\\t\\t\\t#Don\\'t step on the Box!\\n                    if 0 <= newpi < H and 0 <= newpj < W and grid[newpi][newpj] != \\'#\\' and (newpi, newpj) != (nbi, nbj):\\n                        if (newpi, newpj) == (standi, standj):\\n                            return True\\n                        if (newpi, newpj) not in seenpr:\\n                            seenpr.add((newpi, newpj))\\n                            q.append((newpi, newpj))\\n                            \\n            return False\\n        \\n        seen = {(bi, bj, si, sj)}\\n        \\n        q = deque([(bi, bj, si, sj, 0)])\\n        best = float(\\'inf\\')\\n        while q:\\n            bxi, bxj, pli, plj, pushes = q.popleft()\\n            \\n            for di, dj in dirs:\\n                newi, newj = di + bxi, dj + bxj\\n                \\n                if 0 <= newi < H and 0 <= newj < W and grid[newi][newj] != \\'#\\':\\n                    \\n                    if (newi, newj, pli, plj) not in seen:\\n                        seen.add((newi, newj, pli, plj))\\n                        standi, standj = di*-1 + bxi, dj*-1 + bxj\\n                        \\n                        if playerreach(standi, standj, pli, plj, bxi, bxj):\\n                            \\n                            if (newi, newj) == (ti, tj):\\n                                best = min(best, pushes+1)\\n                            else:\\n                                q.append((newi, newj, standi+di, standj+dj, pushes+1))\\n                            \\n                            \\n        return -1 if best == float(\\'inf\\') else best",
                "codeTag": "Python3"
            },
            {
                "id": 1262265,
                "title": "java-dual-bfs",
                "content": "```\\n// We need to track the min number of steps that the box needs to be pushed to the target\\n// We don\\'t care how many steps the player takes\\n// We will track the state of the box and the player\\n// For every box position we consider each possible next box position\\n//    - The usual checks, is the box position in bounds, visited, not a wall, etc. plus...\\n//    - Can the player be moved into position to move the box to the new position? Use separate BFS\\n// We track the visited position and direction of the box\\n// 4 ms, faster than 99.60%\\nclass State {\\n  int pRow;\\n  int pCol;\\n  int bRow;\\n  int bCol;\\n  State() {}\\n  State(int pRow, int pCol, int bRow, int bCol) {\\n    this.pRow = pRow;\\n    this.pCol = pCol;\\n    this.bRow = bRow;\\n    this.bCol = bCol;\\n  }\\n}\\nclass Solution {\\n  private static final int[][] DIRS = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n  public int minPushBox(char[][] grid) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n    State initState = new State();\\n    for (int row = 0; row < rows; row++) {\\n      for (int col = 0; col < cols; col++) {\\n        if (grid[row][col] == \\'S\\') {\\n          initState.pRow = row;\\n          initState.pCol = col;\\n        } else if (grid[row][col] == \\'B\\') {\\n          initState.bRow = row;\\n          initState.bCol = col;\\n        }\\n      }\\n    }\\n    boolean[][][] visited = new boolean[rows][cols][4];\\n    Deque<State> deque = new ArrayDeque<>();\\n    deque.add(initState);\\n    int steps = 1;\\n    while (!deque.isEmpty()) {\\n      int size = deque.size();\\n      for (int i = 0; i < size; i++) {\\n        State curr = deque.remove();\\n        for (int dir = 0; dir < 4; dir++) {\\n          int adjBRow = curr.bRow + DIRS[dir][0];\\n          int adjBCol = curr.bCol + DIRS[dir][1];\\n          // player must have been in this position to push box to new adj position\\n          int adjPRow = curr.bRow - DIRS[dir][0]; \\n          int adjPCol = curr.bCol - DIRS[dir][1];\\n          if (adjBRow < 0 || adjBRow > rows - 1 || adjBCol < 0 || adjBCol > cols - 1 || \\n             adjPRow < 0 || adjPRow > rows - 1 || adjPCol < 0 || adjPCol > cols - 1 ||\\n              visited[adjBRow][adjBCol][dir] || \\n              grid[adjBRow][adjBCol] == \\'#\\' || grid[adjPRow][adjPCol] == \\'#\\' || \\n             !playerCanReachBox(grid, curr.pRow, curr.pCol, adjPRow, adjPCol, curr.bRow, curr.bCol))\\n            continue;\\n          if (grid[adjBRow][adjBCol] == \\'T\\')\\n            return steps;\\n          visited[adjBRow][adjBCol][dir] = true;\\n          deque.add(new State(curr.bRow, curr.bCol, adjBRow, adjBCol));\\n        }\\n      }\\n      steps++;\\n    }\\n    return -1;\\n  }\\n  private boolean playerCanReachBox(char[][] grid, int pRow1, int pCol1, int pRow2, int pCol2, int bRow, int bCol) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n    if (pRow1 == pRow2 && pCol1 == pCol2)\\n      return true;\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    deque.add(pRow1 * cols + pCol1);\\n    boolean[][] visited = new boolean[rows][cols];\\n    visited[pRow1][pCol1] = true;\\n    visited[bRow][bCol] = true;\\n    while (!deque.isEmpty()) {\\n      int index = deque.remove();\\n      int row = index / cols;\\n      int col = index % cols;\\n      for (int[] dir : DIRS) {\\n        int adjRow = row + dir[0];\\n        int adjCol = col + dir[1];\\n        if (adjRow < 0 || adjRow > rows - 1 || adjCol < 0 || adjCol > cols - 1 ||\\n            visited[adjRow][adjCol] || grid[adjRow][adjCol] == \\'#\\')\\n          continue;\\n        if (adjRow == pRow2 && adjCol == pCol2)\\n          return true;\\n        deque.add(adjRow * cols + adjCol);\\n        visited[adjRow][adjCol] = true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// We need to track the min number of steps that the box needs to be pushed to the target\\n// We don\\'t care how many steps the player takes\\n// We will track the state of the box and the player\\n// For every box position we consider each possible next box position\\n//    - The usual checks, is the box position in bounds, visited, not a wall, etc. plus...\\n//    - Can the player be moved into position to move the box to the new position? Use separate BFS\\n// We track the visited position and direction of the box\\n// 4 ms, faster than 99.60%\\nclass State {\\n  int pRow;\\n  int pCol;\\n  int bRow;\\n  int bCol;\\n  State() {}\\n  State(int pRow, int pCol, int bRow, int bCol) {\\n    this.pRow = pRow;\\n    this.pCol = pCol;\\n    this.bRow = bRow;\\n    this.bCol = bCol;\\n  }\\n}\\nclass Solution {\\n  private static final int[][] DIRS = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n  public int minPushBox(char[][] grid) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n    State initState = new State();\\n    for (int row = 0; row < rows; row++) {\\n      for (int col = 0; col < cols; col++) {\\n        if (grid[row][col] == \\'S\\') {\\n          initState.pRow = row;\\n          initState.pCol = col;\\n        } else if (grid[row][col] == \\'B\\') {\\n          initState.bRow = row;\\n          initState.bCol = col;\\n        }\\n      }\\n    }\\n    boolean[][][] visited = new boolean[rows][cols][4];\\n    Deque<State> deque = new ArrayDeque<>();\\n    deque.add(initState);\\n    int steps = 1;\\n    while (!deque.isEmpty()) {\\n      int size = deque.size();\\n      for (int i = 0; i < size; i++) {\\n        State curr = deque.remove();\\n        for (int dir = 0; dir < 4; dir++) {\\n          int adjBRow = curr.bRow + DIRS[dir][0];\\n          int adjBCol = curr.bCol + DIRS[dir][1];\\n          // player must have been in this position to push box to new adj position\\n          int adjPRow = curr.bRow - DIRS[dir][0]; \\n          int adjPCol = curr.bCol - DIRS[dir][1];\\n          if (adjBRow < 0 || adjBRow > rows - 1 || adjBCol < 0 || adjBCol > cols - 1 || \\n             adjPRow < 0 || adjPRow > rows - 1 || adjPCol < 0 || adjPCol > cols - 1 ||\\n              visited[adjBRow][adjBCol][dir] || \\n              grid[adjBRow][adjBCol] == \\'#\\' || grid[adjPRow][adjPCol] == \\'#\\' || \\n             !playerCanReachBox(grid, curr.pRow, curr.pCol, adjPRow, adjPCol, curr.bRow, curr.bCol))\\n            continue;\\n          if (grid[adjBRow][adjBCol] == \\'T\\')\\n            return steps;\\n          visited[adjBRow][adjBCol][dir] = true;\\n          deque.add(new State(curr.bRow, curr.bCol, adjBRow, adjBCol));\\n        }\\n      }\\n      steps++;\\n    }\\n    return -1;\\n  }\\n  private boolean playerCanReachBox(char[][] grid, int pRow1, int pCol1, int pRow2, int pCol2, int bRow, int bCol) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n    if (pRow1 == pRow2 && pCol1 == pCol2)\\n      return true;\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    deque.add(pRow1 * cols + pCol1);\\n    boolean[][] visited = new boolean[rows][cols];\\n    visited[pRow1][pCol1] = true;\\n    visited[bRow][bCol] = true;\\n    while (!deque.isEmpty()) {\\n      int index = deque.remove();\\n      int row = index / cols;\\n      int col = index % cols;\\n      for (int[] dir : DIRS) {\\n        int adjRow = row + dir[0];\\n        int adjCol = col + dir[1];\\n        if (adjRow < 0 || adjRow > rows - 1 || adjCol < 0 || adjCol > cols - 1 ||\\n            visited[adjRow][adjCol] || grid[adjRow][adjCol] == \\'#\\')\\n          continue;\\n        if (adjRow == pRow2 && adjCol == pCol2)\\n          return true;\\n        deque.add(adjRow * cols + adjCol);\\n        visited[adjRow][adjCol] = true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012970,
                "title": "c-a",
                "content": "Using custom Heap and A* algorithm from https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-astar\\n\\n```\\npublic class Solution \\n{\\n\\tpublic int MinPushBox(char[][] grid)\\n\\t{\\n\\t\\tPoint target = new Point();\\n\\t\\tPoint startBox = new Point();\\n\\t\\tPoint startPerson = new Point();\\n\\t\\tfor (int r = 0; r < grid.Length; ++r)\\n\\t\\t{\\n\\t\\t\\tfor (int c = 0; c < grid[r].Length; ++c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[r][c] == \\'T\\')\\n\\t\\t\\t\\t\\ttarget = new Point(r, c);\\n\\t\\t\\t\\telse if (grid[r][c] == \\'S\\')\\n\\t\\t\\t\\t\\tstartPerson = new Point(r, c);\\n\\t\\t\\t\\telse if (grid[r][c] == \\'B\\')\\n\\t\\t\\t\\t\\tstartBox = new Point(r, c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar heap = new Heap<State>((n1, n2) => n1.Priority.CompareTo(n2.Priority));\\n\\t\\tvar costSoFar = new Dictionary<(Point, Point), int>();\\n\\n\\t\\theap.Insert(new State { Priority = this.Heurestic(startBox, target), Box = startBox, Person = startPerson });\\n\\t\\tcostSoFar[(startBox, startPerson)] = 0;\\n\\n\\t\\twhile (heap.Count > 0)\\n\\t\\t{\\n\\t\\t\\tvar state = heap.RemoveMin();\\n\\n\\t\\t\\tif (state.Box == target)\\n\\t\\t\\t\\treturn state.Moves;\\n\\n\\t\\t\\tfor (int dr = -1; dr <= 1; dr++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int dc = -1; dc <= 1; dc++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif ((dr == 0 && dc == 0) || (dr != 0 && dc != 0))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tvar newPersonLocation = new Point(state.Person.Row + dr, state.Person.Col + dc);\\n\\t\\t\\t\\t\\tif (!this.CanMove(newPersonLocation, grid))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tvar currentState = (state.Box, state.Person);\\n\\n\\t\\t\\t\\t\\tif (newPersonLocation == state.Box)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar newBoxLocation = new Point(state.Box.Row + dr, state.Box.Col + dc);\\n\\t\\t\\t\\t\\t\\tif (!this.CanMove(newBoxLocation, grid))\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t\\tvar nextState = (newBoxLocation, newPersonLocation);\\n\\t\\t\\t\\t\\t\\tvar newCost = costSoFar[currentState] + 1;\\n\\t\\t\\t\\t\\t\\tif (!costSoFar.ContainsKey(nextState) || newCost < costSoFar[nextState])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcostSoFar[nextState] = newCost;\\n\\t\\t\\t\\t\\t\\t\\tint priority = newCost + this.Heurestic(newBoxLocation, target);\\n\\t\\t\\t\\t\\t\\t\\theap.Insert(new State { Box = newBoxLocation, Person = newPersonLocation, Moves = state.Moves + 1, Priority = priority });\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar nextState = (state.Box, newPersonLocation);\\n\\t\\t\\t\\t\\t\\tvar newCost = costSoFar[currentState];\\n\\t\\t\\t\\t\\t\\tif (!costSoFar.ContainsKey(nextState) || newCost < costSoFar[nextState])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcostSoFar[nextState] = newCost;\\n\\t\\t\\t\\t\\t\\t\\tint priority = newCost + this.Heurestic(state.Box, target);\\n\\t\\t\\t\\t\\t\\t\\theap.Insert(new State { Box = state.Box, Person = newPersonLocation, Moves = state.Moves, Priority = priority });\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tprivate bool CanMove(Point point, char[][] grid)\\n\\t{\\n\\t\\tbool invalidLocation =\\n\\t\\t\\tpoint.Row < 0 ||\\n\\t\\t\\tpoint.Row >= grid.Length ||\\n\\t\\t\\tpoint.Col < 0 ||\\n\\t\\t\\tpoint.Col >= grid[0].Length ||\\n\\t\\t\\tgrid[point.Row][point.Col] == \\'#\\';\\n\\n\\t\\treturn !invalidLocation;\\n\\t}\\n\\n\\tprivate int Heurestic(Point box, Point target) => Math.Abs(box.Row - target.Row) + Math.Abs(box.Col - target.Col);\\n\\n\\tpublic struct Point : IEquatable<Point>\\n\\t{\\n\\t\\tpublic Point(int row, int col) => (this.Row, this.Col) = (row, col);\\n\\n\\t\\tpublic int Row { get; set; }\\n\\n\\t\\tpublic int Col { get; set; }\\n\\n\\t\\tpublic static bool operator ==(Point p1, Point p2) => p1.Equals(p2);\\n\\n\\t\\tpublic static bool operator !=(Point p1, Point p2) => !p1.Equals(p2);\\n\\n\\t\\tpublic bool Equals(Point other) => this.Row == other.Row && this.Col == other.Col;\\n\\n\\t\\tpublic override bool Equals(object obj) => base.Equals(obj);\\n\\n\\t\\tpublic override int GetHashCode() => HashCode.Combine(Row, Col);\\n\\t}\\n\\n\\tpublic class State : IComparable<State>\\n\\t{\\n\\t\\tpublic int Priority { get; set; }\\n\\t\\tpublic int Moves { get; set; }\\n\\t\\tpublic Point Box { get; set; }\\n\\t\\tpublic Point Person { get; set; }\\n\\n\\t\\tpublic int CompareTo(State other) => this.Priority.CompareTo(other.Priority);\\n\\t}\\n\\t\\t\\n    public class Heap<T>\\n    {\\n        private readonly List<T> list = new List<T>();\\n\\n        private readonly Comparison<T> compare;\\n\\n        public Heap(Comparison<T> compare) => this.compare = compare;\\n\\n        public T Min\\n        {\\n            get => this.list[0];\\n        }\\n\\n        public int Count\\n        {\\n            get => this.list.Count;\\n        }\\n\\n        public void Insert(T item)\\n        {\\n            this.list.Add(item);\\n            this.FixHeapUp();\\n        }\\n\\n        public void Build(IList<T> items)\\n        {\\n            this.list.Clear();\\n            this.list.AddRange(items);\\n\\n            int parentIndex = this.GetParentIndex(items.Count - 1);\\n            int index;\\n            for (index = items.Count - 1; index >= 0; --index)\\n            {\\n                if (index != parentIndex)\\n                    break;\\n            }\\n\\n            for (int i = index; i >= 0; --i)\\n                this.FixHeapDown(i);\\n        }\\n\\n        public T RemoveMin()\\n        {\\n            T min = this.list[0];\\n\\n            if (this.list.Count == 1)\\n            {\\n                this.list.Clear();\\n            }\\n            else\\n            {\\n                this.list[0] = this.list[this.list.Count - 1];\\n                this.list.RemoveAt(this.list.Count - 1);\\n                this.FixHeapDown(0);\\n            }\\n\\n            return min;\\n        }\\n\\n        private int GetParentIndex(int index) => (index - 1) / 2;\\n\\n        private int GetLeftChildIndex(int index)\\n        {\\n            int leftIndex = 2 * index + 1;\\n            if (leftIndex >= this.list.Count)\\n                leftIndex = -1;\\n            return leftIndex;\\n        }\\n\\n        private int GetRightChildIndex(int index)\\n        {\\n            int rightIndex = 2 * index + 2;\\n            if (rightIndex >= this.list.Count)\\n                rightIndex = -1;\\n            return rightIndex;\\n        }\\n\\n        private void Swap(int i1, int i2)\\n        {\\n            T tmp = this.list[i1];\\n            this.list[i1] = this.list[i2];\\n            this.list[i2] = tmp;\\n        }\\n\\n        private void FixHeapUp()\\n        {\\n            int i = this.list.Count - 1;\\n            int parentIndex = this.GetParentIndex(i);\\n\\n            while (i != 0 && this.compare(this.list[parentIndex], this.list[i]) > 0)\\n            {\\n                this.Swap(parentIndex, i);\\n                i = this.GetParentIndex(i);\\n                parentIndex = this.GetParentIndex(i);\\n            }\\n        }\\n\\n        private void FixHeapDown(int rootIndex)\\n        {\\n            int leftChildIndex = this.GetLeftChildIndex(rootIndex);\\n            int rightChildIndex = this.GetRightChildIndex(rootIndex);\\n\\n            int smallestIndex = rootIndex;\\n\\n            if (leftChildIndex != -1 && rightChildIndex != -1)\\n            {\\n                smallestIndex = this.compare(this.list[leftChildIndex], this.list[rightChildIndex]) < 0\\n                    ? leftChildIndex\\n                    : rightChildIndex;\\n            }\\n            else if (leftChildIndex != -1)\\n                smallestIndex = leftChildIndex;\\n            else if (rightChildIndex != -1)\\n                smallestIndex = rightChildIndex;\\n\\n            smallestIndex = this.compare(this.list[smallestIndex], this.list[rootIndex]) < 0\\n                ? smallestIndex\\n                : rootIndex;\\n\\n            if (smallestIndex == rootIndex)\\n                return;\\n\\n            this.Swap(smallestIndex, rootIndex);\\n            this.FixHeapDown(smallestIndex);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n\\tpublic int MinPushBox(char[][] grid)\\n\\t{\\n\\t\\tPoint target = new Point();\\n\\t\\tPoint startBox = new Point();\\n\\t\\tPoint startPerson = new Point();\\n\\t\\tfor (int r = 0; r < grid.Length; ++r)\\n\\t\\t{\\n\\t\\t\\tfor (int c = 0; c < grid[r].Length; ++c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[r][c] == \\'T\\')\\n\\t\\t\\t\\t\\ttarget = new Point(r, c);\\n\\t\\t\\t\\telse if (grid[r][c] == \\'S\\')\\n\\t\\t\\t\\t\\tstartPerson = new Point(r, c);\\n\\t\\t\\t\\telse if (grid[r][c] == \\'B\\')\\n\\t\\t\\t\\t\\tstartBox = new Point(r, c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar heap = new Heap<State>((n1, n2) => n1.Priority.CompareTo(n2.Priority));\\n\\t\\tvar costSoFar = new Dictionary<(Point, Point), int>();\\n\\n\\t\\theap.Insert(new State { Priority = this.Heurestic(startBox, target), Box = startBox, Person = startPerson });\\n\\t\\tcostSoFar[(startBox, startPerson)] = 0;\\n\\n\\t\\twhile (heap.Count > 0)\\n\\t\\t{\\n\\t\\t\\tvar state = heap.RemoveMin();\\n\\n\\t\\t\\tif (state.Box == target)\\n\\t\\t\\t\\treturn state.Moves;\\n\\n\\t\\t\\tfor (int dr = -1; dr <= 1; dr++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int dc = -1; dc <= 1; dc++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif ((dr == 0 && dc == 0) || (dr != 0 && dc != 0))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tvar newPersonLocation = new Point(state.Person.Row + dr, state.Person.Col + dc);\\n\\t\\t\\t\\t\\tif (!this.CanMove(newPersonLocation, grid))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tvar currentState = (state.Box, state.Person);\\n\\n\\t\\t\\t\\t\\tif (newPersonLocation == state.Box)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar newBoxLocation = new Point(state.Box.Row + dr, state.Box.Col + dc);\\n\\t\\t\\t\\t\\t\\tif (!this.CanMove(newBoxLocation, grid))\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t\\tvar nextState = (newBoxLocation, newPersonLocation);\\n\\t\\t\\t\\t\\t\\tvar newCost = costSoFar[currentState] + 1;\\n\\t\\t\\t\\t\\t\\tif (!costSoFar.ContainsKey(nextState) || newCost < costSoFar[nextState])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcostSoFar[nextState] = newCost;\\n\\t\\t\\t\\t\\t\\t\\tint priority = newCost + this.Heurestic(newBoxLocation, target);\\n\\t\\t\\t\\t\\t\\t\\theap.Insert(new State { Box = newBoxLocation, Person = newPersonLocation, Moves = state.Moves + 1, Priority = priority });\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar nextState = (state.Box, newPersonLocation);\\n\\t\\t\\t\\t\\t\\tvar newCost = costSoFar[currentState];\\n\\t\\t\\t\\t\\t\\tif (!costSoFar.ContainsKey(nextState) || newCost < costSoFar[nextState])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcostSoFar[nextState] = newCost;\\n\\t\\t\\t\\t\\t\\t\\tint priority = newCost + this.Heurestic(state.Box, target);\\n\\t\\t\\t\\t\\t\\t\\theap.Insert(new State { Box = state.Box, Person = newPersonLocation, Moves = state.Moves, Priority = priority });\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tprivate bool CanMove(Point point, char[][] grid)\\n\\t{\\n\\t\\tbool invalidLocation =\\n\\t\\t\\tpoint.Row < 0 ||\\n\\t\\t\\tpoint.Row >= grid.Length ||\\n\\t\\t\\tpoint.Col < 0 ||\\n\\t\\t\\tpoint.Col >= grid[0].Length ||\\n\\t\\t\\tgrid[point.Row][point.Col] == \\'#\\';\\n\\n\\t\\treturn !invalidLocation;\\n\\t}\\n\\n\\tprivate int Heurestic(Point box, Point target) => Math.Abs(box.Row - target.Row) + Math.Abs(box.Col - target.Col);\\n\\n\\tpublic struct Point : IEquatable<Point>\\n\\t{\\n\\t\\tpublic Point(int row, int col) => (this.Row, this.Col) = (row, col);\\n\\n\\t\\tpublic int Row { get; set; }\\n\\n\\t\\tpublic int Col { get; set; }\\n\\n\\t\\tpublic static bool operator ==(Point p1, Point p2) => p1.Equals(p2);\\n\\n\\t\\tpublic static bool operator !=(Point p1, Point p2) => !p1.Equals(p2);\\n\\n\\t\\tpublic bool Equals(Point other) => this.Row == other.Row && this.Col == other.Col;\\n\\n\\t\\tpublic override bool Equals(object obj) => base.Equals(obj);\\n\\n\\t\\tpublic override int GetHashCode() => HashCode.Combine(Row, Col);\\n\\t}\\n\\n\\tpublic class State : IComparable<State>\\n\\t{\\n\\t\\tpublic int Priority { get; set; }\\n\\t\\tpublic int Moves { get; set; }\\n\\t\\tpublic Point Box { get; set; }\\n\\t\\tpublic Point Person { get; set; }\\n\\n\\t\\tpublic int CompareTo(State other) => this.Priority.CompareTo(other.Priority);\\n\\t}\\n\\t\\t\\n    public class Heap<T>\\n    {\\n        private readonly List<T> list = new List<T>();\\n\\n        private readonly Comparison<T> compare;\\n\\n        public Heap(Comparison<T> compare) => this.compare = compare;\\n\\n        public T Min\\n        {\\n            get => this.list[0];\\n        }\\n\\n        public int Count\\n        {\\n            get => this.list.Count;\\n        }\\n\\n        public void Insert(T item)\\n        {\\n            this.list.Add(item);\\n            this.FixHeapUp();\\n        }\\n\\n        public void Build(IList<T> items)\\n        {\\n            this.list.Clear();\\n            this.list.AddRange(items);\\n\\n            int parentIndex = this.GetParentIndex(items.Count - 1);\\n            int index;\\n            for (index = items.Count - 1; index >= 0; --index)\\n            {\\n                if (index != parentIndex)\\n                    break;\\n            }\\n\\n            for (int i = index; i >= 0; --i)\\n                this.FixHeapDown(i);\\n        }\\n\\n        public T RemoveMin()\\n        {\\n            T min = this.list[0];\\n\\n            if (this.list.Count == 1)\\n            {\\n                this.list.Clear();\\n            }\\n            else\\n            {\\n                this.list[0] = this.list[this.list.Count - 1];\\n                this.list.RemoveAt(this.list.Count - 1);\\n                this.FixHeapDown(0);\\n            }\\n\\n            return min;\\n        }\\n\\n        private int GetParentIndex(int index) => (index - 1) / 2;\\n\\n        private int GetLeftChildIndex(int index)\\n        {\\n            int leftIndex = 2 * index + 1;\\n            if (leftIndex >= this.list.Count)\\n                leftIndex = -1;\\n            return leftIndex;\\n        }\\n\\n        private int GetRightChildIndex(int index)\\n        {\\n            int rightIndex = 2 * index + 2;\\n            if (rightIndex >= this.list.Count)\\n                rightIndex = -1;\\n            return rightIndex;\\n        }\\n\\n        private void Swap(int i1, int i2)\\n        {\\n            T tmp = this.list[i1];\\n            this.list[i1] = this.list[i2];\\n            this.list[i2] = tmp;\\n        }\\n\\n        private void FixHeapUp()\\n        {\\n            int i = this.list.Count - 1;\\n            int parentIndex = this.GetParentIndex(i);\\n\\n            while (i != 0 && this.compare(this.list[parentIndex], this.list[i]) > 0)\\n            {\\n                this.Swap(parentIndex, i);\\n                i = this.GetParentIndex(i);\\n                parentIndex = this.GetParentIndex(i);\\n            }\\n        }\\n\\n        private void FixHeapDown(int rootIndex)\\n        {\\n            int leftChildIndex = this.GetLeftChildIndex(rootIndex);\\n            int rightChildIndex = this.GetRightChildIndex(rootIndex);\\n\\n            int smallestIndex = rootIndex;\\n\\n            if (leftChildIndex != -1 && rightChildIndex != -1)\\n            {\\n                smallestIndex = this.compare(this.list[leftChildIndex], this.list[rightChildIndex]) < 0\\n                    ? leftChildIndex\\n                    : rightChildIndex;\\n            }\\n            else if (leftChildIndex != -1)\\n                smallestIndex = leftChildIndex;\\n            else if (rightChildIndex != -1)\\n                smallestIndex = rightChildIndex;\\n\\n            smallestIndex = this.compare(this.list[smallestIndex], this.list[rootIndex]) < 0\\n                ? smallestIndex\\n                : rootIndex;\\n\\n            if (smallestIndex == rootIndex)\\n                return;\\n\\n            this.Swap(smallestIndex, rootIndex);\\n            this.FixHeapDown(smallestIndex);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798693,
                "title": "c-bfs-dfs-solution-32ms",
                "content": "```\\nvector<int> dx={1,0,-1,0};\\nvector<int> dy={0,1,0,-1};\\nint memo[20][20];\\nbool dfs(int i1,int j1,int i2,int j2,int b1,int b2,vector<vector<char>>& grid)\\n{\\n    memset(memo,0,sizeof(memo));  \\n    return hasPath(i1,j1,i2,j2,b1,b2,grid);\\n}\\nbool hasPath(int i1,int j1,int i2,int j2,int b1,int b2,vector<vector<char>>& grid)\\n{\\n    if(grid[i1][j1]==\\'#\\'||(i1==b1&&j1==b2))\\n        return false;\\n    memo[i1][j1]=1;\\n    if(i1==i2&&j1==j2)\\n        return true;\\n    else\\n    {\\n        bool q=false;\\n        for(int k=0;k<4;++k)\\n            if(i1+dx[k]<0||j1+dy[k]<0||i1+dx[k]>=grid.size()||j1+dy[k]>=grid[0].size()||memo[i1+dx[k]][j1+dy[k]])\\n                continue;\\n            else\\n                q=q||hasPath(i1+dx[k],j1+dy[k],i2,j2,b1,b2,grid);\\n        return q;\\n    }\\n            \\n}\\nint minPushBox(vector<vector<char>>& grid) \\n{\\n    int grey[20][20][20][20];\\n    memset(grey,0,sizeof(grey));\\n    queue<vector<int>> q;\\n    int n=grid.size(),m=grid[0].size();\\n    int i1,j1,i2,j2,e1,e2;\\n    for(int i=0;i<n;++i)\\n        for(int j=0;j<m;++j)\\n            if(grid[i][j]!=\\'#\\')\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    i2=i;\\n                    j2=j;\\n                }\\n                else if(grid[i][j]==\\'B\\')\\n                {\\n                    i1=i;\\n                    j1=j;\\n                }\\n                else if(grid[i][j]==\\'T\\')\\n                {\\n                    e1=i;\\n                    e2=j;\\n                }\\n            }\\n    q.push({i1,j1,i2,j2,0});\\n    grey[i1][j1][i2][j2]=1;\\n    while(!q.empty())\\n    {\\n        vector<int> temp=q.front();\\n        q.pop();\\n        i1=temp[0],j1=temp[1],i2=temp[2],j2=temp[3];\\n        int d=temp[4];\\n        if(i1==e1&&j1==e2)\\n            return d;\\n        else\\n        {\\n            if(i1+1<n&&grid[i1+1][j1]!=\\'#\\'&&i1>0&&grid[i1-1][j1]!=\\'#\\'&&dfs(i2,j2,i1-1,j1,i1,j1,grid)&&!grey[i1+1][j1][i1][j1])\\n            {\\n                q.push({i1+1,j1,i1,j1,d+1});\\n                grey[i1+1][j1][i1][j1]=1;\\n            }\\n            if(j1+1<m&&grid[i1][j1+1]!=\\'#\\'&&j1>0&&grid[i1][j1-1]!=\\'#\\'&&dfs(i2,j2,i1,j1-1,i1,j1,grid)&&!grey[i1][j1+1][i1][j1])\\n            {\\n                q.push({i1,j1+1,i1,j1,d+1});\\n                grey[i1][j1+1][i1][j1]=1;\\n            }\\n            if(i1>0&&grid[i1-1][j1]!=\\'#\\'&&i1+1<n&&grid[i1+1][j1]!=\\'#\\'&&dfs(i2,j2,i1+1,j1,i1,j1,grid)&&!grey[i1-1][j1][i1][j1])\\n            {\\n                q.push({i1-1,j1,i1,j1,d+1});\\n                grey[i1-1][j1][i1][j1]=1;\\n            }\\n            if(j1>0&&grid[i1][j1-1]!=\\'#\\'&&j1+1<m&&grid[i1][j1+1]!=\\'#\\'&&dfs(i2,j2,i1,j1+1,i1,j1,grid)&&!grey[i1][j1-1][i1][j1])\\n            {\\n                q.push({i1,j1-1,i1,j1,d+1});\\n                grey[i1][j1-1][i1][j1]=1;\\n            }\\n        }\\n            \\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<int> dx={1,0,-1,0};\\nvector<int> dy={0,1,0,-1};\\nint memo[20][20];\\nbool dfs(int i1,int j1,int i2,int j2,int b1,int b2,vector<vector<char>>& grid)\\n{\\n    memset(memo,0,sizeof(memo));  \\n    return hasPath(i1,j1,i2,j2,b1,b2,grid);\\n}\\nbool hasPath(int i1,int j1,int i2,int j2,int b1,int b2,vector<vector<char>>& grid)\\n{\\n    if(grid[i1][j1]==\\'#\\'||(i1==b1&&j1==b2))\\n        return false;\\n    memo[i1][j1]=1;\\n    if(i1==i2&&j1==j2)\\n        return true;\\n    else\\n    {\\n        bool q=false;\\n        for(int k=0;k<4;++k)\\n            if(i1+dx[k]<0||j1+dy[k]<0||i1+dx[k]>=grid.size()||j1+dy[k]>=grid[0].size()||memo[i1+dx[k]][j1+dy[k]])\\n                continue;\\n            else\\n                q=q||hasPath(i1+dx[k],j1+dy[k],i2,j2,b1,b2,grid);\\n        return q;\\n    }\\n            \\n}\\nint minPushBox(vector<vector<char>>& grid) \\n{\\n    int grey[20][20][20][20];\\n    memset(grey,0,sizeof(grey));\\n    queue<vector<int>> q;\\n    int n=grid.size(),m=grid[0].size();\\n    int i1,j1,i2,j2,e1,e2;\\n    for(int i=0;i<n;++i)\\n        for(int j=0;j<m;++j)\\n            if(grid[i][j]!=\\'#\\')\\n            {\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    i2=i;\\n                    j2=j;\\n                }\\n                else if(grid[i][j]==\\'B\\')\\n                {\\n                    i1=i;\\n                    j1=j;\\n                }\\n                else if(grid[i][j]==\\'T\\')\\n                {\\n                    e1=i;\\n                    e2=j;\\n                }\\n            }\\n    q.push({i1,j1,i2,j2,0});\\n    grey[i1][j1][i2][j2]=1;\\n    while(!q.empty())\\n    {\\n        vector<int> temp=q.front();\\n        q.pop();\\n        i1=temp[0],j1=temp[1],i2=temp[2],j2=temp[3];\\n        int d=temp[4];\\n        if(i1==e1&&j1==e2)\\n            return d;\\n        else\\n        {\\n            if(i1+1<n&&grid[i1+1][j1]!=\\'#\\'&&i1>0&&grid[i1-1][j1]!=\\'#\\'&&dfs(i2,j2,i1-1,j1,i1,j1,grid)&&!grey[i1+1][j1][i1][j1])\\n            {\\n                q.push({i1+1,j1,i1,j1,d+1});\\n                grey[i1+1][j1][i1][j1]=1;\\n            }\\n            if(j1+1<m&&grid[i1][j1+1]!=\\'#\\'&&j1>0&&grid[i1][j1-1]!=\\'#\\'&&dfs(i2,j2,i1,j1-1,i1,j1,grid)&&!grey[i1][j1+1][i1][j1])\\n            {\\n                q.push({i1,j1+1,i1,j1,d+1});\\n                grey[i1][j1+1][i1][j1]=1;\\n            }\\n            if(i1>0&&grid[i1-1][j1]!=\\'#\\'&&i1+1<n&&grid[i1+1][j1]!=\\'#\\'&&dfs(i2,j2,i1+1,j1,i1,j1,grid)&&!grey[i1-1][j1][i1][j1])\\n            {\\n                q.push({i1-1,j1,i1,j1,d+1});\\n                grey[i1-1][j1][i1][j1]=1;\\n            }\\n            if(j1>0&&grid[i1][j1-1]!=\\'#\\'&&j1+1<m&&grid[i1][j1+1]!=\\'#\\'&&dfs(i2,j2,i1,j1+1,i1,j1,grid)&&!grey[i1][j1-1][i1][j1])\\n            {\\n                q.push({i1,j1-1,i1,j1,d+1});\\n                grey[i1][j1-1][i1][j1]=1;\\n            }\\n        }\\n            \\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751767,
                "title": "idiomatic-rust-using-bfs",
                "content": "Long but idiomatic solution in Rust.\\n\\n```\\nuse std::collections::{HashSet, VecDeque};\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nenum Tile {\\n    Wall,\\n    Empty,\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nstruct Position {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Position {\\n    pub fn new(i: usize, j: usize) -> Position {\\n        Position { i, j }\\n    }\\n\\n    pub fn pos_in_dir(&self, d: Direction, grid_sizes: Position) -> Option<Position> {\\n        let adj_pos = match d {\\n            Direction::Right => Position::new(self.i, self.j + 1),\\n            Direction::Left => Position::new(self.i, self.j.checked_sub(1)?),\\n            Direction::Down => Position::new(self.i + 1, self.j),\\n            Direction::Up => Position::new(self.i.checked_sub(1)?, self.j),\\n        };\\n\\n        if adj_pos.i < grid_sizes.i && adj_pos.j < grid_sizes.j {\\n            Some(adj_pos)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nstruct State {\\n    box_pos: Position,\\n    player_pos: Position,\\n}\\n\\nimpl State {\\n    pub fn new(box_pos: Position, player_pos: Position) -> State {\\n        State {\\n            box_pos,\\n            player_pos,\\n        }\\n    }\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nenum Direction {\\n    Right,\\n    Left,\\n    Down,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn opposite(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Left,\\n            Direction::Left => Direction::Right,\\n            Direction::Down => Direction::Up,\\n            Direction::Up => Direction::Down,\\n        }\\n    }\\n}\\n\\nlazy_static! {\\n    static ref DIRECTIONS: Vec<Direction> = vec![\\n        Direction::Right,\\n        Direction::Left,\\n        Direction::Down,\\n        Direction::Up,\\n    ];\\n}\\n\\n/// Returns a list of tuples of `(expected_player_position, moved_box_position)`.\\n/// If the player were to reach `expected_player_position`, the box could be moved to `moved_box_position`.\\nfn push_positions(grid: &Vec<Vec<Tile>>, box_pos: Position) -> Vec<(Position, Position)> {\\n    let mut res = vec![];\\n\\n    let grid_sizes = Position::new(grid.len(), grid[0].len());\\n    for direction in &*DIRECTIONS {\\n        let new_player_pos = box_pos.pos_in_dir(direction.opposite(), grid_sizes);\\n        let new_box_pos = box_pos.pos_in_dir(*direction, grid_sizes);\\n        if let (Some(new_player_pos), Some(new_box_pos)) = (new_player_pos, new_box_pos) {\\n            if grid[new_player_pos.i][new_player_pos.j] == Tile::Empty\\n                && grid[new_box_pos.i][new_box_pos.j] == Tile::Empty\\n            {\\n                res.push((new_player_pos, new_box_pos))\\n            }\\n        }\\n    }\\n\\n    res\\n}\\n\\n/// Returns whether the player can move from `state.player_pos` to `new_player_pos`.\\n/// Player cannot move through `Tile::Wall` or `state.box_pos`.\\nfn can_move_player(grid: &Vec<Vec<Tile>>, state: State, new_player_pos: Position) -> bool {\\n    let mut worklist = vec![state.player_pos];\\n\\n    let grid_sizes = Position::new(grid.len(), grid[0].len());\\n    let mut visited = HashSet::new();\\n    visited.insert(state.player_pos);\\n    while let Some(player_pos) = worklist.pop() {\\n        if player_pos == new_player_pos {\\n            return true;\\n        }\\n\\n        for direction in &*DIRECTIONS {\\n            if let Some(adj_pos) = player_pos.pos_in_dir(*direction, grid_sizes) {\\n                if grid[adj_pos.i][adj_pos.j] == Tile::Empty\\n                    && adj_pos != state.box_pos\\n                    && visited.insert(adj_pos)\\n                {\\n                    worklist.push(adj_pos);\\n                }\\n            }\\n        }\\n    }\\n\\n    false\\n}\\n\\n/// Returns the minimum number of pushes to get the box from `start` to `end` given\\n/// the player position `player`.\\nfn num_pushes(\\n    grid: &Vec<Vec<Tile>>,\\n    box_pos: Position,\\n    end: Position,\\n    player_pos: Position,\\n) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    let init_state = State::new(box_pos, player_pos);\\n    q.push_back((0, init_state));\\n\\n    let mut visited = HashSet::new();\\n    visited.insert(init_state);\\n    while let Some((cur_dist, state)) = q.pop_front() {\\n        if state.box_pos == end {\\n            return Some(cur_dist);\\n        }\\n\\n        // let mut s = vec![\"\".to_string(); grid.len()];\\n        // for (i, row) in grid.iter().enumerate() {\\n        //     for (j, tile) in row.iter().enumerate() {\\n        //         if *tile == Tile::Empty {\\n        //             s[i].push(\\'.\\');\\n        //         } else {\\n        //             s[i].push(\\'#\\');\\n        //         }\\n\\n        //         if Position::new(i, j) == state.box_pos {\\n        //             s[i].pop();\\n        //             s[i].push(\\'B\\');\\n        //         } else if Position::new(i, j) == state.player_pos {\\n        //             s[i].pop();\\n        //             s[i].push(\\'P\\');\\n        //         }\\n        //     }\\n        //     println!(\"{:?}\", s[i]);\\n        // }\\n        // println!(\"------\");\\n\\n        // For each position the box can be pushed into, check if the player can move behind the box.\\n        for (expected_player_pos, new_box_pos) in push_positions(grid, state.box_pos) {\\n            let new_state = State::new(new_box_pos, expected_player_pos);\\n            // Order is important here! If we insert before moving, we can discount some possibilities early.\\n            if can_move_player(grid, state, expected_player_pos) && visited.insert(new_state) {\\n                q.push_back((cur_dist + 1, new_state));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\npub fn min_push_box(grid: Vec<Vec<char>>) -> i32 {\\n    let mut box_pos = None;\\n    let mut end = None;\\n    let mut player_pos = None;\\n    let mut grid_tile = vec![vec![]; grid.len()];\\n    for (i, row) in grid.into_iter().enumerate() {\\n        for (j, ch) in row.into_iter().enumerate() {\\n            match &ch {\\n                \\'#\\' => grid_tile[i].push(Tile::Wall),\\n                _ => grid_tile[i].push(Tile::Empty),\\n            }\\n\\n            match ch {\\n                \\'B\\' => box_pos = Some(Position::new(i, j)),\\n                \\'T\\' => end = Some(Position::new(i, j)),\\n                \\'S\\' => player_pos = Some(Position::new(i, j)),\\n                _ => {}\\n            }\\n        }\\n    }\\n\\n    match num_pushes(\\n        &grid_tile,\\n        box_pos.unwrap(),\\n        end.unwrap(),\\n        player_pos.unwrap(),\\n    ) {\\n        Some(x) => x as i32,\\n        None => -1,\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_num_box_pushes() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 3);\\n    }\\n\\n    #[test]\\n    fn test_num_box_pushes_five_pushes() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'T\\', \\'.\\', \\'.\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 5);\\n    }\\n\\n    #[test]\\n    fn test_num_box_pushes_difficult() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 8);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::{HashSet, VecDeque};\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nenum Tile {\\n    Wall,\\n    Empty,\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nstruct Position {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Position {\\n    pub fn new(i: usize, j: usize) -> Position {\\n        Position { i, j }\\n    }\\n\\n    pub fn pos_in_dir(&self, d: Direction, grid_sizes: Position) -> Option<Position> {\\n        let adj_pos = match d {\\n            Direction::Right => Position::new(self.i, self.j + 1),\\n            Direction::Left => Position::new(self.i, self.j.checked_sub(1)?),\\n            Direction::Down => Position::new(self.i + 1, self.j),\\n            Direction::Up => Position::new(self.i.checked_sub(1)?, self.j),\\n        };\\n\\n        if adj_pos.i < grid_sizes.i && adj_pos.j < grid_sizes.j {\\n            Some(adj_pos)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nstruct State {\\n    box_pos: Position,\\n    player_pos: Position,\\n}\\n\\nimpl State {\\n    pub fn new(box_pos: Position, player_pos: Position) -> State {\\n        State {\\n            box_pos,\\n            player_pos,\\n        }\\n    }\\n}\\n\\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\\nenum Direction {\\n    Right,\\n    Left,\\n    Down,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn opposite(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Left,\\n            Direction::Left => Direction::Right,\\n            Direction::Down => Direction::Up,\\n            Direction::Up => Direction::Down,\\n        }\\n    }\\n}\\n\\nlazy_static! {\\n    static ref DIRECTIONS: Vec<Direction> = vec![\\n        Direction::Right,\\n        Direction::Left,\\n        Direction::Down,\\n        Direction::Up,\\n    ];\\n}\\n\\n/// Returns a list of tuples of `(expected_player_position, moved_box_position)`.\\n/// If the player were to reach `expected_player_position`, the box could be moved to `moved_box_position`.\\nfn push_positions(grid: &Vec<Vec<Tile>>, box_pos: Position) -> Vec<(Position, Position)> {\\n    let mut res = vec![];\\n\\n    let grid_sizes = Position::new(grid.len(), grid[0].len());\\n    for direction in &*DIRECTIONS {\\n        let new_player_pos = box_pos.pos_in_dir(direction.opposite(), grid_sizes);\\n        let new_box_pos = box_pos.pos_in_dir(*direction, grid_sizes);\\n        if let (Some(new_player_pos), Some(new_box_pos)) = (new_player_pos, new_box_pos) {\\n            if grid[new_player_pos.i][new_player_pos.j] == Tile::Empty\\n                && grid[new_box_pos.i][new_box_pos.j] == Tile::Empty\\n            {\\n                res.push((new_player_pos, new_box_pos))\\n            }\\n        }\\n    }\\n\\n    res\\n}\\n\\n/// Returns whether the player can move from `state.player_pos` to `new_player_pos`.\\n/// Player cannot move through `Tile::Wall` or `state.box_pos`.\\nfn can_move_player(grid: &Vec<Vec<Tile>>, state: State, new_player_pos: Position) -> bool {\\n    let mut worklist = vec![state.player_pos];\\n\\n    let grid_sizes = Position::new(grid.len(), grid[0].len());\\n    let mut visited = HashSet::new();\\n    visited.insert(state.player_pos);\\n    while let Some(player_pos) = worklist.pop() {\\n        if player_pos == new_player_pos {\\n            return true;\\n        }\\n\\n        for direction in &*DIRECTIONS {\\n            if let Some(adj_pos) = player_pos.pos_in_dir(*direction, grid_sizes) {\\n                if grid[adj_pos.i][adj_pos.j] == Tile::Empty\\n                    && adj_pos != state.box_pos\\n                    && visited.insert(adj_pos)\\n                {\\n                    worklist.push(adj_pos);\\n                }\\n            }\\n        }\\n    }\\n\\n    false\\n}\\n\\n/// Returns the minimum number of pushes to get the box from `start` to `end` given\\n/// the player position `player`.\\nfn num_pushes(\\n    grid: &Vec<Vec<Tile>>,\\n    box_pos: Position,\\n    end: Position,\\n    player_pos: Position,\\n) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    let init_state = State::new(box_pos, player_pos);\\n    q.push_back((0, init_state));\\n\\n    let mut visited = HashSet::new();\\n    visited.insert(init_state);\\n    while let Some((cur_dist, state)) = q.pop_front() {\\n        if state.box_pos == end {\\n            return Some(cur_dist);\\n        }\\n\\n        // let mut s = vec![\"\".to_string(); grid.len()];\\n        // for (i, row) in grid.iter().enumerate() {\\n        //     for (j, tile) in row.iter().enumerate() {\\n        //         if *tile == Tile::Empty {\\n        //             s[i].push(\\'.\\');\\n        //         } else {\\n        //             s[i].push(\\'#\\');\\n        //         }\\n\\n        //         if Position::new(i, j) == state.box_pos {\\n        //             s[i].pop();\\n        //             s[i].push(\\'B\\');\\n        //         } else if Position::new(i, j) == state.player_pos {\\n        //             s[i].pop();\\n        //             s[i].push(\\'P\\');\\n        //         }\\n        //     }\\n        //     println!(\"{:?}\", s[i]);\\n        // }\\n        // println!(\"------\");\\n\\n        // For each position the box can be pushed into, check if the player can move behind the box.\\n        for (expected_player_pos, new_box_pos) in push_positions(grid, state.box_pos) {\\n            let new_state = State::new(new_box_pos, expected_player_pos);\\n            // Order is important here! If we insert before moving, we can discount some possibilities early.\\n            if can_move_player(grid, state, expected_player_pos) && visited.insert(new_state) {\\n                q.push_back((cur_dist + 1, new_state));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\npub fn min_push_box(grid: Vec<Vec<char>>) -> i32 {\\n    let mut box_pos = None;\\n    let mut end = None;\\n    let mut player_pos = None;\\n    let mut grid_tile = vec![vec![]; grid.len()];\\n    for (i, row) in grid.into_iter().enumerate() {\\n        for (j, ch) in row.into_iter().enumerate() {\\n            match &ch {\\n                \\'#\\' => grid_tile[i].push(Tile::Wall),\\n                _ => grid_tile[i].push(Tile::Empty),\\n            }\\n\\n            match ch {\\n                \\'B\\' => box_pos = Some(Position::new(i, j)),\\n                \\'T\\' => end = Some(Position::new(i, j)),\\n                \\'S\\' => player_pos = Some(Position::new(i, j)),\\n                _ => {}\\n            }\\n        }\\n    }\\n\\n    match num_pushes(\\n        &grid_tile,\\n        box_pos.unwrap(),\\n        end.unwrap(),\\n        player_pos.unwrap(),\\n    ) {\\n        Some(x) => x as i32,\\n        None => -1,\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_num_box_pushes() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 3);\\n    }\\n\\n    #[test]\\n    fn test_num_box_pushes_five_pushes() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'T\\', \\'.\\', \\'.\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 5);\\n    }\\n\\n    #[test]\\n    fn test_num_box_pushes_difficult() {\\n        let grid = vec![\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'S\\', \\'#\\'],\\n            vec![\\'#\\', \\'.\\', \\'.\\', \\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\n        ];\\n\\n        assert_eq!(min_push_box(grid), 8);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535264,
                "title": "need-help-for-one-test-case",
                "content": "In my opinion, for the test case below, the answer should be 5 instead of 7\\n\\n```\\n{\\n{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'T\\',\\'#\\',\\'.\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'B\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'S\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'}\\n}\\n```\\n\\nhere is the path of moving block:\\n\\n![image](https://assets.leetcode.com/users/codecarfield/image_1583850957.png)\\n",
                "solutionTags": [],
                "code": "```\\n{\\n{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'T\\',\\'#\\',\\'.\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'B\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'S\\',\\'#\\'},\\n{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498003,
                "title": "javascript-a-search-implementation",
                "content": "168 ms, 45.9MB\\n\\nAn ugly implementation, but since didn\\'t see a javascript implementation of this yet decided to post mine up to see if it helps someone. The priorityqueue implementation was straight lifted from a stack overflow post. Basically a* search is bfs + heuristics + priorityqueue. Used the same heuristic that many other users are using which is just the manhattan distance + number of moves thus far.\\n\\nOriginally I try to just solve this without using a priorityqueue and just sorting the array at every loop, but the time penalty was too great (I naively thought time complexity will remain the same assuming that nlogn of sort is equivalent to heapifying n moves, but I realized that at each instance you are only really considering 5 new states to push in to the queue so it\\'s not the same). Also, now looking at it using Map for states was probably not necessary, probably would\\'ve been better to use a Set and use...\\n((block[0]*grid[0].length)+block[1])*(grid[0].length*grid.length) +((character[0]*grid[0].length)+character[1])\\n\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst top = 0;\\nconst parent = i => ((i + 1) >>> 1) - 1;\\nconst left = i => (i << 1) + 1;\\nconst right = i => (i + 1) << 1;\\n\\nclass PriorityQueue {\\n  constructor(comparator = (a, b) => a > b) {\\n    this._heap = [];\\n    this._comparator = comparator;\\n  }\\n  size() {\\n    return this._heap.length;\\n  }\\n  isEmpty() {\\n    return this.size() == 0;\\n  }\\n  peek() {\\n    return this._heap[top];\\n  }\\n  push(...values) {\\n    values.forEach(value => {\\n      this._heap.push(value);\\n      this._siftUp();\\n    });\\n    return this.size();\\n  }\\n  pop() {\\n    const poppedValue = this.peek();\\n    const bottom = this.size() - 1;\\n    if (bottom > top) {\\n      this._swap(top, bottom);\\n    }\\n    this._heap.pop();\\n    this._siftDown();\\n    return poppedValue;\\n  }\\n  replace(value) {\\n    const replacedValue = this.peek();\\n    this._heap[top] = value;\\n    this._siftDown();\\n    return replacedValue;\\n  }\\n  _greater(i, j) {\\n    return this._comparator(this._heap[i], this._heap[j]);\\n  }\\n  _swap(i, j) {\\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\\n  }\\n  _siftUp() {\\n    let node = this.size() - 1;\\n    while (node > top && this._greater(node, parent(node))) {\\n      this._swap(node, parent(node));\\n      node = parent(node);\\n    }\\n  }\\n  _siftDown() {\\n    let node = top;\\n    while (\\n      (left(node) < this.size() && this._greater(left(node), node)) ||\\n      (right(node) < this.size() && this._greater(right(node), node))\\n    ) {\\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\\n      this._swap(node, maxChild);\\n      node = maxChild;\\n    }\\n  }\\n}\\n\\nvar minPushBox = function(grid) {\\n    if(typeof(grid)===\\'undefined\\' || grid===null\\n       || grid.length===0 || grid[0].length===0){\\n        return -1;\\n    }\\n    \\n    let TARGET = null;\\n    let startBlk = null;\\n    let startPer = null;\\n    const DIR = [\\n        [0,1], [1,0], [0,-1], [-1,0]\\n    ];\\n    \\n    for(let i = 0; i<grid.length; i++){\\n        for(let j = 0; j<grid[0].length; j++){\\n            if(grid[i][j]===\\'S\\'){\\n                startPer = [i,j];\\n                grid[i][j]=\\'.\\';\\n            }\\n            if(grid[i][j]===\\'T\\'){\\n                TARGET = [i,j];\\n            }\\n            if(grid[i][j]===\\'B\\'){\\n                startBlk = [i,j];\\n                grid[i][j]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    let queue = new PriorityQueue((a,b)=>a.weight<b.weight);\\n    let states = new Map();\\n    queue.push({weight: manDist(startBlk), block: startBlk, character: startPer, move: 0});\\n    while(!queue.isEmpty()){\\n        let {weight,block,character,move} = queue.pop();\\n        if(TARGET[0]===block[0] && TARGET[1]===block[1]){\\n            return move;\\n        }\\n        let key = (block[0]*grid[0].length)+block[1];\\n        let val = (character[0]*grid[0].length)+character[1];\\n        if(!states.has(key)){\\n            states.set(key,new Set());\\n        }\\n        states.get(key).add(val);\\n        DIR.forEach(d=>{\\n            let i = d[0]+character[0];\\n            let j = d[1]+character[1];\\n            let curV = (i*grid[0].length)+j;\\n            if(validMove(i,j,block[0],block[1]) && !states.get(key).has(curV)){\\n                queue.push({weight: manDist(block)+move, block: block, character: [i,j], move: move});\\n            }\\n        });\\n        let pushDir = tryPush(character,block);\\n        if(pushDir!==null){\\n            let newBlk = [block[0]+pushDir[0],block[1]+pushDir[1]];\\n            let newCha = [character[0]+pushDir[0],character[1]+pushDir[1]];\\n            let nBK = (newBlk[0]*grid[0].length)+newBlk[1];\\n            let nVal = (newCha[0]*grid[0].length)+newCha[1];\\n            if(!states.has(nBK) || !states.get(nBK).has(nVal)){\\n                queue.push({weight: manDist(newBlk)+(move+1), block: newBlk, character: newCha, move: move+1});  \\n            }\\n        }\\n    }\\n    \\n    return -1;\\n    \\n    \\n    function manDist(block){\\n        let [x,y] = TARGET;\\n        let [i,j] = block;\\n        return Math.abs(x-i) + Math.abs(y-j);\\n    }\\n    function validMove(i,j,x=null,y=null){\\n        if(i<0 || j<0 || i>=grid.length || \\n           j>=grid[0].length){\\n            return false;\\n        }\\n        if(((x!==null&&(i===x)) && (y!==null&&(j===y))) || grid[i][j]===\\'#\\'){\\n            return false;\\n        }\\n        return true;\\n    }\\n    function tryPush(c,b){\\n        let [i,j] = c;\\n        let [x,y] = b;\\n        for(let u = 0; u<DIR.length; u++){\\n            let [v,w] = DIR[u];\\n            if(((Math.abs(x-i)===1 && y===j) || (Math.abs(y-j)===1 && x===i)) && validMove(i+v,j+w) && validMove(x+v,y+w) && (i+v)===x && (j+w)===y){\\n                return [v,w];\\n            }\\n        }\\n        return null;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst top = 0;\\nconst parent = i => ((i + 1) >>> 1) - 1;\\nconst left = i => (i << 1) + 1;\\nconst right = i => (i + 1) << 1;\\n\\nclass PriorityQueue {\\n  constructor(comparator = (a, b) => a > b) {\\n    this._heap = [];\\n    this._comparator = comparator;\\n  }\\n  size() {\\n    return this._heap.length;\\n  }\\n  isEmpty() {\\n    return this.size() == 0;\\n  }\\n  peek() {\\n    return this._heap[top];\\n  }\\n  push(...values) {\\n    values.forEach(value => {\\n      this._heap.push(value);\\n      this._siftUp();\\n    });\\n    return this.size();\\n  }\\n  pop() {\\n    const poppedValue = this.peek();\\n    const bottom = this.size() - 1;\\n    if (bottom > top) {\\n      this._swap(top, bottom);\\n    }\\n    this._heap.pop();\\n    this._siftDown();\\n    return poppedValue;\\n  }\\n  replace(value) {\\n    const replacedValue = this.peek();\\n    this._heap[top] = value;\\n    this._siftDown();\\n    return replacedValue;\\n  }\\n  _greater(i, j) {\\n    return this._comparator(this._heap[i], this._heap[j]);\\n  }\\n  _swap(i, j) {\\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\\n  }\\n  _siftUp() {\\n    let node = this.size() - 1;\\n    while (node > top && this._greater(node, parent(node))) {\\n      this._swap(node, parent(node));\\n      node = parent(node);\\n    }\\n  }\\n  _siftDown() {\\n    let node = top;\\n    while (\\n      (left(node) < this.size() && this._greater(left(node), node)) ||\\n      (right(node) < this.size() && this._greater(right(node), node))\\n    ) {\\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\\n      this._swap(node, maxChild);\\n      node = maxChild;\\n    }\\n  }\\n}\\n\\nvar minPushBox = function(grid) {\\n    if(typeof(grid)===\\'undefined\\' || grid===null\\n       || grid.length===0 || grid[0].length===0){\\n        return -1;\\n    }\\n    \\n    let TARGET = null;\\n    let startBlk = null;\\n    let startPer = null;\\n    const DIR = [\\n        [0,1], [1,0], [0,-1], [-1,0]\\n    ];\\n    \\n    for(let i = 0; i<grid.length; i++){\\n        for(let j = 0; j<grid[0].length; j++){\\n            if(grid[i][j]===\\'S\\'){\\n                startPer = [i,j];\\n                grid[i][j]=\\'.\\';\\n            }\\n            if(grid[i][j]===\\'T\\'){\\n                TARGET = [i,j];\\n            }\\n            if(grid[i][j]===\\'B\\'){\\n                startBlk = [i,j];\\n                grid[i][j]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    let queue = new PriorityQueue((a,b)=>a.weight<b.weight);\\n    let states = new Map();\\n    queue.push({weight: manDist(startBlk), block: startBlk, character: startPer, move: 0});\\n    while(!queue.isEmpty()){\\n        let {weight,block,character,move} = queue.pop();\\n        if(TARGET[0]===block[0] && TARGET[1]===block[1]){\\n            return move;\\n        }\\n        let key = (block[0]*grid[0].length)+block[1];\\n        let val = (character[0]*grid[0].length)+character[1];\\n        if(!states.has(key)){\\n            states.set(key,new Set());\\n        }\\n        states.get(key).add(val);\\n        DIR.forEach(d=>{\\n            let i = d[0]+character[0];\\n            let j = d[1]+character[1];\\n            let curV = (i*grid[0].length)+j;\\n            if(validMove(i,j,block[0],block[1]) && !states.get(key).has(curV)){\\n                queue.push({weight: manDist(block)+move, block: block, character: [i,j], move: move});\\n            }\\n        });\\n        let pushDir = tryPush(character,block);\\n        if(pushDir!==null){\\n            let newBlk = [block[0]+pushDir[0],block[1]+pushDir[1]];\\n            let newCha = [character[0]+pushDir[0],character[1]+pushDir[1]];\\n            let nBK = (newBlk[0]*grid[0].length)+newBlk[1];\\n            let nVal = (newCha[0]*grid[0].length)+newCha[1];\\n            if(!states.has(nBK) || !states.get(nBK).has(nVal)){\\n                queue.push({weight: manDist(newBlk)+(move+1), block: newBlk, character: newCha, move: move+1});  \\n            }\\n        }\\n    }\\n    \\n    return -1;\\n    \\n    \\n    function manDist(block){\\n        let [x,y] = TARGET;\\n        let [i,j] = block;\\n        return Math.abs(x-i) + Math.abs(y-j);\\n    }\\n    function validMove(i,j,x=null,y=null){\\n        if(i<0 || j<0 || i>=grid.length || \\n           j>=grid[0].length){\\n            return false;\\n        }\\n        if(((x!==null&&(i===x)) && (y!==null&&(j===y))) || grid[i][j]===\\'#\\'){\\n            return false;\\n        }\\n        return true;\\n    }\\n    function tryPush(c,b){\\n        let [i,j] = c;\\n        let [x,y] = b;\\n        for(let u = 0; u<DIR.length; u++){\\n            let [v,w] = DIR[u];\\n            if(((Math.abs(x-i)===1 && y===j) || (Math.abs(y-j)===1 && x===i)) && validMove(i+v,j+w) && validMove(x+v,y+w) && (i+v)===x && (j+w)===y){\\n                return [v,w];\\n            }\\n        }\\n        return null;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493343,
                "title": "c-two-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> dx = {0, 1, 0, -1};\\n    vector<int> dy = {1, 0, -1, 0};\\n    pair<int, int> B;\\n    pair<int, int> P;\\n    pair<int, int> T;\\n    \\n    struct node {\\n        int x;\\n        int y;\\n        int px;\\n        int py;\\n        node(int x, int y, int px, int py) : x(x), y(y), px(px), py(py) {\\n            \\n        };\\n        string to_string() {\\n            return std::to_string(x) + \"-\" + \\n                   std::to_string(y) + \"-\" + \\n                   std::to_string(px) + \"-\" + \\n                   std::to_string(py);\\n            \\n        }\\n    };\\n    \\n    bool inside(vector<vector<char>>& grid, int x, int y) {\\n        return x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size();\\n    }\\n\\n    bool canReachPosition(vector<vector<char>>& grid, \\n                          int px, int py,\\n                          int tx, int ty, \\n                          int bx, int by) {\\n        if(!inside(grid, tx, ty)) return false;\\n        if(grid[tx][ty] == \\'#\\') return false;\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<bool>> seen(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({px, py}); \\n        seen[px][py] = true;\\n        seen[bx][by] = true;\\n        \\n        while(!q.empty()) {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            if(x == tx && y == ty) return true;\\n            \\n            for(int k = 0; k < 4; k++) {\\n                int nx = x + dx[k], ny = y + dy[k];\\n                if(!inside(grid, nx, ny)) continue;\\n                if(seen[nx][ny] || grid[nx][ny] == \\'#\\') continue;\\n                q.push({nx, ny});\\n                seen[nx][ny] = true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<node> expand(vector<vector<char>>& grid, node n) {\\n        vector<node> nodes;\\n        int bx = n.x,  by = n.y;\\n        int px = n.px, py = n.py;\\n        \\n        for(int k = 0; k < 4; k++) {\\n            int nbx = bx + dx[k], nby = by + dy[k];\\n            int tx  = bx - dx[k], ty  = by - dy[k];\\n            \\n            if(!inside(grid, nbx, nby)) continue;\\n            if(grid[nbx][nby] == \\'#\\') continue;\\n            \\n            if(canReachPosition(grid, px, py, tx, ty, bx, by))\\n                nodes.push_back(node(nbx, nby, bx, by));\\n        }\\n        return nodes;\\n    }\\n    bool canReachBox(vector<vector<char>>& grid) {\\n        int px = P.first, py = P.second;\\n        int bx = B.first, by = B.second;\\n        for(int k = 0; k < 4; k++) {\\n            int tx = bx + dx[k];\\n            int ty = by + dy[k];\\n            if(!inside(grid, tx, ty)) continue;\\n            if(grid[tx][ty] == \\'#\\') continue;\\n            if(canReachPosition(grid, px, py, tx, ty, bx, by)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == \\'B\\') {\\n                    B = make_pair(i, j);\\n                    grid[i][j] = \\'.\\';\\n                } \\n                else if(grid[i][j] == \\'S\\') {\\n                    P = make_pair(i, j);\\n                    grid[i][j] = \\'.\\';\\n                } else if(grid[i][j] == \\'T\\') {\\n                    T = make_pair(i, j);\\n                    grid[i][j] = \\'.\\';\\n                } \\n            }\\n        }\\n        if(!canReachBox(grid)) return -1;\\n        \\n        \\n        queue<node> q;\\n        unordered_set<string> seen;\\n        for(int k = 0; k < 4; k++) {\\n            int tx = B.first + dx[k];\\n            int ty = B.second + dy[k];\\n            if(!canReachPosition(grid, P.first, P.second, tx, ty, B.first, B.second)) \\n                continue;\\n            auto nd = node(B.first, B.second, tx, ty);\\n            q.push(nd);\\n            seen.insert(nd.to_string());\\n        }\\n        int steps = 0;\\n        while(!q.empty()) {\\n            for(int t = q.size(); t > 0; t--) {\\n                auto node = q.front(); q.pop();\\n                int x = node.x, y = node.y;\\n                if(x == T.first && y == T.second) return steps;\\n                auto nodes = expand(grid, node);\\n                \\n                for(auto &node : nodes) {\\n                    if(seen.count(node.to_string())) continue;\\n                    q.push(node);\\n                    seen.insert(node.to_string());\\n                }   \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> dx = {0, 1, 0, -1}",
                "codeTag": "Java"
            },
            {
                "id": 445475,
                "title": "python-dijkstra-solution",
                "content": "```\\nclass Solution:\\n    def minPushBox(self, m: List[List[str]]) -> int:\\n        de = ((1,0),(0,1),(-1,0),(0,-1))\\n        rl,cl = len(m),len(m[0])\\n        memo, q = set(), []\\n        for i in range(rl):\\n            for j in range(cl):\\n                if m[i][j] == \"T\":\\n                    tx,ty = i,j\\n                elif m[i][j] == \"S\":\\n                    a,b = i,j\\n                elif m[i][j] == \"B\":\\n                    c,d = i,j\\n        memo.add((a, b, c, d))\\n        q += (0,a,b,c,d),\\n        while q:\\n            t, x, y, bx, by = heapq.heappop(q)\\n            for d in de:\\n                nx, ny = x + d[0], y + d[1]\\n                if 0 <= nx < rl and 0 <= ny < cl:\\n                    nbx, nby = bx + d[0], by + d[1]\\n                    if nx == bx and ny == by and 0 <= nbx < rl and 0 <= nby < cl and m[nbx][nby] != \"#\" and (nx, ny, nbx, nby) not in memo:\\n                        if nbx == tx and nby == ty:\\n                            return t + 1\\n                        memo.add((nx, ny, nbx, nby))\\n                        heapq.heappush(q, (t + 1, nx, ny, nbx, nby))\\n                    elif m[nx][ny] != \"#\" and (nx, ny, bx, by) not in memo:\\n                        memo.add((nx, ny, bx, by))\\n                        heapq.heappush(q, (t, nx, ny, bx, by))\\n        return -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, m: List[List[str]]) -> int:\\n        de = ((1,0),(0,1),(-1,0),(0,-1))\\n        rl,cl = len(m),len(m[0])\\n        memo, q = set(), []\\n        for i in range(rl):\\n            for j in range(cl):\\n                if m[i][j] == \"T\":\\n                    tx,ty = i,j\\n                elif m[i][j] == \"S\":\\n                    a,b = i,j\\n                elif m[i][j] == \"B\":\\n                    c,d = i,j\\n        memo.add((a, b, c, d))\\n        q += (0,a,b,c,d),\\n        while q:\\n            t, x, y, bx, by = heapq.heappop(q)\\n            for d in de:\\n                nx, ny = x + d[0], y + d[1]\\n                if 0 <= nx < rl and 0 <= ny < cl:\\n                    nbx, nby = bx + d[0], by + d[1]\\n                    if nx == bx and ny == by and 0 <= nbx < rl and 0 <= nby < cl and m[nbx][nby] != \"#\" and (nx, ny, nbx, nby) not in memo:\\n                        if nbx == tx and nby == ty:\\n                            return t + 1\\n                        memo.add((nx, ny, nbx, nby))\\n                        heapq.heappush(q, (t + 1, nx, ny, nbx, nby))\\n                    elif m[nx][ny] != \"#\" and (nx, ny, bx, by) not in memo:\\n                        memo.add((nx, ny, bx, by))\\n                        heapq.heappush(q, (t, nx, ny, bx, by))\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 444411,
                "title": "golang-bfs-solution",
                "content": "Inspired by : https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431431/Java-straightforward-BFS-solution\\n\\n```golang\\nfunc minPushBox(grid [][]byte) int {\\n\\tmv := [5]int{0, 1, 0, -1, 0}\\n\\tres := math.MaxInt32\\n\\tm := len(grid)\\n\\tn := len(grid[0])\\n\\tqueue := make([]int, 0, m*n)\\n\\tmem := make(map[int]int)\\n\\ttarget, st, box := [2]int{}, [2]int{}, [2]int{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase \\'B\\':\\n\\t\\t\\t\\tbox = [2]int{i, j}\\n\\t\\t\\tcase \\'T\\':\\n\\t\\t\\t\\ttarget = [2]int{i, j}\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tst = [2]int{i, j}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tstart := encode(box[0], box[1], st[0], st[1])\\n\\tqueue = append(queue, start)\\n\\tmem[start] = 0\\n\\tfor len(queue) > 0 {\\n\\t\\tcur := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\t\\tif mem[cur] > res {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tpos := decode(cur)\\n\\t\\tif pos[0] == target[0] && pos[1] == target[1] {\\n\\t\\t\\tif mem[cur] < res {\\n\\t\\t\\t\\tres = mem[cur]\\n\\t\\t\\t}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := [2]int{pos[0], pos[1]}\\n\\t\\ts := [2]int{pos[2], pos[3]}\\n\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\tsx := s[0] + mv[i]\\n\\t\\t\\tsy := s[1] + mv[i+1]\\n\\t\\t\\tif sx >= 0 && sx < m && sy >= 0 && sy < n && grid[sx][sy] != \\'#\\' {\\n\\t\\t\\t\\tif sx == b[0] && sy == b[1] {\\n\\t\\t\\t\\t\\t//if the store keeper can move to the box position, check if the box can move one step further\\n\\t\\t\\t\\t\\tnbx := b[0] + mv[i]\\n\\t\\t\\t\\t\\tnby := b[1] + mv[i+1]\\n\\t\\t\\t\\t\\tif nbx >= 0 && nby >= 0 && nbx < m && nby < n && grid[nbx][nby] != \\'#\\' {\\n\\t\\t\\t\\t\\t\\tnewpos := encode(nbx, nby, sx, sy)\\n\\t\\t\\t\\t\\t\\tif val, ok := mem[newpos]; ok && val <= mem[cur]+1 {\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue = append(queue, newpos)\\n\\t\\t\\t\\t\\t\\tmem[newpos] = mem[cur] + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//the store keeper move to other position, the number of steps shall not change\\n\\t\\t\\t\\t\\tnewpos := encode(b[0], b[1], sx, sy)\\n\\t\\t\\t\\t\\tif val, ok := mem[newpos]; ok && val <= mem[cur] {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmem[newpos] = mem[cur]\\n\\t\\t\\t\\t\\tqueue = append(queue, newpos)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif res == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t} else {\\n\\t\\treturn res\\n\\t}\\n}\\n\\nfunc encode(bx int, by int, sx int, sy int) int {\\n\\tres := bx<<24 | by<<16 | sx<<8 | sy\\n\\treturn res\\n}\\n\\nfunc decode(state int) [4]int {\\n\\tres := [4]int{}\\n\\tres[0] = (state >> 24) & 0xff\\n\\tres[1] = (state >> 16) & 0xff\\n\\tres[2] = (state >> 8) & 0xff\\n\\tres[3] = (state) & 0xff\\n\\treturn res\\n}\\n```\\n\\nMy other solutions in Golang: https://github.com/yinfirefire/LeetCode-GoSol",
                "solutionTags": [],
                "code": "```golang\\nfunc minPushBox(grid [][]byte) int {\\n\\tmv := [5]int{0, 1, 0, -1, 0}\\n\\tres := math.MaxInt32\\n\\tm := len(grid)\\n\\tn := len(grid[0])\\n\\tqueue := make([]int, 0, m*n)\\n\\tmem := make(map[int]int)\\n\\ttarget, st, box := [2]int{}, [2]int{}, [2]int{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase \\'B\\':\\n\\t\\t\\t\\tbox = [2]int{i, j}\\n\\t\\t\\tcase \\'T\\':\\n\\t\\t\\t\\ttarget = [2]int{i, j}\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tst = [2]int{i, j}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tstart := encode(box[0], box[1], st[0], st[1])\\n\\tqueue = append(queue, start)\\n\\tmem[start] = 0\\n\\tfor len(queue) > 0 {\\n\\t\\tcur := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\t\\tif mem[cur] > res {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tpos := decode(cur)\\n\\t\\tif pos[0] == target[0] && pos[1] == target[1] {\\n\\t\\t\\tif mem[cur] < res {\\n\\t\\t\\t\\tres = mem[cur]\\n\\t\\t\\t}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := [2]int{pos[0], pos[1]}\\n\\t\\ts := [2]int{pos[2], pos[3]}\\n\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\tsx := s[0] + mv[i]\\n\\t\\t\\tsy := s[1] + mv[i+1]\\n\\t\\t\\tif sx >= 0 && sx < m && sy >= 0 && sy < n && grid[sx][sy] != \\'#\\' {\\n\\t\\t\\t\\tif sx == b[0] && sy == b[1] {\\n\\t\\t\\t\\t\\t//if the store keeper can move to the box position, check if the box can move one step further\\n\\t\\t\\t\\t\\tnbx := b[0] + mv[i]\\n\\t\\t\\t\\t\\tnby := b[1] + mv[i+1]\\n\\t\\t\\t\\t\\tif nbx >= 0 && nby >= 0 && nbx < m && nby < n && grid[nbx][nby] != \\'#\\' {\\n\\t\\t\\t\\t\\t\\tnewpos := encode(nbx, nby, sx, sy)\\n\\t\\t\\t\\t\\t\\tif val, ok := mem[newpos]; ok && val <= mem[cur]+1 {\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue = append(queue, newpos)\\n\\t\\t\\t\\t\\t\\tmem[newpos] = mem[cur] + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//the store keeper move to other position, the number of steps shall not change\\n\\t\\t\\t\\t\\tnewpos := encode(b[0], b[1], sx, sy)\\n\\t\\t\\t\\t\\tif val, ok := mem[newpos]; ok && val <= mem[cur] {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmem[newpos] = mem[cur]\\n\\t\\t\\t\\t\\tqueue = append(queue, newpos)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif res == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t} else {\\n\\t\\treturn res\\n\\t}\\n}\\n\\nfunc encode(bx int, by int, sx int, sy int) int {\\n\\tres := bx<<24 | by<<16 | sx<<8 | sy\\n\\treturn res\\n}\\n\\nfunc decode(state int) [4]int {\\n\\tres := [4]int{}\\n\\tres[0] = (state >> 24) & 0xff\\n\\tres[1] = (state >> 16) & 0xff\\n\\tres[2] = (state >> 8) & 0xff\\n\\tres[3] = (state) & 0xff\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442622,
                "title": "python3-32ms-100-tarjan-a",
                "content": "```python []\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                g[grid[i][j]] += [complex(i, j)]\\n        def f(b, s): \\n            nonlocal time\\n            time += 1\\n\\t\\t\\tboxToTarget = b - target\\n            return (abs((boxToTarget).real) + abs((boxToTarget).imag) + s, abs(boxToTarget), time)\\n        player, box, target, time = *g[\\'S\\'], *g[\\'B\\'], *g[\\'T\\'], 1\\n        floor = {player, target, box, *g[\\'.\\']}\\n        alphaStarQueue = [(f(box, 1), 1, player, box)]\\n        directions, visited = (1, 1j, -1, -1j), set()\\n        low = dict.fromkeys(floor, 0)\\n        dfn = low.copy()\\n        count = 0\\n        index = {}\\n        def tarjan(currIndex, parentIndex):\\n            nonlocal count\\n            count += 1\\n            dfn[currIndex] = low[currIndex] = count\\n            index[count] = currIndex\\n            for direction in directions:\\n                nextIndex = currIndex + direction\\n                if nextIndex in floor and nextIndex != parentIndex:\\n                    if not low[nextIndex]:\\n                        tarjan(nextIndex, currIndex)\\n                    low[currIndex] = min(low[currIndex], low[nextIndex])\\n        tarjan(box, -1)\\n        for currIndex in floor:\\n            connect = [currIndex]\\n            while dfn[connect[-1]] != low[connect[-1]]:\\n                connect.append(index[low[connect[-1]]])\\n            for w in connect[: -2]:\\n                low[w] = low[connect[-1]]\\n        while alphaStarQueue:\\n            _, steps, currPlayer, currBox = heapq.heappop(alphaStarQueue)\\n            for direction in directions:\\n                nextPlayer, nextBox = currBox - direction, currBox + direction\\n                if nextBox in floor \\\\\\n                    and nextPlayer in floor \\\\\\n                        and (nextPlayer, currBox) not in visited \\\\\\n                            and low[currPlayer] == low[nextPlayer]:\\n                    if nextBox == target:\\n                        return steps\\n                    heapq.heappush( alphaStarQueue, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\\n                    visited.add((nextPlayer, currBox))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python []\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                g[grid[i][j]] += [complex(i, j)]\\n        def f(b, s): \\n            nonlocal time\\n            time += 1\\n\\t\\t\\tboxToTarget = b - target\\n            return (abs((boxToTarget).real) + abs((boxToTarget).imag) + s, abs(boxToTarget), time)\\n        player, box, target, time = *g[\\'S\\'], *g[\\'B\\'], *g[\\'T\\'], 1\\n        floor = {player, target, box, *g[\\'.\\']}\\n        alphaStarQueue = [(f(box, 1), 1, player, box)]\\n        directions, visited = (1, 1j, -1, -1j), set()\\n        low = dict.fromkeys(floor, 0)\\n        dfn = low.copy()\\n        count = 0\\n        index = {}\\n        def tarjan(currIndex, parentIndex):\\n            nonlocal count\\n            count += 1\\n            dfn[currIndex] = low[currIndex] = count\\n            index[count] = currIndex\\n            for direction in directions:\\n                nextIndex = currIndex + direction\\n                if nextIndex in floor and nextIndex != parentIndex:\\n                    if not low[nextIndex]:\\n                        tarjan(nextIndex, currIndex)\\n                    low[currIndex] = min(low[currIndex], low[nextIndex])\\n        tarjan(box, -1)\\n        for currIndex in floor:\\n            connect = [currIndex]\\n            while dfn[connect[-1]] != low[connect[-1]]:\\n                connect.append(index[low[connect[-1]]])\\n            for w in connect[: -2]:\\n                low[w] = low[connect[-1]]\\n        while alphaStarQueue:\\n            _, steps, currPlayer, currBox = heapq.heappop(alphaStarQueue)\\n            for direction in directions:\\n                nextPlayer, nextBox = currBox - direction, currBox + direction\\n                if nextBox in floor \\\\\\n                    and nextPlayer in floor \\\\\\n                        and (nextPlayer, currBox) not in visited \\\\\\n                            and low[currPlayer] == low[nextPlayer]:\\n                    if nextBox == target:\\n                        return steps\\n                    heapq.heappush( alphaStarQueue, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\\n                    visited.add((nextPlayer, currBox))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436045,
                "title": "java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int m, n;\\n    char[][] grid;\\n    private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\n    public int minPushBox(char[][] grid) {\\n        Queue<int[]> q1 = new ArrayDeque<>();\\n        int[] man = null, box = null, destination = null;\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'T\\') {\\n                    grid[i][j] = \\'.\\';\\n                    destination = new int[]{i, j};\\n                } else if (grid[i][j] == \\'S\\') {\\n                    man = new int[]{i, j};\\n                    grid[i][j] = \\'.\\';\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = new int[]{i, j};\\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        Set<String> set = new HashSet<>();\\n        if (goUp(man, box)) {\\n            set.add(box[0] - 1 + \" \" + box[1] + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0] - 1, box[1], box[0], box[1]});\\n        }\\n        if (goDown(man, box)) {\\n            set.add(box[0] + 1 + \" \" + box[1] + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0] + 1, box[1], box[0], box[1]});\\n        }\\n        if (goLeft(man, box)) {\\n            set.add(box[0] + \" \" + (box[1] - 1) + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0], box[1] - 1, box[0], box[1]});\\n        }\\n        if (goRight(man, box)) {\\n            set.add(box[0] + \" \" + (box[1] + 1) + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0], box[1] + 1, box[0], box[1]});\\n        }\\n        if (q1.isEmpty()) return -1;\\n        int step = 0;\\n        while (!q1.isEmpty()) {\\n            int size = q1.size();\\n            for (int z = 0; z < size; z++) {\\n                int[] node = q1.poll();\\n                box = new int[]{node[2], node[3]};\\n                man = new int[]{node[0], node[1]};\\n                if (node[2] == destination[0] && node[3] == destination[1]) {\\n                    return step;\\n                }\\n                if (goRight(man, box)) {\\n                    goFromRight(box, set, q1);\\n                }\\n                if (goUp(man, box)) {\\n                    goFromUp(box, set, q1);\\n                }\\n                if (goDown(man, box)) {\\n                    goFromDown(box, set, q1);\\n                }\\n                if (goLeft(man, box)) {\\n                    goFromLeft(box, set, q1);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private void goFromRight(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + box[0] + \" \" + (box[1] - 1);\\n        if (box[1] - 1 >= 0 && !set.contains(next) && grid[box[0]][box[1] - 1] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0], box[1] - 1});\\n        }\\n    }\\n\\n    private void goFromLeft(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + box[0] + \" \" + box[1] + 1;\\n        if (box[1] + 1 < n && !set.contains(next) && grid[box[0]][box[1] + 1] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0], box[1] + 1});\\n        }\\n    }\\n\\n    private void goFromDown(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + (box[0] - 1) + \" \" + box[1];\\n        if (box[0] - 1 >= 0 && !set.contains(next) && grid[box[0] - 1][box[1]] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0] - 1, box[1]});\\n        }\\n    }\\n\\n    private void goFromUp(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + (box[0] + 1) + \" \" + box[1];\\n        if (box[0] + 1 < m && !set.contains(next) && grid[box[0] + 1][box[1]] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0] + 1, box[1]});\\n        }\\n    }\\n\\n    private boolean goUp(int[] man, int[] box) {\\n        return bfs(man, box[0] - 1, box[1], box);\\n    }\\n\\n    private boolean goDown(int[] man, int[] box) {\\n        return bfs(man, box[0] + 1, box[1], box);\\n    }\\n\\n    private boolean goLeft(int[] man, int[] box) {\\n        return bfs(man, box[0], box[1] - 1, box);\\n    }\\n\\n    private boolean goRight(int[] man, int[] box) {\\n        return bfs(man, box[0], box[1] + 1, box);\\n    }\\n\\n    private boolean bfs(int[] man, int iEnd, int jEnd, int[] box) {\\n        if (iEnd < 0 || iEnd >= m || jEnd < 0 || jEnd >= n) {\\n            return false;\\n        }\\n        Queue<int[]> q = new ArrayDeque<>();\\n        q.add(man);\\n        boolean[][] visited = new boolean[m][n];\\n        visited[man[0]][man[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] node = q.poll();\\n            if (node[0] == iEnd && node[1] == jEnd) {\\n                return true;\\n            }\\n            for (int[] dir : DIRECTIONS) {\\n                int x = dir[0] + node[0];\\n                int y = dir[1] + node[1];\\n                if (Arrays.equals(new int[]{x, y}, box)) continue;\\n                if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == \\'.\\' && !visited[x][y]) {\\n                    q.add(new int[]{x, y});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int m, n;\\n    char[][] grid;\\n    private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\n    public int minPushBox(char[][] grid) {\\n        Queue<int[]> q1 = new ArrayDeque<>();\\n        int[] man = null, box = null, destination = null;\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'T\\') {\\n                    grid[i][j] = \\'.\\';\\n                    destination = new int[]{i, j};\\n                } else if (grid[i][j] == \\'S\\') {\\n                    man = new int[]{i, j};\\n                    grid[i][j] = \\'.\\';\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = new int[]{i, j};\\n                    grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        Set<String> set = new HashSet<>();\\n        if (goUp(man, box)) {\\n            set.add(box[0] - 1 + \" \" + box[1] + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0] - 1, box[1], box[0], box[1]});\\n        }\\n        if (goDown(man, box)) {\\n            set.add(box[0] + 1 + \" \" + box[1] + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0] + 1, box[1], box[0], box[1]});\\n        }\\n        if (goLeft(man, box)) {\\n            set.add(box[0] + \" \" + (box[1] - 1) + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0], box[1] - 1, box[0], box[1]});\\n        }\\n        if (goRight(man, box)) {\\n            set.add(box[0] + \" \" + (box[1] + 1) + \" \" + box[0] + \" \" + box[1]);\\n            q1.add(new int[]{box[0], box[1] + 1, box[0], box[1]});\\n        }\\n        if (q1.isEmpty()) return -1;\\n        int step = 0;\\n        while (!q1.isEmpty()) {\\n            int size = q1.size();\\n            for (int z = 0; z < size; z++) {\\n                int[] node = q1.poll();\\n                box = new int[]{node[2], node[3]};\\n                man = new int[]{node[0], node[1]};\\n                if (node[2] == destination[0] && node[3] == destination[1]) {\\n                    return step;\\n                }\\n                if (goRight(man, box)) {\\n                    goFromRight(box, set, q1);\\n                }\\n                if (goUp(man, box)) {\\n                    goFromUp(box, set, q1);\\n                }\\n                if (goDown(man, box)) {\\n                    goFromDown(box, set, q1);\\n                }\\n                if (goLeft(man, box)) {\\n                    goFromLeft(box, set, q1);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private void goFromRight(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + box[0] + \" \" + (box[1] - 1);\\n        if (box[1] - 1 >= 0 && !set.contains(next) && grid[box[0]][box[1] - 1] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0], box[1] - 1});\\n        }\\n    }\\n\\n    private void goFromLeft(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + box[0] + \" \" + box[1] + 1;\\n        if (box[1] + 1 < n && !set.contains(next) && grid[box[0]][box[1] + 1] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0], box[1] + 1});\\n        }\\n    }\\n\\n    private void goFromDown(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + (box[0] - 1) + \" \" + box[1];\\n        if (box[0] - 1 >= 0 && !set.contains(next) && grid[box[0] - 1][box[1]] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0] - 1, box[1]});\\n        }\\n    }\\n\\n    private void goFromUp(int[] box, Set<String> set, Queue<int[]> q1) {\\n        String next = box[0] + \" \" + box[1] + \" \" + (box[0] + 1) + \" \" + box[1];\\n        if (box[0] + 1 < m && !set.contains(next) && grid[box[0] + 1][box[1]] == \\'.\\') {\\n            set.add(next);\\n            q1.add(new int[]{box[0], box[1], box[0] + 1, box[1]});\\n        }\\n    }\\n\\n    private boolean goUp(int[] man, int[] box) {\\n        return bfs(man, box[0] - 1, box[1], box);\\n    }\\n\\n    private boolean goDown(int[] man, int[] box) {\\n        return bfs(man, box[0] + 1, box[1], box);\\n    }\\n\\n    private boolean goLeft(int[] man, int[] box) {\\n        return bfs(man, box[0], box[1] - 1, box);\\n    }\\n\\n    private boolean goRight(int[] man, int[] box) {\\n        return bfs(man, box[0], box[1] + 1, box);\\n    }\\n\\n    private boolean bfs(int[] man, int iEnd, int jEnd, int[] box) {\\n        if (iEnd < 0 || iEnd >= m || jEnd < 0 || jEnd >= n) {\\n            return false;\\n        }\\n        Queue<int[]> q = new ArrayDeque<>();\\n        q.add(man);\\n        boolean[][] visited = new boolean[m][n];\\n        visited[man[0]][man[1]] = true;\\n        while (!q.isEmpty()) {\\n            int[] node = q.poll();\\n            if (node[0] == iEnd && node[1] == jEnd) {\\n                return true;\\n            }\\n            for (int[] dir : DIRECTIONS) {\\n                int x = dir[0] + node[0];\\n                int y = dir[1] + node[1];\\n                if (Arrays.equals(new int[]{x, y}, box)) continue;\\n                if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == \\'.\\' && !visited[x][y]) {\\n                    q.add(new int[]{x, y});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434574,
                "title": "bfs-dfs-simple-c-solution-easy-to-understand-with-explanation",
                "content": "Intuition:\\n\\n1. For a moment lets forget about the player and reduce our problem to `what is the minimum push that is required to place the box to it\\'s target?` , the obvious answer come to our mind is to use BFS to get this answer.\\n2. Now we can assume what if someone has to push the box to place it to target and we have given the player position in matrix. It is also given that player can move in all 4 directions, it means same movement is also allowed to box if we are pushing it along the way.\\n3. Then we can ask ourselves.. ohh how do we do that? How can we reach box, then only we can push. We can simply use dfs to get the answer. Like if box is reachable then we might push it along the way if push is valid.\\n4. Now for a moment just ignore constraint and ask ourselves what if player is doing same push again? Like if we are doing same push again then it is of no use to us. So we can store this information in a set using pair. [You can think it is as a loop in a graph]\\n\\nConsider below example, assume we pushed B to its right when player stands left to B. But `current` player\\'s position `S\\'` can be reached via different path in this matrix. So this push we save in a set and for next same push we can ignore as result will be same.\\n\\n\\t\\t\\t   [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\\n               [\"#\",\".\",\"S\\'\",\"B\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n\\n5. So final Idea is to first do dfs to reach box with given constraint and then add all possible push to queue [basically all its neighbor push]. \\n6. To handle case where we cannot pass through the box, before we start visiting all the neighbors of current Box position , we set the value in grid to `#` and then revert it back to `.` \\n\\n```cpp\\nclass Solution {\\npublic:\\n    //direction vector\\n    vector<vector<int>> dir {{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        //rows, cols\\n        int N = grid.size();\\n        int M = grid[0].size();\\n        \\n        //intitial position\\n        int target=-1, box =-1, player = -1;\\n        \\n        //calcluate distance of target, box, player in grid\\n        for(int i=0; i<N;i++){\\n            for(int j=0;j <M;j++){\\n                if(grid[i][j]==\\'S\\'){\\n                    player = i * M + j;\\n                }\\n                if(grid[i][j]==\\'B\\'){\\n                    box = i*M + j;\\n                }       \\n                if(grid[i][j]==\\'T\\'){\\n                    target = i*M + j;\\n                }\\n            }\\n        }\\n        //set stl to track player-box movement\\n        //if already visited same path, ignore it\\n        set<pair<int, int>> visited;\\n        visited.insert({player, box});\\n        \\n        //declare queue for BFS\\n        //move box to all it\\'s eligible neighbor\\n        queue<pair<int,int>> q;\\n        q.push({player, box});\\n        \\n        int ans =0;\\n        while(!q.empty()){\\n            \\n            ans++;\\n            \\n            //size of neighbor to be visited\\n            int size = q.size();\\n            \\n            while(size--){\\n                \\n                auto f = q.front();\\n                q.pop();\\n                \\n                //current box position \\n                int box_curr = f.second;\\n                //get box position in matrix\\n                int box_x = box_curr/ M;\\n                int box_y = box_curr % M;\\n                //palyer position\\n                int p = f.first;\\n                \\n                //make grid with box as obstacle \\n                grid[box_x][box_y] = \\'#\\';\\n                \\n                for(auto &d : dir){\\n                    \\n                    int new_box_x = box_x + d[0];\\n                    int new_box_y = box_y + d[1];\\n                    \\n                    int px = box_x - d[0];\\n                    int py = box_y - d[1];\\n                    \\n                    //to be used in dfs walk by player to reach box\\n                    vector<vector<int>> walk(N, vector<int>(M, 0));\\n                    \\n                    if(isValid(grid, new_box_x, new_box_y) && canWalk(grid, p/M, p %M, px, py, walk) && visited.count({px * M + py, new_box_x*M + new_box_y})==0){\\n                        \\n                        if(new_box_x == target/M && new_box_y==target%M)\\n                            return ans;\\n                        \\n                        visited.insert({px * M + py, new_box_x * M + new_box_y});\\n                        q.push({px * M + py, new_box_x * M + new_box_y});\\n                    }\\n                }        \\n                grid[box_x][box_y] = \\'.\\';\\n            }\\n            \\n        }\\n            \\n        return -1;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& grid, int i, int j){\\n        if(i < 0 || i>=grid.size() || j <0 || j>=grid[0].size() || grid[i][j]==\\'#\\')\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool canWalk(vector<vector<char>>& grid, int x, int y, int i, int j, vector<vector<int>>& walk){\\n        if(x==i && y==j)\\n            return true;\\n        \\n        for(auto &d: dir){\\n            int nx = x + d[0], ny = y+d[1];   \\n            if(isValid(grid, nx, ny) && walk[nx][ny] == 0){\\n                walk[nx][ny] = 1;\\n                if(canWalk(grid, nx, ny, i, j, walk))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nCredit : https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431144/cpp-BFS-%2B-DFS-solution",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    //direction vector\\n    vector<vector<int>> dir {{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        //rows, cols\\n        int N = grid.size();\\n        int M = grid[0].size();\\n        \\n        //intitial position\\n        int target=-1, box =-1, player = -1;\\n        \\n        //calcluate distance of target, box, player in grid\\n        for(int i=0; i<N;i++){\\n            for(int j=0;j <M;j++){\\n                if(grid[i][j]==\\'S\\'){\\n                    player = i * M + j;\\n                }\\n                if(grid[i][j]==\\'B\\'){\\n                    box = i*M + j;\\n                }       \\n                if(grid[i][j]==\\'T\\'){\\n                    target = i*M + j;\\n                }\\n            }\\n        }\\n        //set stl to track player-box movement\\n        //if already visited same path, ignore it\\n        set<pair<int, int>> visited;\\n        visited.insert({player, box});\\n        \\n        //declare queue for BFS\\n        //move box to all it\\'s eligible neighbor\\n        queue<pair<int,int>> q;\\n        q.push({player, box});\\n        \\n        int ans =0;\\n        while(!q.empty()){\\n            \\n            ans++;\\n            \\n            //size of neighbor to be visited\\n            int size = q.size();\\n            \\n            while(size--){\\n                \\n                auto f = q.front();\\n                q.pop();\\n                \\n                //current box position \\n                int box_curr = f.second;\\n                //get box position in matrix\\n                int box_x = box_curr/ M;\\n                int box_y = box_curr % M;\\n                //palyer position\\n                int p = f.first;\\n                \\n                //make grid with box as obstacle \\n                grid[box_x][box_y] = \\'#\\';\\n                \\n                for(auto &d : dir){\\n                    \\n                    int new_box_x = box_x + d[0];\\n                    int new_box_y = box_y + d[1];\\n                    \\n                    int px = box_x - d[0];\\n                    int py = box_y - d[1];\\n                    \\n                    //to be used in dfs walk by player to reach box\\n                    vector<vector<int>> walk(N, vector<int>(M, 0));\\n                    \\n                    if(isValid(grid, new_box_x, new_box_y) && canWalk(grid, p/M, p %M, px, py, walk) && visited.count({px * M + py, new_box_x*M + new_box_y})==0){\\n                        \\n                        if(new_box_x == target/M && new_box_y==target%M)\\n                            return ans;\\n                        \\n                        visited.insert({px * M + py, new_box_x * M + new_box_y});\\n                        q.push({px * M + py, new_box_x * M + new_box_y});\\n                    }\\n                }        \\n                grid[box_x][box_y] = \\'.\\';\\n            }\\n            \\n        }\\n            \\n        return -1;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& grid, int i, int j){\\n        if(i < 0 || i>=grid.size() || j <0 || j>=grid[0].size() || grid[i][j]==\\'#\\')\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool canWalk(vector<vector<char>>& grid, int x, int y, int i, int j, vector<vector<int>>& walk){\\n        if(x==i && y==j)\\n            return true;\\n        \\n        for(auto &d: dir){\\n            int nx = x + d[0], ny = y+d[1];   \\n            if(isValid(grid, nx, ny) && walk[nx][ny] == 0){\\n                walk[nx][ny] = 1;\\n                if(canWalk(grid, nx, ny, i, j, walk))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433504,
                "title": "python3-nested-bfs-95-82",
                "content": "Outer BFS - move box to next place \\nInner BFS - check if player can be placed to move box to next place \\n\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #constants\\n        m, n = len(grid), len(grid[0]) #dimensions\\n        neighbors = ((-1,0), (1,0), (0,-1), (0,1)) \\n        \\n        #initial values\\n        for i, j in product(range(m), range(n)):\\n            if   grid[i][j] == \"B\": box    = i, j\\n            elif grid[i][j] == \"S\": player = i, j\\n            elif grid[i][j] == \"T\": target = i, j\\n        \\n        #helper functions\\n        not_wall = lambda i, j: 0 <= i < m and 0 <= j < n and grid[i][j] !=\"#\" #true if not wall\\n            \\n        def connected(s, d):\\n            \"\"\"bfs to check if s and d are connected\"\"\"\\n            queue = [s]\\n            seen = set(queue)\\n            for i, j in queue: #okay to change size\\n                for di, dj in neighbors:\\n                    ii, jj = i + di, j + dj\\n                    if not_wall(ii, jj) and (ii, jj) != box and (ii, jj) not in seen: \\n                        queue.append((ii, jj))\\n                        seen.add((ii, jj))\\n                if d in seen: return True\\n            return False \\n        \\n        #logic -- nested bfs \\n        final = set((target, (target[0]+di, target[1]+dj)) for di, dj in neighbors)\\n        \\n        moves = 0 \\n        queue = [(box, player)] #initial position\\n        seen = set(queue)\\n        while queue: #bfs by level \\n            temp = []\\n            for box, player in queue:\\n                i, j = box\\n                for di, dj in neighbors:\\n                    if not_wall(i+di, j+dj) and ((i+di, j+dj), (i, j)) not in seen and not_wall(i-di, j-dj) and connected(player, (i-di, j-dj)):\\n                        temp.append(((i+di, j+dj), (i, j)))\\n                        seen.add(((i+di, j+dj), (i, j)))\\n            queue = temp\\n            moves += 1\\n            if seen & final: return moves #final configuration => arrive at target\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #constants\\n        m, n = len(grid), len(grid[0]) #dimensions\\n        neighbors = ((-1,0), (1,0), (0,-1), (0,1)) \\n        \\n        #initial values\\n        for i, j in product(range(m), range(n)):\\n            if   grid[i][j] == \"B\": box    = i, j\\n            elif grid[i][j] == \"S\": player = i, j\\n            elif grid[i][j] == \"T\": target = i, j\\n        \\n        #helper functions\\n        not_wall = lambda i, j: 0 <= i < m and 0 <= j < n and grid[i][j] !=\"#\" #true if not wall\\n            \\n        def connected(s, d):\\n            \"\"\"bfs to check if s and d are connected\"\"\"\\n            queue = [s]\\n            seen = set(queue)\\n            for i, j in queue: #okay to change size\\n                for di, dj in neighbors:\\n                    ii, jj = i + di, j + dj\\n                    if not_wall(ii, jj) and (ii, jj) != box and (ii, jj) not in seen: \\n                        queue.append((ii, jj))\\n                        seen.add((ii, jj))\\n                if d in seen: return True\\n            return False \\n        \\n        #logic -- nested bfs \\n        final = set((target, (target[0]+di, target[1]+dj)) for di, dj in neighbors)\\n        \\n        moves = 0 \\n        queue = [(box, player)] #initial position\\n        seen = set(queue)\\n        while queue: #bfs by level \\n            temp = []\\n            for box, player in queue:\\n                i, j = box\\n                for di, dj in neighbors:\\n                    if not_wall(i+di, j+dj) and ((i+di, j+dj), (i, j)) not in seen and not_wall(i-di, j-dj) and connected(player, (i-di, j-dj)):\\n                        temp.append(((i+di, j+dj), (i, j)))\\n                        seen.add(((i+di, j+dj), (i, j)))\\n            queue = temp\\n            moves += 1\\n            if seen & final: return moves #final configuration => arrive at target\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 432765,
                "title": "the-reason-of-adding-person-location-in-seen-or-visited-set",
                "content": "If BFS is used, if we do not add the location of the person to the seen set, we will get an error for the following test case. It is supposed to get 8, however, without the person add in the seen set, we will get -1.\\nThe @ location is critical. When the box is pushed to the location of \"@\", it has to be moved to the left of @  then the person can go to the left region throught the only entry which is the right of the @. If only box location not the person location is added in the seen. As the first time when the box is moved to @ location, it will be added to seen, and since it is in the seen, box can not be pushed back to the @ location again. This explains why it will get -1. If we add person location also, we will get rid of the problem.\\n```python\\n#[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\".\",\"@\",\".\",\".\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"], \\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n```\\nHope it is helpful.",
                "solutionTags": [],
                "code": "```python\\n#[\"#\",\".\",\".\",\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\".\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\".\",\"@\",\".\",\".\",\".\",\"#\"],\\n#[\"#\",\".\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"], \\n#[\"#\",\".\",\".\",\"#\",\".\",\"#\",\"#\",\"#\",\"#\"]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432752,
                "title": "summary-of-bfs-bfs-bfs-dfs-bfs-unionfind-and-other-possible-ways",
                "content": "The solution to this problem can be: BFS + BFS or BFS + DFS or BFS + Union Find\\nIn the code\\nbi, bj, pi, pj mean the box location and person location. ti, tj mean the target location of the person in order to push the box.\\nSolution 1(BFS + BFS, runtime 160ms)\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def bfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            cur_level = {(i,j)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i,j in cur_level:\\n                    if (i,j)==(ti,tj):return True\\n                    seen.add((i, j))\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                            nxt_level.add((r,c))\\n                cur_level = nxt_level\\n            return False \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if bfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nSolution 2(BFS + DFS runtime 632 ms)\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return False\\n                        \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if dfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nSolution 3(BFS + Union Find runtime1608 ms)\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        self.uf = {}\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n        def find(x):\\n            self.uf.setdefault(x, x)\\n            if self.uf[x] != x:\\n                self.uf[x] = find(self.uf[x])\\n            return self.uf[x]\\n            \\n        def union(x, y):\\n            self.uf[find(y)] = find(x)\\n                 \\n        def union_find(i, j, bi, bj):\\n            open_list = [(i,j)]\\n            seen = set()\\n            while open_list:\\n                i,j = open_list.pop()\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        union((i, j), (r, c))\\n                        open_list.append((r, c))                   \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    children = [(i+di, j+dj, i-di, j-dj) \\n                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]\\n                                if 0<=i+di<R and 0<=j+dj<C and grid[i+di][j+dj]!=\\'#\\' and (i+di, j+dj, i, j) not in b_seen]\\n                    if children:\\n                        self.uf = {}\\n                        union_find(pi, pj , i, j)\\n                        for r, c, ti, tj in children:\\n                            if find((ti, tj)) == find((pi, pj)):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nSolution 4(BFS + DFS TLE) The reason that this solution is TLE might be the open_list size is too large if we keep all levels elements in the whole list. Solution 2 compares with this solution, only the open_list part is changed to only maintain the current level and next level. The speed of solution 2 is much faster and can get accepted.\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return False                     \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            open_list = [(i,j, pi, pj, 0)]\\n            for i, j, pi, pj, d in open_list:\\n                b_seen.add((i,j, pi, pj))\\n                if grid[i][j] == \\'T\\':return d\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                        ti, tj = i-di, j-dj\\n                        if dfs_person(pi, pj, ti, tj, i, j):\\n                            open_list.append((r,c,i, j, d+1))    \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nSolution 5 (BFS + DFS return a seen set 788 ms) It seems in this case union find is slower than DFS.\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, bi, bj):\\n            seen = set()\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return seen                     \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    children = [(i+di, j+dj, i-di, j-dj) \\n                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]\\n                                if 0<=i+di<R and 0<=j+dj<C and grid[i+di][j+dj]!=\\'#\\' and (i+di, j+dj, i, j) not in b_seen]\\n                    if children:\\n                        seen = dfs_person(pi, pj , i, j)\\n                        for r, c, ti, tj in children:\\n                            if (pi, pj) in seen and (ti, tj ) in seen:\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nSolution 6 (BFS + DFS change data type of open_list for DFS from list to set runtime 192 ms) No idea why it can have such a significant speedup. The appending, traversing and pop speed between list and set should not be that much. Still unclear about this part.\\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = {(i,j)}\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.add((r,c))\\n            return False\\n                        \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if dfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\\nFrom this post, hope it can be helpful for a better understanding about the difference and connections between BFS, DFS, and union-find.\\n\\nReference\\nhttps://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def bfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            cur_level = {(i,j)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i,j in cur_level:\\n                    if (i,j)==(ti,tj):return True\\n                    seen.add((i, j))\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                            nxt_level.add((r,c))\\n                cur_level = nxt_level\\n            return False \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if bfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return False\\n                        \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if dfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        self.uf = {}\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n        def find(x):\\n            self.uf.setdefault(x, x)\\n            if self.uf[x] != x:\\n                self.uf[x] = find(self.uf[x])\\n            return self.uf[x]\\n            \\n        def union(x, y):\\n            self.uf[find(y)] = find(x)\\n                 \\n        def union_find(i, j, bi, bj):\\n            open_list = [(i,j)]\\n            seen = set()\\n            while open_list:\\n                i,j = open_list.pop()\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        union((i, j), (r, c))\\n                        open_list.append((r, c))                   \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    children = [(i+di, j+dj, i-di, j-dj) \\n                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]\\n                                if 0<=i+di<R and 0<=j+dj<C and grid[i+di][j+dj]!=\\'#\\' and (i+di, j+dj, i, j) not in b_seen]\\n                    if children:\\n                        self.uf = {}\\n                        union_find(pi, pj , i, j)\\n                        for r, c, ti, tj in children:\\n                            if find((ti, tj)) == find((pi, pj)):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return False                     \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            open_list = [(i,j, pi, pj, 0)]\\n            for i, j, pi, pj, d in open_list:\\n                b_seen.add((i,j, pi, pj))\\n                if grid[i][j] == \\'T\\':return d\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                        ti, tj = i-di, j-dj\\n                        if dfs_person(pi, pj, ti, tj, i, j):\\n                            open_list.append((r,c,i, j, d+1))    \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, bi, bj):\\n            seen = set()\\n            open_list = [(i,j)]\\n            while open_list:\\n                i,j = open_list.pop()\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.append((r,c))\\n            return seen                     \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    children = [(i+di, j+dj, i-di, j-dj) \\n                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]\\n                                if 0<=i+di<R and 0<=j+dj<C and grid[i+di][j+dj]!=\\'#\\' and (i+di, j+dj, i, j) not in b_seen]\\n                    if children:\\n                        seen = dfs_person(pi, pj , i, j)\\n                        for r, c, ti, tj in children:\\n                            if (pi, pj) in seen and (ti, tj ) in seen:\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```\n```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == \\'S\\':\\n                    pi, pj = i, j\\n                elif grid[i][j] == \\'B\\':\\n                    bi, bj = i, j\\n                 \\n        def dfs_person(i, j, ti, tj, bi, bj):\\n            seen = set()\\n            if ti>=R or tj>=C or grid[ti][tj]==\\'#\\':return False\\n            open_list = {(i,j)}\\n            while open_list:\\n                i,j = open_list.pop()\\n                if (i,j)==(ti,tj):return True\\n                seen.add((i, j))\\n                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                    r, c = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!=\\'#\\':\\n                        open_list.add((r,c))\\n            return False\\n                        \\n                \\n        def bfs(i, j, pi, pj):\\n            b_seen = set()\\n            cur_level = {(i,j, pi, pj, 0)}\\n            while cur_level:\\n                nxt_level = set()\\n                for i, j, pi, pj, d in cur_level:\\n                    b_seen.add((i,j, pi, pj))\\n                    if grid[i][j] == \\'T\\':return d\\n                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:\\n                        r, c = i+di, j+dj\\n                        if 0<=r<R and 0<=c<C and grid[r][c]!=\\'#\\' and (r,c, i, j) not in b_seen:\\n                            ti, tj = i-di, j-dj\\n                            if dfs_person(pi, pj, ti, tj, i, j):\\n                                nxt_level.add((r,c,i, j, d+1))\\n                cur_level = nxt_level      \\n            return -1\\n        return bfs(bi, bj, pi, pj)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431663,
                "title": "python-for-newbie-bfs-borrowed-from-davyjing",
                "content": "I cleaned a bit the excellent code of @davyjing for new comers. \\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'B\\': box = (i, j)\\n                if grid[i][j] == \\'T\\': target = (i, j)\\n                if grid[i][j] == \\'S\\': player = (i, j)\\n                    \\n        if target == box: return 0\\n        \\n        def can_get(cur_b, cur_p, pos): # can player get to a certain position pos\\n            if cur_p == pos: return True\\n            seen = {cur_p}\\n            q = [cur_p]\\n            for x, y in q:\\n                for X, Y in ([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]):\\n                    if 0 <= X < m and 0 <= Y < n and (X, Y) not in seen and grid[X][Y] != \\'#\\' and (X, Y) != cur_b:\\n                        if (X, Y) == pos:\\n                            return True\\n                        seen.add((X, Y))\\n                        q.append((X, Y))\\n            return False\\n        \\n        q, seen, ans = {(box, player)}, {(box, player)}, 0\\n        dire = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        while q:\\n            tmp = []\\n            ans += 1\\n            for b, p in q:\\n                for d in dire:\\n                    nb = (b[0] + d[0], b[1] + d[1])\\n                    oppo = (b[0] - d[0], b[1] - d[1]) # player is required to be the opposite side of the box to push\\n                    if 0 <= nb[0] < m and 0 <= nb[1] < n and grid[nb[0]][nb[1]] != \\'#\\' and can_get(b, p, oppo) and (nb, b) not in seen:\\n                        tmp.append((nb, b))\\n            q = set(tmp)\\n            seen |= q\\n            for d in dire:\\n                if (target, (target[0]+d[0], target[1]+d[1])) in seen:\\n                    return ans\\n                    \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'B\\': box = (i, j)\\n                if grid[i][j] == \\'T\\': target = (i, j)\\n                if grid[i][j] == \\'S\\': player = (i, j)\\n                    \\n        if target == box: return 0\\n        \\n        def can_get(cur_b, cur_p, pos): # can player get to a certain position pos\\n            if cur_p == pos: return True\\n            seen = {cur_p}\\n            q = [cur_p]\\n            for x, y in q:\\n                for X, Y in ([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]):\\n                    if 0 <= X < m and 0 <= Y < n and (X, Y) not in seen and grid[X][Y] != \\'#\\' and (X, Y) != cur_b:\\n                        if (X, Y) == pos:\\n                            return True\\n                        seen.add((X, Y))\\n                        q.append((X, Y))\\n            return False\\n        \\n        q, seen, ans = {(box, player)}, {(box, player)}, 0\\n        dire = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        while q:\\n            tmp = []\\n            ans += 1\\n            for b, p in q:\\n                for d in dire:\\n                    nb = (b[0] + d[0], b[1] + d[1])\\n                    oppo = (b[0] - d[0], b[1] - d[1]) # player is required to be the opposite side of the box to push\\n                    if 0 <= nb[0] < m and 0 <= nb[1] < n and grid[nb[0]][nb[1]] != \\'#\\' and can_get(b, p, oppo) and (nb, b) not in seen:\\n                        tmp.append((nb, b))\\n            q = set(tmp)\\n            seen |= q\\n            for d in dire:\\n                if (target, (target[0]+d[0], target[1]+d[1])) in seen:\\n                    return ans\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431259,
                "title": "bfs-with-box-pos-direction-as-the-state",
                "content": "```\\n\\nclass Solution {\\n    int m=0,n=0;\\n    public int minPushBox(char[][] grid) {\\n        m=grid.length;\\n        n=grid[0].length;\\n        int sx=0,sy=0,bx=0,by=0,tx=0,ty=0;\\n        for(int i=0;i<m;i++) for(int j=0;j<n;j++){\\n            if(grid[i][j]==\\'S\\'){sx=i;sy=j;grid[i][j]=\\'.\\';}\\n            if(grid[i][j]==\\'T\\'){tx=i;ty=j;grid[i][j]=\\'.\\';}\\n            if(grid[i][j]==\\'B\\'){bx=i;by=j;grid[i][j]=\\'.\\';}\\n        }\\n        \\n        Queue<int[]> q=new LinkedList();\\n        boolean[][][] visited=new boolean[m][n][4];\\n        if(valid(grid,sx,sy,bx-1,by,bx,by)) {q.offer(new int[]{bx,by,0});visited[bx][by][0]=true;}\\n        if(valid(grid,sx,sy,bx+1,by,bx,by)) {q.offer(new int[]{bx,by,1});visited[bx][by][1]=true;}\\n        if(valid(grid,sx,sy,bx,by+1,bx,by)) {q.offer(new int[]{bx,by,2});visited[bx][by][2]=true;}\\n        if(valid(grid,sx,sy,bx,by-1,bx,by)) {q.offer(new int[]{bx,by,3});visited[bx][by][3]=true;}\\n        int depth=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int[] v=q.poll();\\n                int[] d=trans(v[2]);\\n                int x=v[0]-d[0],y=v[1]-d[1];//move one step x,y is new box position\\n                //System.out.println(v[0]+\"-\"+v[1]+\"##\"+x+\"-\"+y+\"\");\\n                if(x<0||x>m-1||y<0||y>n-1) continue;\\n                if(grid[x][y]!=\\'.\\') continue;\\n                if(x==tx&&y==ty) return depth+1;\\n                //grid[v[0]][v[1]]=\\'.\\';\\n                //grid[x][y]=\\'B\\';\\n                for(int[] dir:dirs){\\n                    if(valid(grid,v[0],v[1],x+dir[0],y+dir[1],x,y)) {\\n                        int dd=transv(dir);\\n                        if(visited[x][y][dd]) continue;\\n                        visited[x][y][dd]=true;\\n                        q.offer(new int[]{x,y,dd});\\n                    }\\n                }\\n                //grid[x][y]=\\'.\\';\\n                //grid[v[0]][v[1]]=\\'B\\';\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean valid(char[][] graph,int sx,int sy,int tx,int ty,int bx,int by){\\n        if(tx<0||tx>m-1||ty<0||ty>n-1) return false;\\n        if(graph[tx][ty]!=\\'.\\') return false;\\n        Queue<int[]> q=new LinkedList();\\n        boolean[][] visited=new boolean[m][n];\\n        q.offer(new int[]{sx,sy});visited[sx][sy]=true;\\n        \\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int[] v=q.poll();\\n                if(v[0]==tx&&v[1]==ty) return true;\\n                for(int[] dir:dirs){\\n                    int x=v[0]+dir[0],y=v[1]+dir[1];\\n                    if(x<0||x>m-1||y<0||y>n-1) continue;\\n                    if(graph[x][y]!=\\'.\\') continue;\\n                    if(x==bx&&y==by) continue;\\n                    if(visited[x][y]) continue;\\n                    visited[x][y]=true;\\n                    q.offer(new int[]{x,y});\\n                }\\n            }\\n        \\n        }\\n        return false;\\n    }\\n    \\n    \\n    private int[][] dirs={{-1,0},{1,0},{0,1},{0,-1}};\\n    private int[] trans(int dir){\\n        int[] res=new int[2];\\n        if(dir==0) res[0]=-1;\\n        else if(dir==1) res[0]=1;\\n        else if(dir==2) res[1]=1;\\n        else res[1]=-1;\\n        return res;\\n    }\\n    \\n    private int transv(int[] dir){\\n        if(dir[0]==-1) return 0;\\n        else if(dir[0]==1) return 1;\\n        else if(dir[1]==1) return 2;\\n        else if(dir[1]==-1) return 3;\\n        return -1;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int m=0,n=0;\\n    public int minPushBox(char[][] grid) {\\n        m=grid.length;\\n        n=grid[0].length;\\n        int sx=0,sy=0,bx=0,by=0,tx=0,ty=0;\\n        for(int i=0;i<m;i++) for(int j=0;j<n;j++){\\n            if(grid[i][j]==\\'S\\'){sx=i;sy=j;grid[i][j]=\\'.\\';}\\n            if(grid[i][j]==\\'T\\'){tx=i;ty=j;grid[i][j]=\\'.\\';}\\n            if(grid[i][j]==\\'B\\'){bx=i;by=j;grid[i][j]=\\'.\\';}\\n        }\\n        \\n        Queue<int[]> q=new LinkedList();\\n        boolean[][][] visited=new boolean[m][n][4];\\n        if(valid(grid,sx,sy,bx-1,by,bx,by)) {q.offer(new int[]{bx,by,0});visited[bx][by][0]=true;}\\n        if(valid(grid,sx,sy,bx+1,by,bx,by)) {q.offer(new int[]{bx,by,1});visited[bx][by][1]=true;}\\n        if(valid(grid,sx,sy,bx,by+1,bx,by)) {q.offer(new int[]{bx,by,2});visited[bx][by][2]=true;}\\n        if(valid(grid,sx,sy,bx,by-1,bx,by)) {q.offer(new int[]{bx,by,3});visited[bx][by][3]=true;}\\n        int depth=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int[] v=q.poll();\\n                int[] d=trans(v[2]);\\n                int x=v[0]-d[0],y=v[1]-d[1];//move one step x,y is new box position\\n                //System.out.println(v[0]+\"-\"+v[1]+\"##\"+x+\"-\"+y+\"\");\\n                if(x<0||x>m-1||y<0||y>n-1) continue;\\n                if(grid[x][y]!=\\'.\\') continue;\\n                if(x==tx&&y==ty) return depth+1;\\n                //grid[v[0]][v[1]]=\\'.\\';\\n                //grid[x][y]=\\'B\\';\\n                for(int[] dir:dirs){\\n                    if(valid(grid,v[0],v[1],x+dir[0],y+dir[1],x,y)) {\\n                        int dd=transv(dir);\\n                        if(visited[x][y][dd]) continue;\\n                        visited[x][y][dd]=true;\\n                        q.offer(new int[]{x,y,dd});\\n                    }\\n                }\\n                //grid[x][y]=\\'.\\';\\n                //grid[v[0]][v[1]]=\\'B\\';\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean valid(char[][] graph,int sx,int sy,int tx,int ty,int bx,int by){\\n        if(tx<0||tx>m-1||ty<0||ty>n-1) return false;\\n        if(graph[tx][ty]!=\\'.\\') return false;\\n        Queue<int[]> q=new LinkedList();\\n        boolean[][] visited=new boolean[m][n];\\n        q.offer(new int[]{sx,sy});visited[sx][sy]=true;\\n        \\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int[] v=q.poll();\\n                if(v[0]==tx&&v[1]==ty) return true;\\n                for(int[] dir:dirs){\\n                    int x=v[0]+dir[0],y=v[1]+dir[1];\\n                    if(x<0||x>m-1||y<0||y>n-1) continue;\\n                    if(graph[x][y]!=\\'.\\') continue;\\n                    if(x==bx&&y==by) continue;\\n                    if(visited[x][y]) continue;\\n                    visited[x][y]=true;\\n                    q.offer(new int[]{x,y});\\n                }\\n            }\\n        \\n        }\\n        return false;\\n    }\\n    \\n    \\n    private int[][] dirs={{-1,0},{1,0},{0,1},{0,-1}};\\n    private int[] trans(int dir){\\n        int[] res=new int[2];\\n        if(dir==0) res[0]=-1;\\n        else if(dir==1) res[0]=1;\\n        else if(dir==2) res[1]=1;\\n        else res[1]=-1;\\n        return res;\\n    }\\n    \\n    private int transv(int[] dir){\\n        if(dir[0]==-1) return 0;\\n        else if(dir[0]==1) return 1;\\n        else if(dir[1]==1) return 2;\\n        else if(dir[1]==-1) return 3;\\n        return -1;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431209,
                "title": "python3-2-level-bfs-a-few-notes",
                "content": "A few key points that distinguishes this problem from your typical BFS:\\n\\n1. To push the box to a specific direction, player has to be at the opposite direction. So there needs be empty space on both sides\\n\\n2. Player has to be able to find a path from previous position to the needed position described in point 1 above\\n\\n3. Box position changes everytime players moves it, which affects point 2 above\\n\\n4, Box can return to a previous location if coming from different direction.\\n\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n      h = len(grid)\\n      w = len(grid[0])\\n      \\n      target, box, player = (0,0), (0,0), (0,0)\\n      for row in range(h):\\n        for col in range(w):\\n          if grid[row][col] == \\'B\\':\\n            cur = (row, col)\\n          if grid[row][col] == \\'T\\':\\n            target = (row, col)\\n          if grid[row][col] == \\'S\\':\\n            player = (row, col)\\n\\n      dirs = [(0, 1), (0, -1), (1, 0), (-1 ,0)]\\n      \\n      def has_path(pos, target):\\n        # print(grid)\\n        myq = [pos]\\n        visited = set()\\n        while myq:\\n          cur = myq.pop(0)\\n          if cur == target:\\n            return True\\n          for dir in dirs:\\n            new_pos = (cur[0] + dir[0], cur[1] + dir[1])\\n            if new_pos[0] >= 0 and new_pos[0] < h and new_pos[1] >= 0 and new_pos[1] < w:\\n              if grid[new_pos[0]][new_pos[1]] != \\'#\\' and grid[new_pos[0]][new_pos[1]] != \\'B\\' and new_pos not in visited:\\n                myq.append(new_pos)\\n                visited.add(new_pos)\\n        return False\\n\\n      myq = [(cur, player, 0)]\\n      visited = set()\\n      grid[box[0]][box[1]] = \\'.\\' \\n      \\n      while myq:\\n        box, player, cur_round = myq.pop(0)\\n        if box == target:\\n          return cur_round\\n        grid[box[0]][box[1]] = \\'B\\' # \\u83B7\\u5F97\\u5F53\\u524D\\u7BB1\\u5B50\\u7684\\u4F4D\\u7F6E\\n        for dir in dirs:\\n          new_pos = (box[0] + dir[0], box[1] + dir[1])\\n          oppo_pos = (box[0] - dir[0], box[1] - dir[1])\\n          if new_pos[0] >= 0 and new_pos[0] < h and new_pos[1] >= 0 and new_pos[1] < w:\\n            if oppo_pos[0] >= 0 and oppo_pos[0] < h and oppo_pos[1] >= 0 and oppo_pos[1] < w:\\n              # \\u5982\\u679C\\u6765\\u7684\\u65B9\\u5411\\u4E0D\\u540C\\uFF0C\\u90A3\\u4E48\\u7BB1\\u5B50\\u53EF\\u4EE5\\u56DE\\u5230\\u4E4B\\u524D\\u7ECF\\u8FC7\\u5230\\u8FC7\\u7684\\u4F4D\\u7F6E\\n              if grid[new_pos[0]][new_pos[1]] != \\'#\\' and grid[oppo_pos[0]][oppo_pos[1]] != \\'#\\' and (new_pos, box) not in visited: \\n                if has_path(player, oppo_pos): # player \\u80FD\\u5426\\u5230\\u8FBE\\u9700\\u8981\\u5230\\u8FBE\\u7684\\u4F4D\\u7F6E\\n                  myq.append((new_pos, box, cur_round + 1))# \\u63A8\\u5B8C\\u7BB1\\u5B50\\u540Eplayer\\u5904\\u4E8Ebox\\u539F\\u672C\\u7684\\u4F4D\\u7F6E\\n                  # print(box, \\'->\\', new_pos)\\n                  visited.add((new_pos, box))\\n        grid[box[0]][box[1]] = \\'.\\'\\n      return -1\\n                           \\n                           \\n              \\n            \\n        \\n      \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n      h = len(grid)\\n      w = len(grid[0])\\n      \\n      target, box, player = (0,0), (0,0), (0,0)\\n      for row in range(h):\\n        for col in range(w):\\n          if grid[row][col] == \\'B\\':\\n            cur = (row, col)\\n          if grid[row][col] == \\'T\\':\\n            target = (row, col)\\n          if grid[row][col] == \\'S\\':\\n            player = (row, col)\\n\\n      dirs = [(0, 1), (0, -1), (1, 0), (-1 ,0)]\\n      \\n      def has_path(pos, target):\\n        # print(grid)\\n        myq = [pos]\\n        visited = set()\\n        while myq:\\n          cur = myq.pop(0)\\n          if cur == target:\\n            return True\\n          for dir in dirs:\\n            new_pos = (cur[0] + dir[0], cur[1] + dir[1])\\n            if new_pos[0] >= 0 and new_pos[0] < h and new_pos[1] >= 0 and new_pos[1] < w:\\n              if grid[new_pos[0]][new_pos[1]] != \\'#\\' and grid[new_pos[0]][new_pos[1]] != \\'B\\' and new_pos not in visited:\\n                myq.append(new_pos)\\n                visited.add(new_pos)\\n        return False\\n\\n      myq = [(cur, player, 0)]\\n      visited = set()\\n      grid[box[0]][box[1]] = \\'.\\' \\n      \\n      while myq:\\n        box, player, cur_round = myq.pop(0)\\n        if box == target:\\n          return cur_round\\n        grid[box[0]][box[1]] = \\'B\\' # \\u83B7\\u5F97\\u5F53\\u524D\\u7BB1\\u5B50\\u7684\\u4F4D\\u7F6E\\n        for dir in dirs:\\n          new_pos = (box[0] + dir[0], box[1] + dir[1])\\n          oppo_pos = (box[0] - dir[0], box[1] - dir[1])\\n          if new_pos[0] >= 0 and new_pos[0] < h and new_pos[1] >= 0 and new_pos[1] < w:\\n            if oppo_pos[0] >= 0 and oppo_pos[0] < h and oppo_pos[1] >= 0 and oppo_pos[1] < w:\\n              # \\u5982\\u679C\\u6765\\u7684\\u65B9\\u5411\\u4E0D\\u540C\\uFF0C\\u90A3\\u4E48\\u7BB1\\u5B50\\u53EF\\u4EE5\\u56DE\\u5230\\u4E4B\\u524D\\u7ECF\\u8FC7\\u5230\\u8FC7\\u7684\\u4F4D\\u7F6E\\n              if grid[new_pos[0]][new_pos[1]] != \\'#\\' and grid[oppo_pos[0]][oppo_pos[1]] != \\'#\\' and (new_pos, box) not in visited: \\n                if has_path(player, oppo_pos): # player \\u80FD\\u5426\\u5230\\u8FBE\\u9700\\u8981\\u5230\\u8FBE\\u7684\\u4F4D\\u7F6E\\n                  myq.append((new_pos, box, cur_round + 1))# \\u63A8\\u5B8C\\u7BB1\\u5B50\\u540Eplayer\\u5904\\u4E8Ebox\\u539F\\u672C\\u7684\\u4F4D\\u7F6E\\n                  # print(box, \\'->\\', new_pos)\\n                  visited.add((new_pos, box))\\n        grid[box[0]][box[1]] = \\'.\\'\\n      return -1\\n                           \\n                           \\n              \\n            \\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431152,
                "title": "one-time-bfs-priority-queue-c-explaination-included",
                "content": "when we mark as visit we need two coords, box and keeper.\\nbecause they all <= 20, so I just use 100 , and easy for debug,\\nmy algorith first work on keeper minimized moves, but the mini push is asked so have to use pq to pop min pushes.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n\\t    // remember three coords, and retore them to not \\'#\\' it is road not wall\\n        int row = grid.size(), col = grid.front().size();\\n        pair<int, int> t, b, s;\\n        for (int r = 0; r < row; ++r) {\\n            for (int c = 0; c < col; ++c) {\\n                if (grid[r][c] == \\'T\\') {\\n                    t = make_pair(r, c);\\n                    grid[r][c] = \\'.\\';\\n                }\\n                if (grid[r][c] == \\'B\\') {\\n                    b = make_pair(r, c);\\n                    grid[r][c] = \\'.\\';\\n                }\\n                if (grid[r][c] == \\'S\\')  {\\n                    s = make_pair(r, c);\\n                    grid[r][c] = \\'.\\';\\n                }\\n            }\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n        unordered_set<int> vi;\\n\\t\\t// step is pushes, and key contains two coords\\n        q.emplace(0, b.first * 1000000 + b.second * 10000 + s.first * 100 + s.second);\\n        vi.emplace(b.first * 1000000 + b.second * 10000 + s.first * 100 + s.second);\\n\\n\\t\\t// just helper function to get cell\\n        auto g = [&](int r, int c) {\\n            if (r < 0 || r >= row || c < 0 || c >= col) return \\'#\\';\\n            return grid[r][c];\\n        };\\n\\n\\t\\t// if keeper possible moves\\n        auto check = [&](int step, int br, int bc, int r, int c) {\\n            if (g(r, c) != \\'.\\') return;\\n            if (br == r && bc == c) return;\\n            int key = br * 1000000 + bc * 10000 + r * 100 + c;\\n            if (vi.count(key)) return;\\n            vi.emplace(key);\\n            q.emplace(step, key);\\n        };\\n\\n\\t\\t// if push is possible, we need +1 on steps if possible\\n        auto push = [&](int step, int br, int bc, int r, int c) {\\n            int key = -1;\\n            if (make_pair(r + 1, c) == make_pair(br, bc) && g(r + 2, c) == \\'.\\') {\\n                key = (br + 1) * 1000000 + bc * 10000 + (r + 1)  * 100 + c;\\n            } else if (make_pair(r - 1, c) == make_pair(br, bc) && g(r - 2, c) == \\'.\\') {\\n                key = (br - 1) * 1000000 + bc * 10000 + (r - 1) * 100 + c;\\n            } else if (make_pair(r, c + 1) == make_pair(br, bc) && g(r, c + 2) == \\'.\\') {\\n                key = br * 1000000 + (bc + 1) * 10000 + r * 100 + c + 1;\\n            } else if (make_pair(r, c - 1) == make_pair(br, bc) && g(r, c - 2) == \\'.\\') {\\n                key = br * 1000000 + (bc - 1) * 10000 + r * 100 + c - 1;\\n            }\\n            if (key == -1) return;\\n            if (vi.count(key)) return;\\n            vi.emplace(key);\\n            q.emplace(step + 1, key);\\n        };\\n\\t\\t// here is just simple bfs\\n        while (q.size()) {\\n            int step = q.top().first;\\n            int cbr = q.top().second / 1000000 % 100;\\n            int cbc = q.top().second / 10000 % 100;\\n            int csr = q.top().second / 100 % 100;\\n            int csc = q.top().second / 1 % 100;\\n            q.pop();\\n            if (cbr == t.first && cbc == t.second) return step;\\n            check(step, cbr, cbc, csr + 1, csc);\\n            check(step, cbr, cbc, csr, csc + 1);\\n            check(step, cbr, cbc, csr - 1, csc);\\n            check(step, cbr, cbc, csr, csc - 1);\\n            push(step, cbr, cbc, csr, csc);\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n\\t    // remember three coords, and retore them to not \\'#\\' it is road not wall\\n        int row = grid.size(), col = grid.front().size();\\n        pair<int, int> t, b, s;\\n        for (int r = 0; r < row; ++r) {\\n            for (int c = 0; c < col; ++c) {\\n                if (grid[r][c] == \\'T\\') {\\n                    t = make_pair(r, c);\\n                    grid[r][c] = \\'.\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 431129,
                "title": "2-stage-dfs-solution-using-java",
                "content": "I used minReach array to record minimal reach steps from 4 directions, then using dfs to walk step by step, finally return minReach of target position.\\n```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        int[][][] minReach = new int[grid.length][grid[0].length][4];\\n        for (int i = 0; i < minReach.length; i++) {\\n            for (int j = 0; j < minReach[0].length; j++) {\\n                for (int k = 0; k < minReach[0][0].length; k++) {\\n                    minReach[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        int px = 0, py = 0, bx = 0, by = 0, tx = 0, ty = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'B\\') {\\n                    minReach[i][j][0] = 0;\\n                    minReach[i][j][1] = 0;\\n                    minReach[i][j][2] = 0;\\n                    minReach[i][j][3] = 0;\\n                    bx = i;\\n                    by = j;\\n                } else if (grid[i][j] == \\'T\\') {\\n                    tx = i;\\n                    ty = j;\\n                } else if (grid[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                }\\n            }\\n        }\\n        dfs(grid, minReach, bx, by, px, py, 0);\\n        int result = -1;\\n        for (int i = 0; i < 4; i++) {\\n            if (minReach[tx][ty][i] != -1) {\\n                if (result == -1) {\\n                    result = minReach[tx][ty][i];\\n                } else {\\n                    result = Math.min(result, minReach[tx][ty][i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void dfs(char[][] grid, int[][][] minReach, int bx, int by, int px, int py, int current) {\\n        current++;\\n        if (bx + 1 < grid.length && grid[bx + 1][by] != \\'#\\' && (minReach[bx + 1][by][0] == -1 || current < minReach[bx + 1][by][0]) && canReach(grid, bx - 1, by, px, py)) {\\n            minReach[bx + 1][by][0] = current;\\n            grid[bx + 1][by] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx + 1, by, bx - 1, by, current);\\n            grid[bx][by] = \\'B\\';\\n            grid[bx + 1][by] = \\'.\\';\\n        }\\n\\n        if (bx - 1 >= 0 && grid[bx - 1][by] != \\'#\\' && (minReach[bx - 1][by][1] == -1 || current < minReach[bx - 1][by][1]) && canReach(grid, bx + 1, by, px, py)) {\\n            minReach[bx - 1][by][1] = current;\\n            grid[bx - 1][by] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx - 1, by, bx + 1, by, current);\\n            grid[bx - 1][by] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n\\n        if (by + 1 < grid[0].length && grid[bx][by + 1] != \\'#\\' && (minReach[bx][by + 1][2] == -1 || current < minReach[bx][by + 1][2]) && canReach(grid, bx, by - 1, px, py)) {\\n            minReach[bx][by + 1][2] = current;\\n            grid[bx][by + 1] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx, by + 1, bx, by - 1, current);\\n            grid[bx][by + 1] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n\\n        if (by - 1 >= 0 && grid[bx][by - 1] != \\'#\\' && (minReach[bx][by - 1][3] == -1 || current < minReach[bx][by - 1][3]) && canReach(grid, bx, by + 1, px, py)) {\\n            minReach[bx][by - 1][3] = current;\\n            grid[bx][by - 1] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx, by - 1, bx, by + 1, current);\\n            grid[bx][by - 1] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n    }\\n\\n    private boolean canReach(char[][] grid, int x, int y, int px, int py) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        boolean[][] visit = new boolean[grid.length][grid[0].length];\\n        travel(grid, px, py, visit);\\n        return visit[x][y];\\n    }\\n\\n    private void travel(char[][] grid, int px, int py, boolean[][] visit) {\\n        if (px >= 0 && px < grid.length && py >= 0 && py < grid[0].length && !visit[px][py] && grid[px][py] != \\'#\\' && grid[px][py] != \\'B\\') {\\n            visit[px][py] = true;\\n            travel(grid, px - 1, py, visit);\\n            travel(grid, px + 1, py, visit);\\n            travel(grid, px, py - 1, visit);\\n            travel(grid, px, py + 1, visit);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(new Solution().minPushBox(new char[][]{{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}, {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}, {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'}, {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'}, {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'}, {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}}));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        int[][][] minReach = new int[grid.length][grid[0].length][4];\\n        for (int i = 0; i < minReach.length; i++) {\\n            for (int j = 0; j < minReach[0].length; j++) {\\n                for (int k = 0; k < minReach[0][0].length; k++) {\\n                    minReach[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        int px = 0, py = 0, bx = 0, by = 0, tx = 0, ty = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'B\\') {\\n                    minReach[i][j][0] = 0;\\n                    minReach[i][j][1] = 0;\\n                    minReach[i][j][2] = 0;\\n                    minReach[i][j][3] = 0;\\n                    bx = i;\\n                    by = j;\\n                } else if (grid[i][j] == \\'T\\') {\\n                    tx = i;\\n                    ty = j;\\n                } else if (grid[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                }\\n            }\\n        }\\n        dfs(grid, minReach, bx, by, px, py, 0);\\n        int result = -1;\\n        for (int i = 0; i < 4; i++) {\\n            if (minReach[tx][ty][i] != -1) {\\n                if (result == -1) {\\n                    result = minReach[tx][ty][i];\\n                } else {\\n                    result = Math.min(result, minReach[tx][ty][i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void dfs(char[][] grid, int[][][] minReach, int bx, int by, int px, int py, int current) {\\n        current++;\\n        if (bx + 1 < grid.length && grid[bx + 1][by] != \\'#\\' && (minReach[bx + 1][by][0] == -1 || current < minReach[bx + 1][by][0]) && canReach(grid, bx - 1, by, px, py)) {\\n            minReach[bx + 1][by][0] = current;\\n            grid[bx + 1][by] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx + 1, by, bx - 1, by, current);\\n            grid[bx][by] = \\'B\\';\\n            grid[bx + 1][by] = \\'.\\';\\n        }\\n\\n        if (bx - 1 >= 0 && grid[bx - 1][by] != \\'#\\' && (minReach[bx - 1][by][1] == -1 || current < minReach[bx - 1][by][1]) && canReach(grid, bx + 1, by, px, py)) {\\n            minReach[bx - 1][by][1] = current;\\n            grid[bx - 1][by] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx - 1, by, bx + 1, by, current);\\n            grid[bx - 1][by] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n\\n        if (by + 1 < grid[0].length && grid[bx][by + 1] != \\'#\\' && (minReach[bx][by + 1][2] == -1 || current < minReach[bx][by + 1][2]) && canReach(grid, bx, by - 1, px, py)) {\\n            minReach[bx][by + 1][2] = current;\\n            grid[bx][by + 1] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx, by + 1, bx, by - 1, current);\\n            grid[bx][by + 1] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n\\n        if (by - 1 >= 0 && grid[bx][by - 1] != \\'#\\' && (minReach[bx][by - 1][3] == -1 || current < minReach[bx][by - 1][3]) && canReach(grid, bx, by + 1, px, py)) {\\n            minReach[bx][by - 1][3] = current;\\n            grid[bx][by - 1] = \\'B\\';\\n            grid[bx][by] = \\'.\\';\\n            dfs(grid, minReach, bx, by - 1, bx, by + 1, current);\\n            grid[bx][by - 1] = \\'.\\';\\n            grid[bx][by] = \\'B\\';\\n        }\\n    }\\n\\n    private boolean canReach(char[][] grid, int x, int y, int px, int py) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == \\'#\\') {\\n            return false;\\n        }\\n        boolean[][] visit = new boolean[grid.length][grid[0].length];\\n        travel(grid, px, py, visit);\\n        return visit[x][y];\\n    }\\n\\n    private void travel(char[][] grid, int px, int py, boolean[][] visit) {\\n        if (px >= 0 && px < grid.length && py >= 0 && py < grid[0].length && !visit[px][py] && grid[px][py] != \\'#\\' && grid[px][py] != \\'B\\') {\\n            visit[px][py] = true;\\n            travel(grid, px - 1, py, visit);\\n            travel(grid, px + 1, py, visit);\\n            travel(grid, px, py - 1, visit);\\n            travel(grid, px, py + 1, visit);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(new Solution().minPushBox(new char[][]{{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}, {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}, {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'}, {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'}, {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'}, {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}}));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020588,
                "title": "0-1-bfs-simple-solution-o-m-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int nRows = grid.size(), nCols = grid[0].size();\\n        int px,py, bx,by;\\n        for(int i=0;i<nRows; i++) {\\n            for(int j=0;j<nCols;j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    px = i; py = j;\\n                }\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i; by = j;\\n                }\\n            }\\n        }\\n\\n        deque<vector<int>> queue;\\n        queue.push_back({px,py,bx,by});\\n\\n        int numPush[21][21][21][21];\\n        memset(numPush, -1, sizeof(numPush));\\n\\n        \\n        numPush[px][py][bx][by] = 0;\\n\\n        while(!queue.empty()) {\\n            auto state = queue.front();\\n            queue.pop_front();\\n\\n            px = state[0], py = state[1];\\n            bx = state[2], by = state[3];\\n            if(grid[bx][by] == \\'T\\') return numPush[px][py][bx][by];\\n\\n            // cout<<px<<\" \"<<py<<\" \"<<bx<<\" \"<<by<<\" \"<<numPush[px][py][bx][by]<<endl;\\n\\n            vector<pair<int,int>> nextPlayerPos = {{px+1, py}, {px-1,py}, {px,py+1}, {px,py-1}};\\n            for(auto [nextPx, nextPy]: nextPlayerPos) {\\n                if(nextPx < 0 || nextPy < 0 || nextPx == nRows || nextPy == nCols || grid[nextPx][nextPy] == \\'#\\')\\n                    continue;\\n                int nextBx = bx, nextBy = by;\\n                if(nextPx == bx && nextPy == by) { \\n                    nextBx+=(nextPx - px); nextBy+=(nextPy-py);\\n                }\\n\\n                if(nextBx < 0 || nextBy < 0 || nextBx == nRows || nextBy == nCols || grid[nextBx][nextBy] == \\'#\\') continue;\\n\\n                int& pushCnt =  numPush[nextPx][nextPy][nextBx][nextBy];\\n                int prevPushCnt = numPush[px][py][bx][by];\\n                vector<int> nextState = {nextPx, nextPy, nextBx, nextBy};\\n\\n                if(pushCnt != -1) continue;\\n\\n                if(bx == nextBx && by == nextBy) {\\n                    pushCnt = prevPushCnt;\\n                    queue.push_front(nextState);\\n                } else {\\n                    pushCnt = prevPushCnt+1;\\n                    queue.push_back(nextState);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int nRows = grid.size(), nCols = grid[0].size();\\n        int px,py, bx,by;\\n        for(int i=0;i<nRows; i++) {\\n            for(int j=0;j<nCols;j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    px = i; py = j;\\n                }\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i; by = j;\\n                }\\n            }\\n        }\\n\\n        deque<vector<int>> queue;\\n        queue.push_back({px,py,bx,by});\\n\\n        int numPush[21][21][21][21];\\n        memset(numPush, -1, sizeof(numPush));\\n\\n        \\n        numPush[px][py][bx][by] = 0;\\n\\n        while(!queue.empty()) {\\n            auto state = queue.front();\\n            queue.pop_front();\\n\\n            px = state[0], py = state[1];\\n            bx = state[2], by = state[3];\\n            if(grid[bx][by] == \\'T\\') return numPush[px][py][bx][by];\\n\\n            // cout<<px<<\" \"<<py<<\" \"<<bx<<\" \"<<by<<\" \"<<numPush[px][py][bx][by]<<endl;\\n\\n            vector<pair<int,int>> nextPlayerPos = {{px+1, py}, {px-1,py}, {px,py+1}, {px,py-1}};\\n            for(auto [nextPx, nextPy]: nextPlayerPos) {\\n                if(nextPx < 0 || nextPy < 0 || nextPx == nRows || nextPy == nCols || grid[nextPx][nextPy] == \\'#\\')\\n                    continue;\\n                int nextBx = bx, nextBy = by;\\n                if(nextPx == bx && nextPy == by) { \\n                    nextBx+=(nextPx - px); nextBy+=(nextPy-py);\\n                }\\n\\n                if(nextBx < 0 || nextBy < 0 || nextBx == nRows || nextBy == nCols || grid[nextBx][nextBy] == \\'#\\') continue;\\n\\n                int& pushCnt =  numPush[nextPx][nextPy][nextBx][nextBy];\\n                int prevPushCnt = numPush[px][py][bx][by];\\n                vector<int> nextState = {nextPx, nextPy, nextBx, nextBy};\\n\\n                if(pushCnt != -1) continue;\\n\\n                if(bx == nextBx && by == nextBy) {\\n                    pushCnt = prevPushCnt;\\n                    queue.push_front(nextState);\\n                } else {\\n                    pushCnt = prevPushCnt+1;\\n                    queue.push_back(nextState);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3958133,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS for box position + player pushing position\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS for box+playr position\\nfor each player position change, check if player can move to new position or not\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing ii=pair<int,int>;\\nusing box_player=tuple<int,int,int,int>;//bx,by,px,py\\nvector<int> d{-1,0,1,0,-1};\\n\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& matrix) {\\n        int m=matrix.size(), n=matrix[0].size();//check case ==0\\n        ii box, player, target;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==\\'B\\') box={i,j};\\n                if(matrix[i][j]==\\'T\\') target={i,j};//use else if\\n                if(matrix[i][j]==\\'S\\') player={i,j};\\n            }\\n        }\\n        box_player start{box.first,box.second,player.first,player.second};\\n        auto [bx,by,px,py]=start;\\n    \\n        queue<box_player> q;\\n        //not use visited to just mark box position, since we can have box in same position but player in diff push position\\n        vector<vector<vector<vector<int>>>> visited(m,vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(n,0))));\\n        q.push(start);\\n        visited[bx][by][px][py]=1;//px py is not the best ready to push postition, check if need to put multiple start with avaliable ready to push positions, seems not required\\n        int step=0;\\n\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int i=0; i<sz; i++){\\n                auto [bx,by,px,py] = q.front(); q.pop();\\n                if(bx==target.first && by==target.second) return step;\\n                for(int i=0; i<4; i++){\\n                    int nbx = bx + d[i];\\n                    int nby = by + d[i+1];\\n                    int npx = bx - d[i];\\n                    int npy = by - d[i+1];\\n                    if(nbx<0 || nbx>m-1 || nby<0 || nby>n-1) continue;//range\\n                    if(npx<0 || npx>m-1 || npy<0 || npy>n-1) continue;//range\\n                    if(matrix[nbx][nby]==\\'#\\') continue;//wall\\n                    if(matrix[npx][npy]==\\'#\\') continue;//wall\\n                    if(visited[nbx][nby][npx][npy]) continue;//visited\\n                    if(!reachable(matrix,{px,py},{npx,npy},{bx,by})) continue;//use dp\\n                    visited[nbx][nby][npx][npy]=1;//mark as visited\\n                    q.emplace(nbx,nby,bx,by);//move player to pre box postion\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    //not use ref for now\\n    bool reachable(vector<vector<char>> matrix, ii start, ii end, ii box){\\n        int m=matrix.size(); \\n        int n=matrix[0].size();\\n        matrix[box.first][box.second] = \\'#\\';\\n\\n        queue<ii> q;\\n        matrix[start.first][start.second] = \\'#\\';//mark as visited\\n        q.push(start);\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            if(x==end.first && y==end.second) return true;\\n            for(int i=0; i<4; i++){\\n                int nx = x + d[i];\\n                int ny = y + d[i+1];\\n                if(nx<0 || nx>m-1 || ny<0 || ny>n-1) continue;\\n                if(matrix[nx][ny]==\\'#\\') continue;\\n                matrix[nx][ny]=\\'#\\';\\n                q.emplace(nx,ny);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/*\\nbox: B\\ntarget postition: T\\nplayer: S\\nempty cell: .\\nwall: #\\nonly push operation\\n\\nreturn: min move of *pushes* to push to target, fallback is -1\\n================================\\nfor people:(not need to calcu, can use to do validation) \\n    for each box postition\\n        we can calcu from cur position to ready to push position, -> bfs\\n\\nfor box move: -> bfs\\n    we need to know each box position from B to T, the shortest posible solution\\n\\nwe can from B bfs to T, if invalid, skip, find the valid path\\n    valid: cur -> nxt, the player can reach the push position of cur \\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ii=pair<int,int>;\\nusing box_player=tuple<int,int,int,int>;//bx,by,px,py\\nvector<int> d{-1,0,1,0,-1};\\n\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& matrix) {\\n        int m=matrix.size(), n=matrix[0].size();//check case ==0\\n        ii box, player, target;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==\\'B\\') box={i,j};\\n                if(matrix[i][j]==\\'T\\') target={i,j};//use else if\\n                if(matrix[i][j]==\\'S\\') player={i,j};\\n            }\\n        }\\n        box_player start{box.first,box.second,player.first,player.second};\\n        auto [bx,by,px,py]=start;\\n    \\n        queue<box_player> q;\\n        //not use visited to just mark box position, since we can have box in same position but player in diff push position\\n        vector<vector<vector<vector<int>>>> visited(m,vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(n,0))));\\n        q.push(start);\\n        visited[bx][by][px][py]=1;//px py is not the best ready to push postition, check if need to put multiple start with avaliable ready to push positions, seems not required\\n        int step=0;\\n\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int i=0; i<sz; i++){\\n                auto [bx,by,px,py] = q.front(); q.pop();\\n                if(bx==target.first && by==target.second) return step;\\n                for(int i=0; i<4; i++){\\n                    int nbx = bx + d[i];\\n                    int nby = by + d[i+1];\\n                    int npx = bx - d[i];\\n                    int npy = by - d[i+1];\\n                    if(nbx<0 || nbx>m-1 || nby<0 || nby>n-1) continue;//range\\n                    if(npx<0 || npx>m-1 || npy<0 || npy>n-1) continue;//range\\n                    if(matrix[nbx][nby]==\\'#\\') continue;//wall\\n                    if(matrix[npx][npy]==\\'#\\') continue;//wall\\n                    if(visited[nbx][nby][npx][npy]) continue;//visited\\n                    if(!reachable(matrix,{px,py},{npx,npy},{bx,by})) continue;//use dp\\n                    visited[nbx][nby][npx][npy]=1;//mark as visited\\n                    q.emplace(nbx,nby,bx,by);//move player to pre box postion\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    //not use ref for now\\n    bool reachable(vector<vector<char>> matrix, ii start, ii end, ii box){\\n        int m=matrix.size(); \\n        int n=matrix[0].size();\\n        matrix[box.first][box.second] = \\'#\\';\\n\\n        queue<ii> q;\\n        matrix[start.first][start.second] = \\'#\\';//mark as visited\\n        q.push(start);\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            if(x==end.first && y==end.second) return true;\\n            for(int i=0; i<4; i++){\\n                int nx = x + d[i];\\n                int ny = y + d[i+1];\\n                if(nx<0 || nx>m-1 || ny<0 || ny>n-1) continue;\\n                if(matrix[nx][ny]==\\'#\\') continue;\\n                matrix[nx][ny]=\\'#\\';\\n                q.emplace(nx,ny);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/*\\nbox: B\\ntarget postition: T\\nplayer: S\\nempty cell: .\\nwall: #\\nonly push operation\\n\\nreturn: min move of *pushes* to push to target, fallback is -1\\n================================\\nfor people:(not need to calcu, can use to do validation) \\n    for each box postition\\n        we can calcu from cur position to ready to push position, -> bfs\\n\\nfor box move: -> bfs\\n    we need to know each box position from B to T, the shortest posible solution\\n\\nwe can from B bfs to T, if invalid, skip, find the valid path\\n    valid: cur -> nxt, the player can reach the push position of cur \\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753475,
                "title": "0-1-bfs-using-postition-pair-as-node",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        valid = lambda x, y: 0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"\\n        start = box = -1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"S\":\\n                    start = (i, j)\\n                if grid[i][j] == \"B\":\\n                    box = (i, j)\\n        q = deque([(start, box, 0)])\\n        v = {(start, box)}\\n        res = -1\\n        while len(q) > 0:\\n            curr, currbox, d = q.pop()\\n            if grid[currbox[0]][currbox[1]] == \"T\":\\n                return d\\n            for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                x, y = curr[0] + dx, curr[1] + dy\\n                if not valid(x, y):\\n                    continue\\n                if (x, y) == currbox:\\n                    newbox = (curr[0] + 2 * dx, curr[1] + 2 * dy)\\n                    if valid(newbox[0], newbox[1]) and ((x, y), newbox) not in v:\\n                        v.add(((x, y), newbox))\\n                        q.appendleft(((x, y), newbox, d + 1))\\n                elif ((x, y), currbox) not in v:\\n                    v.add(((x, y), currbox))\\n                    q.append(((x, y), currbox, d))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        valid = lambda x, y: 0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"\\n        start = box = -1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"S\":\\n                    start = (i, j)\\n                if grid[i][j] == \"B\":\\n                    box = (i, j)\\n        q = deque([(start, box, 0)])\\n        v = {(start, box)}\\n        res = -1\\n        while len(q) > 0:\\n            curr, currbox, d = q.pop()\\n            if grid[currbox[0]][currbox[1]] == \"T\":\\n                return d\\n            for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                x, y = curr[0] + dx, curr[1] + dy\\n                if not valid(x, y):\\n                    continue\\n                if (x, y) == currbox:\\n                    newbox = (curr[0] + 2 * dx, curr[1] + 2 * dy)\\n                    if valid(newbox[0], newbox[1]) and ((x, y), newbox) not in v:\\n                        v.add(((x, y), newbox))\\n                        q.appendleft(((x, y), newbox, d + 1))\\n                elif ((x, y), currbox) not in v:\\n                    v.add(((x, y), currbox))\\n                    q.append(((x, y), currbox, d))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587863,
                "title": "solution",
                "content": "```C++ []\\ntypedef pair<int, int> PII;\\n\\nstruct Node {\\n    PII b_pos;\\n    PII p_pos;\\n    int steps;\\n    Node(PII b_pos_, PII p_pos_, int step) : b_pos(b_pos_), p_pos(p_pos_), steps(step) {}\\n};\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {1, 0, -1, 0};\\n    int row = 0, col = 0;\\n    PII target_pos;\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        PII box_pos, player_pos;\\n        for(int i = 0; i<row; i++) {\\n            for(int j = 0; j<col; j++) {\\n                if(grid[i][j] == \\'T\\') {\\n                    target_pos.first = i, target_pos.second = j;\\n                } else if(grid[i][j] == \\'B\\') {\\n                    box_pos.first = i, box_pos.second = j;\\n                } else if(grid[i][j] == \\'S\\') {\\n                    player_pos.first = i, player_pos.second = j;\\n                }\\n            }\\n        }\\n        auto can_get = [&](PII player_pos_func, PII box_pos_func, PII tar_pos) -> bool {\\n            if(player_pos_func.first == tar_pos.first && player_pos_func.second == tar_pos.second) return true;\\n            queue<PII> que;\\n            que.push(player_pos_func);\\n            bool sta[25][25];\\n            memset(sta, false, sizeof sta);\\n            sta[player_pos_func.first][player_pos_func.second] = true;\\n            while(que.size()) {\\n                auto cur_player_pos = que.front();\\n                que.pop();\\n                int cur_p_x = cur_player_pos.first, cur_p_y = cur_player_pos.second;\\n                for(int i = 0; i<4; i++) {\\n                    int x = cur_p_x + dx[i], y = cur_p_y + dy[i];\\n                    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == \\'#\\' || sta[x][y]) continue;\\n                    if(x == box_pos_func.first && y == box_pos_func.second) continue;\\n                    if(x == tar_pos.first && y == tar_pos.second) return true;\\n                    que.push({x, y});\\n                    sta[x][y] = true;\\n                }\\n            }\\n            return false;\\n        };\\n        queue<Node> q;\\n        q.push({box_pos, player_pos, 0});\\n        bool st[25][25][25][25];\\n        memset(st, false, sizeof st);\\n        while(q.size()) {\\n            auto cur = q.front();\\n            q.pop();\\n            PII cur_box_pos = cur.b_pos, cur_player_pos = cur.p_pos;\\n            int cur_step = cur.steps;\\n            for(int i = 0; i<4; i++) {\\n                int box_next_x = cur_box_pos.first + dx[i], box_next_y = cur_box_pos.second + dy[i];\\n                if(box_next_x<0 || box_next_x>=row || box_next_y<0 || box_next_y>=col || grid[box_next_x][box_next_y] == \\'#\\') {\\n                    continue;\\n                }\\n                int player_next_x, player_next_y;\\n                if(dx[i] == 0) {\\n                    player_next_x = cur_box_pos.first, player_next_y = cur_box_pos.second - dy[i];\\n                }\\n                if(dy[i] == 0) {\\n                    player_next_x = cur_box_pos.first - dx[i], player_next_y = cur_box_pos.second;\\n                }\\n                if(player_next_x<0 || player_next_x>=row || player_next_y<0 || player_next_y>=col || grid[player_next_x][player_next_y] == \\'#\\') {\\n                    continue;\\n                }\\n                if(st[cur_box_pos.first][cur_box_pos.second][player_next_x][player_next_y]) continue;\\n                if(!can_get(cur_player_pos, cur_box_pos, {player_next_x, player_next_y})) {\\n                    continue;\\n                }\\n                if(box_next_x == target_pos.first && box_next_y == target_pos.second) return cur_step + 1;\\n                q.push({{box_next_x, box_next_y}, cur_box_pos, cur_step+1});\\n                st[cur_box_pos.first][cur_box_pos.second][player_next_x][player_next_y] = true;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        maze = [[\\'#\\']*(C+2)]\\n\\n        for r in range(1,R+1):\\n            maze.append([\\'#\\'])\\n            str = grid[r-1]\\n            for c in range(1,C+1): \\n                match str[c-1]:\\n                    case \\'B\\':\\n                        Box = (r,c)\\n                    case \\'S\\':\\n                        Source = (r,c)\\n                    case \\'T\\':\\n                        Target = (r,c)\\n\\n                if(str[c-1] == \\'#\\'):\\n                    maze[r].append(\\'#\\')\\n                else:\\n                    maze[r].append(\\'.\\')\\n\\n            maze[r].append(\\'#\\')\\n\\n        maze.append(maze[0])\\n\\n        layer = 0\\n        layermap = [[0]*(C+2) for _ in range(R+2)]\\n        ways = [[1,0], [0,1], [-1,0], [0,-1]]\\n\\n        def reachable(source, target, layer):\\n            buffer = deque([source])\\n\\n            while buffer:\\n                pos = buffer.popleft()\\n\\n                if(pos == target):\\n                    return True\\n\\n                next = [(pos[0]-1, pos[1]), (pos[0], pos[1]-1), (pos[0]+1, pos[1]), (pos[0], pos[1]+1)]\\n\\n                for r, c in next:\\n                    if(maze[r][c] == \\'.\\' and layermap[r][c] != layer):\\n                        layermap[r][c] = layer\\n                        buffer.append((r,c))\\n                \\n            return False\\n\\n        maxstep = 400\\n        steped = [[[0]*4 for _ in range(C+2)] for _ in range(R+2)]\\n        buffer = deque([(Box, Source, 0)])\\n\\n        while buffer:\\n            box, source, step = buffer.popleft()\\n\\n            if(box == Target):\\n                maxstep = step\\n                break\\n            if(step > maxstep):\\n                break\\n\\n            new_boxes = [(box[0]+1, box[1]), (box[0], box[1]+1), (box[0]-1, box[1]), (box[0], box[1]-1)]\\n            new_sources = [(box[0]-1, box[1]), (box[0], box[1]-1), (box[0]+1, box[1]), (box[0], box[1]+1)]\\n            w = 0\\n\\n            for push_to, push_from in zip(new_boxes, new_sources):\\n                if(maze[push_to[0]][push_to[1]] == \\'.\\' and maze[push_from[0]][push_from[1]] == \\'.\\' and steped[push_to[0]][push_to[1]][w] == 0):\\n                    maze[box[0]][box[1]] = \\'#\\'\\n                    layer += 1\\n\\n                    if(reachable(source, push_from, layer)):\\n                        steped[push_to[0]][push_to[1]][w] = step+1\\n                        buffer.append((push_to, box, step+1))\\n\\n                    maze[box[0]][box[1]] = \\'.\\'\\n\\n                w += 1\\n\\n        if(maxstep == 400):\\n            return -1\\n        \\n        return maxstep\\n```\\n\\n```Java []\\nclass Solution {\\n        char[][] grid;\\n        int m, n;\\n        int[][] DIRS = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] reachable; \\n\\n        public int minPushBox(char[][] grid) {\\n            this.grid = grid;\\n            m = grid.length;\\n            n = grid[0].length;\\n            int step = 0;\\n            boolean[][][] visited = new boolean[m][n][4];\\n            reachable = new boolean[m][n];\\n\\n            Deque<int[]> boxQ = new LinkedList<>();\\n            Deque<int[]> playerQ = new LinkedList<>();\\n            int[] targetLoc = new int[2];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (grid[i][j] == \\'B\\') boxQ.offer(new int[]{i, j});\\n                    if (grid[i][j] == \\'T\\') targetLoc = new int[]{i, j};\\n                    if (grid[i][j] == \\'S\\') playerQ.offer(new int[]{i, j});\\n                }\\n            }\\n            while (!boxQ.isEmpty()) {\\n                int size = boxQ.size();\\n                while (size-- > 0) {\\n                    int[] boxLoc = boxQ.poll();\\n                    int[] playerLoc = playerQ.poll();\\n                    if (boxLoc[0] == targetLoc[0] && boxLoc[1] == targetLoc[1])\\n                        return step;\\n\\n                    for (int d = 0; d < 4; d++) {\\n                        if (visited[boxLoc[0]][boxLoc[1]][d]) continue;\\n                        int[] dir = DIRS[d];\\n                        int newPlayerR = boxLoc[0] - dir[0], newPlayerC = boxLoc[1] - dir[1];\\n                        if (newPlayerR < 0 || newPlayerR >= m || newPlayerC < 0 || newPlayerC >= n\\n                                || grid[newPlayerR][newPlayerC] == \\'#\\')\\n                            continue;\\n                        int newBoxR = boxLoc[0] + dir[0], newBoxC = boxLoc[1] + dir[1];\\n                        if (newBoxR < 0 || newBoxR >= m || newBoxC < 0 || newBoxC >= n\\n                                || grid[newBoxR][newBoxC] == \\'#\\')\\n                            continue;\\n                        if (!reachable(newPlayerR, newPlayerC, boxLoc, playerLoc))\\n                            continue;\\n\\n                        visited[boxLoc[0]][boxLoc[1]][d] = true;\\n                        boxQ.offer(new int[]{newBoxR, newBoxC});\\n                        playerQ.offer(new int[]{newPlayerR, newPlayerC});\\n                    }\\n                }\\n                step++;\\n            }\\n            return -1;\\n        }\\n        private boolean reachable(int targetR, int targetC, int[] boxLoc, int[] playerLoc) {\\n            if (reachable[targetR][targetC]){\\n                return true;\\n            }\\n            Deque<int[]> queue = new LinkedList<>();\\n            queue.offer(playerLoc);\\n            boolean[][] visited = new boolean[m][n];\\n            visited[boxLoc[0]][boxLoc[1]] = true;\\n\\n            while (!queue.isEmpty()) {\\n                int[] curr = queue.poll();\\n                if (curr[0] == targetR && curr[1] == targetC){\\n                    reachable[targetR][targetC] = true;\\n                    return true;\\n                }\\n                for (int[] d : DIRS) {\\n                    int r = curr[0] + d[0], c = curr[1] + d[1];\\n                    if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] == \\'#\\')\\n                        continue;\\n                    queue.offer(new int[]{r, c});\\n                    visited[r][c] = true;\\n                }\\n            }\\n            return false;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\ntypedef pair<int, int> PII;\\n\\nstruct Node {\\n    PII b_pos;\\n    PII p_pos;\\n    int steps;\\n    Node(PII b_pos_, PII p_pos_, int step) : b_pos(b_pos_), p_pos(p_pos_), steps(step) {}\\n};\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {1, 0, -1, 0};\\n    int row = 0, col = 0;\\n    PII target_pos;\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        PII box_pos, player_pos;\\n        for(int i = 0; i<row; i++) {\\n            for(int j = 0; j<col; j++) {\\n                if(grid[i][j] == \\'T\\') {\\n                    target_pos.first = i, target_pos.second = j;\\n                } else if(grid[i][j] == \\'B\\') {\\n                    box_pos.first = i, box_pos.second = j;\\n                } else if(grid[i][j] == \\'S\\') {\\n                    player_pos.first = i, player_pos.second = j;\\n                }\\n            }\\n        }\\n        auto can_get = [&](PII player_pos_func, PII box_pos_func, PII tar_pos) -> bool {\\n            if(player_pos_func.first == tar_pos.first && player_pos_func.second == tar_pos.second) return true;\\n            queue<PII> que;\\n            que.push(player_pos_func);\\n            bool sta[25][25];\\n            memset(sta, false, sizeof sta);\\n            sta[player_pos_func.first][player_pos_func.second] = true;\\n            while(que.size()) {\\n                auto cur_player_pos = que.front();\\n                que.pop();\\n                int cur_p_x = cur_player_pos.first, cur_p_y = cur_player_pos.second;\\n                for(int i = 0; i<4; i++) {\\n                    int x = cur_p_x + dx[i], y = cur_p_y + dy[i];\\n                    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == \\'#\\' || sta[x][y]) continue;\\n                    if(x == box_pos_func.first && y == box_pos_func.second) continue;\\n                    if(x == tar_pos.first && y == tar_pos.second) return true;\\n                    que.push({x, y});\\n                    sta[x][y] = true;\\n                }\\n            }\\n            return false;\\n        };\\n        queue<Node> q;\\n        q.push({box_pos, player_pos, 0});\\n        bool st[25][25][25][25];\\n        memset(st, false, sizeof st);\\n        while(q.size()) {\\n            auto cur = q.front();\\n            q.pop();\\n            PII cur_box_pos = cur.b_pos, cur_player_pos = cur.p_pos;\\n            int cur_step = cur.steps;\\n            for(int i = 0; i<4; i++) {\\n                int box_next_x = cur_box_pos.first + dx[i], box_next_y = cur_box_pos.second + dy[i];\\n                if(box_next_x<0 || box_next_x>=row || box_next_y<0 || box_next_y>=col || grid[box_next_x][box_next_y] == \\'#\\') {\\n                    continue;\\n                }\\n                int player_next_x, player_next_y;\\n                if(dx[i] == 0) {\\n                    player_next_x = cur_box_pos.first, player_next_y = cur_box_pos.second - dy[i];\\n                }\\n                if(dy[i] == 0) {\\n                    player_next_x = cur_box_pos.first - dx[i], player_next_y = cur_box_pos.second;\\n                }\\n                if(player_next_x<0 || player_next_x>=row || player_next_y<0 || player_next_y>=col || grid[player_next_x][player_next_y] == \\'#\\') {\\n                    continue;\\n                }\\n                if(st[cur_box_pos.first][cur_box_pos.second][player_next_x][player_next_y]) continue;\\n                if(!can_get(cur_player_pos, cur_box_pos, {player_next_x, player_next_y})) {\\n                    continue;\\n                }\\n                if(box_next_x == target_pos.first && box_next_y == target_pos.second) return cur_step + 1;\\n                q.push({{box_next_x, box_next_y}, cur_box_pos, cur_step+1});\\n                st[cur_box_pos.first][cur_box_pos.second][player_next_x][player_next_y] = true;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        maze = [[\\'#\\']*(C+2)]\\n\\n        for r in range(1,R+1):\\n            maze.append([\\'#\\'])\\n            str = grid[r-1]\\n            for c in range(1,C+1): \\n                match str[c-1]:\\n                    case \\'B\\':\\n                        Box = (r,c)\\n                    case \\'S\\':\\n                        Source = (r,c)\\n                    case \\'T\\':\\n                        Target = (r,c)\\n\\n                if(str[c-1] == \\'#\\'):\\n                    maze[r].append(\\'#\\')\\n                else:\\n                    maze[r].append(\\'.\\')\\n\\n            maze[r].append(\\'#\\')\\n\\n        maze.append(maze[0])\\n\\n        layer = 0\\n        layermap = [[0]*(C+2) for _ in range(R+2)]\\n        ways = [[1,0], [0,1], [-1,0], [0,-1]]\\n\\n        def reachable(source, target, layer):\\n            buffer = deque([source])\\n\\n            while buffer:\\n                pos = buffer.popleft()\\n\\n                if(pos == target):\\n                    return True\\n\\n                next = [(pos[0]-1, pos[1]), (pos[0], pos[1]-1), (pos[0]+1, pos[1]), (pos[0], pos[1]+1)]\\n\\n                for r, c in next:\\n                    if(maze[r][c] == \\'.\\' and layermap[r][c] != layer):\\n                        layermap[r][c] = layer\\n                        buffer.append((r,c))\\n                \\n            return False\\n\\n        maxstep = 400\\n        steped = [[[0]*4 for _ in range(C+2)] for _ in range(R+2)]\\n        buffer = deque([(Box, Source, 0)])\\n\\n        while buffer:\\n            box, source, step = buffer.popleft()\\n\\n            if(box == Target):\\n                maxstep = step\\n                break\\n            if(step > maxstep):\\n                break\\n\\n            new_boxes = [(box[0]+1, box[1]), (box[0], box[1]+1), (box[0]-1, box[1]), (box[0], box[1]-1)]\\n            new_sources = [(box[0]-1, box[1]), (box[0], box[1]-1), (box[0]+1, box[1]), (box[0], box[1]+1)]\\n            w = 0\\n\\n            for push_to, push_from in zip(new_boxes, new_sources):\\n                if(maze[push_to[0]][push_to[1]] == \\'.\\' and maze[push_from[0]][push_from[1]] == \\'.\\' and steped[push_to[0]][push_to[1]][w] == 0):\\n                    maze[box[0]][box[1]] = \\'#\\'\\n                    layer += 1\\n\\n                    if(reachable(source, push_from, layer)):\\n                        steped[push_to[0]][push_to[1]][w] = step+1\\n                        buffer.append((push_to, box, step+1))\\n\\n                    maze[box[0]][box[1]] = \\'.\\'\\n\\n                w += 1\\n\\n        if(maxstep == 400):\\n            return -1\\n        \\n        return maxstep\\n```\n```Java []\\nclass Solution {\\n        char[][] grid;\\n        int m, n;\\n        int[][] DIRS = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] reachable; \\n\\n        public int minPushBox(char[][] grid) {\\n            this.grid = grid;\\n            m = grid.length;\\n            n = grid[0].length;\\n            int step = 0;\\n            boolean[][][] visited = new boolean[m][n][4];\\n            reachable = new boolean[m][n];\\n\\n            Deque<int[]> boxQ = new LinkedList<>();\\n            Deque<int[]> playerQ = new LinkedList<>();\\n            int[] targetLoc = new int[2];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (grid[i][j] == \\'B\\') boxQ.offer(new int[]{i, j});\\n                    if (grid[i][j] == \\'T\\') targetLoc = new int[]{i, j};\\n                    if (grid[i][j] == \\'S\\') playerQ.offer(new int[]{i, j});\\n                }\\n            }\\n            while (!boxQ.isEmpty()) {\\n                int size = boxQ.size();\\n                while (size-- > 0) {\\n                    int[] boxLoc = boxQ.poll();\\n                    int[] playerLoc = playerQ.poll();\\n                    if (boxLoc[0] == targetLoc[0] && boxLoc[1] == targetLoc[1])\\n                        return step;\\n\\n                    for (int d = 0; d < 4; d++) {\\n                        if (visited[boxLoc[0]][boxLoc[1]][d]) continue;\\n                        int[] dir = DIRS[d];\\n                        int newPlayerR = boxLoc[0] - dir[0], newPlayerC = boxLoc[1] - dir[1];\\n                        if (newPlayerR < 0 || newPlayerR >= m || newPlayerC < 0 || newPlayerC >= n\\n                                || grid[newPlayerR][newPlayerC] == \\'#\\')\\n                            continue;\\n                        int newBoxR = boxLoc[0] + dir[0], newBoxC = boxLoc[1] + dir[1];\\n                        if (newBoxR < 0 || newBoxR >= m || newBoxC < 0 || newBoxC >= n\\n                                || grid[newBoxR][newBoxC] == \\'#\\')\\n                            continue;\\n                        if (!reachable(newPlayerR, newPlayerC, boxLoc, playerLoc))\\n                            continue;\\n\\n                        visited[boxLoc[0]][boxLoc[1]][d] = true;\\n                        boxQ.offer(new int[]{newBoxR, newBoxC});\\n                        playerQ.offer(new int[]{newPlayerR, newPlayerC});\\n                    }\\n                }\\n                step++;\\n            }\\n            return -1;\\n        }\\n        private boolean reachable(int targetR, int targetC, int[] boxLoc, int[] playerLoc) {\\n            if (reachable[targetR][targetC]){\\n                return true;\\n            }\\n            Deque<int[]> queue = new LinkedList<>();\\n            queue.offer(playerLoc);\\n            boolean[][] visited = new boolean[m][n];\\n            visited[boxLoc[0]][boxLoc[1]] = true;\\n\\n            while (!queue.isEmpty()) {\\n                int[] curr = queue.poll();\\n                if (curr[0] == targetR && curr[1] == targetC){\\n                    reachable[targetR][targetC] = true;\\n                    return true;\\n                }\\n                for (int[] d : DIRS) {\\n                    int r = curr[0] + d[0], c = curr[1] + d[1];\\n                    if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] == \\'#\\')\\n                        continue;\\n                    queue.offer(new int[]{r, c});\\n                    visited[r][c] = true;\\n                }\\n            }\\n            return false;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475308,
                "title": "simple-bfs",
                "content": "# Intuition\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(E + V)\\n\\n- Space complexity:\\nO(E + V)\\n\\n# Code\\n```\\nvar directions = [][]int{\\n    []int{-1, 0}, // 0 == up\\n    []int{1, 0},  // 1 == down\\n    []int{0, -1}, // 2 == left\\n    []int{0, 1},  // 3 == right\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    pi, pj, bi, bj, ti, tj := -1, -1, -1, -1, -1, -1\\n\\n    // find start/box/target\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'S\\' {\\n                pi = i\\n                pj = j\\n            } else if grid[i][j] == \\'B\\' {\\n                bi = i\\n                bj = j\\n            } else if grid[i][j] == \\'T\\' {\\n                ti = i\\n                tj = j\\n            }\\n\\n            if pi > -1 && bi > -1 && ti > -1 {\\n                break\\n            }\\n        }\\n\\n        if pi > -1 && bi > -1 && ti > -1 {\\n            break\\n        }\\n    }\\n\\n    q := [][]int{[]int{pi, pj, bi, bj, 0}}\\n    min := -1\\n    visited := map[string]bool{}\\n\\n    for len(q) > 0 {\\n        pi, pj, bi, bj, pushes := q[0][0], q[0][1], q[0][2], q[0][3], q[0][4]\\n        q = q[1:]\\n\\n        // person can\\'t be on wall or box\\n        if grid[pi][pj] == \\'#\\' || (pi == bi && pj == bj) {\\n            continue\\n        }\\n\\n        // if box is at target\\n        if bi == ti && bj == tj {\\n            if min == -1 || pushes < min {\\n                min = pushes\\n            }\\n\\n            continue\\n        }\\n\\n        key := fmt.Sprintf(\"%d+%d+%d+%d\", pi, pj, bi, bj)\\n\\n        if _, ok := visited[key]; ok {\\n            continue\\n        }\\n\\n        visited[key] = true\\n\\n        // if person is next to box\\n        if di := getDirection(pi, pj, bi, bj); di > -1 {\\n            if isValidMove(bi, bj, di, grid) {\\n                q = append(q, []int{\\n                    pi,\\n                    pj,\\n                    bi + directions[di][0],\\n                    bj + directions[di][1],\\n                    pushes + 1,\\n                })\\n            }\\n        }\\n\\n        for di, dir := range directions {\\n            if isValidMove(pi, pj, di, grid) {\\n                q = append(q, []int{pi + dir[0], pj + dir[1], bi, bj, pushes})\\n            }\\n        }\\n    }\\n\\n    return min\\n}\\n\\nfunc isValidMove(i int, j int, di int, grid [][]byte) bool {\\n    x := i + directions[di][0]\\n    y := j + directions[di][1]\\n\\n    return x > -1 && x < len(grid) && y > -1 && y < len(grid[x]) && grid[x][y] != \\'#\\'\\n}\\n\\nfunc getDirection(ai int, aj int, bi int, bj int) int {\\n    for di, dir := range directions {\\n        if ai + dir[0] == bi && aj + dir[1] == bj {\\n            return di\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar directions = [][]int{\\n    []int{-1, 0}, // 0 == up\\n    []int{1, 0},  // 1 == down\\n    []int{0, -1}, // 2 == left\\n    []int{0, 1},  // 3 == right\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    pi, pj, bi, bj, ti, tj := -1, -1, -1, -1, -1, -1\\n\\n    // find start/box/target\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'S\\' {\\n                pi = i\\n                pj = j\\n            } else if grid[i][j] == \\'B\\' {\\n                bi = i\\n                bj = j\\n            } else if grid[i][j] == \\'T\\' {\\n                ti = i\\n                tj = j\\n            }\\n\\n            if pi > -1 && bi > -1 && ti > -1 {\\n                break\\n            }\\n        }\\n\\n        if pi > -1 && bi > -1 && ti > -1 {\\n            break\\n        }\\n    }\\n\\n    q := [][]int{[]int{pi, pj, bi, bj, 0}}\\n    min := -1\\n    visited := map[string]bool{}\\n\\n    for len(q) > 0 {\\n        pi, pj, bi, bj, pushes := q[0][0], q[0][1], q[0][2], q[0][3], q[0][4]\\n        q = q[1:]\\n\\n        // person can\\'t be on wall or box\\n        if grid[pi][pj] == \\'#\\' || (pi == bi && pj == bj) {\\n            continue\\n        }\\n\\n        // if box is at target\\n        if bi == ti && bj == tj {\\n            if min == -1 || pushes < min {\\n                min = pushes\\n            }\\n\\n            continue\\n        }\\n\\n        key := fmt.Sprintf(\"%d+%d+%d+%d\", pi, pj, bi, bj)\\n\\n        if _, ok := visited[key]; ok {\\n            continue\\n        }\\n\\n        visited[key] = true\\n\\n        // if person is next to box\\n        if di := getDirection(pi, pj, bi, bj); di > -1 {\\n            if isValidMove(bi, bj, di, grid) {\\n                q = append(q, []int{\\n                    pi,\\n                    pj,\\n                    bi + directions[di][0],\\n                    bj + directions[di][1],\\n                    pushes + 1,\\n                })\\n            }\\n        }\\n\\n        for di, dir := range directions {\\n            if isValidMove(pi, pj, di, grid) {\\n                q = append(q, []int{pi + dir[0], pj + dir[1], bi, bj, pushes})\\n            }\\n        }\\n    }\\n\\n    return min\\n}\\n\\nfunc isValidMove(i int, j int, di int, grid [][]byte) bool {\\n    x := i + directions[di][0]\\n    y := j + directions[di][1]\\n\\n    return x > -1 && x < len(grid) && y > -1 && y < len(grid[x]) && grid[x][y] != \\'#\\'\\n}\\n\\nfunc getDirection(ai int, aj int, bi int, bj int) int {\\n    for di, dir := range directions {\\n        if ai + dir[0] == bi && aj + dir[1] == bj {\\n            return di\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472097,
                "title": "java-bfs",
                "content": "# class Solution {\\n    public int minPushBox(char[][] grid) {\\n        /*\\n        The problem asks for minimum moves - we have to BFS\\n        valid moves - \\n                     - space for man to stand - this should be in adjascent cell to box\\n                     - space in the opposite direction for the box to move.\\n                    - check if the person can be moved from his previous position to current location from where he is supposed to push the box - this can be checked using DFS(canManReach() in below code).\\n                    - if move is possible, move the box to adjascent cell, place the person in the earlier position of the box.\\n        */\\n        \\n        int[] box = null;\\n        int[] player = null;\\n        int[] target = null;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    box = new int[]{i, j};\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if(grid[i][j] == \\'S\\'){\\n                    player = new int[]{i, j};\\n                     grid[i][j] = \\'.\\';\\n                }\\n                if(grid[i][j] == \\'T\\'){\\n                    target = new int[]{i, j};\\n                     grid[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        \\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.addFirst(new int[]{box[0], box[1], player[0], player[1], 0});\\n        HashSet<String> set = new HashSet<>();\\n        \\n        //BFS\\n        while(queue.isEmpty() == false){\\n            int[] curr = queue.removeLast();\\n            //System.out.println(Arrays.toString(curr));\\n            \\n            if(curr[0] == target[0] && curr[1] == target[1]){\\n                return curr[4];\\n            }\\n            if(set.contains(curr[0]+\"/\"+curr[1]+\"/\"+curr[2]+\"/\"+curr[3])){\\n                continue;\\n            }\\n            set.add(curr[0]+\"/\"+curr[1]+\"/\"+curr[2]+\"/\"+curr[3]);\\n            //check if up movement is possible\\n            if(curr[0] < grid.length-1 && curr[0] > 0){\\n                if(grid[curr[0]+1][curr[1]] == \\'.\\' && canManReach(curr[2], curr[3], curr[0]+1, curr[1], grid, new boolean[grid.length][grid[0].length], curr[0], curr[1]) && grid[curr[0]-1][curr[1]] == \\'.\\'){\\n                    queue.addFirst(new int[]{curr[0]-1, curr[1], curr[0], curr[1], curr[4]+1});\\n                }\\n            }\\n            \\n            //check if down movement is possible\\n            if(curr[0] < grid.length-1 && curr[0] > 0){\\n                if(grid[curr[0]+1][curr[1]] == \\'.\\' && canManReach(curr[2], curr[3], curr[0]-1, curr[1], grid, new boolean[grid.length][grid[0].length], curr[0], curr[1]) && grid[curr[0]-1][curr[1]] == \\'.\\'){\\n                    queue.addFirst(new int[]{curr[0]+1, curr[1], curr[0], curr[1], curr[4]+1});\\n                }\\n            }\\n            \\n            //check if right movement is possible\\n            if(curr[1] < grid[0].length-1 && curr[1] > 0){\\n                if(grid[curr[0]][curr[1]+1] == \\'.\\' && canManReach(curr[2], curr[3], curr[0], curr[1]-1, grid, new boolean[grid.length][grid[0].length], curr[0], curr[1]) && grid[curr[0]][curr[1]-1] == \\'.\\'){\\n                    queue.addFirst(new int[]{curr[0], curr[1]+1, curr[0], curr[1], curr[4]+1});\\n                }\\n            }\\n            \\n            //check if left movement is possible\\n            if(curr[1] < grid[0].length-1 && curr[1] > 0){\\n                \\n                if(grid[curr[0]][curr[1]+1] == \\'.\\' && canManReach(curr[2], curr[3], curr[0], curr[1]+1, grid, new boolean[grid.length][grid[0].length], curr[0], curr[1]) && grid[curr[0]][curr[1]-1] == \\'.\\'){\\n                    //System.out.println(\"AAAAAAA\");\\n                    queue.addFirst(new int[]{curr[0], curr[1]-1, curr[0], curr[1], curr[4]+1});\\n                }\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean canManReach(int x, int y, int newX, int newY, char[][] grid, boolean[][] visited, int bx, int by){\\n        if(x<0 || x>grid.length-1 || y<0 || y>grid[0].length-1){\\n            return false;\\n        }\\n        if(grid[x][y] == \\'#\\'){\\n            return false;\\n        }\\n        if(x == bx && y == by){\\n            return false;\\n        }\\n        if(x == newX && y == newY){\\n            return true;\\n        }\\n        if(visited[x][y] == true){\\n            return false;\\n        }\\n        \\n        visited[x][y] = true;\\n        \\n        boolean left = canManReach(x, y-1, newX, newY, grid, visited, bx, by);\\n        boolean right = canManReach(x, y+1, newX, newY, grid, visited, bx, by);\\n        boolean up = canManReach(x-1, y, newX, newY, grid, visited, bx, by);\\n        boolean down = canManReach(x+1, y, newX, newY, grid, visited, bx, by);\\n        \\n        \\n        return left || right || up || down;\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int minPushBox(char[][] grid) {\\n        /*\\n        The problem asks for minimum moves - we have to BFS\\n        valid moves - \\n                     - space for man to stand - this should be in adjascent cell to box\\n                     - space in the opposite direction for the box to move.\\n                    - check if the person can be moved from his previous position to current location from where he is supposed to push the box - this can be checked using DFS(canManReach() in below code).\\n                    - if move is possible, move the box to adjascent cell, place the person in the earlier position of the box.\\n        */\\n        \\n        int[] box = null;\\n        int[] player = null;\\n        int[] target = null;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    box = new int[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 3471651,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        int bx, by, px, py ;\\n    };\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        int bx, by, px, py, tx, ty ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'B\\')\\n                    bx = i, by = j, grid[i][j] = \\'.\\' ;\\n                else if(grid[i][j] == \\'T\\')\\n                    tx = i, ty = j, grid[i][j] = \\'.\\' ;\\n                else if(grid[i][j] == \\'S\\')\\n                    px = i, py = j, grid[i][j] = \\'.\\' ;\\n            }\\n        }\\n        deque<Node>q{{bx, by, px, py}} ;\\n        int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n        auto memo = vector<vector<vector<vector<int>>>>(m, vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(n, -1)))) ;\\n        memo[bx][by][px][py] = 0 ;\\n        \\n        while(!q.empty()){\\n            auto [bx, by, px, py] = q.front() ;\\n            q.pop_front() ;\\n            if(bx == tx && by == ty)\\n                return memo[bx][by][px][py] ;\\n            for(int k = 0; k < 4; k++){\\n                int x = px + dirs[k][0] ;\\n                int y = py + dirs[k][1] ;\\n                if(x < 0 || x >= m  || y < 0 || y >= n)\\n                    continue ;\\n                if(grid[x][y] != \\'.\\')\\n                    continue ;\\n                if(x == bx && y == by)\\n                    continue ;\\n                if(memo[bx][by][x][y] >= 0)\\n                    continue ;\\n                memo[bx][by][x][y] = memo[bx][by][px][py] ;\\n                q.push_front({bx, by, x, y}) ;\\n            }\\n            if((abs(bx - px) + abs(by - py)) == 1){\\n                for(int k = 0; k < 4; k++){\\n                    if(px + dirs[k][0] == bx && py + dirs[k][1] == by){\\n                        int bx2 = bx + dirs[k][0] ;\\n                        int by2 = by + dirs[k][1] ;\\n                        if(bx2 < 0 || bx2 >= m || by2 < 0 || by2 >= n)\\n                            break ;\\n                        if(grid[bx2][by2] != \\'.\\')\\n                            break ;\\n                        if(memo[bx2][by2][bx][by] >= 0)\\n                            break ;\\n                        memo[bx2][by2][bx][by] = memo[bx][by][px][py] + 1 ;\\n                        q.push_back({bx2, by2, bx, by}) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        int bx, by, px, py ;\\n    };\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        int bx, by, px, py, tx, ty ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'B\\')\\n                    bx = i, by = j, grid[i][j] = \\'.\\' ;\\n                else if(grid[i][j] == \\'T\\')\\n                    tx = i, ty = j, grid[i][j] = \\'.\\' ;\\n                else if(grid[i][j] == \\'S\\')\\n                    px = i, py = j, grid[i][j] = \\'.\\' ;\\n            }\\n        }\\n        deque<Node>q{{bx, by, px, py}} ;\\n        int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n        auto memo = vector<vector<vector<vector<int>>>>(m, vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(n, -1)))) ;\\n        memo[bx][by][px][py] = 0 ;\\n        \\n        while(!q.empty()){\\n            auto [bx, by, px, py] = q.front() ;\\n            q.pop_front() ;\\n            if(bx == tx && by == ty)\\n                return memo[bx][by][px][py] ;\\n            for(int k = 0; k < 4; k++){\\n                int x = px + dirs[k][0] ;\\n                int y = py + dirs[k][1] ;\\n                if(x < 0 || x >= m  || y < 0 || y >= n)\\n                    continue ;\\n                if(grid[x][y] != \\'.\\')\\n                    continue ;\\n                if(x == bx && y == by)\\n                    continue ;\\n                if(memo[bx][by][x][y] >= 0)\\n                    continue ;\\n                memo[bx][by][x][y] = memo[bx][by][px][py] ;\\n                q.push_front({bx, by, x, y}) ;\\n            }\\n            if((abs(bx - px) + abs(by - py)) == 1){\\n                for(int k = 0; k < 4; k++){\\n                    if(px + dirs[k][0] == bx && py + dirs[k][1] == by){\\n                        int bx2 = bx + dirs[k][0] ;\\n                        int by2 = by + dirs[k][1] ;\\n                        if(bx2 < 0 || bx2 >= m || by2 < 0 || by2 >= n)\\n                            break ;\\n                        if(grid[bx2][by2] != \\'.\\')\\n                            break ;\\n                        if(memo[bx2][by2][bx][by] >= 0)\\n                            break ;\\n                        memo[bx2][by2][bx][by] = memo[bx][by][px][py] + 1 ;\\n                        q.push_back({bx2, by2, bx, by}) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466388,
                "title": "clean-fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n\\tdef minPushBox(self, grid: List[List[str]]) -> int:\\n\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tif grid[i][j]==\\'S\\':\\n\\t\\t\\t\\t\\tplayer=[i,j]\\n\\t\\t\\t\\telif grid[i][j]==\\'T\\':\\n\\t\\t\\t\\t\\ttarget=[i,j]\\n\\t\\t\\t\\telif grid[i][j]==\\'B\\':\\n\\t\\t\\t\\t\\tbox=[i,j]\\n\\t\\tq=deque([[player[0],player[1],box[0],box[1],0]])\\n\\t\\tvis=set([(player[0],player[1],box[0],box[1])])\\n\\t\\twhile q:\\n\\t\\t\\ti,j,bi,bj,steps=q.pop()\\n\\t\\t\\tif [bi,bj]==target:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:\\n\\t\\t\\t\\tx,y=i+dx,j+dy\\n\\t\\t\\t\\tif 0<=x<n and 0<=y<m and grid[x][y]!=\\'#\\':\\n\\t\\t\\t\\t\\tif (x,y)==(bi,bj):\\n\\t\\t\\t\\t\\t\\tif 0<=bi+dx<n and 0<=bj+dy<m and grid[bi+dx][bj+dy]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\t\\tif not (x,y,bi+dx,bj+dy) in vis:\\n\\t\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi+dx,bj+dy))\\n\\t\\t\\t\\t\\t\\t\\t\\tq.appendleft([x,y,bi+dx,bj+dy,steps+1])\\n\\t\\t\\t\\t\\telif (x,y,bi,bj) not in vis:\\n\\t\\t\\t\\t\\t\\tvis.add((x,y,bi,bj))\\n\\t\\t\\t\\t\\t\\tq.append([x,y,bi,bj,steps])\\n\\t\\treturn -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef minPushBox(self, grid: List[List[str]]) -> int:\\n\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tif grid[i][j]==\\'S\\':\\n\\t\\t\\t\\t\\tplayer=[i,j]\\n\\t\\t\\t\\telif grid[i][j]==\\'T\\':\\n\\t\\t\\t\\t\\ttarget=[i,j]\\n\\t\\t\\t\\telif grid[i][j]==\\'B\\':\\n\\t\\t\\t\\t\\tbox=[i,j]\\n\\t\\tq=deque([[player[0],player[1],box[0],box[1],0]])\\n\\t\\tvis=set([(player[0],player[1],box[0],box[1])])\\n\\t\\twhile q:\\n\\t\\t\\ti,j,bi,bj,steps=q.pop()\\n\\t\\t\\tif [bi,bj]==target:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:\\n\\t\\t\\t\\tx,y=i+dx,j+dy\\n\\t\\t\\t\\tif 0<=x<n and 0<=y<m and grid[x][y]!=\\'#\\':\\n\\t\\t\\t\\t\\tif (x,y)==(bi,bj):\\n\\t\\t\\t\\t\\t\\tif 0<=bi+dx<n and 0<=bj+dy<m and grid[bi+dx][bj+dy]!=\\'#\\':\\n\\t\\t\\t\\t\\t\\t\\tif not (x,y,bi+dx,bj+dy) in vis:\\n\\t\\t\\t\\t\\t\\t\\t\\tvis.add((x,y,bi+dx,bj+dy))\\n\\t\\t\\t\\t\\t\\t\\t\\tq.appendleft([x,y,bi+dx,bj+dy,steps+1])\\n\\t\\t\\t\\t\\telif (x,y,bi,bj) not in vis:\\n\\t\\t\\t\\t\\t\\tvis.add((x,y,bi,bj))\\n\\t\\t\\t\\t\\t\\tq.append([x,y,bi,bj,steps])\\n\\t\\treturn -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416543,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr char player = \\'S\\';\\n  static constexpr char wall = \\'#\\';\\n  static constexpr char target = \\'T\\';\\n  static constexpr char box = \\'B\\';\\n  static constexpr int n_positions = 3;   // initial player\\'s position, initial box\\'s position, target position\\n  using position_t = pair<int, int>;\\n  using positions_t = array<position_t, n_positions>;\\n  using q_node_t = tuple<int, int, int>;   // {the row, the col, the direction}\\n  \\n public:\\n  int minPushBox(const vector<vector<char>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    const auto [initial_player_position, initial_box_position, target_position] = get_positions(grid);\\n    queue<q_node_t> q;\\n    bool visited[rows][cols][n_directions];\\n    memset(visited, 0, sizeof(visited));\\n    for (int d = 0; d < n_directions; ++d) {\\n      const position_t player_destination = get_adjacent_position(initial_box_position, d, true);\\n      if (can_visit(grid, initial_box_position, player_destination) &&\\n          reachable(grid, initial_box_position, initial_player_position, player_destination)) {\\n        q.emplace(initial_box_position.first, initial_box_position.second, d);\\n        visited[initial_box_position.first][initial_box_position.second][d] = true;\\n        break;\\n      }\\n    }\\n    \\n    int step = 0;\\n    while (!q.empty()) {\\n      ++step;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [current_box_row, current_box_col, current_box_direction] = q.front();\\n        q.pop();\\n        const position_t current_box_position{current_box_row, current_box_col};\\n        const position_t current_player_position = get_adjacent_position(current_box_position,\\n                                                                         current_box_direction,\\n                                                                         true);\\n        for (int d = 0; d < n_directions; ++d) {\\n          const position_t next_box_position = get_adjacent_position(current_box_position, d, false);\\n          const position_t next_player_position = get_adjacent_position(current_box_position, d, true);\\n          if (!can_visit(grid, current_box_position, next_box_position) ||\\n              !can_visit(grid, current_box_position, next_player_position) ||\\n              visited[next_box_position.first][next_box_position.second][d] ||\\n              !reachable(grid, current_box_position, current_player_position, next_player_position)) {\\n            continue;\\n          }\\n          if (target_position == next_box_position) {\\n            return step;\\n          }\\n          q.emplace(next_box_position.first, next_box_position.second, d);\\n          visited[next_box_position.first][next_box_position.second][d] = true;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n private:\\n  positions_t get_positions(const vector<vector<char>> &grid) {\\n    constexpr char findings[] = {player, box, target};\\n    constexpr int n_findings = sizeof(findings) / sizeof(char);\\n    constexpr unsigned short full_mask = (1 << n_findings) - 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    unsigned short mask = 0U;\\n    positions_t ret;\\n    for (int r = 0; r < rows && mask != full_mask; ++r) {\\n      for (int c = 0; c < cols && mask != full_mask; ++c) {\\n        const char cell = grid[r][c];\\n        int index = static_cast<int>(find(findings, findings + n_findings, cell) - findings);\\n        if (index < n_findings) {\\n          ret[index] = make_pair(r, c);\\n          mask |= (1 << index);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n  position_t get_adjacent_position(const position_t &position,\\n                                   const int d,\\n                                   const bool reversed) {\\n    const int coefficient = reversed ? -1 : 1;\\n    return make_pair(position.first + coefficient * directions[d],\\n                     position.second + coefficient * directions[d + 1]);\\n  }\\n  \\n  bool reachable(const vector<vector<char>> &grid,\\n                 const position_t &box_position,\\n                 const position_t &source,\\n                 const position_t &target) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows * cols];\\n    memset(visited, 0, sizeof(visited));\\n    return dfs(grid, box_position, source, target, visited);\\n  }\\n  \\n  bool dfs(const vector<vector<char>> &grid,\\n           const position_t &box_position,\\n           const position_t &current,\\n           const position_t &target,\\n           bool *visited) {\\n    if (current == target) {\\n      return true;\\n    }\\n    \\n    const int cols = static_cast<int>(grid.front().size());\\n    visited[current.first * cols + current.second] = true;\\n    for (int d = 0; d < n_directions; ++d) {\\n      const position_t next = get_adjacent_position(current, d, false);\\n      if (can_visit(grid, box_position, next) &&\\n          !visited[next.first * cols + next.second] &&\\n          dfs(grid, box_position, next, target, visited)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  bool can_visit(const vector<vector<char>> &grid,\\n                 const position_t &box_position,\\n                 const position_t &current) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    return current.first >= 0 &&\\n      current.first < rows &&\\n      current.second >= 0 &&\\n      current.second < cols &&\\n      current != box_position &&\\n      grid[current.first][current.second] != wall;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr char player = \\'S\\';\\n  static constexpr char wall = \\'#\\';\\n  static constexpr char target = \\'T\\';\\n  static constexpr char box = \\'B\\';\\n  static constexpr int n_positions = 3;   // initial player\\'s position, initial box\\'s position, target position\\n  using position_t = pair<int, int>;\\n  using positions_t = array<position_t, n_positions>;\\n  using q_node_t = tuple<int, int, int>;   // {the row, the col, the direction}\\n  \\n public:\\n  int minPushBox(const vector<vector<char>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    const auto [initial_player_position, initial_box_position, target_position] = get_positions(grid);\\n    queue<q_node_t> q;\\n    bool visited[rows][cols][n_directions];\\n    memset(visited, 0, sizeof(visited));\\n    for (int d = 0; d < n_directions; ++d) {\\n      const position_t player_destination = get_adjacent_position(initial_box_position, d, true);\\n      if (can_visit(grid, initial_box_position, player_destination) &&\\n          reachable(grid, initial_box_position, initial_player_position, player_destination)) {\\n        q.emplace(initial_box_position.first, initial_box_position.second, d);\\n        visited[initial_box_position.first][initial_box_position.second][d] = true;\\n        break;\\n      }\\n    }\\n    \\n    int step = 0;\\n    while (!q.empty()) {\\n      ++step;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [current_box_row, current_box_col, current_box_direction] = q.front();\\n        q.pop();\\n        const position_t current_box_position{current_box_row, current_box_col};\\n        const position_t current_player_position = get_adjacent_position(current_box_position,\\n                                                                         current_box_direction,\\n                                                                         true);\\n        for (int d = 0; d < n_directions; ++d) {\\n          const position_t next_box_position = get_adjacent_position(current_box_position, d, false);\\n          const position_t next_player_position = get_adjacent_position(current_box_position, d, true);\\n          if (!can_visit(grid, current_box_position, next_box_position) ||\\n              !can_visit(grid, current_box_position, next_player_position) ||\\n              visited[next_box_position.first][next_box_position.second][d] ||\\n              !reachable(grid, current_box_position, current_player_position, next_player_position)) {\\n            continue;\\n          }\\n          if (target_position == next_box_position) {\\n            return step;\\n          }\\n          q.emplace(next_box_position.first, next_box_position.second, d);\\n          visited[next_box_position.first][next_box_position.second][d] = true;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n private:\\n  positions_t get_positions(const vector<vector<char>> &grid) {\\n    constexpr char findings[] = {player, box, target};\\n    constexpr int n_findings = sizeof(findings) / sizeof(char);\\n    constexpr unsigned short full_mask = (1 << n_findings) - 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    unsigned short mask = 0U;\\n    positions_t ret;\\n    for (int r = 0; r < rows && mask != full_mask; ++r) {\\n      for (int c = 0; c < cols && mask != full_mask; ++c) {\\n        const char cell = grid[r][c];\\n        int index = static_cast<int>(find(findings, findings + n_findings, cell) - findings);\\n        if (index < n_findings) {\\n          ret[index] = make_pair(r, c);\\n          mask |= (1 << index);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n  position_t get_adjacent_position(const position_t &position,\\n                                   const int d,\\n                                   const bool reversed) {\\n    const int coefficient = reversed ? -1 : 1;\\n    return make_pair(position.first + coefficient * directions[d],\\n                     position.second + coefficient * directions[d + 1]);\\n  }\\n  \\n  bool reachable(const vector<vector<char>> &grid,\\n                 const position_t &box_position,\\n                 const position_t &source,\\n                 const position_t &target) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows * cols];\\n    memset(visited, 0, sizeof(visited));\\n    return dfs(grid, box_position, source, target, visited);\\n  }\\n  \\n  bool dfs(const vector<vector<char>> &grid,\\n           const position_t &box_position,\\n           const position_t &current,\\n           const position_t &target,\\n           bool *visited) {\\n    if (current == target) {\\n      return true;\\n    }\\n    \\n    const int cols = static_cast<int>(grid.front().size());\\n    visited[current.first * cols + current.second] = true;\\n    for (int d = 0; d < n_directions; ++d) {\\n      const position_t next = get_adjacent_position(current, d, false);\\n      if (can_visit(grid, box_position, next) &&\\n          !visited[next.first * cols + next.second] &&\\n          dfs(grid, box_position, next, target, visited)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  bool can_visit(const vector<vector<char>> &grid,\\n                 const position_t &box_position,\\n                 const position_t &current) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    return current.first >= 0 &&\\n      current.first < rows &&\\n      current.second >= 0 &&\\n      current.second < cols &&\\n      current != box_position &&\\n      grid[current.first][current.second] != wall;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404942,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPushBox(self, grid):\\n        free  = set()\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"#\": continue\\n                if grid[i][j] == \"S\": sx,sy = i,j\\n                if grid[i][j] == \"B\": bx,by = i,j\\n                if grid[i][j] == \"T\": tx,ty = i,j\\n                free.add((i,j))\\n                \\n        stack, visited = [(0,sx,sy,bx,by)], {(sx,sy,bx,by)}\\n        \\n        while stack:\\n            t, si, sj, bi, bj = heappop(stack)\\n            \\n            if (bi,bj) == (tx,ty): return t\\n            \\n            for d in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                if (si+d[0],sj+d[1]) == (bi,bj) and (bi+d[0],bj+d[1]) in free and (si+d[0],sj+d[1],bi+d[0],bj+d[1]) not in visited:\\n                    visited.add((si+d[0],sj+d[1],bi+d[0],bj+d[1]))\\n                    heappush(stack,(t+1,si+d[0],sj+d[1],bi+d[0],bj+d[1]))\\n                elif (si+d[0],sj+d[1]) in free and (si+d[0],sj+d[1]) != (bi,bj) and (si+d[0],sj+d[1],bi,bj) not in visited:\\n                    visited.add((si+d[0],sj+d[1],bi,bj))\\n                    heappush(stack,(t,si+d[0],sj+d[1],bi,bj))\\n    \\n        return -1\\n                        \\n                        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n                \\n\\n                \\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid):\\n        free  = set()\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"#\": continue\\n                if grid[i][j] == \"S\": sx,sy = i,j\\n                if grid[i][j] == \"B\": bx,by = i,j\\n                if grid[i][j] == \"T\": tx,ty = i,j\\n                free.add((i,j))\\n                \\n        stack, visited = [(0,sx,sy,bx,by)], {(sx,sy,bx,by)}\\n        \\n        while stack:\\n            t, si, sj, bi, bj = heappop(stack)\\n            \\n            if (bi,bj) == (tx,ty): return t\\n            \\n            for d in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                if (si+d[0],sj+d[1]) == (bi,bj) and (bi+d[0],bj+d[1]) in free and (si+d[0],sj+d[1],bi+d[0],bj+d[1]) not in visited:\\n                    visited.add((si+d[0],sj+d[1],bi+d[0],bj+d[1]))\\n                    heappush(stack,(t+1,si+d[0],sj+d[1],bi+d[0],bj+d[1]))\\n                elif (si+d[0],sj+d[1]) in free and (si+d[0],sj+d[1]) != (bi,bj) and (si+d[0],sj+d[1],bi,bj) not in visited:\\n                    visited.add((si+d[0],sj+d[1],bi,bj))\\n                    heappush(stack,(t,si+d[0],sj+d[1],bi,bj))\\n    \\n        return -1\\n                        \\n                        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n                \\n\\n                \\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379847,
                "title": "standard-bfs-approach-solution-clean-code-bfs-bfs",
                "content": "# Intuition\\nwe use BFS to find minimum distance \\n\\n# Approach\\nBFS * BFS\\n# Complexity\\n- Time complexity:\\n$$O(n^2 * m^2)$$ \\n\\n- Space complexity:\\n $$O(n^2 * m^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dx[4]={0,0,1,-1};\\nint dy[4]={1,-1,0,0};\\nint m,n;\\n\\nbool check(int x,int y,vector<vector<char>>& grid ){\\nreturn (x>=0 && x<m ) && (y>=0 && y<n) && (grid[x][y]!=\\'#\\');\\n}\\n\\n\\nbool possible(int px,int py,int npx,int npy,int bx,int by,vector<vector<char>>& grid){\\n    queue<vector<int>>q;\\n     vector<vector<bool>>vis(m,vector<bool>(n,false));\\n     vis[px][py]=true;\\n    q.push({px,py});\\n    while(!q.empty()){\\n        auto it=q.front();\\n        q.pop();\\n        if(it[0]==npx && it[1]==npy){\\n            return true;\\n        }\\n        for(int i=0;i<4;i++){\\n            int x=it[0]+dx[i],y=it[1]+dy[i];\\n            if(check(x,y,grid) && !(x==bx && y==by) && vis[x][y]==false){\\n                vis[x][y]=true;\\n                q.push({x,y});\\n            }\\n        }\\n        \\n    }\\n    return false;\\n\\n}\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m=grid.size(),n=grid[0].size();\\n        int bx,by,tx,ty,px,py;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'T\\'){\\n                    tx=i;\\n                    ty=j;\\n                }\\n                 if(grid[i][j]==\\'B\\'){\\n                    bx=i ;\\n                    by=j;\\n                } \\n                if(grid[i][j]==\\'S\\'){\\n                    px=i;\\n                    py=j;\\n                }\\n            }\\n        }\\n\\n       \\n    int seen[20][20][20][20]={0};\\n        queue<vector<int>>q;\\n        q.push({bx,by,px,py});\\n         seen[bx][by][px][py];\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto vec=q.front();\\n                q.pop();\\n                bx=vec[0],by=vec[1],px=vec[2],py=vec[3];\\n                if(bx==tx && by==ty)\\n                return ans;\\n                for(int i=0;i<4;i++){\\n                    int nbx=bx+dx[i],nby=by+dy[i],npx=bx-dx[i],npy=by-dy[i];\\n                    if(check(nbx,nby,grid) && possible(px,py,npx,npy,bx,by,grid) && seen[nbx][nby][bx][by]==0){\\n                                seen[nbx][nby][bx][by]=1;\\n                                q.push({nbx,nby,bx,by});\\n                    }  \\n                }\\n            }\\n            ans++;\\n\\n        }\\n    return -1;   \\n    } \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dx[4]={0,0,1,-1};\\nint dy[4]={1,-1,0,0};\\nint m,n;\\n\\nbool check(int x,int y,vector<vector<char>>& grid ){\\nreturn (x>=0 && x<m ) && (y>=0 && y<n) && (grid[x][y]!=\\'#\\');\\n}\\n\\n\\nbool possible(int px,int py,int npx,int npy,int bx,int by,vector<vector<char>>& grid){\\n    queue<vector<int>>q;\\n     vector<vector<bool>>vis(m,vector<bool>(n,false));\\n     vis[px][py]=true;\\n    q.push({px,py});\\n    while(!q.empty()){\\n        auto it=q.front();\\n        q.pop();\\n        if(it[0]==npx && it[1]==npy){\\n            return true;\\n        }\\n        for(int i=0;i<4;i++){\\n            int x=it[0]+dx[i],y=it[1]+dy[i];\\n            if(check(x,y,grid) && !(x==bx && y==by) && vis[x][y]==false){\\n                vis[x][y]=true;\\n                q.push({x,y});\\n            }\\n        }\\n        \\n    }\\n    return false;\\n\\n}\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m=grid.size(),n=grid[0].size();\\n        int bx,by,tx,ty,px,py;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'T\\'){\\n                    tx=i;\\n                    ty=j;\\n                }\\n                 if(grid[i][j]==\\'B\\'){\\n                    bx=i ;\\n                    by=j;\\n                } \\n                if(grid[i][j]==\\'S\\'){\\n                    px=i;\\n                    py=j;\\n                }\\n            }\\n        }\\n\\n       \\n    int seen[20][20][20][20]={0};\\n        queue<vector<int>>q;\\n        q.push({bx,by,px,py});\\n         seen[bx][by][px][py];\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto vec=q.front();\\n                q.pop();\\n                bx=vec[0],by=vec[1],px=vec[2],py=vec[3];\\n                if(bx==tx && by==ty)\\n                return ans;\\n                for(int i=0;i<4;i++){\\n                    int nbx=bx+dx[i],nby=by+dy[i],npx=bx-dx[i],npy=by-dy[i];\\n                    if(check(nbx,nby,grid) && possible(px,py,npx,npy,bx,by,grid) && seen[nbx][nby][bx][by]==0){\\n                                seen[nbx][nby][bx][by]=1;\\n                                q.push({nbx,nby,bx,by});\\n                    }  \\n                }\\n            }\\n            ans++;\\n\\n        }\\n    return -1;   \\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281215,
                "title": "a-star-with-tie-breaker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA* algorithm, which is esentially Dijkstra\\'s but with custom priority function for the priority queue that considers not only the accumulated cost associated with each vertex, but also an estimated cost of distance from the target vertex. The distance from target vertex is easy to calculate when working with m*x*n grids (just calculate manhattan distance), which is why I\\'m using A* here. The advantage of having this additional heuristic to assess priority is that it allows us to break ties between paths with the same number of pushes. A simple Dijkstra\\'s would always prioritize the path with the least number of pushes (since Dijkstra\\'s never considers distance to target), which would lead to suboptimal efficiency because paths where boxes do not exist would always be traversed first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn a typical shortest paths problem, \"state\" wouldn\\'t need to be considered because it would be trivial: it\\'s just whatever vertex is being considered. But in this problem, the addition of a person to the mix adds complexity to the state: it is the current location of the box plus the current location of the person. Target is always fixed. To accomodate this complexity I created a State class to keep track of box and person locations. The priority queue consists of State objects, and its comparator class was overriden with a custom comparator that first compares (distance of box to target) + (# of pushes), and breaks ties with the distance.\\n\\nThe decision at each step is this: if the neighbor is a box, \"push\" the box and if it lands on a valid space then add a new State to the priority queue consisting of the new locations of the person and box as well as the increased number of pushes. If the neighbor is an empty space, then add a new State to the priority queue with just the newly updated location of the person.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(E)$$ where E is the number of edges.\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(m*n)$$ due to the priority queue\\n\\n# Code\\n```\\nclass Solution {\\n    class minMoves {\\n        private char[][] grid;\\n        private int n;\\n        private int m;\\n        private int[] t;\\n        private int[] s;\\n        private int[] b;\\n        private int[][] dists;\\n        private Set<String> states;\\n        private PriorityQueue<State> pq;\\n\\n        public minMoves(char[][] grid) {\\n            this.grid = grid;\\n            this.n = grid.length;\\n            this.m = grid[0].length;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    if (grid[i][j] == \\'T\\') { this.t = new int[] {i,j}; }\\n                    else if (grid[i][j] == \\'B\\') { this.b = new int[] {i,j}; }\\n                    else if (grid[i][j] == \\'S\\') { this.s = new int[] {i,j}; }\\n                }\\n            }\\n            this.dists = new int[][] { {0,-1}, {0, 1}, {1, 0}, {-1, 0} };\\n            this.states = new HashSet<>();\\n            this.pq = new PriorityQueue<>(m*n, new Comparator<State>() {\\n                @Override\\n                public int compare(State s1, State s2) {\\n                    return s1.compareTo(s2);\\n                }\\n            });\\n            State initState = new State(s[0], s[1], b[0], b[1], 0);\\n            pq.add(initState);\\n        }\\n\\n        public int leastNumPaths() {\\n            while (!pq.isEmpty()) {\\n                State curr = pq.poll();\\n                int pushes = curr.pushes, sx = curr.sx, sy = curr.sy, bx = curr.bx, by = curr.by;\\n                String state = \"(\" + sx + \",\" + sy + \")\" + \"|\" + \"(\" + bx + \",\" + by + \")\";\\n                if (bx == t[0] && by == t[1]) { return pushes; }\\n                if (states.contains(state)) { continue; }\\n                states.add(state);\\n                State next;\\n                // get the neighbors\\n                for (int[] d : dists) {\\n                    int nx = sx + d[0], ny = sy + d[1];\\n                    if (!isValid(nx, ny)) { continue; }\\n                    if (nx == bx && ny == by) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if (!isValid(nbx, nby)) { continue; }\\n                        next = new State(nx, ny, nbx, nby, pushes + 1);\\n                    } else {\\n                        next = new State(nx, ny, bx, by, pushes);\\n                    }\\n                    pq.add(next);\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        public boolean isValid(int x, int y) {\\n            if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == \\'#\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        public int dist(int x, int y) {\\n            return Math.abs(x-t[0]) + Math.abs(y-t[1]);\\n        }\\n\\n        class State {\\n            private int sx;\\n            private int sy;\\n            private int bx;\\n            private int by;\\n            private int pushes;\\n            private State(int sx, int sy, int bx, int by, int pushes) {\\n                this.sx = sx;\\n                this.sy = sy;\\n                this.bx = bx;\\n                this.by = by;\\n                this.pushes = pushes;\\n            }\\n            public int compareTo(State s2) {\\n                int dist1 = dist(bx,by);\\n                int dist2 = dist(s2.bx, s2.by);\\n                int p1 = dist1 + pushes;\\n                int p2 = dist2 + s2.pushes;\\n                if (p1 != p2) { return p1 - p2; }\\n                else { return dist1 - dist2; }\\n            }\\n        }\\n    }\\n    public int minPushBox(char[][] grid) {\\n        minMoves mm = new minMoves(grid);\\n        return mm.leastNumPaths();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class minMoves {\\n        private char[][] grid;\\n        private int n;\\n        private int m;\\n        private int[] t;\\n        private int[] s;\\n        private int[] b;\\n        private int[][] dists;\\n        private Set<String> states;\\n        private PriorityQueue<State> pq;\\n\\n        public minMoves(char[][] grid) {\\n            this.grid = grid;\\n            this.n = grid.length;\\n            this.m = grid[0].length;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    if (grid[i][j] == \\'T\\') { this.t = new int[] {i,j}; }\\n                    else if (grid[i][j] == \\'B\\') { this.b = new int[] {i,j}; }\\n                    else if (grid[i][j] == \\'S\\') { this.s = new int[] {i,j}; }\\n                }\\n            }\\n            this.dists = new int[][] { {0,-1}, {0, 1}, {1, 0}, {-1, 0} };\\n            this.states = new HashSet<>();\\n            this.pq = new PriorityQueue<>(m*n, new Comparator<State>() {\\n                @Override\\n                public int compare(State s1, State s2) {\\n                    return s1.compareTo(s2);\\n                }\\n            });\\n            State initState = new State(s[0], s[1], b[0], b[1], 0);\\n            pq.add(initState);\\n        }\\n\\n        public int leastNumPaths() {\\n            while (!pq.isEmpty()) {\\n                State curr = pq.poll();\\n                int pushes = curr.pushes, sx = curr.sx, sy = curr.sy, bx = curr.bx, by = curr.by;\\n                String state = \"(\" + sx + \",\" + sy + \")\" + \"|\" + \"(\" + bx + \",\" + by + \")\";\\n                if (bx == t[0] && by == t[1]) { return pushes; }\\n                if (states.contains(state)) { continue; }\\n                states.add(state);\\n                State next;\\n                // get the neighbors\\n                for (int[] d : dists) {\\n                    int nx = sx + d[0], ny = sy + d[1];\\n                    if (!isValid(nx, ny)) { continue; }\\n                    if (nx == bx && ny == by) {\\n                        int nbx = bx + d[0], nby = by + d[1];\\n                        if (!isValid(nbx, nby)) { continue; }\\n                        next = new State(nx, ny, nbx, nby, pushes + 1);\\n                    } else {\\n                        next = new State(nx, ny, bx, by, pushes);\\n                    }\\n                    pq.add(next);\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        public boolean isValid(int x, int y) {\\n            if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == \\'#\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        public int dist(int x, int y) {\\n            return Math.abs(x-t[0]) + Math.abs(y-t[1]);\\n        }\\n\\n        class State {\\n            private int sx;\\n            private int sy;\\n            private int bx;\\n            private int by;\\n            private int pushes;\\n            private State(int sx, int sy, int bx, int by, int pushes) {\\n                this.sx = sx;\\n                this.sy = sy;\\n                this.bx = bx;\\n                this.by = by;\\n                this.pushes = pushes;\\n            }\\n            public int compareTo(State s2) {\\n                int dist1 = dist(bx,by);\\n                int dist2 = dist(s2.bx, s2.by);\\n                int p1 = dist1 + pushes;\\n                int p2 = dist2 + s2.pushes;\\n                if (p1 != p2) { return p1 - p2; }\\n                else { return dist1 - dist2; }\\n            }\\n        }\\n    }\\n    public int minPushBox(char[][] grid) {\\n        minMoves mm = new minMoves(grid);\\n        return mm.leastNumPaths();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154822,
                "title": "java-pre-process-the-connectivity",
                "content": "```\\nclass Solution {\\n    private static final char PLAYER = \\'S\\';\\n    private static final char EMPTY = \\'.\\';\\n    private static final char WALL = \\'#\\';\\n    private static final char BOX = \\'B\\';\\n    private static final char TARGET = \\'T\\';\\n    private int rowLen;\\n    private int colLen;\\n    private boolean[][][][][] canReach;\\n    private int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    \\n    public int minPushBox(char[][] grid) {\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int[] usefulCoordinates = getCoordinates(grid);    \\n        populateCanReach(grid);\\n        int bRow = usefulCoordinates[0];\\n        int bCol = usefulCoordinates[1];\\n        int pRow = usefulCoordinates[2];\\n        int pCol = usefulCoordinates[3];\\n        int tRow = usefulCoordinates[4];\\n        int tCol = usefulCoordinates[5];       \\n        if (bRow == tRow && bCol == tCol) return 0;\\n        Queue<int[]> que = new ArrayDeque<>();\\n        boolean[][][][] visited = new boolean[rowLen][colLen][rowLen][colLen];\\n        visited[bRow][bCol][pRow][pCol] = true;\\n        que.offer(new int[] {bRow, bCol, pRow, pCol});\\n        int step = 0;\\n\\n        while (!que.isEmpty()) {\\n            int size = que.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] cur = que.poll();\\n                int curBRow = cur[0];\\n                int curBCol = cur[1];                \\n                int curPRow = cur[2];\\n                int curPCol = cur[3];\\n                \\n                if (curBRow == tRow && curBCol == tCol) return step; \\n                \\n                for (int i = 0; i < DIRS.length; i++) {\\n                    int[] dir = DIRS[i];\\n                    int nextBRow = curBRow + dir[0];\\n                    int nextBCol = curBCol + dir[1];\\n                    int pushedDir = i % 2 == 0 ? i + 1 : i - 1;\\n                    int pushedRow = curBRow + DIRS[pushedDir][0];\\n                    int pushedCol = curBCol + DIRS[pushedDir][1];\\n                    if (!isValid(nextBRow, nextBCol) || grid[nextBRow][nextBCol] == WALL) continue;\\n                    if (!isValid(pushedRow, pushedCol) || grid[pushedRow][pushedCol] == WALL) continue;\\n                    if (!canReach[curBRow][curBCol][pushedDir][curPRow][curPCol]) continue; \\n                    if (visited[nextBRow][nextBCol][curBRow][curBCol]) continue;\\n                    visited[nextBRow][nextBCol][curBRow][curBCol] = true;\\n                    que.offer(new int[] {nextBRow, nextBCol, curBRow, curBCol});\\n                } \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void populateCanReach(char[][] grid) {\\n        canReach = new boolean[rowLen][colLen][4][rowLen][colLen];\\n        for (int row = 0; row < rowLen; row++) {\\n            for (int col = 0; col < colLen; col++) {\\n                if (grid[row][col] != EMPTY) continue;\\n                for (int i = 0; i < DIRS.length; i++) {\\n                    int nextRow = row + DIRS[i][0];\\n                    int nextCol = col + DIRS[i][1];\\n                    if (!isValid(nextRow, nextCol) || grid[nextRow][nextCol] != EMPTY) continue;\\n                    canReach[row][col][i][row][col] = true; \\n                    BFS(nextRow, nextCol, canReach[row][col][i], grid);\\n                    canReach[row][col][i][row][col] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void BFS(int row, int col, boolean[][] visited, char[][] grid) {\\n        Queue<int[]> que = new ArrayDeque<>();\\n        que.offer(new int[] {row, col});\\n        visited[row][col] = true;\\n        while (!que.isEmpty()) {\\n            int[] curPoint = que.poll();\\n            for (int[] dir : DIRS) {\\n                int nextRow = curPoint[0] + dir[0];\\n                int nextCol = curPoint[1] + dir[1];\\n                if (!isValid(nextRow, nextCol) || visited[nextRow][nextCol] || grid[nextRow][nextCol] == WALL) continue;\\n                visited[nextRow][nextCol] = true;\\n                que.offer(new int[] {nextRow, nextCol});\\n            }\\n        }\\n    }\\n    \\n    private int[] getCoordinates(char[][] grid) {\\n        int bRow = -1, bCol = -1;\\n        int pRow = -1, pCol = -1;\\n        int tRow = -1, tCol = -1;\\n        for (int row = 0; row < rowLen; row++) {\\n            for (int col = 0; col < colLen; col++) {\\n                if (grid[row][col] == PLAYER) {\\n                    pRow = row;\\n                    pCol = col;\\n                    grid[row][col] = EMPTY;\\n                }\\n                if (grid[row][col] == BOX) {\\n                    bRow = row;\\n                    bCol = col;\\n                    grid[row][col] = EMPTY;\\n                }\\n                if (grid[row][col] == TARGET) {\\n                    tRow = row;\\n                    tCol = col;\\n                    grid[row][col] = EMPTY;\\n                } \\n            }\\n        }   \\n        return new int[] {bRow, bCol, pRow, pCol, tRow, tCol};\\n    }\\n    \\n    private boolean isValid(int row, int col) {\\n        return row >= 0 && row < rowLen && col >= 0 && col < colLen;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final char PLAYER = \\'S\\';\\n    private static final char EMPTY = \\'.\\';\\n    private static final char WALL = \\'#\\';\\n    private static final char BOX = \\'B\\';\\n    private static final char TARGET = \\'T\\';\\n    private int rowLen;\\n    private int colLen;\\n    private boolean[][][][][] canReach;\\n    private int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    \\n    public int minPushBox(char[][] grid) {\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int[] usefulCoordinates = getCoordinates(grid);    \\n        populateCanReach(grid);\\n        int bRow = usefulCoordinates[0];\\n        int bCol = usefulCoordinates[1];\\n        int pRow = usefulCoordinates[2];\\n        int pCol = usefulCoordinates[3];\\n        int tRow = usefulCoordinates[4];\\n        int tCol = usefulCoordinates[5];       \\n        if (bRow == tRow && bCol == tCol) return 0;\\n        Queue<int[]> que = new ArrayDeque<>();\\n        boolean[][][][] visited = new boolean[rowLen][colLen][rowLen][colLen];\\n        visited[bRow][bCol][pRow][pCol] = true;\\n        que.offer(new int[] {bRow, bCol, pRow, pCol});\\n        int step = 0;\\n\\n        while (!que.isEmpty()) {\\n            int size = que.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] cur = que.poll();\\n                int curBRow = cur[0];\\n                int curBCol = cur[1];                \\n                int curPRow = cur[2];\\n                int curPCol = cur[3];\\n                \\n                if (curBRow == tRow && curBCol == tCol) return step; \\n                \\n                for (int i = 0; i < DIRS.length; i++) {\\n                    int[] dir = DIRS[i];\\n                    int nextBRow = curBRow + dir[0];\\n                    int nextBCol = curBCol + dir[1];\\n                    int pushedDir = i % 2 == 0 ? i + 1 : i - 1;\\n                    int pushedRow = curBRow + DIRS[pushedDir][0];\\n                    int pushedCol = curBCol + DIRS[pushedDir][1];\\n                    if (!isValid(nextBRow, nextBCol) || grid[nextBRow][nextBCol] == WALL) continue;\\n                    if (!isValid(pushedRow, pushedCol) || grid[pushedRow][pushedCol] == WALL) continue;\\n                    if (!canReach[curBRow][curBCol][pushedDir][curPRow][curPCol]) continue; \\n                    if (visited[nextBRow][nextBCol][curBRow][curBCol]) continue;\\n                    visited[nextBRow][nextBCol][curBRow][curBCol] = true;\\n                    que.offer(new int[] {nextBRow, nextBCol, curBRow, curBCol});\\n                } \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void populateCanReach(char[][] grid) {\\n        canReach = new boolean[rowLen][colLen][4][rowLen][colLen];\\n        for (int row = 0; row < rowLen; row++) {\\n            for (int col = 0; col < colLen; col++) {\\n                if (grid[row][col] != EMPTY) continue;\\n                for (int i = 0; i < DIRS.length; i++) {\\n                    int nextRow = row + DIRS[i][0];\\n                    int nextCol = col + DIRS[i][1];\\n                    if (!isValid(nextRow, nextCol) || grid[nextRow][nextCol] != EMPTY) continue;\\n                    canReach[row][col][i][row][col] = true; \\n                    BFS(nextRow, nextCol, canReach[row][col][i], grid);\\n                    canReach[row][col][i][row][col] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void BFS(int row, int col, boolean[][] visited, char[][] grid) {\\n        Queue<int[]> que = new ArrayDeque<>();\\n        que.offer(new int[] {row, col});\\n        visited[row][col] = true;\\n        while (!que.isEmpty()) {\\n            int[] curPoint = que.poll();\\n            for (int[] dir : DIRS) {\\n                int nextRow = curPoint[0] + dir[0];\\n                int nextCol = curPoint[1] + dir[1];\\n                if (!isValid(nextRow, nextCol) || visited[nextRow][nextCol] || grid[nextRow][nextCol] == WALL) continue;\\n                visited[nextRow][nextCol] = true;\\n                que.offer(new int[] {nextRow, nextCol});\\n            }\\n        }\\n    }\\n    \\n    private int[] getCoordinates(char[][] grid) {\\n        int bRow = -1, bCol = -1;\\n        int pRow = -1, pCol = -1;\\n        int tRow = -1, tCol = -1;\\n        for (int row = 0; row < rowLen; row++) {\\n            for (int col = 0; col < colLen; col++) {\\n                if (grid[row][col] == PLAYER) {\\n                    pRow = row;\\n                    pCol = col;\\n                    grid[row][col] = EMPTY;\\n                }\\n                if (grid[row][col] == BOX) {\\n                    bRow = row;\\n                    bCol = col;\\n                    grid[row][col] = EMPTY;\\n                }\\n                if (grid[row][col] == TARGET) {\\n                    tRow = row;\\n                    tCol = col;\\n                    grid[row][col] = EMPTY;\\n                } \\n            }\\n        }   \\n        return new int[] {bRow, bCol, pRow, pCol, tRow, tCol};\\n    }\\n    \\n    private boolean isValid(int row, int col) {\\n        return row >= 0 && row < rowLen && col >= 0 && col < colLen;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135405,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string stringigy(int x,int t,int a,int b){\\n        return to_string(x)+\"_\"+to_string(t)+\"_\"+\\n            to_string(a)+\"_\"+to_string(b);\\n    }\\n    bool check(vector<vector<char>>& nums,int ni,int nj,int i,int j,int x,int y){\\n        vector<vector<bool>> vis(nums.size(),vector<bool>(nums[0].size(),0));\\n        vis[i][j] = 1;\\n        queue<pair<int,int>> q; \\n        q.push({i,j});\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n            auto [i,j] = q.front(); q.pop();\\n            if(i==ni && j==nj) continue;\\n            if(i==x && j==y) return 1;\\n            if(i+1<nums.size() && !vis[i+1][j] && nums[i+1][j]!=\\'#\\' ){\\n                q.push({i+1,j}); vis[i+1][j] = 1;\\n            }\\n            if(i-1>=0 && !vis[i-1][j] && nums[i-1][j]!=\\'#\\' ){\\n                q.push({i-1,j}); vis[i-1][j] = 1;\\n            }\\n            if(j+1<nums[0].size() && !vis[i][j+1] && nums[i][j+1]!=\\'#\\' ){\\n                q.push({i,j+1}); vis[i][j+1] = 1;\\n            }\\n            if(j-1>=0 && !vis[i][j-1] && nums[i][j-1]!=\\'#\\' ){\\n                q.push({i,j-1}); vis[i][j-1] = 1;\\n            }}\\n        }\\n        return 0;\\n    }\\n    int minPushBox(vector<vector<char>>& nums) {\\n        int bi,bj,si,sj,ti,tj;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0;j<nums[0].size();++j){\\n                if(nums[i][j]==\\'B\\'){ bi = i,bj = j; }\\n                if(nums[i][j]==\\'S\\'){ si = i,sj = j; }\\n                if(nums[i][j]==\\'T\\'){ ti = i,tj = j; }\\n            }\\n        }\\n        unordered_map<string,int> mp;\\n        queue<vector<int>> q;\\n        q.push({bi,bj,si,sj});\\n        mp[stringigy(bi,bj,si,sj)]++;\\n        int n = nums.size(),m=nums[0].size(),l=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> temp = q.front(); q.pop();\\n                int i=temp[0],j=temp[1],si=temp[2],sj=temp[3];\\n                if(i==ti && j==tj) return l;\\n                if(j-1>=0 && nums[i][j-1]!=\\'#\\'){\\n                   if(j+1<m && nums[i][j+1]!=\\'#\\' && mp.find(stringigy(i,j-1,i,j))==mp.end() &&\\n                      check(nums,i,j,si,sj,i,j+1)){\\n                       q.push({i,j-1,i,j});\\n                       mp[stringigy(i,j-1,i,j)]++;\\n                   }\\n                }\\n                if(j+1<m && nums[i][j+1]!=\\'#\\'){\\n                    if(j-1>=0 && nums[i][j-1]!=\\'#\\' && mp.find(stringigy(i,j+1,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i,j-1)){\\n                        q.push({i,j+1,i,j});\\n                        mp[stringigy(i,j+1,i,j)]++;\\n                    }\\n                }\\n                if(i+1<n && nums[i+1][j]!=\\'#\\'){\\n                    if(i-1>=0 && nums[i-1][j]!=\\'#\\' && mp.find(stringigy(i+1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i-1,j)){\\n                        q.push({i+1,j,i,j});\\n                        mp[stringigy(i+1,j,i,j)]++;\\n                    }\\n                }\\n                if(i-1>=0 && nums[i-1][j]!=\\'#\\'){\\n                     if(i+1<n && nums[i+1][j]!=\\'#\\' && mp.find(stringigy(i-1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i+1,j)){\\n                         q.push({i-1,j,i,j});\\n                         mp[stringigy(i-1,j,i,j)]++;\\n                     }\\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string stringigy(int x,int t,int a,int b){\\n        return to_string(x)+\"_\"+to_string(t)+\"_\"+\\n            to_string(a)+\"_\"+to_string(b);\\n    }\\n    bool check(vector<vector<char>>& nums,int ni,int nj,int i,int j,int x,int y){\\n        vector<vector<bool>> vis(nums.size(),vector<bool>(nums[0].size(),0));\\n        vis[i][j] = 1;\\n        queue<pair<int,int>> q; \\n        q.push({i,j});\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n            auto [i,j] = q.front(); q.pop();\\n            if(i==ni && j==nj) continue;\\n            if(i==x && j==y) return 1;\\n            if(i+1<nums.size() && !vis[i+1][j] && nums[i+1][j]!=\\'#\\' ){\\n                q.push({i+1,j}); vis[i+1][j] = 1;\\n            }\\n            if(i-1>=0 && !vis[i-1][j] && nums[i-1][j]!=\\'#\\' ){\\n                q.push({i-1,j}); vis[i-1][j] = 1;\\n            }\\n            if(j+1<nums[0].size() && !vis[i][j+1] && nums[i][j+1]!=\\'#\\' ){\\n                q.push({i,j+1}); vis[i][j+1] = 1;\\n            }\\n            if(j-1>=0 && !vis[i][j-1] && nums[i][j-1]!=\\'#\\' ){\\n                q.push({i,j-1}); vis[i][j-1] = 1;\\n            }}\\n        }\\n        return 0;\\n    }\\n    int minPushBox(vector<vector<char>>& nums) {\\n        int bi,bj,si,sj,ti,tj;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0;j<nums[0].size();++j){\\n                if(nums[i][j]==\\'B\\'){ bi = i,bj = j; }\\n                if(nums[i][j]==\\'S\\'){ si = i,sj = j; }\\n                if(nums[i][j]==\\'T\\'){ ti = i,tj = j; }\\n            }\\n        }\\n        unordered_map<string,int> mp;\\n        queue<vector<int>> q;\\n        q.push({bi,bj,si,sj});\\n        mp[stringigy(bi,bj,si,sj)]++;\\n        int n = nums.size(),m=nums[0].size(),l=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> temp = q.front(); q.pop();\\n                int i=temp[0],j=temp[1],si=temp[2],sj=temp[3];\\n                if(i==ti && j==tj) return l;\\n                if(j-1>=0 && nums[i][j-1]!=\\'#\\'){\\n                   if(j+1<m && nums[i][j+1]!=\\'#\\' && mp.find(stringigy(i,j-1,i,j))==mp.end() &&\\n                      check(nums,i,j,si,sj,i,j+1)){\\n                       q.push({i,j-1,i,j});\\n                       mp[stringigy(i,j-1,i,j)]++;\\n                   }\\n                }\\n                if(j+1<m && nums[i][j+1]!=\\'#\\'){\\n                    if(j-1>=0 && nums[i][j-1]!=\\'#\\' && mp.find(stringigy(i,j+1,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i,j-1)){\\n                        q.push({i,j+1,i,j});\\n                        mp[stringigy(i,j+1,i,j)]++;\\n                    }\\n                }\\n                if(i+1<n && nums[i+1][j]!=\\'#\\'){\\n                    if(i-1>=0 && nums[i-1][j]!=\\'#\\' && mp.find(stringigy(i+1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i-1,j)){\\n                        q.push({i+1,j,i,j});\\n                        mp[stringigy(i+1,j,i,j)]++;\\n                    }\\n                }\\n                if(i-1>=0 && nums[i-1][j]!=\\'#\\'){\\n                     if(i+1<n && nums[i+1][j]!=\\'#\\' && mp.find(stringigy(i-1,j,i,j))==mp.end() &&\\n                       check(nums,i,j,si,sj,i+1,j)){\\n                         q.push({i-1,j,i,j});\\n                         mp[stringigy(i-1,j,i,j)]++;\\n                     }\\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094187,
                "title": "c-bfs-within-bfs-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n\\n    bool isReachable(vector<vector<char>> &grid, int x, int y, int tx, int ty) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        bool visited[n][m];\\n        memset(visited, false, sizeof(visited));\\n        queue<vector<int>> Q;\\n        Q.push({x, y});\\n        visited[x][y] = true;\\n        while(!Q.empty()) {\\n            vector<int> F = Q.front();\\n            if(F[0] == tx && F[1] == ty) {\\n                return true;\\n            }\\n            Q.pop();\\n            for(int i = 0; i < 4; i++) {\\n                int nx = F[0] + dx[i];\\n                int ny = F[1] + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= n || ny >= m) {\\n                    continue;\\n                }\\n                if(visited[nx][ny] || grid[nx][ny] == \\'#\\') {\\n                    continue;\\n                }\\n                visited[nx][ny] = true;\\n                Q.push({nx, ny});\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int sx, sy, bx, by, tx, ty;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    sx = i, sy = j;\\n                }\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i, by = j;\\n                }\\n                if(grid[i][j] == \\'T\\') {\\n                    tx = i, ty = j;\\n                }\\n            }\\n        }\\n        bool visited[n][m][n][m];\\n        memset(visited, false, sizeof(visited));\\n        queue<vector<int>> Q;\\n        Q.push({bx, by, sx, sy});\\n        visited[bx][by][sx][sy] = true;\\n        int level = 0;\\n        while(!Q.empty()) {\\n            int sz = Q.size();\\n            while(sz--) {\\n                vector<int> F = Q.front();\\n                Q.pop();\\n                bx = F[0], by = F[1], sx = F[2], sy = F[3];\\n                if(bx == tx && by == ty) {\\n                    return level;\\n                }\\n                grid[bx][by] = \\'#\\';    \\n                for(int i = 0; i < 4; i++) {\\n                    int nbx = bx + dx[i];\\n                    int nby = by + dy[i];\\n                    int nsx = bx - dx[i];\\n                    int nsy = by - dy[i];\\n                    \\n                    if(nbx < 0 || nbx >= n || nby < 0 || nby >= m || nsx < 0 || nsx >= n || nsy < 0 || nsy >= m) {\\n                        continue;\\n                    }\\n                    if(visited[nbx][nby][nsx][nsy] || grid[nbx][nby] == \\'#\\' || grid[nsx][nsy] == \\'#\\') {\\n                        continue;\\n                    }\\n                    if(isReachable(grid, sx, sy, nsx, nsy)) {\\n                        visited[nbx][nby][nsx][nsy] = true;\\n                        Q.push({nbx, nby, nsx, nsy});\\n                    }\\n                }\\n                grid[bx][by] = \\'.\\';\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n\\n    bool isReachable(vector<vector<char>> &grid, int x, int y, int tx, int ty) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        bool visited[n][m];\\n        memset(visited, false, sizeof(visited));\\n        queue<vector<int>> Q;\\n        Q.push({x, y});\\n        visited[x][y] = true;\\n        while(!Q.empty()) {\\n            vector<int> F = Q.front();\\n            if(F[0] == tx && F[1] == ty) {\\n                return true;\\n            }\\n            Q.pop();\\n            for(int i = 0; i < 4; i++) {\\n                int nx = F[0] + dx[i];\\n                int ny = F[1] + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= n || ny >= m) {\\n                    continue;\\n                }\\n                if(visited[nx][ny] || grid[nx][ny] == \\'#\\') {\\n                    continue;\\n                }\\n                visited[nx][ny] = true;\\n                Q.push({nx, ny});\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int sx, sy, bx, by, tx, ty;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    sx = i, sy = j;\\n                }\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i, by = j;\\n                }\\n                if(grid[i][j] == \\'T\\') {\\n                    tx = i, ty = j;\\n                }\\n            }\\n        }\\n        bool visited[n][m][n][m];\\n        memset(visited, false, sizeof(visited));\\n        queue<vector<int>> Q;\\n        Q.push({bx, by, sx, sy});\\n        visited[bx][by][sx][sy] = true;\\n        int level = 0;\\n        while(!Q.empty()) {\\n            int sz = Q.size();\\n            while(sz--) {\\n                vector<int> F = Q.front();\\n                Q.pop();\\n                bx = F[0], by = F[1], sx = F[2], sy = F[3];\\n                if(bx == tx && by == ty) {\\n                    return level;\\n                }\\n                grid[bx][by] = \\'#\\';    \\n                for(int i = 0; i < 4; i++) {\\n                    int nbx = bx + dx[i];\\n                    int nby = by + dy[i];\\n                    int nsx = bx - dx[i];\\n                    int nsy = by - dy[i];\\n                    \\n                    if(nbx < 0 || nbx >= n || nby < 0 || nby >= m || nsx < 0 || nsx >= n || nsy < 0 || nsy >= m) {\\n                        continue;\\n                    }\\n                    if(visited[nbx][nby][nsx][nsy] || grid[nbx][nby] == \\'#\\' || grid[nsx][nsy] == \\'#\\') {\\n                        continue;\\n                    }\\n                    if(isReachable(grid, sx, sy, nsx, nsy)) {\\n                        visited[nbx][nby][nsx][nsy] = true;\\n                        Q.push({nbx, nby, nsx, nsy});\\n                    }\\n                }\\n                grid[bx][by] = \\'.\\';\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051166,
                "title": "c-nested-bfs-o-n-4",
                "content": "# Intuition\\n\\nBFS seach from the box to the target, at each step, a possible push needs to satisfy the following condition:\\n\\n- for a direction `UP, DOWN, LEFT, RIGHT`, a valid push requires the opposite direction to be empty;\\n- the player can reach the empty grid on the opposite direction\\n\\nA box on the grid is marked as visited, only if all the pushable directions on that grid is visited.\\n\\n![push-box.excalidraw.png](https://assets.leetcode.com/users/images/daad9998-b93b-40a6-a87e-edb71fd2dd2b_1673717469.338137.png)\\n\\n\\n# Code\\n```c++\\n/* dx, dy, direction id */\\nstatic const tuple<int, int, int> dir[] = {\\n    {0, 1, 0}, {0, -1, 1}, {1, 0, 2}, {-1, 0, 3}\\n};\\n\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<char>>* _grid;\\n    vector<vector<bitset<4>>> visited;\\n    pair<int, int> S, T, B;\\n\\n    void build(vector<vector<char>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        _grid = &grid;\\n        visited.resize(m, vector<bitset<4>>(n, bitset<4>(0)));\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int x = grid[i][j];\\n                switch (x)\\n                {\\n                case \\'.\\' :\\n                case \\'#\\' : continue;\\n                case \\'S\\' : S = {i, j}; grid[i][j] = \\'.\\'; break;\\n                case \\'T\\' : T = {i, j}; grid[i][j] = \\'.\\'; break;\\n                case \\'B\\' : B = {i, j}; grid[i][j] = \\'.\\'; break;\\n                }\\n            }\\n        }\\n    }\\n\\n    void show(int bx, int by, int sx, int sy, int nums)\\n    {\\n        printf(\"------ push %d ------\\\\n\", nums);\\n\\n        vector<vector<char>>& grid = *_grid;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (i == bx && j == by) {printf(\"%2c\", \\'B\\');}\\n                else if (i == sx && j == sy) {printf(\"%2c\", \\'S\\');}\\n                else if (i == T.first && j == T.second) {printf(\"%2c\", \\'T\\');}\\n                else {printf(\"%2c\", grid[i][j]);}\\n            }\\n            printf(\"\\\\n\");\\n        }\\n        printf(\"------------\\\\n\");\\n    }\\n\\n    inline bool in_map(int x, int y)\\n    {\\n        return 0 <= x && x < m && 0 <= y && y < n;\\n    }\\n\\n    bool reach(int x, int y, int sx, int sy)\\n    {\\n        if (x == sx && y == sy) {return true;}\\n        vector<vector<char>> & grid = *_grid;\\n\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        q.push({x, y});\\n        while (!q.empty())\\n        {\\n            auto [cx, cy] = q.front();\\n            q.pop();\\n\\n            for (auto [dx, dy, _] : dir )\\n            {\\n                int nx = cx + dx, ny = cy + dy;\\n                if (in_map(nx, ny) && visited[nx][ny] == false && grid[nx][ny] == \\'.\\')\\n                {\\n                    if (nx == sx && ny == sy) {return true;}\\n                    visited[nx][ny] = true;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int push()\\n    {\\n        vector<vector<char>>& grid = *_grid;\\n\\n        queue<tuple<int, int, int, int, int>> q;\\n        q.push({B.first, B.second, S.first, S.second, 0});\\n\\n        auto [tx, ty] = T;\\n\\n        while (!q.empty())\\n        {\\n            auto [bx, by, x, y, nums] = q.front();\\n            q.pop();\\n\\n            // show(bx, by, x, y, nums);\\n\\n            if (bx == tx && by == ty)\\n            {\\n                return nums;\\n            }\\n\\n            grid[bx][by] = \\'B\\';\\n            for (auto [dx, dy, d_id] : dir)\\n            {\\n                int sx = bx + dx, sy = by + dy;\\n                int nx = bx - dx, ny = by - dy;\\n                if (in_map(nx, ny) && grid[nx][ny] == \\'.\\' && \\n                    in_map(sx, sy) && grid[sx][sy] == \\'.\\' && \\n                    reach(sx, sy, x, y) && !visited[nx][ny][d_id])\\n                {\\n                    visited[nx][ny][d_id] = 1;\\n                    q.push({nx, ny, sx, sy, nums + 1});\\n                }\\n            }\\n            grid[bx][by] = \\'.\\';\\n        }\\n        return -1;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        build(grid);\\n        int ans = push();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\n/* dx, dy, direction id */\\nstatic const tuple<int, int, int> dir[] = {\\n    {0, 1, 0}, {0, -1, 1}, {1, 0, 2}, {-1, 0, 3}\\n};\\n\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<char>>* _grid;\\n    vector<vector<bitset<4>>> visited;\\n    pair<int, int> S, T, B;\\n\\n    void build(vector<vector<char>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        _grid = &grid;\\n        visited.resize(m, vector<bitset<4>>(n, bitset<4>(0)));\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int x = grid[i][j];\\n                switch (x)\\n                {\\n                case \\'.\\' :\\n                case \\'#\\' : continue;\\n                case \\'S\\' : S = {i, j}; grid[i][j] = \\'.\\'; break;\\n                case \\'T\\' : T = {i, j}; grid[i][j] = \\'.\\'; break;\\n                case \\'B\\' : B = {i, j}; grid[i][j] = \\'.\\'; break;\\n                }\\n            }\\n        }\\n    }\\n\\n    void show(int bx, int by, int sx, int sy, int nums)\\n    {\\n        printf(\"------ push %d ------\\\\n\", nums);\\n\\n        vector<vector<char>>& grid = *_grid;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (i == bx && j == by) {printf(\"%2c\", \\'B\\');}\\n                else if (i == sx && j == sy) {printf(\"%2c\", \\'S\\');}\\n                else if (i == T.first && j == T.second) {printf(\"%2c\", \\'T\\');}\\n                else {printf(\"%2c\", grid[i][j]);}\\n            }\\n            printf(\"\\\\n\");\\n        }\\n        printf(\"------------\\\\n\");\\n    }\\n\\n    inline bool in_map(int x, int y)\\n    {\\n        return 0 <= x && x < m && 0 <= y && y < n;\\n    }\\n\\n    bool reach(int x, int y, int sx, int sy)\\n    {\\n        if (x == sx && y == sy) {return true;}\\n        vector<vector<char>> & grid = *_grid;\\n\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        q.push({x, y});\\n        while (!q.empty())\\n        {\\n            auto [cx, cy] = q.front();\\n            q.pop();\\n\\n            for (auto [dx, dy, _] : dir )\\n            {\\n                int nx = cx + dx, ny = cy + dy;\\n                if (in_map(nx, ny) && visited[nx][ny] == false && grid[nx][ny] == \\'.\\')\\n                {\\n                    if (nx == sx && ny == sy) {return true;}\\n                    visited[nx][ny] = true;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int push()\\n    {\\n        vector<vector<char>>& grid = *_grid;\\n\\n        queue<tuple<int, int, int, int, int>> q;\\n        q.push({B.first, B.second, S.first, S.second, 0});\\n\\n        auto [tx, ty] = T;\\n\\n        while (!q.empty())\\n        {\\n            auto [bx, by, x, y, nums] = q.front();\\n            q.pop();\\n\\n            // show(bx, by, x, y, nums);\\n\\n            if (bx == tx && by == ty)\\n            {\\n                return nums;\\n            }\\n\\n            grid[bx][by] = \\'B\\';\\n            for (auto [dx, dy, d_id] : dir)\\n            {\\n                int sx = bx + dx, sy = by + dy;\\n                int nx = bx - dx, ny = by - dy;\\n                if (in_map(nx, ny) && grid[nx][ny] == \\'.\\' && \\n                    in_map(sx, sy) && grid[sx][sy] == \\'.\\' && \\n                    reach(sx, sy, x, y) && !visited[nx][ny][d_id])\\n                {\\n                    visited[nx][ny][d_id] = 1;\\n                    q.push({nx, ny, sx, sy, nums + 1});\\n                }\\n            }\\n            grid[bx][by] = \\'.\\';\\n        }\\n        return -1;\\n    }\\n\\n    int minPushBox(vector<vector<char>>& grid) {\\n        build(grid);\\n        int ans = push();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035078,
                "title": "golang-bfs-and-dfs-easy-to-understand",
                "content": "```go\\nfunc minPushBox(grid [][]byte) int {\\n  var queue [][4]int\\n  var pushes int\\n  var playerX, playerY int\\n  var targetX, targetY int\\n  var boxX, boxY int\\n  m, n := len(grid), len(grid[0])\\n  visited := make(map[[4]int]bool)\\n  for i := 0; i < len(grid); i++ {\\n    for j := 0; j < len(grid[i]); j++ {\\n      if grid[i][j] == \\'S\\' {\\n        playerX, playerY = i, j\\n      } else if grid[i][j] == \\'B\\' {\\n        boxX, boxY = i, j\\n      } else if grid[i][j] == \\'T\\' {\\n        targetX, targetY = i, j\\n      }\\n    }\\n  }\\n  // We\\'ve noted down these positions already. Let\\'s clear them so we can easily check\\n  // reachability for the player to move to the corresponding positions.\\n  grid[playerX][playerY] = \\'.\\'\\n  grid[boxX][boxY] = \\'.\\'\\n  grid[targetX][targetY] = \\'.\\'\\n  queue = append(queue, [4]int{playerX, playerY, boxX, boxY})\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} // top, left, bottom, right\\n  personDir := [4][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n  // We just don\\'t want to be in the same state again where the player and box are in the same position\\n  visited[[4]int{playerX,playerY,boxX,boxY}] = true\\n  for len(queue) > 0 {\\n    var newQueue [][4]int\\n    for _, state := range queue {\\n      playerX, playerY, boxX, boxY = state[0], state[1], state[2], state[3]\\n      if boxX == targetX && boxY == targetY {\\n        // If the box is currently in the target position, return the number\\n        // pushes we\\'ve done so far.\\n        return pushes\\n      }\\n      grid[boxX][boxY] = \\'B\\'\\n      for i := 0; i < len(directions); i++ {\\n        x1, y1 := boxX + directions[i][0], boxY + directions[i][1]\\n        if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && grid[x1][y1] == \\'.\\' {\\n          x2, y2 := boxX + personDir[i][0], boxY + personDir[i][1]\\n          if x2 >= 0 && x2 < m && y2 >= 0 && y2 < n && grid[x2][y2] == \\'.\\' && canReach(grid, playerX, playerY, x2, y2) {\\n            // the player is now in the previous position of the box\\n            if !visited[[4]int{boxX, boxY, x1, y1}] {\\n              visited[[4]int{boxX, boxY, x1, y1}] = true\\n              newQueue = append(newQueue, [4]int{boxX, boxY, x1, y1})\\n            }\\n          }\\n        }\\n      }\\n      grid[boxX][boxY] = \\'.\\'\\n    }\\n    pushes++\\n    queue = newQueue\\n  }\\n  return -1\\n}\\n\\n// canReach uses DFS to check if we can reach to the desired position from the current position\\n// using the current state of the grid where the box is placed in a cell which we can\\'t move through.\\nfunc canReach(grid [][]byte, currX, currY, desiredX, desiredY int) bool {\\n  if currX == desiredX && currY == desiredY {\\n    return true\\n  }\\n  m, n := len(grid), len(grid[0])\\n  visited := newVisited(m, n)\\n  visited[currX][currY] = true\\n  return dfs(grid, visited, currX, currY, desiredX, desiredY)\\n}\\n\\nfunc dfs(grid [][]byte, visited [][]bool, currX, currY, desiredX, desiredY int) bool {\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} // top, left, bottom, right\\n  m, n := len(grid), len(grid[0])\\n  if currX == desiredX && currY == desiredY {\\n    return true\\n  }\\n  for _, dir := range directions {\\n    x1, y1 := currX + dir[0], currY + dir[1]\\n    if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && grid[x1][y1] == \\'.\\' && !visited[x1][y1] {\\n      visited[x1][y1] = true\\n      if dfs(grid, visited, x1, y1, desiredX, desiredY) {\\n        return true\\n      }\\n    }\\n  }\\n  return false\\n}\\n\\nfunc newVisited(m, n int) [][]bool {\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  return visited\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```go\\nfunc minPushBox(grid [][]byte) int {\\n  var queue [][4]int\\n  var pushes int\\n  var playerX, playerY int\\n  var targetX, targetY int\\n  var boxX, boxY int\\n  m, n := len(grid), len(grid[0])\\n  visited := make(map[[4]int]bool)\\n  for i := 0; i < len(grid); i++ {\\n    for j := 0; j < len(grid[i]); j++ {\\n      if grid[i][j] == \\'S\\' {\\n        playerX, playerY = i, j\\n      } else if grid[i][j] == \\'B\\' {\\n        boxX, boxY = i, j\\n      } else if grid[i][j] == \\'T\\' {\\n        targetX, targetY = i, j\\n      }\\n    }\\n  }\\n  // We\\'ve noted down these positions already. Let\\'s clear them so we can easily check\\n  // reachability for the player to move to the corresponding positions.\\n  grid[playerX][playerY] = \\'.\\'\\n  grid[boxX][boxY] = \\'.\\'\\n  grid[targetX][targetY] = \\'.\\'\\n  queue = append(queue, [4]int{playerX, playerY, boxX, boxY})\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} // top, left, bottom, right\\n  personDir := [4][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n  // We just don\\'t want to be in the same state again where the player and box are in the same position\\n  visited[[4]int{playerX,playerY,boxX,boxY}] = true\\n  for len(queue) > 0 {\\n    var newQueue [][4]int\\n    for _, state := range queue {\\n      playerX, playerY, boxX, boxY = state[0], state[1], state[2], state[3]\\n      if boxX == targetX && boxY == targetY {\\n        // If the box is currently in the target position, return the number\\n        // pushes we\\'ve done so far.\\n        return pushes\\n      }\\n      grid[boxX][boxY] = \\'B\\'\\n      for i := 0; i < len(directions); i++ {\\n        x1, y1 := boxX + directions[i][0], boxY + directions[i][1]\\n        if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && grid[x1][y1] == \\'.\\' {\\n          x2, y2 := boxX + personDir[i][0], boxY + personDir[i][1]\\n          if x2 >= 0 && x2 < m && y2 >= 0 && y2 < n && grid[x2][y2] == \\'.\\' && canReach(grid, playerX, playerY, x2, y2) {\\n            // the player is now in the previous position of the box\\n            if !visited[[4]int{boxX, boxY, x1, y1}] {\\n              visited[[4]int{boxX, boxY, x1, y1}] = true\\n              newQueue = append(newQueue, [4]int{boxX, boxY, x1, y1})\\n            }\\n          }\\n        }\\n      }\\n      grid[boxX][boxY] = \\'.\\'\\n    }\\n    pushes++\\n    queue = newQueue\\n  }\\n  return -1\\n}\\n\\n// canReach uses DFS to check if we can reach to the desired position from the current position\\n// using the current state of the grid where the box is placed in a cell which we can\\'t move through.\\nfunc canReach(grid [][]byte, currX, currY, desiredX, desiredY int) bool {\\n  if currX == desiredX && currY == desiredY {\\n    return true\\n  }\\n  m, n := len(grid), len(grid[0])\\n  visited := newVisited(m, n)\\n  visited[currX][currY] = true\\n  return dfs(grid, visited, currX, currY, desiredX, desiredY)\\n}\\n\\nfunc dfs(grid [][]byte, visited [][]bool, currX, currY, desiredX, desiredY int) bool {\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} // top, left, bottom, right\\n  m, n := len(grid), len(grid[0])\\n  if currX == desiredX && currY == desiredY {\\n    return true\\n  }\\n  for _, dir := range directions {\\n    x1, y1 := currX + dir[0], currY + dir[1]\\n    if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && grid[x1][y1] == \\'.\\' && !visited[x1][y1] {\\n      visited[x1][y1] = true\\n      if dfs(grid, visited, x1, y1, desiredX, desiredY) {\\n        return true\\n      }\\n    }\\n  }\\n  return false\\n}\\n\\nfunc newVisited(m, n int) [][]bool {\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  return visited\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032779,
                "title": "java-dfs-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] directions = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    int[] start = new int[2];\\n    int[] player = new int[2];\\n    int[] target = new int[2];\\n\\n    public int minPushBox(char[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                } else if (grid[i][j] == \\'B\\') {\\n                    start[0] = i;\\n                    start[1] = j;\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                }\\n            }\\n        }\\n\\n        if (Arrays.equals(start, target)) return 0;\\n\\n        Deque<List<List<Integer>>> queue = new ArrayDeque<>();\\n        Set<List<List<Integer>>> visited = new HashSet<>();\\n        int step = 0;\\n\\n        char[][] updatedGrid = getCopiedGrid(grid, Arrays.asList(start[0], start[1]));\\n        dfs(player, updatedGrid);\\n        for (int i = 0; i < 4; i++) {\\n            int[] playerLoc = new int[]{start[0] + directions[i][0], start[1] + directions[i][1]};\\n           \\n            if (isAccessible(playerLoc, updatedGrid)) {\\n                List<List<Integer>> record = getRecord(start, playerLoc);\\n                queue.add(record);\\n                visited.add(record);\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                List<List<Integer>> current = queue.poll();\\n                List<Integer> curBox = current.get(0);\\n                updatedGrid = getCopiedGrid(grid, curBox);\\n                if (grid[curBox.get(0)][curBox.get(1)] == \\'T\\') {\\n                    return step;\\n                }\\n                List<Integer> curPlayer = current.get(1);\\n                dfs(new int[]{curPlayer.get(0), curPlayer.get(1)}, updatedGrid);\\n                for (int j = 0; j < 4; j++) {\\n                    List<Integer> nextBox = Arrays.asList(curBox.get(0) + directions[j][0], curBox.get(1) + directions[j][1]);\\n                    if (nextBox.get(0) < 0 || nextBox.get(0) >= grid.length || nextBox.get(1) < 0 || nextBox.get(1) >= grid[0].length || grid[nextBox.get(0)][nextBox.get(1)] == \\'#\\') {\\n                        continue;\\n                    }\\n\\n                    List<Integer> nextPlayer = Arrays.asList(curBox.get(0) - directions[j][0], curBox.get(1) - directions[j][1]);\\n\\n                    List<List<Integer>> nextRecord = new ArrayList<>();\\n                    nextRecord.add(nextBox);\\n                    nextRecord.add(curBox);\\n                    if (visited.contains(nextRecord)) continue;\\n\\n                    if (isAccessible(new int[]{nextPlayer.get(0), nextPlayer.get(1)}, updatedGrid)) {\\n                        queue.add(nextRecord);\\n                        visited.add(nextRecord);\\n                    }\\n                }\\n            }\\n            System.out.println(step);\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private char[][] getCopiedGrid(char[][] grid, List<Integer> curBox) {\\n        char[][] result = new char[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                result[i][j] = grid[i][j];\\n            }\\n        }\\n        result[start[0]][start[1]] = \\'.\\';\\n        result[player[0]][player[1]] = \\'.\\';\\n        result[target[0]][target[1]] = \\'.\\';\\n        result[curBox.get(0)][curBox.get(1)] = \\'B\\';\\n        return result;\\n    }\\n\\n    private List<List<Integer>> getRecord(int[] box, int[] playerLoc) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(Arrays.asList(box[0], box[1]));\\n        result.add(Arrays.asList(playerLoc[0], playerLoc[1]));\\n        return result;\\n    }\\n\\n    private boolean isAccessible(int[] end, char[][] grid) {\\n        if (end[0] < 0 || end[0] >= grid.length || end[1] < 0 || end[1] >= grid[0].length || grid[end[0]][end[1]] == \\'#\\') {\\n            return false;\\n        }\\n\\n        return grid[end[0]][end[1]] == \\'*\\';\\n    }\\n\\n    public void dfs(int[] current, char[][] grid) {\\n        if (current[0] < 0 || current[0] >= grid.length || current[1] < 0 || current[1] >= grid[0].length) {\\n            return;\\n        }\\n\\n        if (grid[current[0]][current[1]] == \\'*\\') {\\n            return;\\n        }\\n\\n        if (grid[current[0]][current[1]] == \\'#\\' || grid[current[0]][current[1]] == \\'B\\') {\\n            return;\\n        }\\n\\n        grid[current[0]][current[1]] = \\'*\\';\\n\\n        for (int i = 0; i < 4; i++) {\\n            int[] next = new int[]{ current[0] + directions[i][0], current[1] + directions[i][1] };\\n            dfs(next, grid);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    int[] start = new int[2];\\n    int[] player = new int[2];\\n    int[] target = new int[2];\\n\\n    public int minPushBox(char[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    player[0] = i;\\n                    player[1] = j;\\n                } else if (grid[i][j] == \\'B\\') {\\n                    start[0] = i;\\n                    start[1] = j;\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target[0] = i;\\n                    target[1] = j;\\n                }\\n            }\\n        }\\n\\n        if (Arrays.equals(start, target)) return 0;\\n\\n        Deque<List<List<Integer>>> queue = new ArrayDeque<>();\\n        Set<List<List<Integer>>> visited = new HashSet<>();\\n        int step = 0;\\n\\n        char[][] updatedGrid = getCopiedGrid(grid, Arrays.asList(start[0], start[1]));\\n        dfs(player, updatedGrid);\\n        for (int i = 0; i < 4; i++) {\\n            int[] playerLoc = new int[]{start[0] + directions[i][0], start[1] + directions[i][1]};\\n           \\n            if (isAccessible(playerLoc, updatedGrid)) {\\n                List<List<Integer>> record = getRecord(start, playerLoc);\\n                queue.add(record);\\n                visited.add(record);\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                List<List<Integer>> current = queue.poll();\\n                List<Integer> curBox = current.get(0);\\n                updatedGrid = getCopiedGrid(grid, curBox);\\n                if (grid[curBox.get(0)][curBox.get(1)] == \\'T\\') {\\n                    return step;\\n                }\\n                List<Integer> curPlayer = current.get(1);\\n                dfs(new int[]{curPlayer.get(0), curPlayer.get(1)}, updatedGrid);\\n                for (int j = 0; j < 4; j++) {\\n                    List<Integer> nextBox = Arrays.asList(curBox.get(0) + directions[j][0], curBox.get(1) + directions[j][1]);\\n                    if (nextBox.get(0) < 0 || nextBox.get(0) >= grid.length || nextBox.get(1) < 0 || nextBox.get(1) >= grid[0].length || grid[nextBox.get(0)][nextBox.get(1)] == \\'#\\') {\\n                        continue;\\n                    }\\n\\n                    List<Integer> nextPlayer = Arrays.asList(curBox.get(0) - directions[j][0], curBox.get(1) - directions[j][1]);\\n\\n                    List<List<Integer>> nextRecord = new ArrayList<>();\\n                    nextRecord.add(nextBox);\\n                    nextRecord.add(curBox);\\n                    if (visited.contains(nextRecord)) continue;\\n\\n                    if (isAccessible(new int[]{nextPlayer.get(0), nextPlayer.get(1)}, updatedGrid)) {\\n                        queue.add(nextRecord);\\n                        visited.add(nextRecord);\\n                    }\\n                }\\n            }\\n            System.out.println(step);\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private char[][] getCopiedGrid(char[][] grid, List<Integer> curBox) {\\n        char[][] result = new char[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                result[i][j] = grid[i][j];\\n            }\\n        }\\n        result[start[0]][start[1]] = \\'.\\';\\n        result[player[0]][player[1]] = \\'.\\';\\n        result[target[0]][target[1]] = \\'.\\';\\n        result[curBox.get(0)][curBox.get(1)] = \\'B\\';\\n        return result;\\n    }\\n\\n    private List<List<Integer>> getRecord(int[] box, int[] playerLoc) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(Arrays.asList(box[0], box[1]));\\n        result.add(Arrays.asList(playerLoc[0], playerLoc[1]));\\n        return result;\\n    }\\n\\n    private boolean isAccessible(int[] end, char[][] grid) {\\n        if (end[0] < 0 || end[0] >= grid.length || end[1] < 0 || end[1] >= grid[0].length || grid[end[0]][end[1]] == \\'#\\') {\\n            return false;\\n        }\\n\\n        return grid[end[0]][end[1]] == \\'*\\';\\n    }\\n\\n    public void dfs(int[] current, char[][] grid) {\\n        if (current[0] < 0 || current[0] >= grid.length || current[1] < 0 || current[1] >= grid[0].length) {\\n            return;\\n        }\\n\\n        if (grid[current[0]][current[1]] == \\'*\\') {\\n            return;\\n        }\\n\\n        if (grid[current[0]][current[1]] == \\'#\\' || grid[current[0]][current[1]] == \\'B\\') {\\n            return;\\n        }\\n\\n        grid[current[0]][current[1]] = \\'*\\';\\n\\n        for (int i = 0; i < 4; i++) {\\n            int[] next = new int[]{ current[0] + directions[i][0], current[1] + directions[i][1] };\\n            dfs(next, grid);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993965,
                "title": "2-bfs-easy-to-understand-c-code-with-proper-variable-names",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheckout the explaination from here (https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/solutions/693918/python-bfs-bfs-130ms-beats-95-explained-commented/)\\n\\nCredits: @zypher27\\n\\n# Complexity\\n- Time complexity: O((rows * columns)^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O((rows * columns)^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<vector<bool>>>> visited(grid.size(), vector<vector<vector<bool>>>(grid[0].size(), vector<vector<bool>>(grid.size(), vector<bool>(grid[0].size()))));\\n\\n        // find the coordinates of T, B and S\\n        pair<int,int> locationBox, locationT, locationP;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    locationBox = make_pair(i, j);\\n                }\\n                else if(grid[i][j] == \\'T\\'){\\n                    locationT = make_pair(i, j);\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    locationP = make_pair(i, j);\\n                }\\n            }\\n        }\\n\\n        int pushes = 0;\\n        queue<vector<int>> q;\\n        q.push({locationBox.first, locationBox.second, locationP.first, locationP.second});\\n        visited[locationBox.first][locationBox.second][locationP.first][locationP.second] = true;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto pos = q.front();\\n                q.pop();\\n\\n                int bx = pos[0], by = pos[1];\\n                if(bx == locationT.first && by == locationT.second){\\n                    return pushes;\\n                }\\n                \\n                int sx = pos[2], sy = pos[3];\\n                // new box position = (bx + 1, by), new man position = (bx - 1, by)\\n                // new box position = (bx - 1, by), new man position = (bx + 1, by)\\n                // new box position = (bx, by + 1), new man position = (bx, by - 1)\\n                // new box position = (bx, by - 1), new man position = (bx, by + 1)\\n                if(issafe(bx + 1, by, grid) && issafe(bx - 1, by, grid) && \\n                    !visited[bx + 1][by][bx - 1][by] && isReachable(bx - 1, by, sx, sy, bx, by, grid)){\\n                    visited[bx + 1][by][bx - 1][by] = true;\\n                    q.push({bx + 1, by, bx - 1, by});\\n                }\\n                if(issafe(bx - 1, by, grid) && issafe(bx + 1, by, grid) && \\n                    !visited[bx - 1][by][bx + 1][by] && isReachable(bx + 1, by, sx, sy, bx, by, grid)){\\n                    visited[bx - 1][by][bx + 1][by] = true;\\n                    q.push({bx - 1, by, bx + 1, by});\\n                }\\n                if(issafe(bx, by + 1, grid) && issafe(bx, by - 1, grid) && \\n                    !visited[bx][by + 1][bx][by - 1] && isReachable(bx, by - 1, sx, sy, bx, by, grid)){\\n                    visited[bx][by + 1][bx][by - 1] = true;\\n                    q.push({bx, by + 1, bx, by - 1});\\n                }\\n                if(issafe(bx, by - 1, grid) && issafe(bx, by + 1, grid) && \\n                    !visited[bx][by - 1][bx][by + 1] && isReachable(bx, by + 1, sx, sy, bx, by, grid)){\\n                        //cout<<\"hey \"<<bx<<\" \"<<by<<\" \";\\n                    visited[bx][by - 1][bx][by + 1] = true;\\n                    q.push({bx, by - 1, bx, by + 1});\\n                }\\n            }\\n            pushes++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool issafe(int i, int j, vector<vector<char>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        return i >= 0 && i < m && j >= 0 && j < n && grid[i][j] != \\'#\\';\\n    }\\n\\n    bool isReachable(int destx, int desty, int srcx, int srcy, int currbx, int currby, vector<vector<char>>& grid){\\n        queue<vector<int>> q;\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        q.push({srcx, srcy});\\n        visited[srcx][srcy] = true;\\n        while(!q.empty()){\\n            auto pos = q.front();\\n            q.pop();\\n            \\n            int x = pos[0], y = pos[1];\\n            if(x == destx && y == desty){\\n                return true;\\n            }\\n            \\n            // 1st condtion: we cannot walk through the box, so not adding that point to the queue\\n            // Rest are simple bfs conditions\\n            if(((x + 1) != currbx || y != currby) && issafe(x + 1, y, grid) && !visited[x + 1][y]){\\n                visited[x + 1][y] = true;\\n                q.push({x + 1, y});\\n            }\\n            if(((x - 1) != currbx || y != currby) && issafe(x - 1, y, grid) && !visited[x - 1][y]){\\n                visited[x - 1][y] = true;\\n                q.push({x - 1, y});\\n            }\\n            if(((x) != currbx || (y + 1) != currby) && issafe(x, y + 1, grid) && !visited[x][y + 1]){\\n                visited[x][y + 1] = true;\\n                q.push({x, y + 1});\\n            }\\n            if((x != currbx || (y - 1) != currby) && issafe(x, y - 1, grid) && !visited[x][y - 1]){\\n                visited[x][y - 1] = true;\\n                q.push({x, y - 1});\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<vector<bool>>>> visited(grid.size(), vector<vector<vector<bool>>>(grid[0].size(), vector<vector<bool>>(grid.size(), vector<bool>(grid[0].size()))));\\n\\n        // find the coordinates of T, B and S\\n        pair<int,int> locationBox, locationT, locationP;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == \\'B\\'){\\n                    locationBox = make_pair(i, j);\\n                }\\n                else if(grid[i][j] == \\'T\\'){\\n                    locationT = make_pair(i, j);\\n                }\\n                else if(grid[i][j] == \\'S\\'){\\n                    locationP = make_pair(i, j);\\n                }\\n            }\\n        }\\n\\n        int pushes = 0;\\n        queue<vector<int>> q;\\n        q.push({locationBox.first, locationBox.second, locationP.first, locationP.second});\\n        visited[locationBox.first][locationBox.second][locationP.first][locationP.second] = true;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto pos = q.front();\\n                q.pop();\\n\\n                int bx = pos[0], by = pos[1];\\n                if(bx == locationT.first && by == locationT.second){\\n                    return pushes;\\n                }\\n                \\n                int sx = pos[2], sy = pos[3];\\n                // new box position = (bx + 1, by), new man position = (bx - 1, by)\\n                // new box position = (bx - 1, by), new man position = (bx + 1, by)\\n                // new box position = (bx, by + 1), new man position = (bx, by - 1)\\n                // new box position = (bx, by - 1), new man position = (bx, by + 1)\\n                if(issafe(bx + 1, by, grid) && issafe(bx - 1, by, grid) && \\n                    !visited[bx + 1][by][bx - 1][by] && isReachable(bx - 1, by, sx, sy, bx, by, grid)){\\n                    visited[bx + 1][by][bx - 1][by] = true;\\n                    q.push({bx + 1, by, bx - 1, by});\\n                }\\n                if(issafe(bx - 1, by, grid) && issafe(bx + 1, by, grid) && \\n                    !visited[bx - 1][by][bx + 1][by] && isReachable(bx + 1, by, sx, sy, bx, by, grid)){\\n                    visited[bx - 1][by][bx + 1][by] = true;\\n                    q.push({bx - 1, by, bx + 1, by});\\n                }\\n                if(issafe(bx, by + 1, grid) && issafe(bx, by - 1, grid) && \\n                    !visited[bx][by + 1][bx][by - 1] && isReachable(bx, by - 1, sx, sy, bx, by, grid)){\\n                    visited[bx][by + 1][bx][by - 1] = true;\\n                    q.push({bx, by + 1, bx, by - 1});\\n                }\\n                if(issafe(bx, by - 1, grid) && issafe(bx, by + 1, grid) && \\n                    !visited[bx][by - 1][bx][by + 1] && isReachable(bx, by + 1, sx, sy, bx, by, grid)){\\n                        //cout<<\"hey \"<<bx<<\" \"<<by<<\" \";\\n                    visited[bx][by - 1][bx][by + 1] = true;\\n                    q.push({bx, by - 1, bx, by + 1});\\n                }\\n            }\\n            pushes++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool issafe(int i, int j, vector<vector<char>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        return i >= 0 && i < m && j >= 0 && j < n && grid[i][j] != \\'#\\';\\n    }\\n\\n    bool isReachable(int destx, int desty, int srcx, int srcy, int currbx, int currby, vector<vector<char>>& grid){\\n        queue<vector<int>> q;\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        q.push({srcx, srcy});\\n        visited[srcx][srcy] = true;\\n        while(!q.empty()){\\n            auto pos = q.front();\\n            q.pop();\\n            \\n            int x = pos[0], y = pos[1];\\n            if(x == destx && y == desty){\\n                return true;\\n            }\\n            \\n            // 1st condtion: we cannot walk through the box, so not adding that point to the queue\\n            // Rest are simple bfs conditions\\n            if(((x + 1) != currbx || y != currby) && issafe(x + 1, y, grid) && !visited[x + 1][y]){\\n                visited[x + 1][y] = true;\\n                q.push({x + 1, y});\\n            }\\n            if(((x - 1) != currbx || y != currby) && issafe(x - 1, y, grid) && !visited[x - 1][y]){\\n                visited[x - 1][y] = true;\\n                q.push({x - 1, y});\\n            }\\n            if(((x) != currbx || (y + 1) != currby) && issafe(x, y + 1, grid) && !visited[x][y + 1]){\\n                visited[x][y + 1] = true;\\n                q.push({x, y + 1});\\n            }\\n            if((x != currbx || (y - 1) != currby) && issafe(x, y - 1, grid) && !visited[x][y - 1]){\\n                visited[x][y - 1] = true;\\n                q.push({x, y - 1});\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2942002,
                "title": "python-simple-bfs-solution-faster-than-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check whether the box can be shifted to the new position(up, down, left, right)\\n2. For it to be shifted to the new position the person has to be in a corresponding position.\\n3. So, we check if the person can travel from his old position to his corresponding new position(using another BFS).\\n4. If the person can travel to his new position than the box can be shifted, otherwise the box cannot be shifted.\\n5. We repeat steps 1-4 until we reach the target or it is not possible to move the box anymore.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, grid: List[List[int]], numRows: int, numCols: int, row: int, col: int) -> bool:\\n        return 0 <= row < numRows and 0 <= col < numCols and grid[row][col] != \\'#\\'\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        numRows, numCols = len(grid), len(grid[0])\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == \"T\":\\n                    target = (row, col)\\n                if grid[row][col] == \"B\":\\n                    box = (row, col)\\n                if grid[row][col] == \"S\":\\n                    person = (row, col)\\n        \\n        def check(curr, dest, box):\\n            queue, visited = deque([curr]), set()\\n            while queue:\\n                pos = queue.popleft()\\n                if pos == dest: return True\\n                new_pos = [(pos[0] + 1, pos[1]), (pos[0] - 1, pos[1]), (pos[0], pos[1] + 1), (pos[0], pos[1] - 1)]\\n                for newRow, newCol in new_pos:\\n                    if self.checkValid(grid, numRows, numCols, newRow, newCol) and (newRow, newCol) not in visited and (newRow, newCol) != box:\\n                        visited.add((newRow, newCol))\\n                        queue.append((newRow, newCol))\\n            return False\\n         \\n        queue, visited = deque([(0, box, person)]), {box + person}\\n        while queue:\\n            dist, box, person = queue.popleft()\\n            if box == target:\\n                return dist\\n            boxCoord = [(box[0] + 1, box[1]), (box[0] - 1, box[1]), (box[0], box[1] + 1), (box[0], box[1] - 1)]\\n            personCoord = [(box[0] - 1, box[1]), (box[0] + 1, box[1]), (box[0], box[1] - 1), (box[0], box[1] + 1)]\\n            for newBoxCoord, newPersonCoord in zip(boxCoord, personCoord): \\n                if self.checkValid(grid, numRows, numCols, newBoxCoord[0], newBoxCoord[1]) and newBoxCoord + box not in visited:\\n                    if self.checkValid(grid, numRows, numCols, newPersonCoord[0], newPersonCoord[1]) and check(person, newPersonCoord, box):\\n                        visited.add(newBoxCoord + box)\\n                        queue.append((dist + 1, newBoxCoord, box))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, grid: List[List[int]], numRows: int, numCols: int, row: int, col: int) -> bool:\\n        return 0 <= row < numRows and 0 <= col < numCols and grid[row][col] != \\'#\\'\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        numRows, numCols = len(grid), len(grid[0])\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == \"T\":\\n                    target = (row, col)\\n                if grid[row][col] == \"B\":\\n                    box = (row, col)\\n                if grid[row][col] == \"S\":\\n                    person = (row, col)\\n        \\n        def check(curr, dest, box):\\n            queue, visited = deque([curr]), set()\\n            while queue:\\n                pos = queue.popleft()\\n                if pos == dest: return True\\n                new_pos = [(pos[0] + 1, pos[1]), (pos[0] - 1, pos[1]), (pos[0], pos[1] + 1), (pos[0], pos[1] - 1)]\\n                for newRow, newCol in new_pos:\\n                    if self.checkValid(grid, numRows, numCols, newRow, newCol) and (newRow, newCol) not in visited and (newRow, newCol) != box:\\n                        visited.add((newRow, newCol))\\n                        queue.append((newRow, newCol))\\n            return False\\n         \\n        queue, visited = deque([(0, box, person)]), {box + person}\\n        while queue:\\n            dist, box, person = queue.popleft()\\n            if box == target:\\n                return dist\\n            boxCoord = [(box[0] + 1, box[1]), (box[0] - 1, box[1]), (box[0], box[1] + 1), (box[0], box[1] - 1)]\\n            personCoord = [(box[0] - 1, box[1]), (box[0] + 1, box[1]), (box[0], box[1] - 1), (box[0], box[1] + 1)]\\n            for newBoxCoord, newPersonCoord in zip(boxCoord, personCoord): \\n                if self.checkValid(grid, numRows, numCols, newBoxCoord[0], newBoxCoord[1]) and newBoxCoord + box not in visited:\\n                    if self.checkValid(grid, numRows, numCols, newPersonCoord[0], newPersonCoord[1]) and check(person, newPersonCoord, box):\\n                        visited.add(newBoxCoord + box)\\n                        queue.append((dist + 1, newBoxCoord, box))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940281,
                "title": "python-bfs-ez-solution",
                "content": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        R, C = len(grid), len(grid[0])\\n        S, B, T = (0, 0), (0, 0), (0, 0)\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == \"T\":\\n                    T = (r, c)\\n                if grid[r][c] == \"B\":\\n                    B = (r, c)\\n                if grid[r][c] == \"S\":\\n                    S = (r, c)\\n                \\n        \\n        pq = [(0, S, B)]\\n        seen = set()\\n        \\n        while pq:\\n            steps, (cx, cy), (bx, by) = heappop(pq)\\n            steps = -steps\\n            \\n            if (cx, cy, bx, by) in seen:\\n                continue\\n            \\n            seen.add((cx, cy, bx, by))\\n            \\n            if (bx, by) == T:\\n                return steps\\n            \\n            for i, (dx, dy) in enumerate([(0, 1), (0, -1), (1, 0), (-1, 0)]): # ->, <- , V , ^\\n                nx = dx + cx\\n                ny = dy + cy\\n                \\n                \\n                if not( 0 <= nx < R and 0 <= ny < C ):\\n                    continue\\n                \\n                if grid[nx][ny] == \"#\": continue \\n                    \\n                \\n                if (nx, ny) == (bx, by):\\n                    # we are attached to box\\n                    # 1. try moving it if possible in opposite direction\\n                    nnx, nny = None, None\\n                    if i == 0: # box on my right\\n                        nnx = nx \\n                        nny = ny + 1\\n                    elif i == 1: # box on my left\\n                        nnx = nx \\n                        nny = ny - 1\\n                    elif i == 2: # box under me\\n                        nnx = nx + 1\\n                        nny = ny\\n                    else: # box above me\\n                        nnx = nx - 1\\n                        nny = ny\\n                    \\n                    if (0 <= nnx < R and 0 <= nny < C) and grid[nnx][nny] != \"#\":\\n                        # we can move \\n                        heappush(pq, (-(steps + 1), (nx, ny), (nnx, nny)))\\n                    \\n                    \\n                # 2. take all other dirctions urself without moving it\\n                    \\n                else:\\n                    # not near box\\n                    heappush(pq, (steps, (nx, ny), (bx, by)))\\n            \\n        \\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        R, C = len(grid), len(grid[0])\\n        S, B, T = (0, 0), (0, 0), (0, 0)\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == \"T\":\\n                    T = (r, c)\\n                if grid[r][c] == \"B\":\\n                    B = (r, c)\\n                if grid[r][c] == \"S\":\\n                    S = (r, c)\\n                \\n        \\n        pq = [(0, S, B)]\\n        seen = set()\\n        \\n        while pq:\\n            steps, (cx, cy), (bx, by) = heappop(pq)\\n            steps = -steps\\n            \\n            if (cx, cy, bx, by) in seen:\\n                continue\\n            \\n            seen.add((cx, cy, bx, by))\\n            \\n            if (bx, by) == T:\\n                return steps\\n            \\n            for i, (dx, dy) in enumerate([(0, 1), (0, -1), (1, 0), (-1, 0)]): # ->, <- , V , ^\\n                nx = dx + cx\\n                ny = dy + cy\\n                \\n                \\n                if not( 0 <= nx < R and 0 <= ny < C ):\\n                    continue\\n                \\n                if grid[nx][ny] == \"#\": continue \\n                    \\n                \\n                if (nx, ny) == (bx, by):\\n                    # we are attached to box\\n                    # 1. try moving it if possible in opposite direction\\n                    nnx, nny = None, None\\n                    if i == 0: # box on my right\\n                        nnx = nx \\n                        nny = ny + 1\\n                    elif i == 1: # box on my left\\n                        nnx = nx \\n                        nny = ny - 1\\n                    elif i == 2: # box under me\\n                        nnx = nx + 1\\n                        nny = ny\\n                    else: # box above me\\n                        nnx = nx - 1\\n                        nny = ny\\n                    \\n                    if (0 <= nnx < R and 0 <= nny < C) and grid[nnx][nny] != \"#\":\\n                        # we can move \\n                        heappush(pq, (-(steps + 1), (nx, ny), (nnx, nny)))\\n                    \\n                    \\n                # 2. take all other dirctions urself without moving it\\n                    \\n                else:\\n                    # not near box\\n                    heappush(pq, (steps, (nx, ny), (bx, by)))\\n            \\n        \\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934571,
                "title": "c-bfs",
                "content": "# Intuition\\nOuter BFS search for termination state, and inner BFS check if the player can move from current location to candidate location. Convert state to index by flatting the 4D array and use it as hashing key to store visited state.\\n\\n# Code\\n```\\nclass Solution {\\n    struct State{\\n        State() {}\\n        State(int br, int bc, int pr, int pc) : box_r(br), box_c(bc), p_r(pr), p_c(pc) {}\\n        int box_r, box_c;\\n        int p_r, p_c;\\n    };\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        const vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        State init_s;\\n        int t_r, t_c;\\n        for(int r = 0; r < m; ++r){\\n            for(int c = 0; c < n; ++c){\\n                if(grid[r][c] == \\'S\\') init_s.p_r = r, init_s.p_c = c;\\n                else if(grid[r][c] == \\'B\\') init_s.box_r = r, init_s.box_c = c;\\n                else if(grid[r][c] == \\'T\\') t_r = r, t_c = c;\\n            }\\n        }\\n        grid[init_s.box_r][init_s.box_c] = \\'.\\';\\n        grid[init_s.p_r][init_s.p_c] = \\'.\\';\\n        grid[t_r][t_c] = \\'.\\';\\n\\n        auto empty = [&](int r, int c, const State& s){\\n            return r >= 0 && r < m &&\\n                   c >= 0 && c < n && grid[r][c] == \\'.\\' &&\\n                   (r != s.box_r || c != s.box_c);};\\n        auto get_neighbors = [&](const State& s) -> vector<State>{\\n            unordered_map<int, State> candidates;\\n            for(const auto& dir : dirs){\\n                const int br = s.box_r + dir[0], bc = s.box_c + dir[1];\\n                const int pr = s.box_r - dir[0], pc = s.box_c - dir[1];\\n                if(empty(pr, pc, s) && empty(br, bc, s)){\\n                    candidates[pr * n + pc] = {br, bc, s.box_r, s.box_c};\\n                }\\n            }\\n\\n            vector<State> result;\\n            queue<pair<int, int>> player_q;\\n            player_q.push(make_pair(s.p_r, s.p_c));\\n            unordered_set<int> visited;\\n            visited.insert(s.p_r * n + s.p_c);\\n            while(!player_q.empty()){\\n                const auto p = player_q.front();\\n                player_q.pop();\\n                const int cell_idx = p.first * n + p.second;\\n                if(candidates.count(cell_idx) > 0){\\n                    result.push_back(candidates[cell_idx]);\\n                    if(result.size() == candidates.size()) break;\\n                }\\n                for(const auto& dir : dirs){\\n                    const int r = p.first + dir[0], c = p.second + dir[1];\\n                    if(empty(r, c, s) && visited.count(r * n + c) == 0){\\n                        player_q.push(make_pair(r, c));\\n                        visited.insert(r * n + c);\\n                    }\\n                }\\n            }\\n            return result;\\n        };\\n        auto s2idx = [&](const State& s){\\n            return  m * n *(s.box_r * n + s.box_c) + s.p_r * n + s.p_c;\\n        };\\n        queue<pair<State, int>> q;\\n        q.push(make_pair(init_s, 0));\\n        unordered_set<int> visited_s;\\n        visited_s.insert(s2idx(init_s));\\n        while(!q.empty()){\\n            const State s = q.front().first;\\n            const int pushes = q.front().second;\\n            q.pop();\\n            if(s.box_r == t_r && s.box_c == t_c) return pushes;\\n            for(const auto n : get_neighbors(s)){\\n                const int n_idx = s2idx(n);\\n                if(visited_s.count(n_idx) == 0)\\n                    q.push(make_pair(n, pushes + 1));\\n                    visited_s.insert(n_idx);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    struct State{\\n        State() {}\\n        State(int br, int bc, int pr, int pc) : box_r(br), box_c(bc), p_r(pr), p_c(pc) {}\\n        int box_r, box_c;\\n        int p_r, p_c;\\n    };\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        const vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        State init_s;\\n        int t_r, t_c;\\n        for(int r = 0; r < m; ++r){\\n            for(int c = 0; c < n; ++c){\\n                if(grid[r][c] == \\'S\\') init_s.p_r = r, init_s.p_c = c;\\n                else if(grid[r][c] == \\'B\\') init_s.box_r = r, init_s.box_c = c;\\n                else if(grid[r][c] == \\'T\\') t_r = r, t_c = c;\\n            }\\n        }\\n        grid[init_s.box_r][init_s.box_c] = \\'.\\';\\n        grid[init_s.p_r][init_s.p_c] = \\'.\\';\\n        grid[t_r][t_c] = \\'.\\';\\n\\n        auto empty = [&](int r, int c, const State& s){\\n            return r >= 0 && r < m &&\\n                   c >= 0 && c < n && grid[r][c] == \\'.\\' &&\\n                   (r != s.box_r || c != s.box_c);};\\n        auto get_neighbors = [&](const State& s) -> vector<State>{\\n            unordered_map<int, State> candidates;\\n            for(const auto& dir : dirs){\\n                const int br = s.box_r + dir[0], bc = s.box_c + dir[1];\\n                const int pr = s.box_r - dir[0], pc = s.box_c - dir[1];\\n                if(empty(pr, pc, s) && empty(br, bc, s)){\\n                    candidates[pr * n + pc] = {br, bc, s.box_r, s.box_c};\\n                }\\n            }\\n\\n            vector<State> result;\\n            queue<pair<int, int>> player_q;\\n            player_q.push(make_pair(s.p_r, s.p_c));\\n            unordered_set<int> visited;\\n            visited.insert(s.p_r * n + s.p_c);\\n            while(!player_q.empty()){\\n                const auto p = player_q.front();\\n                player_q.pop();\\n                const int cell_idx = p.first * n + p.second;\\n                if(candidates.count(cell_idx) > 0){\\n                    result.push_back(candidates[cell_idx]);\\n                    if(result.size() == candidates.size()) break;\\n                }\\n                for(const auto& dir : dirs){\\n                    const int r = p.first + dir[0], c = p.second + dir[1];\\n                    if(empty(r, c, s) && visited.count(r * n + c) == 0){\\n                        player_q.push(make_pair(r, c));\\n                        visited.insert(r * n + c);\\n                    }\\n                }\\n            }\\n            return result;\\n        };\\n        auto s2idx = [&](const State& s){\\n            return  m * n *(s.box_r * n + s.box_c) + s.p_r * n + s.p_c;\\n        };\\n        queue<pair<State, int>> q;\\n        q.push(make_pair(init_s, 0));\\n        unordered_set<int> visited_s;\\n        visited_s.insert(s2idx(init_s));\\n        while(!q.empty()){\\n            const State s = q.front().first;\\n            const int pushes = q.front().second;\\n            q.pop();\\n            if(s.box_r == t_r && s.box_c == t_c) return pushes;\\n            for(const auto n : get_neighbors(s)){\\n                const int n_idx = s2idx(n);\\n                if(visited_s.count(n_idx) == 0)\\n                    q.push(make_pair(n, pushes + 1));\\n                    visited_s.insert(n_idx);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921830,
                "title": "java-bfs-pair-class",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int [][]dir={{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int sx;\\n        int sy;\\n        int bx;\\n        int by;\\n        Pair(int sx,int sy,int bx,int by)\\n        {\\n            this.sx=sx;\\n            this.sy=sy;\\n            this.by=by;\\n            this.bx=bx;\\n        }\\n    }\\n    public int minPushBox(char[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int bx=0,by=0;\\n        int sx=0,sy=0;\\n        int tx=0,ty=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'B\\')\\n                {\\n                    bx=i;\\n                   by=j;\\n                }\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    sx=i;\\n                    sy=j;\\n                }\\n                if(grid[i][j]==\\'T\\'\\n                )\\n                {\\n                    tx=i;\\n                    ty=j;\\n                    \\n                }\\n\\n\\n\\n            }\\n        }\\n        Queue<Pair> dq=new ArrayDeque<>();\\n        int [][][][]vis=new int [m][n][m][n];\\n\\n\\n        for(int k=0;k<dir.length;k++)\\n        {\\n            int nx=bx+dir[k][0];\\n            int ny=by+dir[k][1];\\n            if(nx>=0&&nx<grid.length&&ny>=0&&ny<grid[0].length&&grid[nx][ny]!=\\'#\\')\\n            {\\n                boolean isPossible=possible(grid,sx,sy,nx,ny,bx,by,new int [m][n]);\\n              \\n              if(isPossible)\\n              {\\n\\n              \\n            \\n   dq.add(new Pair(nx,ny,bx,by));\\n                   vis[nx][ny][bx][by]=1;\\n\\n              }   \\n              \\n                 \\n\\n               \\n                \\n\\n            }\\n\\n        }\\n\\n        int steps=-1;\\n\\n        while(dq.size()!=0) {\\n\\n         \\n\\n            int size = dq.size();\\n              steps++;\\n            while (size-- > 0) {\\n              \\n                Pair rem = dq.remove();\\n                if(rem.bx==tx&&rem.by==ty)\\n                {\\n                    return steps;\\n                    \\n                }\\n                boolean f2=true;\\n\\n\\n                for (int k = 0; k < dir.length; k++) {\\n                    int nx = rem.sx + dir[k][0];\\n                    int ny = rem.sy + dir[k][1];\\n                    if (nx == rem.bx && ny == rem.by) {\\n                        rem.bx += dir[k][0];\\n                        rem.by += dir[k][1];\\n                        if(rem.bx<0||rem.bx>=m||rem.by<0||rem.by>=n||\\n                        grid[rem.bx][rem.by]==\\'#\\')\\n                        {\\n                            f2=false;\\n\\n\\n                        }\\n\\n\\n                        break;\\n\\n                    }\\n\\n                }\\n\\n                if(!f2)\\n                {\\n                    continue;\\n                }\\n\\n                for (int k = 0; k < dir.length; k++) {\\n                    int nx = rem.bx + dir[k][0];\\n                    int ny = rem.by + dir[k][1];\\n                    boolean f1 = possible(grid, rem.sx, rem.sy, nx, ny, rem.bx, rem.by, new int[m][n]);\\n                    if (f1 && vis[nx][ny][rem.bx][rem.by] != 1) {\\n                        vis[nx][ny][rem.bx][rem.by] = 1;\\n                        dq.add(new Pair(nx, ny, rem.bx, rem.by));\\n\\n\\n                    }\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        return -1;\\n\\n    }\\n\\n    public boolean possible(char[][]grid,int i,int j,int fx,int fy,int bx,int by,int [][]vis)\\n    {\\n        if(i<0||j<0||i>grid.length||j>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n         if(fx<0||fy<0||fx>grid.length||fy>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n         if(bx<0||by<0||bx>grid.length||by>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n        if(i==bx&&j==by)\\n        {\\n            return false;\\n        }\\n        vis[i][j]=1;\\n        if(i==fx&&j==fy)\\n        {\\n        \\n\\n            return true;\\n        }\\n        \\n\\n        for(int k=0;k<dir.length;k++)\\n        {\\n            int nx=i+dir[k][0];\\n            int ny= j+dir[k][1];\\n            if(nx>=0&&nx<grid.length&&ny>=0&&ny<grid[0].length&&grid[nx][ny]!=\\'#\\'&&vis[nx][ny]!=1)\\n            {\\n                boolean f1=possible(grid,nx,ny,fx,fy,bx,by,vis);\\n                if(f1)\\n                {\\n                    return true;\\n                }\\n\\n            }\\n\\n\\n        }\\n\\n        return false;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int [][]dir={{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int sx;\\n        int sy;\\n        int bx;\\n        int by;\\n        Pair(int sx,int sy,int bx,int by)\\n        {\\n            this.sx=sx;\\n            this.sy=sy;\\n            this.by=by;\\n            this.bx=bx;\\n        }\\n    }\\n    public int minPushBox(char[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int bx=0,by=0;\\n        int sx=0,sy=0;\\n        int tx=0,ty=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'B\\')\\n                {\\n                    bx=i;\\n                   by=j;\\n                }\\n                if(grid[i][j]==\\'S\\')\\n                {\\n                    sx=i;\\n                    sy=j;\\n                }\\n                if(grid[i][j]==\\'T\\'\\n                )\\n                {\\n                    tx=i;\\n                    ty=j;\\n                    \\n                }\\n\\n\\n\\n            }\\n        }\\n        Queue<Pair> dq=new ArrayDeque<>();\\n        int [][][][]vis=new int [m][n][m][n];\\n\\n\\n        for(int k=0;k<dir.length;k++)\\n        {\\n            int nx=bx+dir[k][0];\\n            int ny=by+dir[k][1];\\n            if(nx>=0&&nx<grid.length&&ny>=0&&ny<grid[0].length&&grid[nx][ny]!=\\'#\\')\\n            {\\n                boolean isPossible=possible(grid,sx,sy,nx,ny,bx,by,new int [m][n]);\\n              \\n              if(isPossible)\\n              {\\n\\n              \\n            \\n   dq.add(new Pair(nx,ny,bx,by));\\n                   vis[nx][ny][bx][by]=1;\\n\\n              }   \\n              \\n                 \\n\\n               \\n                \\n\\n            }\\n\\n        }\\n\\n        int steps=-1;\\n\\n        while(dq.size()!=0) {\\n\\n         \\n\\n            int size = dq.size();\\n              steps++;\\n            while (size-- > 0) {\\n              \\n                Pair rem = dq.remove();\\n                if(rem.bx==tx&&rem.by==ty)\\n                {\\n                    return steps;\\n                    \\n                }\\n                boolean f2=true;\\n\\n\\n                for (int k = 0; k < dir.length; k++) {\\n                    int nx = rem.sx + dir[k][0];\\n                    int ny = rem.sy + dir[k][1];\\n                    if (nx == rem.bx && ny == rem.by) {\\n                        rem.bx += dir[k][0];\\n                        rem.by += dir[k][1];\\n                        if(rem.bx<0||rem.bx>=m||rem.by<0||rem.by>=n||\\n                        grid[rem.bx][rem.by]==\\'#\\')\\n                        {\\n                            f2=false;\\n\\n\\n                        }\\n\\n\\n                        break;\\n\\n                    }\\n\\n                }\\n\\n                if(!f2)\\n                {\\n                    continue;\\n                }\\n\\n                for (int k = 0; k < dir.length; k++) {\\n                    int nx = rem.bx + dir[k][0];\\n                    int ny = rem.by + dir[k][1];\\n                    boolean f1 = possible(grid, rem.sx, rem.sy, nx, ny, rem.bx, rem.by, new int[m][n]);\\n                    if (f1 && vis[nx][ny][rem.bx][rem.by] != 1) {\\n                        vis[nx][ny][rem.bx][rem.by] = 1;\\n                        dq.add(new Pair(nx, ny, rem.bx, rem.by));\\n\\n\\n                    }\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        return -1;\\n\\n    }\\n\\n    public boolean possible(char[][]grid,int i,int j,int fx,int fy,int bx,int by,int [][]vis)\\n    {\\n        if(i<0||j<0||i>grid.length||j>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n         if(fx<0||fy<0||fx>grid.length||fy>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n         if(bx<0||by<0||bx>grid.length||by>grid[0].length)\\n        {\\n            return false;\\n        }\\n\\n        if(i==bx&&j==by)\\n        {\\n            return false;\\n        }\\n        vis[i][j]=1;\\n        if(i==fx&&j==fy)\\n        {\\n        \\n\\n            return true;\\n        }\\n        \\n\\n        for(int k=0;k<dir.length;k++)\\n        {\\n            int nx=i+dir[k][0];\\n            int ny= j+dir[k][1];\\n            if(nx>=0&&nx<grid.length&&ny>=0&&ny<grid[0].length&&grid[nx][ny]!=\\'#\\'&&vis[nx][ny]!=1)\\n            {\\n                boolean f1=possible(grid,nx,ny,fx,fy,bx,by,vis);\\n                if(f1)\\n                {\\n                    return true;\\n                }\\n\\n            }\\n\\n\\n        }\\n\\n        return false;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902317,
                "title": "bfs-inside-bfs",
                "content": "Code says everything.\\n\\n# Code\\n```\\n#include <array>\\n#include <iostream>\\n#include <queue>\\n#include <unordered_set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nnamespace std {\\ntemplate <>\\nstruct hash<array<int, 2>> {\\n  uint16_t operator()(const array<int, 2> &a) const { return a[0] << 8 | a[1]; }\\n};\\n\\ntemplate <>\\nstruct hash<array<int, 4>> {\\n  uint32_t operator()(const array<int, 4> &a) const {\\n    return a[0] << 24 | a[1] << 16 | a[2] << 8 | a[3];\\n  }\\n};\\n}  // namespace std\\n\\n/* Use a graph search (BFS) to find if our store-man can reach the cell just\\n * behind the box to push. This BFS routine is called inside another BFS to find\\n * the shortest moves required for the box to reach the target cell. There is\\n * just one nuance. The outer BFS, the one for the box, need to be adjusted to\\n * allow the box to visit a previously-visited cell but coming from a different\\n * direction. So the BFS state is a 5-tuple {curr_x, curr_y, prev_x, prev_y,\\n * moves}. The walls might force our store-man to push the box to a previously\\n * visited cell in order to go to a different side of the box. Other than that,\\n * this is mostly an implementation problem. We override the\\n * std::hash<std::array<int, N>> function object to use unordered_set<array<int,\\n * N>> to track visited cells by the store-man and the box.  Since we can visit\\n * each cell at most 4 times, and there are m*n cells, the time complexity is\\n * O(4mn * O(mn)) = O(4(mn)^2) time = 2.5e7 < 1e8 for m = n = 20. This solution\\n * won\\'t give us a TLE.\\n */\\nclass Solution {\\n public:\\n  int minPushBox(vector<vector<char>> &grid) {\\n    auto m = grid.size(), n = grid[0].size();\\n    int bx, by, sx, sy;\\n    for (auto i = 0; i < m; ++i)\\n      for (auto j = 0; j < n; ++j)\\n        if (grid[i][j] == \\'B\\')\\n          bx = i, by = j;\\n        else if (grid[i][j] == \\'S\\')\\n          sx = i, sy = j;\\n\\n    const int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    unordered_set<array<int, 2>> man_visited;\\n    auto updateManVisited = [&](const array<int, 2> sxy) {\\n      queue<array<int, 2>> sq;\\n      man_visited.clear();\\n      sq.push(sxy);\\n      man_visited.insert(sxy);\\n      while (!sq.empty()) {\\n        auto [sx, sy] = sq.front();\\n        sq.pop();\\n        for (auto [dx, dy] : dirs) {\\n          auto nsx = sx + dx;\\n          auto nsy = sy + dy;\\n          if (0 <= nsx && nsx < m && 0 <= nsy && nsy < n &&\\n              (grid[nsx][nsy] == \\'.\\' || grid[nsx][nsy] == \\'T\\') &&\\n              man_visited.find({nsx, nsy}) == man_visited.end()) {\\n            sq.push({nsx, nsy});\\n            man_visited.insert({nsx, nsy});\\n          }\\n        }\\n      }\\n    };\\n\\n    unordered_set<array<int, 4>> box_visited; /* x, y, sx, sy */\\n    queue<array<int, 5>> q;                   /* x, y, sx, sy, moves */\\n    q.push({bx, by, sx, sy, 0});\\n    grid[sx][sy] = \\'.\\';\\n    while (!q.empty()) {\\n      auto [bx, by, sx, sy, moves] = q.front();\\n      q.pop();\\n      if (grid[bx][by] == \\'T\\') return moves;\\n      grid[bx][by] = \\'B\\';\\n      updateManVisited({sx, sy});\\n      grid[bx][by] = \\'.\\';\\n      for (auto [dx, dy] : dirs) {\\n        auto nbx = bx + dx;\\n        auto nby = by + dy;\\n        auto nsx = bx - dx;\\n        auto nsy = by - dy;\\n        if (0 <= nbx && nbx < m && 0 <= nby && nby < n && 0 <= nsx && nsx < m &&\\n            0 <= nsy && nsy < n &&\\n            (grid[nbx][nby] == \\'.\\' || grid[nbx][nby] == \\'T\\') &&\\n            man_visited.find({nsx, nsy}) != man_visited.end() &&\\n            box_visited.find({nbx, nby, nsx, nsy}) == box_visited.end()) {\\n          q.push({nbx, nby, bx, by, moves + 1});\\n          box_visited.insert({nbx, nby, nsx, nsy});\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\nint main() {\\n  Solution s;\\n  vector<vector<char>> grid;\\n\\n  // clang-format off\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 3. */\\n\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'.\\', \\'.\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 5. */\\n\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* -1. */\\n\\n  grid = {{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'T\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'.\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'B\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'S\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 8. */\\n  // clang-format on\\n  return 0;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <array>\\n#include <iostream>\\n#include <queue>\\n#include <unordered_set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nnamespace std {\\ntemplate <>\\nstruct hash<array<int, 2>> {\\n  uint16_t operator()(const array<int, 2> &a) const { return a[0] << 8 | a[1]; }\\n};\\n\\ntemplate <>\\nstruct hash<array<int, 4>> {\\n  uint32_t operator()(const array<int, 4> &a) const {\\n    return a[0] << 24 | a[1] << 16 | a[2] << 8 | a[3];\\n  }\\n};\\n}  // namespace std\\n\\n/* Use a graph search (BFS) to find if our store-man can reach the cell just\\n * behind the box to push. This BFS routine is called inside another BFS to find\\n * the shortest moves required for the box to reach the target cell. There is\\n * just one nuance. The outer BFS, the one for the box, need to be adjusted to\\n * allow the box to visit a previously-visited cell but coming from a different\\n * direction. So the BFS state is a 5-tuple {curr_x, curr_y, prev_x, prev_y,\\n * moves}. The walls might force our store-man to push the box to a previously\\n * visited cell in order to go to a different side of the box. Other than that,\\n * this is mostly an implementation problem. We override the\\n * std::hash<std::array<int, N>> function object to use unordered_set<array<int,\\n * N>> to track visited cells by the store-man and the box.  Since we can visit\\n * each cell at most 4 times, and there are m*n cells, the time complexity is\\n * O(4mn * O(mn)) = O(4(mn)^2) time = 2.5e7 < 1e8 for m = n = 20. This solution\\n * won\\'t give us a TLE.\\n */\\nclass Solution {\\n public:\\n  int minPushBox(vector<vector<char>> &grid) {\\n    auto m = grid.size(), n = grid[0].size();\\n    int bx, by, sx, sy;\\n    for (auto i = 0; i < m; ++i)\\n      for (auto j = 0; j < n; ++j)\\n        if (grid[i][j] == \\'B\\')\\n          bx = i, by = j;\\n        else if (grid[i][j] == \\'S\\')\\n          sx = i, sy = j;\\n\\n    const int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    unordered_set<array<int, 2>> man_visited;\\n    auto updateManVisited = [&](const array<int, 2> sxy) {\\n      queue<array<int, 2>> sq;\\n      man_visited.clear();\\n      sq.push(sxy);\\n      man_visited.insert(sxy);\\n      while (!sq.empty()) {\\n        auto [sx, sy] = sq.front();\\n        sq.pop();\\n        for (auto [dx, dy] : dirs) {\\n          auto nsx = sx + dx;\\n          auto nsy = sy + dy;\\n          if (0 <= nsx && nsx < m && 0 <= nsy && nsy < n &&\\n              (grid[nsx][nsy] == \\'.\\' || grid[nsx][nsy] == \\'T\\') &&\\n              man_visited.find({nsx, nsy}) == man_visited.end()) {\\n            sq.push({nsx, nsy});\\n            man_visited.insert({nsx, nsy});\\n          }\\n        }\\n      }\\n    };\\n\\n    unordered_set<array<int, 4>> box_visited; /* x, y, sx, sy */\\n    queue<array<int, 5>> q;                   /* x, y, sx, sy, moves */\\n    q.push({bx, by, sx, sy, 0});\\n    grid[sx][sy] = \\'.\\';\\n    while (!q.empty()) {\\n      auto [bx, by, sx, sy, moves] = q.front();\\n      q.pop();\\n      if (grid[bx][by] == \\'T\\') return moves;\\n      grid[bx][by] = \\'B\\';\\n      updateManVisited({sx, sy});\\n      grid[bx][by] = \\'.\\';\\n      for (auto [dx, dy] : dirs) {\\n        auto nbx = bx + dx;\\n        auto nby = by + dy;\\n        auto nsx = bx - dx;\\n        auto nsy = by - dy;\\n        if (0 <= nbx && nbx < m && 0 <= nby && nby < n && 0 <= nsx && nsx < m &&\\n            0 <= nsy && nsy < n &&\\n            (grid[nbx][nby] == \\'.\\' || grid[nbx][nby] == \\'T\\') &&\\n            man_visited.find({nsx, nsy}) != man_visited.end() &&\\n            box_visited.find({nbx, nby, nsx, nsy}) == box_visited.end()) {\\n          q.push({nbx, nby, bx, by, moves + 1});\\n          box_visited.insert({nbx, nby, nsx, nsy});\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\nint main() {\\n  Solution s;\\n  vector<vector<char>> grid;\\n\\n  // clang-format off\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 3. */\\n\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'.\\', \\'.\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'#\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 5. */\\n\\n  grid = {{\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'T\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'B\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'.\\', \\'#\\'},\\n          {\\'#\\', \\'.\\', \\'.\\', \\'.\\', \\'S\\', \\'#\\'},\\n          {\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* -1. */\\n\\n  grid = {{\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'T\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'.\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'B\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'S\\',\\'#\\'},\\n          {\\'#\\',\\'.\\',\\'.\\',\\'#\\',\\'.\\',\\'#\\',\\'#\\',\\'#\\',\\'#\\'}};\\n  cout << s.minPushBox(grid) << endl; /* 8. */\\n  // clang-format on\\n  return 0;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2862973,
                "title": "python-bfs-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPushBox(self, grid) -> int:\\n        def gen_next(x, y):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                new_x = x + dx\\n                new_y = y + dy\\n                if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]):\\n                    yield new_x, new_y\\n\\n        def find_people_pos(x, y, box_pos):\\n            visited.add((x, y))\\n            for new_x, new_y in gen_next(x, y):\\n                if grid[new_x][new_y] == \".\" and (new_x, new_y) != box_pos and (new_x, new_y) not in visited:\\n                    find_people_pos(new_x, new_y, box_pos)\\n\\n        def compute_push_pos(new_box_pos, original_pos):\\n            return 2 * original_pos[0] - new_box_pos[0], 2 * original_pos[1] - new_box_pos[1]\\n\\n        q = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"T\":\\n                    target_pos = i, j\\n                    grid[i][j] = \".\"\\n                elif grid[i][j] == \"B\":\\n                    grid[i][j] = \".\"\\n                    box_pos = i, j\\n                elif grid[i][j] == \"S\":\\n                    people_pos = i, j\\n                    grid[i][j] = \".\"\\n        if box_pos == target_pos:\\n            return 0\\n\\n        q.append((box_pos, 0, people_pos))\\n        box_visited = set()\\n        while len(q) > 0:\\n            (x, y), cnt, people_pos = q.popleft()\\n            visited = set()\\n            find_people_pos(people_pos[0], people_pos[1], (x,y))\\n            for new_box_pos in gen_next(x, y):\\n                \\n                if (new_box_pos, (x,y)) in box_visited or grid[new_box_pos[0]][new_box_pos[1]] == \"#\":\\n                    continue\\n                push_pos = compute_push_pos(new_box_pos, (x, y))\\n                if push_pos in visited:\\n                    if new_box_pos == target_pos:\\n                        return cnt + 1\\n                    q.append((new_box_pos, cnt + 1, (x,y)))\\n                    box_visited.add((new_box_pos, (x, y)))\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid) -> int:\\n        def gen_next(x, y):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                new_x = x + dx\\n                new_y = y + dy\\n                if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]):\\n                    yield new_x, new_y\\n\\n        def find_people_pos(x, y, box_pos):\\n            visited.add((x, y))\\n            for new_x, new_y in gen_next(x, y):\\n                if grid[new_x][new_y] == \".\" and (new_x, new_y) != box_pos and (new_x, new_y) not in visited:\\n                    find_people_pos(new_x, new_y, box_pos)\\n\\n        def compute_push_pos(new_box_pos, original_pos):\\n            return 2 * original_pos[0] - new_box_pos[0], 2 * original_pos[1] - new_box_pos[1]\\n\\n        q = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"T\":\\n                    target_pos = i, j\\n                    grid[i][j] = \".\"\\n                elif grid[i][j] == \"B\":\\n                    grid[i][j] = \".\"\\n                    box_pos = i, j\\n                elif grid[i][j] == \"S\":\\n                    people_pos = i, j\\n                    grid[i][j] = \".\"\\n        if box_pos == target_pos:\\n            return 0\\n\\n        q.append((box_pos, 0, people_pos))\\n        box_visited = set()\\n        while len(q) > 0:\\n            (x, y), cnt, people_pos = q.popleft()\\n            visited = set()\\n            find_people_pos(people_pos[0], people_pos[1], (x,y))\\n            for new_box_pos in gen_next(x, y):\\n                \\n                if (new_box_pos, (x,y)) in box_visited or grid[new_box_pos[0]][new_box_pos[1]] == \"#\":\\n                    continue\\n                push_pos = compute_push_pos(new_box_pos, (x, y))\\n                if push_pos in visited:\\n                    if new_box_pos == target_pos:\\n                        return cnt + 1\\n                    q.append((new_box_pos, cnt + 1, (x,y)))\\n                    box_visited.add((new_box_pos, (x, y)))\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855081,
                "title": "simple-python-answer-beats-100-in-both-time-and-memory",
                "content": "PLEASE UPVOTE IF USEFUL\\n\\nState is (current box i, current box j, i next to box, j next to box)\\n\\ndef canReach checks if person can move to another location\\n\\n1. move person to locations next to box and add to queue\\n2. in each location, check if can push box\\n3. if can push box, push box\\n4. After that, check if you can move to other locations\\n5. continue until box reaches target\\n6. use a set seen to check if the state has been seen\\n\\n\\n```\\nclass Solution(object):\\n    def minPushBox(self, grid):\\n\\n        \\n        ball=None\\n        person=None\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"B\":\\n                    ball=[i,j]\\n                    grid[i][j]=\".\"\\n                elif grid[i][j]==\"S\":\\n                    person=[i,j]\\n                    grid[i][j]=\".\"\\n        \\n\\n        \\n        queue=[]\\n        seen=set()\\n        for i,j in [[ball[0],ball[1]-1],[ball[0],ball[1]+1],[ball[0]+1,ball[1]],[ball[0]-1,ball[1]]]:\\n            if -1<i<len(grid) and -1<j<len(grid[0]) and grid[i][j]!=\"#\" and canReach(person,[i,j],ball,[row[:] for row in grid]):\\n                queue.append(ball+[i,j])\\n                seen.add(tuple(ball+[i,j]))\\n                \\n\\n                \\n        pushes=0\\n        while queue:\\n            newQueue=[]\\n            pushes+=1\\n            for bi,bj,pi,pj in queue:\\n                \\n                \\n                newState=None\\n                if bi==pi:\\n                    if bj+1==pj:\\n                        if bj>0 and grid[bi][bj-1]!=\"#\":\\n                            newState=[bi,bj-1,pi,pj-1]      \\n                    else:\\n                        if bj<len(grid[0])-1 and grid[bi][bj+1]!=\"#\":\\n                            newState=[bi,bj+1,pi,pj+1]    \\n                            \\n                else:\\n                    if bi+1==pi:\\n                        if bi>0 and grid[bi-1][bj]!=\"#\":\\n                            newState=[bi-1,bj,pi-1,pj]             \\n                    else:\\n                        if bi<len(grid)-1 and grid[bi+1][bj]!=\"#\":\\n                            newState=[bi+1,bj,pi+1,pj]    \\n                            \\n                \\n                if newState:\\n\\n                    if grid[newState[0]][newState[1]]==\"T\":\\n                        return pushes\\n                    \\n                    if tuple(newState) not in seen:\\n                        seen.add(tuple(newState))\\n                        newQueue.append(newState)\\n                        \\n                    \\n                   \\n                        bi,bj=newState[0],newState[1]\\n                        for nextbi,nextbj in [(bi,bj-1),(bi,bj+1),(bi-1,bj),(bi+1,bj)]:\\n                            if (-1<nextbi<len(grid) and -1<nextbj<len(grid[0]) \\n                                and grid[nextbi][nextbj]==\".\" \\n                                and tuple([bi,bj,nextbi,nextbj]) not in seen\\n                                and canReach([pi,pj],[nextbi,nextbj],[bi,bj],[row[:] for row in grid])):\\n                                \\n                                \\n \\n                                newQueue.append([bi,bj,nextbi,nextbj])\\n                                seen.add(tuple([bi,bj,nextbi,nextbj]))\\n                        \\n                        \\n            queue=newQueue\\n            \\n\\n        return -1\\n                \\n                \\n            \\n            \\n            \\n            \\ndef canReach(person,target,ball,grid):\\n    \\n    if person==target:\\n        return True\\n\\n    queue=[person]\\n    grid[ball[0]][ball[1]]=\"#\"\\n    \\n    while queue:\\n        newQueue=[]\\n        \\n        for i,j in queue:\\n            for y,x in [(i,j-1),(i+1,j),(i-1,j),(i,j+1)]:\\n                if -1<y<len(grid) and -1<x<len(grid[0]) and grid[y][x]!=\"#\":\\n                    if [y,x]==target:\\n                        return True\\n                    grid[y][x]=\"#\"\\n                    newQueue.append([y,x])\\n                    \\n            queue=newQueue\\n        \\n    return False\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "PLEASE UPVOTE IF USEFUL\\n\\nState is (current box i, current box j, i next to box, j next to box)\\n\\ndef canReach checks if person can move to another location\\n\\n1. move person to locations next to box and add to queue\\n2. in each location, check if can push box\\n3. if can push box, push box\\n4. After that, check if you can move to other locations\\n5. continue until box reaches target\\n6. use a set seen to check if the state has been seen\\n\\n\\n```\\nclass Solution(object):\\n    def minPushBox(self, grid):\\n\\n        \\n        ball=None\\n        person=None\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"B\":\\n                    ball=[i,j]\\n                    grid[i][j]=\".\"\\n                elif grid[i][j]==\"S\":\\n                    person=[i,j]\\n                    grid[i][j]=\".\"\\n        \\n\\n        \\n        queue=[]\\n        seen=set()\\n        for i,j in [[ball[0],ball[1]-1],[ball[0],ball[1]+1],[ball[0]+1,ball[1]],[ball[0]-1,ball[1]]]:\\n            if -1<i<len(grid) and -1<j<len(grid[0]) and grid[i][j]!=\"#\" and canReach(person,[i,j],ball,[row[:] for row in grid]):\\n                queue.append(ball+[i,j])\\n                seen.add(tuple(ball+[i,j]))\\n                \\n\\n                \\n        pushes=0\\n        while queue:\\n            newQueue=[]\\n            pushes+=1\\n            for bi,bj,pi,pj in queue:\\n                \\n                \\n                newState=None\\n                if bi==pi:\\n                    if bj+1==pj:\\n                        if bj>0 and grid[bi][bj-1]!=\"#\":\\n                            newState=[bi,bj-1,pi,pj-1]      \\n                    else:\\n                        if bj<len(grid[0])-1 and grid[bi][bj+1]!=\"#\":\\n                            newState=[bi,bj+1,pi,pj+1]    \\n                            \\n                else:\\n                    if bi+1==pi:\\n                        if bi>0 and grid[bi-1][bj]!=\"#\":\\n                            newState=[bi-1,bj,pi-1,pj]             \\n                    else:\\n                        if bi<len(grid)-1 and grid[bi+1][bj]!=\"#\":\\n                            newState=[bi+1,bj,pi+1,pj]    \\n                            \\n                \\n                if newState:\\n\\n                    if grid[newState[0]][newState[1]]==\"T\":\\n                        return pushes\\n                    \\n                    if tuple(newState) not in seen:\\n                        seen.add(tuple(newState))\\n                        newQueue.append(newState)\\n                        \\n                    \\n                   \\n                        bi,bj=newState[0],newState[1]\\n                        for nextbi,nextbj in [(bi,bj-1),(bi,bj+1),(bi-1,bj),(bi+1,bj)]:\\n                            if (-1<nextbi<len(grid) and -1<nextbj<len(grid[0]) \\n                                and grid[nextbi][nextbj]==\".\" \\n                                and tuple([bi,bj,nextbi,nextbj]) not in seen\\n                                and canReach([pi,pj],[nextbi,nextbj],[bi,bj],[row[:] for row in grid])):\\n                                \\n                                \\n \\n                                newQueue.append([bi,bj,nextbi,nextbj])\\n                                seen.add(tuple([bi,bj,nextbi,nextbj]))\\n                        \\n                        \\n            queue=newQueue\\n            \\n\\n        return -1\\n                \\n                \\n            \\n            \\n            \\n            \\ndef canReach(person,target,ball,grid):\\n    \\n    if person==target:\\n        return True\\n\\n    queue=[person]\\n    grid[ball[0]][ball[1]]=\"#\"\\n    \\n    while queue:\\n        newQueue=[]\\n        \\n        for i,j in queue:\\n            for y,x in [(i,j-1),(i+1,j),(i-1,j),(i,j+1)]:\\n                if -1<y<len(grid) and -1<x<len(grid[0]) and grid[y][x]!=\"#\":\\n                    if [y,x]==target:\\n                        return True\\n                    grid[y][x]=\"#\"\\n                    newQueue.append([y,x])\\n                    \\n            queue=newQueue\\n        \\n    return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2823561,
                "title": "c-0-1-bfs-well-commented-solution",
                "content": "```\\n#define INF 1\\'000\\'000\\'000\\n#define pi pair<int, int>\\n#define f first\\n#define s second\\n#define mp(x, y) make_pair(x, y)\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pi box, man, t;\\n        \\n        // graph traversal array\\n        int g[] = {1, 0, -1, 0, 1};\\n        \\n        // lambda function to check if vertex is valid\\n        auto check = [&](int xx, int yy){\\n            if(0 <= xx && xx < m && 0 <= yy && yy < n && grid[xx][yy] != \\'#\\')\\n                return true;\\n            return false;\\n        };\\n        \\n        // searching for box, player and target\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(grid[i][j] == \\'B\\')\\n                    box = mp(i, j);\\n                if(grid[i][j] == \\'S\\')\\n                    man = mp(i, j);\\n                if(grid[i][j] == \\'T\\')\\n                    t = mp(i, j);\\n            }\\n        }\\n        \\n\\t\\t// to check already visited states\\n        set<tuple<int, int, int, int>> vis;\\n        \\n        // 0-1 BFS\\n        deque<tuple<int, int, int, int, int> > q;\\n        q.push_back({man.f, man.s, box.f, box.s, 0});\\n        \\n        while(!q.empty() ){\\n            int x, y, a, b, d;\\n            tie(x, y, a, b, d) = q.front();\\n            q.pop_front();\\n            \\n            // goal node reached\\n            if(mp(a, b) == t)\\n               return d;\\n            \\n            auto cur = make_tuple(x, y, a, b);\\n            // check if already visited\\n            if(vis.count(cur) )\\n                continue;\\n            \\n            // if not, mark visited\\n            vis.insert(cur);\\n            \\n            // visit all neighbors\\n            for(int i = 0; i < 4; ++i){\\n                int nx = x + g[i], ny = y + g[i + 1];\\n                pi nxt = mp(nx, ny), A = mp(a, b);\\n                \\n                if(!check(nx, ny) )\\n                    continue;\\n                \\n                // if neighbor -> box\\n                if(nxt == A){\\n                    // push it in same direction\\n                    int na = a + g[i], nb = b + g[i + 1];\\n                    if(!check(na, nb) )\\n                        continue;\\n                    \\n                    // pushing box -> 1 cost operation\\n                    // so add this state to the last of queue\\n                    q.push_back({a, b, na, nb, d + 1});\\n                } else\\n                    // moving man -> 0 cost operation\\n                    q.push_front({nx, ny, a, b, d});\\n            }\\n        }\\n        \\n        // if target not found\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define INF 1\\'000\\'000\\'000\\n#define pi pair<int, int>\\n#define f first\\n#define s second\\n#define mp(x, y) make_pair(x, y)\\nclass Solution {\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pi box, man, t;\\n        \\n        // graph traversal array\\n        int g[] = {1, 0, -1, 0, 1};\\n        \\n        // lambda function to check if vertex is valid\\n        auto check = [&](int xx, int yy){\\n            if(0 <= xx && xx < m && 0 <= yy && yy < n && grid[xx][yy] != \\'#\\')\\n                return true;\\n            return false;\\n        };\\n        \\n        // searching for box, player and target\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(grid[i][j] == \\'B\\')\\n                    box = mp(i, j);\\n                if(grid[i][j] == \\'S\\')\\n                    man = mp(i, j);\\n                if(grid[i][j] == \\'T\\')\\n                    t = mp(i, j);\\n            }\\n        }\\n        \\n\\t\\t// to check already visited states\\n        set<tuple<int, int, int, int>> vis;\\n        \\n        // 0-1 BFS\\n        deque<tuple<int, int, int, int, int> > q;\\n        q.push_back({man.f, man.s, box.f, box.s, 0});\\n        \\n        while(!q.empty() ){\\n            int x, y, a, b, d;\\n            tie(x, y, a, b, d) = q.front();\\n            q.pop_front();\\n            \\n            // goal node reached\\n            if(mp(a, b) == t)\\n               return d;\\n            \\n            auto cur = make_tuple(x, y, a, b);\\n            // check if already visited\\n            if(vis.count(cur) )\\n                continue;\\n            \\n            // if not, mark visited\\n            vis.insert(cur);\\n            \\n            // visit all neighbors\\n            for(int i = 0; i < 4; ++i){\\n                int nx = x + g[i], ny = y + g[i + 1];\\n                pi nxt = mp(nx, ny), A = mp(a, b);\\n                \\n                if(!check(nx, ny) )\\n                    continue;\\n                \\n                // if neighbor -> box\\n                if(nxt == A){\\n                    // push it in same direction\\n                    int na = a + g[i], nb = b + g[i + 1];\\n                    if(!check(na, nb) )\\n                        continue;\\n                    \\n                    // pushing box -> 1 cost operation\\n                    // so add this state to the last of queue\\n                    q.push_back({a, b, na, nb, d + 1});\\n                } else\\n                    // moving man -> 0 cost operation\\n                    q.push_front({nx, ny, a, b, d});\\n            }\\n        }\\n        \\n        // if target not found\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796958,
                "title": "bfs-dfs-c-easy-to-understand",
                "content": "1. For S to be able to push box B, we need to check if S can reach any point adjacent to B. If S does, there are few cases -\\n\\t\\ta) If S can reach Bx + 1, he can push box upwards to position Bx - 1 & vice versa\\n\\t\\tb) If S can reach Yx + 1, he can push box towards left to position Yx - 1 & vice versa\\n2. After reaching to a certain point, we can add the new box position as well as position of S in q. \\n\\n\\tWhy do we need to add position of S ? \\n\\tSuppose we have reach (bx, by) by pushing the box from (bx -1, by). Now there can be a case where we can push this box from (bx, by - 1) to (bx, by). It is possible that (bx, by - 1) wasn\\'t reachable earlier, so we missed this case and need to add this. We can update our distance array as follows -\\n\\t\\t\\t`dp[next_bx][next_by][from_sx][from_sy] = 1 + dp[bx][by][last_x][last_y]`\\n\\t\\t\\twhere dp[next_bx][next_by][from_sx][from_sy] => Cost of pushing box from (sx, sy) to (next_x, next_y)\\n3. Keep on checking if adjacent positions of box is reachable, add newly found position in queue & update distance.\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool isReachable(int cx, int cy, int tx, int ty, vector<vector<bool> > &vis, vector<vector<char> > &grid, int n, int m, int bx, int by) {\\n        if(cx == tx && cy == ty) return true;\\n        vis[cx][cy] = 1;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = cx + dx[i], ny = cy + dy[i];\\n            if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if(grid[nx][ny] == \\'#\\') continue;\\n            if(vis[nx][ny]) continue;\\n            if(nx == bx && ny == by) continue;\\n            if(isReachable(nx, ny, tx, ty, vis, grid, n, m, bx, by)) return true;\\n        }\\n        return false;\\n    }\\n    int dis[22][22][22][22];\\n    int minPushBox(vector<vector<char>>& grid) {\\n        queue<vector<int> > q;\\n        int sx, sy, bx, by;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    sx = i;\\n                    sy = j;\\n                }\\n                else if(grid[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < 22; i++) {\\n            for(int j = 0; j < 22; j++) {\\n                for(int k = 0; k < 22; k++) {\\n                    for(int l = 0; l < 22; l++) {\\n                        dis[i][j][k][l] = 1e9;\\n                    }\\n                }\\n            }\\n        }\\n        q.push({ bx, by, sx, sy });\\n        dis[bx][by][sx][sy] = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        while(!q.empty()) {\\n            vector<int> cur = q.front();\\n            q.pop();\\n            int x = cur[0], y = cur[1], lx = cur[2], ly = cur[3];\\n            if(grid[x][y] == \\'T\\') return dis[x][y][lx][ly];\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i], ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n                vector<vector<bool> > vis(n, vector<bool>(m, 0));\\n                if(isReachable(lx, ly, nx, ny, vis, grid, n, m, x, y)) {\\n                    if(nx > x) {\\n                        if(x - 1 >= 0 && grid[x - 1][y] != \\'#\\' && dis[x - 1][y][nx][ny] == 1e9) {\\n                            q.push({ x - 1, y, nx, ny });\\n                            dis[x - 1][y][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else if(nx < x) {\\n                        if(x + 1 < n && grid[x + 1][y] != \\'#\\' && dis[x + 1][y][nx][ny] == 1e9) {\\n                            q.push({ x + 1, y, nx, ny });\\n                            dis[x + 1][y][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else if(ny > y) {\\n                        if(y - 1 >= 0 && grid[x][y - 1] != \\'#\\' && dis[x][y - 1][nx][ny] == 1e9) {\\n                            q.push({ x, y - 1, nx, ny });\\n                            dis[x][y - 1][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else {\\n                        if(y + 1 < m && grid[x][y + 1] != \\'#\\' && dis[x][y + 1][nx][ny] == 1e9) {\\n                            q.push({ x, y + 1, nx, ny });\\n                            dis[x][y + 1][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool isReachable(int cx, int cy, int tx, int ty, vector<vector<bool> > &vis, vector<vector<char> > &grid, int n, int m, int bx, int by) {\\n        if(cx == tx && cy == ty) return true;\\n        vis[cx][cy] = 1;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = cx + dx[i], ny = cy + dy[i];\\n            if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if(grid[nx][ny] == \\'#\\') continue;\\n            if(vis[nx][ny]) continue;\\n            if(nx == bx && ny == by) continue;\\n            if(isReachable(nx, ny, tx, ty, vis, grid, n, m, bx, by)) return true;\\n        }\\n        return false;\\n    }\\n    int dis[22][22][22][22];\\n    int minPushBox(vector<vector<char>>& grid) {\\n        queue<vector<int> > q;\\n        int sx, sy, bx, by;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    sx = i;\\n                    sy = j;\\n                }\\n                else if(grid[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < 22; i++) {\\n            for(int j = 0; j < 22; j++) {\\n                for(int k = 0; k < 22; k++) {\\n                    for(int l = 0; l < 22; l++) {\\n                        dis[i][j][k][l] = 1e9;\\n                    }\\n                }\\n            }\\n        }\\n        q.push({ bx, by, sx, sy });\\n        dis[bx][by][sx][sy] = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        while(!q.empty()) {\\n            vector<int> cur = q.front();\\n            q.pop();\\n            int x = cur[0], y = cur[1], lx = cur[2], ly = cur[3];\\n            if(grid[x][y] == \\'T\\') return dis[x][y][lx][ly];\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i], ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n                vector<vector<bool> > vis(n, vector<bool>(m, 0));\\n                if(isReachable(lx, ly, nx, ny, vis, grid, n, m, x, y)) {\\n                    if(nx > x) {\\n                        if(x - 1 >= 0 && grid[x - 1][y] != \\'#\\' && dis[x - 1][y][nx][ny] == 1e9) {\\n                            q.push({ x - 1, y, nx, ny });\\n                            dis[x - 1][y][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else if(nx < x) {\\n                        if(x + 1 < n && grid[x + 1][y] != \\'#\\' && dis[x + 1][y][nx][ny] == 1e9) {\\n                            q.push({ x + 1, y, nx, ny });\\n                            dis[x + 1][y][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else if(ny > y) {\\n                        if(y - 1 >= 0 && grid[x][y - 1] != \\'#\\' && dis[x][y - 1][nx][ny] == 1e9) {\\n                            q.push({ x, y - 1, nx, ny });\\n                            dis[x][y - 1][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                    else {\\n                        if(y + 1 < m && grid[x][y + 1] != \\'#\\' && dis[x][y + 1][nx][ny] == 1e9) {\\n                            q.push({ x, y + 1, nx, ny });\\n                            dis[x][y + 1][nx][ny] = 1 + dis[x][y][lx][ly];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699481,
                "title": "rust-dijkstra",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\nconst UNREACHABLE: i32 = -1;\\nconst DIR: [(isize, isize); 4] = [(-1, 0), (0, -1), (0, 1), (1, 0)];\\n\\nconst OBSTACLE: char = \\'#\\';\\nconst BOX: char = \\'B\\';\\nconst PERSON: char = \\'S\\';\\nconst TARGET: char = \\'T\\';\\n\\npub fn min_push_box(grid: Vec<Vec<char>>) -> i32 {\\n    let mut visited = HashSet::new();\\n    let (mut pr, mut pc) = (0, 0);\\n    let (mut br, mut bc) = (0, 0);\\n    let (mut tr, mut tc) = (0, 0);\\n\\n    for r in 0..grid.len() {\\n        for c in 0..grid[r].len() {\\n            match grid[r][c] {\\n                BOX => {\\n                    br = r;\\n                    bc = c;\\n                }\\n                PERSON => {\\n                    pr = r;\\n                    pc = c;\\n                }\\n                TARGET => {\\n                    tr = r;\\n                    tc = c;\\n                }\\n                _ => {}\\n            }\\n        }\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse(0), br, bc, pr, pc));\\n    visited.insert((br, bc, pr, pc));\\n\\n    while let Some((Reverse(cost), br, bc, pr, pc)) = pq.pop() {\\n        if (tr, tc) == (br, bc) {\\n            return cost;\\n        }\\n\\n        for (dr, dc) in DIR.iter().copied() {\\n            let rx = pr as isize + dr;\\n            let cx = pc as isize + dc;\\n\\n            // out of bounds: up/left\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let pr_new = rx as usize;\\n            let pc_new = cx as usize;\\n\\n            // out of bounds: down/right\\n            if pr_new >= grid.len() || pc_new >= grid[pr_new].len() {\\n                continue;\\n            }\\n\\n            // we cannot move into a wall\\n            if grid[pr_new][pc_new] == OBSTACLE {\\n                continue;\\n            }\\n\\n            let mut cost_new = cost;\\n            let mut br_new = br;\\n            let mut bc_new = bc;\\n\\n            // check if we are moving the box\\n            if (pr_new, pc_new) == (br_new, bc_new) {\\n                let rx = br_new as isize + dr;\\n                let cx = bc_new as isize + dc;\\n\\n                // cannot move the box outside the board\\n                if rx < 0 || cx < 0 {\\n                    continue;\\n                }\\n\\n                br_new = rx as usize;\\n                bc_new = cx as usize;\\n\\n                // cannot move the box outside the board\\n                if br_new >= grid.len() || bc_new >= grid[br_new].len() {\\n                    continue;\\n                }\\n\\n                // cannot move the box into an obstacle\\n                if grid[br_new][bc_new] == OBSTACLE {\\n                    continue;\\n                }\\n\\n                // we\\'ve moved the box\\n                cost_new += 1;\\n            }\\n\\n            // Skip already visited combinations\\n            if !visited.insert((br_new, bc_new, pr_new, pc_new)) {\\n                continue;\\n            }\\n\\n            pq.push((Reverse(cost_new), br_new, bc_new, pr_new, pc_new));\\n        }\\n    }\\n\\n    UNREACHABLE\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\nconst UNREACHABLE: i32 = -1;\\nconst DIR: [(isize, isize); 4] = [(-1, 0), (0, -1), (0, 1), (1, 0)];\\n\\nconst OBSTACLE: char = \\'#\\';\\nconst BOX: char = \\'B\\';\\nconst PERSON: char = \\'S\\';\\nconst TARGET: char = \\'T\\';\\n\\npub fn min_push_box(grid: Vec<Vec<char>>) -> i32 {\\n    let mut visited = HashSet::new();\\n    let (mut pr, mut pc) = (0, 0);\\n    let (mut br, mut bc) = (0, 0);\\n    let (mut tr, mut tc) = (0, 0);\\n\\n    for r in 0..grid.len() {\\n        for c in 0..grid[r].len() {\\n            match grid[r][c] {\\n                BOX => {\\n                    br = r;\\n                    bc = c;\\n                }\\n                PERSON => {\\n                    pr = r;\\n                    pc = c;\\n                }\\n                TARGET => {\\n                    tr = r;\\n                    tc = c;\\n                }\\n                _ => {}\\n            }\\n        }\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse(0), br, bc, pr, pc));\\n    visited.insert((br, bc, pr, pc));\\n\\n    while let Some((Reverse(cost), br, bc, pr, pc)) = pq.pop() {\\n        if (tr, tc) == (br, bc) {\\n            return cost;\\n        }\\n\\n        for (dr, dc) in DIR.iter().copied() {\\n            let rx = pr as isize + dr;\\n            let cx = pc as isize + dc;\\n\\n            // out of bounds: up/left\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let pr_new = rx as usize;\\n            let pc_new = cx as usize;\\n\\n            // out of bounds: down/right\\n            if pr_new >= grid.len() || pc_new >= grid[pr_new].len() {\\n                continue;\\n            }\\n\\n            // we cannot move into a wall\\n            if grid[pr_new][pc_new] == OBSTACLE {\\n                continue;\\n            }\\n\\n            let mut cost_new = cost;\\n            let mut br_new = br;\\n            let mut bc_new = bc;\\n\\n            // check if we are moving the box\\n            if (pr_new, pc_new) == (br_new, bc_new) {\\n                let rx = br_new as isize + dr;\\n                let cx = bc_new as isize + dc;\\n\\n                // cannot move the box outside the board\\n                if rx < 0 || cx < 0 {\\n                    continue;\\n                }\\n\\n                br_new = rx as usize;\\n                bc_new = cx as usize;\\n\\n                // cannot move the box outside the board\\n                if br_new >= grid.len() || bc_new >= grid[br_new].len() {\\n                    continue;\\n                }\\n\\n                // cannot move the box into an obstacle\\n                if grid[br_new][bc_new] == OBSTACLE {\\n                    continue;\\n                }\\n\\n                // we\\'ve moved the box\\n                cost_new += 1;\\n            }\\n\\n            // Skip already visited combinations\\n            if !visited.insert((br_new, bc_new, pr_new, pc_new)) {\\n                continue;\\n            }\\n\\n            pq.push((Reverse(cost_new), br_new, bc_new, pr_new, pc_new));\\n        }\\n    }\\n\\n    UNREACHABLE\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643673,
                "title": "python3-double-bfs-o-m-2-n-2",
                "content": "I believe there is a faster way to do this involving some preprocessing, but this nested BFS also works under the time constraint. Upvote if it helps! :)\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]\\n        \\n        def player_bfs(st_row, st_col, tgt_row, tgt_col):\\n            nonlocal rows, cols\\n            if (st_row, st_col) == (tgt_row, tgt_col):\\n                return True\\n            q = deque([(st_row, st_col)]) \\n            seen = [[False] * cols for _ in range(rows)]\\n            seen[st_row][st_col] = True\\n            \\n            while q:\\n                row, col = q.pop()\\n                for r, c in neighbors:\\n                    if 0 <= row+r < rows and 0 <= col+c < cols and not seen[row+r][col+c] and grid[row+r][col+c] == \\'.\\':\\n                        if row+r == tgt_row and col+c == tgt_col:\\n                            return True\\n                        seen[row+r][col+c] = True\\n                        q.appendleft((row+r, col+c))\\n            return False\\n            \\n        def box_bfs(st_row, st_col):\\n            nonlocal rows, cols, target\\n            q = deque([(st_row, st_col, start[0], start[1], 0)])\\n            seen = {st_row, st_col, start[0], start[1]}\\n            \\n            while q:\\n                row, col, prow, pcol, moves = q.pop()\\n                grid[row][col] = \\'B\\'\\n                for r, c in neighbors:\\n                    box_can_move = 0 <= row+r < rows and 0 <= col+c < cols and (row+r, col+c, row-r, col-c) not in seen and grid[row+r][col+c] == \\'.\\'\\n                    if box_can_move and player_bfs(prow, pcol, row-r, col-c):\\n                        if (row+r, col+c) == target:\\n                            return moves + 1\\n                        seen.add((row+r, col+c, row-r, col-c))\\n                        q.appendleft((row+r, col+c, row-r, col-c, moves+1))\\n                grid[row][col] = \\'.\\'\\n            \\n            return -1\\n        \\n        start = target = box = None\\n        rows, cols = len(grid), len(grid[0])\\n        for r, row in enumerate(grid):\\n            for c, pos in enumerate(row):\\n                if pos == \\'S\\':\\n                    start = (r, c)\\n                    grid[r][c] = \\'.\\'\\n                elif pos == \\'T\\':\\n                    target = (r, c)\\n                    grid[r][c] = \\'.\\'\\n                elif pos == \\'B\\':\\n                    box = (r, c)\\n                    grid[r][c] = \\'.\\'\\n        \\n        return box_bfs(*box)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        \\n        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]\\n        \\n        def player_bfs(st_row, st_col, tgt_row, tgt_col):\\n            nonlocal rows, cols\\n            if (st_row, st_col) == (tgt_row, tgt_col):\\n                return True\\n            q = deque([(st_row, st_col)]) \\n            seen = [[False] * cols for _ in range(rows)]\\n            seen[st_row][st_col] = True\\n            \\n            while q:\\n                row, col = q.pop()\\n                for r, c in neighbors:\\n                    if 0 <= row+r < rows and 0 <= col+c < cols and not seen[row+r][col+c] and grid[row+r][col+c] == \\'.\\':\\n                        if row+r == tgt_row and col+c == tgt_col:\\n                            return True\\n                        seen[row+r][col+c] = True\\n                        q.appendleft((row+r, col+c))\\n            return False\\n            \\n        def box_bfs(st_row, st_col):\\n            nonlocal rows, cols, target\\n            q = deque([(st_row, st_col, start[0], start[1], 0)])\\n            seen = {st_row, st_col, start[0], start[1]}",
                "codeTag": "Java"
            },
            {
                "id": 2603632,
                "title": "python-double-bfs-solution-interesting-problem",
                "content": "```\\nclass Solution:\\n    # Given the box position, it can be moved to a neighbour if\\n    # 1. The neighbour is free\\n    # 2. The opposite position of the neighbour is free\\n    # 3. This opposite position is reachable from S\\n    # Therefore there are two layers of BFS:\\n    # A. Box BFS\\n    # B. Opposite neighbour BFS to currently where S is\\n    # State is represented by (Sx, Sy, Bx, By)\\n    \\n    def valid_grid_point(self, x, y):\\n        m, n = len(self.grid), len(self.grid[0])\\n        return x >= 0 and y >= 0 and x < m and y < n\\n    \\n    def canreach(self, sx, sy, nox, noy):\\n        dq, visited = deque(), set()\\n        dq.append((nox, noy))\\n        visited.add((nox, noy))\\n        while dq:\\n            x, y = dq.popleft()\\n            if x == sx and y == sy:\\n                return True\\n            neigs = [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]\\n            for xn, yn in neigs:\\n                if self.valid_grid_point(xn, yn) and self.grid[xn][yn] == \".\" and (xn,yn) not in visited:\\n                    dq.append((xn,yn))\\n                    visited.add((xn,yn))\\n        return False\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.grid = grid\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j] == \"T\":\\n                    Tx, Ty = i, j\\n                    self.grid[i][j] = \".\"\\n                elif self.grid[i][j] == \"S\":\\n                    Sx, Sy = i, j\\n                    self.grid[i][j] = \".\"\\n                elif self.grid[i][j] == \"B\":\\n                    Bx, By = i, j\\n                    self.grid[i][j] = \".\"\\n        \\n        dq, visited, push = deque(), set(), 0\\n        dq.append((Sx, Sy, Bx, By))\\n        visited.add((Sx, Sy, Bx, By))\\n        while dq:\\n            for i in range(len(dq)):\\n                sx, sy, bx, by = dq.popleft()\\n                if bx == Tx and by == Ty:\\n                    return push\\n                neigs = [(bx+1,by), (bx-1,by), (bx, by+1), (bx, by-1)]\\n                neigs_oppo = [(bx-1,by), (bx+1,by), (bx, by-1), (bx, by+1)]\\n                for j in range(4):\\n                    nx, ny = neigs[j]\\n                    nox, noy = neigs_oppo[j]\\n                    if self.valid_grid_point(nx, ny) and self.valid_grid_point(nox, noy) and self.grid[nx][ny] == \".\" and self.grid[nox][noy] == \".\":\\n                        self.grid[bx][by] = \"#\"\\n                        if self.canreach(sx, sy, nox, noy) and (bx, by, nx, ny) not in visited:\\n                            dq.append((bx, by, nx, ny))\\n                            visited.add((bx, by, nx, ny))                            \\n                        self.grid[bx][by] = \".\"\\n            push += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Given the box position, it can be moved to a neighbour if\\n    # 1. The neighbour is free\\n    # 2. The opposite position of the neighbour is free\\n    # 3. This opposite position is reachable from S\\n    # Therefore there are two layers of BFS:\\n    # A. Box BFS\\n    # B. Opposite neighbour BFS to currently where S is\\n    # State is represented by (Sx, Sy, Bx, By)\\n    \\n    def valid_grid_point(self, x, y):\\n        m, n = len(self.grid), len(self.grid[0])\\n        return x >= 0 and y >= 0 and x < m and y < n\\n    \\n    def canreach(self, sx, sy, nox, noy):\\n        dq, visited = deque(), set()\\n        dq.append((nox, noy))\\n        visited.add((nox, noy))\\n        while dq:\\n            x, y = dq.popleft()\\n            if x == sx and y == sy:\\n                return True\\n            neigs = [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]\\n            for xn, yn in neigs:\\n                if self.valid_grid_point(xn, yn) and self.grid[xn][yn] == \".\" and (xn,yn) not in visited:\\n                    dq.append((xn,yn))\\n                    visited.add((xn,yn))\\n        return False\\n    \\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.grid = grid\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j] == \"T\":\\n                    Tx, Ty = i, j\\n                    self.grid[i][j] = \".\"\\n                elif self.grid[i][j] == \"S\":\\n                    Sx, Sy = i, j\\n                    self.grid[i][j] = \".\"\\n                elif self.grid[i][j] == \"B\":\\n                    Bx, By = i, j\\n                    self.grid[i][j] = \".\"\\n        \\n        dq, visited, push = deque(), set(), 0\\n        dq.append((Sx, Sy, Bx, By))\\n        visited.add((Sx, Sy, Bx, By))\\n        while dq:\\n            for i in range(len(dq)):\\n                sx, sy, bx, by = dq.popleft()\\n                if bx == Tx and by == Ty:\\n                    return push\\n                neigs = [(bx+1,by), (bx-1,by), (bx, by+1), (bx, by-1)]\\n                neigs_oppo = [(bx-1,by), (bx+1,by), (bx, by-1), (bx, by+1)]\\n                for j in range(4):\\n                    nx, ny = neigs[j]\\n                    nox, noy = neigs_oppo[j]\\n                    if self.valid_grid_point(nx, ny) and self.valid_grid_point(nox, noy) and self.grid[nx][ny] == \".\" and self.grid[nox][noy] == \".\":\\n                        self.grid[bx][by] = \"#\"\\n                        if self.canreach(sx, sy, nox, noy) and (bx, by, nx, ny) not in visited:\\n                            dq.append((bx, by, nx, ny))\\n                            visited.add((bx, by, nx, ny))                            \\n                        self.grid[bx][by] = \".\"\\n            push += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589595,
                "title": "tc-sc-90-double-bfs-explanation-python",
                "content": "```\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m = len(grid); n = len(grid[0])\\n        \\n        #finding the start locations and modifying the grid a little bit for easier bfs\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\": target = (i, j); grid[i][j] = \".\"\\n                if grid[i][j] == \"S\": player = (i, j); grid[i][j] = \".\"\\n                if grid[i][j] == \"B\": box = (i, j); grid[i][j] = \".\"\\n        \\n        #need a search function to check if player can around the box to push from the correct direction\\n        def path(s_i, s_j, t_i, t_j):\\n            visited = [[0]*n for _ in range(m)]\\n            visited[s_i][s_j] = 1\\n            que = deque([[s_i, s_j]])\\n            while len(que):\\n                c_i, c_j = que.popleft()\\n\\n                if (c_i, c_j) == (t_i,t_j): return 1\\n\\n                for n_i, n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n                    if -1<n_i<m and -1<n_j<n and grid[n_i][n_j]==\".\" and not visited[n_i][n_j]:\\n                        visited[n_i][n_j] = 1\\n                        que.append([n_i, n_j])\\n            return 0\\n        \\n        #using bfs to move box from startPosition to target\\n        #keeping track of boxLocation, playerPos, number of pushes = distance moved by the box\\n        que = deque([[box, player, 0]])\\n        #the box can visited each cell from 4 different directions\\n        visited = [[[0]*4 for _ in range(n)] for _ in range(m)]\\n                    \\n        while len(que):\\n            src, pusher, c_dis = que.popleft()\\n            if src == target: return c_dis\\n            \\n            #you must mark the location of the box, so that player doesnt go through it\\n            c_i, c_j = src; grid[c_i][c_j] = \"B\"\\n            p_i, p_j = pusher\\n            \\n            moves = [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]\\n    \\n            for idx, neigh in enumerate(moves):\\n                n_i, n_j = neigh\\n                if -1<n_i<m and -1<n_j<n and grid[n_i][n_j]==\".\" and not visited[n_i][n_j][idx]:\\n                    \\n                    if idx == 0: #up -> push from down\\n                        if c_i+1<m and grid[c_i+1][c_j]==\".\" and path(p_i, p_j, c_i+1, c_j):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    elif idx == 1: #right -> push from left\\n                        if -1<c_j-1 and grid[c_i][c_j-1]==\".\" and path(p_i, p_j, c_i, c_j-1):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    elif idx == 2: #down -> push from up\\n                        if -1<c_i-1 and grid[c_i-1][c_j]==\".\" and path(p_i, p_j, c_i-1, c_j):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    else: #left -> push from right\\n                        if c_j+1<n and grid[c_i][c_j+1]==\".\" and path(p_i, p_j, c_i, c_j+1):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n            \\n            #box will now go in a new location, so make the cell empty again\\n            grid[c_i][c_j] = \".\"\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m = len(grid); n = len(grid[0])\\n        \\n        #finding the start locations and modifying the grid a little bit for easier bfs\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\": target = (i, j); grid[i][j] = \".\"\\n                if grid[i][j] == \"S\": player = (i, j); grid[i][j] = \".\"\\n                if grid[i][j] == \"B\": box = (i, j); grid[i][j] = \".\"\\n        \\n        #need a search function to check if player can around the box to push from the correct direction\\n        def path(s_i, s_j, t_i, t_j):\\n            visited = [[0]*n for _ in range(m)]\\n            visited[s_i][s_j] = 1\\n            que = deque([[s_i, s_j]])\\n            while len(que):\\n                c_i, c_j = que.popleft()\\n\\n                if (c_i, c_j) == (t_i,t_j): return 1\\n\\n                for n_i, n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n                    if -1<n_i<m and -1<n_j<n and grid[n_i][n_j]==\".\" and not visited[n_i][n_j]:\\n                        visited[n_i][n_j] = 1\\n                        que.append([n_i, n_j])\\n            return 0\\n        \\n        #using bfs to move box from startPosition to target\\n        #keeping track of boxLocation, playerPos, number of pushes = distance moved by the box\\n        que = deque([[box, player, 0]])\\n        #the box can visited each cell from 4 different directions\\n        visited = [[[0]*4 for _ in range(n)] for _ in range(m)]\\n                    \\n        while len(que):\\n            src, pusher, c_dis = que.popleft()\\n            if src == target: return c_dis\\n            \\n            #you must mark the location of the box, so that player doesnt go through it\\n            c_i, c_j = src; grid[c_i][c_j] = \"B\"\\n            p_i, p_j = pusher\\n            \\n            moves = [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]\\n    \\n            for idx, neigh in enumerate(moves):\\n                n_i, n_j = neigh\\n                if -1<n_i<m and -1<n_j<n and grid[n_i][n_j]==\".\" and not visited[n_i][n_j][idx]:\\n                    \\n                    if idx == 0: #up -> push from down\\n                        if c_i+1<m and grid[c_i+1][c_j]==\".\" and path(p_i, p_j, c_i+1, c_j):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    elif idx == 1: #right -> push from left\\n                        if -1<c_j-1 and grid[c_i][c_j-1]==\".\" and path(p_i, p_j, c_i, c_j-1):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    elif idx == 2: #down -> push from up\\n                        if -1<c_i-1 and grid[c_i-1][c_j]==\".\" and path(p_i, p_j, c_i-1, c_j):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n                    else: #left -> push from right\\n                        if c_j+1<n and grid[c_i][c_j+1]==\".\" and path(p_i, p_j, c_i, c_j+1):\\n                            visited[n_i][n_j][idx] = 1\\n                            que.append([(n_i, n_j), (c_i, c_j) , c_dis+1])\\n            \\n            #box will now go in a new location, so make the cell empty again\\n            grid[c_i][c_j] = \".\"\\n        \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2552575,
                "title": "c-solution-using-double-bfs",
                "content": "My solution is a double BFS solution. I start from the starting position from of the box and do a BFS to reach the target. The added complexity now is to ensure our player can reach the required position to enforce this change i.e. a push.\\n\\n```\\ntypedef pair<int,int> P;\\n\\nstruct state{\\n\\n    P b,p;    \\n    bool operator <(const state& aa) const {\\n        return make_pair(b, p) < make_pair(aa.b, aa.p);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> dx = {1,-1, 0, 0};\\n    vector<int> dy = {0, 0, 1,-1};\\n    \\n    int M,N;\\n    \\n    P getLocation(vector<vector<char>>& grid, char c){\\n        for(int i = 0 ; i < M ; i++){\\n            for(int j = 0 ; j < N ; j++){\\n                if(grid[i][j] == c){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n        return {0,0};\\n    }\\n    \\n    bool isValid(vector<vector<char>>& grid, int x, int y){\\n        if(x >= M || x < 0 || y >= N || y < 0 || grid[x][y] == \\'#\\')\\n            return false;\\n        return true;\\n    }\\n    \\n    bool canReach(vector<vector<char>>& grid ,P curPos, P endPos, P boxPos){\\n        // BFS to try reaching a,b from x,y\\n        queue<pair<int,int>> q;\\n        q.push(curPos);\\n        set<P> visited;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                \\n                P pos = q.front();\\n                if(pos == endPos)\\n                    return true;\\n                q.pop();\\n                \\n                for(int i = 0 ; i < 4; i++){\\n                    P pos_new = {pos.first + dx[i], pos.second + dy[i]};\\n                    if(!isValid(grid, pos_new.first, pos_new.second) || visited.count(pos_new))\\n                        continue;\\n                    if(pos_new == boxPos)\\n                        continue;\\n                    q.push(pos_new);\\n                    visited.insert(pos_new);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid){\\n        // grid = GRID;\\n        M = grid.size();\\n        N = grid[0].size();\\n        \\n        P tgt = getLocation(grid, \\'T\\');\\n        P player = getLocation(grid, \\'S\\');\\n        P box = getLocation(grid, \\'B\\');\\n        \\n        queue<state> q;\\n        q.push(state{box, player});\\n        int steps = 0;\\n        set<state> visited;\\n                    \\n        // BFS\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                \\n                auto cur_state = q.front();\\n                q.pop();\\n                if(cur_state.b == tgt)\\n                    return steps;\\n                \\n                \\n                for(int i = 0 ; i < 4; i++){\\n                    int box_new_x = cur_state.b.first + dx[i];\\n                    int box_new_y = cur_state.b.second + dy[i];\\n                    \\n                    // check if box can be pushed to the new lcoation\\n                    if(!isValid(grid, box_new_x, box_new_y)){\\n                        continue;\\n                    }\\n                    \\n                    // check if person can push the box\\n                    int per_new_x = cur_state.b.first - dx[i];\\n                    int per_new_y = cur_state.b.second - dy[i];\\n                    \\n                    // check if box can be pushed to the new lcoation\\n                    if(!isValid(grid, per_new_x, per_new_y)){\\n                        continue;\\n                    }\\n                    \\n                    // can person reach the new loc\\n                    if(!canReach(grid, cur_state.p, {per_new_x, per_new_y} , cur_state.b)){\\n                        continue;\\n                    }\\n                    \\n                    state new_state = state{{box_new_x,box_new_y},{per_new_x,per_new_y}};\\n                    if(visited.count(new_state))\\n                        continue;\\n                    \\n                    q.push(new_state);\\n                    visited.insert(new_state);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;        \\n    }\\n};             \\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int,int> P;\\n\\nstruct state{\\n\\n    P b,p;    \\n    bool operator <(const state& aa) const {\\n        return make_pair(b, p) < make_pair(aa.b, aa.p);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> dx = {1,-1, 0, 0};\\n    vector<int> dy = {0, 0, 1,-1};\\n    \\n    int M,N;\\n    \\n    P getLocation(vector<vector<char>>& grid, char c){\\n        for(int i = 0 ; i < M ; i++){\\n            for(int j = 0 ; j < N ; j++){\\n                if(grid[i][j] == c){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n        return {0,0};\\n    }\\n    \\n    bool isValid(vector<vector<char>>& grid, int x, int y){\\n        if(x >= M || x < 0 || y >= N || y < 0 || grid[x][y] == \\'#\\')\\n            return false;\\n        return true;\\n    }\\n    \\n    bool canReach(vector<vector<char>>& grid ,P curPos, P endPos, P boxPos){\\n        // BFS to try reaching a,b from x,y\\n        queue<pair<int,int>> q;\\n        q.push(curPos);\\n        set<P> visited;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                \\n                P pos = q.front();\\n                if(pos == endPos)\\n                    return true;\\n                q.pop();\\n                \\n                for(int i = 0 ; i < 4; i++){\\n                    P pos_new = {pos.first + dx[i], pos.second + dy[i]};\\n                    if(!isValid(grid, pos_new.first, pos_new.second) || visited.count(pos_new))\\n                        continue;\\n                    if(pos_new == boxPos)\\n                        continue;\\n                    q.push(pos_new);\\n                    visited.insert(pos_new);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid){\\n        // grid = GRID;\\n        M = grid.size();\\n        N = grid[0].size();\\n        \\n        P tgt = getLocation(grid, \\'T\\');\\n        P player = getLocation(grid, \\'S\\');\\n        P box = getLocation(grid, \\'B\\');\\n        \\n        queue<state> q;\\n        q.push(state{box, player});\\n        int steps = 0;\\n        set<state> visited;\\n                    \\n        // BFS\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                \\n                auto cur_state = q.front();\\n                q.pop();\\n                if(cur_state.b == tgt)\\n                    return steps;\\n                \\n                \\n                for(int i = 0 ; i < 4; i++){\\n                    int box_new_x = cur_state.b.first + dx[i];\\n                    int box_new_y = cur_state.b.second + dy[i];\\n                    \\n                    // check if box can be pushed to the new lcoation\\n                    if(!isValid(grid, box_new_x, box_new_y)){\\n                        continue;\\n                    }\\n                    \\n                    // check if person can push the box\\n                    int per_new_x = cur_state.b.first - dx[i];\\n                    int per_new_y = cur_state.b.second - dy[i];\\n                    \\n                    // check if box can be pushed to the new lcoation\\n                    if(!isValid(grid, per_new_x, per_new_y)){\\n                        continue;\\n                    }\\n                    \\n                    // can person reach the new loc\\n                    if(!canReach(grid, cur_state.p, {per_new_x, per_new_y} , cur_state.b)){\\n                        continue;\\n                    }\\n                    \\n                    state new_state = state{{box_new_x,box_new_y},{per_new_x,per_new_y}};\\n                    if(visited.count(new_state))\\n                        continue;\\n                    \\n                    q.push(new_state);\\n                    visited.insert(new_state);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;        \\n    }\\n};             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473317,
                "title": "javascript-clever-solution-easy-to-understand",
                "content": "This Github repository, https://github.com/AnasImloul/Leetcode-solutions, have all the solutions I was looking for.\\nIt is extremely beneficial to have every solution available in one place. I hope it is useful to you as well.\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n\\t// common info & utils\\n    const m = grid.length\\n    const n = grid[0].length\\n    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const add = (a, b) => [a[0] + b[0], a[1] + b[1]]\\n    const equals = (a, b) => a[0] === b[0] && a[1] === b[1]\\n    const validate = ([x, y]) => x >= 0 && y >= 0 && x < m && y < n\\n    const getKey = ([x, y]) => x * n + y\\n\\n\\t// find all player, ball, target, and free cells\\n    const init = () => {\\n        let player\\n        let ball\\n        let target\\n        const freeSet = new Set()\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (grid[i][j] === \\'.\\') {\\n                    freeSet.add(getKey([i, j]))\\n                } else if (grid[i][j] === \\'S\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    player = [i, j]\\n                } else if (grid[i][j] === \\'B\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    ball = [i, j]\\n                } else if (grid[i][j] === \\'T\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    target = [i, j]\\n                }\\n            }\\n        }\\n        return { player, ball, target, freeSet }\\n    }\\n    const { player, ball, target, freeSet } = init()\\n    const targetKey = getKey(target)\\n\\n\\t// detect whether two cells are connected\\n    const connCache = new Map() // [x,y,x2,y2,x3,y3] => boolean\\n    const getConnKey = (a, b, ball) => {\\n        if (\\n            a[0] > b[0] ||\\n            a[0] === b[0] && a[1] > b[1]\\n        ) {\\n            [a, b] = [b, a]\\n        }\\n        return [a[0], a[1], b[0], b[1], ball[0], ball[1]].join(\\',\\')\\n    }\\n    const isConnected = (a, b, ball) => {\\n        if (a[0] === b[0] && a[1] === b[1]) {\\n            return true\\n        }\\n        const connKey = getConnKey(a, b, ball)\\n        if (connCache.has(connKey)) {\\n            return connCache.get(connKey)\\n        }\\n        const bKey = getKey(b)\\n        const ballKey = getKey(ball)\\n        const visited = new Array(m * n).fill(false)\\n        visited[getKey(a)] = true\\n        const queue = [a]\\n        while (queue.length) {\\n            const cell = queue.shift()\\n            for (let i = 0; i < dirs.length; i++) {\\n                const next = add(cell, dirs[i])\\n                if (validate(next)) {\\n                    const nextKey = getKey(next)\\n                    if (nextKey === bKey) {\\n                        connCache.set(connKey, true)\\n                        return true\\n                    }\\n                    if (\\n                        freeSet.has(nextKey) &&\\n                        nextKey !== ballKey &&\\n                        !visited[nextKey]\\n                    ) {\\n                        visited[nextKey] = true\\n                        queue.push(next)\\n                    }\\n                }\\n            }\\n        }\\n        connCache.set(connKey, false)\\n        return false\\n    }\\n\\n\\t// solve the game\\n    const getStateKey = ([x, y], [xx, yy]) => [x, y, xx, yy].join(\\',\\') // ball, player\\n    const stateCache = new Set() // Set<stateKey>\\n    let queue = [[ball, player]]\\n    let count = 1\\n    while (queue.length) {\\n        const nextQueue = []\\n        for (let i = 0; i < queue.length; i++) {\\n            const [ball, player] = queue[i]\\n            for (let j = 0; j < dirs.length; j++) {\\n                const dir = dirs[j]\\n                const reverseDir = [dir[0] ? -dir[0] : 0, dir[1] ? -dir[1] : 0]\\n                const nextBall = add(ball, dir)\\n                const nextPlayer = add(ball, reverseDir)\\n                const nextBallKey = getKey(nextBall)\\n                const nextPlayerKey = getKey(nextPlayer)\\n                if (\\n                    validate(nextBall) &&\\n                    validate(nextPlayer) &&\\n                    freeSet.has(nextBallKey) &&\\n                    freeSet.has(nextPlayerKey)\\n                ) {\\n                    const nextStateKey = getStateKey(nextBall, nextPlayer)\\n                    if (isConnected(player, nextPlayer, ball)) {\\n                        if (!stateCache.has(nextStateKey)) {\\n                            stateCache.add(nextStateKey)\\n                            if (nextBallKey === targetKey) {\\n                                return count\\n                            }\\n                            nextQueue.push([nextBall, nextPlayer])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue\\n        count++\\n    }\\n    return -1\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n\\t// common info & utils\\n    const m = grid.length\\n    const n = grid[0].length\\n    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const add = (a, b) => [a[0] + b[0], a[1] + b[1]]\\n    const equals = (a, b) => a[0] === b[0] && a[1] === b[1]\\n    const validate = ([x, y]) => x >= 0 && y >= 0 && x < m && y < n\\n    const getKey = ([x, y]) => x * n + y\\n\\n\\t// find all player, ball, target, and free cells\\n    const init = () => {\\n        let player\\n        let ball\\n        let target\\n        const freeSet = new Set()\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (grid[i][j] === \\'.\\') {\\n                    freeSet.add(getKey([i, j]))\\n                } else if (grid[i][j] === \\'S\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    player = [i, j]\\n                } else if (grid[i][j] === \\'B\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    ball = [i, j]\\n                } else if (grid[i][j] === \\'T\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    target = [i, j]\\n                }\\n            }\\n        }\\n        return { player, ball, target, freeSet }\\n    }\\n    const { player, ball, target, freeSet } = init()\\n    const targetKey = getKey(target)\\n\\n\\t// detect whether two cells are connected\\n    const connCache = new Map() // [x,y,x2,y2,x3,y3] => boolean\\n    const getConnKey = (a, b, ball) => {\\n        if (\\n            a[0] > b[0] ||\\n            a[0] === b[0] && a[1] > b[1]\\n        ) {\\n            [a, b] = [b, a]\\n        }\\n        return [a[0], a[1], b[0], b[1], ball[0], ball[1]].join(\\',\\')\\n    }\\n    const isConnected = (a, b, ball) => {\\n        if (a[0] === b[0] && a[1] === b[1]) {\\n            return true\\n        }\\n        const connKey = getConnKey(a, b, ball)\\n        if (connCache.has(connKey)) {\\n            return connCache.get(connKey)\\n        }\\n        const bKey = getKey(b)\\n        const ballKey = getKey(ball)\\n        const visited = new Array(m * n).fill(false)\\n        visited[getKey(a)] = true\\n        const queue = [a]\\n        while (queue.length) {\\n            const cell = queue.shift()\\n            for (let i = 0; i < dirs.length; i++) {\\n                const next = add(cell, dirs[i])\\n                if (validate(next)) {\\n                    const nextKey = getKey(next)\\n                    if (nextKey === bKey) {\\n                        connCache.set(connKey, true)\\n                        return true\\n                    }\\n                    if (\\n                        freeSet.has(nextKey) &&\\n                        nextKey !== ballKey &&\\n                        !visited[nextKey]\\n                    ) {\\n                        visited[nextKey] = true\\n                        queue.push(next)\\n                    }\\n                }\\n            }\\n        }\\n        connCache.set(connKey, false)\\n        return false\\n    }\\n\\n\\t// solve the game\\n    const getStateKey = ([x, y], [xx, yy]) => [x, y, xx, yy].join(\\',\\') // ball, player\\n    const stateCache = new Set() // Set<stateKey>\\n    let queue = [[ball, player]]\\n    let count = 1\\n    while (queue.length) {\\n        const nextQueue = []\\n        for (let i = 0; i < queue.length; i++) {\\n            const [ball, player] = queue[i]\\n            for (let j = 0; j < dirs.length; j++) {\\n                const dir = dirs[j]\\n                const reverseDir = [dir[0] ? -dir[0] : 0, dir[1] ? -dir[1] : 0]\\n                const nextBall = add(ball, dir)\\n                const nextPlayer = add(ball, reverseDir)\\n                const nextBallKey = getKey(nextBall)\\n                const nextPlayerKey = getKey(nextPlayer)\\n                if (\\n                    validate(nextBall) &&\\n                    validate(nextPlayer) &&\\n                    freeSet.has(nextBallKey) &&\\n                    freeSet.has(nextPlayerKey)\\n                ) {\\n                    const nextStateKey = getStateKey(nextBall, nextPlayer)\\n                    if (isConnected(player, nextPlayer, ball)) {\\n                        if (!stateCache.has(nextStateKey)) {\\n                            stateCache.add(nextStateKey)\\n                            if (nextBallKey === targetKey) {\\n                                return count\\n                            }\\n                            nextQueue.push([nextBall, nextPlayer])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue\\n        count++\\n    }\\n    return -1\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451102,
                "title": "weak-test-set",
                "content": "11 rows\\n41 columns\\n\\nExpected solution is 1.\\n\\nMy solution returns 7, but gets Accepted verdict.\\n\\n\\n```\\n#########################################\\n####################...................##\\n####################.#################.##\\n####################.#################.##\\n####################.#################.##\\n####################.#################.##\\n##########......T###.#################.##\\n##########......BS...#################.##\\n##########....##.#####################.##\\n##########....##.......................##\\n#########################################\\n```\\n\\n\\n(I created another Accepted solution that fixes this)",
                "solutionTags": [],
                "code": "```\\n#########################################\\n####################...................##\\n####################.#################.##\\n####################.#################.##\\n####################.#################.##\\n####################.#################.##\\n##########......T###.#################.##\\n##########......BS...#################.##\\n##########....##.#####################.##\\n##########....##.......................##\\n#########################################\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421722,
                "title": "java-bfs-bfs",
                "content": "```\\nclass Solution {\\n    public int minPushBox(char[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int px = -1, py = -1, bx = -1, by = -1, tx = -1, ty = -1;\\n        Set<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    px = i; py = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if(grid[i][j] == \\'B\\') {\\n                    bx = i; by = j;\\n                    grid[i][j] = \\'.\\';\\n                }\\n                if(grid[i][j] == \\'T\\') {\\n                    tx = i; ty = j;\\n                }\\n            }\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{px, py, bx, by});\\n        int ans = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size-- > 0) {\\n                int[] el = q.poll();\\n                if(el[2] == tx && el[3] == ty) return ans;\\n                int en = encode(el);\\n                if(seen.contains(en)) continue;\\n                seen.add(en);\\n                // try push\\n                for(int[] dir: dirs) {\\n                    int nbx = el[2] + dir[0], nby = el[3] + dir[1];\\n                    if(nbx < 0 || nbx >= row || nby < 0 || nby >= col || grid[nbx][nby] == \\'#\\') continue;\\n                    int npx = el[2] - dir[0], npy = el[3] - dir[1];\\n                    if(npx < 0 || npx >= row || npy < 0 || npy >= col || grid[npx][npy] == \\'#\\') continue;\\n                    if(reach(npx, npy, el[0], el[1], el[2], el[3], grid, row, col)) {\\n                        int[] nel = new int[4];\\n                        nel[0] = el[2]; nel[1] = el[3]; nel[2] = nbx; nel[3] = nby;\\n                        if(!seen.contains(encode(nel)))\\n                            q.add(nel);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean reach(int npx, int npy, int px, int py, int bx, int by, char[][] grid, int row, int col) {\\n        grid[bx][by] = \\'#\\';\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        q.add(new int[]{px, py, 0, 0});\\n        while(!q.isEmpty()) {\\n            int[] el = q.poll();\\n            if(el[0] == npx && el[1] == npy) {\\n                grid[bx][by] = \\'.\\';\\n                return true;\\n            }\\n            if(seen.contains(encode(el))) continue;\\n            seen.add(encode(el));\\n            for(int[] dir: dirs) {\\n                int nx = el[0] + dir[0], ny = el[1] + dir[1];\\n                int[] nel = new int[]{nx, ny, 0, 0};\\n                if(nx < 0 || nx >= row || ny < 0 || ny >= col || grid[nx][ny] == \\'#\\' || seen.contains(encode(nel))) continue;\\n                q.add(nel);\\n            }\\n        }\\n        grid[bx][by] = \\'.\\';\\n        return false;\\n    }\\n    \\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n    \\n    int encode(int[] el) {\\n        return el[0] + 20 * el[1] + 400 * el[2] + 8000 * el[3];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPushBox(char[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int px = -1, py = -1, bx = -1, by = -1, tx = -1, ty = -1;\\n        Set<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == \\'S\\') {\\n                    px = i; py = j;\\n                    grid[i][j] = \\'.\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2384359,
                "title": "python-dual-bfs",
                "content": "```python\\nfrom collections import deque\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        player_pos, box_pos, target_pos = self.find_player_box_target(grid)\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def is_valid_pos(x, y):\\n            return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != \\'#\\'\\n\\n        visited = set()\\n\\n        visited.add((player_pos, box_pos))\\n        q = deque([(player_pos, box_pos, 0)])\\n\\n        while q:\\n            player_pos, box_pos, d = q.popleft()\\n            if box_pos == target_pos:\\n                return d\\n\\n            box_x, box_y = box_pos\\n            reachable = [[False] * len(grid[0]) for _ in range(len(grid))]\\n            self.find_reachables_by_player(grid, player_pos, box_pos, reachable)\\n\\n            for x_dir, y_dir in dirs:\\n                new_box_x = box_x + x_dir\\n                new_box_y = box_y + y_dir\\n                behind_box_x = box_x - x_dir\\n                behind_box_y = box_y - y_dir\\n                next_person_pos = box_pos\\n                next_box_pos = (new_box_x, new_box_y)\\n                if (is_valid_pos(new_box_x, new_box_y) and is_valid_pos(behind_box_x, behind_box_y) and\\n                        reachable[behind_box_x][behind_box_y] and (next_person_pos, next_box_pos) not in visited):\\n                    visited.add((next_person_pos, next_box_pos))\\n                    q.append((next_person_pos, next_box_pos, d + 1))\\n        return -1\\n\\n    def find_reachables_by_player(self, grid, player_pos, box_pos, reachable):\\n        x, y = player_pos\\n        reachable[x][y] = True\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for x_dir, y_dir in dirs:\\n            new_x = x + x_dir\\n            new_y = y + y_dir\\n            if (0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] != \\'#\\' and\\n                    (new_x, new_y) != box_pos and not reachable[new_x][new_y]):\\n                self.find_reachables_by_player(grid, (new_x, new_y), box_pos, reachable)\\n\\n    def find_player_box_target(self, grid):\\n        player, box, target = None, None, None\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                elif grid[i][j] == \\'B\\':\\n                    box = (i, j)\\n                elif grid[i][j] == \\'T\\':\\n                    target = (i, j)\\n        return player, box, target\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        player_pos, box_pos, target_pos = self.find_player_box_target(grid)\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def is_valid_pos(x, y):\\n            return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != \\'#\\'\\n\\n        visited = set()\\n\\n        visited.add((player_pos, box_pos))\\n        q = deque([(player_pos, box_pos, 0)])\\n\\n        while q:\\n            player_pos, box_pos, d = q.popleft()\\n            if box_pos == target_pos:\\n                return d\\n\\n            box_x, box_y = box_pos\\n            reachable = [[False] * len(grid[0]) for _ in range(len(grid))]\\n            self.find_reachables_by_player(grid, player_pos, box_pos, reachable)\\n\\n            for x_dir, y_dir in dirs:\\n                new_box_x = box_x + x_dir\\n                new_box_y = box_y + y_dir\\n                behind_box_x = box_x - x_dir\\n                behind_box_y = box_y - y_dir\\n                next_person_pos = box_pos\\n                next_box_pos = (new_box_x, new_box_y)\\n                if (is_valid_pos(new_box_x, new_box_y) and is_valid_pos(behind_box_x, behind_box_y) and\\n                        reachable[behind_box_x][behind_box_y] and (next_person_pos, next_box_pos) not in visited):\\n                    visited.add((next_person_pos, next_box_pos))\\n                    q.append((next_person_pos, next_box_pos, d + 1))\\n        return -1\\n\\n    def find_reachables_by_player(self, grid, player_pos, box_pos, reachable):\\n        x, y = player_pos\\n        reachable[x][y] = True\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for x_dir, y_dir in dirs:\\n            new_x = x + x_dir\\n            new_y = y + y_dir\\n            if (0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] != \\'#\\' and\\n                    (new_x, new_y) != box_pos and not reachable[new_x][new_y]):\\n                self.find_reachables_by_player(grid, (new_x, new_y), box_pos, reachable)\\n\\n    def find_player_box_target(self, grid):\\n        player, box, target = None, None, None\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'S\\':\\n                    player = (i, j)\\n                elif grid[i][j] == \\'B\\':\\n                    box = (i, j)\\n                elif grid[i][j] == \\'T\\':\\n                    target = (i, j)\\n        return player, box, target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323373,
                "title": "javascript-solution-faster-than-100",
                "content": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n\\t// common info & utils\\n    const m = grid.length\\n    const n = grid[0].length\\n    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const add = (a, b) => [a[0] + b[0], a[1] + b[1]]\\n    const equals = (a, b) => a[0] === b[0] && a[1] === b[1]\\n    const validate = ([x, y]) => x >= 0 && y >= 0 && x < m && y < n\\n    const getKey = ([x, y]) => x * n + y\\n\\n\\t// find all player, ball, target, and free cells\\n    const init = () => {\\n        let player\\n        let ball\\n        let target\\n        const freeSet = new Set()\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (grid[i][j] === \\'.\\') {\\n                    freeSet.add(getKey([i, j]))\\n                } else if (grid[i][j] === \\'S\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    player = [i, j]\\n                } else if (grid[i][j] === \\'B\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    ball = [i, j]\\n                } else if (grid[i][j] === \\'T\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    target = [i, j]\\n                }\\n            }\\n        }\\n        return { player, ball, target, freeSet }\\n    }\\n    const { player, ball, target, freeSet } = init()\\n    const targetKey = getKey(target)\\n\\n\\t// detect whether two cells are connected\\n    const connCache = new Map() // [x,y,x2,y2,x3,y3] => boolean\\n    const getConnKey = (a, b, ball) => {\\n        if (\\n            a[0] > b[0] ||\\n            a[0] === b[0] && a[1] > b[1]\\n        ) {\\n            [a, b] = [b, a]\\n        }\\n        return [a[0], a[1], b[0], b[1], ball[0], ball[1]].join(\\',\\')\\n    }\\n    const isConnected = (a, b, ball) => {\\n        if (a[0] === b[0] && a[1] === b[1]) {\\n            return true\\n        }\\n        const connKey = getConnKey(a, b, ball)\\n        if (connCache.has(connKey)) {\\n            return connCache.get(connKey)\\n        }\\n        const bKey = getKey(b)\\n        const ballKey = getKey(ball)\\n        const visited = new Array(m * n).fill(false)\\n        visited[getKey(a)] = true\\n        const queue = [a]\\n        while (queue.length) {\\n            const cell = queue.shift()\\n            for (let i = 0; i < dirs.length; i++) {\\n                const next = add(cell, dirs[i])\\n                if (validate(next)) {\\n                    const nextKey = getKey(next)\\n                    if (nextKey === bKey) {\\n                        connCache.set(connKey, true)\\n                        return true\\n                    }\\n                    if (\\n                        freeSet.has(nextKey) &&\\n                        nextKey !== ballKey &&\\n                        !visited[nextKey]\\n                    ) {\\n                        visited[nextKey] = true\\n                        queue.push(next)\\n                    }\\n                }\\n            }\\n        }\\n        connCache.set(connKey, false)\\n        return false\\n    }\\n\\n\\t// solve the game\\n    const getStateKey = ([x, y], [xx, yy]) => [x, y, xx, yy].join(\\',\\') // ball, player\\n    const stateCache = new Set() // Set<stateKey>\\n    let queue = [[ball, player]]\\n    let count = 1\\n    while (queue.length) {\\n        const nextQueue = []\\n        for (let i = 0; i < queue.length; i++) {\\n            const [ball, player] = queue[i]\\n            for (let j = 0; j < dirs.length; j++) {\\n                const dir = dirs[j]\\n                const reverseDir = [dir[0] ? -dir[0] : 0, dir[1] ? -dir[1] : 0]\\n                const nextBall = add(ball, dir)\\n                const nextPlayer = add(ball, reverseDir)\\n                const nextBallKey = getKey(nextBall)\\n                const nextPlayerKey = getKey(nextPlayer)\\n                if (\\n                    validate(nextBall) &&\\n                    validate(nextPlayer) &&\\n                    freeSet.has(nextBallKey) &&\\n                    freeSet.has(nextPlayerKey)\\n                ) {\\n                    const nextStateKey = getStateKey(nextBall, nextPlayer)\\n                    if (isConnected(player, nextPlayer, ball)) {\\n                        if (!stateCache.has(nextStateKey)) {\\n                            stateCache.add(nextStateKey)\\n                            if (nextBallKey === targetKey) {\\n                                return count\\n                            }\\n                            nextQueue.push([nextBall, nextPlayer])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue\\n        count++\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n\\t// common info & utils\\n    const m = grid.length\\n    const n = grid[0].length\\n    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const add = (a, b) => [a[0] + b[0], a[1] + b[1]]\\n    const equals = (a, b) => a[0] === b[0] && a[1] === b[1]\\n    const validate = ([x, y]) => x >= 0 && y >= 0 && x < m && y < n\\n    const getKey = ([x, y]) => x * n + y\\n\\n\\t// find all player, ball, target, and free cells\\n    const init = () => {\\n        let player\\n        let ball\\n        let target\\n        const freeSet = new Set()\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (grid[i][j] === \\'.\\') {\\n                    freeSet.add(getKey([i, j]))\\n                } else if (grid[i][j] === \\'S\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    player = [i, j]\\n                } else if (grid[i][j] === \\'B\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    ball = [i, j]\\n                } else if (grid[i][j] === \\'T\\') {\\n                    freeSet.add(getKey([i, j]))\\n                    target = [i, j]\\n                }\\n            }\\n        }\\n        return { player, ball, target, freeSet }\\n    }\\n    const { player, ball, target, freeSet } = init()\\n    const targetKey = getKey(target)\\n\\n\\t// detect whether two cells are connected\\n    const connCache = new Map() // [x,y,x2,y2,x3,y3] => boolean\\n    const getConnKey = (a, b, ball) => {\\n        if (\\n            a[0] > b[0] ||\\n            a[0] === b[0] && a[1] > b[1]\\n        ) {\\n            [a, b] = [b, a]\\n        }\\n        return [a[0], a[1], b[0], b[1], ball[0], ball[1]].join(\\',\\')\\n    }\\n    const isConnected = (a, b, ball) => {\\n        if (a[0] === b[0] && a[1] === b[1]) {\\n            return true\\n        }\\n        const connKey = getConnKey(a, b, ball)\\n        if (connCache.has(connKey)) {\\n            return connCache.get(connKey)\\n        }\\n        const bKey = getKey(b)\\n        const ballKey = getKey(ball)\\n        const visited = new Array(m * n).fill(false)\\n        visited[getKey(a)] = true\\n        const queue = [a]\\n        while (queue.length) {\\n            const cell = queue.shift()\\n            for (let i = 0; i < dirs.length; i++) {\\n                const next = add(cell, dirs[i])\\n                if (validate(next)) {\\n                    const nextKey = getKey(next)\\n                    if (nextKey === bKey) {\\n                        connCache.set(connKey, true)\\n                        return true\\n                    }\\n                    if (\\n                        freeSet.has(nextKey) &&\\n                        nextKey !== ballKey &&\\n                        !visited[nextKey]\\n                    ) {\\n                        visited[nextKey] = true\\n                        queue.push(next)\\n                    }\\n                }\\n            }\\n        }\\n        connCache.set(connKey, false)\\n        return false\\n    }\\n\\n\\t// solve the game\\n    const getStateKey = ([x, y], [xx, yy]) => [x, y, xx, yy].join(\\',\\') // ball, player\\n    const stateCache = new Set() // Set<stateKey>\\n    let queue = [[ball, player]]\\n    let count = 1\\n    while (queue.length) {\\n        const nextQueue = []\\n        for (let i = 0; i < queue.length; i++) {\\n            const [ball, player] = queue[i]\\n            for (let j = 0; j < dirs.length; j++) {\\n                const dir = dirs[j]\\n                const reverseDir = [dir[0] ? -dir[0] : 0, dir[1] ? -dir[1] : 0]\\n                const nextBall = add(ball, dir)\\n                const nextPlayer = add(ball, reverseDir)\\n                const nextBallKey = getKey(nextBall)\\n                const nextPlayerKey = getKey(nextPlayer)\\n                if (\\n                    validate(nextBall) &&\\n                    validate(nextPlayer) &&\\n                    freeSet.has(nextBallKey) &&\\n                    freeSet.has(nextPlayerKey)\\n                ) {\\n                    const nextStateKey = getStateKey(nextBall, nextPlayer)\\n                    if (isConnected(player, nextPlayer, ball)) {\\n                        if (!stateCache.has(nextStateKey)) {\\n                            stateCache.add(nextStateKey)\\n                            if (nextBallKey === targetKey) {\\n                                return count\\n                            }\\n                            nextQueue.push([nextBall, nextPlayer])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue\\n        count++\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286029,
                "title": "c-solution-based-on-bfs",
                "content": "```\\nclass Unit{\\npublic:\\n    int cy;\\n    int cx;\\n    int by;\\n    int bx;\\n    int push;\\n    Unit(){\\n        this->cy = -1;\\n        this->cx = -1;\\n        this->by = -1;\\n        this->bx = -1;\\n    }\\n    Unit(int cy, int cx, int by, int bx){\\n        this->cy = cy;\\n        this->cx = cx;\\n        this->by = by;\\n        this->bx = bx;\\n        this->push = 0;\\n    }\\n    Unit(int cy, int cx, int by, int bx, int push){\\n        this->cy = cy;\\n        this->cx = cx;        \\n        this->by = by;\\n        this->bx = bx;\\n        this->push = push;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int temp[50][50];\\n    vector<pair<int, int>> dots;\\n    int minPushBox(vector<vector<char>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size();\\n        int start_y, start_x;\\n        int target_y, target_x;\\n        int cue_y, cue_x;\\n        for (int y = 0; y < m; y++){\\n            for (int x = 0; x < n; x++){\\n                if (grid[y][x] != \\'#\\'){\\n                    dots.push_back({y, x});\\n                }\\n                if (grid[y][x] == \\'B\\'){\\n                    start_y = y;\\n                    start_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n                if (grid[y][x] == \\'T\\'){\\n                    target_y = y;\\n                    target_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n                if (grid[y][x] == \\'S\\'){\\n                    cue_y = y, cue_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n            }\\n        }\\n        /* the box starts from [start_y, start_x], our aim is [target_y, target_x]\\n        */\\n        int nd[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<Unit> units; units.push(Unit(cue_y, cue_x, start_y, start_x));\\n        vector<vector<vector<vector<int>>>> marked(m, vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(n, INT_MAX))));  \\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                Unit unit = units.front();  units.pop();\\n                if (unit.by == target_y && unit.bx == target_x){\\n                    return unit.push;\\n                }\\n                // unit.y, unit.x, unit.push\\n                for (int k = 0; k < 4; k++){\\n                    int ny = unit.by + nd[k][0], nx = unit.bx + nd[k][1];\\n                    int py = unit.by - nd[k][0], px = unit.bx - nd[k][1];\\n                    if (ny >= 0 && ny < m && nx >= 0 && nx < n \\n                        && py >= 0 && py < m && px >= 0 && px < n){\\n                        /*  if we can go to [py, px]->[y, x]->[ny, nx]\\n                            [cue_y, cue_x] -> [py, px] must be available\\n                        */\\n                        if (is_available(grid, m, n, unit.cy, unit.cx, py, px, unit.by, unit.bx)){\\n                            // printf(\"available.\\\\n\");\\n                            if (grid[ny][nx] == \\'.\\' && grid[py][px] == \\'.\\'){\\n                                int update_push = unit.push + 1;\\n                                if (update_push < marked[unit.by][unit.bx][ny][nx]){\\n                                    // printf(\"move from [y=%d, x=%d] to [ny=%d, nx=%d]\\\\n\", unit.y, unit.x, ny, nx);\\n                                    marked[unit.by][unit.bx][ny][nx] = update_push;\\n                                    units.push(Unit(unit.by, unit.bx, ny, nx, unit.push + 1));\\n                                }\\n                            }                            \\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    bool is_available(vector<vector<char>>& grid, int m, int n, int cy, int cx, int py, int px, int by, int bx){\\n        \\n        int nd[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<Unit> units;  units.push(Unit(cy, cx, by, bx));\\n        for (auto pair: this->dots){\\n            this->temp[pair.first][pair.second] = INT_MAX;\\n        }\\n        this->temp[cy][cx] = 0;\\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                Unit unit = units.front();  units.pop();\\n                if (unit.cy == py && unit.cx == px){\\n                    return true;\\n                }\\n                for (int k = 0; k < 4; k++){\\n                    int ny = unit.cy + nd[k][0], nx = unit.cx + nd[k][1];\\n                    if (ny >= 0 && ny < m && nx >= 0 && nx < n){\\n                        if (grid[ny][nx] == \\'.\\' && (ny != by || nx != bx)){\\n                            int update_push = unit.push + 1;\\n                            if (update_push < this->temp[ny][nx]){\\n                                this->temp[ny][nx] = update_push;\\n                                units.push(Unit(ny, nx, by, bx, update_push));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Unit{\\npublic:\\n    int cy;\\n    int cx;\\n    int by;\\n    int bx;\\n    int push;\\n    Unit(){\\n        this->cy = -1;\\n        this->cx = -1;\\n        this->by = -1;\\n        this->bx = -1;\\n    }\\n    Unit(int cy, int cx, int by, int bx){\\n        this->cy = cy;\\n        this->cx = cx;\\n        this->by = by;\\n        this->bx = bx;\\n        this->push = 0;\\n    }\\n    Unit(int cy, int cx, int by, int bx, int push){\\n        this->cy = cy;\\n        this->cx = cx;        \\n        this->by = by;\\n        this->bx = bx;\\n        this->push = push;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int temp[50][50];\\n    vector<pair<int, int>> dots;\\n    int minPushBox(vector<vector<char>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size();\\n        int start_y, start_x;\\n        int target_y, target_x;\\n        int cue_y, cue_x;\\n        for (int y = 0; y < m; y++){\\n            for (int x = 0; x < n; x++){\\n                if (grid[y][x] != \\'#\\'){\\n                    dots.push_back({y, x});\\n                }\\n                if (grid[y][x] == \\'B\\'){\\n                    start_y = y;\\n                    start_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n                if (grid[y][x] == \\'T\\'){\\n                    target_y = y;\\n                    target_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n                if (grid[y][x] == \\'S\\'){\\n                    cue_y = y, cue_x = x;\\n                    grid[y][x] = \\'.\\';\\n                }\\n            }\\n        }\\n        /* the box starts from [start_y, start_x], our aim is [target_y, target_x]\\n        */\\n        int nd[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<Unit> units; units.push(Unit(cue_y, cue_x, start_y, start_x));\\n        vector<vector<vector<vector<int>>>> marked(m, vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(n, INT_MAX))));  \\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                Unit unit = units.front();  units.pop();\\n                if (unit.by == target_y && unit.bx == target_x){\\n                    return unit.push;\\n                }\\n                // unit.y, unit.x, unit.push\\n                for (int k = 0; k < 4; k++){\\n                    int ny = unit.by + nd[k][0], nx = unit.bx + nd[k][1];\\n                    int py = unit.by - nd[k][0], px = unit.bx - nd[k][1];\\n                    if (ny >= 0 && ny < m && nx >= 0 && nx < n \\n                        && py >= 0 && py < m && px >= 0 && px < n){\\n                        /*  if we can go to [py, px]->[y, x]->[ny, nx]\\n                            [cue_y, cue_x] -> [py, px] must be available\\n                        */\\n                        if (is_available(grid, m, n, unit.cy, unit.cx, py, px, unit.by, unit.bx)){\\n                            // printf(\"available.\\\\n\");\\n                            if (grid[ny][nx] == \\'.\\' && grid[py][px] == \\'.\\'){\\n                                int update_push = unit.push + 1;\\n                                if (update_push < marked[unit.by][unit.bx][ny][nx]){\\n                                    // printf(\"move from [y=%d, x=%d] to [ny=%d, nx=%d]\\\\n\", unit.y, unit.x, ny, nx);\\n                                    marked[unit.by][unit.bx][ny][nx] = update_push;\\n                                    units.push(Unit(unit.by, unit.bx, ny, nx, unit.push + 1));\\n                                }\\n                            }                            \\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    bool is_available(vector<vector<char>>& grid, int m, int n, int cy, int cx, int py, int px, int by, int bx){\\n        \\n        int nd[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<Unit> units;  units.push(Unit(cy, cx, by, bx));\\n        for (auto pair: this->dots){\\n            this->temp[pair.first][pair.second] = INT_MAX;\\n        }\\n        this->temp[cy][cx] = 0;\\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                Unit unit = units.front();  units.pop();\\n                if (unit.cy == py && unit.cx == px){\\n                    return true;\\n                }\\n                for (int k = 0; k < 4; k++){\\n                    int ny = unit.cy + nd[k][0], nx = unit.cx + nd[k][1];\\n                    if (ny >= 0 && ny < m && nx >= 0 && nx < n){\\n                        if (grid[ny][nx] == \\'.\\' && (ny != by || nx != bx)){\\n                            int update_push = unit.push + 1;\\n                            if (update_push < this->temp[ny][nx]){\\n                                this->temp[ny][nx] = update_push;\\n                                units.push(Unit(ny, nx, by, bx, update_push));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279461,
                "title": "python-bfs-dfs",
                "content": "```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        # dfs to move person\\n        # bfs to move box\\n        m = len(grid)\\n        n = len(grid[0])\\n        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"S\":\\n                    si, sj = i, j\\n                if grid[i][j] == \"B\":\\n                    bi, bj = i, j\\n                if grid[i][j] == \"T\":\\n                    tari, tarj = i, j\\n        \\n        def ok(i, j, bi=-1, bj=-1):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            if grid[i][j] == \"#\" or (i == bi and j == bj):\\n                return False\\n            return True\\n        \\n        def p_reachable(si, sj, ti, tj, bi, bj):\\n            if not ok(ti, tj, bi, bj):\\n                return False\\n            vis = set()\\n            def dfs(i, j):\\n                vis.add((i, j))\\n                if i == ti and j == tj:\\n                    return True\\n                flag = False\\n                for d in dirc:\\n                    newi, newj = i + d[0], j + d[1]\\n                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:\\n                        flag = flag or dfs(newi, newj)\\n                return flag\\n            return dfs(si, sj)\\n        \\n        queue = deque()\\n        queue.append(((bi, bj), (si, sj)))\\n        bvis = set()\\n        cnt = 0\\n        while queue:\\n            l = len(queue)\\n            for i in range(l):\\n                cur = queue.popleft()\\n                if cur[0][0] == tari and cur[0][1] == tarj:\\n                    return cnt\\n                for d in dirc:\\n                    newbi = cur[0][0] + d[0]\\n                    newsi = cur[0][0] - d[0]\\n                    newbj = cur[0][1] + d[1]\\n                    newsj = cur[0][1] - d[1]\\n                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):\\n                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))\\n                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))\\n            cnt += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        # dfs to move person\\n        # bfs to move box\\n        m = len(grid)\\n        n = len(grid[0])\\n        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"S\":\\n                    si, sj = i, j\\n                if grid[i][j] == \"B\":\\n                    bi, bj = i, j\\n                if grid[i][j] == \"T\":\\n                    tari, tarj = i, j\\n        \\n        def ok(i, j, bi=-1, bj=-1):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            if grid[i][j] == \"#\" or (i == bi and j == bj):\\n                return False\\n            return True\\n        \\n        def p_reachable(si, sj, ti, tj, bi, bj):\\n            if not ok(ti, tj, bi, bj):\\n                return False\\n            vis = set()\\n            def dfs(i, j):\\n                vis.add((i, j))\\n                if i == ti and j == tj:\\n                    return True\\n                flag = False\\n                for d in dirc:\\n                    newi, newj = i + d[0], j + d[1]\\n                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:\\n                        flag = flag or dfs(newi, newj)\\n                return flag\\n            return dfs(si, sj)\\n        \\n        queue = deque()\\n        queue.append(((bi, bj), (si, sj)))\\n        bvis = set()\\n        cnt = 0\\n        while queue:\\n            l = len(queue)\\n            for i in range(l):\\n                cur = queue.popleft()\\n                if cur[0][0] == tari and cur[0][1] == tarj:\\n                    return cnt\\n                for d in dirc:\\n                    newbi = cur[0][0] + d[0]\\n                    newsi = cur[0][0] - d[0]\\n                    newbj = cur[0][1] + d[1]\\n                    newsj = cur[0][1] - d[1]\\n                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):\\n                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))\\n                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))\\n            cnt += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257156,
                "title": "python3-a-beat-100",
                "content": "A* version of [zypher27\\'s solution](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/693918/Python-BFS-*-BFS-or-130ms-or-beats-95-or-Explained-and-Commented)\\n\\n[A great explanation of A* algorithm](http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html)\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n        \\n        def valid(pos) -> bool:\\n            nonlocal grid, m, n\\n            return 0<=pos[0]<m and 0<=pos[1]<n and grid[pos[0]][pos[1]]!=\\'#\\'\\n        \\n        def manhattan_dist(p1, p2) -> int:\\n            return abs(p1[0]-p2[0]) +abs(p1[1]-p2[1])\\n        \\n        def check(s, d, box) -> bool:\\n            open_set = [(manhattan_dist(s, d), 0, s)]\\n            vis = {s, box}\\n            while open_set:\\n                _, dist, pos = heapq.heappop(open_set)\\n                if pos == d:\\n                    return True\\n                for new_pos in [(pos[0]+1, pos[1]), (pos[0]-1, pos[1]), (pos[0], pos[1]+1), (pos[0], pos[1]-1)]:\\n                    if valid(new_pos) and new_pos not in vis:\\n                        vis.add(new_pos)\\n                        heapq.heappush(open_set, (dist+1+manhattan_dist(new_pos, d), dist+1, new_pos))\\n            return False\\n        \\n        \\n        open_set = [(manhattan_dist(box, target), 0, box, person)]\\n        vis = {box+person}\\n        while open_set:\\n            _, dist, box, person = heapq.heappop(open_set)\\n            if box == target:\\n                return dist\\n            b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\\n            p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\\n            for new_box,new_person in zip(b_coord,p_coord): \\n                if valid(new_box) and valid(new_person) and new_box+box not in vis and check(person, new_person, box):\\n                    vis.add(new_box+box)\\n                    heapq.heappush(open_set,(dist+1+manhattan_dist(new_box, target), dist+1, new_box, box))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n        \\n        def valid(pos) -> bool:\\n            nonlocal grid, m, n\\n            return 0<=pos[0]<m and 0<=pos[1]<n and grid[pos[0]][pos[1]]!=\\'#\\'\\n        \\n        def manhattan_dist(p1, p2) -> int:\\n            return abs(p1[0]-p2[0]) +abs(p1[1]-p2[1])\\n        \\n        def check(s, d, box) -> bool:\\n            open_set = [(manhattan_dist(s, d), 0, s)]\\n            vis = {s, box}\\n            while open_set:\\n                _, dist, pos = heapq.heappop(open_set)\\n                if pos == d:\\n                    return True\\n                for new_pos in [(pos[0]+1, pos[1]), (pos[0]-1, pos[1]), (pos[0], pos[1]+1), (pos[0], pos[1]-1)]:\\n                    if valid(new_pos) and new_pos not in vis:\\n                        vis.add(new_pos)\\n                        heapq.heappush(open_set, (dist+1+manhattan_dist(new_pos, d), dist+1, new_pos))\\n            return False\\n        \\n        \\n        open_set = [(manhattan_dist(box, target), 0, box, person)]\\n        vis = {box+person}\\n        while open_set:\\n            _, dist, box, person = heapq.heappop(open_set)\\n            if box == target:\\n                return dist\\n            b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\\n            p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\\n            for new_box,new_person in zip(b_coord,p_coord): \\n                if valid(new_box) and valid(new_person) and new_box+box not in vis and check(person, new_person, box):\\n                    vis.add(new_box+box)\\n                    heapq.heappush(open_set,(dist+1+manhattan_dist(new_box, target), dist+1, new_box, box))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215035,
                "title": "bfs-o-n-n-n-n-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[21][21][21][21];\\n    bool find(vector<vector<char>>& grid,int i1,int j1,int s1,int s2,int i2,int j2)\\n    {\\n         int m=grid.size(),n=grid[0].size();\\n        queue<pair<int,int>>qmt;\\n        qmt.push({s1,s2});\\n        vector<vector<int>>vst(m,vector<int>(n,0));\\n        vst[s1][s2]=1;\\n         while(qmt.size()>0)\\n        {\\n            pair<int,int>p=qmt.front();\\n            qmt.pop();\\n            int x=p.first,y=p.second;\\n            if(x==i2&&y==j2)return true;\\n            \\nif(x+1<m&&grid[x+1][y]!=\\'#\\'&&vst[x+1][y]==0&&(x+1!=i1||y!=j1)){qmt.push({x+1,y});vst[x+1][y]=1;}\\nif(x-1>=0&&grid[x-1][y]!=\\'#\\'&&vst[x-1][y]==0&&(x-1!=i1||y!=j1)){qmt.push({x-1,y});vst[x-1][y]=1;}\\nif(y+1<n&&grid[x][y+1]!=\\'#\\'&&vst[x][y+1]==0&&(x!=i1||y+1!=j1)){qmt.push({x,y+1});vst[x][y+1]=1;}\\nif(y-1>=0&&grid[x][y-1]!=\\'#\\'&&vst[x][y-1]==0&&(x!=i1||y-1!=j1)){qmt.push({x,y-1});vst[x][y-1];}\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int bi=0,bj=0,si=0,sj=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==\\'B\\'){bi=i;bj=j;}\\n                if(grid[i][j]==\\'S\\'){si=i;sj=j;}\\n            }\\n        }\\n        queue<vector<int>>qmt;\\n        memset(dp,0,sizeof(dp));\\n        qmt.push({bi,bj,si,sj,0});\\n        dp[bi][bj][si][sj]=1;\\n        while(qmt.size()>0)\\n        {\\n            vector<int>p=qmt.front();\\n            qmt.pop();\\n            int i=p[0],j=p[1],i1=p[2],j1=p[3],lvl=p[4];\\n            if(grid[i][j]==\\'T\\')return lvl;\\n           // cout<<i<<j<<i1<<j1<<\"\\\\n\";\\n\\nif(i-1>=0&&grid[i-1][j]!=\\'#\\'&&find(grid,i,j,i1,j1,i+1,j)==true&&dp[i-1][j][i][j]==0)\\n{qmt.push({i-1,j,i,j,lvl+1});dp[i-1][j][i][j]=1;}\\n            \\nif(j-1>=0&&grid[i][j-1]!=\\'#\\'&&find(grid,i,j,i1,j1,i,j+1)==true&&dp[i][j-1][i][j]==0)\\n{qmt.push({i,j-1,i,j,lvl+1});dp[i][j-1][i][j]=1;}\\n            \\nif(i+1<m&&grid[i+1][j]!=\\'#\\'&&find(grid,i,j,i1,j1,i-1,j)==true&&dp[i+1][j][i][j]==0)\\n{qmt.push({i+1,j,i,j,lvl+1});dp[i+1][j][i][j]=1;}\\n            \\nif(j+1<n&&grid[i][j+1]!=\\'#\\'&&find(grid,i,j,i1,j1,i,j-1)==true&&dp[i][j+1][i][j]==0)\\n{qmt.push({i,j+1,i,j,lvl+1});dp[i][j+1][i][j]=1;}\\n                \\n\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[21][21][21][21];\\n    bool find(vector<vector<char>>& grid,int i1,int j1,int s1,int s2,int i2,int j2)\\n    {\\n         int m=grid.size(),n=grid[0].size();\\n        queue<pair<int,int>>qmt;\\n        qmt.push({s1,s2});\\n        vector<vector<int>>vst(m,vector<int>(n,0));\\n        vst[s1][s2]=1;\\n         while(qmt.size()>0)\\n        {\\n            pair<int,int>p=qmt.front();\\n            qmt.pop();\\n            int x=p.first,y=p.second;\\n            if(x==i2&&y==j2)return true;\\n            \\nif(x+1<m&&grid[x+1][y]!=\\'#\\'&&vst[x+1][y]==0&&(x+1!=i1||y!=j1)){qmt.push({x+1,y});vst[x+1][y]=1;}\\nif(x-1>=0&&grid[x-1][y]!=\\'#\\'&&vst[x-1][y]==0&&(x-1!=i1||y!=j1)){qmt.push({x-1,y});vst[x-1][y]=1;}\\nif(y+1<n&&grid[x][y+1]!=\\'#\\'&&vst[x][y+1]==0&&(x!=i1||y+1!=j1)){qmt.push({x,y+1});vst[x][y+1]=1;}\\nif(y-1>=0&&grid[x][y-1]!=\\'#\\'&&vst[x][y-1]==0&&(x!=i1||y-1!=j1)){qmt.push({x,y-1});vst[x][y-1];}\\n        }\\n        return false;\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int bi=0,bj=0,si=0,sj=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==\\'B\\'){bi=i;bj=j;}\\n                if(grid[i][j]==\\'S\\'){si=i;sj=j;}\\n            }\\n        }\\n        queue<vector<int>>qmt;\\n        memset(dp,0,sizeof(dp));\\n        qmt.push({bi,bj,si,sj,0});\\n        dp[bi][bj][si][sj]=1;\\n        while(qmt.size()>0)\\n        {\\n            vector<int>p=qmt.front();\\n            qmt.pop();\\n            int i=p[0],j=p[1],i1=p[2],j1=p[3],lvl=p[4];\\n            if(grid[i][j]==\\'T\\')return lvl;\\n           // cout<<i<<j<<i1<<j1<<\"\\\\n\";\\n\\nif(i-1>=0&&grid[i-1][j]!=\\'#\\'&&find(grid,i,j,i1,j1,i+1,j)==true&&dp[i-1][j][i][j]==0)\\n{qmt.push({i-1,j,i,j,lvl+1});dp[i-1][j][i][j]=1;}\\n            \\nif(j-1>=0&&grid[i][j-1]!=\\'#\\'&&find(grid,i,j,i1,j1,i,j+1)==true&&dp[i][j-1][i][j]==0)\\n{qmt.push({i,j-1,i,j,lvl+1});dp[i][j-1][i][j]=1;}\\n            \\nif(i+1<m&&grid[i+1][j]!=\\'#\\'&&find(grid,i,j,i1,j1,i-1,j)==true&&dp[i+1][j][i][j]==0)\\n{qmt.push({i+1,j,i,j,lvl+1});dp[i+1][j][i][j]=1;}\\n            \\nif(j+1<n&&grid[i][j+1]!=\\'#\\'&&find(grid,i,j,i1,j1,i,j-1)==true&&dp[i][j+1][i][j]==0)\\n{qmt.push({i,j+1,i,j,lvl+1});dp[i][j+1][i][j]=1;}\\n                \\n\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2213173,
                "title": "java-bfs-bfs-with-detailed-comments",
                "content": "```\\n/**\\nThe algorithm is not too hard though it took me a long time to write the actual code\\n\\nUse An augmented BFS to find \"pushable positions\" among the box\\'s neighbors\\n1. Find all neighbors of a box where it can be successfully pushed. \\n   We\\'ll need to do a BFS from the  player\\'s current position to determine if the box can be pushed successfully\\n2. Record each neighbor and the push direction to avoid revisiting the cell in a similar manner.\\n   It\\'s okay to visit a cell more than once but only if the direction of the push from the cell is different\\n3. Update players location to box\\'s current location\\n4. Push each neighbor to a queue\\n5. Repeat until queue is empty\\n\\n**/\\nclass Solution {\\n    char[][] grid;\\n    int[][] directions = new int[][]{{0,1},{0,-1},{-1,0},{1,0}};\\n    \\n    public int minPushBox(char[][] grid) {\\n        this.grid = grid;\\n        \\n        int[] start = new int[2], end = new int[2],  player = new int[2];\\n        \\n        for (int i = 0; i < this.grid.length; i++){\\n            for (int j = 0; j < this.grid[0].length; j++){\\n                if (this.grid[i][j] == \\'S\\'){\\n                    player[0] = i;\\n                    player[1] = j;\\n                }\\n                else if (this.grid[i][j] == \\'B\\'){\\n                    start[0] = i;\\n                    start[1] = j;\\n                }\\n                else if (this.grid[i][j] == \\'T\\'){\\n                    end[0] = i;\\n                    end[1] = j;\\n                }\\n            }\\n        }\\n        Queue<int[][]> q = new ArrayDeque();\\n        //Track if we have visted a cell going in a certain direction\\n        boolean[][][] visited = new boolean[this.grid.length][this.grid[0].length][4];\\n        \\n        //Push first location to queue. Note since we haven\\'t attempted to push the box yet, we don\\'t mark it as visited \\n        q.add(new int[][]{{start[0],start[1]}, {player[0], player[1]}, {0}});\\n       \\n        while (q.size() > 0){\\n            int[][] item =  q.poll();\\n            int[] boxLoc = item[0];\\n            int[] playerLoc = item[1];\\n            int dist = item[2][0];\\n            int row = boxLoc[0], col = boxLoc[1];\\n            \\n            if (row == end[0] && col == end[1]) return dist;\\n            \\n            for (int i = 0; i < directions.length; i++){\\n                int[] d = directions[i];\\n                int newRow = row+d[0];\\n                int newCol = col+d[1];\\n                if (newRow >=0 && newRow < this.grid.length && newCol >= 0 && newCol < this.grid[0].length && this.grid[newRow][newCol] != \\'#\\' && !visited[newRow][newCol][i]){\\n                    if (canPush(boxLoc, i, playerLoc)){\\n                        q.add(new int[][]{{newRow, newCol}, {row, col}, {dist+1}});\\n                        // Mark neighbor as visited as we know a successful push can happen\\n                        visited[newRow][newCol][i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    /**\\n    Checks if the player can can push the in a certain direction given the box\\' and player\\'s current location. \\n\\tSimple BFS to check if the player can reach the point needed to push the box.\\n    **/\\n    private boolean canPush(int[] boxLoc, int direction, int[] playerStart){\\n        // Player\\'s desired location           \\n        int [] playerDest = new int[2];\\n        playerDest[0] = boxLoc[0] - this.directions[direction][0];\\n        playerDest[1] = boxLoc[1] - this.directions[direction][1];\\n       \\n        if (playerDest[0] < 0 || playerDest[1] < 0 || playerDest[0] >= this.grid.length || playerDest[1] >= this.grid[0].length || this.grid[playerDest[0]][playerDest[1]] == \\'#\\'){\\n            return false;\\n        }\\n        \\n        Queue<int[]> q = new ArrayDeque();\\n        boolean [][] visited = new boolean[this.grid.length][this.grid[0].length];\\n        \\n        q.add(playerStart);\\n        visited[playerStart[0]][playerStart[1]] = true;\\n        while(q.size() > 0){\\n            int[] currentPlayerLoc = q.poll();\\n            int row = currentPlayerLoc[0], col = currentPlayerLoc[1];\\n            if(row == playerDest[0] && col == playerDest[1]){\\n                return true;\\n            }\\n            for (int i = 0; i < directions.length; i++){\\n                int[] d = directions[i];\\n                int newRow = row+d[0];\\n                int newCol = col+d[1];\\n                if (newRow >=0 && newRow < this.grid.length && newCol >=0 && newCol < this.grid[0].length && this.grid[newRow][newCol] != \\'#\\' && !visited[newRow][newCol] && !(newRow == boxLoc[0] && newCol == boxLoc[1])){\\n                    q.add(new int[]{newRow, newCol});\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return false;\\n   }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    char[][] grid;\\n    int[][] directions = new int[][]{{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2185484,
                "title": "dual-bfs-dirty-java",
                "content": "Everytime I met it, I want to give up doing LeetCode. It is not difficult when you have done it for more than twice, but no happiness is felt after being AC.\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    char[][] grid;\\n    public int minPushBox(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int xPlayer = -1;\\n        int yPlayer = -1;\\n        int xBox = -1;\\n        int yBox = -1;\\n        int xTarget = -1;\\n        int yTarget = -1;\\n        this.grid = grid;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\')  {\\n                    xPlayer = i;\\n                    yPlayer = j;\\n                }\\n                else if (grid[i][j] == \\'B\\') {\\n                    xBox = i;\\n                    yBox = j;\\n                }\\n                else if (grid[i][j] == \\'T\\') {\\n                    xTarget = i;\\n                    yTarget = j;\\n                }\\n            }\\n        }\\n        \\n        Deque<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[m][n][4];\\n        q.offer(new int[] {0, -1, xPlayer, yPlayer, xBox, yBox});\\n        \\n        while (!q.isEmpty())    {\\n            int[] curr = q.poll();\\n            int px = curr[2];\\n            int py = curr[3];\\n            int bx = curr[4];\\n            int by = curr[5];\\n            int cnt = curr[0];\\n            int currDir = curr[1];\\n            if (currDir != -1 && visited[bx][by][currDir])\\n                continue;\\n            if (currDir != -1)\\n                visited[bx][by][currDir] = true;\\n            \\n            if (bx == xTarget && by == yTarget)\\n                return cnt;\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int dx = dir[i][0];\\n                int dy = dir[i][1];\\n                int nx = dx + bx;\\n                int ny = dy + by;\\n                if (nx < 0 || ny < 0 || nx > m - 1 || ny > n - 1)\\n                    continue;\\n                if (visited[nx][ny][i])\\n                    continue;\\n                if (grid[nx][ny] == \\'#\\')\\n                    continue;\\n                if (canReach(bx - dx, by - dy, px, py, bx, by))\\n                    q.offer(new int[] {cnt + 1, i, bx, by, nx, ny});\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n    \\n    boolean canReach(int x, int y, int px, int py, int bx, int by)  {\\n        if (x < 0 || x > m - 1 || y < 0 || y > n - 1)\\n            return false;\\n        if (x == bx && y == by)\\n            return false;\\n        if (grid[x][y] == \\'#\\')\\n            return false;\\n        Deque<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        q.offer(new int[] {px, py});\\n        while (!q.isEmpty())    {\\n            int[] curr = q.poll();\\n            int currX = curr[0];\\n            int currY = curr[1];\\n            if (visited[currX][currY])\\n                continue;\\n            visited[currX][currY] = true;\\n            if (currX == x && currY == y)\\n                return true;\\n            \\n            for (int[] d : dir) {\\n                int dx = d[0];\\n                int dy = d[1];\\n                int newX = dx + currX;\\n                int newY = dy + currY;\\n                if (newX < 0 || newX > m - 1 || newY < 0 || newY > n - 1)\\n                    continue;\\n                if (grid[newX][newY] == \\'#\\')\\n                    continue;\\n                if (visited[newX][newY])\\n                    continue;\\n                if (newX == bx && newY == by)\\n                    continue;\\n                q.offer(new int[] {newX, newY});\\n            }\\n        \\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    char[][] grid;\\n    public int minPushBox(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int xPlayer = -1;\\n        int yPlayer = -1;\\n        int xBox = -1;\\n        int yBox = -1;\\n        int xTarget = -1;\\n        int yTarget = -1;\\n        this.grid = grid;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\')  {\\n                    xPlayer = i;\\n                    yPlayer = j;\\n                }\\n                else if (grid[i][j] == \\'B\\') {\\n                    xBox = i;\\n                    yBox = j;\\n                }\\n                else if (grid[i][j] == \\'T\\') {\\n                    xTarget = i;\\n                    yTarget = j;\\n                }\\n            }\\n        }\\n        \\n        Deque<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[m][n][4];\\n        q.offer(new int[] {0, -1, xPlayer, yPlayer, xBox, yBox});\\n        \\n        while (!q.isEmpty())    {\\n            int[] curr = q.poll();\\n            int px = curr[2];\\n            int py = curr[3];\\n            int bx = curr[4];\\n            int by = curr[5];\\n            int cnt = curr[0];\\n            int currDir = curr[1];\\n            if (currDir != -1 && visited[bx][by][currDir])\\n                continue;\\n            if (currDir != -1)\\n                visited[bx][by][currDir] = true;\\n            \\n            if (bx == xTarget && by == yTarget)\\n                return cnt;\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int dx = dir[i][0];\\n                int dy = dir[i][1];\\n                int nx = dx + bx;\\n                int ny = dy + by;\\n                if (nx < 0 || ny < 0 || nx > m - 1 || ny > n - 1)\\n                    continue;\\n                if (visited[nx][ny][i])\\n                    continue;\\n                if (grid[nx][ny] == \\'#\\')\\n                    continue;\\n                if (canReach(bx - dx, by - dy, px, py, bx, by))\\n                    q.offer(new int[] {cnt + 1, i, bx, by, nx, ny});\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n    \\n    boolean canReach(int x, int y, int px, int py, int bx, int by)  {\\n        if (x < 0 || x > m - 1 || y < 0 || y > n - 1)\\n            return false;\\n        if (x == bx && y == by)\\n            return false;\\n        if (grid[x][y] == \\'#\\')\\n            return false;\\n        Deque<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        q.offer(new int[] {px, py});\\n        while (!q.isEmpty())    {\\n            int[] curr = q.poll();\\n            int currX = curr[0];\\n            int currY = curr[1];\\n            if (visited[currX][currY])\\n                continue;\\n            visited[currX][currY] = true;\\n            if (currX == x && currY == y)\\n                return true;\\n            \\n            for (int[] d : dir) {\\n                int dx = d[0];\\n                int dy = d[1];\\n                int newX = dx + currX;\\n                int newY = dy + currY;\\n                if (newX < 0 || newX > m - 1 || newY < 0 || newY > n - 1)\\n                    continue;\\n                if (grid[newX][newY] == \\'#\\')\\n                    continue;\\n                if (visited[newX][newY])\\n                    continue;\\n                if (newX == bx && newY == by)\\n                    continue;\\n                q.offer(new int[] {newX, newY});\\n            }\\n        \\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171010,
                "title": "c-a-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> t; //target\\n    pair<int,int> s; //source\\n    pair<int,int> b; //box\\n    \\n    // struct to store each member in priority queue\\n    struct node {\\n        int heuristic; // to find the dist between target and box\\n        int dist; // to keep track of how much the box moved\\n        pair<int,int> src; // to store the source\\n        pair<int,int> dest; // to store the box location\\n    };\\n    \\n    struct comp {\\n        bool operator()(node const& a, node const& b){\\n            return a.heuristic + a.dist > b.heuristic + b.dist;\\n        }\\n    };\\n \\n    int direction[4][2]= {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'T\\')\\n                    t={i,j};\\n                \\n                else if(grid[i][j]==\\'B\\')\\n                    b={i,j};\\n                \\n                else if(grid[i][j]==\\'S\\')\\n                    s={i,j};\\n            }\\n        }\\n        \\n        priority_queue<node,vector<node>,comp> pq;\\n        set<string> visited;\\n        \\n        node initialState = node{manhattanDist(b.first,b.second),0,s,b};\\n        string initialStr = hash(initialState);\\n        \\n        pq.push(initialState);\\n                \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            // we have reached the target return\\n            if(cur.dest == t) \\n                return cur.dist;\\n            \\n            // hash the cur string and \\n            string cur_vis = hash(cur);\\n            if(visited.count(cur_vis)) continue;\\n            \\n            // mark it as visited\\n            visited.insert(cur_vis);\\n            \\n            // in all the four directions\\n            for(auto& dir:direction){\\n                int sx = cur.src.first + dir[0];\\n                int sy = cur.src.second + dir[1];\\n                \\n                // if the new source is valid index\\n                if(valid(sx,sy,grid)){\\n                    \\n                    //if the source is equal to the where the box is\\n                    if(sx == cur.dest.first && sy == cur.dest.second){\\n                        int bx=cur.dest.first + dir[0];\\n                        int by=cur.dest.second + dir[1];\\n                        \\n                        // if the box is at right position\\n                        if(valid(bx,by,grid)){\\n                            \\n                            // increment the dist by 1 and update the source and box location\\n                            node updated = node{manhattanDist(bx,by),cur.dist+1,{sx,sy},{bx,by}};\\n                            pq.push(updated);\\n                        }\\n                    }else{\\n                        // update the new location of source \\n                        node updated = node{cur.heuristic,cur.dist,{sx,sy},cur.dest};\\n                        pq.push(updated);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we cannot perform the operation\\n        return -1;\\n        \\n    }\\n    \\n    string hash(node t){\\n        stringstream ss;\\n        ss<<t.src.first<<\" \"<<t.src.second<<\" \"<<t.dest.first<<\" \"<<t.dest.second;\\n        return ss.str();\\n    }\\n    \\n    int manhattanDist(int i, int j){\\n        return abs(t.first-i) + abs(t.second-j);\\n    }\\n    \\n    bool valid(int i, int j, vector<vector<char>>& g){\\n        \\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==\\'#\\') return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> t; //target\\n    pair<int,int> s; //source\\n    pair<int,int> b; //box\\n    \\n    // struct to store each member in priority queue\\n    struct node {\\n        int heuristic; // to find the dist between target and box\\n        int dist; // to keep track of how much the box moved\\n        pair<int,int> src; // to store the source\\n        pair<int,int> dest; // to store the box location\\n    };\\n    \\n    struct comp {\\n        bool operator()(node const& a, node const& b){\\n            return a.heuristic + a.dist > b.heuristic + b.dist;\\n        }\\n    };\\n \\n    int direction[4][2]= {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'T\\')\\n                    t={i,j};\\n                \\n                else if(grid[i][j]==\\'B\\')\\n                    b={i,j};\\n                \\n                else if(grid[i][j]==\\'S\\')\\n                    s={i,j};\\n            }\\n        }\\n        \\n        priority_queue<node,vector<node>,comp> pq;\\n        set<string> visited;\\n        \\n        node initialState = node{manhattanDist(b.first,b.second),0,s,b};\\n        string initialStr = hash(initialState);\\n        \\n        pq.push(initialState);\\n                \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            // we have reached the target return\\n            if(cur.dest == t) \\n                return cur.dist;\\n            \\n            // hash the cur string and \\n            string cur_vis = hash(cur);\\n            if(visited.count(cur_vis)) continue;\\n            \\n            // mark it as visited\\n            visited.insert(cur_vis);\\n            \\n            // in all the four directions\\n            for(auto& dir:direction){\\n                int sx = cur.src.first + dir[0];\\n                int sy = cur.src.second + dir[1];\\n                \\n                // if the new source is valid index\\n                if(valid(sx,sy,grid)){\\n                    \\n                    //if the source is equal to the where the box is\\n                    if(sx == cur.dest.first && sy == cur.dest.second){\\n                        int bx=cur.dest.first + dir[0];\\n                        int by=cur.dest.second + dir[1];\\n                        \\n                        // if the box is at right position\\n                        if(valid(bx,by,grid)){\\n                            \\n                            // increment the dist by 1 and update the source and box location\\n                            node updated = node{manhattanDist(bx,by),cur.dist+1,{sx,sy},{bx,by}};\\n                            pq.push(updated);\\n                        }\\n                    }else{\\n                        // update the new location of source \\n                        node updated = node{cur.heuristic,cur.dist,{sx,sy},cur.dest};\\n                        pq.push(updated);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we cannot perform the operation\\n        return -1;\\n        \\n    }\\n    \\n    string hash(node t){\\n        stringstream ss;\\n        ss<<t.src.first<<\" \"<<t.src.second<<\" \"<<t.dest.first<<\" \"<<t.dest.second;\\n        return ss.str();\\n    }\\n    \\n    int manhattanDist(int i, int j){\\n        return abs(t.first-i) + abs(t.second-j);\\n    }\\n    \\n    bool valid(int i, int j, vector<vector<char>>& g){\\n        \\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==\\'#\\') return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147430,
                "title": "javascript-bfs",
                "content": "```\\nvar minPushBox = function (grid) {\\n\\tconst n = grid.length;\\n\\tconst m = grid[0].length;\\n\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[-1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\n\\tconst person = { x: 0, y: 0 };\\n\\tconst box = { x: 0, y: 0 };\\n\\tconst exit = { x: 0, y: 0 };\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (grid[y][x] === \\'S\\') {\\n\\t\\t\\t\\tperson.x = x;\\n\\t\\t\\t\\tperson.y = y;\\n\\t\\t\\t} else if (grid[y][x] === \\'B\\') {\\n\\t\\t\\t\\tbox.x = x;\\n\\t\\t\\t\\tbox.y = y;\\n\\t\\t\\t} else if (grid[y][x] === \\'T\\') {\\n\\t\\t\\t\\texit.x = x;\\n\\t\\t\\t\\texit.y = y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction canPersonMoveToLocation(startX, startY, endX, endY, boxX, boxY) {\\n\\t\\tconst v = [];\\n\\t\\tconst q = [[startX, startY]];\\n\\t\\tv[startX + startY * m] = 1;\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst [x, y] = q.shift();\\n\\t\\t\\tif (x === endX && y === endY) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tfor (const [mx, my] of directions) {\\n\\t\\t\\t\\tconst nx = mx + x;\\n\\t\\t\\t\\tconst ny = my + y;\\n\\t\\t\\t\\tconst nkey = nx + ny * m;\\n\\t\\t\\t\\tconst nextSpot = grid[ny]?.[nx] ?? \\'#\\';\\n\\t\\t\\t\\tif (!v[nkey] && nextSpot !== \\'#\\') {\\n\\t\\t\\t\\t\\tv[nkey] = 1;\\n\\t\\t\\t\\t\\tif (nx !== boxX || ny !== boxY) {\\n\\t\\t\\t\\t\\t\\tq.push([nx, ny]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tconst v = [];\\n\\tconst q = [[box.x, box.y, person.x, person.y, 0]];\\n\\n\\twhile (q.length) {\\n\\t\\tconst [boxX, boxY, personX, personY, pushCount] = q.shift();\\n\\n\\t\\tif (boxX === exit.x && boxY === exit.y) {\\n\\t\\t\\treturn pushCount;\\n\\t\\t}\\n\\n\\t\\tconst boxKey = boxX + boxY * m;\\n\\t\\tconst personKey = personX + personY * m;\\n\\n\\t\\tif (v[boxKey] && v[boxKey][personKey]) continue;\\n\\n\\t\\tif (!v[boxKey]) v[boxKey] = {};\\n\\t\\tv[boxKey][personKey] = 1;\\n\\n\\t\\tfor (const [moveX, moveY] of directions) {\\n\\t\\t\\tconst nextBoxX = boxX + moveX;\\n\\t\\t\\tconst nextBoxY = boxY + moveY;\\n\\t\\t\\tconst nextSpot = grid[nextBoxY]?.[nextBoxX] ?? \\'#\\';\\n\\t\\t\\tif (nextSpot !== \\'#\\') {\\n\\t\\t\\t\\t//check if person can be positioned from the other side of the box\\n\\t\\t\\t\\tconst targetX = boxX - moveX;\\n\\t\\t\\t\\tconst targetY = boxY - moveY;\\n\\t\\t\\t\\tif (canPersonMoveToLocation(personX, personY, targetX, targetY, boxX, boxY)) {\\n\\t\\t\\t\\t\\tq.push([nextBoxX, nextBoxY, targetX, targetY, pushCount + 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minPushBox = function (grid) {\\n\\tconst n = grid.length;\\n\\tconst m = grid[0].length;\\n\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[-1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\n\\tconst person = { x: 0, y: 0 };\\n\\tconst box = { x: 0, y: 0 };\\n\\tconst exit = { x: 0, y: 0 };\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (grid[y][x] === \\'S\\') {\\n\\t\\t\\t\\tperson.x = x;\\n\\t\\t\\t\\tperson.y = y;\\n\\t\\t\\t} else if (grid[y][x] === \\'B\\') {\\n\\t\\t\\t\\tbox.x = x;\\n\\t\\t\\t\\tbox.y = y;\\n\\t\\t\\t} else if (grid[y][x] === \\'T\\') {\\n\\t\\t\\t\\texit.x = x;\\n\\t\\t\\t\\texit.y = y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction canPersonMoveToLocation(startX, startY, endX, endY, boxX, boxY) {\\n\\t\\tconst v = [];\\n\\t\\tconst q = [[startX, startY]];\\n\\t\\tv[startX + startY * m] = 1;\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst [x, y] = q.shift();\\n\\t\\t\\tif (x === endX && y === endY) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tfor (const [mx, my] of directions) {\\n\\t\\t\\t\\tconst nx = mx + x;\\n\\t\\t\\t\\tconst ny = my + y;\\n\\t\\t\\t\\tconst nkey = nx + ny * m;\\n\\t\\t\\t\\tconst nextSpot = grid[ny]?.[nx] ?? \\'#\\';\\n\\t\\t\\t\\tif (!v[nkey] && nextSpot !== \\'#\\') {\\n\\t\\t\\t\\t\\tv[nkey] = 1;\\n\\t\\t\\t\\t\\tif (nx !== boxX || ny !== boxY) {\\n\\t\\t\\t\\t\\t\\tq.push([nx, ny]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tconst v = [];\\n\\tconst q = [[box.x, box.y, person.x, person.y, 0]];\\n\\n\\twhile (q.length) {\\n\\t\\tconst [boxX, boxY, personX, personY, pushCount] = q.shift();\\n\\n\\t\\tif (boxX === exit.x && boxY === exit.y) {\\n\\t\\t\\treturn pushCount;\\n\\t\\t}\\n\\n\\t\\tconst boxKey = boxX + boxY * m;\\n\\t\\tconst personKey = personX + personY * m;\\n\\n\\t\\tif (v[boxKey] && v[boxKey][personKey]) continue;\\n\\n\\t\\tif (!v[boxKey]) v[boxKey] = {};\\n\\t\\tv[boxKey][personKey] = 1;\\n\\n\\t\\tfor (const [moveX, moveY] of directions) {\\n\\t\\t\\tconst nextBoxX = boxX + moveX;\\n\\t\\t\\tconst nextBoxY = boxY + moveY;\\n\\t\\t\\tconst nextSpot = grid[nextBoxY]?.[nextBoxX] ?? \\'#\\';\\n\\t\\t\\tif (nextSpot !== \\'#\\') {\\n\\t\\t\\t\\t//check if person can be positioned from the other side of the box\\n\\t\\t\\t\\tconst targetX = boxX - moveX;\\n\\t\\t\\t\\tconst targetY = boxY - moveY;\\n\\t\\t\\t\\tif (canPersonMoveToLocation(personX, personY, targetX, targetY, boxX, boxY)) {\\n\\t\\t\\t\\t\\tq.push([nextBoxX, nextBoxY, targetX, targetY, pushCount + 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123691,
                "title": "python-bfs-dfs-explained",
                "content": "For box we neeed simple bfs from box to target\\nfor person we add a new function solve() which is a simple dfs function with seen set to check if a person can travel from his initial position to one position opposite from the direction where the box is moving. So directions is defined accordingly with 4 positions.Also from question its clear that after moving the box, position of the person becomes initial position of the box.\\nBefore we porceed in solve() we make grid[i][j] as \"#\", since its given that a person cannot walk through box and make it \".\" after function returns.\\nIf this function returns True, proceed further.\\nvisited set for box\\'s bfs is edited as follows-\\nPut (next,initial) position in visited set instead of just next position.\\n\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        start,target,box=(0,0),(0,0),(0,0)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\"B\":\\n                    box=(i,j)\\n                elif grid[i][j]==\"T\":\\n                    target=(i,j)\\n                elif grid[i][j]==\"S\":\\n                    start=(i,j)\\n        q.append((box[0],box[1],0,start[0],start[1]))\\n        visited=set()\\n        directions=((1,0,-1,0),(0,1,0,-1),(-1,0,1,0),(0,-1,0,1))\\n        visited.add(box+box)\\n        def solve(i,j,bi,bj):\\n            nonlocal seen\\n            if (i,j)==(bi,bj):\\n                return True\\n            ans=False\\n            for d in directions:\\n                ni,nj=i+d[0],j+d[1]\\n                if 0<=ni<m and 0<=nj<n and (ni,nj) not in seen and grid[ni][nj]!=\"#\":\\n                    seen.add((ni,nj))\\n                    ans=ans or solve(ni,nj,bi,bj)\\n                    if ans: return ans\\n            return ans\\n        while q:\\n            i,j,pushes,si,sj=q.popleft()\\n            if (i,j)==target:\\n                return pushes\\n            if pushes>m+n:\\n                return -1\\n            for d in directions:\\n                ni,nj,bi,bj=i+d[0],j+d[1],i+d[2],j+d[3]\\n                if 0<=ni<m and 0<=nj<n and (ni,nj,i,j) not in visited and grid[ni][nj]!=\"#\" and 0<=bi<m and 0<=bj<n and grid[bi][bj]!=\"#\":\\n                    seen=set()\\n                    seen.add((i,j))\\n                    grid[i][j]==\"#\"\\n                    res=solve(si,sj,bi,bj)\\n                    grid[i][j]=\".\"\\n                    if not res:\\n                        continue\\n                    visited.add((ni,nj,i,j))\\n                    q.append((ni,nj,pushes+1,i,j))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        start,target,box=(0,0),(0,0),(0,0)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\"B\":\\n                    box=(i,j)\\n                elif grid[i][j]==\"T\":\\n                    target=(i,j)\\n                elif grid[i][j]==\"S\":\\n                    start=(i,j)\\n        q.append((box[0],box[1],0,start[0],start[1]))\\n        visited=set()\\n        directions=((1,0,-1,0),(0,1,0,-1),(-1,0,1,0),(0,-1,0,1))\\n        visited.add(box+box)\\n        def solve(i,j,bi,bj):\\n            nonlocal seen\\n            if (i,j)==(bi,bj):\\n                return True\\n            ans=False\\n            for d in directions:\\n                ni,nj=i+d[0],j+d[1]\\n                if 0<=ni<m and 0<=nj<n and (ni,nj) not in seen and grid[ni][nj]!=\"#\":\\n                    seen.add((ni,nj))\\n                    ans=ans or solve(ni,nj,bi,bj)\\n                    if ans: return ans\\n            return ans\\n        while q:\\n            i,j,pushes,si,sj=q.popleft()\\n            if (i,j)==target:\\n                return pushes\\n            if pushes>m+n:\\n                return -1\\n            for d in directions:\\n                ni,nj,bi,bj=i+d[0],j+d[1],i+d[2],j+d[3]\\n                if 0<=ni<m and 0<=nj<n and (ni,nj,i,j) not in visited and grid[ni][nj]!=\"#\" and 0<=bi<m and 0<=bj<n and grid[bi][bj]!=\"#\":\\n                    seen=set()\\n                    seen.add((i,j))\\n                    grid[i][j]==\"#\"\\n                    res=solve(si,sj,bi,bj)\\n                    grid[i][j]=\".\"\\n                    if not res:\\n                        continue\\n                    visited.add((ni,nj,i,j))\\n                    q.append((ni,nj,pushes+1,i,j))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065727,
                "title": "dfs-bfs-in-c",
                "content": "```\\nclass Solution {\\n    map<vector<int>, bool> beenhere;\\n    bool visited(int x, int y, int px, int py) {\\n        return beenhere.find({x, y, px, py}) != beenhere.end();\\n    }\\n    bool dfs(vector<vector<char>>& g, int tx, int ty, int sx, int sy, int bx, int by, vector<vector<bool>>& vis) {\\n        if (sx < 0 || sy < 0 || sx == g.size() || sy == g[0].size())\\n            return false;\\n        if (g[sx][sy] ==  \\'#\\' || vis[sx][sy] || sx == bx && sy == by)\\n            return false;\\n        if (sx == tx && sy == ty)\\n            return true;\\n        vis[sx][sy] = true;\\n        return dfs(g, tx, ty, sx - 1, sy, bx, by, vis) ||\\n               dfs(g, tx, ty, sx + 1, sy, bx, by, vis) ||\\n               dfs(g, tx, ty, sx, sy - 1, bx, by, vis) ||\\n               dfs(g, tx, ty, sx, sy + 1, bx, by, vis);\\n    }\\n    bool canreach(vector<vector<char>>& g, int tx, int ty, int sx, int sy, int bx, int by) {\\n        vector<vector<bool>> vis(g.size(), vector<bool>(g[0].size(), false));\\n        return dfs(g, tx, ty, sx, sy, bx, by, vis);\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& g) {\\n        int m = g.size();\\n        int n = g[0].size();\\n        int px = -1, py = -1, bx = -1, by = -1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                } else if (g[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                }\\n                if (px != -1 && bx != -1)\\n                    break;\\n            }\\n        }\\n        queue<tuple<int, int, int, int>> q;\\n        q.push({bx, by, px, py});\\n        int moves = 0;\\n        while (q.size()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto[x, y, px, py] = q.front();\\n                q.pop();\\n                if (g[x][y] == \\'T\\')\\n                    return moves;\\n                if (x > 0 && x < m - 1 && g[x - 1][y] != \\'#\\' && g[x + 1][y] != \\'#\\') {\\n                    if (!visited(x - 1, y, x + 1, y) && canreach(g, x + 1, y, px, py, x, y)) {\\n                        beenhere[{x - 1, y, x + 1, y}] = true;\\n                        q.push({x - 1, y, x, y});\\n                    }\\n                    if (!visited(x + 1, y, x - 1, y) && canreach(g, x - 1, y, px, py, x, y)) {\\n                        beenhere[{x + 1, y, x - 1, y}] = true;\\n                        q.push({x + 1, y, x, y});\\n                    }\\n                }\\n                if (y > 0 && y < n - 1 && g[x][y - 1] != \\'#\\' && g[x][y + 1] != \\'#\\') {\\n                    if (!visited(x, y - 1, x, y + 1) && canreach(g, x, y + 1, px, py, x, y)) {\\n                        beenhere[{x, y - 1, x, y + 1}] = true;\\n                        q.push({x, y - 1, x, y});\\n                    }\\n                    if (!visited(x, y + 1, x, y - 1) && canreach(g, x, y - 1, px, py, x, y)) {\\n                        beenhere[{x, y + 1, x, y - 1}] = true;\\n                        q.push({x, y + 1, x, y});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<vector<int>, bool> beenhere;\\n    bool visited(int x, int y, int px, int py) {\\n        return beenhere.find({x, y, px, py}) != beenhere.end();\\n    }\\n    bool dfs(vector<vector<char>>& g, int tx, int ty, int sx, int sy, int bx, int by, vector<vector<bool>>& vis) {\\n        if (sx < 0 || sy < 0 || sx == g.size() || sy == g[0].size())\\n            return false;\\n        if (g[sx][sy] ==  \\'#\\' || vis[sx][sy] || sx == bx && sy == by)\\n            return false;\\n        if (sx == tx && sy == ty)\\n            return true;\\n        vis[sx][sy] = true;\\n        return dfs(g, tx, ty, sx - 1, sy, bx, by, vis) ||\\n               dfs(g, tx, ty, sx + 1, sy, bx, by, vis) ||\\n               dfs(g, tx, ty, sx, sy - 1, bx, by, vis) ||\\n               dfs(g, tx, ty, sx, sy + 1, bx, by, vis);\\n    }\\n    bool canreach(vector<vector<char>>& g, int tx, int ty, int sx, int sy, int bx, int by) {\\n        vector<vector<bool>> vis(g.size(), vector<bool>(g[0].size(), false));\\n        return dfs(g, tx, ty, sx, sy, bx, by, vis);\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& g) {\\n        int m = g.size();\\n        int n = g[0].size();\\n        int px = -1, py = -1, bx = -1, by = -1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == \\'B\\') {\\n                    bx = i;\\n                    by = j;\\n                } else if (g[i][j] == \\'S\\') {\\n                    px = i;\\n                    py = j;\\n                }\\n                if (px != -1 && bx != -1)\\n                    break;\\n            }\\n        }\\n        queue<tuple<int, int, int, int>> q;\\n        q.push({bx, by, px, py});\\n        int moves = 0;\\n        while (q.size()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto[x, y, px, py] = q.front();\\n                q.pop();\\n                if (g[x][y] == \\'T\\')\\n                    return moves;\\n                if (x > 0 && x < m - 1 && g[x - 1][y] != \\'#\\' && g[x + 1][y] != \\'#\\') {\\n                    if (!visited(x - 1, y, x + 1, y) && canreach(g, x + 1, y, px, py, x, y)) {\\n                        beenhere[{x - 1, y, x + 1, y}] = true;\\n                        q.push({x - 1, y, x, y});\\n                    }\\n                    if (!visited(x + 1, y, x - 1, y) && canreach(g, x - 1, y, px, py, x, y)) {\\n                        beenhere[{x + 1, y, x - 1, y}] = true;\\n                        q.push({x + 1, y, x, y});\\n                    }\\n                }\\n                if (y > 0 && y < n - 1 && g[x][y - 1] != \\'#\\' && g[x][y + 1] != \\'#\\') {\\n                    if (!visited(x, y - 1, x, y + 1) && canreach(g, x, y + 1, px, py, x, y)) {\\n                        beenhere[{x, y - 1, x, y + 1}] = true;\\n                        q.push({x, y - 1, x, y});\\n                    }\\n                    if (!visited(x, y + 1, x, y - 1) && canreach(g, x, y - 1, px, py, x, y)) {\\n                        beenhere[{x, y + 1, x, y - 1}] = true;\\n                        q.push({x, y + 1, x, y});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012397,
                "title": "python-bfs-dfs",
                "content": "```\\nfrom collections import deque\\nimport copy\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid),len(grid[0])\\n        def dfs(i,j,ti,tj,grid,visited):\\n            if (i,j) == (ti,tj): return True\\n            if (i,j) in visited:\\n                return False\\n            visited.add((i,j))\\n            res = False\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and grid[i+di][j+dj] in [\".\",\"T\"]:\\n                    res = res or dfs(i+di,j+dj,ti,tj,grid,visited)\\n            return res\\n        box_visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'B\\':\\n                    b_pos = (i,j)\\n                elif grid[i][j] == \\'S\\':\\n                    s_pos = (i,j)\\n                elif grid[i][j] == \\'T\\':\\n                    t_pos = (i,j)\\n        que = deque([(b_pos,s_pos,0)])\\n        while que:\\n            (bi,bj),(si,sj),d = que.popleft()\\n            if (bi,bj) == t_pos: return d\\n            if (bi,bj,si,sj) in box_visited: continue\\n            box_visited.add((bi,bj,si,sj))\\n            tmp_grid = copy.deepcopy(grid)\\n            tmp_grid[b_pos[0]][b_pos[1]] = \\'.\\'\\n            tmp_grid[s_pos[0]][s_pos[1]] = \\'.\\'\\n            tmp_grid[bi][bj] = \\'B\\'\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=bi+di<m and 0<=bj+dj<n and 0<=bi-di<m and 0<=bj-dj<n:\\n                    if tmp_grid[bi-di][bj-dj] in [\".\",\"S\",\"T\"] and tmp_grid[bi+di][bj+dj] in [\".\",\"S\",\"T\"] and dfs(si,sj,bi+di,bj+dj,tmp_grid,set()):\\n                        que.append(((bi-di,bj-dj),(bi,bj),d+1))\\n        return -1\\n                        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nimport copy\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid),len(grid[0])\\n        def dfs(i,j,ti,tj,grid,visited):\\n            if (i,j) == (ti,tj): return True\\n            if (i,j) in visited:\\n                return False\\n            visited.add((i,j))\\n            res = False\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and grid[i+di][j+dj] in [\".\",\"T\"]:\\n                    res = res or dfs(i+di,j+dj,ti,tj,grid,visited)\\n            return res\\n        box_visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'B\\':\\n                    b_pos = (i,j)\\n                elif grid[i][j] == \\'S\\':\\n                    s_pos = (i,j)\\n                elif grid[i][j] == \\'T\\':\\n                    t_pos = (i,j)\\n        que = deque([(b_pos,s_pos,0)])\\n        while que:\\n            (bi,bj),(si,sj),d = que.popleft()\\n            if (bi,bj) == t_pos: return d\\n            if (bi,bj,si,sj) in box_visited: continue\\n            box_visited.add((bi,bj,si,sj))\\n            tmp_grid = copy.deepcopy(grid)\\n            tmp_grid[b_pos[0]][b_pos[1]] = \\'.\\'\\n            tmp_grid[s_pos[0]][s_pos[1]] = \\'.\\'\\n            tmp_grid[bi][bj] = \\'B\\'\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=bi+di<m and 0<=bj+dj<n and 0<=bi-di<m and 0<=bj-dj<n:\\n                    if tmp_grid[bi-di][bj-dj] in [\".\",\"S\",\"T\"] and tmp_grid[bi+di][bj+dj] in [\".\",\"S\",\"T\"] and dfs(si,sj,bi+di,bj+dj,tmp_grid,set()):\\n                        que.append(((bi-di,bj-dj),(bi,bj),d+1))\\n        return -1\\n                        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1979814,
                "title": "golang-2-level-bfs-with-min-heap-implementation",
                "content": "\\n```\\ntype Coord struct{\\n    x int\\n    y int\\n}\\n\\nfunc (this *Coord)equal(comp Coord) bool {\\n    return this.x == comp.x && this.y == comp.y\\n}\\n\\nfunc (this *Coord) coordExistIn(list []Coord) bool {\\n    for _, v := range(list) {\\n        if this.equal(v) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype State struct {\\n    box Coord\\n    player Coord\\n    moves int\\n}\\n\\ntype StateList []State\\n\\nfunc (this StateList) Len() int { return len(this) }\\nfunc (this StateList) Less(i, j int) bool { return (this)[i].moves < (this)[j].moves }\\nfunc (this StateList) Swap(i, j int) { (this)[i], (this)[j] = (this)[j], (this)[i] }\\nfunc (this *StateList) Push(x interface{}) {\\n    *this = append(*this, x.(State))\\n}\\nfunc (this *StateList) Pop() interface{} {\\n    old := *this\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*this = old[0:n-1]\\n\\treturn x\\n}\\n\\ntype StateCoord struct {\\n    box Coord\\n    player Coord\\n}\\n\\nfunc (this *StateCoord) existIn(list []StateCoord) bool {\\n    for _, v := range(list) {\\n        if this.box.equal(v.box) && this.player.equal(v.player) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    player := Coord{}\\n    box := Coord{}\\n    target := Coord{}\\n    for j:=0; j< len(grid[0]); j++ {\\n        for i:=0; i<len(grid); i++ {\\n            switch grid[i][j] {\\n                case \\'B\\': box = Coord{x: i, y: j}\\n                case \\'S\\': player = Coord{x: i, y: j}\\n                case \\'T\\': target = Coord{x: i, y: j}\\n            }\\n        }\\n    }\\n    \\n    stack := &StateList{}\\n    visited := []StateCoord{}\\n    heap.Init(stack)\\n    \\n    heap.Push(stack, State{box, player, 0})\\n    \\n    for len(*stack) > 0 {\\n        \\n        state := heap.Pop(stack).(State)\\n        box := state.box\\n        player := state.player\\n        moves := state.moves\\n        \\n        visited = append(visited, StateCoord{box,player})\\n        \\n        if box.equal(target){\\n            return moves\\n        }\\n        \\n        // Try to push left \\n        stateCoord := StateCoord{Coord{box.x, box.y-1},Coord{player.x, player.y-1}}\\n        if box.y-1 >=0 && box.x == player.x && box.y+1 == player.y && grid[box.x][box.y-1] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x, box.y-1},Coord{player.x, player.y-1}, moves+1})    \\n        }\\n        // Try to push right\\n        stateCoord = StateCoord{Coord{box.x, box.y+1},Coord{player.x, player.y+1}}\\n        if box.y+1 < len(grid[0]) && box.x == player.x && box.y-1 == player.y && grid[box.x][box.y+1] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x, box.y+1},Coord{player.x, player.y+1}, moves+1})    \\n        }\\n        // Try to push up\\n        stateCoord = StateCoord{Coord{box.x-1, box.y},Coord{player.x-1, player.y}}\\n        if box.x-1 >=0 && box.x+1 == player.x && box.y == player.y && grid[box.x-1][box.y] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x-1, box.y},Coord{player.x-1, player.y}, moves+1})    \\n        }\\n        // Try to push down\\n        stateCoord = StateCoord{Coord{box.x+1, box.y},Coord{player.x+1, player.y}}\\n        if box.x+1 < len(grid) && box.x-1 == player.x && box.y == player.y && grid[box.x+1][box.y] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x+1, box.y},Coord{player.x+1, player.y}, moves+1})    \\n        }\\n        \\n        for _, newCoord := range([]Coord{{box.x,box.y-1}, {box.x, box.y+1}, {box.x-1,box.y}, {box.x+1,box.y}}) {\\n            stateCoord = StateCoord{box,newCoord}\\n            if isValidCoordinates(newCoord, grid) && !stateCoord.existIn(visited) && canMoveTo(player, newCoord, box, grid) {\\n                heap.Push(stack, State{box,newCoord, moves})        \\n            }\\n        }\\n        \\n    }\\n    \\n    return -1\\n}\\n\\nfunc canMoveTo(start, end, box Coord, grid [][]byte) bool {\\n    visited := []Coord{}\\n    stack := []Coord{start}\\n    \\n    for len(stack)>0 {\\n        coord := stack[0]\\n        stack = stack[1:]\\n        \\n        if coord.equal(end) {\\n            return true\\n        }\\n        \\n        visited = append(visited, coord)\\n        \\n        for _, new_coord := range([]Coord{{coord.x,coord.y-1}, {coord.x, coord.y+1}, {coord.x-1,coord.y}, {coord.x+1,coord.y}}) {\\n            if isValidCoordinates(new_coord, grid) && !new_coord.equal(box) && !new_coord.coordExistIn(visited) && !new_coord.coordExistIn(stack) {\\n                stack = append(stack, new_coord)\\n            }\\n        }\\n    }\\n    return false\\n    \\n}\\n\\nfunc isValidCoordinates(coord Coord, grid [][]byte) bool{\\n    if 0 <= coord.x && coord.x < len(grid) && 0 <= coord.y && coord.y < len(grid[0]) && grid[coord.x][coord.y] != \\'#\\'{\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype Coord struct{\\n    x int\\n    y int\\n}\\n\\nfunc (this *Coord)equal(comp Coord) bool {\\n    return this.x == comp.x && this.y == comp.y\\n}\\n\\nfunc (this *Coord) coordExistIn(list []Coord) bool {\\n    for _, v := range(list) {\\n        if this.equal(v) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype State struct {\\n    box Coord\\n    player Coord\\n    moves int\\n}\\n\\ntype StateList []State\\n\\nfunc (this StateList) Len() int { return len(this) }\\nfunc (this StateList) Less(i, j int) bool { return (this)[i].moves < (this)[j].moves }\\nfunc (this StateList) Swap(i, j int) { (this)[i], (this)[j] = (this)[j], (this)[i] }\\nfunc (this *StateList) Push(x interface{}) {\\n    *this = append(*this, x.(State))\\n}\\nfunc (this *StateList) Pop() interface{} {\\n    old := *this\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*this = old[0:n-1]\\n\\treturn x\\n}\\n\\ntype StateCoord struct {\\n    box Coord\\n    player Coord\\n}\\n\\nfunc (this *StateCoord) existIn(list []StateCoord) bool {\\n    for _, v := range(list) {\\n        if this.box.equal(v.box) && this.player.equal(v.player) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc minPushBox(grid [][]byte) int {\\n    player := Coord{}\\n    box := Coord{}\\n    target := Coord{}\\n    for j:=0; j< len(grid[0]); j++ {\\n        for i:=0; i<len(grid); i++ {\\n            switch grid[i][j] {\\n                case \\'B\\': box = Coord{x: i, y: j}\\n                case \\'S\\': player = Coord{x: i, y: j}\\n                case \\'T\\': target = Coord{x: i, y: j}\\n            }\\n        }\\n    }\\n    \\n    stack := &StateList{}\\n    visited := []StateCoord{}\\n    heap.Init(stack)\\n    \\n    heap.Push(stack, State{box, player, 0})\\n    \\n    for len(*stack) > 0 {\\n        \\n        state := heap.Pop(stack).(State)\\n        box := state.box\\n        player := state.player\\n        moves := state.moves\\n        \\n        visited = append(visited, StateCoord{box,player})\\n        \\n        if box.equal(target){\\n            return moves\\n        }\\n        \\n        // Try to push left \\n        stateCoord := StateCoord{Coord{box.x, box.y-1},Coord{player.x, player.y-1}}\\n        if box.y-1 >=0 && box.x == player.x && box.y+1 == player.y && grid[box.x][box.y-1] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x, box.y-1},Coord{player.x, player.y-1}, moves+1})    \\n        }\\n        // Try to push right\\n        stateCoord = StateCoord{Coord{box.x, box.y+1},Coord{player.x, player.y+1}}\\n        if box.y+1 < len(grid[0]) && box.x == player.x && box.y-1 == player.y && grid[box.x][box.y+1] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x, box.y+1},Coord{player.x, player.y+1}, moves+1})    \\n        }\\n        // Try to push up\\n        stateCoord = StateCoord{Coord{box.x-1, box.y},Coord{player.x-1, player.y}}\\n        if box.x-1 >=0 && box.x+1 == player.x && box.y == player.y && grid[box.x-1][box.y] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x-1, box.y},Coord{player.x-1, player.y}, moves+1})    \\n        }\\n        // Try to push down\\n        stateCoord = StateCoord{Coord{box.x+1, box.y},Coord{player.x+1, player.y}}\\n        if box.x+1 < len(grid) && box.x-1 == player.x && box.y == player.y && grid[box.x+1][box.y] != \\'#\\' && !stateCoord.existIn(visited){\\n            heap.Push(stack, State{Coord{box.x+1, box.y},Coord{player.x+1, player.y}, moves+1})    \\n        }\\n        \\n        for _, newCoord := range([]Coord{{box.x,box.y-1}, {box.x, box.y+1}, {box.x-1,box.y}, {box.x+1,box.y}}) {\\n            stateCoord = StateCoord{box,newCoord}\\n            if isValidCoordinates(newCoord, grid) && !stateCoord.existIn(visited) && canMoveTo(player, newCoord, box, grid) {\\n                heap.Push(stack, State{box,newCoord, moves})        \\n            }\\n        }\\n        \\n    }\\n    \\n    return -1\\n}\\n\\nfunc canMoveTo(start, end, box Coord, grid [][]byte) bool {\\n    visited := []Coord{}\\n    stack := []Coord{start}\\n    \\n    for len(stack)>0 {\\n        coord := stack[0]\\n        stack = stack[1:]\\n        \\n        if coord.equal(end) {\\n            return true\\n        }\\n        \\n        visited = append(visited, coord)\\n        \\n        for _, new_coord := range([]Coord{{coord.x,coord.y-1}, {coord.x, coord.y+1}, {coord.x-1,coord.y}, {coord.x+1,coord.y}}) {\\n            if isValidCoordinates(new_coord, grid) && !new_coord.equal(box) && !new_coord.coordExistIn(visited) && !new_coord.coordExistIn(stack) {\\n                stack = append(stack, new_coord)\\n            }\\n        }\\n    }\\n    return false\\n    \\n}\\n\\nfunc isValidCoordinates(coord Coord, grid [][]byte) bool{\\n    if 0 <= coord.x && coord.x < len(grid) && 0 <= coord.y && coord.y < len(grid[0]) && grid[coord.x][coord.y] != \\'#\\'{\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957744,
                "title": "python-bfs-for-finding-shortest-path-bfs-for-moving-player-to-push-the-box",
                "content": "This is a BFS problem masked in a game. You\\'re trying to find the **minimum** moves to push a box, which a BFS can do. This is what I do in a nutshell:\\n\\n- Try to find shortest path for the box to reach target\\n- Try to push the box. Remember, the path is only good if the box can be pushed that way. **For every move, I check if the player can reach the required position to push**.\\n- I keep track of the previous positions that led to other positions by `vis_dir`. **You can go back to a point you already visited, as long as you don\\'t reach it from the exact same previous position!**\\n\\n---\\n\\n```python\\ndx = [-1, 0, 1, 0]; \\ndy = [ 0, 1, 0,-1]; \\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        # find all necessary information\\n        player_r, player_c = -1, -1\\n        box_r, box_c = -1, -1\\n        target_r, target_c = -1, -1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'T\\':\\n                    target_c = j\\n                    target_r = i\\n                if grid[i][j] == \\'B\\':\\n                    box_c = j\\n                    box_r = i\\n                if grid[i][j] == \\'S\\':\\n                    player_c = j\\n                    player_r = i\\n        \\n        # find the shortest path\\n        q = deque([])\\n        player_pos = deque([]) # same length as q\\n        vis = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        vis_dir = [[set() for _ in range(len(grid[0]))] for _ in range(len(grid))] # previous position the box came from to this position\\n        path_len = 0\\n        found_target = False\\n        q.append((box_r, box_c))\\n        player_pos.append((player_r, player_c))\\n        vis[box_r][box_c] = True\\n        while q and not found_target:\\n            sz = len(q)\\n            while sz > 0:\\n                sz -= 1\\n                (cur_r, cur_c) = q.popleft() # box position\\n                (cur_player_r, cur_player_c) = player_pos.popleft()\\n                if grid[cur_r][cur_c] == \\'T\\':\\n                    found_target = True\\n                    break\\n                for i in range(4):\\n                    new_r = cur_r + dy[i]\\n                    new_c = cur_c + dx[i]\\n                    push_r = cur_r - dy[i]\\n                    push_c = cur_c - dx[i]\\n                    \\n                    if new_r < 0 or new_r == len(grid) or new_c < 0 or new_c == len(grid[0]):\\n                        continue # don\\'t push box out of bounds\\n                    if push_r < 0 or push_r == len(grid) or push_c < 0 or push_c == len(grid[0]):\\n                        continue # don\\'t go out of bounds to push the box\\n                    if vis[new_r][new_c] and (cur_r, cur_c) in vis_dir[new_r][new_c]:\\n                        continue # don\\'t try to push the box back to where it came from if pushed in the same direction before\\n                    if grid[new_r][new_c] == \\'#\\':\\n                        continue # position to push box to isn\\'t free\\n                    if grid[push_r][push_c] == \\'#\\':\\n                        continue # push position to push box isn\\'t free\\n                    \\n                    # move the player to the required push position\\n                    reached_push_pos = False\\n                    q2 = deque([])\\n                    vis2 = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n                    q2.append((cur_player_r, cur_player_c))\\n                    vis2[cur_player_r][cur_player_c] = True\\n                    while q2 and not reached_push_pos:\\n                        sz2 = len(q2)\\n                        while sz2 > 0:\\n                            sz2 -= 1\\n                            (cur_player_r2, cur_player_c2) = q2.popleft()\\n                            if cur_player_r2 == push_r and cur_player_c2 == push_c:\\n                                reached_push_pos = True\\n                                break\\n                            for i2 in range(4):\\n                                new_r2 = cur_player_r2 + dy[i2]\\n                                new_c2 = cur_player_c2 + dx[i2]\\n                                if new_r2 == cur_r and new_c2 == cur_c:\\n                                    continue # can\\'t go past the box\\n                                \\n                                if new_r2 >= 0 and new_r2 < len(grid) and new_c2 >= 0 and new_c2 < len(grid[0]) and grid[new_r2][new_c2] != \\'#\\' and not vis2[new_r2][new_c2]:\\n                                    vis2[new_r2][new_c2] = True\\n                                    q2.append((new_r2, new_c2))\\n                    if not reached_push_pos:\\n                        continue # player can\\'t get to required position to push the box\\n                    \\n                    vis[new_r][new_c] = True\\n                    vis_dir[new_r][new_c].add((cur_r, cur_c))\\n                    q.append((new_r, new_c))\\n                    player_pos.append((push_r, push_c))\\n            path_len += 1\\n        path_len -= 1\\n        if not found_target:\\n            return -1 # we don\\'t even have a possible path in the first place\\n        return path_len\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\ndx = [-1, 0, 1, 0]; \\ndy = [ 0, 1, 0,-1]; \\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        # find all necessary information\\n        player_r, player_c = -1, -1\\n        box_r, box_c = -1, -1\\n        target_r, target_c = -1, -1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'T\\':\\n                    target_c = j\\n                    target_r = i\\n                if grid[i][j] == \\'B\\':\\n                    box_c = j\\n                    box_r = i\\n                if grid[i][j] == \\'S\\':\\n                    player_c = j\\n                    player_r = i\\n        \\n        # find the shortest path\\n        q = deque([])\\n        player_pos = deque([]) # same length as q\\n        vis = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        vis_dir = [[set() for _ in range(len(grid[0]))] for _ in range(len(grid))] # previous position the box came from to this position\\n        path_len = 0\\n        found_target = False\\n        q.append((box_r, box_c))\\n        player_pos.append((player_r, player_c))\\n        vis[box_r][box_c] = True\\n        while q and not found_target:\\n            sz = len(q)\\n            while sz > 0:\\n                sz -= 1\\n                (cur_r, cur_c) = q.popleft() # box position\\n                (cur_player_r, cur_player_c) = player_pos.popleft()\\n                if grid[cur_r][cur_c] == \\'T\\':\\n                    found_target = True\\n                    break\\n                for i in range(4):\\n                    new_r = cur_r + dy[i]\\n                    new_c = cur_c + dx[i]\\n                    push_r = cur_r - dy[i]\\n                    push_c = cur_c - dx[i]\\n                    \\n                    if new_r < 0 or new_r == len(grid) or new_c < 0 or new_c == len(grid[0]):\\n                        continue # don\\'t push box out of bounds\\n                    if push_r < 0 or push_r == len(grid) or push_c < 0 or push_c == len(grid[0]):\\n                        continue # don\\'t go out of bounds to push the box\\n                    if vis[new_r][new_c] and (cur_r, cur_c) in vis_dir[new_r][new_c]:\\n                        continue # don\\'t try to push the box back to where it came from if pushed in the same direction before\\n                    if grid[new_r][new_c] == \\'#\\':\\n                        continue # position to push box to isn\\'t free\\n                    if grid[push_r][push_c] == \\'#\\':\\n                        continue # push position to push box isn\\'t free\\n                    \\n                    # move the player to the required push position\\n                    reached_push_pos = False\\n                    q2 = deque([])\\n                    vis2 = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n                    q2.append((cur_player_r, cur_player_c))\\n                    vis2[cur_player_r][cur_player_c] = True\\n                    while q2 and not reached_push_pos:\\n                        sz2 = len(q2)\\n                        while sz2 > 0:\\n                            sz2 -= 1\\n                            (cur_player_r2, cur_player_c2) = q2.popleft()\\n                            if cur_player_r2 == push_r and cur_player_c2 == push_c:\\n                                reached_push_pos = True\\n                                break\\n                            for i2 in range(4):\\n                                new_r2 = cur_player_r2 + dy[i2]\\n                                new_c2 = cur_player_c2 + dx[i2]\\n                                if new_r2 == cur_r and new_c2 == cur_c:\\n                                    continue # can\\'t go past the box\\n                                \\n                                if new_r2 >= 0 and new_r2 < len(grid) and new_c2 >= 0 and new_c2 < len(grid[0]) and grid[new_r2][new_c2] != \\'#\\' and not vis2[new_r2][new_c2]:\\n                                    vis2[new_r2][new_c2] = True\\n                                    q2.append((new_r2, new_c2))\\n                    if not reached_push_pos:\\n                        continue # player can\\'t get to required position to push the box\\n                    \\n                    vis[new_r][new_c] = True\\n                    vis_dir[new_r][new_c].add((cur_r, cur_c))\\n                    q.append((new_r, new_c))\\n                    player_pos.append((push_r, push_c))\\n            path_len += 1\\n        path_len -= 1\\n        if not found_target:\\n            return -1 # we don\\'t even have a possible path in the first place\\n        return path_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908579,
                "title": "c-dijstra-solution",
                "content": "Rewrite from https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431061/A-star-search\\n```\\nclass Solution {\\n    vector<int> dirs = {-1,0,1,0,-1};\\n    int m,n;\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int si,sj,ei,ej,bi,bj;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j]==\\'S\\') {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if (grid[i][j]==\\'B\\') {\\n                    bi = i;\\n                    bj = j;\\n                }\\n                if (grid[i][j]==\\'T\\') {\\n                    ei = i;\\n                    ej = j;\\n                }\\n            }\\n        }\\n        auto compare = [&ei,&ej](vector<int>&a, vector<int>&b) {\\n            return abs(a[0]-ei) + abs(a[1]-ej) + a[4] > abs(b[0]-ei) + abs(b[1]-ej) + b[4];    \\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> pq(compare);\\n        pq.push({bi,bj,si,sj,0});\\n        unordered_set<string> visited;\\n        visited.insert(help({bi,bj,si,sj}));\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            int cbi = cur[0], cbj = cur[1], i = cur[2], j = cur[3], cost = cur[4];\\n            for (int k=0; k<4; k++) {\\n                int ii = i+dirs[k], jj = j+dirs[k+1];\\n                if (ii>=0 && jj>=0 && ii<m && jj<n && grid[ii][jj]!=\\'#\\' && visited.find(help({cbi,cbj,ii,jj}))==visited.end()) {\\n                    if (ii==cbi && jj==cbj) {\\n                        int cbii = cbi+dirs[k], cbjj = cbj+dirs[k+1];\\n                        if (cbii==ei && cbjj==ej)   return cost+1;\\n                        if (cbii>=0 && cbjj>=0 && cbii<m && cbjj<n && grid[cbii][cbjj]!=\\'#\\') {\\n                            pq.push({cbii,cbjj,ii,jj,cost+1});\\n                        }\\n                    } else {\\n                        visited.insert(help({cbi,cbj,ii,jj}));\\n                        pq.push({cbi,cbj,ii,jj,cost});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    string help(vector<int> a) {\\n        string res = \"\";\\n        for (int i=0; i<4; i++)\\n            res+=to_string(a[i])+\",\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> dirs = {-1,0,1,0,-1};\\n    int m,n;\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int si,sj,ei,ej,bi,bj;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j]==\\'S\\') {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if (grid[i][j]==\\'B\\') {\\n                    bi = i;\\n                    bj = j;\\n                }\\n                if (grid[i][j]==\\'T\\') {\\n                    ei = i;\\n                    ej = j;\\n                }\\n            }\\n        }\\n        auto compare = [&ei,&ej](vector<int>&a, vector<int>&b) {\\n            return abs(a[0]-ei) + abs(a[1]-ej) + a[4] > abs(b[0]-ei) + abs(b[1]-ej) + b[4];    \\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> pq(compare);\\n        pq.push({bi,bj,si,sj,0});\\n        unordered_set<string> visited;\\n        visited.insert(help({bi,bj,si,sj}));\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            int cbi = cur[0], cbj = cur[1], i = cur[2], j = cur[3], cost = cur[4];\\n            for (int k=0; k<4; k++) {\\n                int ii = i+dirs[k], jj = j+dirs[k+1];\\n                if (ii>=0 && jj>=0 && ii<m && jj<n && grid[ii][jj]!=\\'#\\' && visited.find(help({cbi,cbj,ii,jj}))==visited.end()) {\\n                    if (ii==cbi && jj==cbj) {\\n                        int cbii = cbi+dirs[k], cbjj = cbj+dirs[k+1];\\n                        if (cbii==ei && cbjj==ej)   return cost+1;\\n                        if (cbii>=0 && cbjj>=0 && cbii<m && cbjj<n && grid[cbii][cbjj]!=\\'#\\') {\\n                            pq.push({cbii,cbjj,ii,jj,cost+1});\\n                        }\\n                    } else {\\n                        visited.insert(help({cbi,cbj,ii,jj}));\\n                        pq.push({cbi,cbj,ii,jj,cost});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    string help(vector<int> a) {\\n        string res = \"\";\\n        for (int i=0; i<4; i++)\\n            res+=to_string(a[i])+\",\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908229,
                "title": "c-17-double-bfs-o-r-r",
                "content": "\\n\\n```\\nnamespace lc1263_push_box {\\n// 1263. Minimum Moves to Move a Box to Their Target Location\\nclass Solution {\\npublic:\\n    // BFS over a derived graph, derived from the input grid --\\n    // each vertex in the derived graph has two states:\\n    // * the Storekeeper/Player p{x,y} and\\n    // * the Box location b{x,y}.\\n    //\\n    // A push/move of the box is feasible if\\n    // 1. the storekeeper can go to the position behind the box\\n    // (this will be determined using another \"nested\" BFS. Time complexity of this \"nested\" BFS:\\n    // O(R) where R is the number of reachable cells by the storekeeper/player.).\\n    // 2. the box\\'s new location is empty.\\n    //\\n    // Overal Time-Complexity: O(R*R) since the main BFS queue may contain up to 4*R items, and each\\n    // item may take O(R) time to determine whether player can reach the ideal position to push the\\n    // box.\\n    //\\n    /// we can use a 4-tuple to represent the state:\\n    /// {xBox, yBox, xPlayer, yPlayer}.\\n    /// Note that, except the initial state, the player is always adjacent to the box in the states.\\n    /// so the possibility of the states are at most 4*R where R is the cells that can be reached.\\n    using State = tuple<int8_t, int8_t, int8_t, int8_t>;\\n    using Position = tuple<int8_t, int8_t>;\\n\\n    // deltas for 4 directions to which the box can be pushed.\\n    constexpr static const array<int8_t, 4> RowDelta{1, -1, 0, 0};\\n    constexpr static const array<int8_t, 4> ColDelta{0, 0, 1, -1};\\n\\n    // using C++17 structured binding to extract the parts out of the State:\\n    // auto [boxX, boxY, playerX, playerY] = state;\\n    int minPushBox(vector<vector<char>>& grid) {\\n        // 1 <= m,n <= 20. Thus a byte can represent a {x,y} pair if we use bit-fields.\\n        // but for saving time, we won\\'t do that.\\n        const int8_t m = grid.size(), n = grid[0].size();\\n\\n        // extract the positions of the player and the box, and the target\\n        Position player, box, target;\\n        extractPositions(grid, player, box, target);\\n\\n        // the queue for the main BFS.\\n        queue<State> Q;\\n        unordered_set<uint32_t> visited;\\n\\n        int numPushes = 0;\\n        const auto [xTarget, yTarget] = target;\\n        // enqueue the initial states\\n        {\\n            State initialState = std::tuple_cat(box, player);\\n            Q.emplace(initialState);\\n            visited.emplace(stateToUInt32(initialState));\\n        }\\n\\n        // main body of the BFS\\n        while (!Q.empty()) { // x for row, y for col\\n            auto qSize = Q.size();\\n            ++numPushes;\\n            while (qSize--) {\\n                const auto [xBox, yBox, xPlayer, yPlayer] = Q.front();\\n                Q.pop();\\n                if (xBox == xTarget && yBox == yTarget) {\\n                    return numPushes - 1; // got a good solution\\n                }\\n                // optimization: compute the reachability only once for 4 neighboring cells.\\n                auto reachableCells = computeReachableCells(grid, {xBox, yBox}, {xPlayer, yPlayer});\\n                for (int i = 0; i < RowDelta.size(); ++i) { // exploring the 4 neighbor cells\\n                    int8_t newXBox = xBox + RowDelta[i];\\n                    int8_t newYBox = yBox + ColDelta[i];\\n                    int8_t idealXPlayer = xBox - RowDelta[i];\\n                    int8_t idealYPlayer = yBox - ColDelta[i];\\n                    // note that {xBox, yBox} is the new position of the player/storekeeper\\n                    State newState = {newXBox, newYBox, xBox, yBox};\\n                    if (withinBounds(m, n, newXBox, newYBox) // pushable\\n                        && isEmptyCell(grid, newXBox, newYBox)\\n                        && withinBounds(m, n, idealXPlayer, idealYPlayer) //\\n                        && isEmptyCell(grid, idealXPlayer, idealYPlayer)\\n                        // player/storekeeper can reach it\\n                        && reachableCells[idealXPlayer][idealYPlayer]\\n                        // the new state is not visited yet.\\n                        && visited.count(stateToUInt32(newState)) == 0) {\\n                        // enqueue the new state, and mark it as visited.\\n                        Q.emplace(newState);\\n                        visited.emplace(stateToUInt32(newState));\\n                    }\\n                }\\n            } // qSize != 0\\n        } // q not empty\\n\\n        return -1;\\n    }\\n\\nprivate:\\n    static inline bool isEmptyCell(const vector<vector<char>>& grid, int8_t row, int8_t col) {\\n        return grid[row][col] == \\'.\\';\\n    }\\n\\n    static inline bool withinBounds(int8_t m, int8_t n, int8_t row, int8_t col) {\\n        return 0 <= row && row < m && 0 <= col && col < n;\\n    }\\n\\n    static inline uint32_t stateToUInt32(State state) {\\n        const auto [a, b, c, d] = state;\\n        uint32_t res = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8) | (uint32_t)d;\\n        return res;\\n    }\\n\\n    /// use BFS to compute the cells that the player can reach\\n    static vector<vector<bool>>\\n    computeReachableCells(vector<vector<char>>& grid, Position box, Position player) {\\n        const int8_t m = grid.size(), n = grid[0].size();\\n        const auto [xBox, yBox] = box;\\n        const auto [xPlayer, yPlayer] = player;\\n        assert(isEmptyCell(grid, xBox, yBox));\\n        assert(isEmptyCell(grid, xPlayer, yPlayer));\\n        // mark the box\\'s and the storekeeper/player\\'s positions in the grid.\\n        // it\\'ll be restored just before exit.\\n        grid[xBox][yBox] = \\'B\\';\\n        grid[xPlayer][yPlayer] = \\'S\\';\\n        // R is the both the reachability matrix and the visited-ness matrix\\n        vector<vector<bool>> R(m, vector<bool>(n, false));\\n        queue<Position> Q;\\n        R[xPlayer][yPlayer] = true;\\n        Q.emplace(player);\\n        while (!Q.empty()) {\\n            const auto [xpos, ypos] = Q.front();\\n            Q.pop();\\n            for (int i = 0; i < RowDelta.size(); ++i) {\\n                int8_t newXPos = xpos + RowDelta[i];\\n                int8_t newYPos = ypos + ColDelta[i];\\n                if (withinBounds(m, n, newXPos, newYPos) //\\n                    && isEmptyCell(grid, newXPos, newYPos)\\n                    && !R[newXPos][newYPos] // not already visited/reached\\n                ) {\\n                    R[newXPos][newYPos] = true;\\n                    Q.emplace(newXPos, newYPos);\\n                }\\n            }\\n        }\\n        // restore the grid\\n        grid[xBox][yBox] = \\'.\\';\\n        grid[xPlayer][yPlayer] = \\'.\\';\\n\\n        return R;\\n    }\\n\\n    static void extractPositions(\\n            vector<vector<char>>& grid,\\n            Position& player,\\n            Position& box,\\n            Position& target) {\\n        const int m = grid.size(), n = grid[0].size();\\n\\n        for (int8_t r = 0; r < m; ++r) {\\n            for (int8_t c = 0; c < n; ++c) {\\n                if (grid[r][c] == \\'S\\') {\\n                    player = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                } else if (grid[r][c] == \\'B\\') {\\n                    box = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                } else if (grid[r][c] == \\'T\\') {\\n                    target = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n\\nstatic vector<char> stringToVector(const std::string& s) {\\n    return vector<char>(s.begin(), s.end());\\n}\\n\\nvoid test1() {\\n    Solution solver;\\n    // [\\n    // [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n    // [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n    // [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\\n    // [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\\n    // [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n    // [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n    // ]\\n    vector<vector<char>> g{\\n            stringToVector(\"######\"),\\n            stringToVector(\"#T####\"),\\n            stringToVector(\"#..B.#\"),\\n            stringToVector(\"#.##.#\"),\\n            stringToVector(\"#...S#\"),\\n            stringToVector(\"######\")};\\n    std::cout << solver.minPushBox(g) << std::endl;\\n}\\n\\n} // namespace lc1263_push_box\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnamespace lc1263_push_box {\\n// 1263. Minimum Moves to Move a Box to Their Target Location\\nclass Solution {\\npublic:\\n    // BFS over a derived graph, derived from the input grid --\\n    // each vertex in the derived graph has two states:\\n    // * the Storekeeper/Player p{x,y} and\\n    // * the Box location b{x,y}.\\n    //\\n    // A push/move of the box is feasible if\\n    // 1. the storekeeper can go to the position behind the box\\n    // (this will be determined using another \"nested\" BFS. Time complexity of this \"nested\" BFS:\\n    // O(R) where R is the number of reachable cells by the storekeeper/player.).\\n    // 2. the box\\'s new location is empty.\\n    //\\n    // Overal Time-Complexity: O(R*R) since the main BFS queue may contain up to 4*R items, and each\\n    // item may take O(R) time to determine whether player can reach the ideal position to push the\\n    // box.\\n    //\\n    /// we can use a 4-tuple to represent the state:\\n    /// {xBox, yBox, xPlayer, yPlayer}.\\n    /// Note that, except the initial state, the player is always adjacent to the box in the states.\\n    /// so the possibility of the states are at most 4*R where R is the cells that can be reached.\\n    using State = tuple<int8_t, int8_t, int8_t, int8_t>;\\n    using Position = tuple<int8_t, int8_t>;\\n\\n    // deltas for 4 directions to which the box can be pushed.\\n    constexpr static const array<int8_t, 4> RowDelta{1, -1, 0, 0};\\n    constexpr static const array<int8_t, 4> ColDelta{0, 0, 1, -1};\\n\\n    // using C++17 structured binding to extract the parts out of the State:\\n    // auto [boxX, boxY, playerX, playerY] = state;\\n    int minPushBox(vector<vector<char>>& grid) {\\n        // 1 <= m,n <= 20. Thus a byte can represent a {x,y} pair if we use bit-fields.\\n        // but for saving time, we won\\'t do that.\\n        const int8_t m = grid.size(), n = grid[0].size();\\n\\n        // extract the positions of the player and the box, and the target\\n        Position player, box, target;\\n        extractPositions(grid, player, box, target);\\n\\n        // the queue for the main BFS.\\n        queue<State> Q;\\n        unordered_set<uint32_t> visited;\\n\\n        int numPushes = 0;\\n        const auto [xTarget, yTarget] = target;\\n        // enqueue the initial states\\n        {\\n            State initialState = std::tuple_cat(box, player);\\n            Q.emplace(initialState);\\n            visited.emplace(stateToUInt32(initialState));\\n        }\\n\\n        // main body of the BFS\\n        while (!Q.empty()) { // x for row, y for col\\n            auto qSize = Q.size();\\n            ++numPushes;\\n            while (qSize--) {\\n                const auto [xBox, yBox, xPlayer, yPlayer] = Q.front();\\n                Q.pop();\\n                if (xBox == xTarget && yBox == yTarget) {\\n                    return numPushes - 1; // got a good solution\\n                }\\n                // optimization: compute the reachability only once for 4 neighboring cells.\\n                auto reachableCells = computeReachableCells(grid, {xBox, yBox}, {xPlayer, yPlayer});\\n                for (int i = 0; i < RowDelta.size(); ++i) { // exploring the 4 neighbor cells\\n                    int8_t newXBox = xBox + RowDelta[i];\\n                    int8_t newYBox = yBox + ColDelta[i];\\n                    int8_t idealXPlayer = xBox - RowDelta[i];\\n                    int8_t idealYPlayer = yBox - ColDelta[i];\\n                    // note that {xBox, yBox} is the new position of the player/storekeeper\\n                    State newState = {newXBox, newYBox, xBox, yBox};\\n                    if (withinBounds(m, n, newXBox, newYBox) // pushable\\n                        && isEmptyCell(grid, newXBox, newYBox)\\n                        && withinBounds(m, n, idealXPlayer, idealYPlayer) //\\n                        && isEmptyCell(grid, idealXPlayer, idealYPlayer)\\n                        // player/storekeeper can reach it\\n                        && reachableCells[idealXPlayer][idealYPlayer]\\n                        // the new state is not visited yet.\\n                        && visited.count(stateToUInt32(newState)) == 0) {\\n                        // enqueue the new state, and mark it as visited.\\n                        Q.emplace(newState);\\n                        visited.emplace(stateToUInt32(newState));\\n                    }\\n                }\\n            } // qSize != 0\\n        } // q not empty\\n\\n        return -1;\\n    }\\n\\nprivate:\\n    static inline bool isEmptyCell(const vector<vector<char>>& grid, int8_t row, int8_t col) {\\n        return grid[row][col] == \\'.\\';\\n    }\\n\\n    static inline bool withinBounds(int8_t m, int8_t n, int8_t row, int8_t col) {\\n        return 0 <= row && row < m && 0 <= col && col < n;\\n    }\\n\\n    static inline uint32_t stateToUInt32(State state) {\\n        const auto [a, b, c, d] = state;\\n        uint32_t res = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8) | (uint32_t)d;\\n        return res;\\n    }\\n\\n    /// use BFS to compute the cells that the player can reach\\n    static vector<vector<bool>>\\n    computeReachableCells(vector<vector<char>>& grid, Position box, Position player) {\\n        const int8_t m = grid.size(), n = grid[0].size();\\n        const auto [xBox, yBox] = box;\\n        const auto [xPlayer, yPlayer] = player;\\n        assert(isEmptyCell(grid, xBox, yBox));\\n        assert(isEmptyCell(grid, xPlayer, yPlayer));\\n        // mark the box\\'s and the storekeeper/player\\'s positions in the grid.\\n        // it\\'ll be restored just before exit.\\n        grid[xBox][yBox] = \\'B\\';\\n        grid[xPlayer][yPlayer] = \\'S\\';\\n        // R is the both the reachability matrix and the visited-ness matrix\\n        vector<vector<bool>> R(m, vector<bool>(n, false));\\n        queue<Position> Q;\\n        R[xPlayer][yPlayer] = true;\\n        Q.emplace(player);\\n        while (!Q.empty()) {\\n            const auto [xpos, ypos] = Q.front();\\n            Q.pop();\\n            for (int i = 0; i < RowDelta.size(); ++i) {\\n                int8_t newXPos = xpos + RowDelta[i];\\n                int8_t newYPos = ypos + ColDelta[i];\\n                if (withinBounds(m, n, newXPos, newYPos) //\\n                    && isEmptyCell(grid, newXPos, newYPos)\\n                    && !R[newXPos][newYPos] // not already visited/reached\\n                ) {\\n                    R[newXPos][newYPos] = true;\\n                    Q.emplace(newXPos, newYPos);\\n                }\\n            }\\n        }\\n        // restore the grid\\n        grid[xBox][yBox] = \\'.\\';\\n        grid[xPlayer][yPlayer] = \\'.\\';\\n\\n        return R;\\n    }\\n\\n    static void extractPositions(\\n            vector<vector<char>>& grid,\\n            Position& player,\\n            Position& box,\\n            Position& target) {\\n        const int m = grid.size(), n = grid[0].size();\\n\\n        for (int8_t r = 0; r < m; ++r) {\\n            for (int8_t c = 0; c < n; ++c) {\\n                if (grid[r][c] == \\'S\\') {\\n                    player = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                } else if (grid[r][c] == \\'B\\') {\\n                    box = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                } else if (grid[r][c] == \\'T\\') {\\n                    target = {r, c};\\n                    grid[r][c] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n\\nstatic vector<char> stringToVector(const std::string& s) {\\n    return vector<char>(s.begin(), s.end());\\n}\\n\\nvoid test1() {\\n    Solution solver;\\n    // [\\n    // [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\\n    // [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\\n    // [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\\n    // [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\\n    // [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\\n    // [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n    // ]\\n    vector<vector<char>> g{\\n            stringToVector(\"######\"),\\n            stringToVector(\"#T####\"),\\n            stringToVector(\"#..B.#\"),\\n            stringToVector(\"#.##.#\"),\\n            stringToVector(\"#...S#\"),\\n            stringToVector(\"######\")};\\n    std::cout << solver.minPushBox(g) << std::endl;\\n}\\n\\n} // namespace lc1263_push_box\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1904775,
                "title": "python-bfs-a",
                "content": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # get target, box, person\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n        \\n        # \\n        def valid(x,y):\\n            return 0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"\\n        \\n        # heuristic\\n        def heuristic(box):\\n            return abs(box[0]-target[0]) + abs(box[1]-target[1])\\n        \\n        \\n        # check person can go to the position to push box\\n        def check(cur,dist,box):\\n            q = deque([cur])\\n            visited = {cur}\\n            while q:\\n                pos = q.popleft()\\n                if pos == dist:\\n                    return True\\n                nex = [(pos[0]+1, pos[1]),(pos[0]-1, pos[1]),(pos[0], pos[1]+1),(pos[0], pos[1]-1)]\\n                for x, y in nex:\\n                    if valid(x,y) and (x,y) not in visited and (x,y) != box:\\n                        q.append((x,y))\\n                        visited.add((x,y))\\n            return False\\n        \\n        \\n        # bfs\\n        #q = deque([(0,box,person)])\\n        pq = [(heuristic(box),0,box,person)]\\n        seen = {(box,person)}\\n        #while q:\\n        while pq:\\n            #ans, b, p = q.popleft()\\n            _, ans, b, p = heapq.heappop(pq)\\n            if b == target:\\n                return ans\\n            \\n            for di, dj in [(1,0),(0,1),(-1,0),(0,-1)]:\\n                b_nxt = (b[0]+di, b[1]+dj)\\n                p_nxt = (b[0]-di, b[1]-dj)\\n                \\n                if valid(*b_nxt) and (b_nxt,p_nxt) not in seen:\\n                    if valid(*p_nxt) and check(p,p_nxt,b):\\n                        seen.add((b_nxt,p_nxt))\\n                        #q.append((ans+1,b_nxt,p_nxt))\\n                        heapq.heappush(pq,(heuristic(b_nxt)+ans+1,ans+1,b_nxt,p_nxt))\\n                    \\n                \\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # get target, box, person\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"T\":\\n                    target = (i,j)\\n                if grid[i][j] == \"B\":\\n                    box = (i,j)\\n                if grid[i][j] == \"S\":\\n                    person = (i,j)\\n        \\n        # \\n        def valid(x,y):\\n            return 0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"\\n        \\n        # heuristic\\n        def heuristic(box):\\n            return abs(box[0]-target[0]) + abs(box[1]-target[1])\\n        \\n        \\n        # check person can go to the position to push box\\n        def check(cur,dist,box):\\n            q = deque([cur])\\n            visited = {cur}\\n            while q:\\n                pos = q.popleft()\\n                if pos == dist:\\n                    return True\\n                nex = [(pos[0]+1, pos[1]),(pos[0]-1, pos[1]),(pos[0], pos[1]+1),(pos[0], pos[1]-1)]\\n                for x, y in nex:\\n                    if valid(x,y) and (x,y) not in visited and (x,y) != box:\\n                        q.append((x,y))\\n                        visited.add((x,y))\\n            return False\\n        \\n        \\n        # bfs\\n        #q = deque([(0,box,person)])\\n        pq = [(heuristic(box),0,box,person)]\\n        seen = {(box,person)}\\n        #while q:\\n        while pq:\\n            #ans, b, p = q.popleft()\\n            _, ans, b, p = heapq.heappop(pq)\\n            if b == target:\\n                return ans\\n            \\n            for di, dj in [(1,0),(0,1),(-1,0),(0,-1)]:\\n                b_nxt = (b[0]+di, b[1]+dj)\\n                p_nxt = (b[0]-di, b[1]-dj)\\n                \\n                if valid(*b_nxt) and (b_nxt,p_nxt) not in seen:\\n                    if valid(*p_nxt) and check(p,p_nxt,b):\\n                        seen.add((b_nxt,p_nxt))\\n                        #q.append((ans+1,b_nxt,p_nxt))\\n                        heapq.heappush(pq,(heuristic(b_nxt)+ans+1,ans+1,b_nxt,p_nxt))\\n                    \\n                \\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893073,
                "title": "c-o-mn-mn-bfs-on-bfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct BoardState {\\n    public:\\n        int bR, bC;\\n        int wR, wC;\\n        \\n        BoardState(int _bR, int _bC, int _wR, int _wC) {\\n            bR = _bR;\\n            bC = _bC;\\n            wR = _wR;\\n            wC = _wC;\\n        }\\n    };\\n    \\n    const int dir[5] = {0, 1, 0, -1, 0};\\n    int rSize, cSize;\\n    \\n    bool inBound(int r, int c) {\\n        return (r >= 0 && c >= 0 && r < rSize && c < cSize);\\n    }\\n    \\n    // This part of the code uses BFS to try find from which direction we can push the box\\n    void bfsWorker(vector<bool> &pushDir, vector<vector<char>> &grid, BoardState &s) {\\n        vector<vector<bool>> memo (rSize, vector<bool>(cSize, false));\\n        queue<pair<int, int>> bfsQ;\\n        \\n        bfsQ.emplace(s.wR, s.wC);\\n        memo[s.wR][s.wC] = true;\\n        \\n        while (!bfsQ.empty()) {\\n            int currR = bfsQ.front().first;\\n            int currC = bfsQ.front().second;\\n            bfsQ.pop();\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int nextR = currR + dir[i];\\n                int nextC = currC + dir[i + 1];\\n                if (inBound(nextR, nextC)) {\\n                    if (nextR == s.bR && nextC == s.bC) {\\n                        pushDir[i] = true;\\n                    } else if (!memo[nextR][nextC] && grid[nextR][nextC] != \\'#\\') {\\n                        bfsQ.emplace(nextR, nextC);\\n                        memo[nextR][nextC] = true;\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int initWR, initWC; // initial worker coordinates\\n        int initBR, initBC; // initial box coordinates\\n        int tarR, tarC;     // target coordinates\\n        \\n        // Find initial locations\\n        rSize = grid.size();\\n        cSize = grid[0].size();\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                switch (grid[r][c]) {\\n                    case \\'B\\':\\n                        initBR = r;\\n                        initBC = c;\\n                        break;\\n                    case \\'T\\':\\n                        tarR = r;\\n                        tarC = c;\\n                        break;\\n                    case \\'S\\':\\n                        initWR = r;\\n                        initWC = c;\\n                        break;\\n                    default:\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        // Use BFS to search location of the box\\n        // Note that a box can travel the same direction, but to reduce duplicated calculations\\n        // we have to memoize the direciton where the box is pushed from to the current slot\\n        queue<BoardState> bfsQ;\\n        vector<vector<vector<bool>>> memo(rSize, vector<vector<bool>>(cSize, vector<bool>(4, false)));\\n        \\n        bfsQ.emplace(initBR, initBC, initWR, initWC);\\n        \\n        int steps = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                BoardState currState = bfsQ.front();\\n                bfsQ.pop();\\n                \\n                if (currState.bR == tarR && currState.bC == tarC)\\n                    return steps;\\n                \\n                vector<bool> pushDir(4, false); // direction we can push from\\n                bfsWorker(pushDir, grid, currState);\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    if (!pushDir[i]) continue;\\n                    int nextBR = currState.bR + dir[i];\\n                    int nextBC = currState.bC + dir[i + 1];\\n                    if (inBound(nextBR, nextBC) && !memo[nextBR][nextBC][i] && grid[nextBR][nextBC] != \\'#\\') {\\n                        memo[nextBR][nextBC][i] = true;\\n                        bfsQ.emplace(nextBR, nextBC, currState.bR, currState.bC);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct BoardState {\\n    public:\\n        int bR, bC;\\n        int wR, wC;\\n        \\n        BoardState(int _bR, int _bC, int _wR, int _wC) {\\n            bR = _bR;\\n            bC = _bC;\\n            wR = _wR;\\n            wC = _wC;\\n        }\\n    };\\n    \\n    const int dir[5] = {0, 1, 0, -1, 0};\\n    int rSize, cSize;\\n    \\n    bool inBound(int r, int c) {\\n        return (r >= 0 && c >= 0 && r < rSize && c < cSize);\\n    }\\n    \\n    // This part of the code uses BFS to try find from which direction we can push the box\\n    void bfsWorker(vector<bool> &pushDir, vector<vector<char>> &grid, BoardState &s) {\\n        vector<vector<bool>> memo (rSize, vector<bool>(cSize, false));\\n        queue<pair<int, int>> bfsQ;\\n        \\n        bfsQ.emplace(s.wR, s.wC);\\n        memo[s.wR][s.wC] = true;\\n        \\n        while (!bfsQ.empty()) {\\n            int currR = bfsQ.front().first;\\n            int currC = bfsQ.front().second;\\n            bfsQ.pop();\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int nextR = currR + dir[i];\\n                int nextC = currC + dir[i + 1];\\n                if (inBound(nextR, nextC)) {\\n                    if (nextR == s.bR && nextC == s.bC) {\\n                        pushDir[i] = true;\\n                    } else if (!memo[nextR][nextC] && grid[nextR][nextC] != \\'#\\') {\\n                        bfsQ.emplace(nextR, nextC);\\n                        memo[nextR][nextC] = true;\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        int initWR, initWC; // initial worker coordinates\\n        int initBR, initBC; // initial box coordinates\\n        int tarR, tarC;     // target coordinates\\n        \\n        // Find initial locations\\n        rSize = grid.size();\\n        cSize = grid[0].size();\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                switch (grid[r][c]) {\\n                    case \\'B\\':\\n                        initBR = r;\\n                        initBC = c;\\n                        break;\\n                    case \\'T\\':\\n                        tarR = r;\\n                        tarC = c;\\n                        break;\\n                    case \\'S\\':\\n                        initWR = r;\\n                        initWC = c;\\n                        break;\\n                    default:\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        // Use BFS to search location of the box\\n        // Note that a box can travel the same direction, but to reduce duplicated calculations\\n        // we have to memoize the direciton where the box is pushed from to the current slot\\n        queue<BoardState> bfsQ;\\n        vector<vector<vector<bool>>> memo(rSize, vector<vector<bool>>(cSize, vector<bool>(4, false)));\\n        \\n        bfsQ.emplace(initBR, initBC, initWR, initWC);\\n        \\n        int steps = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                BoardState currState = bfsQ.front();\\n                bfsQ.pop();\\n                \\n                if (currState.bR == tarR && currState.bC == tarC)\\n                    return steps;\\n                \\n                vector<bool> pushDir(4, false); // direction we can push from\\n                bfsWorker(pushDir, grid, currState);\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    if (!pushDir[i]) continue;\\n                    int nextBR = currState.bR + dir[i];\\n                    int nextBC = currState.bC + dir[i + 1];\\n                    if (inBound(nextBR, nextBC) && !memo[nextBR][nextBC][i] && grid[nextBR][nextBC] != \\'#\\') {\\n                        memo[nextBR][nextBC][i] = true;\\n                        bfsQ.emplace(nextBR, nextBC, currState.bR, currState.bC);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891706,
                "title": "easy-to-understand-beginners-friendly-c-80ms",
                "content": "~~~\\nclass Solution {\\npublic:\\n    string get4(int a, int b, int c, int d){  \\n        return to_string(a) + \"#\" + to_string(b) + \"#\" + to_string(c) + \"#\" + to_string(d);\\n    }\\n    int minPushBox(vector<vector<char>>& grid) {\\n        pair<int,int> b,p;\\n       for(int i=0;i<grid.size();i++){\\n           for(int j=0;j<grid[0].size();j++){\\n               if(grid[i][j]==\\'S\\')p={i,j};\\n               if(grid[i][j]==\\'B\\'){\\n                   grid[i][j]=\\'.\\';\\n                   b={i,j};\\n               }\\n           }\\n       }\\n        unordered_set<string> s;\\n        queue<vector<int>> q;\\n        q.push({b.first,b.second,p.first,p.second});\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n               int i=q.front()[0];          // mat[i][j] is the current position of a Box\\n                int j=q.front()[1];\\n                int pi=q.front()[2];        //mat[pi][pj] is the current position of a person\\n                int pj=q.front()[3];\\n                q.pop();\\n                if(grid[i][j]==\\'T\\')return ans;\\n                if(i-1>=0&&grid[i-1][j]!=\\'#\\'&&s.count(get4(i,j,i+1,j))==0&&ispos(grid,i,j,i+1,j,pi,pj)){\\n                    s.insert(get4(i,j,i+1,j));\\n                    q.push({i-1,j,i+1,j});\\n                }\\n                if(i+1<grid.size()&&grid[i+1][j]!=\\'#\\'&&s.count(get4(i,j,i-1,j))==0&&ispos(grid,i,j,i-1,j,pi,pj)){\\n                    s.insert(get4(i,j,i-1,j));\\n                    q.push({i+1,j,i-1,j});\\n                }\\n                if(j-1>=0&&grid[i][j-1]!=\\'#\\'&&s.count(get4(i,j,i,j+1))==0&&ispos(grid,i,j,i,j+1,pi,pj)){\\n                   s.insert(get4(i,j,i,j+1));\\n                    q.push({i,j-1,i,j+1});\\n                }\\n                if(j+1<grid[0].size()&&grid[i][j+1]!=\\'#\\'&&s.count(get4(i,j,i,j-1))==0&&ispos(grid,i,j,i,j-1,pi,pj)){\\n                    s.insert(get4(i,j,i,j-1));\\n                    q.push({i,j+1,i,j-1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n    bool ispos(vector<vector<char>>&nums,int bi, int bj, int fi,int fj,int ii,int ij){\\n        if(fi<0||fi>=nums.size()||fj<0||fj>=nums[0].size())return false;\\n        if(fi==ii&&fj==ij)return true;\\n        char c=nums[bi][bj];\\n        nums[bi][bj]=\\'#\\';\\n        queue<pair<int,int>> q;\\n        q.push({ii,ij});\\n        vector<vector<int>> visited(nums.size(),vector<int>(nums[0].size(),0));\\n        while(!q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                int i=q.front().first;\\n                int j=q.front().second;\\n                if(i==fi&&j==fj){\\n                    nums[bi][bj]=c;\\n                    return true;\\n                }\\n                q.pop();\\n                if(i-1>=0&&visited[i-1][j]==0&&nums[i-1][j]!=\\'#\\'){\\n                    visited[i-1][j]=1;\\n                    q.push({i-1,j});\\n                }\\n                if(i+1<nums.size()&&visited[i+1][j]==0&&nums[i+1][j]!=\\'#\\'){\\n                    visited[i+1][j]=1;\\n                    q.push({i+1,j});\\n                }\\n                if(j-1>=0&&visited[i][j-1]==0&&nums[i][j-1]!=\\'#\\'){\\n                    visited[i][j-1]=1;\\n                    q.push({i,j-1});\\n                }\\n                if(j+1<nums[0].size()&&visited[i][j+1]==0&&nums[i][j+1]!=\\'#\\'){\\n                    visited[i][j+1]=1;\\n                    q.push({i,j+1});\\n                }\\n            }\\n        }\\n        nums[bi][bj]=c;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string get4(int a, int b, int c, int d){  \\n        return to_string(a) + \"#\" + to_string(b) + \"#\" + to_string(c) + \"#\" + to_string(d);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1848418,
                "title": "c-brute-force-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Status {\\n        int mr;\\n        int mc;\\n        int mf; // 0 = up, 1 = left, 2 = down, 3 = right\\n        int br;\\n        int bc;\\n        int cnt;\\n    };\\n        \\n    void pushInitStatus(queue<Status>& qu, vector<vector<char>>& grid,\\n                        int rows, int cols, unordered_map<long long, int>& mp) {\\n        Status s;\\n        s.cnt = 0;\\n        s.mf = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                if (grid[i][j] == \\'B\\') {\\n                    s.br = i;\\n                    s.bc = j;\\n                } else if (grid[i][j] == \\'S\\') {\\n                    s.mr = i;\\n                    s.mc = j;\\n                }\\n            }\\n        }\\n        long long hash = (long long)(s.br + 1) * 100000000L\\n                            + (long long)(s.bc + 1) * 1000000\\n                            + (s.mr + 1) * 10000 + (s.mc + 1) * 100\\n                            + s.mf + 1;\\n        mp[hash] = 0;\\n        qu.push(s);\\n        for (int i = 0; i < 3; ++i) {\\n            s.mf++;\\n            hash++;\\n            mp[hash] = 0;\\n            qu.push(s);\\n        }\\n    }\\n    \\n    int getManWithBoxFace(Status& s) {\\n        if (s.mr == s.br + 1 && s.mc == s.bc) {\\n            return 0;\\n        }\\n        if (s.mr == s.br && s.mc == s.bc + 1) {\\n            return 1;\\n        }\\n        if (s.mr == s.br - 1 && s.mc == s.bc) {\\n            return 2;\\n        }\\n        if (s.mr == s.br && s.mc == s.bc - 1) {\\n            return 3;\\n        }\\n        return -1;\\n    }\\n    \\n    void expand(queue<Status>& qu, vector<vector<char>>& grid, int rows, int cols,\\n                unordered_map<long long, int>& mp, int dirs[4][2], Status& prev, int pos, bool manWithBox) {\\n        Status next;\\n        next.cnt = prev.cnt;\\n        next.mf = pos;\\n        next.mr = prev.mr + dirs[pos][0];\\n        next.mc = prev.mc + dirs[pos][1];\\n        next.br = prev.br;\\n        next.bc = prev.bc;\\n        if (manWithBox) {\\n            next.br = next.br + dirs[pos][0];\\n            next.bc = next.bc + dirs[pos][1];\\n            next.cnt++;\\n        }\\n        if (next.mr >= 0 && next.mr < rows && next.mc >= 0 && next.mc < cols && next.br >= 0 \\n                && next.br < rows && next.bc >= 0 && next.bc < cols) {\\n            if (grid[next.mr][next.mc] != \\'#\\' && grid[next.br][next.bc] != \\'#\\'\\n                    && (next.mr != next.br || next.mc != next.bc)) {\\n                long long hash = (long long)(next.br + 1) * 100000000L \\n                                    + (long long)(next.bc + 1) * 1000000\\n                                    + (next.mr + 1) * 10000 + (next.mc + 1) * 100 \\n                                    + next.mf + 1;\\n                if (!mp.count(hash) || mp[hash] > next.cnt) {\\n                    mp[hash] = next.cnt;\\n                    qu.push(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        queue<Status> qu;\\n        int dirs[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        unordered_map<long long, int> mp;\\n        pushInitStatus(qu, grid, rows, cols, mp);\\n        int ans = INT_MAX;\\n        while (!qu.empty()) {\\n            Status prev = qu.front();\\n            qu.pop();\\n            if (grid[prev.br][prev.bc] == \\'T\\') {\\n                if (ans > prev.cnt) {\\n                    ans = prev.cnt;\\n                }\\n                continue;\\n            }\\n            int manWithBoxFace = getManWithBoxFace(prev);\\n            if (manWithBoxFace != -1) {\\n                expand(qu, grid, rows, cols, mp, dirs, prev, manWithBoxFace, true);   // expand most possible first, but still cannot guarantee the first reached T is the shortest.\\n            }\\n            for (int i = 0; i < 4; ++i) {\\n                if (i != manWithBoxFace) {\\n                    expand(qu, grid, rows, cols, mp, dirs, prev, i, false);\\n                }\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Status {\\n        int mr;\\n        int mc;\\n        int mf; // 0 = up, 1 = left, 2 = down, 3 = right\\n        int br;\\n        int bc;\\n        int cnt;\\n    };\\n        \\n    void pushInitStatus(queue<Status>& qu, vector<vector<char>>& grid,\\n                        int rows, int cols, unordered_map<long long, int>& mp) {\\n        Status s;\\n        s.cnt = 0;\\n        s.mf = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                if (grid[i][j] == \\'B\\') {\\n                    s.br = i;\\n                    s.bc = j;\\n                } else if (grid[i][j] == \\'S\\') {\\n                    s.mr = i;\\n                    s.mc = j;\\n                }\\n            }\\n        }\\n        long long hash = (long long)(s.br + 1) * 100000000L\\n                            + (long long)(s.bc + 1) * 1000000\\n                            + (s.mr + 1) * 10000 + (s.mc + 1) * 100\\n                            + s.mf + 1;\\n        mp[hash] = 0;\\n        qu.push(s);\\n        for (int i = 0; i < 3; ++i) {\\n            s.mf++;\\n            hash++;\\n            mp[hash] = 0;\\n            qu.push(s);\\n        }\\n    }\\n    \\n    int getManWithBoxFace(Status& s) {\\n        if (s.mr == s.br + 1 && s.mc == s.bc) {\\n            return 0;\\n        }\\n        if (s.mr == s.br && s.mc == s.bc + 1) {\\n            return 1;\\n        }\\n        if (s.mr == s.br - 1 && s.mc == s.bc) {\\n            return 2;\\n        }\\n        if (s.mr == s.br && s.mc == s.bc - 1) {\\n            return 3;\\n        }\\n        return -1;\\n    }\\n    \\n    void expand(queue<Status>& qu, vector<vector<char>>& grid, int rows, int cols,\\n                unordered_map<long long, int>& mp, int dirs[4][2], Status& prev, int pos, bool manWithBox) {\\n        Status next;\\n        next.cnt = prev.cnt;\\n        next.mf = pos;\\n        next.mr = prev.mr + dirs[pos][0];\\n        next.mc = prev.mc + dirs[pos][1];\\n        next.br = prev.br;\\n        next.bc = prev.bc;\\n        if (manWithBox) {\\n            next.br = next.br + dirs[pos][0];\\n            next.bc = next.bc + dirs[pos][1];\\n            next.cnt++;\\n        }\\n        if (next.mr >= 0 && next.mr < rows && next.mc >= 0 && next.mc < cols && next.br >= 0 \\n                && next.br < rows && next.bc >= 0 && next.bc < cols) {\\n            if (grid[next.mr][next.mc] != \\'#\\' && grid[next.br][next.bc] != \\'#\\'\\n                    && (next.mr != next.br || next.mc != next.bc)) {\\n                long long hash = (long long)(next.br + 1) * 100000000L \\n                                    + (long long)(next.bc + 1) * 1000000\\n                                    + (next.mr + 1) * 10000 + (next.mc + 1) * 100 \\n                                    + next.mf + 1;\\n                if (!mp.count(hash) || mp[hash] > next.cnt) {\\n                    mp[hash] = next.cnt;\\n                    qu.push(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minPushBox(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        queue<Status> qu;\\n        int dirs[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        unordered_map<long long, int> mp;\\n        pushInitStatus(qu, grid, rows, cols, mp);\\n        int ans = INT_MAX;\\n        while (!qu.empty()) {\\n            Status prev = qu.front();\\n            qu.pop();\\n            if (grid[prev.br][prev.bc] == \\'T\\') {\\n                if (ans > prev.cnt) {\\n                    ans = prev.cnt;\\n                }\\n                continue;\\n            }\\n            int manWithBoxFace = getManWithBoxFace(prev);\\n            if (manWithBoxFace != -1) {\\n                expand(qu, grid, rows, cols, mp, dirs, prev, manWithBoxFace, true);   // expand most possible first, but still cannot guarantee the first reached T is the shortest.\\n            }\\n            for (int i = 0; i < 4; ++i) {\\n                if (i != manWithBoxFace) {\\n                    expand(qu, grid, rows, cols, mp, dirs, prev, i, false);\\n                }\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751903,
                "title": "c-version-bfs-nested-with-bfs",
                "content": "A classic BFS problem , with new constraints for the player to reach the right pos from its current pos so it can push the box.    Note that a box and pass a same position twice. The first time to make room to let the player pass.  So the visited[] flag needs the combination of box + player positions as a single key. \\n\\n```\\nclass Solution {\\n\\n        \\n    int row, col; \\n    \\n    // find initial position of player S, box B and Target T\\n    void initialScan (vector<vector<char>>& grid, pair<int,int>& playerPos,   pair<int,int>& boxPos,  pair<int,int>& targetPos)\\n    {\\n        for (int i=0; i<row; i++)\\n            for (int j=0; j<col; j++)\\n            {\\n                if (grid[i][j]==\\'S\\')\\n                    playerPos={i,j};\\n                else if (grid[i][j]==\\'B\\')\\n                    boxPos={i,j};\\n                else if (grid[i][j]==\\'T\\')\\n                    targetPos={i,j};\\n            }\\n    }\\n    //Check if a coordinate is valid pos to move a box or person into\\n    bool validPos(vector<vector<char>>& grid, int x, int y) \\n    {  // it can be S, T, and B: they change values\\n        return x>=0 && x<row && y>=0 && y<col && grid[x][y]!=\\'#\\'; \\n    }    \\n    // check if a person can reach an end pos from a start pos    \\n    bool reacheableByPerson (vector<vector<char>>& grid, pair<int,int>boxPos, pair<int,int> start_pos, pair<int,int> end_pos)\\n    {\\n        // Using BFS, consider current box pos, which can block the way\\n        queue<pair<int,int>> q; // push, pop, front\\n        // more efficient, a visited flag: if a pos has been pushed into the queue\\n        unordered_map <int, unordered_map<int, bool>> visited; \\n        \\n        q.push(start_pos); \\n        visited[start_pos.first][start_pos.second]=true; \\n        while (q.size())\\n        {\\n            int sz=q.size(); \\n            while (sz--)\\n            {\\n                auto [a,b] = q.front(); \\n                q.pop(); \\n                \\n                if (a==end_pos.first && b== end_pos.second)\\n                    return true; \\n                \\n                // 4 directions\\n                vector <pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}}; \\n                for (auto d: dirs)\\n                {\\n                    pair<int,int> nextPos= {a+d.first, b+d.second}; \\n                    if (validPos(grid, nextPos.first, nextPos.second) \\n                         && !visited[nextPos.first][nextPos.second]\\n                       && nextPos !=boxPos)\\n                    {\\n                        q.push (nextPos);\\n                        visited[nextPos.first][nextPos.second]=true; \\n                    }\\n                }                \\n            }\\n        }        \\n        return false; \\n    }\\n    \\n    int linearize(pair<int,int> pos)\\n    {\\n        return pos.first * col + pos.second; \\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        row=grid.size();\\n        if (row==0)\\n            return -1; \\n        col=grid[0].size(); \\n        \\n        pair<int,int> playerPos, boxPos, targetPos; \\n        initialScan (grid, playerPos, boxPos, targetPos);\\n        \\n        // now focus on the box, do the BFS \\n        // must also store current person pos??  box and person\\n        queue< vector<pair<int,int>> > q; \\n        // HUGE MISTAKE:  a box may away from one place to leave room for person to pass, then move back to an old place!!\\n        // unordered_map <int, unordered_map<int, bool>> visited; \\n        // without this : timeout\\n        // A compromise: the combination of box and person position!!\\n        unordered_map <int, unordered_map<int, bool>> visited; \\n        \\n        vector<pair<int,int>> node;\\n        node.push_back(boxPos); node.push_back(playerPos);\\n        q.push(node); \\n        visited[linearize(boxPos)][linearize(playerPos)]=true; \\n        int moveCount=0; \\n        while (q.size())\\n        {\\n            int sz=q.size(); \\n            while (sz--)\\n            {\\n                vector<pair<int,int>> cur_node = q.front(); \\n                q.pop(); \\n                boxPos= cur_node[0];\\n                playerPos= cur_node[1];\\n                \\n                if (boxPos==targetPos)\\n                    return moveCount; \\n                \\n                // 4 directions\\n                vector <pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}}; \\n                // 4 opposite directions? \\n                for (auto d: dirs)\\n                {\\n                    pair<int, int> newPlayerPos= boxPos; \\n                    if (d.first==0)\\n                        newPlayerPos.second-= d.second; \\n                    else  if (d.second==0)\\n                        newPlayerPos.first-= d.first; \\n                    \\n                    pair<int,int> nextPos= {boxPos.first +d.first, boxPos.second + d.second}; \\n                    if (validPos(grid, nextPos.first, nextPos.second) \\n                        && !visited[linearize(nextPos)][linearize(playerPos)]\\n                       && reacheableByPerson(grid, boxPos, playerPos, newPlayerPos) )\\n                    {\\n                        vector<pair<int,int>> next_node; \\n                        next_node.push_back(nextPos);\\n                        next_node.push_back(newPlayerPos);\\n                        \\n                        q.push (next_node);\\n                        visited[linearize(nextPos)][linearize(playerPos)]=true; \\n                    }\\n                }                \\n            }\\n            moveCount++; \\n        }        \\n        return -1;         \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n        \\n    int row, col; \\n    \\n    // find initial position of player S, box B and Target T\\n    void initialScan (vector<vector<char>>& grid, pair<int,int>& playerPos,   pair<int,int>& boxPos,  pair<int,int>& targetPos)\\n    {\\n        for (int i=0; i<row; i++)\\n            for (int j=0; j<col; j++)\\n            {\\n                if (grid[i][j]==\\'S\\')\\n                    playerPos={i,j};\\n                else if (grid[i][j]==\\'B\\')\\n                    boxPos={i,j};\\n                else if (grid[i][j]==\\'T\\')\\n                    targetPos={i,j};\\n            }\\n    }\\n    //Check if a coordinate is valid pos to move a box or person into\\n    bool validPos(vector<vector<char>>& grid, int x, int y) \\n    {  // it can be S, T, and B: they change values\\n        return x>=0 && x<row && y>=0 && y<col && grid[x][y]!=\\'#\\'; \\n    }    \\n    // check if a person can reach an end pos from a start pos    \\n    bool reacheableByPerson (vector<vector<char>>& grid, pair<int,int>boxPos, pair<int,int> start_pos, pair<int,int> end_pos)\\n    {\\n        // Using BFS, consider current box pos, which can block the way\\n        queue<pair<int,int>> q; // push, pop, front\\n        // more efficient, a visited flag: if a pos has been pushed into the queue\\n        unordered_map <int, unordered_map<int, bool>> visited; \\n        \\n        q.push(start_pos); \\n        visited[start_pos.first][start_pos.second]=true; \\n        while (q.size())\\n        {\\n            int sz=q.size(); \\n            while (sz--)\\n            {\\n                auto [a,b] = q.front(); \\n                q.pop(); \\n                \\n                if (a==end_pos.first && b== end_pos.second)\\n                    return true; \\n                \\n                // 4 directions\\n                vector <pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}}; \\n                for (auto d: dirs)\\n                {\\n                    pair<int,int> nextPos= {a+d.first, b+d.second}; \\n                    if (validPos(grid, nextPos.first, nextPos.second) \\n                         && !visited[nextPos.first][nextPos.second]\\n                       && nextPos !=boxPos)\\n                    {\\n                        q.push (nextPos);\\n                        visited[nextPos.first][nextPos.second]=true; \\n                    }\\n                }                \\n            }\\n        }        \\n        return false; \\n    }\\n    \\n    int linearize(pair<int,int> pos)\\n    {\\n        return pos.first * col + pos.second; \\n    }\\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        row=grid.size();\\n        if (row==0)\\n            return -1; \\n        col=grid[0].size(); \\n        \\n        pair<int,int> playerPos, boxPos, targetPos; \\n        initialScan (grid, playerPos, boxPos, targetPos);\\n        \\n        // now focus on the box, do the BFS \\n        // must also store current person pos??  box and person\\n        queue< vector<pair<int,int>> > q; \\n        // HUGE MISTAKE:  a box may away from one place to leave room for person to pass, then move back to an old place!!\\n        // unordered_map <int, unordered_map<int, bool>> visited; \\n        // without this : timeout\\n        // A compromise: the combination of box and person position!!\\n        unordered_map <int, unordered_map<int, bool>> visited; \\n        \\n        vector<pair<int,int>> node;\\n        node.push_back(boxPos); node.push_back(playerPos);\\n        q.push(node); \\n        visited[linearize(boxPos)][linearize(playerPos)]=true; \\n        int moveCount=0; \\n        while (q.size())\\n        {\\n            int sz=q.size(); \\n            while (sz--)\\n            {\\n                vector<pair<int,int>> cur_node = q.front(); \\n                q.pop(); \\n                boxPos= cur_node[0];\\n                playerPos= cur_node[1];\\n                \\n                if (boxPos==targetPos)\\n                    return moveCount; \\n                \\n                // 4 directions\\n                vector <pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}}; \\n                // 4 opposite directions? \\n                for (auto d: dirs)\\n                {\\n                    pair<int, int> newPlayerPos= boxPos; \\n                    if (d.first==0)\\n                        newPlayerPos.second-= d.second; \\n                    else  if (d.second==0)\\n                        newPlayerPos.first-= d.first; \\n                    \\n                    pair<int,int> nextPos= {boxPos.first +d.first, boxPos.second + d.second}; \\n                    if (validPos(grid, nextPos.first, nextPos.second) \\n                        && !visited[linearize(nextPos)][linearize(playerPos)]\\n                       && reacheableByPerson(grid, boxPos, playerPos, newPlayerPos) )\\n                    {\\n                        vector<pair<int,int>> next_node; \\n                        next_node.push_back(nextPos);\\n                        next_node.push_back(newPlayerPos);\\n                        \\n                        q.push (next_node);\\n                        visited[linearize(nextPos)][linearize(playerPos)]=true; \\n                    }\\n                }                \\n            }\\n            moveCount++; \\n        }        \\n        return -1;         \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726926,
                "title": "everytime-i-use-spfa-leetcode-will-give-me-tle",
                "content": "Kinda forced to write dijkstra + heap here\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'S\\':\\n                    start=(i,j)\\n                elif grid[i][j]==\\'B\\':\\n                    box_start=(i,j)\\n                elif grid[i][j]==\\'T\\':\\n                    end=(i,j)\\n        state=(0,start,box_start)\\n        queue=[state]\\n        visited=set()\\n        dirs=[[0,1],[0,-1],[1,0],[-1,0]]\\n        ## [0,1]:go south\\n        ## [0,-1]:go north\\n        ## [1,0]: go east\\n        ## [-1,0]: go west\\n        while queue:\\n            \\n            st=heapq.heappop(queue)\\n            steps=st[0]\\n            coord=st[1]\\n            x,y=coord[0],coord[1]\\n            box_coord=st[2]\\n            box_x,box_y=box_coord[0],box_coord[1]\\n            ##\\u72B6\\u6001\\u662F\\u4EBA\\u548C\\u7BB1\\u5B50\\u7684\\u5750\\u6807\\u7EC4\\u6210\\u7684\\u5143\\u7EC4\\n            st1=(coord,box_coord)\\n            ##\\u5982\\u679C\\u72B6\\u6001\\n            if st1 in visited:\\n                continue\\n            visited.add(st1)\\n            if box_coord==end:\\n                return steps\\n            for d in dirs:\\n                if 0<=d[0]+x<m and 0<=d[1]+y<n:\\n                    dest=(d[0]+x,d[1]+y)                    \\n                    if dest==box_coord and 0<=d[0]+box_x<m and 0<=d[1]+box_y<n:\\n                        box_dest=(d[0]+box_x,d[1]+box_y)\\n                        state2=(steps+1,dest,box_dest)\\n                        st2=(dest,box_dest)\\n                        ##\\u63A8\\u7BB1\\u5B50\\uFF0Csteps+1\\uFF0C\\u7BB1\\u5B50\\u5750\\u6807\\u52A0\\u4E0A\\u4F4D\\u79FB\\u5411\\u91CFd\\n                        if st2 not in visited and grid[box_dest[0]][box_dest[1]]!=\\'#\\':\\n                            ##if steps==3 and box_dest==(2,3):\\n                                ##print(\"next\",dest,\"box_coord\",box_coord,\"coord\",coord,\"steps\",steps)\\n                            heapq.heappush(queue,state2)\\n                            continue\\n                    ##\\u4E0D\\u63A8\\u7BB1\\u5B50,\\u5982\\u679C\\u51B3\\u5B9A\\u4E0D\\u63A8\\u7BB1\\u5B50\\uFF0C\\u90A3\\u4E48\\u5C31\\u628A\\u7BB1\\u5B50\\u89C6\\u4E3A\\u4E00\\u7EC4\\u5899\\uFF0C\\u56E0\\u4E3A\\u4EBA\\u4E0D\\u80FD\\u7A7F\\u8FC7\\u7BB1\\u5B50,steps\\u4E0D\\u53D8\\n                    st2=(dest,box_coord)\\n                    if grid[dest[0]][dest[1]]!=\\'#\\' and dest!=box_coord:\\n                        ##if steps==3 and coord==(4,3) and dest==(3,3):\\n                            ##print(\"weird dir\",d)\\n                        state2=(steps,dest,box_coord)\\n                        if st2 not in visited:\\n                            heapq.heappush(queue,state2)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'S\\':\\n                    start=(i,j)\\n                elif grid[i][j]==\\'B\\':\\n                    box_start=(i,j)\\n                elif grid[i][j]==\\'T\\':\\n                    end=(i,j)\\n        state=(0,start,box_start)\\n        queue=[state]\\n        visited=set()\\n        dirs=[[0,1],[0,-1],[1,0],[-1,0]]\\n        ## [0,1]:go south\\n        ## [0,-1]:go north\\n        ## [1,0]: go east\\n        ## [-1,0]: go west\\n        while queue:\\n            \\n            st=heapq.heappop(queue)\\n            steps=st[0]\\n            coord=st[1]\\n            x,y=coord[0],coord[1]\\n            box_coord=st[2]\\n            box_x,box_y=box_coord[0],box_coord[1]\\n            ##\\u72B6\\u6001\\u662F\\u4EBA\\u548C\\u7BB1\\u5B50\\u7684\\u5750\\u6807\\u7EC4\\u6210\\u7684\\u5143\\u7EC4\\n            st1=(coord,box_coord)\\n            ##\\u5982\\u679C\\u72B6\\u6001\\n            if st1 in visited:\\n                continue\\n            visited.add(st1)\\n            if box_coord==end:\\n                return steps\\n            for d in dirs:\\n                if 0<=d[0]+x<m and 0<=d[1]+y<n:\\n                    dest=(d[0]+x,d[1]+y)                    \\n                    if dest==box_coord and 0<=d[0]+box_x<m and 0<=d[1]+box_y<n:\\n                        box_dest=(d[0]+box_x,d[1]+box_y)\\n                        state2=(steps+1,dest,box_dest)\\n                        st2=(dest,box_dest)\\n                        ##\\u63A8\\u7BB1\\u5B50\\uFF0Csteps+1\\uFF0C\\u7BB1\\u5B50\\u5750\\u6807\\u52A0\\u4E0A\\u4F4D\\u79FB\\u5411\\u91CFd\\n                        if st2 not in visited and grid[box_dest[0]][box_dest[1]]!=\\'#\\':\\n                            ##if steps==3 and box_dest==(2,3):\\n                                ##print(\"next\",dest,\"box_coord\",box_coord,\"coord\",coord,\"steps\",steps)\\n                            heapq.heappush(queue,state2)\\n                            continue\\n                    ##\\u4E0D\\u63A8\\u7BB1\\u5B50,\\u5982\\u679C\\u51B3\\u5B9A\\u4E0D\\u63A8\\u7BB1\\u5B50\\uFF0C\\u90A3\\u4E48\\u5C31\\u628A\\u7BB1\\u5B50\\u89C6\\u4E3A\\u4E00\\u7EC4\\u5899\\uFF0C\\u56E0\\u4E3A\\u4EBA\\u4E0D\\u80FD\\u7A7F\\u8FC7\\u7BB1\\u5B50,steps\\u4E0D\\u53D8\\n                    st2=(dest,box_coord)\\n                    if grid[dest[0]][dest[1]]!=\\'#\\' and dest!=box_coord:\\n                        ##if steps==3 and coord==(4,3) and dest==(3,3):\\n                            ##print(\"weird dir\",d)\\n                        state2=(steps,dest,box_coord)\\n                        if st2 not in visited:\\n                            heapq.heappush(queue,state2)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604246,
                "title": "c-4ms-easy-to-understand-bfs-bfs-solution",
                "content": "```\\nstruct Point {\\n    int8_t x;\\n    int8_t y;\\n\\n    Point() = default;\\n    Point(int8_t x, int8_t y) : x(x), y(y) { }\\n    inline bool operator==(const Point& other) const { return x == other.x && y == other.y; }\\n};\\n\\nstruct Objective {\\n    Point player;\\n    Point box;\\n\\n    Objective() = default;\\n    Objective(Point player, Point box) : player(player), box(box) { }\\n    Objective(int8_t playerX, int8_t playerY, int8_t boxX, int8_t boxY) :\\n        player{playerX, playerY}, box{boxX, boxY} { }\\n};\\n\\n\\nclass Solution {\\n    int8_t n, m;\\n    unordered_set<int> visited;\\n    vector<Point> reachablePoints;\\n    inline static constexpr int8_t dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    inline static int uniqueId(int16_t player, int16_t box)\\n    {\\n        return (player << 16) | box;\\n    }\\n\\n    void findPushableLocs(const vector<bool>& visitable, int8_t x, int8_t y, unordered_set<int16_t>& dest)\\n    {\\n        int16_t box = x * m + y;\\n        if (x - 1 >= 0 && x + 1 < n && visitable[box - m] && visitable[box + m]) {\\n            int16_t p = box - m;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n            p = box + m;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n        }\\n        if (y - 1 >= 0 && y + 1 < m && visitable[box - 1] && visitable[box + 1]) {\\n            int16_t p = box - 1;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n            p = box + 1;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n        }\\n    }\\n\\n    void completeObjective(const vector<bool>& visitable, Objective& obj)\\n    {\\n        unordered_set<int16_t> dest;\\n        findPushableLocs(visitable, obj.box.x, obj.box.y, dest);\\n\\n        if (auto it = dest.find(obj.player.x * m + obj.player.y); it != dest.end()) {\\n            reachablePoints.emplace_back(obj.player);\\n            dest.erase(it);\\n        }\\n        if (dest.empty())\\n            return;\\n\\n        queue<Point> moveQ;\\n        moveQ.emplace(obj.player);\\n        vector<bool> playerNotVisited(visitable);\\n        playerNotVisited[m * obj.player.x + obj.player.y] = false;\\n        playerNotVisited[m * obj.box.x + obj.box.y] = false;\\n\\n        while (!moveQ.empty()) {\\n            for (int s = moveQ.size(); s; --s) {\\n                auto p = moveQ.front();\\n                moveQ.pop();\\n                for (auto& dir : dirs) {\\n                    Point newP(p.x + dir[0], p.y + dir[1]);\\n                    int16_t loc = newP.x * m + newP.y;\\n                    if (newP.x >= 0 && newP.x < n && newP.y >= 0 && newP.y < m && playerNotVisited[loc]) {\\n                        playerNotVisited[loc] = false;\\n                        moveQ.emplace(newP);\\n                        if (auto it = dest.find(loc); it != dest.end()) {\\n                            reachablePoints.emplace_back(newP);\\n                            dest.erase(it);\\n                            if (dest.empty())\\n                                return;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minPushBox(vector<vector<char>>& grid)\\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<bool> visitable(n * m, true);\\n        Point player{-1, -1}, finish{-1, -1}, box{-1, -1};\\n        for (int8_t i = 0; i < n; ++i) {\\n            for (int8_t j = 0; j < m; ++j) {\\n                if (grid[i][j] == \\'S\\')\\n                    player = {i, j};\\n                else if (grid[i][j] == \\'B\\')\\n                    box = {i, j};\\n                else if (grid[i][j] == \\'T\\')\\n                    finish = {i, j};\\n                else if (grid[i][j] == \\'#\\')\\n                    visitable[i * m + j] = false;\\n            }\\n        }\\n        queue<Objective> q;\\n        q.emplace(player, box);\\n        reachablePoints.reserve(4);\\n\\n        int ans = 1;\\n        while (!q.empty()) {\\n            for (int s = q.size(); s; --s) {\\n                Objective obj = q.front();\\n                q.pop();\\n                completeObjective(visitable, obj);\\n                for (auto p : reachablePoints) {\\n                    Point newBox{(int8_t)((obj.box.x << 1) - p.x), (int8_t)((obj.box.y << 1) - p.y)};\\n                    if (newBox == finish)\\n                        return ans;\\n                    visited.insert(uniqueId(p.x * m + p.y, obj.box.x * m + obj.box.y));\\n                    q.emplace(p, newBox);\\n                }\\n                reachablePoints.clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Point {\\n    int8_t x;\\n    int8_t y;\\n\\n    Point() = default;\\n    Point(int8_t x, int8_t y) : x(x), y(y) { }\\n    inline bool operator==(const Point& other) const { return x == other.x && y == other.y; }\\n};\\n\\nstruct Objective {\\n    Point player;\\n    Point box;\\n\\n    Objective() = default;\\n    Objective(Point player, Point box) : player(player), box(box) { }\\n    Objective(int8_t playerX, int8_t playerY, int8_t boxX, int8_t boxY) :\\n        player{playerX, playerY}, box{boxX, boxY} { }\\n};\\n\\n\\nclass Solution {\\n    int8_t n, m;\\n    unordered_set<int> visited;\\n    vector<Point> reachablePoints;\\n    inline static constexpr int8_t dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    inline static int uniqueId(int16_t player, int16_t box)\\n    {\\n        return (player << 16) | box;\\n    }\\n\\n    void findPushableLocs(const vector<bool>& visitable, int8_t x, int8_t y, unordered_set<int16_t>& dest)\\n    {\\n        int16_t box = x * m + y;\\n        if (x - 1 >= 0 && x + 1 < n && visitable[box - m] && visitable[box + m]) {\\n            int16_t p = box - m;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n            p = box + m;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n        }\\n        if (y - 1 >= 0 && y + 1 < m && visitable[box - 1] && visitable[box + 1]) {\\n            int16_t p = box - 1;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n            p = box + 1;\\n            if (visited.find(uniqueId(p, box)) == visited.end())\\n                dest.insert(p);\\n        }\\n    }\\n\\n    void completeObjective(const vector<bool>& visitable, Objective& obj)\\n    {\\n        unordered_set<int16_t> dest;\\n        findPushableLocs(visitable, obj.box.x, obj.box.y, dest);\\n\\n        if (auto it = dest.find(obj.player.x * m + obj.player.y); it != dest.end()) {\\n            reachablePoints.emplace_back(obj.player);\\n            dest.erase(it);\\n        }\\n        if (dest.empty())\\n            return;\\n\\n        queue<Point> moveQ;\\n        moveQ.emplace(obj.player);\\n        vector<bool> playerNotVisited(visitable);\\n        playerNotVisited[m * obj.player.x + obj.player.y] = false;\\n        playerNotVisited[m * obj.box.x + obj.box.y] = false;\\n\\n        while (!moveQ.empty()) {\\n            for (int s = moveQ.size(); s; --s) {\\n                auto p = moveQ.front();\\n                moveQ.pop();\\n                for (auto& dir : dirs) {\\n                    Point newP(p.x + dir[0], p.y + dir[1]);\\n                    int16_t loc = newP.x * m + newP.y;\\n                    if (newP.x >= 0 && newP.x < n && newP.y >= 0 && newP.y < m && playerNotVisited[loc]) {\\n                        playerNotVisited[loc] = false;\\n                        moveQ.emplace(newP);\\n                        if (auto it = dest.find(loc); it != dest.end()) {\\n                            reachablePoints.emplace_back(newP);\\n                            dest.erase(it);\\n                            if (dest.empty())\\n                                return;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minPushBox(vector<vector<char>>& grid)\\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<bool> visitable(n * m, true);\\n        Point player{-1, -1}, finish{-1, -1}, box{-1, -1};\\n        for (int8_t i = 0; i < n; ++i) {\\n            for (int8_t j = 0; j < m; ++j) {\\n                if (grid[i][j] == \\'S\\')\\n                    player = {i, j};\\n                else if (grid[i][j] == \\'B\\')\\n                    box = {i, j};\\n                else if (grid[i][j] == \\'T\\')\\n                    finish = {i, j};\\n                else if (grid[i][j] == \\'#\\')\\n                    visitable[i * m + j] = false;\\n            }\\n        }\\n        queue<Objective> q;\\n        q.emplace(player, box);\\n        reachablePoints.reserve(4);\\n\\n        int ans = 1;\\n        while (!q.empty()) {\\n            for (int s = q.size(); s; --s) {\\n                Objective obj = q.front();\\n                q.pop();\\n                completeObjective(visitable, obj);\\n                for (auto p : reachablePoints) {\\n                    Point newBox{(int8_t)((obj.box.x << 1) - p.x), (int8_t)((obj.box.y << 1) - p.y)};\\n                    if (newBox == finish)\\n                        return ans;\\n                    visited.insert(uniqueId(p.x * m + p.y, obj.box.x * m + obj.box.y));\\n                    q.emplace(p, newBox);\\n                }\\n                reachablePoints.clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599205,
                "title": "java-a-star-w-comments",
                "content": "This isn\\'t the most optimized solution (runtime 28 ms beats 51%), but I think it\\'s well commented and easy to follow. \\n\\n```\\n/**\\n  Finds Initial State (State consists of shopkeeper & box locations + # of boxMoves)\\n  Uses BFS/A* Algorithm to visit valid transition states \\n  Note: The min heuristic here is # of boxMoves + manHattanDistance between box & target locations\\n*/\\nclass Solution {\\n    private int targetRow;\\n    private int targetCol;\\n    private char[][] grid;\\n    private static int[][] DIRS = {\\n            {1,0}, //Down\\n            {-1,0},//Up\\n            {0,1}, //Right\\n            {0,-1} //Left\\n    };\\n    \\n    /**\\n      State holds shopkeeper and box location, as well as how many times the box has been pushed\\n    */\\n    class State implements Comparable<State>{\\n        int personRow;\\n        int personCol;\\n        int boxRow; \\n        int boxCol;\\n        int boxPushes;\\n        \\n        public State(int personRow, int personCol, int boxRow, int boxCol, int boxPushes){                \\n            this.personRow = personRow;\\n            this.personCol = personCol;            \\n            this.boxRow = boxRow;            \\n            this.boxCol = boxCol;\\n            this.boxPushes = boxPushes;\\n        }\\n        \\n        // Override equals - used along with hashcode when we have visited HashSet\\n        public boolean equals(Object o){\\n            State other = (State) o;\\n            return \\n            this.personRow == other.personRow &&\\n            this.personCol == other.personCol &&\\n            this.boxRow == other.boxRow &&\\n            this.boxCol == other.boxCol;\\n        }\\n        \\n        // Override the hashCode - Note: it\\'s okay for this to have collisions\\n        // But it won\\'t due to the problem constraint that there is a bound on NxM dimensions\\n        public int hashCode(){\\n            return personRow *10_000 + personCol * 1_000 + boxRow * 100 + boxCol;\\n        }\\n        \\n        // Override to string method - helpful in debugging state.\\n        public String toString(){\\n            return \"ShopKeeper:{row:\"+personRow+\", col:\"+personCol+\"}\" +\\n                   \"Box:{row:\"+boxRow+\", col:\"+boxCol+\"}\";            \\n        }\\n        \\n        // Implement comparable interface such that we return the state that\\n        // has the possibility of lowest distance using box push count + Manhattan distance\\n        public int compareTo(State other){\\n            int minDistanceThis = this.boxPushes + distanceToTarget(this);\\n            int minDistanceOther = other.boxPushes + distanceToTarget(other);            \\n            return Integer.compare(minDistanceThis, minDistanceOther);\\n        }\\n        \\n    }\\n    \\n    // Calculates Manhattan distance\\n    private int distanceToTarget(State state){\\n        int yDiff = Math.abs(state.boxCol - targetCol);\\n        int xDiff = Math.abs(state.boxRow - targetRow);\\n        return yDiff + xDiff;\\n    }\\n    \\n    /**\\n       Given a state, compare box location to target location to determine if it is\\n       a solution state.\\n    */\\n    private boolean isSolutionState(State state){\\n        return state.boxRow == targetRow && state.boxCol == targetCol;\\n    }\\n    \\n    /**\\n        Given a state, finds all valid transition states.\\n        This is accomplished by moving the ShopKeeper in all 4 directions and validate\\n        - Next ShopKeeper location is in bounds and is not a wall\\n        \\n        We have additional logic for when the next shopkeeper location is the box location:\\n        - Get next box location, by pushing the same direction, again validate that\\n          the next box location is in bounds, and is not a wall.\\n                    \\n        If it\\'s a valid transition, create the new state with the new shop keeper location\\n        and if the box moved, the new box location (also increment the number of box moves).\\n        \\n    **/\\n    private List<State> getNeighbors(State state){\\n        \\n        int personRow = state.personRow;\\n        int personCol = state.personCol;\\n        int boxRow = state.boxRow;\\n        int boxCol = state.boxCol;\\n        \\n        List<State> states = new ArrayList<>();\\n        for(int[] dir : DIRS){\\n            int rowMove = dir[0];\\n            int colMove = dir[1];\\n            int personRowNew = personRow + rowMove;\\n            int personColNew = personCol + colMove;\\n            // Shopkeeper cannot move into wall or go out of bounds skip to next direction\\n            if(!inBounds(personRowNew, personColNew) ||\\n               isWall(personRowNew, personColNew)){\\n                continue;\\n            }\\n            // Whether or not person will collide with box\\n            boolean willPushBox = personRowNew == boxRow && personColNew == boxCol;\\n            \\n            if(willPushBox){\\n                int boxRowNew = boxRow + rowMove;\\n                int boxColNew = boxCol + colMove;\\n                // Validate box can be pushed - if so push box and add to neighbor states\\n                if(inBounds(boxRowNew, boxColNew) && \\n                   !isWall(boxRowNew, boxColNew)){\\n                   states.add(new State(personRowNew, personColNew, boxRowNew, boxColNew, state.boxPushes + 1));\\n                }                \\n            } else {\\n                //Shop keeper moved, but not box\\n                states.add(new State(personRowNew, personColNew, boxRow, boxCol, state.boxPushes));\\n            }\\n        }\\n        return states;\\n        \\n    }\\n    \\n    // Given row/col, return whether it is wall\\n    private boolean isWall(int row, int col){\\n        char cell = grid[row][col];\\n        return cell == \\'#\\';\\n    }\\n    \\n    // Given row/col return whether is inBounds\\n    private boolean inBounds(int row, int col){\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if(row < 0 || col < 0 || row > rows-1 || col > cols-1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    /**\\n      Returns initial state. Also finds and stores the target location.\\n    */\\n    private State getInitialState(){\\n        \\n        int shopKeeperRow=0;\\n        int shopKeeperCol=0;\\n\\n        int boxRow = 0;\\n        int boxCol = 0;\\n        \\n        for(int r=0; r<grid.length; r++){\\n            char[] row = grid[r];\\n            for(int c=0; c<row.length; c++){\\n                char cell = grid[r][c];\\n                if(cell == \\'T\\'){\\n                    this.targetRow = r;\\n                    this.targetCol = c;\\n                }\\n                else if(cell == \\'B\\'){\\n                    boxRow = r;\\n                    boxCol = c;\\n                } else if(cell == \\'S\\'){\\n                    shopKeeperRow = r;\\n                    shopKeeperCol = c;\\n                }\\n            }                            \\n        }\\n        \\n        return new State(shopKeeperRow, shopKeeperCol, boxRow, boxCol, 0);\\n    }\\n    \\n    public int minPushBox(char[][] grid) {\\n        this.grid = grid;\\n        \\n        State initialState = getInitialState();\\n        Queue<State> queue = new PriorityQueue<>();\\n        Set<State> visited = new HashSet<>();\\n        queue.offer(initialState);\\n  \\n        // Explore every state using BSF and keep track of the best solution\\n        while(!queue.isEmpty()){\\n            State state = queue.poll();\\n            if(visited.contains(state)){\\n                continue;\\n            }            \\n            visited.add(state);\\n            /*\\n              Note: the reason we can return the first solution state we find, is because we are \\n              using priority queue with minDistance heuristic which means the first solution we find\\n              is guaranteed to be the optimal solution - (A* Algorithm)\\n            */\\n            if(isSolutionState(state)){\\n                return state.boxPushes;\\n            }\\n            for(State neighbor : getNeighbors(state)){                \\n                if(!visited.contains(neighbor)){\\n                    queue.offer(neighbor);    \\n                }                \\n            };            \\n        }\\n        // No solution - return -1\\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n  Finds Initial State (State consists of shopkeeper & box locations + # of boxMoves)\\n  Uses BFS/A* Algorithm to visit valid transition states \\n  Note: The min heuristic here is # of boxMoves + manHattanDistance between box & target locations\\n*/\\nclass Solution {\\n    private int targetRow;\\n    private int targetCol;\\n    private char[][] grid;\\n    private static int[][] DIRS = {\\n            {1,0}, //Down\\n            {-1,0},//Up\\n            {0,1}, //Right\\n            {0,-1} //Left\\n    };\\n    \\n    /**\\n      State holds shopkeeper and box location, as well as how many times the box has been pushed\\n    */\\n    class State implements Comparable<State>{\\n        int personRow;\\n        int personCol;\\n        int boxRow; \\n        int boxCol;\\n        int boxPushes;\\n        \\n        public State(int personRow, int personCol, int boxRow, int boxCol, int boxPushes){                \\n            this.personRow = personRow;\\n            this.personCol = personCol;            \\n            this.boxRow = boxRow;            \\n            this.boxCol = boxCol;\\n            this.boxPushes = boxPushes;\\n        }\\n        \\n        // Override equals - used along with hashcode when we have visited HashSet\\n        public boolean equals(Object o){\\n            State other = (State) o;\\n            return \\n            this.personRow == other.personRow &&\\n            this.personCol == other.personCol &&\\n            this.boxRow == other.boxRow &&\\n            this.boxCol == other.boxCol;\\n        }\\n        \\n        // Override the hashCode - Note: it\\'s okay for this to have collisions\\n        // But it won\\'t due to the problem constraint that there is a bound on NxM dimensions\\n        public int hashCode(){\\n            return personRow *10_000 + personCol * 1_000 + boxRow * 100 + boxCol;\\n        }\\n        \\n        // Override to string method - helpful in debugging state.\\n        public String toString(){\\n            return \"ShopKeeper:{row:\"+personRow+\", col:\"+personCol+\"}\" +\\n                   \"Box:{row:\"+boxRow+\", col:\"+boxCol+\"}\";            \\n        }\\n        \\n        // Implement comparable interface such that we return the state that\\n        // has the possibility of lowest distance using box push count + Manhattan distance\\n        public int compareTo(State other){\\n            int minDistanceThis = this.boxPushes + distanceToTarget(this);\\n            int minDistanceOther = other.boxPushes + distanceToTarget(other);            \\n            return Integer.compare(minDistanceThis, minDistanceOther);\\n        }\\n        \\n    }\\n    \\n    // Calculates Manhattan distance\\n    private int distanceToTarget(State state){\\n        int yDiff = Math.abs(state.boxCol - targetCol);\\n        int xDiff = Math.abs(state.boxRow - targetRow);\\n        return yDiff + xDiff;\\n    }\\n    \\n    /**\\n       Given a state, compare box location to target location to determine if it is\\n       a solution state.\\n    */\\n    private boolean isSolutionState(State state){\\n        return state.boxRow == targetRow && state.boxCol == targetCol;\\n    }\\n    \\n    /**\\n        Given a state, finds all valid transition states.\\n        This is accomplished by moving the ShopKeeper in all 4 directions and validate\\n        - Next ShopKeeper location is in bounds and is not a wall\\n        \\n        We have additional logic for when the next shopkeeper location is the box location:\\n        - Get next box location, by pushing the same direction, again validate that\\n          the next box location is in bounds, and is not a wall.\\n                    \\n        If it\\'s a valid transition, create the new state with the new shop keeper location\\n        and if the box moved, the new box location (also increment the number of box moves).\\n        \\n    **/\\n    private List<State> getNeighbors(State state){\\n        \\n        int personRow = state.personRow;\\n        int personCol = state.personCol;\\n        int boxRow = state.boxRow;\\n        int boxCol = state.boxCol;\\n        \\n        List<State> states = new ArrayList<>();\\n        for(int[] dir : DIRS){\\n            int rowMove = dir[0];\\n            int colMove = dir[1];\\n            int personRowNew = personRow + rowMove;\\n            int personColNew = personCol + colMove;\\n            // Shopkeeper cannot move into wall or go out of bounds skip to next direction\\n            if(!inBounds(personRowNew, personColNew) ||\\n               isWall(personRowNew, personColNew)){\\n                continue;\\n            }\\n            // Whether or not person will collide with box\\n            boolean willPushBox = personRowNew == boxRow && personColNew == boxCol;\\n            \\n            if(willPushBox){\\n                int boxRowNew = boxRow + rowMove;\\n                int boxColNew = boxCol + colMove;\\n                // Validate box can be pushed - if so push box and add to neighbor states\\n                if(inBounds(boxRowNew, boxColNew) && \\n                   !isWall(boxRowNew, boxColNew)){\\n                   states.add(new State(personRowNew, personColNew, boxRowNew, boxColNew, state.boxPushes + 1));\\n                }                \\n            } else {\\n                //Shop keeper moved, but not box\\n                states.add(new State(personRowNew, personColNew, boxRow, boxCol, state.boxPushes));\\n            }\\n        }\\n        return states;\\n        \\n    }\\n    \\n    // Given row/col, return whether it is wall\\n    private boolean isWall(int row, int col){\\n        char cell = grid[row][col];\\n        return cell == \\'#\\';\\n    }\\n    \\n    // Given row/col return whether is inBounds\\n    private boolean inBounds(int row, int col){\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if(row < 0 || col < 0 || row > rows-1 || col > cols-1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    /**\\n      Returns initial state. Also finds and stores the target location.\\n    */\\n    private State getInitialState(){\\n        \\n        int shopKeeperRow=0;\\n        int shopKeeperCol=0;\\n\\n        int boxRow = 0;\\n        int boxCol = 0;\\n        \\n        for(int r=0; r<grid.length; r++){\\n            char[] row = grid[r];\\n            for(int c=0; c<row.length; c++){\\n                char cell = grid[r][c];\\n                if(cell == \\'T\\'){\\n                    this.targetRow = r;\\n                    this.targetCol = c;\\n                }\\n                else if(cell == \\'B\\'){\\n                    boxRow = r;\\n                    boxCol = c;\\n                } else if(cell == \\'S\\'){\\n                    shopKeeperRow = r;\\n                    shopKeeperCol = c;\\n                }\\n            }                            \\n        }\\n        \\n        return new State(shopKeeperRow, shopKeeperCol, boxRow, boxCol, 0);\\n    }\\n    \\n    public int minPushBox(char[][] grid) {\\n        this.grid = grid;\\n        \\n        State initialState = getInitialState();\\n        Queue<State> queue = new PriorityQueue<>();\\n        Set<State> visited = new HashSet<>();\\n        queue.offer(initialState);\\n  \\n        // Explore every state using BSF and keep track of the best solution\\n        while(!queue.isEmpty()){\\n            State state = queue.poll();\\n            if(visited.contains(state)){\\n                continue;\\n            }            \\n            visited.add(state);\\n            /*\\n              Note: the reason we can return the first solution state we find, is because we are \\n              using priority queue with minDistance heuristic which means the first solution we find\\n              is guaranteed to be the optimal solution - (A* Algorithm)\\n            */\\n            if(isSolutionState(state)){\\n                return state.boxPushes;\\n            }\\n            for(State neighbor : getNeighbors(state)){                \\n                if(!visited.contains(neighbor)){\\n                    queue.offer(neighbor);    \\n                }                \\n            };            \\n        }\\n        // No solution - return -1\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597575,
                "title": "c-minimum-moves-to-move-box-bfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\n    vector<pair<int, int>> dir;\\n    struct Hash {\\n        size_t operator()(const vector<int> &v) const {\\n            return v[0] * 20 + v[1] + v[2] * 20 + v[3];\\n        }\\n    };\\n    unordered_set<vector<int>, Hash> visited;\\n    struct Hash2 {\\n        size_t operator()(const vector<int> &v) const {\\n            return v[0] * 20 + v[1];\\n        }\\n    };\\n    \\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dir = vector<pair<int, int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // find target, box, person\\n        vector<int> target, box, person;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    person = vector<int>{i, j};\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = vector<int>{i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = vector<int>{i, j};\\n                }\\n            }\\n        }\\n        // BFS\\n        queue<vector<int>> q;\\n        q.push(vector<int>{box[0], box[1], person[0], person[1]});\\n        visited.insert(vector<int>{box[0], box[1], person[0], person[1]});\\n        int res = 0;\\n        while (!q.empty()) {\\n            int N = q.size();\\n            while (N--) {\\n                vector<int> cur = q.front();\\n                q.pop();\\n                if (cur[0] == target[0] && cur[1] == target[1])\\n                    return res;\\n                for (auto &d : dir) {\\n                    int b_row_nex = cur[0] + d.first;\\n                    int b_col_nex = cur[1] + d.second;\\n                    int p_row_nex = cur[0] - d.first;\\n                    int p_col_nex = cur[1] - d.second;\\n                    // judge position valid\\n                    if (valid(grid, b_row_nex, b_col_nex) && valid(grid, p_row_nex, p_col_nex)) {\\n                        // judge person reach and visited\\n                        if (canReach(grid, cur, p_row_nex, p_col_nex) &&\\n                            visited.find(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]}) == visited.end()) {\\n                            q.push(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]});\\n                            visited.insert(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]});\\n                        }\\n                    }\\n                }\\n            }\\n            res += 1;\\n        }\\n        return -1;\\n    }\\n    \\n    bool canReach(vector<vector<char>> &grid, vector<int> &start, int &p_row, int &p_col) {\\n        // judge whether person could reach (p_row, p_col)\\n        queue<vector<int>> q;\\n        unordered_set<vector<int>, Hash2> visited2;\\n        q.push(vector<int>{start[2], start[3]});\\n        visited2.insert(vector<int>{start[2], start[3]});\\n        while (!q.empty()) {\\n            vector<int> cur = q.front();\\n            q.pop();\\n            if (cur[0] == p_row && cur[1] == p_col)\\n                return true;\\n            for (auto &d : dir) {\\n                int row_nex = cur[0] + d.first;\\n                int col_nex = cur[1] + d.second;\\n                if (valid(grid, row_nex, col_nex) && !(row_nex == start[0] && col_nex == start[1]) &&\\n                    visited2.find(vector<int>{row_nex, col_nex}) == visited2.end()) {\\n                    q.push(vector<int>{row_nex, col_nex});\\n                    visited2.insert(vector<int>{row_nex, col_nex});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool valid(vector<vector<char>> &grid, int row, int col) {\\n        return row >= 0 && row < m && col >= 0 && col < n && grid[row][col] != \\'#\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\n    vector<pair<int, int>> dir;\\n    struct Hash {\\n        size_t operator()(const vector<int> &v) const {\\n            return v[0] * 20 + v[1] + v[2] * 20 + v[3];\\n        }\\n    };\\n    unordered_set<vector<int>, Hash> visited;\\n    struct Hash2 {\\n        size_t operator()(const vector<int> &v) const {\\n            return v[0] * 20 + v[1];\\n        }\\n    };\\n    \\npublic:\\n    int minPushBox(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dir = vector<pair<int, int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // find target, box, person\\n        vector<int> target, box, person;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'S\\') {\\n                    person = vector<int>{i, j};\\n                } else if (grid[i][j] == \\'B\\') {\\n                    box = vector<int>{i, j};\\n                } else if (grid[i][j] == \\'T\\') {\\n                    target = vector<int>{i, j};\\n                }\\n            }\\n        }\\n        // BFS\\n        queue<vector<int>> q;\\n        q.push(vector<int>{box[0], box[1], person[0], person[1]});\\n        visited.insert(vector<int>{box[0], box[1], person[0], person[1]});\\n        int res = 0;\\n        while (!q.empty()) {\\n            int N = q.size();\\n            while (N--) {\\n                vector<int> cur = q.front();\\n                q.pop();\\n                if (cur[0] == target[0] && cur[1] == target[1])\\n                    return res;\\n                for (auto &d : dir) {\\n                    int b_row_nex = cur[0] + d.first;\\n                    int b_col_nex = cur[1] + d.second;\\n                    int p_row_nex = cur[0] - d.first;\\n                    int p_col_nex = cur[1] - d.second;\\n                    // judge position valid\\n                    if (valid(grid, b_row_nex, b_col_nex) && valid(grid, p_row_nex, p_col_nex)) {\\n                        // judge person reach and visited\\n                        if (canReach(grid, cur, p_row_nex, p_col_nex) &&\\n                            visited.find(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]}) == visited.end()) {\\n                            q.push(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]});\\n                            visited.insert(vector<int>{b_row_nex, b_col_nex, cur[0], cur[1]});\\n                        }\\n                    }\\n                }\\n            }\\n            res += 1;\\n        }\\n        return -1;\\n    }\\n    \\n    bool canReach(vector<vector<char>> &grid, vector<int> &start, int &p_row, int &p_col) {\\n        // judge whether person could reach (p_row, p_col)\\n        queue<vector<int>> q;\\n        unordered_set<vector<int>, Hash2> visited2;\\n        q.push(vector<int>{start[2], start[3]});\\n        visited2.insert(vector<int>{start[2], start[3]});\\n        while (!q.empty()) {\\n            vector<int> cur = q.front();\\n            q.pop();\\n            if (cur[0] == p_row && cur[1] == p_col)\\n                return true;\\n            for (auto &d : dir) {\\n                int row_nex = cur[0] + d.first;\\n                int col_nex = cur[1] + d.second;\\n                if (valid(grid, row_nex, col_nex) && !(row_nex == start[0] && col_nex == start[1]) &&\\n                    visited2.find(vector<int>{row_nex, col_nex}) == visited2.end()) {\\n                    q.push(vector<int>{row_nex, col_nex});\\n                    visited2.insert(vector<int>{row_nex, col_nex});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool valid(vector<vector<char>> &grid, int row, int col) {\\n        return row >= 0 && row < m && col >= 0 && col < n && grid[row][col] != \\'#\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587875,
                "title": "anyone-can-help-to-explain-the-output",
                "content": "For the bellow input, I thought the result should be 5, but the answer is 7. Anyone can help to explain why?\\nInput:\\n```\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n```\\n![image](https://assets.leetcode.com/users/images/513536fe-b72d-402e-801b-4e5fa5f57524_1637401319.2810934.png)\\n\\n![image](https://assets.leetcode.com/users/images/a607e0f3-a183-4f22-8f91-bdf55148dd06_1637401476.5700872.png)\\n",
                "solutionTags": [],
                "code": "```\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568014,
                "title": "c-simple-bfs-solution",
                "content": "```\\n\\t\\tpublic int Solution(char[][] grid)\\n        {\\n\\n            // find start position\\n            // bfs move\\n\\n            int step = 1;\\n\\n            int m = grid.Length, n = grid[0].Length;\\n\\n            Location start = new Location();\\n\\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (grid[i][j] == \\'S\\')\\n                    {\\n                        start.Y = i;\\n                        start.X = j;\\n                    }\\n                    else if (grid[i][j] == \\'B\\')\\n                    {\\n                        start.BlockY = i;\\n                        start.BlockX = j;\\n                    }\\n                }\\n            }\\n\\n            Stack<Location> stack = new Stack<Location>();\\n\\n            stack.Push(start);\\n\\n            ISet<Location> visited = new HashSet<Location>();\\n\\n            var success = Bfs(stack, new Stack<Location>(), () =>\\n            {\\n                step++;\\n            }, (next, old, curr) =>\\n            {\\n                return Move(curr.Y - 1, curr.X, Direction.Top)\\n                || Move(curr.Y + 1, curr.X, Direction.Bottom)\\n                || Move(curr.Y, curr.X - 1, Direction.Left)\\n                || Move(curr.Y, curr.X + 1, Direction.Right);\\n\\n                bool Move(int y, int x, Direction direction)\\n                {\\n                    if (y == -1 || y == m || x == -1 || x == n || grid[y][x] == \\'#\\') return false;\\n\\n                    int blockY = curr.BlockY, blockX = curr.BlockX;\\n\\n                    bool drive = y == curr.BlockY && x == curr.BlockX;\\n\\n                    if (drive)\\n                    {\\n                        switch (direction)\\n                        {\\n                            case Direction.Top:\\n                                if (y == 0 || grid[y - 1][x] == \\'#\\') return false;\\n                                blockY = y - 1;\\n                                break;\\n                            case Direction.Bottom:\\n                                if (y == m - 1 || grid[y + 1][x] == \\'#\\') return false;\\n                                blockY = y + 1;\\n                                break;\\n                            case Direction.Left:\\n                                if (x == 0 || grid[y][x - 1] == \\'#\\') return false;\\n                                blockX = x - 1;\\n                                break;\\n                            case Direction.Right:\\n                                if (x == n - 1 || grid[y][x + 1] == \\'#\\') return false;\\n                                blockX = x + 1;\\n                                break;\\n                        }\\n                    }\\n\\n                    if (grid[blockY][blockX] == \\'T\\') return true;\\n\\n                    var move = new Location()\\n                    {\\n                        Y = y,\\n                        X = x,\\n                        BlockX = blockX,\\n                        BlockY = blockY,\\n                    };\\n\\n                    if (visited.Add(move))\\n                    {\\n                        if (drive)\\n                            next.Push(move);\\n                        else\\n                            // We return only the number of times the box is pushed.\\n                            old.Push(move);\\n                    }\\n                    return false;\\n                }\\n\\n\\n            });\\n\\n            if (success) return step;\\n\\n            return -1;\\n\\n        }\\n\\t\\t\\n\\t\\tenum Direction\\n        {\\n            Top,\\n            Bottom,\\n            Left,\\n            Right,\\n        }\\n\\n        class Location\\n        {\\n            public int X { get; set; }\\n            public int Y { get; set; }\\n            public int BlockX { get; set; }\\n            public int BlockY { get; set; }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return obj is Location location &&\\n                       X == location.X &&\\n                       Y == location.Y &&\\n                       BlockX == location.BlockX &&\\n                       BlockY == location.BlockY;\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                return HashCode.Combine(X, Y, BlockX, BlockY);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"[{Y},{X}]=>[{BlockY},{BlockX}]\";\\n            }\\n        }\\n\\t\\t\\n\\t\\tpublic static bool Bfs<T>(Stack<T> curr, Stack<T> next, Action moveToNext, Func<Stack<T>, Stack<T>, T, bool> coreFunc)\\n        {\\n            while (curr.Count > 0)\\n            {\\n\\n                while (curr.Count > 0)\\n                    if (coreFunc(next, curr, curr.Pop())) return true;\\n\\n                var t = curr;\\n                curr = next;\\n                next = t;\\n                if (moveToNext != null)\\n                    moveToNext();\\n            }\\n            return false;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int Solution(char[][] grid)\\n        {\\n\\n            // find start position\\n            // bfs move\\n\\n            int step = 1;\\n\\n            int m = grid.Length, n = grid[0].Length;\\n\\n            Location start = new Location();\\n\\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (grid[i][j] == \\'S\\')\\n                    {\\n                        start.Y = i;\\n                        start.X = j;\\n                    }\\n                    else if (grid[i][j] == \\'B\\')\\n                    {\\n                        start.BlockY = i;\\n                        start.BlockX = j;\\n                    }\\n                }\\n            }\\n\\n            Stack<Location> stack = new Stack<Location>();\\n\\n            stack.Push(start);\\n\\n            ISet<Location> visited = new HashSet<Location>();\\n\\n            var success = Bfs(stack, new Stack<Location>(), () =>\\n            {\\n                step++;\\n            }, (next, old, curr) =>\\n            {\\n                return Move(curr.Y - 1, curr.X, Direction.Top)\\n                || Move(curr.Y + 1, curr.X, Direction.Bottom)\\n                || Move(curr.Y, curr.X - 1, Direction.Left)\\n                || Move(curr.Y, curr.X + 1, Direction.Right);\\n\\n                bool Move(int y, int x, Direction direction)\\n                {\\n                    if (y == -1 || y == m || x == -1 || x == n || grid[y][x] == \\'#\\') return false;\\n\\n                    int blockY = curr.BlockY, blockX = curr.BlockX;\\n\\n                    bool drive = y == curr.BlockY && x == curr.BlockX;\\n\\n                    if (drive)\\n                    {\\n                        switch (direction)\\n                        {\\n                            case Direction.Top:\\n                                if (y == 0 || grid[y - 1][x] == \\'#\\') return false;\\n                                blockY = y - 1;\\n                                break;\\n                            case Direction.Bottom:\\n                                if (y == m - 1 || grid[y + 1][x] == \\'#\\') return false;\\n                                blockY = y + 1;\\n                                break;\\n                            case Direction.Left:\\n                                if (x == 0 || grid[y][x - 1] == \\'#\\') return false;\\n                                blockX = x - 1;\\n                                break;\\n                            case Direction.Right:\\n                                if (x == n - 1 || grid[y][x + 1] == \\'#\\') return false;\\n                                blockX = x + 1;\\n                                break;\\n                        }\\n                    }\\n\\n                    if (grid[blockY][blockX] == \\'T\\') return true;\\n\\n                    var move = new Location()\\n                    {\\n                        Y = y,\\n                        X = x,\\n                        BlockX = blockX,\\n                        BlockY = blockY,\\n                    };\\n\\n                    if (visited.Add(move))\\n                    {\\n                        if (drive)\\n                            next.Push(move);\\n                        else\\n                            // We return only the number of times the box is pushed.\\n                            old.Push(move);\\n                    }\\n                    return false;\\n                }\\n\\n\\n            });\\n\\n            if (success) return step;\\n\\n            return -1;\\n\\n        }\\n\\t\\t\\n\\t\\tenum Direction\\n        {\\n            Top,\\n            Bottom,\\n            Left,\\n            Right,\\n        }\\n\\n        class Location\\n        {\\n            public int X { get; set; }\\n            public int Y { get; set; }\\n            public int BlockX { get; set; }\\n            public int BlockY { get; set; }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return obj is Location location &&\\n                       X == location.X &&\\n                       Y == location.Y &&\\n                       BlockX == location.BlockX &&\\n                       BlockY == location.BlockY;\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                return HashCode.Combine(X, Y, BlockX, BlockY);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"[{Y},{X}]=>[{BlockY},{BlockX}]\";\\n            }\\n        }\\n\\t\\t\\n\\t\\tpublic static bool Bfs<T>(Stack<T> curr, Stack<T> next, Action moveToNext, Func<Stack<T>, Stack<T>, T, bool> coreFunc)\\n        {\\n            while (curr.Count > 0)\\n            {\\n\\n                while (curr.Count > 0)\\n                    if (coreFunc(next, curr, curr.Pop())) return true;\\n\\n                var t = curr;\\n                curr = next;\\n                next = t;\\n                if (moveToNext != null)\\n                    moveToNext();\\n            }\\n            return false;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557449,
                "title": "c-bfs-striaght-forward-with-explanation",
                "content": "```\\npublic class Solution\\n{\\n        int rows;\\n        int cols;\\n        char[][] mat;\\n        Dictionary<((int, int), (int, int), (int, int)), bool> route;\\n\\n        public int MinPushBox(char[][] grid)\\n        {\\n            mat = grid;\\n            rows = grid.Length;\\n            cols = grid[0].Length;\\n\\t\\t\\t\\n\\t\\t\\t//Cache to store if a route exists from point A to point B. (source, dest, box location)\\n            route = new Dictionary<((int, int), (int, int), (int, int)), bool>();\\n\\n            (int, int) bp = (0, 0);   // box position\\n            (int, int) tp = (0, 0);   // target position\\n            (int, int) sp = (0, 0);   // player position\\n\\n           // Traverse Through the matrix and store the above positions\\n            for (int i = 0; i < rows; i++)\\n            {\\n                for (int j = 0; j < cols; j++)\\n                {\\n                    if (grid[i][j] == \\'B\\')\\n                    {\\n                        bp.Item1 = i;\\n                        bp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                    else if (grid[i][j] == \\'S\\')\\n                    {\\n                        sp.Item1 = i;\\n                        sp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                    else if (grid[i][j] == \\'T\\')\\n                    {\\n                        tp.Item1 = i;\\n                        tp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                }\\n            }\\n\\n            var q = new Queue<((int, int), (int, int), int)>();\\n\\n            q.Enqueue((bp, sp, 0));\\n            var v = new HashSet<(int, int, int, int)>();\\n            \\n\\t\\t\\t//Start BFS from the Box position.\\n            while (q.Count > 0)\\n            {\\n                    var cur = q.Dequeue();\\n                    var cbp = cur.Item1;     // current box position\\n                    var cpp = cur.Item2;     // current player position\\n                    var push = cur.Item3;   // number of pushes upto this position\\n\\n                    if (cbp == tp)               // if current box posotion == target then we are done\\n                        return push;\\n                    \\n                    push++;\\n                    //Console.WriteLine();\\n                    //Console.WriteLine($\"DeQueue {cbp.Item1}:{cbp.Item2}  {cpp.Item1}:{cpp.Item2} -> \");\\n                    for (int dir = 0; dir < 4; dir++)   // from one cell try to go all 4 ways\\n                    {\\n                        var nbp = cbp;  //nbp - next box position. set next position basing on direction\\n\\n                        switch (dir)\\n                        {\\n                            case 0:\\n                                nbp.Item2 = cbp.Item2 + 1; //right\\n                                break;\\n                            case 1:\\n                                nbp.Item1 = cbp.Item1 + 1; //down\\n                                break;\\n                            case 2:\\n                                nbp.Item2 = cbp.Item2 - 1; //left\\n                                break;\\n                            case 3:\\n                                nbp.Item1 = cbp.Item1 - 1; //up\\n                                break;\\n                        }\\n\\n                        if (v.Contains((cbp.Item1, cbp.Item2, nbp.Item1, nbp.Item2)))\\n                            continue;\\n                        \\n                        if (CellFree(nbp.Item1, nbp.Item2) && CanPush(cbp, cpp, dir))\\n                        {\\n                            //Console.WriteLine($\"  Can Push From {cbp.Item1}:{cbp.Item2} To {nbp.Item1}:{nbp.Item2}  player at {cpp.Item1}:{cpp.Item2} {dir}\");\\n                            q.Enqueue((nbp, cbp, push));  //cbp becomes nbp & cpp becomes cbp after a push.\\n                            v.Add((cbp.Item1, cbp.Item2, nbp.Item1, nbp.Item2));\\n                        }\\n                    }\\n            }\\n\\n            return -1;\\n        }\\n\\n        // Check if the Box can be pushed from point A to Point B.\\n        public bool CanPush((int, int) cbp, (int, int) cpp, int direction)\\n        {\\n            var dpi = cbp.Item1;  // destination player position i\\n            var dpj = cbp.Item2;  // destination player position j\\n\\n            int i = cpp.Item1;\\n            int j = cpp.Item2;\\n\\n            if (!CellFree(dpi, dpj) || !CellFree(i, j))\\n                return false;\\n     \\n\\t       // set the player location. where the player should be in order to push the box\\n\\t\\t   // basically one cell before the box.\\n            switch (direction)\\n            {\\n                case 0:\\n                    dpj = dpj - 1; // right\\n                    break;\\n                case 1:\\n                    dpi = dpi - 1; // down\\n                    break;\\n                case 2:\\n                    dpj = dpj + 1; // left\\n                    break;\\n                case 3:\\n                    dpi = dpi + 1; //up\\n                    break;\\n            }\\n\\t\\t\\t\\n           // [dpi, dpj] is where the player needs to be in order to push the box. \\n\\t\\t   // so see if the player has a clear path from cpp to [dpi, dpj].\\n\\n            if (cpp.Item1 == dpi && cpp.Item2 == dpj)\\n                return true;\\n\\n            if (!CellFree(dpi, dpj))\\n                return false;\\n            \\n            if(route.TryGetValue((cpp, (dpi, dpj), cbp), out bool exists))\\n                return exists;\\n            \\n\\t\\t\\t// If player  has path from A to B then he can take same path from B to A as well.\\n\\t\\t\\t// no need to traverse the graph to check if a path exists from B to A again. \\n            if(route.TryGetValue(((dpi, dpj), cpp, cbp), out exists))\\n                return exists;\\n\\n            exists = dfs(cpp, (dpi, dpj), cbp, new bool[rows, cols]);\\n            \\n            route.Add((cpp, (dpi, dpj), cbp), exists);\\n            return exists;\\n        }\\n\\n        // If the player is at a different lcoation, then do a dfs and check if \\n\\t\\t// player can reach to the target location so that he can push the box.\\n        public bool dfs((int, int) cpp, (int, int) dpp, (int, int) cbp, bool[,] v)\\n        {\\n            if (cpp == dpp)\\n                return true;\\n\\n            int i = cpp.Item1;\\n            int j = cpp.Item2;\\n\\n\\n            if (!CellFree(i, j) || v[i, j] || cpp == cbp)\\n                return false;\\n\\n            v[i, j] = true;\\n\\n            if (dfs((i + 1, j), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i, j + 1), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i - 1, j), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i, j - 1), dpp, cbp, v))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public bool CellFree(int i, int j)\\n        {\\n            if (i < 0 || i >= rows || j < 0 || j >= cols || mat[i][j] != \\'.\\')\\n                return false;\\n\\n            return true;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n        int rows;\\n        int cols;\\n        char[][] mat;\\n        Dictionary<((int, int), (int, int), (int, int)), bool> route;\\n\\n        public int MinPushBox(char[][] grid)\\n        {\\n            mat = grid;\\n            rows = grid.Length;\\n            cols = grid[0].Length;\\n\\t\\t\\t\\n\\t\\t\\t//Cache to store if a route exists from point A to point B. (source, dest, box location)\\n            route = new Dictionary<((int, int), (int, int), (int, int)), bool>();\\n\\n            (int, int) bp = (0, 0);   // box position\\n            (int, int) tp = (0, 0);   // target position\\n            (int, int) sp = (0, 0);   // player position\\n\\n           // Traverse Through the matrix and store the above positions\\n            for (int i = 0; i < rows; i++)\\n            {\\n                for (int j = 0; j < cols; j++)\\n                {\\n                    if (grid[i][j] == \\'B\\')\\n                    {\\n                        bp.Item1 = i;\\n                        bp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                    else if (grid[i][j] == \\'S\\')\\n                    {\\n                        sp.Item1 = i;\\n                        sp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                    else if (grid[i][j] == \\'T\\')\\n                    {\\n                        tp.Item1 = i;\\n                        tp.Item2 = j;\\n                        grid[i][j] = \\'.\\';\\n                    }\\n                }\\n            }\\n\\n            var q = new Queue<((int, int), (int, int), int)>();\\n\\n            q.Enqueue((bp, sp, 0));\\n            var v = new HashSet<(int, int, int, int)>();\\n            \\n\\t\\t\\t//Start BFS from the Box position.\\n            while (q.Count > 0)\\n            {\\n                    var cur = q.Dequeue();\\n                    var cbp = cur.Item1;     // current box position\\n                    var cpp = cur.Item2;     // current player position\\n                    var push = cur.Item3;   // number of pushes upto this position\\n\\n                    if (cbp == tp)               // if current box posotion == target then we are done\\n                        return push;\\n                    \\n                    push++;\\n                    //Console.WriteLine();\\n                    //Console.WriteLine($\"DeQueue {cbp.Item1}:{cbp.Item2}  {cpp.Item1}:{cpp.Item2} -> \");\\n                    for (int dir = 0; dir < 4; dir++)   // from one cell try to go all 4 ways\\n                    {\\n                        var nbp = cbp;  //nbp - next box position. set next position basing on direction\\n\\n                        switch (dir)\\n                        {\\n                            case 0:\\n                                nbp.Item2 = cbp.Item2 + 1; //right\\n                                break;\\n                            case 1:\\n                                nbp.Item1 = cbp.Item1 + 1; //down\\n                                break;\\n                            case 2:\\n                                nbp.Item2 = cbp.Item2 - 1; //left\\n                                break;\\n                            case 3:\\n                                nbp.Item1 = cbp.Item1 - 1; //up\\n                                break;\\n                        }\\n\\n                        if (v.Contains((cbp.Item1, cbp.Item2, nbp.Item1, nbp.Item2)))\\n                            continue;\\n                        \\n                        if (CellFree(nbp.Item1, nbp.Item2) && CanPush(cbp, cpp, dir))\\n                        {\\n                            //Console.WriteLine($\"  Can Push From {cbp.Item1}:{cbp.Item2} To {nbp.Item1}:{nbp.Item2}  player at {cpp.Item1}:{cpp.Item2} {dir}\");\\n                            q.Enqueue((nbp, cbp, push));  //cbp becomes nbp & cpp becomes cbp after a push.\\n                            v.Add((cbp.Item1, cbp.Item2, nbp.Item1, nbp.Item2));\\n                        }\\n                    }\\n            }\\n\\n            return -1;\\n        }\\n\\n        // Check if the Box can be pushed from point A to Point B.\\n        public bool CanPush((int, int) cbp, (int, int) cpp, int direction)\\n        {\\n            var dpi = cbp.Item1;  // destination player position i\\n            var dpj = cbp.Item2;  // destination player position j\\n\\n            int i = cpp.Item1;\\n            int j = cpp.Item2;\\n\\n            if (!CellFree(dpi, dpj) || !CellFree(i, j))\\n                return false;\\n     \\n\\t       // set the player location. where the player should be in order to push the box\\n\\t\\t   // basically one cell before the box.\\n            switch (direction)\\n            {\\n                case 0:\\n                    dpj = dpj - 1; // right\\n                    break;\\n                case 1:\\n                    dpi = dpi - 1; // down\\n                    break;\\n                case 2:\\n                    dpj = dpj + 1; // left\\n                    break;\\n                case 3:\\n                    dpi = dpi + 1; //up\\n                    break;\\n            }\\n\\t\\t\\t\\n           // [dpi, dpj] is where the player needs to be in order to push the box. \\n\\t\\t   // so see if the player has a clear path from cpp to [dpi, dpj].\\n\\n            if (cpp.Item1 == dpi && cpp.Item2 == dpj)\\n                return true;\\n\\n            if (!CellFree(dpi, dpj))\\n                return false;\\n            \\n            if(route.TryGetValue((cpp, (dpi, dpj), cbp), out bool exists))\\n                return exists;\\n            \\n\\t\\t\\t// If player  has path from A to B then he can take same path from B to A as well.\\n\\t\\t\\t// no need to traverse the graph to check if a path exists from B to A again. \\n            if(route.TryGetValue(((dpi, dpj), cpp, cbp), out exists))\\n                return exists;\\n\\n            exists = dfs(cpp, (dpi, dpj), cbp, new bool[rows, cols]);\\n            \\n            route.Add((cpp, (dpi, dpj), cbp), exists);\\n            return exists;\\n        }\\n\\n        // If the player is at a different lcoation, then do a dfs and check if \\n\\t\\t// player can reach to the target location so that he can push the box.\\n        public bool dfs((int, int) cpp, (int, int) dpp, (int, int) cbp, bool[,] v)\\n        {\\n            if (cpp == dpp)\\n                return true;\\n\\n            int i = cpp.Item1;\\n            int j = cpp.Item2;\\n\\n\\n            if (!CellFree(i, j) || v[i, j] || cpp == cbp)\\n                return false;\\n\\n            v[i, j] = true;\\n\\n            if (dfs((i + 1, j), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i, j + 1), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i - 1, j), dpp, cbp, v))\\n                return true;\\n\\n            if (dfs((i, j - 1), dpp, cbp, v))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public bool CellFree(int i, int j)\\n        {\\n            if (i < 0 || i >= rows || j < 0 || j >= cols || mat[i][j] != \\'.\\')\\n                return false;\\n\\n            return true;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552120,
                "title": "javascript-nested-bfs",
                "content": "Use a nested BFS Approach\\n```\\n//for ease of looping through directions\\nconst dirs = [\\n    [0,1],\\n    [0,-1],\\n    [1,0],\\n    [-1,0]\\n]\\n\\n// point is in bounds of the grid\\nconst vPt = (pt,grid)=> pt[0] >=0 && pt[1] >=0 && pt[0] < grid.length && pt[1]<grid[0].length\\n//two points are equal\\nconst ptsEqual = (p1,p2) => p1[0] === p2[0] && p1[1] === p2[1]\\n//intially find our box and player\\nconst findTokens = (grid)=>{\\n    const output = {\\n        box: null,\\n        player: null\\n    }\\n    for(let i = 0; i<grid.length ;i++){\\n        for(let j = 0; j<grid[0].length; j++){\\n            if(grid[i][j] === \\'B\\') output.box = [i,j]\\n            if(grid[i][j] === \\'S\\') output.player = [i,j]\\n            \\n        }\\n    }\\n    return output\\n}\\n//check if player can reach with BFS\\nconst pCR = (pC,dC,grid,box)=>{\\n    \\n    if(ptsEqual(pC,dC)) return true\\n    const tried = new Set()\\n    const queue = [pC]\\n    \\n    while(queue.length){\\n        const [i,j] = queue.shift()\\n        \\n        const key = `${i}-${j}`\\n        if(tried.has(key)) continue;\\n        else tried.add(key)\\n        \\n        \\n        \\n        for(const dir of dirs){\\n            let newI = i + dir[0]\\n            let newJ = j + dir[1]\\n            \\n            // note edge case where we can\\'t go through the box\\n        if(!vPt([newI,newJ],grid) || grid[newI][newJ] === \\'#\\' || ptsEqual([newI,newJ],box)) continue\\n            \\n            \\n            if(ptsEqual([newI,newJ],dC)) return true\\n            else {\\n                queue.push([newI,newJ])\\n            }\\n            \\n        }\\n    }\\n    return false\\n}\\n\\n//use a BFS approach to explore if we can push box in the right direction\\nvar minPushBox = function(grid) {\\n\\n    let minMoves = Infinity\\n    \\n    const { box, player } = findTokens(grid)\\n    \\n    //we\\'ll set the box and player to open spaces as we\\'ll be exploring using bfs and our \\'current\\' positions of\\n    // both tokens will be in our queue objects\\n    grid[box[0]][box[1]] = \\'.\\'\\n    grid[player[0]][player[1]] = \\'.\\'\\n    \\n    const queue = [{\\n        box,\\n        player,\\n        moves: 0\\n    }]\\n    const tried = new Set()\\n    while(queue.length){\\n        const { box, player, moves} = queue.shift()\\n        \\n        \\n        const key = `${box[0]}-${box[1]}--${player[0]}-${player[1]}`\\n            if(tried.has(key)) continue;\\n            else tried.add(key)\\n        \\n        \\n        for(const dir of dirs){\\n            const moveBoxTo = [box[0] + dir[0], box[1]+dir[1]]\\n            const playerSt = [box[0] - dir[0], box[1] - dir[1]]\\n            \\n            \\n            \\n            // check for valid pt\\n            if(!vPt(moveBoxTo,grid)|| !vPt(playerSt,grid)) {\\n                // console.log(`${moveBoxTo} or ${playerSt} is not valid`)\\n                continue;\\n                \\n            };\\n            \\n            const boxToVal = grid[moveBoxTo[0]][moveBoxTo[1]]\\n            const playerStVal = grid[playerSt[0]][playerSt[1]]\\n            \\n            // happy path\\n            if(boxToVal === \\'T\\' && pCR(player,playerSt,grid,box)){\\n                minMoves = Math.min(minMoves,moves+1)\\n                continue;\\n            }\\n            \\n            // if we can move the box, we\\'ll add to the queue for a move possibility\\n            if(boxToVal !== \\'#\\' && pCR(player,playerSt,grid,box)){\\n                queue.push({\\n                    box:moveBoxTo,\\n                    player: box,\\n                    moves: moves + 1\\n                })\\n            }\\n            \\n        }\\n    }\\n    \\n    \\n    \\n    return minMoves === Infinity ? -1 : minMoves\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//for ease of looping through directions\\nconst dirs = [\\n    [0,1],\\n    [0,-1],\\n    [1,0],\\n    [-1,0]\\n]\\n\\n// point is in bounds of the grid\\nconst vPt = (pt,grid)=> pt[0] >=0 && pt[1] >=0 && pt[0] < grid.length && pt[1]<grid[0].length\\n//two points are equal\\nconst ptsEqual = (p1,p2) => p1[0] === p2[0] && p1[1] === p2[1]\\n//intially find our box and player\\nconst findTokens = (grid)=>{\\n    const output = {\\n        box: null,\\n        player: null\\n    }\\n    for(let i = 0; i<grid.length ;i++){\\n        for(let j = 0; j<grid[0].length; j++){\\n            if(grid[i][j] === \\'B\\') output.box = [i,j]\\n            if(grid[i][j] === \\'S\\') output.player = [i,j]\\n            \\n        }\\n    }\\n    return output\\n}\\n//check if player can reach with BFS\\nconst pCR = (pC,dC,grid,box)=>{\\n    \\n    if(ptsEqual(pC,dC)) return true\\n    const tried = new Set()\\n    const queue = [pC]\\n    \\n    while(queue.length){\\n        const [i,j] = queue.shift()\\n        \\n        const key = `${i}-${j}`\\n        if(tried.has(key)) continue;\\n        else tried.add(key)\\n        \\n        \\n        \\n        for(const dir of dirs){\\n            let newI = i + dir[0]\\n            let newJ = j + dir[1]\\n            \\n            // note edge case where we can\\'t go through the box\\n        if(!vPt([newI,newJ],grid) || grid[newI][newJ] === \\'#\\' || ptsEqual([newI,newJ],box)) continue\\n            \\n            \\n            if(ptsEqual([newI,newJ],dC)) return true\\n            else {\\n                queue.push([newI,newJ])\\n            }\\n            \\n        }\\n    }\\n    return false\\n}\\n\\n//use a BFS approach to explore if we can push box in the right direction\\nvar minPushBox = function(grid) {\\n\\n    let minMoves = Infinity\\n    \\n    const { box, player } = findTokens(grid)\\n    \\n    //we\\'ll set the box and player to open spaces as we\\'ll be exploring using bfs and our \\'current\\' positions of\\n    // both tokens will be in our queue objects\\n    grid[box[0]][box[1]] = \\'.\\'\\n    grid[player[0]][player[1]] = \\'.\\'\\n    \\n    const queue = [{\\n        box,\\n        player,\\n        moves: 0\\n    }]\\n    const tried = new Set()\\n    while(queue.length){\\n        const { box, player, moves} = queue.shift()\\n        \\n        \\n        const key = `${box[0]}-${box[1]}--${player[0]}-${player[1]}`\\n            if(tried.has(key)) continue;\\n            else tried.add(key)\\n        \\n        \\n        for(const dir of dirs){\\n            const moveBoxTo = [box[0] + dir[0], box[1]+dir[1]]\\n            const playerSt = [box[0] - dir[0], box[1] - dir[1]]\\n            \\n            \\n            \\n            // check for valid pt\\n            if(!vPt(moveBoxTo,grid)|| !vPt(playerSt,grid)) {\\n                // console.log(`${moveBoxTo} or ${playerSt} is not valid`)\\n                continue;\\n                \\n            };\\n            \\n            const boxToVal = grid[moveBoxTo[0]][moveBoxTo[1]]\\n            const playerStVal = grid[playerSt[0]][playerSt[1]]\\n            \\n            // happy path\\n            if(boxToVal === \\'T\\' && pCR(player,playerSt,grid,box)){\\n                minMoves = Math.min(minMoves,moves+1)\\n                continue;\\n            }\\n            \\n            // if we can move the box, we\\'ll add to the queue for a move possibility\\n            if(boxToVal !== \\'#\\' && pCR(player,playerSt,grid,box)){\\n                queue.push({\\n                    box:moveBoxTo,\\n                    player: box,\\n                    moves: moves + 1\\n                })\\n            }\\n            \\n        }\\n    }\\n    \\n    \\n    \\n    return minMoves === Infinity ? -1 : minMoves\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519170,
                "title": "python-nested-bfs-solution",
                "content": "The idea is that we can push a box to a given location given that the player can travel to the opposite location. We\\'ll have 1 outer BFS with the number of pushes as the level and the current box and player coordinates as the state. When computing the next box position, we will use an inner BFS to compute whether the player at the current coordinates can travel to the opposite side to push it to the next destination. If we reach the target, we\\'re done, otherwise return -1.\\n\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        queue = deque()\\n        box, player, target = None, None, None\\n        \\n        for y in range(len(grid)):\\n            for x in range(len(grid[0])):\\n                if grid[y][x] == \\'T\\':\\n                    target = (y,x)\\n                if grid[y][x] == \\'B\\':\\n                    box = (y,x)\\n                if grid[y][x] == \\'S\\':\\n                    player = (y,x)\\n        \\n        queue.append((box[0],box[1],player[0],player[1], 0))\\n        grid[box[0]][box[1]] = \\'.\\'\\n        grid[player[0]][player[1]] = \\'.\\'\\n        grid[target[0]][target[1]] = \\'.\\'\\n                    \\n        visited = set()\\n        \\n        while queue:\\n            boxY,boxX,playerY,playerX,pushes = queue.popleft()\\n            \\n            if (boxY,boxX) == target:\\n                return pushes\\n            if (boxY,boxX,playerY,playerX) in visited:\\n                continue\\n                        \\n            visited.add((boxY,boxX,playerY,playerX))\\n            \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                nextY, nextX = boxY+dy, boxX+dx\\n                oppositeY, oppositeX = boxY-dy, boxX-dx\\n                if not self.checkGrid(nextY, nextX, grid, \\'.\\') or not self.checkGrid(nextY, nextX, grid, \\'.\\'):\\n                    continue\\n                if (nextY,nextX,boxY,boxX) in visited:\\n                    continue\\n                if not self.isReachable(playerY, playerX, boxY, boxX, oppositeY, oppositeX, grid):\\n                    continue\\n                \\n                queue.append((nextY, nextX, boxY, boxX, pushes + 1))\\n        \\n        return -1\\n        \\n    def checkGrid(self, y, x, grid, value):\\n        return (0 <= y < len(grid)) and (0 <= x < len(grid[0])) and grid[y][x] == value\\n    \\n    def isReachable(self, playerY, playerX, boxY, boxX, y, x, grid):\\n        queue = deque()\\n        queue.append((playerY,playerX))\\n        visited = set()\\n        \\n        while queue:\\n            currY, currX = queue.popleft()\\n            if not self.checkGrid(currY, currX, grid, \\'.\\'):\\n                continue\\n            if (currY, currX) == (boxY, boxX):\\n                continue\\n            if (currY, currX) == (y,x):\\n                return True\\n            if (currY, currX) in visited:\\n                continue\\n            \\n            visited.add((currY, currX))\\n            \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                queue.append((currY+dy, currX+dx))\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        queue = deque()\\n        box, player, target = None, None, None\\n        \\n        for y in range(len(grid)):\\n            for x in range(len(grid[0])):\\n                if grid[y][x] == \\'T\\':\\n                    target = (y,x)\\n                if grid[y][x] == \\'B\\':\\n                    box = (y,x)\\n                if grid[y][x] == \\'S\\':\\n                    player = (y,x)\\n        \\n        queue.append((box[0],box[1],player[0],player[1], 0))\\n        grid[box[0]][box[1]] = \\'.\\'\\n        grid[player[0]][player[1]] = \\'.\\'\\n        grid[target[0]][target[1]] = \\'.\\'\\n                    \\n        visited = set()\\n        \\n        while queue:\\n            boxY,boxX,playerY,playerX,pushes = queue.popleft()\\n            \\n            if (boxY,boxX) == target:\\n                return pushes\\n            if (boxY,boxX,playerY,playerX) in visited:\\n                continue\\n                        \\n            visited.add((boxY,boxX,playerY,playerX))\\n            \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                nextY, nextX = boxY+dy, boxX+dx\\n                oppositeY, oppositeX = boxY-dy, boxX-dx\\n                if not self.checkGrid(nextY, nextX, grid, \\'.\\') or not self.checkGrid(nextY, nextX, grid, \\'.\\'):\\n                    continue\\n                if (nextY,nextX,boxY,boxX) in visited:\\n                    continue\\n                if not self.isReachable(playerY, playerX, boxY, boxX, oppositeY, oppositeX, grid):\\n                    continue\\n                \\n                queue.append((nextY, nextX, boxY, boxX, pushes + 1))\\n        \\n        return -1\\n        \\n    def checkGrid(self, y, x, grid, value):\\n        return (0 <= y < len(grid)) and (0 <= x < len(grid[0])) and grid[y][x] == value\\n    \\n    def isReachable(self, playerY, playerX, boxY, boxX, y, x, grid):\\n        queue = deque()\\n        queue.append((playerY,playerX))\\n        visited = set()\\n        \\n        while queue:\\n            currY, currX = queue.popleft()\\n            if not self.checkGrid(currY, currX, grid, \\'.\\'):\\n                continue\\n            if (currY, currX) == (boxY, boxX):\\n                continue\\n            if (currY, currX) == (y,x):\\n                return True\\n            if (currY, currX) in visited:\\n                continue\\n            \\n            visited.add((currY, currX))\\n            \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                queue.append((currY+dy, currX+dx))\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497606,
                "title": "python-4d-state-bfs-to-dijkstra",
                "content": "From the problem statement, it\\'s very tempting to apply a simple queue-based BFS with a four dimensional state (x_box, y_box, x_person, y_person). Simply expand the solution out from the nearest neighbors until you get the box to the target point. The problem is that if you reach the box in the wrong orientation (i.e. you come at the box from the bottom but the optimal solution requires you to go around the box and come from the top), the BFS will expand the solution where you start pushing the box from the bottom and ultimately stops when you finish pushing the box into the end.\\n\\nTo get around this, one can simply realize that you want the \"queue\" or datastructure to set itself up so that the person is approaching the box from all orientations before committing to probing the solution from any given orientation. In that respect, we just need a priority queue which sorts the solutions based on the current cost. Then, we can walk around the box at 0 cost until we have the person able to push the box from any direction. Then we can explore all cost 1 paths, all cost 2 paths, etc. etc.\\n\\n```\\nimport numpy as np\\nimport heapq\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #bfs for parametrizing complex problems\\n        # (i,j,x,y), position of box, position of person\\n        #bfs on these, cost for a push is 1, everything else is 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        i=j=x=y=0\\n        #print(np.array(grid))\\n        for p in range(n):\\n            for q in range(m):\\n                if(grid[p][q] == \\'S\\'): #person\\n                    x,y = p,q\\n                if(grid[p][q] == \\'B\\'): #box\\n                    i,j = p,q\\n\\n        queue = []\\n        heapq.heappush(queue, (0,0, i,j,x,y))\\n        visited=set()\\n        ansr = float(\\'Inf\\')\\n        \\n        # can we track predecessors in this traversal?\\n        # what if we use a pq...that way we process all 0 cost\\n        # nodes first...i.e. we position ourselves around\\n        # the box first, then we proceed to psuh the box?\\n        \\n        while(queue):\\n            # box, person\\n            #i,j,x,y, curcost, pl, pred = queue.popleft()\\n\\t\\t\\t#pl is the path length, used only for diagnosing behavior, it\\'s otherwise not necessary\\n            curcost, pl, i,j,x,y= heapq.heappop(queue)\\n            #print(i,j,x,y,curcost)\\n\\n            if((i,j,x,y) in visited):\\n                continue\\n            visited.add((i,j,x,y))\\n            if(grid[i][j] == \\'T\\'):\\n                #print(i,j,x,y,curcost, pl, pred.prev.val)\\n                ansr = min(ansr, curcost)\\n                continue\\n            ## search for neighbors of i and j\\n            for dx, dy in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                xn = x+dx #increment person\\n                yn = y+dy\\n                i1, j1 = (i+dx), (j+dy)\\n                #print(xn, yn, )\\n                if(0<=xn<n and 0<=yn<m and grid[xn][yn]!= \\'#\\'):\\n                    if((xn,yn) ==(i,j) and 0<=i1<n and 0<=j1<m):\\n                        #box is in our direction\\n                        if(grid[i1][j1]!=\\'#\\'): # check if we can push\\n                            # queue.append((i1, j1, xn, yn, curcost+1, pl+1, Predecessor((i,j,x,y),pred)))\\n                            heapq.heappush(queue, (curcost+1, pl+1, i1, j1, xn, yn))\\n                        else: # direction is not possible to push at all\\n                            pass\\n                    elif((xn,yn)!=(i,j)): #person can move but the box does not move\\n                        #queue.append((i, j, xn, yn, curcost, pl+1, Predecessor((i,j,x,y),pred)))\\n                        heapq.heappush(queue, (curcost, pl+1, i, j, xn, yn))\\n                    \\n        return ansr if ansr!=float(\\'Inf\\') else -1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nimport heapq\\n\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #bfs for parametrizing complex problems\\n        # (i,j,x,y), position of box, position of person\\n        #bfs on these, cost for a push is 1, everything else is 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        i=j=x=y=0\\n        #print(np.array(grid))\\n        for p in range(n):\\n            for q in range(m):\\n                if(grid[p][q] == \\'S\\'): #person\\n                    x,y = p,q\\n                if(grid[p][q] == \\'B\\'): #box\\n                    i,j = p,q\\n\\n        queue = []\\n        heapq.heappush(queue, (0,0, i,j,x,y))\\n        visited=set()\\n        ansr = float(\\'Inf\\')\\n        \\n        # can we track predecessors in this traversal?\\n        # what if we use a pq...that way we process all 0 cost\\n        # nodes first...i.e. we position ourselves around\\n        # the box first, then we proceed to psuh the box?\\n        \\n        while(queue):\\n            # box, person\\n            #i,j,x,y, curcost, pl, pred = queue.popleft()\\n\\t\\t\\t#pl is the path length, used only for diagnosing behavior, it\\'s otherwise not necessary\\n            curcost, pl, i,j,x,y= heapq.heappop(queue)\\n            #print(i,j,x,y,curcost)\\n\\n            if((i,j,x,y) in visited):\\n                continue\\n            visited.add((i,j,x,y))\\n            if(grid[i][j] == \\'T\\'):\\n                #print(i,j,x,y,curcost, pl, pred.prev.val)\\n                ansr = min(ansr, curcost)\\n                continue\\n            ## search for neighbors of i and j\\n            for dx, dy in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                xn = x+dx #increment person\\n                yn = y+dy\\n                i1, j1 = (i+dx), (j+dy)\\n                #print(xn, yn, )\\n                if(0<=xn<n and 0<=yn<m and grid[xn][yn]!= \\'#\\'):\\n                    if((xn,yn) ==(i,j) and 0<=i1<n and 0<=j1<m):\\n                        #box is in our direction\\n                        if(grid[i1][j1]!=\\'#\\'): # check if we can push\\n                            # queue.append((i1, j1, xn, yn, curcost+1, pl+1, Predecessor((i,j,x,y),pred)))\\n                            heapq.heappush(queue, (curcost+1, pl+1, i1, j1, xn, yn))\\n                        else: # direction is not possible to push at all\\n                            pass\\n                    elif((xn,yn)!=(i,j)): #person can move but the box does not move\\n                        #queue.append((i, j, xn, yn, curcost, pl+1, Predecessor((i,j,x,y),pred)))\\n                        heapq.heappush(queue, (curcost, pl+1, i, j, xn, yn))\\n                    \\n        return ansr if ansr!=float(\\'Inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495386,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    private static final char WALL = \\'#\\';\\n    private static final char EMPTY = \\'.\\';\\n    private static final char TARGET = \\'T\\';\\n    private static final char KEEPER = \\'S\\';\\n    private static final char BOX = \\'B\\';\\n\\n    private static final int[][] dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n\\n    private char[][] field;\\n    private int m;\\n    private int n;\\n    private int bound;\\n\\n    private boolean canMove(int x, int y) {\\n        return x >= 0 && x < m && y >= 0 && y < n && field[x][y] != WALL;\\n    }\\n\\n    private void setField(int point, char value) {\\n        field[point / n][point % n] = value;\\n    }\\n\\n    private boolean canAccess(int oldKeeper, int newKeeper) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(oldKeeper);\\n\\n        boolean[] visited = new boolean[m * n];\\n        visited[oldKeeper] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int point = queue.poll();\\n\\n            if (point == newKeeper)\\n                return true;\\n\\n            for (int[] dir : dirs) {\\n                int x = point / n + dir[0];\\n                int y = point % n + dir[1];\\n\\n                if (!canMove(x, y))\\n                    continue;\\n\\n                int next = x * n + y;\\n\\n                if (!visited[next]) {\\n                    visited[next] = true;\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public int minPushBox(char[][] grid) {\\n        this.field = grid;\\n        this.m = field.length;\\n        this.n = field[0].length;\\n        this.bound = m * n;\\n\\n        int box = 0;\\n        int target = 0;\\n        int keeper = 0;\\n\\n        /*\\n            To simplify search space we keep only \\n            walls and empty spaces on the board\\n        */\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                char point = field[i][j];\\n\\n                switch(point) {\\n                    case TARGET:\\n                        target = i * n + j; // save target coordinate\\n                        setField(target, EMPTY); // erase the field\\n                        break;\\n                    case KEEPER:\\n                        keeper = i * n + j; // same for keeper\\n                        setField(keeper, EMPTY);\\n                        break;\\n                    case BOX:\\n                        box = i * n + j; // same for box\\n                        setField(box, EMPTY);\\n                        break;\\n                }\\n            }\\n        }\\n\\n        /*\\n            The trick here is to consider both\\n            box and keeper postions while searching\\n        */\\n        int[] startPoint = new int[] {box, keeper};\\n        int startHash = Arrays.hashCode(startPoint);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(startPoint);\\n\\n        /*\\n            Having 20 * 20 = 400 max board size\\n\\t\\t\\tArrays.hashCode() calculates the hash using next formula\\n\\t\\t\\t31 * box + keeper which equals to 12800 in our case\\n            so 2 ^ 14 = 16384 would be enouth to track visited points\\n        */\\n        boolean[] visited = new boolean[(int)Math.pow(2, 14)];\\n        visited[startHash] = true;\\n\\n        int result = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            while (0 < size--) {\\n                int[] oldPoint = queue.poll();\\n\\n                int oldBox = oldPoint[0];\\n                int oldKeeper = oldPoint[1];\\n\\n                if (oldBox == target)\\n                    return result;\\n\\n                for (int[] dir : dirs) {\\n                    // next box position\\n                    int bX = oldBox / n + dir[0];\\n                    int bY = oldBox % n + dir[1];\\n\\n                    /*\\n                        If we want to move the box one step to the left\\n                        [.][.][.]\\n                        [.][B][.] <- direction\\n                        [.][.][.]\\n\\n                        We have to check if the keepoer can reach the position\\n                        one step before currnt box position from left\\n                        [.][.][.]\\n                        [.][B][K] <- direction\\n                        [.][.][.]\\n\\n                        That\\'s why we have to substruct current direction\\n                        from current box position to get next keeper position\\n\\n                        Next box and keeper positions shell look like\\n                        [.][.][.]\\n                        [B][.][K]\\n                        [.][.][.]\\n\\n                        Next move will start from there\\n                    */\\n                    int kX = oldBox / n - dir[0];\\n                    int kY = oldBox % n - dir[1];\\n\\n                    if (!canMove(bX, bY) || !canMove(kX, kY))\\n                        continue;\\n\\n                    int newBox = bX * n + bY;\\n                    int newKeeper = kX * n + kY;\\n\\n                    int[] newPoint = new int[] {newBox, oldBox};\\n                    int newHash = Arrays.hashCode(newPoint);\\n\\n                    if (!visited[newHash]) {\\n\\n                        /*\\n                            While checking if keeper can reach next position\\n                            consider the box as the wall\\n                        */\\n                        setField(oldBox, WALL);\\n\\n                        /*\\n                            Check if the keeper can reach next position\\n                        */\\n                        if (canAccess(oldKeeper, newKeeper)) {\\n                            visited[newHash] = true;\\n                            queue.offer(newPoint);\\n                        }\\n\\n                        /*\\n                            Make box\\'s old position an empty again\\n                        */\\n                        setField(oldBox, EMPTY);\\n                    }\\n                }\\n            }\\n\\n            result++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final char WALL = \\'#\\';\\n    private static final char EMPTY = \\'.\\';\\n    private static final char TARGET = \\'T\\';\\n    private static final char KEEPER = \\'S\\';\\n    private static final char BOX = \\'B\\';\\n\\n    private static final int[][] dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n\\n    private char[][] field;\\n    private int m;\\n    private int n;\\n    private int bound;\\n\\n    private boolean canMove(int x, int y) {\\n        return x >= 0 && x < m && y >= 0 && y < n && field[x][y] != WALL;\\n    }\\n\\n    private void setField(int point, char value) {\\n        field[point / n][point % n] = value;\\n    }\\n\\n    private boolean canAccess(int oldKeeper, int newKeeper) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(oldKeeper);\\n\\n        boolean[] visited = new boolean[m * n];\\n        visited[oldKeeper] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int point = queue.poll();\\n\\n            if (point == newKeeper)\\n                return true;\\n\\n            for (int[] dir : dirs) {\\n                int x = point / n + dir[0];\\n                int y = point % n + dir[1];\\n\\n                if (!canMove(x, y))\\n                    continue;\\n\\n                int next = x * n + y;\\n\\n                if (!visited[next]) {\\n                    visited[next] = true;\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public int minPushBox(char[][] grid) {\\n        this.field = grid;\\n        this.m = field.length;\\n        this.n = field[0].length;\\n        this.bound = m * n;\\n\\n        int box = 0;\\n        int target = 0;\\n        int keeper = 0;\\n\\n        /*\\n            To simplify search space we keep only \\n            walls and empty spaces on the board\\n        */\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                char point = field[i][j];\\n\\n                switch(point) {\\n                    case TARGET:\\n                        target = i * n + j; // save target coordinate\\n                        setField(target, EMPTY); // erase the field\\n                        break;\\n                    case KEEPER:\\n                        keeper = i * n + j; // same for keeper\\n                        setField(keeper, EMPTY);\\n                        break;\\n                    case BOX:\\n                        box = i * n + j; // same for box\\n                        setField(box, EMPTY);\\n                        break;\\n                }\\n            }\\n        }\\n\\n        /*\\n            The trick here is to consider both\\n            box and keeper postions while searching\\n        */\\n        int[] startPoint = new int[] {box, keeper};\\n        int startHash = Arrays.hashCode(startPoint);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(startPoint);\\n\\n        /*\\n            Having 20 * 20 = 400 max board size\\n\\t\\t\\tArrays.hashCode() calculates the hash using next formula\\n\\t\\t\\t31 * box + keeper which equals to 12800 in our case\\n            so 2 ^ 14 = 16384 would be enouth to track visited points\\n        */\\n        boolean[] visited = new boolean[(int)Math.pow(2, 14)];\\n        visited[startHash] = true;\\n\\n        int result = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            while (0 < size--) {\\n                int[] oldPoint = queue.poll();\\n\\n                int oldBox = oldPoint[0];\\n                int oldKeeper = oldPoint[1];\\n\\n                if (oldBox == target)\\n                    return result;\\n\\n                for (int[] dir : dirs) {\\n                    // next box position\\n                    int bX = oldBox / n + dir[0];\\n                    int bY = oldBox % n + dir[1];\\n\\n                    /*\\n                        If we want to move the box one step to the left\\n                        [.][.][.]\\n                        [.][B][.] <- direction\\n                        [.][.][.]\\n\\n                        We have to check if the keepoer can reach the position\\n                        one step before currnt box position from left\\n                        [.][.][.]\\n                        [.][B][K] <- direction\\n                        [.][.][.]\\n\\n                        That\\'s why we have to substruct current direction\\n                        from current box position to get next keeper position\\n\\n                        Next box and keeper positions shell look like\\n                        [.][.][.]\\n                        [B][.][K]\\n                        [.][.][.]\\n\\n                        Next move will start from there\\n                    */\\n                    int kX = oldBox / n - dir[0];\\n                    int kY = oldBox % n - dir[1];\\n\\n                    if (!canMove(bX, bY) || !canMove(kX, kY))\\n                        continue;\\n\\n                    int newBox = bX * n + bY;\\n                    int newKeeper = kX * n + kY;\\n\\n                    int[] newPoint = new int[] {newBox, oldBox};\\n                    int newHash = Arrays.hashCode(newPoint);\\n\\n                    if (!visited[newHash]) {\\n\\n                        /*\\n                            While checking if keeper can reach next position\\n                            consider the box as the wall\\n                        */\\n                        setField(oldBox, WALL);\\n\\n                        /*\\n                            Check if the keeper can reach next position\\n                        */\\n                        if (canAccess(oldKeeper, newKeeper)) {\\n                            visited[newHash] = true;\\n                            queue.offer(newPoint);\\n                        }\\n\\n                        /*\\n                            Make box\\'s old position an empty again\\n                        */\\n                        setField(oldBox, EMPTY);\\n                    }\\n                }\\n            }\\n\\n            result++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492203,
                "title": "c-faster-than-92-73-less-than-96-36-memory-easy-to-understand",
                "content": "```\\npublic class Solution \\n{\\n    int[] X = new int[4]{0, 0, -1, +1};\\n    int[] Y = new int[4]{-1, +1, 0, 0};\\n    \\n    int[] XOpposite = new int[4]{0, 0, +1, -1};\\n    int[] YOpposite = new int[4]{+1, -1, 0, 0};\\n    \\n    public int MinPushBox(char[][] grid) \\n    {\\n        int COUNT = Int32.MaxValue;\\n        (int, int) start = (0, 0);\\n        (int, int) target = (0, 0);\\n        (int, int) box = (0, 0);\\n        \\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                if(grid[i][j] == \\'S\\')\\n                    start = (i, j);\\n                else if(grid[i][j] == \\'B\\')\\n                    box = (i, j);\\n                else if(grid[i][j] == \\'T\\')\\n                    target = (i, j);\\n            }\\n        }\\n\\n        HashSet<(int, int, int, int, int, int)> hashSet = new HashSet<(int, int, int, int, int, int)>();\\n        //bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        Queue<(int, int, int, int, int)> queue = new Queue<(int, int, int, int, int)>();\\n        queue.Enqueue((box.Item1, box.Item2, start.Item1, start.Item2, 0));\\n        while(queue.Count > 0)\\n        {\\n            var dq = queue.Dequeue();\\n            box = (dq.Item1, dq.Item2);\\n            start = (dq.Item3, dq.Item4);\\n            int count = dq.Item5;\\n            \\n            if(box.Item1 == target.Item1 && box.Item2 == target.Item2)\\n               COUNT = Math.Min(count, COUNT); \\n            \\n            for(int i = 0; i < 4; i++)\\n            {\\n                int x = box.Item1 + X[i];\\n                int y = box.Item2 + Y[i];\\n                \\n                int xOpposite = box.Item1 + XOpposite[i];\\n                int yOpposite = box.Item2 + YOpposite[i];\\n                \\n                if(x >= 0 && y >= 0 && x < grid.Length && y < grid[0].Length\\n                  && xOpposite >= 0 && yOpposite >= 0 && xOpposite < grid.Length && yOpposite < grid[0].Length\\n                  && !hashSet.Contains((x, y, xOpposite, yOpposite, box.Item1, box.Item2)) //visited[x, y] == false\\n                  && grid[x][y] != \\'#\\' && grid[xOpposite][yOpposite] != \\'#\\' ) // check where to visit\\n                {\\n                    if(CheckCanVisit(grid, start.Item1, start.Item2, \\n                                     new bool[grid.Length, grid[0].Length], xOpposite, yOpposite, box.Item1, box.Item2)) //check if human can be on opposite side\\n                    {\\n                        queue.Enqueue((x, y, xOpposite, yOpposite,  count + 1));\\n                        \\n                        hashSet.Add((x, y, xOpposite, yOpposite, box.Item1, box.Item2));\\n                    }\\n                   \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        if(COUNT < Int32.MaxValue)\\n            return COUNT;\\n        else\\n            return -1;\\n    }\\n\\n    private bool CheckCanVisit(char[][] grid, int x, int y, bool[,] visited, int targetX, int targetY, int blockX, int blockY)\\n    {\\n        if(x < 0 || y < 0 || x >= grid.Length || y >= grid[0].Length || visited[x, y] || grid[x][y] == \\'#\\' || (x == blockX && y == blockY))\\n            return false;\\n        else if(x == targetX && y == targetY)\\n            return true;\\n        \\n        visited[x, y] = true;\\n        bool found = false;\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int xx = x + X[i];\\n            int yy = y + Y[i];\\n            found = found || CheckCanVisit(grid, xx, yy, visited, targetX, targetY, blockX, blockY);\\n        }\\n        \\n        return found;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    int[] X = new int[4]{0, 0, -1, +1};\\n    int[] Y = new int[4]{-1, +1, 0, 0};\\n    \\n    int[] XOpposite = new int[4]{0, 0, +1, -1};\\n    int[] YOpposite = new int[4]{+1, -1, 0, 0};\\n    \\n    public int MinPushBox(char[][] grid) \\n    {\\n        int COUNT = Int32.MaxValue;\\n        (int, int) start = (0, 0);\\n        (int, int) target = (0, 0);\\n        (int, int) box = (0, 0);\\n        \\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                if(grid[i][j] == \\'S\\')\\n                    start = (i, j);\\n                else if(grid[i][j] == \\'B\\')\\n                    box = (i, j);\\n                else if(grid[i][j] == \\'T\\')\\n                    target = (i, j);\\n            }\\n        }\\n\\n        HashSet<(int, int, int, int, int, int)> hashSet = new HashSet<(int, int, int, int, int, int)>();\\n        //bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        Queue<(int, int, int, int, int)> queue = new Queue<(int, int, int, int, int)>();\\n        queue.Enqueue((box.Item1, box.Item2, start.Item1, start.Item2, 0));\\n        while(queue.Count > 0)\\n        {\\n            var dq = queue.Dequeue();\\n            box = (dq.Item1, dq.Item2);\\n            start = (dq.Item3, dq.Item4);\\n            int count = dq.Item5;\\n            \\n            if(box.Item1 == target.Item1 && box.Item2 == target.Item2)\\n               COUNT = Math.Min(count, COUNT); \\n            \\n            for(int i = 0; i < 4; i++)\\n            {\\n                int x = box.Item1 + X[i];\\n                int y = box.Item2 + Y[i];\\n                \\n                int xOpposite = box.Item1 + XOpposite[i];\\n                int yOpposite = box.Item2 + YOpposite[i];\\n                \\n                if(x >= 0 && y >= 0 && x < grid.Length && y < grid[0].Length\\n                  && xOpposite >= 0 && yOpposite >= 0 && xOpposite < grid.Length && yOpposite < grid[0].Length\\n                  && !hashSet.Contains((x, y, xOpposite, yOpposite, box.Item1, box.Item2)) //visited[x, y] == false\\n                  && grid[x][y] != \\'#\\' && grid[xOpposite][yOpposite] != \\'#\\' ) // check where to visit\\n                {\\n                    if(CheckCanVisit(grid, start.Item1, start.Item2, \\n                                     new bool[grid.Length, grid[0].Length], xOpposite, yOpposite, box.Item1, box.Item2)) //check if human can be on opposite side\\n                    {\\n                        queue.Enqueue((x, y, xOpposite, yOpposite,  count + 1));\\n                        \\n                        hashSet.Add((x, y, xOpposite, yOpposite, box.Item1, box.Item2));\\n                    }\\n                   \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        if(COUNT < Int32.MaxValue)\\n            return COUNT;\\n        else\\n            return -1;\\n    }\\n\\n    private bool CheckCanVisit(char[][] grid, int x, int y, bool[,] visited, int targetX, int targetY, int blockX, int blockY)\\n    {\\n        if(x < 0 || y < 0 || x >= grid.Length || y >= grid[0].Length || visited[x, y] || grid[x][y] == \\'#\\' || (x == blockX && y == blockY))\\n            return false;\\n        else if(x == targetX && y == targetY)\\n            return true;\\n        \\n        visited[x, y] = true;\\n        bool found = false;\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int xx = x + X[i];\\n            int yy = y + Y[i];\\n            found = found || CheckCanVisit(grid, xx, yy, visited, targetX, targetY, blockX, blockY);\\n        }\\n        \\n        return found;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487193,
                "title": "python-spfa-modified-bellman-ford",
                "content": "Inspired by https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431528/Python-Dijkstra-Short, here is a Shortest Path Faster Algorithm (modified form of Bellman-Ford, see https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\\n\\nIf we replace the queue with a heap (a hybrid Dijkstra/SPFA) we could get rid of the res and just return moves the first time we reach target.\\n\\nIn any case, I think Dijkstra is the better choice here, as SPFA adds some code complexity (and time complexity) for no gain.\\n\\n```py\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        rows, cols = len(grid), len(grid[0])\\n\\n        free = lambda r, c: 0 <= r < rows and 0 <= c < cols and grid[r][c] != \\'#\\'\\n        box, player, target = [x[1:] for x in sorted((grid[r][c], r, c) for r in range(rows) for c in range(cols) if grid[r][c] in {\\'S\\', \\'T\\', \\'B\\'})]\\n\\n        dist = defaultdict(lambda: float(\\'inf\\'))\\n        dist[(player, box)] = 0\\n        res = float(\\'inf\\')\\n\\n        q = {(player, box): None}\\n        while q:\\n            player, box = next(iter(q))\\n            q.pop((player, box))\\n\\n            if box == target:\\n                res = min(res, dist[(player, box)])\\n\\n            for r_offset, c_offset in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n\\n                new_player = player[0] + r_offset, player[1] + c_offset\\n                new_box = box[0] + r_offset, box[1] + c_offset\\n\\n                if new_player == box and free(*new_box) and dist[(new_player, new_box)] > dist[(player, box)] + 1:\\n                    dist[(new_player, new_box)] = dist[(player, box)] + 1\\n                    if (new_player, new_box) not in q:\\n                        q[(new_player, new_box)] = None\\n\\n                elif new_player != box and free(*new_player) and dist[(new_player, box)] > dist[(player, box)]:\\n                    dist[(new_player, box)] = dist[(player, box)]\\n                    if (new_player, box) not in q:\\n                        q[(new_player, box)] = None\\n        \\n        return res if res < float(\\'inf\\') else -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n\\n        rows, cols = len(grid), len(grid[0])\\n\\n        free = lambda r, c: 0 <= r < rows and 0 <= c < cols and grid[r][c] != \\'#\\'\\n        box, player, target = [x[1:] for x in sorted((grid[r][c], r, c) for r in range(rows) for c in range(cols) if grid[r][c] in {\\'S\\', \\'T\\', \\'B\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1459855,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #because we only need to care about the push, we can igore the path that storekeeper get to the box\\n        #try in 4 directions that the box can be pushed, check if the store keeper can get to the box in that direction\\n        #keep track of the postion of the storekeeper and box, we skip the position of the two that has been seen before\\n        #O(n^2) time and O(n^2) space \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"S\":\\n                    si, sj = i, j\\n                if grid[i][j] == \"B\":\\n                    bi, bj = i, j\\n                if grid[i][j] == \"T\":\\n                    ti, tj = i, j\\n        return self.getTarget(grid, si, sj, bi, bj, ti, tj)\\n    \\n    def getTarget(self, grid, si, sj, bi, bj, ti, tj):\\n        m = len(grid)\\n        n = len(grid[0])\\n        q = deque([(si, sj, bi, bj)])\\n        push = 0\\n        seen = set()\\n        while q:\\n            for _ in range(len(q)):\\n                si, sj, bi, bj  = q.pop()\\n                if bi == ti and bj == tj:\\n                    return push\\n                seen.add((si, sj, bi, bj))\\n                for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                    ni, nj = bi + x, bj + y\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] != \"#\" and self.canArrive(grid, bi - x, bj - y, bi, bj, si, sj):\\n                        if (bi, bj, ni, nj) not in seen:\\n                            q.appendleft((bi, bj, ni, nj))\\n                            seen.add((bi, bj, ni, nj))\\n            push += 1\\n            \\n        return -1\\n    \\n    def canArrive(self, grid, di, dj, bi, bj, si, sj):\\n        m = len(grid)\\n        n = len(grid[0])\\n        seen = set()\\n        q = deque([(si, sj)])\\n        while q:\\n            si, sj = q.pop()\\n            if si == di and sj == dj:\\n                return True\\n            for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = si + x, sj + y\\n                \\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] != \"#\" and not (ni == bi and nj == bj) and (ni, nj) not in seen:\\n                    q.appendleft((ni, nj))\\n                    seen.add((ni, nj))\\n                    \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        #because we only need to care about the push, we can igore the path that storekeeper get to the box\\n        #try in 4 directions that the box can be pushed, check if the store keeper can get to the box in that direction\\n        #keep track of the postion of the storekeeper and box, we skip the position of the two that has been seen before\\n        #O(n^2) time and O(n^2) space \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"S\":\\n                    si, sj = i, j\\n                if grid[i][j] == \"B\":\\n                    bi, bj = i, j\\n                if grid[i][j] == \"T\":\\n                    ti, tj = i, j\\n        return self.getTarget(grid, si, sj, bi, bj, ti, tj)\\n    \\n    def getTarget(self, grid, si, sj, bi, bj, ti, tj):\\n        m = len(grid)\\n        n = len(grid[0])\\n        q = deque([(si, sj, bi, bj)])\\n        push = 0\\n        seen = set()\\n        while q:\\n            for _ in range(len(q)):\\n                si, sj, bi, bj  = q.pop()\\n                if bi == ti and bj == tj:\\n                    return push\\n                seen.add((si, sj, bi, bj))\\n                for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                    ni, nj = bi + x, bj + y\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] != \"#\" and self.canArrive(grid, bi - x, bj - y, bi, bj, si, sj):\\n                        if (bi, bj, ni, nj) not in seen:\\n                            q.appendleft((bi, bj, ni, nj))\\n                            seen.add((bi, bj, ni, nj))\\n            push += 1\\n            \\n        return -1\\n    \\n    def canArrive(self, grid, di, dj, bi, bj, si, sj):\\n        m = len(grid)\\n        n = len(grid[0])\\n        seen = set()\\n        q = deque([(si, sj)])\\n        while q:\\n            si, sj = q.pop()\\n            if si == di and sj == dj:\\n                return True\\n            for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = si + x, sj + y\\n                \\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] != \"#\" and not (ni == bi and nj == bj) and (ni, nj) not in seen:\\n                    q.appendleft((ni, nj))\\n                    seen.add((ni, nj))\\n                    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450540,
                "title": "javascript-two-bfs-solution",
                "content": "The main idea is that:\\n1. for each box position, try to push it in 4 directions; in each direction, check whether its front and back position is empty;\\n2. if the back and front positions are available, we need to check whether people could reach to the back position to push the box;\\n```\\nconst dirs = [0, 1, 0, -1, 0];\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n    let people;\\n    let box;\\n    let target;\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            if (grid[i][j] === \\'S\\') {\\n                people = [i, j];\\n            } else if (grid[i][j] === \\'B\\') {\\n                box = [i, j];\\n            } else if (grid[i][j] === \\'T\\') {\\n                target = [i, j];\\n            }\\n        }\\n    }\\n    \\n    const visited = new Set();\\n    const queue = [[people[0], people[1], box[0], box[1]]];\\n    let queueIndex = 0;\\n    let steps = 0;\\n    while (queueIndex < queue.length) {\\n        const curQueueLen = queue.length;\\n        let reached = false;\\n        while (queueIndex < curQueueLen) {\\n            const [pX, pY, bX, bY] = queue[queueIndex++];\\n            if (bX === target[0] && bY === target[1]) {\\n                reached = true;\\n                break;\\n            }\\n            \\n            const curKey = `${pX}#${pY}#${bX}#${bY}`;\\n            if (visited.has(curKey)) continue;\\n            visited.add(curKey);\\n            \\n            for (let i = 0; i < 4; i++) {\\n                const pX1 = bX + dirs[i];\\n                const pY1 = bY + dirs[i+1];\\n                if (pX1 < 0 || pX1 >= rows || pY1 < 0 || pY1 >= cols || grid[pX1][pY1] === \\'#\\') {\\n                    continue;\\n                }\\n\\n                const bX1 = bX - dirs[i];\\n                const bY1 = bY - dirs[i+1];\\n                if (bX1 < 0 || bX1 >= rows || bY1 < 0 || bY1 >= cols || grid[bX1][bY1] === \\'#\\') {\\n                    continue;\\n                }\\n\\n                if (isReachable(grid, [pX1, pY1], [bX, bY], [pX, pY])) {\\n                    queue.push([bX, bY, bX1, bY1]);\\n                }\\n            }\\n        }\\n        \\n        if (reached) return steps;\\n        \\n        steps++;\\n    }\\n    \\n    return -1;\\n};\\n\\nconst isReachable = (grid, target, box, start) => {\\n    const t = grid[box[0]][box[1]];\\n    grid[box[0]][box[1]] = \\'#\\';\\n    const queue = [start];\\n    const visited = new Set();\\n    visited.add(`${start[0]}#${start[1]}`);\\n    \\n    let i = 0;\\n    while (i < queue.length) {\\n        const [curX, curY] = queue[i++];\\n        if (curX === target[0] && curY === target[1]) {\\n            grid[box[0]][box[1]] = t;\\n            return true;\\n        }\\n\\n        for (let j = 0; j < 4; j++) {\\n            const newX = curX + dirs[j];\\n            const newY = curY + dirs[j+1];\\n            const pointStr = `${newX}#${newY}`;\\n            if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length && grid[newX][newY] !== \\'#\\' && !visited.has(pointStr)) {\\n                queue.push([newX, newY]);\\n                visited.add(pointStr);\\n            }\\n        }\\n    }\\n    \\n    grid[box[0]][box[1]] = t;\\n    return false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The main idea is that:\\n1. for each box position, try to push it in 4 directions; in each direction, check whether its front and back position is empty;\\n2. if the back and front positions are available, we need to check whether people could reach to the back position to push the box;\\n```\\nconst dirs = [0, 1, 0, -1, 0];\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar minPushBox = function(grid) {\\n    let people;\\n    let box;\\n    let target;\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            if (grid[i][j] === \\'S\\') {\\n                people = [i, j];\\n            } else if (grid[i][j] === \\'B\\') {\\n                box = [i, j];\\n            } else if (grid[i][j] === \\'T\\') {\\n                target = [i, j];\\n            }\\n        }\\n    }\\n    \\n    const visited = new Set();\\n    const queue = [[people[0], people[1], box[0], box[1]]];\\n    let queueIndex = 0;\\n    let steps = 0;\\n    while (queueIndex < queue.length) {\\n        const curQueueLen = queue.length;\\n        let reached = false;\\n        while (queueIndex < curQueueLen) {\\n            const [pX, pY, bX, bY] = queue[queueIndex++];\\n            if (bX === target[0] && bY === target[1]) {\\n                reached = true;\\n                break;\\n            }\\n            \\n            const curKey = `${pX}#${pY}#${bX}#${bY}`;\\n            if (visited.has(curKey)) continue;\\n            visited.add(curKey);\\n            \\n            for (let i = 0; i < 4; i++) {\\n                const pX1 = bX + dirs[i];\\n                const pY1 = bY + dirs[i+1];\\n                if (pX1 < 0 || pX1 >= rows || pY1 < 0 || pY1 >= cols || grid[pX1][pY1] === \\'#\\') {\\n                    continue;\\n                }\\n\\n                const bX1 = bX - dirs[i];\\n                const bY1 = bY - dirs[i+1];\\n                if (bX1 < 0 || bX1 >= rows || bY1 < 0 || bY1 >= cols || grid[bX1][bY1] === \\'#\\') {\\n                    continue;\\n                }\\n\\n                if (isReachable(grid, [pX1, pY1], [bX, bY], [pX, pY])) {\\n                    queue.push([bX, bY, bX1, bY1]);\\n                }\\n            }\\n        }\\n        \\n        if (reached) return steps;\\n        \\n        steps++;\\n    }\\n    \\n    return -1;\\n};\\n\\nconst isReachable = (grid, target, box, start) => {\\n    const t = grid[box[0]][box[1]];\\n    grid[box[0]][box[1]] = \\'#\\';\\n    const queue = [start];\\n    const visited = new Set();\\n    visited.add(`${start[0]}#${start[1]}`);\\n    \\n    let i = 0;\\n    while (i < queue.length) {\\n        const [curX, curY] = queue[i++];\\n        if (curX === target[0] && curY === target[1]) {\\n            grid[box[0]][box[1]] = t;\\n            return true;\\n        }\\n\\n        for (let j = 0; j < 4; j++) {\\n            const newX = curX + dirs[j];\\n            const newY = curY + dirs[j+1];\\n            const pointStr = `${newX}#${newY}`;\\n            if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length && grid[newX][newY] !== \\'#\\' && !visited.has(pointStr)) {\\n                queue.push([newX, newY]);\\n                visited.add(pointStr);\\n            }\\n        }\\n    }\\n    \\n    grid[box[0]][box[1]] = t;\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1435819,
                "title": "2-solutions-with-explanation",
                "content": "\\n\\n### BFS\\nThe minimum push equals to the shortest path from box to target. In order to push the box, the player should be able to reach the corresponding positons, which can be verified using BFS. So we can iterate each possbile combination of positions of boxs and players, for each we check if player can reach that position, and increase *push* if possible. Return the push when the box reaches the target.\\nIn order to avoid repeated calculation, we use *visited* to store the status of each move by `(player, box)`.\\nThe common part between 2 solutions\\n```python\\nm, n = len(grid), len(grid[0])\\nplayer, box, target = [], [], []\\n        \\nfor i in range(m):\\n\\tfor j in range(n):\\n\\t\\tif grid[i][j] == \\'S\\':\\n\\t\\t\\tplayer = [i, j]\\n\\t\\telif grid[i][j] == \\'B\\':\\n\\t\\t\\tbox = [i, j]\\n\\t\\telif grid[i][j] == \\'T\\':\\n            target = [i, j]\\n#### above common part \\ndef reachable(i, j, a, b, x, y):\\n\\tvisited = {(i, j)}\\n    queue = deque([(i, j)])\\n\\twhile queue:\\n\\t\\ti, j = queue.popleft() \\n        if [i, j] == [a, b]:\\n\\t\\t\\treturn True\\n\\t\\tfor i, j in [(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]:\\n\\t\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] != \\'#\\' and (i, j) != (x, y) and (i, j) not in visited:\\n\\t\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\t\\tqueue.append((i, j))\\n\\treturn False\\n        \\nvisited = {(*player, *box)}\\nqueue = deque([(*player, *box, 0)])\\nwhile queue:\\n\\ti, j, x, y, p = queue.popleft()\\n\\tif [x, y] == target:\\n\\t\\treturn p\\n    boxs = [(x, y + 1), (x, y - 1), (x - 1, y), (x + 1, y)]\\n\\tplayers = [(x, y - 1), (x, y + 1), (x + 1, y), (x - 1, y)]\\n\\tfor [a, b], [c, d] in zip(players, boxs):\\n\\t\\tif 0 <= a < m and 0 <= c < m and 0 <= b < n and 0 <= d < n and grid[a][b] != \\'#\\' and grid[c][d] != \\'#\\' and (x, y, c, d) not in visited and reachable(i, j, a, b, x, y):\\n\\t\\t\\tvisited.add((x, y, c, d))\\n\\t\\t\\tqueue.append((x, y, c, d, p + 1))\\nreturn -1\\n```\\n\\n\\n### Heap + BFS (Dijkstra Alogrithm)\\nShortest path problem can be always resolved using heap + bfs, instead of checking if player is reachable to specific position, we just move player for 4 directions, and update the box as well when player can push the box. We check the status with minimum movement using heap, and return the push when box reaches to the target.\\n\\n```python\\n# common part is omitted\\ndirt = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\nvisited = {(*player, *box): 0}\\nheap = [(0, *player, *box)]\\nwhile heap:\\n\\tp, i, j, x, y = heapq.heappop(heap)\\n    if [x, y] == target:\\n\\t\\treturn p\\n    for d, [i, j] in enumerate([(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] != \\'#\\':\\n\\t\\t\\tif [i, j] == [x, y]: # player can push the box\\n\\t\\t\\t\\tnew_x, new_y = x + dirt[d][0], y + dirt[d][1]\\n                if 0 <= new_x < m and 0 <= new_y < n and grid[new_x][new_y] != \\'#\\' and ((i, j, new_x, new_y) not in visited or visited[i, j, new_x, new_y] > p + 1):\\n\\t\\t\\t\\t\\tvisited[i, j, new_x, new_y] = p + 1\\n                    heapq.heappush(heap, (p + 1, i, j, new_x, new_y))\\n\\t\\t\\telif (i, j, x,y) not in visited or visited[i, j, x, y] > p:\\n\\t\\t\\t\\tvisited[i, j, x, y] = p\\n                heapq.heappush(heap, (p, i, j, x, y))\\nreturn -1\\n```",
                "solutionTags": [],
                "code": "```python\\nm, n = len(grid), len(grid[0])\\nplayer, box, target = [], [], []\\n        \\nfor i in range(m):\\n\\tfor j in range(n):\\n\\t\\tif grid[i][j] == \\'S\\':\\n\\t\\t\\tplayer = [i, j]\\n\\t\\telif grid[i][j] == \\'B\\':\\n\\t\\t\\tbox = [i, j]\\n\\t\\telif grid[i][j] == \\'T\\':\\n            target = [i, j]\\n#### above common part \\ndef reachable(i, j, a, b, x, y):\\n\\tvisited = {(i, j)}\\n    queue = deque([(i, j)])\\n\\twhile queue:\\n\\t\\ti, j = queue.popleft() \\n        if [i, j] == [a, b]:\\n\\t\\t\\treturn True\\n\\t\\tfor i, j in [(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]:\\n\\t\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] != \\'#\\' and (i, j) != (x, y) and (i, j) not in visited:\\n\\t\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\t\\tqueue.append((i, j))\\n\\treturn False\\n        \\nvisited = {(*player, *box)}\\nqueue = deque([(*player, *box, 0)])\\nwhile queue:\\n\\ti, j, x, y, p = queue.popleft()\\n\\tif [x, y] == target:\\n\\t\\treturn p\\n    boxs = [(x, y + 1), (x, y - 1), (x - 1, y), (x + 1, y)]\\n\\tplayers = [(x, y - 1), (x, y + 1), (x + 1, y), (x - 1, y)]\\n\\tfor [a, b], [c, d] in zip(players, boxs):\\n\\t\\tif 0 <= a < m and 0 <= c < m and 0 <= b < n and 0 <= d < n and grid[a][b] != \\'#\\' and grid[c][d] != \\'#\\' and (x, y, c, d) not in visited and reachable(i, j, a, b, x, y):\\n\\t\\t\\tvisited.add((x, y, c, d))\\n\\t\\t\\tqueue.append((x, y, c, d, p + 1))\\nreturn -1\\n```\n```python\\n# common part is omitted\\ndirt = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\nvisited = {(*player, *box): 0}\\nheap = [(0, *player, *box)]\\nwhile heap:\\n\\tp, i, j, x, y = heapq.heappop(heap)\\n    if [x, y] == target:\\n\\t\\treturn p\\n    for d, [i, j] in enumerate([(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] != \\'#\\':\\n\\t\\t\\tif [i, j] == [x, y]: # player can push the box\\n\\t\\t\\t\\tnew_x, new_y = x + dirt[d][0], y + dirt[d][1]\\n                if 0 <= new_x < m and 0 <= new_y < n and grid[new_x][new_y] != \\'#\\' and ((i, j, new_x, new_y) not in visited or visited[i, j, new_x, new_y] > p + 1):\\n\\t\\t\\t\\t\\tvisited[i, j, new_x, new_y] = p + 1\\n                    heapq.heappush(heap, (p + 1, i, j, new_x, new_y))\\n\\t\\t\\telif (i, j, x,y) not in visited or visited[i, j, x, y] > p:\\n\\t\\t\\t\\tvisited[i, j, x, y] = p\\n                heapq.heappush(heap, (p, i, j, x, y))\\nreturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1389936,
                "title": "simple-python-bfs",
                "content": "\\n```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        self.dirs = [(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        \\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if grid[i][j] == \\'B\\':\\n                    box = (i,j)\\n                if grid[i][j] == \\'S\\':\\n                    person = (i,j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i,j)\\n                    \\n        def isvalid(x,y):\\n            return  0<= x < self.m and 0<= y < self.n and grid[x][y] != \\'#\\'\\n        \\n        def check(curr,dest,box):\\n            q =deque()\\n            q.append(curr)\\n            visited = set(curr)\\n            while q:\\n                curr = q.popleft()\\n                \\n                if curr == dest: \\n                    return True\\n                \\n                for dir_ in self.dirs:\\n                    r = curr[0] + dir_[0]\\n                    c = curr[1] + dir_[1]\\n                    \\n                    if isvalid(r,c) and (r,c) not in visited and (r,c) != box:\\n                        q.append((r,c))\\n                        visited.add((r,c))\\n            return False\\n        \\n        \\n        q = deque([(0,box,person)])\\n        \\n        visited = set((box,person))\\n        \\n        while q :\\n            dis , box, person = q.popleft()\\n            \\n            if box == target :\\n                return dis\\n            \\n            for dir_ in self.dirs:\\n                \\n                new_box_x = dir_[0] + box[0]\\n                new_box_y = dir_[1] + box[1]\\n                \\n\\t\\t\\t\\t#person is always behind box\\n                new_person_x = box[0] - dir_[0]\\n                new_person_y = box[1] - dir_[1]\\n                \\n                new_box = (new_box_x,new_box_y)\\n                new_person = (new_person_x,new_person_y) \\n                \\n                if isvalid(new_box_x,new_box_y) and isvalid(new_person_x,new_person_y) and check(person,new_person,box) and (new_box,new_person) not in visited:\\n                        visited.add((new_box,new_person))\\n                        q.append(( dis +1, new_box, new_person))\\n        return -1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPushBox(self, grid: List[List[str]]) -> int:\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        self.dirs = [(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        \\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if grid[i][j] == \\'B\\':\\n                    box = (i,j)\\n                if grid[i][j] == \\'S\\':\\n                    person = (i,j)\\n                if grid[i][j] == \\'T\\':\\n                    target = (i,j)\\n                    \\n        def isvalid(x,y):\\n            return  0<= x < self.m and 0<= y < self.n and grid[x][y] != \\'#\\'\\n        \\n        def check(curr,dest,box):\\n            q =deque()\\n            q.append(curr)\\n            visited = set(curr)\\n            while q:\\n                curr = q.popleft()\\n                \\n                if curr == dest: \\n                    return True\\n                \\n                for dir_ in self.dirs:\\n                    r = curr[0] + dir_[0]\\n                    c = curr[1] + dir_[1]\\n                    \\n                    if isvalid(r,c) and (r,c) not in visited and (r,c) != box:\\n                        q.append((r,c))\\n                        visited.add((r,c))\\n            return False\\n        \\n        \\n        q = deque([(0,box,person)])\\n        \\n        visited = set((box,person))\\n        \\n        while q :\\n            dis , box, person = q.popleft()\\n            \\n            if box == target :\\n                return dis\\n            \\n            for dir_ in self.dirs:\\n                \\n                new_box_x = dir_[0] + box[0]\\n                new_box_y = dir_[1] + box[1]\\n                \\n\\t\\t\\t\\t#person is always behind box\\n                new_person_x = box[0] - dir_[0]\\n                new_person_y = box[1] - dir_[1]\\n                \\n                new_box = (new_box_x,new_box_y)\\n                new_person = (new_person_x,new_person_y) \\n                \\n                if isvalid(new_box_x,new_box_y) and isvalid(new_person_x,new_person_y) and check(person,new_person,box) and (new_box,new_person) not in visited:\\n                        visited.add((new_box,new_person))\\n                        q.append(( dis +1, new_box, new_person))\\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374988,
                "title": "java-concise-bfs-with-comments",
                "content": "```\\nprivate static final int[][] DIRS = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n\\npublic int minPushBox(char[][] grid) {\\n\\tint R = grid.length, C = grid[0].length;\\n\\tint[] box = new int[2], player = new int[2];\\n\\tfor (int i = 0; i < R; i++) {\\n\\t\\tfor (int j = 0; j < C; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'B\\') {\\n\\t\\t\\t\\tbox[0] = i;\\n\\t\\t\\t\\tbox[1] = j;\\n\\t\\t\\t} else if (grid[i][j] == \\'S\\') {\\n\\t\\t\\t\\tplayer[0] = i;\\n\\t\\t\\t\\tplayer[1] = j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tQueue<Pair<int[], int[]>> queue = new LinkedList();\\n\\tqueue.add(new Pair(box, player));\\n\\tboolean[][] visited = new boolean[R * C][R * C];\\n\\t// in some cases, player needs to push the box further in order to change its direction; hence, tracking the box itself isn\\'t enough,\\n\\t// we need to track both box and player locations. for example,\\n\\t// . # T # .\\n\\t// . . . B S\\n\\t// . . . # .\\n\\t// `B` needs to land on location(1,2) twice\\n\\tvisited[box[0] * C + box[1]][player[0] * C + player[1]] = true;\\n\\tint step = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tstep++;\\n\\t\\tfor (int i = queue.size() - 1; i >= 0; i--) {\\n\\t\\t\\tPair<int[], int[]> state = queue.poll();\\n\\t\\t\\tint[] b = state.getKey(), p = state.getValue();\\n\\t\\t\\tfor (int j = 0; j < DIRS.length; j++) {\\n\\t\\t\\t\\tint[] nb = new int[]{b[0] + DIRS[j][0], b[1] + DIRS[j][1]};\\n\\t\\t\\t\\tif (nb[0] >= 0 && nb[0] < R && nb[1] >= 0 && nb[1] < C && grid[nb[0]][nb[1]] != \\'#\\') {\\n\\t\\t\\t\\t\\t// check where was it pushed from. basically, the opposite direction where the box moves to.\\n\\t\\t\\t\\t\\tint[] np = new int[]{b[0] - DIRS[j][0], b[1] - DIRS[j][1]};\\n\\t\\t\\t\\t\\tif (np[0] >= 0 && np[0] < R && np[1] >= 0 && np[1] < C\\n\\t\\t\\t\\t\\t\\t&& grid[np[0]][np[1]] != \\'#\\'\\n\\t\\t\\t\\t\\t\\t&& !visited[nb[0] * C + nb[1]][np[0] * C + np[1]]) {\\n\\t\\t\\t\\t\\t\\t// can the player reach to the box-pushing location\\n\\t\\t\\t\\t\\t\\tif (isReachable(grid, R, C, b, p, np)) {\\n\\t\\t\\t\\t\\t\\t\\tif (grid[nb[0]][nb[1]] == \\'T\\') {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tvisited[nb[0] * C + nb[1]][np[0] * C + np[1]] = true;\\n\\t\\t\\t\\t\\t\\t\\tqueue.add(new Pair(nb, b));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\nprivate boolean isReachable(char[][] grid, int R, int C, int[] box, int[] from, int[] to) {\\n\\tQueue<int[]> queue = new LinkedList();\\n\\tqueue.add(from);\\n\\tboolean[][] visited = new boolean[R][C];\\n\\tvisited[from[0]][from[1]] = true;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint[] loc = queue.poll();\\n\\t\\tif (loc[0] == to[0] && loc[1] == to[1]) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < DIRS.length; j++) {\\n\\t\\t\\tint nr = loc[0] + DIRS[j][0], nc = loc[1] + DIRS[j][1];\\n\\t\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc]\\n\\t\\t\\t\\t&& grid[nr][nc] != \\'#\\'\\n\\t\\t\\t\\t&& (nr != box[0] || nc != box[1])) {\\n\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n\\npublic int minPushBox(char[][] grid) {\\n\\tint R = grid.length, C = grid[0].length;\\n\\tint[] box = new int[2], player = new int[2];\\n\\tfor (int i = 0; i < R; i++) {\\n\\t\\tfor (int j = 0; j < C; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'B\\') {\\n\\t\\t\\t\\tbox[0] = i;\\n\\t\\t\\t\\tbox[1] = j;\\n\\t\\t\\t} else if (grid[i][j] == \\'S\\') {\\n\\t\\t\\t\\tplayer[0] = i;\\n\\t\\t\\t\\tplayer[1] = j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tQueue<Pair<int[], int[]>> queue = new LinkedList();\\n\\tqueue.add(new Pair(box, player));\\n\\tboolean[][] visited = new boolean[R * C][R * C];\\n\\t// in some cases, player needs to push the box further in order to change its direction; hence, tracking the box itself isn\\'t enough,\\n\\t// we need to track both box and player locations. for example,\\n\\t// . # T # .\\n\\t// . . . B S\\n\\t// . . . # .\\n\\t// `B` needs to land on location(1,2) twice\\n\\tvisited[box[0] * C + box[1]][player[0] * C + player[1]] = true;\\n\\tint step = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tstep++;\\n\\t\\tfor (int i = queue.size() - 1; i >= 0; i--) {\\n\\t\\t\\tPair<int[], int[]> state = queue.poll();\\n\\t\\t\\tint[] b = state.getKey(), p = state.getValue();\\n\\t\\t\\tfor (int j = 0; j < DIRS.length; j++) {\\n\\t\\t\\t\\tint[] nb = new int[]{b[0] + DIRS[j][0], b[1] + DIRS[j][1]};\\n\\t\\t\\t\\tif (nb[0] >= 0 && nb[0] < R && nb[1] >= 0 && nb[1] < C && grid[nb[0]][nb[1]] != \\'#\\') {\\n\\t\\t\\t\\t\\t// check where was it pushed from. basically, the opposite direction where the box moves to.\\n\\t\\t\\t\\t\\tint[] np = new int[]{b[0] - DIRS[j][0], b[1] - DIRS[j][1]};\\n\\t\\t\\t\\t\\tif (np[0] >= 0 && np[0] < R && np[1] >= 0 && np[1] < C\\n\\t\\t\\t\\t\\t\\t&& grid[np[0]][np[1]] != \\'#\\'\\n\\t\\t\\t\\t\\t\\t&& !visited[nb[0] * C + nb[1]][np[0] * C + np[1]]) {\\n\\t\\t\\t\\t\\t\\t// can the player reach to the box-pushing location\\n\\t\\t\\t\\t\\t\\tif (isReachable(grid, R, C, b, p, np)) {\\n\\t\\t\\t\\t\\t\\t\\tif (grid[nb[0]][nb[1]] == \\'T\\') {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tvisited[nb[0] * C + nb[1]][np[0] * C + np[1]] = true;\\n\\t\\t\\t\\t\\t\\t\\tqueue.add(new Pair(nb, b));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\nprivate boolean isReachable(char[][] grid, int R, int C, int[] box, int[] from, int[] to) {\\n\\tQueue<int[]> queue = new LinkedList();\\n\\tqueue.add(from);\\n\\tboolean[][] visited = new boolean[R][C];\\n\\tvisited[from[0]][from[1]] = true;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint[] loc = queue.poll();\\n\\t\\tif (loc[0] == to[0] && loc[1] == to[1]) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < DIRS.length; j++) {\\n\\t\\t\\tint nr = loc[0] + DIRS[j][0], nc = loc[1] + DIRS[j][1];\\n\\t\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc]\\n\\t\\t\\t\\t&& grid[nr][nc] != \\'#\\'\\n\\t\\t\\t\\t&& (nr != box[0] || nc != box[1])) {\\n\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569936,
                "content": [
                    {
                        "username": "V0idk",
                        "content": "Details \\nInput\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n,[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"]\\n,[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput\\n5\\nExpected\\n7"
                    },
                    {
                        "username": "realones",
                        "content": "Box also can block the player from moving"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/3138e594-ab1b-4484-834e-81467b308b0d_1673186302.3798378.png)"
                    },
                    {
                        "username": "jjliao",
                        "content": "I am quite new guy to the **LeetCode**. \\n\\nI mean no offence and I am just asking, can anyone tell me? \\n\\nIt\\'s so **hard**, I just want to skip this kind of problem if it will not be in the OA or Onsite."
                    },
                    {
                        "username": "realones",
                        "content": "I agree, but sadly we already practiced too much, and way more than what we need, and then you just realize this issue is not an issue now."
                    },
                    {
                        "username": "czjnbb",
                        "content": "So the key point is that if you want to bush a box to a neighbor grid, that grid and the grid on the opposite direction should be both '.', and also the grid on the opposite direction should be reachable by the player. \n\nA nested BFS would work perfectly."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The thing I'm \"stuck\" on is pushing the box alters the potential paths, so do I need to recaluculate the routes the person can take every time? Thats a full BFS per push and that seems pretty unreasonable, and even things like Dijkstra for efficiency seems like a lot. "
                    },
                    {
                        "username": "gagandeepahuja09",
                        "content": "https://youtu.be/2RDQVW7RspM"
                    },
                    {
                        "username": "CuteTN",
                        "content": "I have to admit that the stickman \"animation\" is cute \\uD83E\\uDEE0"
                    }
                ]
            },
            {
                "id": 1573195,
                "content": [
                    {
                        "username": "V0idk",
                        "content": "Details \\nInput\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n,[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"]\\n,[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput\\n5\\nExpected\\n7"
                    },
                    {
                        "username": "realones",
                        "content": "Box also can block the player from moving"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/3138e594-ab1b-4484-834e-81467b308b0d_1673186302.3798378.png)"
                    },
                    {
                        "username": "jjliao",
                        "content": "I am quite new guy to the **LeetCode**. \\n\\nI mean no offence and I am just asking, can anyone tell me? \\n\\nIt\\'s so **hard**, I just want to skip this kind of problem if it will not be in the OA or Onsite."
                    },
                    {
                        "username": "realones",
                        "content": "I agree, but sadly we already practiced too much, and way more than what we need, and then you just realize this issue is not an issue now."
                    },
                    {
                        "username": "czjnbb",
                        "content": "So the key point is that if you want to bush a box to a neighbor grid, that grid and the grid on the opposite direction should be both '.', and also the grid on the opposite direction should be reachable by the player. \n\nA nested BFS would work perfectly."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The thing I'm \"stuck\" on is pushing the box alters the potential paths, so do I need to recaluculate the routes the person can take every time? Thats a full BFS per push and that seems pretty unreasonable, and even things like Dijkstra for efficiency seems like a lot. "
                    },
                    {
                        "username": "gagandeepahuja09",
                        "content": "https://youtu.be/2RDQVW7RspM"
                    },
                    {
                        "username": "CuteTN",
                        "content": "I have to admit that the stickman \"animation\" is cute \\uD83E\\uDEE0"
                    }
                ]
            },
            {
                "id": 1846896,
                "content": [
                    {
                        "username": "V0idk",
                        "content": "Details \\nInput\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n,[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"]\\n,[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput\\n5\\nExpected\\n7"
                    },
                    {
                        "username": "realones",
                        "content": "Box also can block the player from moving"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/3138e594-ab1b-4484-834e-81467b308b0d_1673186302.3798378.png)"
                    },
                    {
                        "username": "jjliao",
                        "content": "I am quite new guy to the **LeetCode**. \\n\\nI mean no offence and I am just asking, can anyone tell me? \\n\\nIt\\'s so **hard**, I just want to skip this kind of problem if it will not be in the OA or Onsite."
                    },
                    {
                        "username": "realones",
                        "content": "I agree, but sadly we already practiced too much, and way more than what we need, and then you just realize this issue is not an issue now."
                    },
                    {
                        "username": "czjnbb",
                        "content": "So the key point is that if you want to bush a box to a neighbor grid, that grid and the grid on the opposite direction should be both '.', and also the grid on the opposite direction should be reachable by the player. \n\nA nested BFS would work perfectly."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The thing I'm \"stuck\" on is pushing the box alters the potential paths, so do I need to recaluculate the routes the person can take every time? Thats a full BFS per push and that seems pretty unreasonable, and even things like Dijkstra for efficiency seems like a lot. "
                    },
                    {
                        "username": "gagandeepahuja09",
                        "content": "https://youtu.be/2RDQVW7RspM"
                    },
                    {
                        "username": "CuteTN",
                        "content": "I have to admit that the stickman \"animation\" is cute \\uD83E\\uDEE0"
                    }
                ]
            },
            {
                "id": 1573303,
                "content": [
                    {
                        "username": "V0idk",
                        "content": "Details \\nInput\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n,[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"]\\n,[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput\\n5\\nExpected\\n7"
                    },
                    {
                        "username": "realones",
                        "content": "Box also can block the player from moving"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/3138e594-ab1b-4484-834e-81467b308b0d_1673186302.3798378.png)"
                    },
                    {
                        "username": "jjliao",
                        "content": "I am quite new guy to the **LeetCode**. \\n\\nI mean no offence and I am just asking, can anyone tell me? \\n\\nIt\\'s so **hard**, I just want to skip this kind of problem if it will not be in the OA or Onsite."
                    },
                    {
                        "username": "realones",
                        "content": "I agree, but sadly we already practiced too much, and way more than what we need, and then you just realize this issue is not an issue now."
                    },
                    {
                        "username": "czjnbb",
                        "content": "So the key point is that if you want to bush a box to a neighbor grid, that grid and the grid on the opposite direction should be both '.', and also the grid on the opposite direction should be reachable by the player. \n\nA nested BFS would work perfectly."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The thing I'm \"stuck\" on is pushing the box alters the potential paths, so do I need to recaluculate the routes the person can take every time? Thats a full BFS per push and that seems pretty unreasonable, and even things like Dijkstra for efficiency seems like a lot. "
                    },
                    {
                        "username": "gagandeepahuja09",
                        "content": "https://youtu.be/2RDQVW7RspM"
                    },
                    {
                        "username": "CuteTN",
                        "content": "I have to admit that the stickman \"animation\" is cute \\uD83E\\uDEE0"
                    }
                ]
            },
            {
                "id": 2039815,
                "content": [
                    {
                        "username": "V0idk",
                        "content": "Details \\nInput\\n[[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]\\n,[\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"]\\n,[\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"]\\n,[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\nOutput\\n5\\nExpected\\n7"
                    },
                    {
                        "username": "realones",
                        "content": "Box also can block the player from moving"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/3138e594-ab1b-4484-834e-81467b308b0d_1673186302.3798378.png)"
                    },
                    {
                        "username": "jjliao",
                        "content": "I am quite new guy to the **LeetCode**. \\n\\nI mean no offence and I am just asking, can anyone tell me? \\n\\nIt\\'s so **hard**, I just want to skip this kind of problem if it will not be in the OA or Onsite."
                    },
                    {
                        "username": "realones",
                        "content": "I agree, but sadly we already practiced too much, and way more than what we need, and then you just realize this issue is not an issue now."
                    },
                    {
                        "username": "czjnbb",
                        "content": "So the key point is that if you want to bush a box to a neighbor grid, that grid and the grid on the opposite direction should be both '.', and also the grid on the opposite direction should be reachable by the player. \n\nA nested BFS would work perfectly."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The thing I'm \"stuck\" on is pushing the box alters the potential paths, so do I need to recaluculate the routes the person can take every time? Thats a full BFS per push and that seems pretty unreasonable, and even things like Dijkstra for efficiency seems like a lot. "
                    },
                    {
                        "username": "gagandeepahuja09",
                        "content": "https://youtu.be/2RDQVW7RspM"
                    },
                    {
                        "username": "CuteTN",
                        "content": "I have to admit that the stickman \"animation\" is cute \\uD83E\\uDEE0"
                    }
                ]
            }
        ]
    },
    {
        "title": "Page Recommendations",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576742,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1827604,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1576831,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1574906,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1574500,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1826882,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            },
            {
                "id": 1683261,
                "content": [
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect distinct b.page_id as recommended_page \\nfrom Friendship a\\ninner join likes b\\non a.user1_id = b.user_id or a.user2_id = b.user_id\\nwhere (a.user1_id = 1 or a.user2_id = 1) and b.page_id not in (select page_id from likes where user_id = 1)\\n\\n2)\\nselect distinct page_id as recommended_page\\nfrom Likes\\nwhere user_id in\\n(\\nselect user1_id as user_id\\nfrom Friendship\\nwhere user2_id=1\\nunion\\nselect user2_id as user_id\\nfrom Friendship\\nwhere user1_id=1\\n)\\nand page_id not in (select page_id from Likes where user_id = 1)\\n\\n3)\\nwith cte as\\n(select user1_id as id, user2_id as friend from Friendship\\nunion\\nselect user2_id as id, user1_id as friend from Friendship)\\n\\nselect distinct b.page_id as recommended_page\\nfrom cte a\\njoin likes b\\non a.friend = b.user_id\\nwhere a.id = 1\\nexcept \\nselect page_id from likes where user_id = 1"
                    },
                    {
                        "username": "ftfugew36472",
                        "content": "WHY MY CODE IS FAILING TEST CASE  `select DISTINCT page_id AS recommended_page from likes where user_id in (\\nselect user1_id from \\nFriendship where user2_id=1\\nunion\\nselect user2_id from \\nFriendship where user1_id=1\\n)\\nand page_id!=(select page_id from Likes where user_id=1)`"
                    },
                    {
                        "username": "rockthy",
                        "content": "\\'\\'\\'with a as(\\nselect distinct page_id \\nfrom Friendship f\\njoin Likes l\\non f.user2_id = l.user_id or f.user1_id = l.user_id\\nwhere user1_id = 1 or user2_id = 1\\n)\\nselect page_id as recommended_page\\nfrom a\\nwhere page_id not in \\n(select page_id from Likes where user_id = 1 )\\'\\'\\'"
                    },
                    {
                        "username": "SuperRenee",
                        "content": "with table1 as (\\nselect user2_id as users from Friendship where user1_id=1\\nunion \\nselect user1_id as users from Friendship where user2_id=1\\n    )\\n    \\nselect distinct l.page_id as recommended_page\\nfrom table1 t left join Likes l on t.users=l.user_id\\nwhere l.page_id not in (select page_id from Likes where user_id=1)"
                    },
                    {
                        "username": "nechopra",
                        "content": "/* Write your T-SQL query statement below */\\nselect  page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user2_id = l.user_id\\nand f.user1_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\nunion \\n\\n\\nselect page_id as recommended_page\\nfrom Friendship f inner join Likes l\\non f.user1_id = l.user_id\\nand f.user2_id = 1\\nwhere page_id not in (select page_id from Likes where Likes.user_id = 1)\\n\\n"
                    },
                    {
                        "username": "ylivy",
                        "content": "Hi, can someone help me on this?\\n\\n1) the case was accepted for the first test case but was \\n2) tested wrong in test case 2 as my result returns null and the expected answer is blank\\n\\nThanks in advance!\\n\\n\\n# Step 1 distinct_users\\nWITH users AS(\\nSELECT DISTINCT user1_id as user_id\\nFROM Friendship\\nUNION\\nSELECT DISTINCT user2_id as user_id\\nFROM Friendship\\n),\\n\\n# Step 2 relationship\\nrelationship AS(\\nSELECT user_id,user2_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user1_id\\nUNION\\nSELECT user_id,user1_id friend\\nFROM users u\\nLEFT JOIN Friendship f\\nON u.user_id=f.user2_id\\n),\\n\\n#Step 3 list down all user\\'s friend page_id\\nfriends_like AS( \\nSELECT r.user_id user_id, friend, l.user_id friend_user_id, page_id\\nFROM relationship r\\nLEFT JOIN Likes l\\nON r.friend=l.user_id\\n)\\n\\n# Step 4 filter for user_id=1\\nSELECT DISTINCT(page_id) recommended_page\\nFROM friends_like\\nWHERE user_id=1 \\nAND page_id NOT IN(SELECT page_id\\n                        FROM Likes\\n                        WHERE user_id=1)"
                    },
                    {
                        "username": "yj92",
                        "content": "does anybody know why this doesn\\'t work: \\nwith ff as (\\nselect user1_id as u1id, user2_id as u2id from friendship\\nunion\\nselect user2_id as u1id, user1_id as u2id from friendship\\n)\\n\\nselect\\ndistpage_id as recommended_page\\nfrom ff as f\\ninner join \\n(select * from likes where page_id not in (select page_id from likes where user_id = 1))\\nas l\\non l.user_id = f.u2id\\nwhere u1id = 1\\norder by 1 asc"
                    }
                ]
            }
        ]
    },
    {
        "title": "Print Immutable Linked List in Reverse",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566964,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1573206,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1574350,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1568246,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1570622,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 2037631,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1941368,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1894158,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1863272,
                "content": [
                    {
                        "username": "Chenger123",
                        "content": "Given: recursion callstack is O(n) memory \\nHow would you do this? at first glance it seems impossible.\\n\\n"
                    },
                    {
                        "username": "mhelvens",
                        "content": "Solutions posted so far are the simple ones with both _O(n)_ time complexity and _O(n)_ space complexity, whether they be recursive or iterative.\\n\\nThe first followup challenge of _O(1)_ space complexity is simple as well, if you go with _O(n\\xB2)_ time complexity.\\n\\nBut I\\'m curious about the final followup challenge. Is it possible to achieve _O(n)_ time complexity with _less than O(n)_ space complexity? I\\'m real tempted to say _no_, but I don\\'t exactly have a formal proof for that, and these problems don\\'t usually ask \"Can you do X\", intending for the answer to be \"no\".\\n\\n(PS: Note that getting 100% time and 100% space means very little here. We\\'re talking about asymptotic complexity. Besides, these problem constraints are very strong and LeetCode\\'s measurements are imprecise and inconsistent.)"
                    },
                    {
                        "username": "andy_hujian",
                        "content": "When leetcode asks for O(1) space complexity, does it mean we can\\'t even use recursion? Recursion has O(n) space used by calling stack."
                    },
                    {
                        "username": "vjuiliu",
                        "content": "I solved it in Java. When running in C#, I got this compile time error:\\n\\nLine 11: Char 17: error CS0051: Inconsistent accessibility: parameter type \\'ImmutableListNode\\' is less accessible than method \\'Solution.PrintLinkedListInReverse(ImmutableListNode)\\' (in Solution.cs)\\n"
                    },
                    {
                        "username": "parttimetyper",
                        "content": "Am I missing something? There does not seem to be much complexity and there are numerous solutions where we cache the values of the linkedlist using stacks, arraylists. Most medium problems usually have some intuitive concept to grasp before revealing itself. What is the catch here?"
                    },
                    {
                        "username": "eljoshi",
                        "content": "This should be an easy, in all honesty. I\\'ve seen some easy problems with more edge cases."
                    },
                    {
                        "username": "danek1313",
                        "content": "Trying to implement this in TypeScript and I\\'m massively confused. If I try calling node.printValue() and assigning that to a variable or array value, I get \"error TS2345: Argument of type \\'void\\' is not assignable to parameter of type \\'never\\'.\" How do I get the value?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should specify what happens when calling getNext() on the last node in a linked list. Yes, usually this returns null, but that\\'s only the typical, defined behaviour, not required. Maybe it returns -1, or the string \"hey buddy, this is the end of the road\". Despite what the problem claims, we *must* speculate on its implementation"
                    },
                    {
                        "username": "nodarius",
                        "content": "How do I check the end of the list in Go? Since it does not return a pointer, I can\\'t compare to nil\\n\\n```   \\nfunc (this *ImmutableListNode) getNext() ImmutableListNode {\\n \\t\\t// return the next node.\\n}\\n```\\n"
                    }
                ]
            }
        ]
    }
]