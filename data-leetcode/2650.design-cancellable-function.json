[
    {
        "title": "Design Cancellable Function",
        "question_content": "Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&nbsp;cancellable that accepts a generator object and returns an array of two values: a cancel function and a promise.\nYou may assume the generator function will only&nbsp;yield promises. It is your function's responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&nbsp;error back to the generator.\nIf the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&nbsp;\"Cancelled\"&nbsp;(Not an Error&nbsp;object). If the error was caught, the returned&nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.\nWhen the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.\nAn example of how your code would be used:\n\nfunction* tasks() {\n  const val = yield new Promise(resolve => resolve(2 + 2));\n  yield new Promise(resolve => setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn't be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs \"Cancelled\" at t=50ms\n\nIf&nbsp;instead&nbsp;cancel() was not called or was called after t=100ms, the promise would&nbsp;have resolved&nbsp;5.\n&nbsp;\nExample 1:\n\nInput: \ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\nOutput: {\"resolved\": 42}\nExplanation:\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // resolves 42 at t=0ms\nThe generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.\n\nExample 2:\n\nInput:\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res => res(\"Hello\")); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\nOutput: {\"rejected\": \"Error: Hello\"}\nExplanation:\nA promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.\n\nExample 3:\n\nInput: \ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res => setTimeout(res, 200)); \n&nbsp; return \"Success\"; \n}\ncancelledAt = 100\nOutput: {\"rejected\": \"Cancelled\"}\nExplanation:\nWhile the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.\n\nExample 4:\n\nInput:\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res => setTimeout(res, 100));\n&nbsp; result += yield new Promise(res => res(1)); \n&nbsp; yield new Promise(res => setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res => res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\nOutput: {\"resolved\": 2}\nExplanation:\n4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.\n\nExample 5:\n\nInput: \ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res => setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res => res(1)); \n&nbsp;   yield new Promise(res => setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res => res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\nOutput: {\"resolved\": 1}\nExplanation:\nThe first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.\n\nExample 6:\n\nInput: \ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) => reject(\"Promise Rejected\")); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve => resolve(2));\n    let b = yield new Promise(resolve => resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\nOutput: {\"resolved\": 4}\nExplanation:\nThe first yielded promise immediately rejects. This error is caught. Because the generator hasn't been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.\n&nbsp;\nConstraints:\n\n\tcancelledAt == null or 0 <= cancelledAt <= 1000\n\tgeneratorFunction returns a generator object",
        "solutions": [
            {
                "id": 3440923,
                "title": "simple-solution-with-async-and-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443563,
                "title": "javascript-typescript-simple-solution-with-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBased on the given code snippet, the `cancellable` function seems to wrap a generator function in a way that allows it to be cancelled using a returned function. The generator function is executed asynchronously using promises and `await`, and the cancellation is implemented by rejecting a cancellation promise that is created inside the `cancellable` function.\\n\\nTo solve this problem, one could start by understanding how generators work in JavaScript/TypeScript and how to use the `Generator` type. Then, one could analyze the given code snippet and try to understand how it works, and what are the roles of the `cancel` function and the `cancelPromise`. Finally, one could try to replicate the same functionality in a different way or extend the existing code to fit a specific use case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngeneral approach that one use to solve a problem:\\n\\n1. Understand the problem: Read and analyze the problem statement, requirements, and constraints. Ensure that you understand the problem\\'s scope, expected output, and any input constraints.\\n\\n2. Research: Look for relevant information, algorithms, libraries, and tools that could help solve the problem. Check for any existing solutions, and learn from their approaches.\\n\\n3. Plan and design: Based on your understanding of the problem and the available resources, plan your approach and design your solution. Break down the problem into smaller sub-problems and identify the key components and functions that you need.\\n\\n4. Implement: Start implementing your solution in code. Follow best practices, write clean, modular, and maintainable code. Test your code frequently and make adjustments as needed.\\n\\n5. Test and validate: Test your code thoroughly, both manually and using automated tests. Validate your code\\'s output against the problem requirements and ensure that it meets the expected results.\\n\\n6. Optimize and improve: Once you have a working solution, look for ways to optimize and improve it. Consider factors such as performance, scalability, security, and usability.\\n\\n7. Document and share: Document your code, including its purpose, usage, and any dependencies. Share your code with others, and contribute to the community by sharing your insights, solutions, and experiences.\\n# Complexity\\nThe time and space complexity of the `cancellable` function depend on the implementation details and the behavior of the generator function passed as a parameter. However, we can analyze the time and space complexity of the `cancellable` function itself:\\n- Time complexity: The `cancellable` function creates a new promise and uses the `Promise.race` method to race between the generator\\'s next value and the cancellation promise. The `Promise.race` method has a time complexity of O(n), where n is the number of promises passed as arguments. The generator function is executed synchronously until it reaches the first `yield` statement, so its time complexity depends on its implementation. Therefore, the time complexity of the `cancellable` function is at least O(1) and at most O(n), where n is the number of promises involved in the race.\\n\\n- Space complexity: The `cancellable` function creates two promises: the cancellation promise and the promise returned by the async function. It also creates a `cancel` function and a `next` variable used to iterate over the generator function. The space complexity of the `cancellable` function is therefore O(1), as the amount of memory used by the function does not depend on the input size. However, the space complexity of the generator function may be higher, depending on its implementation and the amount of data it processes.\\n\\n```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```\\n```TypeScript []\\nconst cancellable = <T>(generator: Generator): [() => void, Promise<T>] => {\\n  let cancel: () => void;\\n  const cancelPromise = new Promise<never>((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async (): Promise<T> => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564498,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608553,
                "title": "design-cancellable-function-compact-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442426,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445591,
                "title": "a-support-request-to-leetcode",
                "content": "# To Leetcode team\\n\\nHi, so I have a solution that has a bug which manages to pass all the given testcases in the description. However, when I submit it as a solution, it fails and the evaluator says 0 testcases passed. This is not true because if I add logs I can see that most testcases are passing. There seems to be some error in figuring out which testcases are failing for this kind of question. If you have someone available can you look at why that happens with this submission:\\n\\nThing to check:\\n1. Paste this submission\\n2. Run button says all 7 testcases passed\\n3. Submit and the evaluator will say 0 testcases passed\\n\\nNote that I know where the bug is and how to fix it. I have already submitted another solution which fixes the problem. However, I was troubled by the evaluator reporting 0 cases passing. Note also that yo can return the function that is getting assigned to `cancellable` from inside an IIFE to ensure even more isolation but the problem stays.\\n\\n```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\\n\\n# Actual solution that works\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440819,
                "title": "design-cancellable-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025306,
                "title": "recursive-solution-and-easy-to-understand",
                "content": "# Intuition\\n1. Ready the doc of Generator before you start to read or write the code:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\\n2. Fully underatand how Promise works is the required skill\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951692,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Code\\n```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847351,
                "title": "posted-my-first-solution-on-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742714,
                "title": "recursive-solution-without-using-async-await",
                "content": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3672778,
                "title": "faster-and-easier-solution-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother quick and simple solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632981,
                "title": "brief-explanation-in-typescript-using-try-catch-syntax",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`genCall` is a function which calls the next yielding element and if it is not done yielding it keeps calling itself in turns to the point of resolution.\\nSame functionality is needed when we throw something to generator which is handled by explicitThrow param which is by default false.\\nwhile cancelling we simply call `genCall( \"Cancelled\",true);` that handles the rest for us.\\n\\nNote within `genCall` there are two try catch blocks, first one simply rejects as, if there is some error that is now handled and happens during generator function execution it should be rejected. While in the second one we are seeking if there is some error thrown from the promise that is returned in that case we simply chain that value to next call. \\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622155,
                "title": "using-recursion",
                "content": "# Intuition\\nSolution using recursion\\n\\n\\n# Code\\n```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606837,
                "title": "efficient-cancellable-promises-in-typescript-achieving-control-and-flexibility-in-asynchronous",
                "content": "# Intuition\\nThe code is implementing a cancellable promise in JavaScript. It makes use of generators and promises to achieve this. The `cancellable` function takes a generator as an argument. This generator is expected to yield promises. The `cancellable` function returns a pair consisting of a cancel function and a promise. When the cancel function is called, the promise gets rejected with the reason \\'Cancelled\\'.\\n\\n# Approach\\nThe `cancellable` function starts by initializing some variables. It then creates a promise which will be returned and used for the computation. This promise is handled by an `async` function which is immediately invoked. This function calls `next` on the generator and enters a loop. Inside the loop, it waits for the promise yielded by the generator to be fulfilled or for the cancel promise to be fulfilled, whichever happens first. If the cancel promise is fulfilled, an error is thrown which is caught and rethrown to the generator. The loop continues until the generator is done.\\n\\nIf the cancel function is called, it rejects the cancel promise, which causes the promise race to resolve with an error. This error is then propagated through the generator, causing the computation to be cancelled.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where n is the number of promises yielded by the generator. This is because we\\'re going through each yielded promise one by one.\\n- Space complexity: The space complexity is O(1), as we\\'re only using a constant amount of space. No matter the number of promises yielded by the generator, we\\'re only storing a constant amount of variables.\\n\\n# Code\\n\\n```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877960,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1886735,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1941911,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            }
        ]
    }
]